commit 4b80e2917ced9ba24aa72b9b1fa130aedcc5dbad
Author: Bradley Nicholes <bnicholes@apache.org>
Date:   Thu Aug 19 18:08:19 2004 +0000

    Clean up some compiler warnings
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@104727 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/modules/aaa/mod_authnz_ldap.c b/modules/aaa/mod_authnz_ldap.c
index e293cb6..88b7da3 100644
--- a/modules/aaa/mod_authnz_ldap.c
+++ b/modules/aaa/mod_authnz_ldap.c
@@ -64,8 +64,6 @@ typedef struct {
     char *binddn;                   /* DN to bind to server (can be NULL) */
     char *bindpw;                   /* Password to bind to server (can be NULL) */
 
-/*    int frontpage_hack;             /* Hack for frontpage support */
-
     int user_is_dn;                 /* If true, connection->user is DN instead of userid */
     int compare_dn_on_server;       /* If true, will use server to do DN compare */
 
@@ -165,7 +163,7 @@ static apr_xlate_t* get_conv_set (request_rec *r)
  * search filter will be (&(posixid=*)(uid=userj)).
  */
 #define FILTER_LENGTH MAX_STRING_LEN
-void authn_ldap_build_filter(char *filtbuf, 
+static void authn_ldap_build_filter(char *filtbuf, 
                              request_rec *r,
                              const char* sent_user,
                              authn_ldap_config_t *sec)
@@ -424,7 +422,7 @@ start_over:
  *                              LDAP tree to be let in.
  *
  */
-int authz_ldap_check_user_access(request_rec *r)
+static int authz_ldap_check_user_access(request_rec *r)
 {
     int result = 0;
     authn_ldap_request_t *req =
@@ -502,35 +500,6 @@ int authz_ldap_check_user_access(request_rec *r)
         t = reqs[x].requirement;
         w = ap_getword_white(r->pool, &t);
     
-/*
-        if (strcmp(w, "valid-user") == 0) {
-            /*
-             * Valid user will always be true if we authenticated with ldap,
-             * but when using front page, valid user should only be true if
-             * he exists in the frontpage password file. This hack will get
-             * auth_ldap to look up the user in the the pw file to really be
-             * sure that he's valid. Naturally, it requires mod_auth to be
-             * compiled in, but if mod_auth wasn't in there, then the need
-             * for this hack wouldn't exist anyway.
-             */
-/*
-            if (sec->frontpage_hack) {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r, 
-                      "[%d] auth_ldap authorise: "
-                      "deferring authorisation to mod_auth (FP Hack)", 
-                      getpid());
-                return OK;
-            }
-            else {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r, 
-                              "[%d] auth_ldap authorise: "
-                              "successful authorisation because user "
-                              "is valid-user", getpid());
-                return OK;
-            }
-        }
-        else 
-*/
         if (strcmp(w, "ldap-user") == 0) {
             if (req->dn == NULL || strlen(req->dn) == 0) {
                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r,
@@ -900,10 +869,6 @@ static const command_rec authnz_ldap_cmds[] =
     AP_INIT_FLAG("AuthLDAPAuthzEnabled", ap_set_flag_slot,
                  (void *)APR_OFFSETOF(authn_ldap_config_t, authz_enabled), OR_AUTHCFG,
                  "Set to off to disable the LDAP authorization handler, even if it's been enabled in a higher tree"),
- 
-    AP_INIT_FLAG("AuthLDAPFrontPageHack", ap_set_flag_slot,
-                 (void *)APR_OFFSETOF(authn_ldap_config_t, frontpage_hack), OR_AUTHCFG,
-                 "Set to 'on' to support Microsoft FrontPage"),
 */
 
     AP_INIT_TAKE1("AuthLDAPCharsetConfig", set_charset_config, NULL, RSRC_CONF,
diff --git a/modules/ldap/util_ldap.c b/modules/ldap/util_ldap.c
index 7b58cb9..5c62696 100644
--- a/modules/ldap/util_ldap.c
+++ b/modules/ldap/util_ldap.c
@@ -239,9 +239,6 @@ LDAP_DECLARE(int) util_ldap_connection_open(request_rec *r,
     int failures = 0;
     int version  = LDAP_VERSION3;
 
-    util_ldap_state_t *st = (util_ldap_state_t *)ap_get_module_config(
-                                r->server->module_config, &ldap_module);
-
     /* If the connection is already bound, return
     */
     if (ldc->bound)
@@ -255,12 +252,9 @@ LDAP_DECLARE(int) util_ldap_connection_open(request_rec *r,
     if (NULL == ldc->ldap)
     {
         apr_ldap_err_t *result = NULL;
-        int rc = apr_ldap_init(r->pool,
-                               &(ldc->ldap),
-                               ldc->host,
-                               ldc->port,
-                               ldc->secure,
-                               &(result));
+
+        apr_ldap_init(r->pool, &(ldc->ldap), ldc->host, ldc->port,
+                      ldc->secure, &(result));
 
         if (result != NULL) {
             ldc->reason = result->reason;
@@ -1132,7 +1126,6 @@ static apr_status_t util_ldap_cleanup_module(void *data)
 static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog, 
                                  apr_pool_t *ptemp, server_rec *s)
 {
-    int rc = LDAP_SUCCESS;
     apr_status_t result;
     char buf[MAX_STRING_LEN];
     server_rec *s_vhost;
