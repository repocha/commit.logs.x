commit 273b7aac7750c415d8981e8fa5f1ce3ba55d787a
Author: Stefan Fritsch <sf@apache.org>
Date:   Fri Dec 2 23:02:04 2011 +0000

    Add lots of unique tags to error log messages
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1209766 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/docs/log-message-tags/next-number b/docs/log-message-tags/next-number
index d00491f..d1003cf 100644
--- a/docs/log-message-tags/next-number
+++ b/docs/log-message-tags/next-number
@@ -1 +1 @@
-1
+2183
diff --git a/modules/aaa/mod_access_compat.c b/modules/aaa/mod_access_compat.c
index e3cc74f..59122a9 100644
--- a/modules/aaa/mod_access_compat.c
+++ b/modules/aaa/mod_access_compat.c
@@ -350,7 +350,7 @@ static int check_dir_access(request_rec *r)
     }
 
     if (ret == HTTP_FORBIDDEN) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01797)
                       "client denied by server configuration: %s%s",
                       r->filename ? "" : "uri ",
                       r->filename ? r->filename : r->uri);
diff --git a/modules/aaa/mod_allowmethods.c b/modules/aaa/mod_allowmethods.c
index e586a1c..43ba176 100644
--- a/modules/aaa/mod_allowmethods.c
+++ b/modules/aaa/mod_allowmethods.c
@@ -67,7 +67,7 @@ static int am_check_access(request_rec *r)
     return DECLINED;
   }
 
-  ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+  ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01623)
                   "client method denied by server configuration: '%s' to %s%s",
                   r->method,
                   r->filename ? "" : "uri ",
diff --git a/modules/aaa/mod_auth_basic.c b/modules/aaa/mod_auth_basic.c
index ae75378..cadeb5b 100644
--- a/modules/aaa/mod_auth_basic.c
+++ b/modules/aaa/mod_auth_basic.c
@@ -155,7 +155,7 @@ static int get_basic_auth(request_rec *r, const char **user,
 
     if (strcasecmp(ap_getword(r->pool, &auth_line, ' '), "Basic")) {
         /* Client tried to authenticate using wrong auth scheme */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01614)
                       "client used wrong authentication scheme: %s", r->uri);
         note_basic_auth_failure(r);
         return HTTP_UNAUTHORIZED;
@@ -201,7 +201,7 @@ static int authenticate_basic_user(request_rec *r)
     /* We need an authentication realm. */
     if (!ap_auth_name(r)) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR,
-                      0, r, "need AuthName: %s", r->uri);
+                      0, r, APLOGNO(01615) "need AuthName: %s", r->uri);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
@@ -225,7 +225,7 @@ static int authenticate_basic_user(request_rec *r)
                                           AUTHN_PROVIDER_VERSION);
 
             if (!provider || !provider->check_password) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01616)
                               "No Authn provider configured");
                 auth_result = AUTH_GENERAL_ERROR;
                 break;
@@ -265,14 +265,14 @@ static int authenticate_basic_user(request_rec *r)
 
         switch (auth_result) {
         case AUTH_DENIED:
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01617)
                       "user %s: authentication failure for \"%s\": "
                       "Password Mismatch",
                       sent_user, r->uri);
             return_code = HTTP_UNAUTHORIZED;
             break;
         case AUTH_USER_NOT_FOUND:
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01618)
                       "user %s not found: %s", sent_user, r->uri);
             return_code = HTTP_UNAUTHORIZED;
             break;
diff --git a/modules/aaa/mod_auth_digest.c b/modules/aaa/mod_auth_digest.c
index 77240b6..460619b 100644
--- a/modules/aaa/mod_auth_digest.c
+++ b/modules/aaa/mod_auth_digest.c
@@ -200,7 +200,7 @@ module AP_MODULE_DECLARE_DATA auth_digest_module;
 
 static apr_status_t cleanup_tables(void *not_used)
 {
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL, APLOGNO(01756)
                   "cleaning up shared memory");
 
     if (client_rmm) {
@@ -230,7 +230,7 @@ static apr_status_t initialize_secret(server_rec *s)
 {
     apr_status_t status;
 
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s, APLOGNO(01757)
                  "generating secret for digest authentication ...");
 
 #if APR_HAS_RANDOM
@@ -241,20 +241,20 @@ static apr_status_t initialize_secret(server_rec *s)
 
     if (status != APR_SUCCESS) {
         char buf[120];
-        ap_log_error(APLOG_MARK, APLOG_CRIT, status, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, status, s, APLOGNO(01758)
                      "error generating secret: %s",
                      apr_strerror(status, buf, sizeof(buf)));
         return status;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "done");
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01759) "done");
 
     return APR_SUCCESS;
 }
 
 static void log_error_and_cleanup(char *msg, apr_status_t sts, server_rec *s)
 {
-    ap_log_error(APLOG_MARK, APLOG_ERR, sts, s,
+    ap_log_error(APLOG_MARK, APLOG_ERR, sts, s, APLOGNO(01760)
                  "%s - all nonce-count checking, one-time nonces, and "
                  "MD5-sess algorithm disabled", msg);
 
@@ -273,7 +273,7 @@ static int initialize_tables(server_rec *s, apr_pool_t *ctx)
 
     sts = apr_temp_dir_get(&tempdir, ctx);
     if (APR_SUCCESS != sts) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s, APLOGNO(01761)
                      "Failed to find temporary directory");
         log_error_and_cleanup("failed to find temp dir", sts, s);
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -292,7 +292,7 @@ static int initialize_tables(server_rec *s, apr_pool_t *ctx)
     sts = apr_shm_create(&client_shm, shmem_size,
                         client_shm_filename, ctx);
     if (APR_SUCCESS != sts) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s, APLOGNO(01762)
                      "Failed to create shared memory segment on file %s",
                      client_shm_filename);
         log_error_and_cleanup("failed to initialize shm", sts, s);
@@ -671,7 +671,7 @@ static const char *set_shmem_size(cmd_parms *cmd, void *config,
     if (num_buckets == 0) {
         num_buckets = 1;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01763)
                  "Set shmem-size: %" APR_SIZE_T_FMT ", num-buckets: %ld",
                  shmem_size, num_buckets);
 
@@ -785,11 +785,11 @@ static client_entry *get_client(unsigned long key, const request_rec *r)
     apr_global_mutex_unlock(client_lock);
 
     if (entry) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01764)
                       "get_client(): client %lu found", key);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01765)
                       "get_client(): client %lu not found", key);
     }
 
@@ -860,7 +860,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
     entry = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(client_entry)));
     if (!entry) {
         long num_removed = gc();
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01766)
                      "gc'd %ld client entries. Total new clients: "
                      "%ld; Total removed clients: %ld; Total renewed clients: "
                      "%ld", num_removed,
@@ -868,7 +868,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
                      client_list->num_removed, client_list->num_renewed);
         entry = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(client_entry)));
         if (!entry) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01767)
                          "unable to allocate new auth_digest client");
             apr_global_mutex_unlock(client_lock);
             return NULL;       /* give up */
@@ -886,7 +886,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
 
     apr_global_mutex_unlock(client_lock);
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01768)
                  "allocated new client %lu", key);
 
     return entry;
@@ -1144,7 +1144,7 @@ static client_entry *gen_client(const request_rec *r)
     apr_global_mutex_unlock(opaque_lock);
 
     if (!(entry = add_client(op, &new_entry, r->server))) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01769)
                       "failed to allocate client entry - ignoring client");
         return NULL;
     }
@@ -1416,7 +1416,7 @@ static authn_status get_hash(request_rec *r, const char *user,
                                           AUTHN_PROVIDER_VERSION);
 
             if (!provider || !provider->get_realm_hash) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01770)
                               "No Authn provider configured");
                 auth_result = AUTH_GENERAL_ERROR;
                 break;
@@ -1464,7 +1464,7 @@ static int check_nc(const request_rec *r, const digest_header_rec *resp,
 
     if (conf->check_nc && !client_shm) {
         /* Shouldn't happen, but just in case... */
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01771)
                       "cannot check nonce count without shared memory");
         return OK;
     }
@@ -1478,7 +1478,7 @@ static int check_nc(const request_rec *r, const digest_header_rec *resp,
         &&!strcasecmp(conf->qop_list[0], "none")) {
         /* qop is none, client must not send a nonce count */
         if (snc != NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01772)
                           "invalid nc %s received - no nonce count allowed when qop=none",
                           snc);
             return !OK;
@@ -1489,7 +1489,7 @@ static int check_nc(const request_rec *r, const digest_header_rec *resp,
 
     nc = strtol(snc, &endptr, 16);
     if (endptr < (snc+strlen(snc)) && !apr_isspace(*endptr)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01773)
                       "invalid nc %s received - not a number", snc);
         return !OK;
     }
@@ -1499,7 +1499,7 @@ static int check_nc(const request_rec *r, const digest_header_rec *resp,
     }
 
     if (nc != resp->client->nonce_count) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01774)
                       "Warning, possible replay attack: nonce-count "
                       "check failed: %lu != %lu", nc,
                       resp->client->nonce_count);
@@ -1517,7 +1517,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
     char tmp, hash[NONCE_HASH_LEN+1];
 
     if (strlen(resp->nonce) != NONCE_LEN) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01775)
                       "invalid nonce %s received - length is not %d",
                       resp->nonce, NONCE_LEN);
         note_digest_auth_failure(r, conf, resp, 1);
@@ -1532,7 +1532,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
     resp->nonce_time = nonce_time.time;
 
     if (strcmp(hash, resp->nonce+NONCE_TIME_LEN)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01776)
                       "invalid nonce %s received - hash is not %s",
                       resp->nonce, hash);
         note_digest_auth_failure(r, conf, resp, 1);
@@ -1541,7 +1541,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
 
     dt = r->request_time - nonce_time.time;
     if (conf->nonce_lifetime > 0 && dt < 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01777)
                       "invalid nonce %s received - user attempted "
                       "time travel", resp->nonce);
         note_digest_auth_failure(r, conf, resp, 1);
@@ -1550,7 +1550,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
 
     if (conf->nonce_lifetime > 0) {
         if (dt > conf->nonce_lifetime) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0,r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0,r, APLOGNO(01778)
                           "user %s: nonce expired (%.2f seconds old "
                           "- max lifetime %.2f) - sending new nonce",
                           r->user, (double)apr_time_sec(dt),
@@ -1561,7 +1561,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
     }
     else if (conf->nonce_lifetime == 0 && resp->client) {
         if (memcmp(resp->client->last_nonce, resp->nonce, NONCE_LEN)) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01779)
                           "user %s: one-time-nonce mismatch - sending "
                           "new nonce", r->user);
             note_digest_auth_failure(r, conf, resp, 1);
@@ -1697,7 +1697,7 @@ static int authenticate_digest_user(request_rec *r)
     }
 
     if (!ap_auth_name(r)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01780)
                       "need AuthName: %s", r->uri);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -1727,12 +1727,12 @@ static int authenticate_digest_user(request_rec *r)
 
     if (resp->auth_hdr_sts != VALID) {
         if (resp->auth_hdr_sts == NOT_DIGEST) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01781)
                           "client used wrong authentication scheme `%s': %s",
                           resp->scheme, r->uri);
         }
         else if (resp->auth_hdr_sts == INVALID) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01782)
                           "missing user, realm, nonce, uri, digest, "
                           "cnonce, or nonce_count in authorization header: %s",
                           r->uri);
@@ -1755,7 +1755,7 @@ static int authenticate_digest_user(request_rec *r)
 
         copy_uri_components(&r_uri, resp->psd_request_uri, r);
         if (apr_uri_parse(r->pool, resp->uri, &d_uri) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01783)
                           "invalid uri <%s> in Authorization header",
                           resp->uri);
             return HTTP_BAD_REQUEST;
@@ -1790,7 +1790,7 @@ static int authenticate_digest_user(request_rec *r)
             if (apr_table_get(r->subprocess_env,
                               "AuthDigestEnableQueryStringHack")) {
 
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01784)
                               "applying AuthDigestEnableQueryStringHack "
                               "to uri <%s>", resp->raw_request_uri);
 
@@ -1800,7 +1800,7 @@ static int authenticate_digest_user(request_rec *r)
 
         if (r->method_number == M_CONNECT) {
             if (!r_uri.hostinfo || strcmp(resp->uri, r_uri.hostinfo)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01785)
                               "uri mismatch - <%s> does not match "
                               "request-uri <%s>", resp->uri, r_uri.hostinfo);
                 return HTTP_BAD_REQUEST;
@@ -1828,7 +1828,7 @@ static int authenticate_digest_user(request_rec *r)
                 && (!d_uri.query || !r_uri.query
                     || strcmp(d_uri.query, r_uri.query)))
             ) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01786)
                           "uri mismatch - <%s> does not match "
                           "request-uri <%s>", resp->uri, resp->raw_request_uri);
             return HTTP_BAD_REQUEST;
@@ -1836,7 +1836,7 @@ static int authenticate_digest_user(request_rec *r)
     }
 
     if (resp->opaque && resp->opaque_num == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01787)
                       "received invalid opaque - got `%s'",
                       resp->opaque);
         note_digest_auth_failure(r, conf, resp, 0);
@@ -1844,7 +1844,7 @@ static int authenticate_digest_user(request_rec *r)
     }
 
     if (strcmp(resp->realm, conf->realm)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01788)
                       "realm mismatch - got `%s' but expected `%s'",
                       resp->realm, conf->realm);
         note_digest_auth_failure(r, conf, resp, 0);
@@ -1854,7 +1854,7 @@ static int authenticate_digest_user(request_rec *r)
     if (resp->algorithm != NULL
         && strcasecmp(resp->algorithm, "MD5")
         && strcasecmp(resp->algorithm, "MD5-sess")) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01789)
                       "unknown algorithm `%s' received: %s",
                       resp->algorithm, r->uri);
         note_digest_auth_failure(r, conf, resp, 0);
@@ -1864,7 +1864,7 @@ static int authenticate_digest_user(request_rec *r)
     return_code = get_hash(r, r->user, conf);
 
     if (return_code == AUTH_USER_NOT_FOUND) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01790)
                       "user `%s' in realm `%s' not found: %s",
                       r->user, conf->realm, r->uri);
         note_digest_auth_failure(r, conf, resp, 0);
@@ -1875,7 +1875,7 @@ static int authenticate_digest_user(request_rec *r)
     }
     else if (return_code == AUTH_DENIED) {
         /* authentication denied in the provider before attempting a match */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01791)
                       "user `%s' in realm `%s' denied by provider: %s",
                       r->user, conf->realm, r->uri);
         note_digest_auth_failure(r, conf, resp, 0);
@@ -1892,7 +1892,7 @@ static int authenticate_digest_user(request_rec *r)
     if (resp->message_qop == NULL) {
         /* old (rfc-2069) style digest */
         if (strcmp(resp->digest, old_digest(r, resp, conf->ha1))) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01792)
                           "user %s: password mismatch: %s", r->user,
                           r->uri);
             note_digest_auth_failure(r, conf, resp, 0);
@@ -1912,7 +1912,7 @@ static int authenticate_digest_user(request_rec *r)
         if (!match
             && !(conf->qop_list[0] == NULL
                  && !strcasecmp(resp->message_qop, "auth"))) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01793)
                           "invalid qop `%s' received: %s",
                           resp->message_qop, r->uri);
             note_digest_auth_failure(r, conf, resp, 0);
@@ -1925,7 +1925,7 @@ static int authenticate_digest_user(request_rec *r)
             return HTTP_INTERNAL_SERVER_ERROR;
         }
         if (strcmp(resp->digest, exp_digest)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01794)
                           "user %s: password mismatch: %s", r->user,
                           r->uri);
             note_digest_auth_failure(r, conf, resp, 0);
@@ -2005,7 +2005,7 @@ static int add_auth_info(request_rec *r)
         if (resp->algorithm && !strcasecmp(resp->algorithm, "MD5-sess")) {
             ha1 = get_session_HA1(r, resp, conf, 0);
             if (!ha1) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01795)
                               "internal error: couldn't find session "
                               "info for user %s", resp->username);
                 return !OK;
diff --git a/modules/aaa/mod_auth_form.c b/modules/aaa/mod_auth_form.c
index f7b5b08..9cdaed0 100644
--- a/modules/aaa/mod_auth_form.c
+++ b/modules/aaa/mod_auth_form.c
@@ -742,7 +742,7 @@ static int check_authn(request_rec * r, const char *sent_user, const char *sent_
                                           AUTHN_PROVIDER_VERSION);
 
             if (!provider || !provider->check_password) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01806)
                               "no authn provider configured");
                 auth_result = AUTH_GENERAL_ERROR;
                 break;
@@ -786,14 +786,14 @@ static int check_authn(request_rec * r, const char *sent_user, const char *sent_
 
         switch (auth_result) {
         case AUTH_DENIED:
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01807)
                           "user '%s': authentication failure for \"%s\": "
                           "password Mismatch",
                           sent_user, r->uri);
             return_code = HTTP_UNAUTHORIZED;
             break;
         case AUTH_USER_NOT_FOUND:
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01808)
                           "user '%s' not found: %s", sent_user, r->uri);
             return_code = HTTP_UNAUTHORIZED;
             break;
@@ -868,7 +868,7 @@ static int authenticate_form_authn(request_rec * r)
      */
     if (PROXYREQ_PROXY == r->proxyreq) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR,
-                      0, r, "form auth cannot be used for proxy "
+                      0, r, APLOGNO(01809) "form auth cannot be used for proxy "
                       "requests due to XSS risk, access denied: %s", r->uri);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -876,7 +876,7 @@ static int authenticate_form_authn(request_rec * r)
     /* We need an authentication realm. */
     if (!ap_auth_name(r)) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR,
-                      0, r, "need AuthName: %s", r->uri);
+                      0, r, APLOGNO(01810) "need AuthName: %s", r->uri);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
@@ -1068,7 +1068,7 @@ static int authenticate_form_login_handler(request_rec * r)
     }
 
     if (r->method_number != M_POST) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01811)
           "the " FORM_LOGIN_HANDLER " only supports the POST method for %s",
                       r->uri);
         return HTTP_METHOD_NOT_ALLOWED;
@@ -1170,7 +1170,7 @@ static int authenticate_form_redirect_handler(request_rec * r)
 
     if (r->kept_body && sent_method && sent_mimetype) {
 
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01812)
           "internal redirect to method '%s' and body mimetype '%s' for the "
                       "uri: %s", sent_method, sent_mimetype, r->uri);
 
@@ -1179,7 +1179,7 @@ static int authenticate_form_redirect_handler(request_rec * r)
 
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01813)
         "internal redirect requested but one or all of method, mimetype or "
                       "body are NULL: %s", r->uri);
         return HTTP_INTERNAL_SERVER_ERROR;
diff --git a/modules/aaa/mod_authn_anon.c b/modules/aaa/mod_authn_anon.c
index fc47619..21e0da8 100644
--- a/modules/aaa/mod_authn_anon.c
+++ b/modules/aaa/mod_authn_anon.c
@@ -179,7 +179,7 @@ static authn_status check_anonymous(request_rec *r, const char *user,
             || (ap_strchr_c(sent_pw, '@') && ap_strchr_c(sent_pw, '.'))))
     {
         if (conf->logemail && ap_is_initial_req(r)) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, APR_SUCCESS, r, APLOGNO(01672)
                           "Anonymous: Passwd <%s> Accepted",
                           sent_pw ? sent_pw : "\'none\'");
         }
diff --git a/modules/aaa/mod_authn_core.c b/modules/aaa/mod_authn_core.c
index f8b4165..29d1988 100644
--- a/modules/aaa/mod_authn_core.c
+++ b/modules/aaa/mod_authn_core.c
@@ -351,7 +351,7 @@ static int authenticate_no_user(request_rec *r)
     /* there's an AuthType configured, but no authentication module
      * loaded to support it
      */
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r, APLOGNO(01796)
                   "AuthType %s configured without corresponding module",
                   ap_auth_type(r));
 
diff --git a/modules/aaa/mod_authn_dbd.c b/modules/aaa/mod_authn_dbd.c
index 75db852..5819abd 100644
--- a/modules/aaa/mod_authn_dbd.c
+++ b/modules/aaa/mod_authn_dbd.c
@@ -105,28 +105,28 @@ static authn_status authn_dbd_password(request_rec *r, const char *user,
                                                 &authn_dbd_module);
     ap_dbd_t *dbd = authn_dbd_acquire_fn(r);
     if (dbd == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01653)
                       "Failed to acquire database connection to look up "
                       "user '%s'", user);
         return AUTH_GENERAL_ERROR;
     }
 
     if (conf->user == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01654)
                       "No AuthDBDUserPWQuery has been specified");
         return AUTH_GENERAL_ERROR;
     }
 
     statement = apr_hash_get(dbd->prepared, conf->user, APR_HASH_KEY_STRING);
     if (statement == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01655)
                       "A prepared statement could not be found for "
                       "AuthDBDUserPWQuery with the key '%s'", conf->user);
         return AUTH_GENERAL_ERROR;
     }
     if (apr_dbd_pvselect(dbd->driver, r->pool, dbd->handle, &res, statement,
                               0, user, NULL) != 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01656)
                       "Query execution error looking up '%s' "
                       "in database", user);
         return AUTH_GENERAL_ERROR;
@@ -135,7 +135,7 @@ static authn_status authn_dbd_password(request_rec *r, const char *user,
          rv != -1;
          rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1)) {
         if (rv != 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01657)
                           "Error retrieving results while looking up '%s' "
                           "in database", user);
             return AUTH_GENERAL_ERROR;
@@ -198,26 +198,26 @@ static authn_status authn_dbd_realm(request_rec *r, const char *user,
                                                 &authn_dbd_module);
     ap_dbd_t *dbd = authn_dbd_acquire_fn(r);
     if (dbd == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01658)
                       "Failed to acquire database connection to look up "
                       "user '%s:%s'", user, realm);
         return AUTH_GENERAL_ERROR;
     }
     if (conf->realm == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01659)
                       "No AuthDBDUserRealmQuery has been specified");
         return AUTH_GENERAL_ERROR;
     }
     statement = apr_hash_get(dbd->prepared, conf->realm, APR_HASH_KEY_STRING);
     if (statement == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01660)
                       "A prepared statement could not be found for "
                       "AuthDBDUserRealmQuery with the key '%s'", conf->realm);
         return AUTH_GENERAL_ERROR;
     }
     if (apr_dbd_pvselect(dbd->driver, r->pool, dbd->handle, &res, statement,
                               0, user, realm, NULL) != 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01661)
                       "Query execution error looking up '%s:%s' "
                       "in database", user, realm);
         return AUTH_GENERAL_ERROR;
@@ -226,7 +226,7 @@ static authn_status authn_dbd_realm(request_rec *r, const char *user,
          rv != -1;
          rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1)) {
         if (rv != 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01662)
                           "Error retrieving results while looking up '%s:%s' "
                           "in database", user, realm);
             return AUTH_GENERAL_ERROR;
diff --git a/modules/aaa/mod_authn_dbm.c b/modules/aaa/mod_authn_dbm.c
index f1e1dbe..9ab05e4 100644
--- a/modules/aaa/mod_authn_dbm.c
+++ b/modules/aaa/mod_authn_dbm.c
@@ -128,7 +128,7 @@ static authn_status check_dbm_pw(request_rec *r, const char *user,
                          r->pool);
 
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01754)
                       "could not open dbm (type %s) auth file: %s",
                       conf->dbmtype, conf->pwfile);
         return AUTH_GENERAL_ERROR;
@@ -167,7 +167,7 @@ static authn_status get_dbm_realm_hash(request_rec *r, const char *user,
                          &dbm_hash, r->pool);
 
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01755)
                       "Could not open dbm (type %s) hash file: %s",
                       conf->dbmtype, conf->pwfile);
         return AUTH_GENERAL_ERROR;
diff --git a/modules/aaa/mod_authn_file.c b/modules/aaa/mod_authn_file.c
index 90c5d26..a54a423 100644
--- a/modules/aaa/mod_authn_file.c
+++ b/modules/aaa/mod_authn_file.c
@@ -76,7 +76,7 @@ static authn_status check_password(request_rec *r, const char *user,
     char *file_password = NULL;
 
     if (!conf->pwfile) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01619)
                       "AuthUserFile not specified in the configuration");
         return AUTH_GENERAL_ERROR;
     }
@@ -84,7 +84,7 @@ static authn_status check_password(request_rec *r, const char *user,
     status = ap_pcfg_openfile(&f, r->pool, conf->pwfile);
 
     if (status != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01620)
                       "Could not open password file: %s", conf->pwfile);
         return AUTH_GENERAL_ERROR;
     }
@@ -131,7 +131,7 @@ static authn_status get_realm_hash(request_rec *r, const char *user,
     char *file_hash = NULL;
 
     if (!conf->pwfile) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01621)
                       "AuthUserFile not specified in the configuration");
         return AUTH_GENERAL_ERROR;
     }
@@ -139,7 +139,7 @@ static authn_status get_realm_hash(request_rec *r, const char *user,
     status = ap_pcfg_openfile(&f, r->pool, conf->pwfile);
 
     if (status != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01622)
                       "Could not open password file: %s", conf->pwfile);
         return AUTH_GENERAL_ERROR;
     }
diff --git a/modules/aaa/mod_authn_socache.c b/modules/aaa/mod_authn_socache.c
index 317ce9f..1188a0b 100644
--- a/modules/aaa/mod_authn_socache.c
+++ b/modules/aaa/mod_authn_socache.c
@@ -72,7 +72,7 @@ static int authn_cache_precfg(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *p
     apr_status_t rv = ap_mutex_register(pconf, authn_cache_id,
                                         NULL, APR_LOCK_DEFAULT, 0);
     if (rv != APR_SUCCESS) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog,
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog, APLOGNO(01673)
                       "failed to register %s mutex", authn_cache_id);
         return 500; /* An HTTP status would be a misnomer! */
     }
@@ -93,7 +93,7 @@ static int authn_cache_post_config(apr_pool_t *pconf, apr_pool_t *plog,
         return OK;    /* don't waste the overhead of creating mutex & cache */
     }
     if (socache_provider == NULL) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, 0, plog,
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, 0, plog, APLOGNO(01674)
                       "Please select a socache provider with AuthnCacheSOCache "
                       "(no default found on this platform)");
         return 500; /* An HTTP status would be a misnomer! */
@@ -102,7 +102,7 @@ static int authn_cache_post_config(apr_pool_t *pconf, apr_pool_t *plog,
     rv = ap_global_mutex_create(&authn_cache_mutex, NULL,
                                 authn_cache_id, NULL, s, pconf, 0);
     if (rv != APR_SUCCESS) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog,
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog, APLOGNO(01675)
                       "failed to create %s mutex", authn_cache_id);
         return 500; /* An HTTP status would be a misnomer! */
     }
@@ -110,14 +110,14 @@ static int authn_cache_post_config(apr_pool_t *pconf, apr_pool_t *plog,
 
     errmsg = socache_provider->create(&socache_instance, NULL, ptmp, pconf);
     if (errmsg) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog, "%s", errmsg);
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog, APLOGNO(01676) "%s", errmsg);
         return 500; /* An HTTP status would be a misnomer! */
     }
 
     rv = socache_provider->init(socache_instance, authn_cache_id,
                                 &authn_cache_hints, s, pconf);
     if (rv != APR_SUCCESS) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog,
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, plog, APLOGNO(01677)
                       "failed to initialise %s cache", authn_cache_id);
         return 500; /* An HTTP status would be a misnomer! */
     }
@@ -134,7 +134,7 @@ static void authn_cache_child_init(apr_pool_t *p, server_rec *s)
     lock = apr_global_mutex_lockfile(authn_cache_mutex);
     rv = apr_global_mutex_child_init(&authn_cache_mutex, lock, p);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(01678)
                      "failed to initialise mutex in child_init");
     }
 }
@@ -281,12 +281,12 @@ static void ap_authn_cache_store(request_rec *r, const char *module,
     rv = apr_global_mutex_trylock(authn_cache_mutex);
     if (APR_STATUS_IS_EBUSY(rv)) {
         /* don't wait around; just abandon it */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(01679)
                       "authn credentials for %s not cached (mutex busy)", user);
         return;
     }
     else if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01680)
                       "Failed to cache authn credentials for %s in %s",
                       module, dcfg->context);
         return;
@@ -302,12 +302,12 @@ static void ap_authn_cache_store(request_rec *r, const char *module,
                                  (unsigned char*)key, strlen(key), expiry,
                                  (unsigned char*)data, strlen(data), r->pool);
     if (rv == APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01681)
                       "Cached authn credentials for %s in %s",
                       user, dcfg->context);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01682)
                       "Failed to cache authn credentials for %s in %s",
                       module, dcfg->context);
     }
@@ -315,7 +315,7 @@ static void ap_authn_cache_store(request_rec *r, const char *module,
     /* We're done with the mutex */
     rv = apr_global_mutex_unlock(authn_cache_mutex);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "Failed to release mutex!");
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01683) "Failed to release mutex!");
     }
     return;
 }
@@ -351,20 +351,20 @@ static authn_status check_password(request_rec *r, const char *user,
 
     if (APR_STATUS_IS_NOTFOUND(rv)) {
         /* not found - just return */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01684)
                       "Authn cache: no credentials found for %s", user);
         return AUTH_USER_NOT_FOUND;
     }
     else if (rv == APR_SUCCESS) {
         /* OK, we got a value */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01685)
                       "Authn cache: found credentials for %s", user);
         val[vallen] = 0;
     }
     else {
         /* error: give up and pass the buck */
         /* FIXME: getting this for NOTFOUND - prolly a bug in mod_socache */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01686)
                       "Error accessing authentication cache");
         return AUTH_USER_NOT_FOUND;
     }
@@ -396,19 +396,19 @@ static authn_status get_realm_hash(request_rec *r, const char *user,
 
     if (APR_STATUS_IS_NOTFOUND(rv)) {
         /* not found - just return */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01687)
                       "Authn cache: no credentials found for %s", user);
         return AUTH_USER_NOT_FOUND;
     }
     else if (rv == APR_SUCCESS) {
         /* OK, we got a value */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01688)
                       "Authn cache: found credentials for %s", user);
     }
     else {
         /* error: give up and pass the buck */
         /* FIXME: getting this for NOTFOUND - prolly a bug in mod_socache */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01689)
                       "Error accessing authentication cache");
         return AUTH_USER_NOT_FOUND;
     }
diff --git a/modules/aaa/mod_authnz_ldap.c b/modules/aaa/mod_authnz_ldap.c
index 8cada8f..689d5b7 100644
--- a/modules/aaa/mod_authnz_ldap.c
+++ b/modules/aaa/mod_authnz_ldap.c
@@ -492,24 +492,24 @@ static authn_status authn_ldap_check_password(request_rec *r, const char *user,
                                        sec->deref, sec->secure);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01690)
                       "auth_ldap authenticate: no sec->host - weird...?");
         return AUTH_GENERAL_ERROR;
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01691)
                   "auth_ldap authenticate: using URL %s", sec->url);
 
     /* Get the password that the client sent */
     if (password == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01692)
                       "auth_ldap authenticate: no password specified");
         util_ldap_connection_close(ldc);
         return AUTH_GENERAL_ERROR;
     }
 
     if (user == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01693)
                       "auth_ldap authenticate: no user specified");
         util_ldap_connection_close(ldc);
         return AUTH_GENERAL_ERROR;
@@ -533,14 +533,14 @@ static authn_status authn_ldap_check_password(request_rec *r, const char *user,
     /* handle bind failure */
     if (result != LDAP_SUCCESS) {
         if (!sec->bind_authoritative) {
-           ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+           ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01694)
                       "auth_ldap authenticate: user %s authentication failed; "
                       "URI %s [%s][%s] (not authoritative)",
                       user, r->uri, ldc->reason, ldap_err2string(result));
            return AUTH_USER_NOT_FOUND;
         }
 
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01695)
                       "auth_ldap authenticate: "
                       "user %s authentication failed; URI %s [%s][%s]",
                       user, r->uri, ldc->reason, ldap_err2string(result));
@@ -580,7 +580,7 @@ static authn_status authn_ldap_check_password(request_rec *r, const char *user,
 
     /* sanity check */
     if (sec->remote_user_attribute && !remote_user_attribute_set) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01696)
                   "auth_ldap authenticate: "
                   "REMOTE_USER was to be set with attribute '%s', "
                   "but this attribute was not requested for in the "
@@ -589,7 +589,7 @@ static authn_status authn_ldap_check_password(request_rec *r, const char *user,
                   sec->remote_user_attribute);
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01697)
                   "auth_ldap authenticate: accepting %s", user);
 
     return AUTH_GRANTED;
@@ -628,7 +628,7 @@ static authz_status ldapuser_check_authorization(request_rec *r,
                                   apr_pool_cleanup_null);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01698)
                       "auth_ldap authorize: no sec->host - weird...?");
         return AUTHZ_DENIED;
     }
@@ -641,13 +641,13 @@ static authz_status ldapuser_check_authorization(request_rec *r,
 
 
     if (!strlen(r->user)) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01699)
             "ldap authorize: Userid is blank, AuthType=%s",
             r->ap_auth_type);
     }
 
     if(!req) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01700)
             "ldap authorize: Creating LDAP req structure");
 
         req = (authn_ldap_request_t *)apr_pcalloc(r->pool,
@@ -662,7 +662,7 @@ static authz_status ldapuser_check_authorization(request_rec *r,
 
         /* Search failed, log error and return failure */
         if(result != LDAP_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01701)
                 "auth_ldap authorise: User DN not found, %s", ldc->reason);
             return AUTHZ_DENIED;
         }
@@ -674,7 +674,7 @@ static authz_status ldapuser_check_authorization(request_rec *r,
     }
 
     if (req->dn == NULL || strlen(req->dn) == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01702)
                       "auth_ldap authorize: require user: user's DN has not "
                       "been defined; failing authorization");
         return AUTHZ_DENIED;
@@ -687,14 +687,14 @@ static authz_status ldapuser_check_authorization(request_rec *r,
     result = util_ldap_cache_compare(r, ldc, sec->url, req->dn, sec->attribute, require_args);
     switch(result) {
         case LDAP_COMPARE_TRUE: {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01703)
                           "auth_ldap authorize: require user: authorization "
                           "successful");
             set_request_vars(r, LDAP_AUTHZ);
             return AUTHZ_GRANTED;
         }
         default: {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01704)
                           "auth_ldap authorize: require user: "
                           "authorization failed [%s][%s]",
                           ldc->reason, ldap_err2string(result));
@@ -709,14 +709,14 @@ static authz_status ldapuser_check_authorization(request_rec *r,
         result = util_ldap_cache_compare(r, ldc, sec->url, req->dn, sec->attribute, w);
         switch(result) {
             case LDAP_COMPARE_TRUE: {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01705)
                               "auth_ldap authorize: "
                               "require user: authorization successful");
                 set_request_vars(r, LDAP_AUTHZ);
                 return AUTHZ_GRANTED;
             }
             default: {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01706)
                               "auth_ldap authorize: "
                               "require user: authorization failed [%s][%s]",
                               ldc->reason, ldap_err2string(result));
@@ -724,7 +724,7 @@ static authz_status ldapuser_check_authorization(request_rec *r,
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01707)
                   "auth_ldap authorize user: authorization denied for "
                   "user %s to %s",
                   r->user, r->uri);
@@ -766,7 +766,7 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
                                   apr_pool_cleanup_null);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01708)
                       "auth_ldap authorize: no sec->host - weird...?");
         return AUTHZ_DENIED;
     }
@@ -814,13 +814,13 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
      */
 
     if (!strlen(r->user)) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01709)
             "ldap authorize: Userid is blank, AuthType=%s",
             r->ap_auth_type);
     }
 
     if(!req) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01710)
             "ldap authorize: Creating LDAP req structure");
 
         req = (authn_ldap_request_t *)apr_pcalloc(r->pool,
@@ -834,7 +834,7 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
 
         /* Search failed, log error and return failure */
         if(result != LDAP_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01711)
                 "auth_ldap authorise: User DN not found, %s", ldc->reason);
             return AUTHZ_DENIED;
         }
@@ -848,7 +848,7 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
 
     if (sec->group_attrib_is_dn) {
         if (req->dn == NULL || strlen(req->dn) == 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01712)
                           "auth_ldap authorize: require group: user's DN has "
                           "not been defined; failing authorization for user %s",
                           r->user);
@@ -865,13 +865,13 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
 
     t = require_args;
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01713)
                   "auth_ldap authorize: require group: testing for group "
                   "membership in \"%s\"",
                   t);
 
     for (i = 0; i < sec->groupattr->nelts; i++) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01714)
                       "auth_ldap authorize: require group: testing for %s: "
                       "%s (%s)",
                       ent[i].name,
@@ -881,7 +881,7 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
                              sec->group_attrib_is_dn ? req->dn : req->user);
         switch(result) {
             case LDAP_COMPARE_TRUE: {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01715)
                               "auth_ldap authorize: require group: "
                               "authorization successful (attribute %s) "
                               "[%s][%d - %s]",
@@ -901,7 +901,7 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
                                           authnz_ldap_cleanup_connection_close,
                                           apr_pool_cleanup_null);
 
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01716)
                                "auth_ldap authorise: require group \"%s\": "
                                "failed [%s][%d - %s], checking sub-groups",
                                t, ldc->reason, result, ldap_err2string(result));
@@ -912,7 +912,7 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
                                                          sec->subgroupclasses,
                                                          0, sec->maxNestingDepth);
                 if(result == LDAP_COMPARE_TRUE) {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01717)
                                   "auth_ldap authorise: require group "
                                   "(sub-group): authorisation successful "
                                   "(attribute %s) [%s][%d - %s]",
@@ -922,7 +922,7 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
                     return AUTHZ_GRANTED;
                 }
                 else {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01718)
                                   "auth_ldap authorise: require group "
                                   "(sub-group) \"%s\": authorisation failed "
                                   "[%s][%d - %s]",
@@ -932,7 +932,7 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
                 break;
             }
             default: {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01719)
                               "auth_ldap authorize: require group \"%s\": "
                               "authorization failed [%s][%d - %s]",
                               t, ldc->reason, result, ldap_err2string(result));
@@ -940,7 +940,7 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01720)
                   "auth_ldap authorize group: authorization denied for "
                   "user %s to %s",
                   r->user, r->uri);
@@ -980,7 +980,7 @@ static authz_status ldapdn_check_authorization(request_rec *r,
                                   apr_pool_cleanup_null);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01721)
                       "auth_ldap authorize: no sec->host - weird...?");
         return AUTHZ_DENIED;
     }
@@ -992,13 +992,13 @@ static authz_status ldapdn_check_authorization(request_rec *r,
      */
 
     if (!strlen(r->user)) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01722)
             "ldap authorize: Userid is blank, AuthType=%s",
             r->ap_auth_type);
     }
 
     if(!req) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01723)
             "ldap authorize: Creating LDAP req structure");
 
         req = (authn_ldap_request_t *)apr_pcalloc(r->pool,
@@ -1012,7 +1012,7 @@ static authz_status ldapdn_check_authorization(request_rec *r,
 
         /* Search failed, log error and return failure */
         if(result != LDAP_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01724)
                 "auth_ldap authorise: User DN not found with filter %s: %s", filtbuf, ldc->reason);
             return AUTHZ_DENIED;
         }
@@ -1025,7 +1025,7 @@ static authz_status ldapdn_check_authorization(request_rec *r,
     t = require_args;
 
     if (req->dn == NULL || strlen(req->dn) == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01725)
                       "auth_ldap authorize: require dn: user's DN has not "
                       "been defined; failing authorization");
         return AUTHZ_DENIED;
@@ -1034,14 +1034,14 @@ static authz_status ldapdn_check_authorization(request_rec *r,
     result = util_ldap_cache_comparedn(r, ldc, sec->url, req->dn, t, sec->compare_dn_on_server);
     switch(result) {
         case LDAP_COMPARE_TRUE: {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01726)
                           "auth_ldap authorize: "
                           "require dn: authorization successful");
             set_request_vars(r, LDAP_AUTHZ);
             return AUTHZ_GRANTED;
         }
         default: {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01727)
                           "auth_ldap authorize: "
                           "require dn \"%s\": LDAP error [%s][%s]",
                           t, ldc->reason, ldap_err2string(result));
@@ -1049,7 +1049,7 @@ static authz_status ldapdn_check_authorization(request_rec *r,
     }
 
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01728)
                   "auth_ldap authorize dn: authorization denied for "
                   "user %s to %s",
                   r->user, r->uri);
@@ -1090,7 +1090,7 @@ static authz_status ldapattribute_check_authorization(request_rec *r,
                                   apr_pool_cleanup_null);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01729)
                       "auth_ldap authorize: no sec->host - weird...?");
         return AUTHZ_DENIED;
     }
@@ -1102,13 +1102,13 @@ static authz_status ldapattribute_check_authorization(request_rec *r,
      */
 
     if (!strlen(r->user)) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01730)
             "ldap authorize: Userid is blank, AuthType=%s",
             r->ap_auth_type);
     }
 
     if(!req) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01731)
             "ldap authorize: Creating LDAP req structure");
 
         req = (authn_ldap_request_t *)apr_pcalloc(r->pool,
@@ -1122,7 +1122,7 @@ static authz_status ldapattribute_check_authorization(request_rec *r,
 
         /* Search failed, log error and return failure */
         if(result != LDAP_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01732)
                 "auth_ldap authorise: User DN not found with filter %s: %s", filtbuf, ldc->reason);
             return AUTHZ_DENIED;
         }
@@ -1133,7 +1133,7 @@ static authz_status ldapattribute_check_authorization(request_rec *r,
     }
 
     if (req->dn == NULL || strlen(req->dn) == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01733)
                       "auth_ldap authorize: require ldap-attribute: user's DN "
                       "has not been defined; failing authorization");
         return AUTHZ_DENIED;
@@ -1144,20 +1144,20 @@ static authz_status ldapattribute_check_authorization(request_rec *r,
         w = ap_getword(r->pool, &t, '=');
         value = ap_getword_conf(r->pool, &t);
 
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01734)
                       "auth_ldap authorize: checking attribute %s has value %s",
                       w, value);
         result = util_ldap_cache_compare(r, ldc, sec->url, req->dn, w, value);
         switch(result) {
             case LDAP_COMPARE_TRUE: {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01735)
                               "auth_ldap authorize: "
                               "require attribute: authorization successful");
                 set_request_vars(r, LDAP_AUTHZ);
                 return AUTHZ_GRANTED;
             }
             default: {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01736)
                               "auth_ldap authorize: require attribute: "
                               "authorization failed [%s][%s]",
                               ldc->reason, ldap_err2string(result));
@@ -1165,7 +1165,7 @@ static authz_status ldapattribute_check_authorization(request_rec *r,
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01737)
                   "auth_ldap authorize attribute: authorization denied for "
                   "user %s to %s",
                   r->user, r->uri);
@@ -1204,7 +1204,7 @@ static authz_status ldapfilter_check_authorization(request_rec *r,
                                   apr_pool_cleanup_null);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01738)
                       "auth_ldap authorize: no sec->host - weird...?");
         return AUTHZ_DENIED;
     }
@@ -1216,13 +1216,13 @@ static authz_status ldapfilter_check_authorization(request_rec *r,
      */
 
     if (!strlen(r->user)) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01739)
             "ldap authorize: Userid is blank, AuthType=%s",
             r->ap_auth_type);
     }
 
     if(!req) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01740)
             "ldap authorize: Creating LDAP req structure");
 
         req = (authn_ldap_request_t *)apr_pcalloc(r->pool,
@@ -1236,7 +1236,7 @@ static authz_status ldapfilter_check_authorization(request_rec *r,
 
         /* Search failed, log error and return failure */
         if(result != LDAP_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01741)
                 "auth_ldap authorise: User DN not found with filter %s: %s", filtbuf, ldc->reason);
             return AUTHZ_DENIED;
         }
@@ -1247,7 +1247,7 @@ static authz_status ldapfilter_check_authorization(request_rec *r,
     }
 
     if (req->dn == NULL || strlen(req->dn) == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01742)
                       "auth_ldap authorize: require ldap-filter: user's DN "
                       "has not been defined; failing authorization");
         return AUTHZ_DENIED;
@@ -1256,7 +1256,7 @@ static authz_status ldapfilter_check_authorization(request_rec *r,
     t = require_args;
 
     if (t[0]) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01743)
                       "auth_ldap authorize: checking filter %s", t);
 
         /* Build the username filter */
@@ -1268,7 +1268,7 @@ static authz_status ldapfilter_check_authorization(request_rec *r,
 
         /* Make sure that the filtered search returned the correct user dn */
         if (result == LDAP_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01744)
                           "auth_ldap authorize: checking dn match %s", dn);
             if (sec->compare_as_user) {
                 /* ldap-filter is the only authz that requires a search and a compare */
@@ -1282,21 +1282,21 @@ static authz_status ldapfilter_check_authorization(request_rec *r,
 
         switch(result) {
             case LDAP_COMPARE_TRUE: {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01745)
                               "auth_ldap authorize: require ldap-filter: "
                               "authorization successful");
                 set_request_vars(r, LDAP_AUTHZ);
                 return AUTHZ_GRANTED;
             }
             case LDAP_FILTER_ERROR: {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01746)
                               "auth_ldap authorize: require ldap-filter: "
                               "%s authorization failed [%s][%s]",
                               filtbuf, ldc->reason, ldap_err2string(result));
                 break;
             }
             default: {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01747)
                               "auth_ldap authorize: require ldap-filter: "
                               "authorization failed [%s][%s]",
                               ldc->reason, ldap_err2string(result));
@@ -1304,7 +1304,7 @@ static authz_status ldapfilter_check_authorization(request_rec *r,
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01748)
                   "auth_ldap authorize filter: authorization denied for "
                   "user %s to %s",
                   r->user, r->uri);
@@ -1669,7 +1669,7 @@ static int authnz_ldap_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *
 
     /* make sure that mod_ldap (util_ldap) is loaded */
     if (ap_find_linked_module("util_ldap.c") == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01749)
                      "Module mod_ldap missing. Mod_ldap (aka. util_ldap) "
                      "must be loaded in order for mod_authnz_ldap to function properly");
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -1682,7 +1682,7 @@ static int authnz_ldap_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *
 
     charset_confname = ap_server_root_relative(p, charset_confname);
     if (!charset_confname) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s, APLOGNO(01750)
                      "Invalid charset conversion config path %s",
                      (const char *)ap_get_module_config(s->module_config,
                                                         &authnz_ldap_module));
@@ -1690,7 +1690,7 @@ static int authnz_ldap_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *
     }
     if ((status = ap_pcfg_openfile(&f, ptemp, charset_confname))
                 != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, status, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, status, s, APLOGNO(01751)
                      "could not open charset conversion config file %s.",
                      charset_confname);
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -1717,7 +1717,7 @@ static int authnz_ldap_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *
 
     to_charset = derive_codepage_from_lang (p, "utf-8");
     if (to_charset == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, status, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, status, s, APLOGNO(01752)
                      "could not find the UTF-8 charset in the file %s.",
                      charset_confname);
         return HTTP_INTERNAL_SERVER_ERROR;
diff --git a/modules/aaa/mod_authz_core.c b/modules/aaa/mod_authz_core.c
index 6503971..fb286e2 100644
--- a/modules/aaa/mod_authz_core.c
+++ b/modules/aaa/mod_authz_core.c
@@ -606,7 +606,7 @@ static int authz_core_check_section(apr_pool_t *p, server_rec *s,
     }
 
     if (ret != OK) {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, APR_SUCCESS, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, APR_SUCCESS, s, APLOGNO(01624)
                      "%s",
                      apr_pstrcat(p, (is_conf
                                      ? "<Directory>, <Location>, or similar"
@@ -695,7 +695,7 @@ static authz_status apply_authz_sections(request_rec *r,
         auth_result =
             (parent_op == AUTHZ_LOGIC_AND) ? AUTHZ_GRANTED : AUTHZ_NEUTRAL;
 
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(01625)
                       "authorization result of %s: %s "
                       "(directive limited to other methods)",
                       format_authz_command(r->pool, section),
@@ -777,7 +777,7 @@ static authz_status apply_authz_sections(request_rec *r,
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(01626)
                   "authorization result of %s: %s",
                   format_authz_command(r->pool, section),
                   format_authz_result(auth_result));
@@ -798,14 +798,14 @@ static int authorize_user_core(request_rec *r, int after_authn)
              * directives applied to support it
              */
 
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r, APLOGNO(01627)
                           "AuthType configured with no corresponding "
                           "authorization directives");
 
             return HTTP_INTERNAL_SERVER_ERROR;
         }
 
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(01628)
                       "authorization result: granted (no directives)");
 
         return OK;
@@ -818,7 +818,7 @@ static int authorize_user_core(request_rec *r, int after_authn)
     }
     else if (auth_result == AUTHZ_DENIED_NO_USER) {
         if (after_authn) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r, APLOGNO(01629)
                           "authorization failure (no authenticated user): %s",
                           r->uri);
             /*
@@ -841,7 +841,7 @@ static int authorize_user_core(request_rec *r, int after_authn)
     }
     else if (auth_result == AUTHZ_DENIED || auth_result == AUTHZ_NEUTRAL) {
         if (!after_authn || ap_auth_type(r) == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r, APLOGNO(01630)
                           "client denied by server configuration: %s%s",
                           r->filename ? "" : "uri ",
                           r->filename ? r->filename : r->uri);
@@ -849,7 +849,7 @@ static int authorize_user_core(request_rec *r, int after_authn)
             return HTTP_FORBIDDEN;
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r, APLOGNO(01631)
                           "user %s: authorization failure for \"%s\": ",
                           r->user, r->uri);
 
diff --git a/modules/aaa/mod_authz_dbd.c b/modules/aaa/mod_authz_dbd.c
index e9a67ae..59ca2b3 100644
--- a/modules/aaa/mod_authz_dbd.c
+++ b/modules/aaa/mod_authz_dbd.c
@@ -122,13 +122,13 @@ static int authz_dbd_login(request_rec *r, authz_dbd_cfg *cfg,
     apr_dbd_row_t *row = NULL;
 
     if (cfg->query == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01642)
                       "No query configured for %s!", action);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
     query = apr_hash_get(dbd->prepared, cfg->query, APR_HASH_KEY_STRING);
     if (query == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01643)
                       "Error retrieving Query for %s!", action);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -137,14 +137,14 @@ static int authz_dbd_login(request_rec *r, authz_dbd_cfg *cfg,
                          query, r->user, NULL);
     if (rv == 0) {
         if (nrows != 1) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01644)
                           "authz_dbd: %s of user %s updated %d rows",
                           action, r->user, nrows);
         }
     }
     else {
         message = apr_dbd_error(dbd->driver, dbd->handle, rv);
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01645)
                       "authz_dbd: query for %s failed; user %s [%s]",
                       action, r->user, message?message:noerror);
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -158,7 +158,7 @@ static int authz_dbd_login(request_rec *r, authz_dbd_cfg *cfg,
         query = apr_hash_get(dbd->prepared, cfg->redir_query,
                              APR_HASH_KEY_STRING);
         if (query == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01646)
                           "authz_dbd: no redirect query!");
             /* OK, this is non-critical; we can just not-redirect */
         }
@@ -169,7 +169,7 @@ static int authz_dbd_login(request_rec *r, authz_dbd_cfg *cfg,
                  rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1)) {
                 if (rv != 0) {
                     message = apr_dbd_error(dbd->driver, dbd->handle, rv);
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01647)
                           "authz_dbd in get_row; action=%s user=%s [%s]",
                           action, r->user, message?message:noerror);
                 }
@@ -181,7 +181,7 @@ static int authz_dbd_login(request_rec *r, authz_dbd_cfg *cfg,
         }
         else {
             message = apr_dbd_error(dbd->driver, dbd->handle, rv);
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01648)
                           "authz_dbd/redirect for %s of %s [%s]",
                           action, r->user, message?message:noerror);
         }
@@ -207,13 +207,13 @@ static int authz_dbd_group_query(request_rec *r, authz_dbd_cfg *cfg,
     const char **group;
 
     if (cfg->query == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01649)
                       "No query configured for dbd-group!");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
     query = apr_hash_get(dbd->prepared, cfg->query, APR_HASH_KEY_STRING);
     if (query == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01650)
                       "Error retrieving query for dbd-group!");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -229,7 +229,7 @@ static int authz_dbd_group_query(request_rec *r, authz_dbd_cfg *cfg,
             }
             else {
                 message = apr_dbd_error(dbd->driver, dbd->handle, rv);
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01651)
                         "authz_dbd in get_row; group query for user=%s [%s]",
                         r->user, message?message:noerror);
                 return HTTP_INTERNAL_SERVER_ERROR;
@@ -238,7 +238,7 @@ static int authz_dbd_group_query(request_rec *r, authz_dbd_cfg *cfg,
     }
     else {
         message = apr_dbd_error(dbd->driver, dbd->handle, rv);
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01652)
                       "authz_dbd, in groups query for %s [%s]",
                       r->user, message?message:noerror);
         return HTTP_INTERNAL_SERVER_ERROR;
diff --git a/modules/aaa/mod_authz_dbm.c b/modules/aaa/mod_authz_dbm.c
index 9fadb82..4f13cae 100644
--- a/modules/aaa/mod_authz_dbm.c
+++ b/modules/aaa/mod_authz_dbm.c
@@ -149,7 +149,7 @@ static authz_status dbmgroup_check_authorization(request_rec *r,
     }
 
     if (!conf->grpfile) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01798)
                         "No group file was specified in the configuration");
         return AUTHZ_DENIED;
     }
@@ -162,7 +162,7 @@ static authz_status dbmgroup_check_authorization(request_rec *r,
                              user, conf->grpfile, conf->dbmtype, &groups);
 
         if (status != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01799)
                           "could not open dbm (type %s) group access "
                           "file: %s", conf->dbmtype, conf->grpfile);
             return AUTHZ_GENERAL_ERROR;
@@ -170,7 +170,7 @@ static authz_status dbmgroup_check_authorization(request_rec *r,
 
         if (groups == NULL) {
             /* no groups available, so exit immediately */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01800)
                           "Authorization of user %s to access %s failed, reason: "
                           "user doesn't appear in DBM group file (%s).",
                           r->user, r->uri, conf->grpfile);
@@ -191,7 +191,7 @@ static authz_status dbmgroup_check_authorization(request_rec *r,
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01801)
                   "Authorization of user %s to access %s failed, reason: "
                   "user is not part of the 'require'ed group(s).",
                   r->user, r->uri);
@@ -220,7 +220,7 @@ static authz_status dbmfilegroup_check_authorization(request_rec *r,
     }
 
     if (!conf->grpfile) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01802)
                         "No group file was specified in the configuration");
         return AUTHZ_DENIED;
     }
@@ -230,7 +230,7 @@ static authz_status dbmfilegroup_check_authorization(request_rec *r,
                          user, conf->grpfile, conf->dbmtype, &groups);
 
     if (status != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01803)
                       "could not open dbm (type %s) group access "
                       "file: %s", conf->dbmtype, conf->grpfile);
         return AUTHZ_DENIED;
@@ -238,7 +238,7 @@ static authz_status dbmfilegroup_check_authorization(request_rec *r,
 
     if (groups == NULL) {
         /* no groups available, so exit immediately */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01804)
                       "Authorization of user %s to access %s failed, reason: "
                       "user doesn't appear in DBM group file (%s).",
                       r->user, r->uri, conf->grpfile);
@@ -259,7 +259,7 @@ static authz_status dbmfilegroup_check_authorization(request_rec *r,
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01805)
                   "Authorization of user %s to access %s failed, reason: "
                   "user is not part of the 'require'ed group(s).",
                   r->user, r->uri);
diff --git a/modules/aaa/mod_authz_groupfile.c b/modules/aaa/mod_authz_groupfile.c
index 94128f1..fb94168 100644
--- a/modules/aaa/mod_authz_groupfile.c
+++ b/modules/aaa/mod_authz_groupfile.c
@@ -161,7 +161,7 @@ static authz_status group_check_authorization(request_rec *r,
      * configured. So decline.
      */
     if (!(conf->groupfile)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01664)
                         "No group file was specified in the configuration");
         return AUTHZ_DENIED;
     }
@@ -170,7 +170,7 @@ static authz_status group_check_authorization(request_rec *r,
                                 &grpstatus);
 
     if (status != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01665)
                         "Could not open group file: %s",
                         conf->groupfile);
         return AUTHZ_DENIED;
@@ -178,7 +178,7 @@ static authz_status group_check_authorization(request_rec *r,
 
     if (apr_table_elts(grpstatus)->nelts == 0) {
         /* no groups available, so exit immediately */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01666)
                       "Authorization of user %s to access %s failed, reason: "
                       "user doesn't appear in group file (%s).",
                       r->user, r->uri, conf->groupfile);
@@ -192,7 +192,7 @@ static authz_status group_check_authorization(request_rec *r,
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01667)
                     "Authorization of user %s to access %s failed, reason: "
                     "user is not part of the 'require'ed group(s).",
                     r->user, r->uri);
@@ -221,7 +221,7 @@ static authz_status filegroup_check_authorization(request_rec *r,
      * configured. So decline.
      */
     if (!(conf->groupfile)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01668)
                         "No group file was specified in the configuration");
         return AUTHZ_DENIED;
     }
@@ -229,7 +229,7 @@ static authz_status filegroup_check_authorization(request_rec *r,
     status = groups_for_user(r->pool, user, conf->groupfile,
                              &grpstatus);
     if (status != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01669)
                       "Could not open group file: %s",
                       conf->groupfile);
         return AUTHZ_DENIED;
@@ -237,7 +237,7 @@ static authz_status filegroup_check_authorization(request_rec *r,
 
     if (apr_table_elts(grpstatus)->nelts == 0) {
         /* no groups available, so exit immediately */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01670)
                         "Authorization of user %s to access %s failed, reason: "
                         "user doesn't appear in group file (%s).",
                         r->user, r->uri, conf->groupfile);
@@ -259,7 +259,7 @@ static authz_status filegroup_check_authorization(request_rec *r,
         return AUTHZ_DENIED;
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01671)
                   "Authorization of user %s to access %s failed, reason: "
                   "user is not part of the 'require'ed file group.",
                   r->user, r->uri);
diff --git a/modules/aaa/mod_authz_host.c b/modules/aaa/mod_authz_host.c
index 180172a..e3108e8 100644
--- a/modules/aaa/mod_authz_host.c
+++ b/modules/aaa/mod_authz_host.c
@@ -176,7 +176,7 @@ static authz_status host_check_authorization(request_rec *r,
                                     &remotehost_is_ip);
 
     if ((remotehost == NULL) || remotehost_is_ip) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01753)
                       "access check of '%s' to %s failed, reason: unable to get the "
                       "remote host name", require_line, r->uri);
     }
diff --git a/modules/aaa/mod_authz_owner.c b/modules/aaa/mod_authz_owner.c
index 4cd3cdc..61d4734 100644
--- a/modules/aaa/mod_authz_owner.c
+++ b/modules/aaa/mod_authz_owner.c
@@ -47,7 +47,7 @@ static authz_status fileowner_check_authorization(request_rec *r,
 
 #if !APR_HAS_USER
     reason = "'Require file-owner' is not supported on this platform.";
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01632)
                   "Authorization of user %s to access %s failed, reason: %s",
                   r->user, r->uri, reason ? reason : "unknown");
     return AUTHZ_DENIED;
@@ -61,7 +61,7 @@ static authz_status fileowner_check_authorization(request_rec *r,
 
     if (!r->filename) {
         reason = "no filename available";
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01633)
                       "Authorization of user %s to access %s failed, reason: %s",
                       r->user, r->uri, reason ? reason : "unknown");
         return AUTHZ_DENIED;
@@ -71,7 +71,7 @@ static authz_status fileowner_check_authorization(request_rec *r,
     if (status != APR_SUCCESS) {
         reason = apr_pstrcat(r->pool, "could not stat file ",
                                 r->filename, NULL);
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01634)
                       "Authorization of user %s to access %s failed, reason: %s",
                       r->user, r->uri, reason ? reason : "unknown");
         return AUTHZ_DENIED;
@@ -79,7 +79,7 @@ static authz_status fileowner_check_authorization(request_rec *r,
 
     if (!(finfo.valid & APR_FINFO_USER)) {
         reason = "no file owner information available";
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01635)
                       "Authorization of user %s to access %s failed, reason: %s",
                       r->user, r->uri, reason ? reason : "unknown");
         return AUTHZ_DENIED;
@@ -88,7 +88,7 @@ static authz_status fileowner_check_authorization(request_rec *r,
     status = apr_uid_name_get(&owner, finfo.user, r->pool);
     if (status != APR_SUCCESS || !owner) {
         reason = "could not get name of file owner";
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01636)
                       "Authorization of user %s to access %s failed, reason: %s",
                       r->user, r->uri, reason ? reason : "unknown");
         return AUTHZ_DENIED;
@@ -97,7 +97,7 @@ static authz_status fileowner_check_authorization(request_rec *r,
     if (strcmp(owner, r->user)) {
         reason = apr_psprintf(r->pool, "file owner %s does not match.",
                                 owner);
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01637)
                       "Authorization of user %s to access %s failed, reason: %s",
                       r->user, r->uri, reason ? reason : "unknown");
         return AUTHZ_DENIED;
@@ -126,7 +126,7 @@ static char *authz_owner_get_file_group(request_rec *r)
 
     if (!r->filename) {
         reason = "no filename available";
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01638)
                       "Authorization of user %s to access %s failed, reason: %s",
                       r->user, r->uri, reason ? reason : "unknown");
         return NULL;
@@ -136,7 +136,7 @@ static char *authz_owner_get_file_group(request_rec *r)
     if (status != APR_SUCCESS) {
         reason = apr_pstrcat(r->pool, "could not stat file ",
                                 r->filename, NULL);
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01639)
                       "Authorization of user %s to access %s failed, reason: %s",
                       r->user, r->uri, reason ? reason : "unknown");
         return NULL;
@@ -144,7 +144,7 @@ static char *authz_owner_get_file_group(request_rec *r)
 
     if (!(finfo.valid & APR_FINFO_GROUP)) {
         reason = "no file group information available";
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01640)
                       "Authorization of user %s to access %s failed, reason: %s",
                       r->user, r->uri, reason ? reason : "unknown");
         return NULL;
@@ -153,7 +153,7 @@ static char *authz_owner_get_file_group(request_rec *r)
     status = apr_gid_name_get(&group, finfo.group, r->pool);
     if (status != APR_SUCCESS || !group) {
         reason = "could not get name of file group";
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01641)
                       "Authorization of user %s to access %s failed, reason: %s",
                       r->user, r->uri, reason ? reason : "unknown");
         return NULL;
diff --git a/modules/aaa/mod_authz_user.c b/modules/aaa/mod_authz_user.c
index 2d16a3c..7c9462c 100644
--- a/modules/aaa/mod_authz_user.c
+++ b/modules/aaa/mod_authz_user.c
@@ -62,7 +62,7 @@ static authz_status user_check_authorization(request_rec *r,
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01663)
                   "access to %s failed, reason: user '%s' does not meet "
                   "'require'ments for user to be allowed access",
                   r->uri, r->user);
diff --git a/modules/apreq/filter.c b/modules/apreq/filter.c
index b682e6d..09f24a2 100644
--- a/modules/apreq/filter.c
+++ b/modules/apreq/filter.c
@@ -127,13 +127,13 @@ void apreq_filter_init_context(ap_filter_t *f)
         apr_uint64_t content_length = apr_strtoi64(cl_header,&dummy,0);
 
         if (dummy == NULL || *dummy != 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r, APLOGNO(02045)
                           "Invalid Content-Length header (%s)", cl_header);
             ctx->body_status = APREQ_ERROR_BADHEADER;
             return;
         }
         else if (content_length > ctx->read_limit) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r, APLOGNO(02046)
                           "Content-Length header (%s) exceeds configured "
                           "max_body limit (%" APR_UINT64_T_FMT ")",
                           cl_header, ctx->read_limit);
@@ -221,14 +221,14 @@ static apr_status_t apreq_filter_init(ap_filter_t *f)
             handle->f = f;
         }
         else if (r->input_filters->frec->filter_func.in_func == apreq_filter) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(02047)
                           "removing intermediate apreq filter");
             if (handle->f == f)
                 handle->f = r->input_filters;
             ap_remove_input_filter(f);
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(02048)
                           "relocating intermediate apreq filter");
             apreq_filter_relocate(f);
             handle->f = f;
@@ -240,7 +240,7 @@ static apr_status_t apreq_filter_init(ap_filter_t *f)
      * if it is, we must deregister it now.
      */
     if (handle->f == f) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(02049)
                      "disabling stale protocol filter");
         if (ctx->body_status == APR_INCOMPLETE)
             ctx->body_status = APREQ_ERROR_INTERRUPT;
@@ -264,14 +264,14 @@ apr_status_t apreq_filter_prefetch(ap_filter_t *f, apr_off_t readbytes)
     if (ctx->body_status != APR_INCOMPLETE || readbytes == 0)
         return ctx->body_status;
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(02050)
                   "prefetching %" APR_OFF_T_FMT " bytes", readbytes);
 
     rv = ap_get_brigade(f->next, ctx->bb, AP_MODE_READBYTES,
                        APR_BLOCK_READ, readbytes);
 
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02051)
                       "ap_get_brigade failed during prefetch");
         ctx->filter_error = rv;
         return ctx->body_status = APREQ_ERROR_GENERAL;
@@ -283,7 +283,7 @@ apr_status_t apreq_filter_prefetch(ap_filter_t *f, apr_off_t readbytes)
     rv = apreq_brigade_concat(r->pool, ctx->temp_dir, ctx->brigade_limit,
                               ctx->spool, ctx->bbtmp);
     if (rv != APR_SUCCESS && rv != APR_EOF) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02052)
                       "apreq_brigade_concat failed; TempDir problem?");
         ctx->filter_error = APR_EGENERAL;
         return ctx->body_status = rv;
@@ -310,7 +310,7 @@ apr_status_t apreq_filter_prefetch(ap_filter_t *f, apr_off_t readbytes)
 
     if (ctx->bytes_read > ctx->read_limit) {
         ctx->body_status = APREQ_ERROR_OVERLIMIT;
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, ctx->body_status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, ctx->body_status, r, APLOGNO(02053)
                       "Bytes read (%" APR_UINT64_T_FMT
                       ") exceeds configured read limit (%" APR_UINT64_T_FMT ")",
                       ctx->bytes_read, ctx->read_limit);
@@ -389,7 +389,7 @@ apr_status_t apreq_filter(ap_filter_t *f,
 
     if (ctx->bytes_read > ctx->read_limit) {
         ctx->body_status = APREQ_ERROR_OVERLIMIT;
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, ctx->body_status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, ctx->body_status, r, APLOGNO(02054)
                       "Bytes read (%" APR_UINT64_T_FMT
                       ") exceeds configured max_body limit (%"
                       APR_UINT64_T_FMT ")",
@@ -410,7 +410,7 @@ static int apreq_pre_init(apr_pool_t *p, apr_pool_t *plog,
 
     status = apreq_pre_initialize(p);
     if (status != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, status, base_server,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, status, base_server, APLOGNO(02055)
                      "Failed to pre-initialize libapreq2");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -425,7 +425,7 @@ static int apreq_post_init(apr_pool_t *p, apr_pool_t *plog,
 
     status = apreq_post_initialize(p);
     if (status != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, status, base_server,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, status, base_server, APLOGNO(02056)
                      "Failed to post-initialize libapreq2");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -502,7 +502,7 @@ void apreq_filter_make_context(ap_filter_t *f)
 
             }
 
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(02057)
                           "stealing filter context");
             f->ctx = ctx;
             r->proto_input_filters = f;
@@ -511,7 +511,7 @@ void apreq_filter_make_context(ap_filter_t *f)
             return;
 
         default:
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, ctx->body_status, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, ctx->body_status, r, APLOGNO(02058)
                           "cannot steal context: bad filter status");
         }
     }
diff --git a/modules/arch/netware/mod_netware.c b/modules/arch/netware/mod_netware.c
index bfb1e87..1c5950d 100644
--- a/modules/arch/netware/mod_netware.c
+++ b/modules/arch/netware/mod_netware.c
@@ -144,7 +144,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
     new_cmd = apr_table_get(d->file_type_handlers, ext);
     e_info->detached = 1;
     if (new_cmd == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02135)
                   "Could not find a command associated with the %s extension", ext);
         return APR_EBADF;
     }
diff --git a/modules/arch/netware/mod_nw_ssl.c b/modules/arch/netware/mod_nw_ssl.c
index 3e20edb..22418d3 100644
--- a/modules/arch/netware/mod_nw_ssl.c
+++ b/modules/arch/netware/mod_nw_ssl.c
@@ -258,7 +258,7 @@ static int make_secure_socket(apr_pool_t *pconf, const struct sockaddr_in *serve
             (LPWSAPROTOCOL_INFO)&SecureProtoInfo, 0, 0);
 
     if (s == INVALID_SOCKET) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf, APLOGNO(02120)
                      "make_secure_socket: failed to get a socket for %s",
                      addr);
         return -1;
@@ -269,7 +269,7 @@ static int make_secure_socket(apr_pool_t *pconf, const struct sockaddr_in *serve
 
         if (WSAIoctl(s, SO_SSL_SET_FLAGS, (char *)&optParam,
             sizeof(optParam), NULL, 0, NULL, NULL, NULL)) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf, APLOGNO(02121)
                          "make_secure_socket: for %s, WSAIoctl: "
                          "(SO_SSL_SET_FLAGS)", addr);
             return -1;
@@ -284,7 +284,7 @@ static int make_secure_socket(apr_pool_t *pconf, const struct sockaddr_in *serve
 
     if (WSAIoctl(s, SO_SSL_SET_SERVER, (char *)&opts, sizeof(opts),
         NULL, 0, NULL, NULL, NULL) != 0) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf, APLOGNO(02122)
                      "make_secure_socket: for %s, WSAIoctl: "
                      "(SO_SSL_SET_SERVER)", addr);
         return -1;
@@ -295,7 +295,7 @@ static int make_secure_socket(apr_pool_t *pconf, const struct sockaddr_in *serve
 
         if(WSAIoctl(s, SO_SSL_SET_FLAGS, (char*)&optParam,
             sizeof(optParam), NULL, 0, NULL, NULL, NULL)) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf, APLOGNO(02123)
                          "make_secure_socket: for %s, WSAIoctl: "
                          "(SO_SSL_SET_FLAGS)", addr);
             return -1;
@@ -331,7 +331,7 @@ static int convert_secure_socket(conn_rec *c, apr_socket_t *csd)
                      NULL, 0, NULL, NULL, NULL);
         if (SOCKET_ERROR == rcode)
         {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server, APLOGNO(02124)
                      "Error: %d with ioctlsocket(flag SO_TLS_ENABLE)", WSAGetLastError());
                 return rcode;
         }
@@ -366,7 +366,7 @@ static int convert_secure_socket(conn_rec *c, apr_socket_t *csd)
 
     /* make sure that it was successful */
         if(SOCKET_ERROR == rcode ){
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server, APLOGNO(02125)
                      "Error: %d with ioctl (SO_TLS_SET_CLIENT)", WSAGetLastError());
         }
         return rcode;
@@ -388,7 +388,7 @@ static int SSLize_Socket(SOCKET socketHnd, char *key, request_rec *r)
     rcode = WSAIoctl(socketHnd, SO_TLS_SET_FLAGS, &ulFlag, sizeof(unsigned long), NULL, 0, NULL, NULL, NULL);
     if(rcode)
     {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(02126)
                      "Error: %d with WSAIoctl(SO_TLS_SET_FLAGS, SO_TLS_ENABLE)", WSAGetLastError());
         goto ERR;
     }
@@ -399,7 +399,7 @@ static int SSLize_Socket(SOCKET socketHnd, char *key, request_rec *r)
 
     if(rcode)
     {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(02127)
                      "Error: %d with WSAIoctl(SO_TLS_SET_FLAGS, SO_TLS_SERVER)", WSAGetLastError());
         goto ERR;
     }
@@ -437,7 +437,7 @@ static int SSLize_Socket(SOCKET socketHnd, char *key, request_rec *r)
                      NULL,
                      NULL);
     if(SOCKET_ERROR == rcode) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(02128)
                      "Error: %d with WSAIoctl(SO_TLS_SET_SERVER)", WSAGetLastError());
         goto ERR;
     }
@@ -785,7 +785,7 @@ static int nwssl_post_config(apr_pool_t *pconf, apr_pool_t *plog,
                 lr->sd = sd;
                 if ((status = apr_sockaddr_info_get(&lr->bind_addr, sl->addr, APR_UNSPEC, sl->port, 0,
                                               s->process->pool)) != APR_SUCCESS) {
-                    ap_log_perror(APLOG_MARK, APLOG_CRIT, status, pconf,
+                    ap_log_perror(APLOG_MARK, APLOG_CRIT, status, pconf, APLOGNO(02129)
                                  "alloc_listener: failed to set up sockaddr for %s:%d", sl->addr, sl->port);
                     return HTTP_INTERNAL_SERVER_ERROR;
                 }
@@ -808,7 +808,7 @@ static int nwssl_post_config(apr_pool_t *pconf, apr_pool_t *plog,
             }
         }
         if (!found) {
-            ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, plog,
+            ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, plog, APLOGNO(02130)
                          "No Listen directive found for upgradeable listener %s:%d", slu->addr, slu->port);
         }
     }
@@ -1167,7 +1167,7 @@ static apr_status_t ssl_io_filter_Upgrade(ap_filter_t *f,
         csd = csd_data->csd;
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(02131)
                      "Unable to get upgradeable socket handle");
         return ap_pass_brigade(f->next, bb);
     }
@@ -1184,7 +1184,7 @@ static apr_status_t ssl_io_filter_Upgrade(ap_filter_t *f,
 
     rv = ap_pass_brigade(f->next, upgradebb);
     if (rv) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02132)
                       "could not send interim 101 Upgrade response");
         return AP_FILTER_ERROR;
     }
@@ -1202,12 +1202,12 @@ static apr_status_t ssl_io_filter_Upgrade(ap_filter_t *f,
         }
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(02133)
                      "Upgradeable socket handle not found");
         return AP_FILTER_ERROR;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server, APLOGNO(02134)
                  "Awaiting re-negotiation handshake");
 
     /* Now that we have initialized the ssl connection which added the ssl_io_filter,
diff --git a/modules/arch/unix/mod_privileges.c b/modules/arch/unix/mod_privileges.c
index a04a2c5..87a841d 100644
--- a/modules/arch/unix/mod_privileges.c
+++ b/modules/arch/unix/mod_privileges.c
@@ -150,22 +150,22 @@ static apr_status_t privileges_end_req(void *data)
     /* if either user or group are not the default, restore them */
     if (cfg->uid || cfg->gid) {
         if (setppriv(PRIV_ON, PRIV_EFFECTIVE, priv_setid) == -1) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02136)
                           "PRIV_ON failed restoring default user/group");
         }
         if (cfg->uid && (setuid(ap_unixd_config.user_id) == -1)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02137)
                           "Error restoring default userid");
         }
         if (cfg->gid && (setgid(ap_unixd_config.group_id) == -1)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02138)
                           "Error restoring default group");
         }
     }
 
     /* restore default privileges */
     if (setppriv(PRIV_SET, PRIV_EFFECTIVE, priv_default) == -1) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, APLOGNO(02139)
                       "Error restoring default privileges");
     }
     return APR_SUCCESS;
@@ -216,14 +216,14 @@ static int privileges_req(request_rec *r)
        rv = apr_proc_fork(&proc, r->pool);
         switch (rv) {
         case APR_INPARENT:
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02140)
                           "parent waiting for child");
             /* FIXME - does the child need to run synchronously?
              * esp. if we enable mod_privileges with threaded MPMs?
              * We do need at least to ensure r outlives the child.
              */
             rv = apr_proc_wait(&proc, &exitcode, &exitwhy, APR_WAIT);
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "parent: child %s",
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02141) "parent: child %s",
                           (rv == APR_CHILD_DONE) ? "done" : "notdone");
 
             /* The child has taken responsibility for reading all input
@@ -239,10 +239,10 @@ static int privileges_req(request_rec *r)
              */
             return DONE;
         case APR_INCHILD:
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "In child!");
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02142) "In child!");
             break;  /* now we'll drop privileges in the child */
         default:
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02143)
                           "Failed to fork secure child process!");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -256,38 +256,38 @@ static int privileges_req(request_rec *r)
     /* set user and group if configured */
     if (cfg->uid || cfg->gid) {
         if (setppriv(PRIV_ON, PRIV_EFFECTIVE, priv_setid) == -1) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02144)
                           "No privilege to set user/group");
         }
         /* if we should be able to set these but can't, it could be
          * a serious security issue.  Bail out rather than risk it!
          */
         if (cfg->uid && (setuid(cfg->uid) == -1)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02145)
                           "Error setting userid");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
         if (cfg->gid && (setgid(cfg->gid) == -1)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02146)
                           "Error setting group");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
     }
     /* set vhost's privileges */
     if (setppriv(PRIV_SET, PRIV_EFFECTIVE, cfg->priv) == -1) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, APLOGNO(02147)
                       "Error setting effective privileges");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     /* ... including those of any subprocesses */
     if (setppriv(PRIV_SET, PRIV_INHERITABLE, cfg->child_priv) == -1) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, APLOGNO(02148)
                       "Error setting inheritable privileges");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
     if (setppriv(PRIV_SET, PRIV_LIMIT, cfg->child_priv) == -1) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, APLOGNO(02149)
                       "Error setting limit privileges");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -295,7 +295,7 @@ static int privileges_req(request_rec *r)
     /* If we're in a child process, drop down PPERM too */
     if (fork_req) {
         if (setppriv(PRIV_SET, PRIV_PERMITTED, cfg->priv) == -1) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, APLOGNO(02150)
                           "Error setting permitted privileges");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -304,7 +304,7 @@ static int privileges_req(request_rec *r)
     return OK;
 }
 #define PDROP_CHECK(x) if (x == -1) { \
-        ap_log_error(APLOG_MARK, APLOG_CRIT, errno, s, \
+        ap_log_error(APLOG_MARK, APLOG_CRIT, errno, s, APLOGNO(02151) \
                      "Error dropping privileges"); \
         return !OK; \
     }
@@ -380,7 +380,7 @@ static int privileges_postconf(apr_pool_t *pconf, apr_pool_t *plog,
                               apr_pool_cleanup_null);
     priv_emptyset(priv_setid);
     if (priv_addset(priv_setid, PRIV_PROC_SETID) == -1) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, errno, ptemp,
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, errno, ptemp, APLOGNO(02152)
                       "priv_addset");
         return !OK;
     }
@@ -393,13 +393,13 @@ static int privileges_init(apr_pool_t *pconf, apr_pool_t *plog,
     int threaded;
     int rv = ap_mpm_query(AP_MPMQ_IS_THREADED, &threaded);
     if (rv != APR_SUCCESS) {
-        ap_log_perror(APLOG_MARK, APLOG_NOTICE, rv, ptemp,
+        ap_log_perror(APLOG_MARK, APLOG_NOTICE, rv, ptemp, APLOGNO(02153)
                       "mod_privileges: unable to determine MPM characteristics."
                       "  Please ensure you are using a non-threaded MPM "
                       "with this module.");
     }
     if (threaded) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, ptemp,
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, rv, ptemp, APLOGNO(02154)
                       "mod_privileges is not compatible with a threaded MPM.");
         return !OK;
     }
diff --git a/modules/arch/unix/mod_unixd.c b/modules/arch/unix/mod_unixd.c
index d30ac4f..f6e9500 100644
--- a/modules/arch/unix/mod_unixd.c
+++ b/modules/arch/unix/mod_unixd.c
@@ -96,7 +96,7 @@ static int set_group_privs(void)
             uid_t uid = atol(&ap_unixd_config.user_name[1]);
 
             if ((ent = getpwuid(uid)) == NULL) {
-                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02155)
                          "getpwuid: couldn't determine user name from uid %ld, "
                          "you probably need to modify the User directive",
                          (long)uid);
@@ -115,7 +115,7 @@ static int set_group_privs(void)
          * setgid() is known to zap the group list.
          */
         if (setgid(ap_unixd_config.group_id) == -1) {
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02156)
                         "setgid: unable to set group id to Group %ld",
                         (long)ap_unixd_config.group_id);
             return -1;
@@ -124,7 +124,7 @@ static int set_group_privs(void)
         /* Reset `groups' attributes. */
 
         if (initgroups(name, ap_unixd_config.group_id) == -1) {
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02157)
                         "initgroups: unable to set groups for User %s "
                         "and Group %ld", name, (long)ap_unixd_config.group_id);
             return -1;
@@ -147,28 +147,28 @@ unixd_drop_privileges(apr_pool_t *pool, server_rec *s)
     if (NULL != ap_unixd_config.chroot_dir) {
         if (geteuid()) {
             rv = errno;
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02158)
                          "Cannot chroot when not started as root");
             return rv;
         }
 
         if (chdir(ap_unixd_config.chroot_dir) != 0) {
             rv = errno;
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02159)
                          "Can't chdir to %s", ap_unixd_config.chroot_dir);
             return rv;
         }
 
         if (chroot(ap_unixd_config.chroot_dir) != 0) {
             rv = errno;
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02160)
                          "Can't chroot to %s", ap_unixd_config.chroot_dir);
             return rv;
         }
 
         if (chdir("/") != 0) {
             rv = errno;
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02161)
                          "Can't chdir to new root");
             return rv;
         }
@@ -181,7 +181,7 @@ unixd_drop_privileges(apr_pool_t *pool, server_rec *s)
 #endif
         setuid(ap_unixd_config.user_id) == -1)) {
         rv = errno;
-        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02162)
                     "setuid: unable to change to uid: %ld",
                     (long) ap_unixd_config.user_id);
         return rv;
@@ -191,7 +191,7 @@ unixd_drop_privileges(apr_pool_t *pool, server_rec *s)
     if (ap_coredumpdir_configured) {
         if (prctl(PR_SET_DUMPABLE, 1)) {
             rv = errno;
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02163)
                          "set dumpable failed - this child will not coredump"
                          " after software errors");
             return rv;
@@ -327,22 +327,22 @@ AP_DECLARE(int) ap_unixd_setup_child(void)
 
     if (NULL != ap_unixd_config.chroot_dir) {
         if (geteuid()) {
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02164)
                          "Cannot chroot when not started as root");
             return -1;
         }
         if (chdir(ap_unixd_config.chroot_dir) != 0) {
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02165)
                          "Can't chdir to %s", ap_unixd_config.chroot_dir);
             return -1;
         }
         if (chroot(ap_unixd_config.chroot_dir) != 0) {
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02166)
                          "Can't chroot to %s", ap_unixd_config.chroot_dir);
             return -1;
         }
         if (chdir("/") != 0) {
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02167)
                          "Can't chdir to new root");
             return -1;
         }
@@ -354,7 +354,7 @@ AP_DECLARE(int) ap_unixd_setup_child(void)
         os_init_job_environment(NULL, ap_unixd_config.user_name, ap_exists_config_define("DEBUG")) != 0 ||
 #endif
         setuid(ap_unixd_config.user_id) == -1)) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02168)
                     "setuid: unable to change to uid: %ld",
                     (long) ap_unixd_config.user_id);
         return -1;
@@ -363,7 +363,7 @@ AP_DECLARE(int) ap_unixd_setup_child(void)
     /* this applies to Linux 2.4+ */
     if (ap_coredumpdir_configured) {
         if (prctl(PR_SET_DUMPABLE, 1)) {
-            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL, APLOGNO(02169)
                          "set dumpable failed - this child will not coredump"
                          " after software errors");
         }
diff --git a/modules/arch/win32/mod_isapi.c b/modules/arch/win32/mod_isapi.c
index 873d0f0..fd2f1f7 100644
--- a/modules/arch/win32/mod_isapi.c
+++ b/modules/arch/win32/mod_isapi.c
@@ -136,18 +136,18 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
      */
     fspec = ap_server_root_relative(cmd->pool, filename);
     if (!fspec) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, APR_EBADPATH, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, APR_EBADPATH, cmd->server, APLOGNO(02103)
                      "invalid module path, skipping %s", filename);
         return NULL;
     }
     if ((rv = apr_stat(&tmp, fspec, APR_FINFO_TYPE,
                       cmd->temp_pool)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, cmd->server, APLOGNO(02104)
                      "unable to stat, skipping %s", fspec);
         return NULL;
     }
     if (tmp.filetype != APR_REG) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(02105)
                      "not a regular file, skipping %s", fspec);
         return NULL;
     }
@@ -155,7 +155,7 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
     /* Load the extention as cached (with null request_rec) */
     rv = isapi_lookup(cmd->pool, cmd->server, NULL, fspec, &isa);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, cmd->server, APLOGNO(02106)
                      "unable to cache, skipping %s", fspec);
         return NULL;
     }
@@ -271,7 +271,7 @@ static apr_status_t isapi_load(apr_pool_t *p, server_rec *s, isapi_loaded *isa)
     rv = apr_dso_load(&isa->handle, isa->filename, p);
     if (rv)
     {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(02107)
                      "failed to load %s", isa->filename);
         isa->handle = NULL;
         return rv;
@@ -281,7 +281,7 @@ static apr_status_t isapi_load(apr_pool_t *p, server_rec *s, isapi_loaded *isa)
                      "GetExtensionVersion");
     if (rv)
     {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(02108)
                      "missing GetExtensionVersion() in %s",
                      isa->filename);
         apr_dso_unload(isa->handle);
@@ -293,7 +293,7 @@ static apr_status_t isapi_load(apr_pool_t *p, server_rec *s, isapi_loaded *isa)
                      "HttpExtensionProc");
     if (rv)
     {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(02109)
                      "missing HttpExtensionProc() in %s",
                      isa->filename);
         apr_dso_unload(isa->handle);
@@ -309,7 +309,7 @@ static apr_status_t isapi_load(apr_pool_t *p, server_rec *s, isapi_loaded *isa)
     /* Run GetExtensionVersion() */
     if (!(isa->GetExtensionVersion)(isa->isapi_version)) {
         apr_status_t rv = apr_get_os_error();
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(02110)
                      "failed call to GetExtensionVersion() in %s",
                      isa->filename);
         apr_dso_unload(isa->handle);
@@ -771,7 +771,7 @@ static apr_ssize_t send_response_header(isapi_cid *cid,
         cid->r->status = HTTP_OK;
         cid->r->status_line = ap_get_status_line(cid->r->status);
         cid->ecb->dwHttpStatusCode = cid->r->status;
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, cid->r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, cid->r, APLOGNO(02111)
                 "Could not determine HTTP response code; using %d",
                 cid->r->status);
     }
@@ -1572,7 +1572,7 @@ static apr_status_t isapi_handler (request_rec *r)
         }
 
         if (!cid->completed || (rv != APR_SUCCESS)) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02112)
                           "Failed to create completion mutex");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -1583,7 +1583,7 @@ static apr_status_t isapi_handler (request_rec *r)
 
     /* Check for a log message - and log it */
     if (cid->ecb->lpszLogData && *cid->ecb->lpszLogData)
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02113)
                       "%s: %s", r->filename, cid->ecb->lpszLogData);
 
     switch(rv) {
@@ -1614,7 +1614,7 @@ static apr_status_t isapi_handler (request_rec *r)
                 break;
             }
             else if (cid->dconf.log_unsupported) {
-                 ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                 ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02114)
                                "asynch I/O result HSE_STATUS_PENDING "
                                "from HttpExtensionProc() is not supported: %s",
                                r->filename);
@@ -1625,14 +1625,14 @@ static apr_status_t isapi_handler (request_rec *r)
         case HSE_STATUS_ERROR:
             /* end response if we have yet to do so.
              */
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, apr_get_os_error(), r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, apr_get_os_error(), r, APLOGNO(02115)
                           "HSE_STATUS_ERROR result from "
                           "HttpExtensionProc(): %s", r->filename);
             r->status = HTTP_INTERNAL_SERVER_ERROR;
             break;
 
         default:
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, apr_get_os_error(), r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, apr_get_os_error(), r, APLOGNO(02116)
                           "unrecognized result code %d "
                           "from HttpExtensionProc(): %s ",
                           rv, r->filename);
@@ -1654,7 +1654,7 @@ static apr_status_t isapi_handler (request_rec *r)
         cid->response_sent = 1;
 
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(02117)
                           "ap_pass_brigade failed to "
                           "complete the response: %s ", r->filename);
         }
@@ -1687,14 +1687,14 @@ static int isapi_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pte
 
     apr_pool_create_ex(&loaded.pool, pconf, NULL, NULL);
     if (!loaded.pool) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EGENERAL, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EGENERAL, NULL, APLOGNO(02118)
                      "could not create the isapi cache pool");
         return APR_EGENERAL;
     }
 
     loaded.hash = apr_hash_make(loaded.pool);
     if (!loaded.hash) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(02119)
                      "Failed to create module cache");
         return APR_EGENERAL;
     }
diff --git a/modules/arch/win32/mod_win32.c b/modules/arch/win32/mod_win32.c
index ec6809b..d9ef73c 100644
--- a/modules/arch/win32/mod_win32.c
+++ b/modules/arch/win32/mod_win32.c
@@ -439,12 +439,12 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
          */
         if ((rv = apr_file_open(&fh, *cmd, APR_READ | APR_BUFFERED,
                                  APR_OS_DEFAULT, r->pool)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02100)
                           "Failed to open cgi file %s for testing", *cmd);
             return rv;
         }
         if ((rv = apr_file_read(fh, buffer, &bytes)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02101)
                           "Failed to read cgi file %s for testing", *cmd);
             return rv;
         }
@@ -505,7 +505,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
         }
     }
     if (!interpreter) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02102)
                       "%s is not executable; ensure interpreted scripts have "
                       "\"#!\" or \"'!\" first line", *cmd);
         return APR_EBADF;
diff --git a/modules/cache/cache_storage.c b/modules/cache/cache_storage.c
index dd0433e..e936389 100644
--- a/modules/cache/cache_storage.c
+++ b/modules/cache/cache_storage.c
@@ -46,7 +46,7 @@ int cache_remove_url(cache_request_rec *cache, request_rec *r)
     if (!h) {
        return OK;
     }
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00691)
                  "cache: Removing url %s from the cache", h->cache_obj->key);
 
     /* for each specified cache type, delete the URL */
@@ -78,7 +78,7 @@ int cache_create_entity(cache_request_rec *cache, request_rec *r,
 
     if (!cache) {
         /* This should never happen */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r, APLOGNO(00692)
                 "cache: No cache request information available for key"
                 " generation");
         return APR_EGENERAL;
@@ -203,7 +203,7 @@ int cache_select(cache_request_rec *cache, request_rec *r)
 
     if (!cache) {
         /* This should never happen */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r, APLOGNO(00693)
                 "cache: No cache request information available for key"
                 " generation");
         return DECLINED;
@@ -283,7 +283,7 @@ int cache_select(cache_request_rec *cache, request_rec *r)
                 else {
                     /* headers do not match, so Vary failed */
                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,
-                            r, "cache_select_url(): Vary header mismatch.");
+                            r, APLOGNO(00694) "cache_select_url(): Vary header mismatch.");
                     mismatch = 1;
                 }
             }
@@ -317,7 +317,7 @@ int cache_select(cache_request_rec *cache, request_rec *r)
                         r->headers_in);
                 cache->stale_handle = h;
 
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00695)
                         "Cached response for %s isn't fresh.  Adding/replacing "
                         "conditional request headers.", r->uri);
 
@@ -380,7 +380,7 @@ int cache_select(cache_request_rec *cache, request_rec *r)
 
     /* if Cache-Control: only-if-cached, and not cached, return 504 */
     if (cache->control_in.only_if_cached) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00696)
                 "cache: 'only-if-cached' requested and no cached entity, "
                 "returning 504 Gateway Timeout for: %s", r->uri);
         return HTTP_GATEWAY_TIME_OUT;
@@ -406,7 +406,7 @@ int cache_invalidate(cache_request_rec *cache, request_rec *r)
 
     if (!cache) {
         /* This should never happen */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r, APLOGNO(00697)
                 "cache: No cache request information available for key"
                 " generation");
         return DECLINED;
@@ -668,7 +668,7 @@ apr_status_t cache_generate_key_default(request_rec *r, apr_pool_t* p,
      * resource in the cache under a key where it is never found by the quick
      * handler during following requests.
      */
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00698)
             "cache: Key for entity %s?%s is %s", r->uri,
             r->parsed_uri.query, *key);
 
diff --git a/modules/cache/cache_util.c b/modules/cache/cache_util.c
index a735cef..8a1050d 100644
--- a/modules/cache/cache_util.c
+++ b/modules/cache/cache_util.c
@@ -301,7 +301,7 @@ apr_status_t cache_try_lock(cache_server_conf *conf, cache_request_rec *cache,
     path = apr_pstrcat(r->pool, conf->lockpath, dir, NULL);
     if (APR_SUCCESS != (status = apr_dir_make_recursive(path,
             APR_UREAD|APR_UWRITE|APR_UEXECUTE, r->pool))) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00778)
                 "Could not create a cache lock directory: %s",
                 path);
         return status;
@@ -313,14 +313,14 @@ apr_status_t cache_try_lock(cache_server_conf *conf, cache_request_rec *cache,
     status = apr_stat(&finfo, lockname,
                 APR_FINFO_MTIME | APR_FINFO_NLINK, r->pool);
     if (!(APR_STATUS_IS_ENOENT(status)) && APR_SUCCESS != status) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EEXIST, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EEXIST, r, APLOGNO(00779)
                 "Could not stat a cache lock file: %s",
                 lockname);
         return status;
     }
     if ((status == APR_SUCCESS) && (((now - finfo.mtime) > conf->lockmaxage)
                                   || (now < finfo.mtime))) {
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, status, r, APLOGNO(00780)
                 "Cache lock file for '%s' too old, removing: %s",
                 r->uri, lockname);
         apr_file_remove(lockname, r->pool);
@@ -530,7 +530,7 @@ int cache_check_freshness(cache_handle_t *h, cache_request_rec *cache,
             return 0;
         }
 
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00781)
                 "Incoming request is asking for a uncached version of "
                 "%s, but we have been configured to ignore it and "
                 "serve a cached response anyway",
@@ -703,7 +703,7 @@ int cache_check_freshness(cache_handle_t *h, cache_request_rec *cache,
     status = cache_try_lock(conf, cache, r);
     if (APR_SUCCESS == status) {
         /* we obtained a lock, follow the stale path */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00782)
                 "Cache lock obtained for stale cached URL, "
                 "revalidating entry: %s",
                 r->unparsed_uri);
@@ -711,7 +711,7 @@ int cache_check_freshness(cache_handle_t *h, cache_request_rec *cache,
     }
     else if (APR_EEXIST == status) {
         /* lock already exists, return stale data anyway, with a warning */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00783)
                 "Cache already locked for stale cached URL, "
                 "pretend it is fresh: %s",
                 r->unparsed_uri);
@@ -728,7 +728,7 @@ int cache_check_freshness(cache_handle_t *h, cache_request_rec *cache,
     }
     else {
         /* some other error occurred, just treat the object as stale */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00784)
                 "Attempt to obtain a cache lock for stale "
                 "cached URL failed, revalidating entry anyway: %s",
                 r->unparsed_uri);
diff --git a/modules/cache/mod_cache.c b/modules/cache/mod_cache.c
index b95ded5..b863b96 100644
--- a/modules/cache/mod_cache.c
+++ b/modules/cache/mod_cache.c
@@ -117,7 +117,7 @@ static int cache_quick_handler(request_rec *r, int lookup)
      */
     if (r->method_number != M_GET) {
 
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00748)
                 "Invalidating all cached entities in response to '%s' request for %s",
                 r->method, r->uri);
 
@@ -163,7 +163,7 @@ static int cache_quick_handler(request_rec *r, int lookup)
                      */
                     if (r->main) {
                         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,
-                                r, "Adding CACHE_SAVE_SUBREQ filter for %s",
+                                r, APLOGNO(00749) "Adding CACHE_SAVE_SUBREQ filter for %s",
                                 r->uri);
                         cache->save_filter = ap_add_output_filter_handle(
                                 cache_save_subreq_filter_handle, cache, r,
@@ -171,7 +171,7 @@ static int cache_quick_handler(request_rec *r, int lookup)
                     }
                     else {
                         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,
-                                r, "Adding CACHE_SAVE filter for %s",
+                                r, APLOGNO(00750) "Adding CACHE_SAVE filter for %s",
                                 r->uri);
                         cache->save_filter = ap_add_output_filter_handle(
                                 cache_save_filter_handle, cache, r,
@@ -180,7 +180,7 @@ static int cache_quick_handler(request_rec *r, int lookup)
 
                     apr_pool_userdata_setn(cache, CACHE_CTX_KEY, NULL, r->pool);
 
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00751)
                             "Adding CACHE_REMOVE_URL filter for %s",
                             r->uri);
 
@@ -197,14 +197,14 @@ static int cache_quick_handler(request_rec *r, int lookup)
                 }
                 else {
                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv,
-                            r, "Cache locked for url, not caching "
+                            r, APLOGNO(00752) "Cache locked for url, not caching "
                             "response: %s", r->uri);
                 }
             }
             else {
                 if (cache->stale_headers) {
                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,
-                            r, "Restoring request headers for %s",
+                            r, APLOGNO(00753) "Restoring request headers for %s",
                             r->uri);
 
                     r->headers_in = cache->stale_headers;
@@ -226,7 +226,7 @@ static int cache_quick_handler(request_rec *r, int lookup)
      * the headers. */
     if (lookup) {
         if (cache->stale_headers) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00754)
                     "Restoring request headers.");
             r->headers_in = cache->stale_headers;
         }
@@ -390,7 +390,7 @@ static int cache_handler(request_rec *r)
      */
     if (r->method_number != M_GET) {
 
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00755)
                 "Invalidating all cached entities in response to '%s' request for %s",
                 r->method, r->uri);
 
@@ -436,13 +436,13 @@ static int cache_handler(request_rec *r)
                  */
                 if (r->main) {
                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,
-                            r, "Adding CACHE_SAVE_SUBREQ filter for %s",
+                            r, APLOGNO(00756) "Adding CACHE_SAVE_SUBREQ filter for %s",
                             r->uri);
                     cache_save_handle = cache_save_subreq_filter_handle;
                 }
                 else {
                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,
-                            r, "Adding CACHE_SAVE filter for %s",
+                            r, APLOGNO(00757) "Adding CACHE_SAVE filter for %s",
                             r->uri);
                     cache_save_handle = cache_save_filter_handle;
                 }
@@ -465,7 +465,7 @@ static int cache_handler(request_rec *r)
                         cache_filter_handle, cache_save_handle,
                         ap_get_input_filter_handle("SUBREQ_CORE"))) {
                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,
-                            r, "Replacing CACHE with CACHE_SAVE "
+                            r, APLOGNO(00758) "Replacing CACHE with CACHE_SAVE "
                             "filter for %s", r->uri);
                 }
 
@@ -475,7 +475,7 @@ static int cache_handler(request_rec *r)
 
                 apr_pool_userdata_setn(cache, CACHE_CTX_KEY, NULL, r->pool);
 
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00759)
                         "Adding CACHE_REMOVE_URL filter for %s",
                         r->uri);
 
@@ -493,7 +493,7 @@ static int cache_handler(request_rec *r)
             }
             else {
                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv,
-                        r, "Cache locked for url, not caching "
+                        r, APLOGNO(00760) "Cache locked for url, not caching "
                         "response: %s", r->uri);
             }
         }
@@ -541,7 +541,7 @@ static int cache_handler(request_rec *r)
     if (cache_replace_filter(r->output_filters, cache_filter_handle,
             cache_out_handle, ap_get_input_filter_handle("SUBREQ_CORE"))) {
         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,
-                r, "Replacing CACHE with CACHE_OUT filter for %s",
+                r, APLOGNO(00761) "Replacing CACHE with CACHE_OUT filter for %s",
                 r->uri);
     }
 
@@ -586,13 +586,13 @@ static int cache_out_filter(ap_filter_t *f, apr_bucket_brigade *in)
     if (!cache) {
         /* user likely configured CACHE_OUT manually; they should use mod_cache
          * configuration to do that */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00762)
                 "CACHE/CACHE_OUT filter enabled while caching is disabled, ignoring");
         ap_remove_output_filter(f);
         return ap_pass_brigade(f->next, in);
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00763)
             "cache: running CACHE_OUT filter");
 
     /* clean out any previous response up to EOS, if any */
@@ -614,7 +614,7 @@ static int cache_out_filter(ap_filter_t *f, apr_bucket_brigade *in)
             /* This filter is done once it has served up its content */
             ap_remove_output_filter(f);
 
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00764)
                     "cache: serving %s", r->uri);
             return ap_pass_brigade(f->next, in);
 
@@ -649,7 +649,7 @@ static int cache_save_store(ap_filter_t *f, apr_bucket_brigade *in,
 
         rv = cache->provider->store_body(cache->handle, f->r, in, cache->out);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, f->r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, f->r, APLOGNO(00765)
                     "cache: Cache provider's store_body failed!");
             ap_remove_output_filter(f);
 
@@ -687,7 +687,7 @@ static int cache_save_store(ap_filter_t *f, apr_bucket_brigade *in,
                 /* oops, no data out, but not all data read in either, be
                  * safe and stand down to prevent a spin.
                  */
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, f->r, APLOGNO(00766)
                         "cache: Cache provider's store_body returned an "
                         "empty brigade, but didn't consume all of the"
                         "input brigade, standing down to prevent a spin");
@@ -752,7 +752,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
         /* user likely configured CACHE_SAVE manually; they should really use
          * mod_cache configuration to do that
          */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00767)
                 "CACHE/CACHE_SAVE filter enabled while caching is disabled, ignoring");
         ap_remove_output_filter(f);
         return ap_pass_brigade(f->next, in);
@@ -1101,7 +1101,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
     }
 
     if (reason) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00768)
                 "cache: %s not cached. Reason: %s", r->unparsed_uri,
                 reason);
 
@@ -1220,13 +1220,13 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
         return ap_pass_brigade(f->next, in);
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00769)
             "cache: Caching url: %s", r->unparsed_uri);
 
     /* We are actually caching this response. So it does not
      * make sense to remove this entity any more.
      */
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00770)
             "cache: Removing CACHE_REMOVE_URL filter.");
     ap_remove_output_filter(cache->remove_url_filter);
 
@@ -1273,7 +1273,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
         /* if it's in the future, then replace by date */
         lastmod = date;
         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0,
-                r, "cache: Last modified is in the future, "
+                r, APLOGNO(00771) "cache: Last modified is in the future, "
                 "replacing with now");
     }
 
@@ -1404,7 +1404,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
          * the body it is safe to try and remove the url from the cache.
          */
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(00772)
                     "cache: updating headers with store_headers failed. "
                     "Removing cached url.");
 
@@ -1413,7 +1413,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
                 /* Probably a mod_cache_disk cache area has been (re)mounted
                  * read-only, or that there is a permissions problem.
                  */
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(00773)
                         "cache: attempt to remove url from cache unsuccessful.");
             }
 
@@ -1439,7 +1439,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
     }
 
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(00774)
                 "cache: store_headers failed");
 
         /* we've got a cache miss! tell anyone who cares */
@@ -1493,7 +1493,7 @@ static int cache_remove_url_filter(ap_filter_t *f, apr_bucket_brigade *in)
          * 1. Remove ourselves
          * 2. Do nothing and bail out
          */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00775)
                 "cache: CACHE_REMOVE_URL enabled unexpectedly");
         ap_remove_output_filter(f);
         return ap_pass_brigade(f->next, in);
@@ -1534,13 +1534,13 @@ static int cache_filter(ap_filter_t *f, apr_bucket_brigade *in)
 
     /* was the quick handler enabled */
     if (conf->quick) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, f->r, APLOGNO(00776)
                 "cache: CACHE filter was added in quick handler mode and "
                 "will be ignored: %s", f->r->unparsed_uri);
     }
     /* otherwise we may have been bypassed, nothing to see here */
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r, APLOGNO(00777)
                 "cache: CACHE filter was added twice, or was added where "
                 "the cache has been bypassed and will be ignored: %s",
                 f->r->unparsed_uri);
diff --git a/modules/cache/mod_cache_disk.c b/modules/cache/mod_cache_disk.c
index 87fdef6..0c65c17 100644
--- a/modules/cache/mod_cache_disk.c
+++ b/modules/cache/mod_cache_disk.c
@@ -173,7 +173,7 @@ static apr_status_t file_cache_el_final(disk_cache_conf *conf, disk_cache_file_t
 
         rv = safe_file_rename(conf, file->tempfile, file->file, file->pool);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00699)
                     "rename tempfile to file failed:"
                     " %s -> %s", file->tempfile, file->file);
             apr_file_remove(file->tempfile, file->pool);
@@ -350,7 +350,7 @@ static int create_entity(cache_handle_t *h, request_rec *r, const char *key, apr
 
     /* we don't support caching of range requests (yet) */
     if (r->status == HTTP_PARTIAL_CONTENT) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00700)
                 "URL %s partial content response not cached",
                 key);
         return DECLINED;
@@ -358,14 +358,14 @@ static int create_entity(cache_handle_t *h, request_rec *r, const char *key, apr
 
     /* Note, len is -1 if unknown so don't trust it too hard */
     if (len > dconf->maxfs) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00701)
                 "URL %s failed the size check "
                 "(%" APR_OFF_T_FMT " > %" APR_OFF_T_FMT ")",
                 key, len, dconf->maxfs);
         return DECLINED;
     }
     if (len >= 0 && len < dconf->minfs) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00702)
                 "URL %s failed the size check "
                 "(%" APR_OFF_T_FMT " < %" APR_OFF_T_FMT ")",
                 key, len, dconf->minfs);
@@ -424,7 +424,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
     if (conf->cache_root == NULL) {
         if (!error_logged) {
             error_logged = 1;
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00703)
                     "Cannot cache files to disk without a CacheRoot specified.");
         }
         return DECLINED;
@@ -464,7 +464,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
         varray = apr_array_make(r->pool, 5, sizeof(char*));
         rc = read_array(r, varray, dobj->vary.fd);
         if (rc != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(00704)
                     "Cannot parse vary header file: %s",
                     dobj->vary.file);
             apr_file_close(dobj->vary.fd);
@@ -485,7 +485,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
         }
     }
     else if (format != DISK_FORMAT_VERSION) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00705)
                 "File '%s' has a version mismatch. File had version: %d.",
                 dobj->vary.file, format);
         apr_file_close(dobj->vary.fd);
@@ -521,7 +521,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
     /* Read the bytes to setup the cache_info fields */
     rc = file_cache_recall_mydata(dobj->hdrs.fd, info, dobj, r);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(00706)
                 "Cannot read header file %s", dobj->hdrs.file);
         apr_file_close(dobj->hdrs.fd);
         return DECLINED;
@@ -531,7 +531,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
 
     /* Is this a cached HEAD request? */
     if (dobj->disk_info.header_only && !r->header_only) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(00707)
                 "HEAD request cached, non-HEAD requested, ignoring: %s",
                 dobj->hdrs.file);
         return DECLINED;
@@ -549,7 +549,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
 #endif
         rc = apr_file_open(&dobj->data.fd, dobj->data.file, flags, 0, r->pool);
         if (rc != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(00708)
                     "Cannot open data file %s", dobj->data.file);
             apr_file_close(dobj->hdrs.fd);
             return DECLINED;
@@ -566,7 +566,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
                 dobj->disk_info.device == finfo.device) {
 
             /* Initialize the cache_handle callback functions */
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00709)
                     "Recalled cached URL info header %s", dobj->name);
 
             /* make the configuration stick */
@@ -587,7 +587,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
     }
 
     /* Oh dear, no luck matching header to the body */
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00710)
             "Cached URL info header '%s' didn't match body, ignoring this entry",
             dobj->name);
 
@@ -614,7 +614,7 @@ static int remove_url(cache_handle_t *h, request_rec *r)
 
     /* Delete headers file */
     if (dobj->hdrs.file) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00711)
                 "Deleting %s from cache.", dobj->hdrs.file);
 
         rc = apr_file_remove(dobj->hdrs.file, r->pool);
@@ -622,7 +622,7 @@ static int remove_url(cache_handle_t *h, request_rec *r)
             /* Will only result in an output if httpd is started with -e debug.
              * For reason see log_error_core for the case s == NULL.
              */
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rc, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rc, r, APLOGNO(00712)
                     "Failed to delete headers file %s from cache.",
                     dobj->hdrs.file);
             return DECLINED;
@@ -631,7 +631,7 @@ static int remove_url(cache_handle_t *h, request_rec *r)
 
     /* Delete data file */
     if (dobj->data.file) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00713)
                 "Deleting %s from cache.", dobj->data.file);
 
         rc = apr_file_remove(dobj->data.file, r->pool);
@@ -639,7 +639,7 @@ static int remove_url(cache_handle_t *h, request_rec *r)
             /* Will only result in an output if httpd is started with -e debug.
              * For reason see log_error_core for the case s == NULL.
              */
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rc, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rc, r, APLOGNO(00714)
                     "Failed to delete data file %s from cache.",
                     dobj->data.file);
             return DECLINED;
@@ -671,7 +671,7 @@ static int remove_url(cache_handle_t *h, request_rec *r)
              * we won't either delete or go above our cache root.
              */
             for (q = dir + dobj->root_len; *q ; ) {
-                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00715)
                         "Deleting directory %s from cache", dir);
 
                  rc = apr_dir_remove(dir, r->pool);
@@ -697,7 +697,7 @@ static apr_status_t read_array(request_rec *r, apr_array_header_t* arr,
     while (1) {
         rv = apr_file_gets(w, MAX_STRING_LEN - 1, file);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00716)
                           "Premature end of vary array.");
             return rv;
         }
@@ -766,7 +766,7 @@ static apr_status_t read_table(cache_handle_t *handle, request_rec *r,
         /* ### What about APR_EOF? */
         rv = apr_file_gets(w, MAX_STRING_LEN - 1, file);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00717)
                           "Premature end of cache headers.");
             return rv;
         }
@@ -809,7 +809,7 @@ static apr_status_t read_table(cache_handle_t *handle, request_rec *r,
                     ++maybeASCII;
             }
             if (maybeASCII > maybeEBCDIC) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00718)
                         "CGI Interface Error: Script headers apparently ASCII: (CGI = %s)",
                         r->filename);
                 inbytes_left = outbytes_left = cp - w;
@@ -848,7 +848,7 @@ static apr_status_t recall_headers(cache_handle_t *h, request_rec *r)
 
     /* This case should not happen... */
     if (!dobj->hdrs.fd) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00719)
                 "recalling headers; but no header fd for %s", dobj->name);
         return APR_NOTFOUND;
     }
@@ -862,7 +862,7 @@ static apr_status_t recall_headers(cache_handle_t *h, request_rec *r)
 
     apr_file_close(dobj->hdrs.fd);
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00720)
             "Recalled headers for URL %s", dobj->name);
     return APR_SUCCESS;
 }
@@ -967,7 +967,7 @@ static apr_status_t write_headers(cache_handle_t *h, request_rec *r)
                                  dobj->vary.pool);
 
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00721)
                         "could not create vary file %s",
                         dobj->vary.tempfile);
                 return rv;
@@ -976,7 +976,7 @@ static apr_status_t write_headers(cache_handle_t *h, request_rec *r)
             amt = sizeof(format);
             rv = apr_file_write(dobj->vary.tempfd, &format, &amt);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00722)
                         "could not write to vary file %s",
                         dobj->vary.tempfile);
                 apr_file_close(dobj->vary.tempfd);
@@ -988,7 +988,7 @@ static apr_status_t write_headers(cache_handle_t *h, request_rec *r)
             rv = apr_file_write(dobj->vary.tempfd, &h->cache_obj->info.expire,
                     &amt);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00723)
                         "could not write to vary file %s",
                         dobj->vary.tempfile);
                 apr_file_close(dobj->vary.tempfd);
@@ -1003,7 +1003,7 @@ static apr_status_t write_headers(cache_handle_t *h, request_rec *r)
 
             rv = apr_file_close(dobj->vary.tempfd);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00724)
                         "could not close vary file %s",
                         dobj->vary.tempfile);
                 apr_pool_destroy(dobj->vary.pool);
@@ -1024,7 +1024,7 @@ static apr_status_t write_headers(cache_handle_t *h, request_rec *r)
                          APR_BUFFERED | APR_EXCL, dobj->hdrs.pool);
 
     if (rv != APR_SUCCESS) {
-       ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r,
+       ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00725)
                 "could not create header file %s",
                 dobj->hdrs.tempfile);
         return rv;
@@ -1053,7 +1053,7 @@ static apr_status_t write_headers(cache_handle_t *h, request_rec *r)
 
     rv = apr_file_writev(dobj->hdrs.tempfd, (const struct iovec *) &iov, 2, &amt);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00726)
                 "could not write info to header file %s",
                 dobj->hdrs.tempfile);
         apr_file_close(dobj->hdrs.tempfd);
@@ -1064,7 +1064,7 @@ static apr_status_t write_headers(cache_handle_t *h, request_rec *r)
     if (dobj->headers_out) {
         rv = store_table(dobj->hdrs.tempfd, dobj->headers_out);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00727)
                     "could not write out-headers to header file %s",
                     dobj->hdrs.tempfile);
             apr_file_close(dobj->hdrs.tempfd);
@@ -1078,7 +1078,7 @@ static apr_status_t write_headers(cache_handle_t *h, request_rec *r)
     if (dobj->headers_in) {
         rv = store_table(dobj->hdrs.tempfd, dobj->headers_in);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00728)
                     "could not write in-headers to header file %s",
                     dobj->hdrs.tempfile);
             apr_file_close(dobj->hdrs.tempfd);
@@ -1089,7 +1089,7 @@ static apr_status_t write_headers(cache_handle_t *h, request_rec *r)
 
     rv = apr_file_close(dobj->hdrs.tempfd); /* flush and close */
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00729)
                 "could not close header file %s",
                 dobj->hdrs.tempfile);
         apr_pool_destroy(dobj->hdrs.pool);
@@ -1160,7 +1160,7 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r,
         APR_BUCKET_REMOVE(e);
         APR_BRIGADE_INSERT_TAIL(out, e);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00730)
                     "Error when reading bucket for URL %s",
                     h->cache_obj->key);
             /* Remove the intermediate cache file and return non-APR_SUCCESS */
@@ -1200,7 +1200,7 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r,
         /* write to the cache, leave if we fail */
         rv = apr_file_write_full(dobj->data.tempfd, str, length, &written);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00731)
                     "Error when writing cache file for URL %s",
                     h->cache_obj->key);
             /* Remove the intermediate cache file and return non-APR_SUCCESS */
@@ -1209,7 +1209,7 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r,
         }
         dobj->file_size += written;
         if (dobj->file_size > dconf->maxfs) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00732)
                     "URL %s failed the size check "
                     "(%" APR_OFF_T_FMT ">%" APR_OFF_T_FMT ")",
                     h->cache_obj->key, dobj->file_size, dconf->maxfs);
@@ -1251,7 +1251,7 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r,
         }
 
         if (r->connection->aborted || r->no_cache) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00733)
                     "Discarding body for URL %s "
                     "because connection has been aborted.",
                     h->cache_obj->key);
@@ -1260,7 +1260,7 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r,
             return APR_EGENERAL;
         }
         if (dobj->file_size < dconf->minfs) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00734)
                     "URL %s failed the size check "
                     "(%" APR_OFF_T_FMT "<%" APR_OFF_T_FMT ")",
                     h->cache_obj->key, dobj->file_size, dconf->minfs);
@@ -1271,7 +1271,7 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r,
         if (cl_header) {
             apr_int64_t cl = apr_atoi64(cl_header);
             if ((errno == 0) && (dobj->file_size != cl)) {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00735)
                         "URL %s didn't receive complete response, not caching",
                         h->cache_obj->key);
                 /* Remove the intermediate cache file and return non-APR_SUCCESS */
@@ -1310,12 +1310,12 @@ static apr_status_t commit_entity(cache_handle_t *h, request_rec *r)
     /* remove the cached items completely on any failure */
     if (APR_SUCCESS != rv) {
         remove_url(h, r);
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00736)
                 "commit_entity: URL '%s' not cached due to earlier disk error.",
                 dobj->name);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00737)
                 "commit_entity: Headers and body for URL %s cached.",
                 dobj->name);
     }
diff --git a/modules/cache/mod_file_cache.c b/modules/cache/mod_file_cache.c
index 5eb3055..8ab3abe 100644
--- a/modules/cache/mod_file_cache.c
+++ b/modules/cache/mod_file_cache.c
@@ -133,24 +133,24 @@ static void cache_the_file(cmd_parms *cmd, const char *filename, int mmap)
 
     fspec = ap_server_root_relative(cmd->pool, filename);
     if (!fspec) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, APR_EBADPATH, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, APR_EBADPATH, cmd->server, APLOGNO(00794)
                      "invalid file path "
                      "%s, skipping", filename);
         return;
     }
     if ((rc = apr_stat(&tmp.finfo, fspec, APR_FINFO_MIN,
                                  cmd->temp_pool)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server, APLOGNO(00795)
                      "unable to stat(%s), skipping", fspec);
         return;
     }
     if (tmp.finfo.filetype != APR_REG) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00796)
                      "%s isn't a regular file, skipping", fspec);
         return;
     }
     if (tmp.finfo.size > AP_MAX_SENDFILE) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00797)
                      "%s is too large to cache, skipping", fspec);
         return;
     }
@@ -158,7 +158,7 @@ static void cache_the_file(cmd_parms *cmd, const char *filename, int mmap)
     rc = apr_file_open(&fd, fspec, APR_READ | APR_BINARY | APR_XTHREAD,
                        APR_OS_DEFAULT, cmd->pool);
     if (rc != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server, APLOGNO(00798)
                      "unable to open(%s, O_RDONLY), skipping", fspec);
         return;
     }
@@ -178,7 +178,7 @@ static void cache_the_file(cmd_parms *cmd, const char *filename, int mmap)
                                   (apr_size_t)new_file->finfo.size,
                                   APR_MMAP_READ, cmd->pool)) != APR_SUCCESS) {
             apr_file_close(fd);
-            ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server, APLOGNO(00799)
                          "unable to mmap %s, skipping", filename);
             return;
         }
@@ -209,7 +209,7 @@ static const char *cachefilehandle(cmd_parms *cmd, void *dummy, const char *file
     cache_the_file(cmd, filename, 0);
 #else
     /* Sendfile not supported by this OS */
-    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00800)
                  "unable to cache file: %s. Sendfile is not supported on this OS", filename);
 #endif
     return NULL;
@@ -220,7 +220,7 @@ static const char *cachefilemmap(cmd_parms *cmd, void *dummy, const char *filena
     cache_the_file(cmd, filename, 1);
 #else
     /* MMAP not supported by this OS */
-    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00801)
                  "unable to cache file: %s. MMAP is not supported by this OS", filename);
 #endif
     return NULL;
diff --git a/modules/cache/mod_socache_dbm.c b/modules/cache/mod_socache_dbm.c
index 79aa279..70fe28b 100644
--- a/modules/cache/mod_socache_dbm.c
+++ b/modules/cache/mod_socache_dbm.c
@@ -105,7 +105,7 @@ static int try_chown(apr_pool_t *p, server_rec *s,
                     (gid_t)-1 /* no gid change */ ))
     {
         if (errno != ENOENT)
-            ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(errno), s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(errno), s, APLOGNO(00802)
                          "Can't change owner of %s", name);
         return -1;
     }
@@ -130,7 +130,7 @@ static apr_status_t socache_dbm_init(ap_socache_instance_t *ctx,
         ctx->data_file = ap_server_root_relative(p, path);
 
         if (ctx->data_file == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00803)
                          "could not use default path '%s' for DBM socache",
                          path);
             return APR_EINVAL;
@@ -142,7 +142,7 @@ static apr_status_t socache_dbm_init(ap_socache_instance_t *ctx,
 
     if ((rv = apr_dbm_open(&dbm, ctx->data_file,
             APR_DBM_RWCREATE, DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00804)
                      "Cannot create socache DBM file `%s'",
                      ctx->data_file);
         return rv;
@@ -201,14 +201,14 @@ static apr_status_t socache_dbm_store(ap_socache_instance_t *ctx,
     /* be careful: do not try to store too much bytes in a DBM file! */
 #ifdef PAIRMAX
     if ((idlen + nData) >= PAIRMAX) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00805)
                  "data size too large for DBM socache: %d >= %d",
                  (idlen + nData), PAIRMAX);
         return APR_ENOSPC;
     }
 #else
     if ((idlen + nData) >= 950 /* at least less than approx. 1KB */) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00806)
                  "data size too large for DBM socache: %d >= %d",
                  (idlen + nData), 950);
         return APR_ENOSPC;
@@ -230,7 +230,7 @@ static apr_status_t socache_dbm_store(ap_socache_instance_t *ctx,
 
     if ((rv = apr_dbm_open(&dbm, ctx->data_file,
                            APR_DBM_RWCREATE, DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00807)
                      "Cannot open socache DBM file `%s' for writing "
                      "(store)",
                      ctx->data_file);
@@ -238,7 +238,7 @@ static apr_status_t socache_dbm_store(ap_socache_instance_t *ctx,
         return rv;
     }
     if ((rv = apr_dbm_store(dbm, dbmkey, dbmval)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00808)
                      "Cannot store socache object to DBM file `%s'",
                      ctx->data_file);
         apr_dbm_close(dbm);
@@ -283,7 +283,7 @@ static apr_status_t socache_dbm_retrieve(ap_socache_instance_t *ctx, server_rec
     apr_pool_clear(ctx->pool);
     if ((rc = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,
                            DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rc, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rc, s, APLOGNO(00809)
                      "Cannot open socache DBM file `%s' for reading "
                      "(fetch)",
                      ctx->data_file);
@@ -339,7 +339,7 @@ static apr_status_t socache_dbm_remove(ap_socache_instance_t *ctx,
 
     if ((rv = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,
                            DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00810)
                      "Cannot open socache DBM file `%s' for writing "
                      "(delete)",
                      ctx->data_file);
@@ -403,7 +403,7 @@ static void socache_dbm_expire(ap_socache_instance_t *ctx, server_rec *s)
         keyidx = 0;
         if ((rv = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,
                                DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00811)
                          "Cannot open socache DBM file `%s' for "
                          "scanning",
                          ctx->data_file);
@@ -436,7 +436,7 @@ static void socache_dbm_expire(ap_socache_instance_t *ctx, server_rec *s)
         /* pass 2: delete expired elements */
         if (apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,
                          DBM_FILE_MODE, ctx->pool) != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00812)
                          "Cannot re-open socache DBM file `%s' for "
                          "expiring",
                          ctx->data_file);
@@ -452,7 +452,7 @@ static void socache_dbm_expire(ap_socache_instance_t *ctx, server_rec *s)
             break;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00813)
                  "DBM socache expiry: "
                  "old: %d, new: %d, removed: %d",
                  elts, elts-deleted, deleted);
@@ -475,7 +475,7 @@ static void socache_dbm_status(ap_socache_instance_t *ctx, request_rec *r,
     apr_pool_clear(ctx->pool);
     if ((rv = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,
                            DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00814)
                      "Cannot open socache DBM file `%s' for status "
                      "retrival",
                      ctx->data_file);
@@ -522,7 +522,7 @@ static apr_status_t socache_dbm_iterate(ap_socache_instance_t *ctx,
     now = apr_time_now();
     if ((rv = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,
                            DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00815)
                      "Cannot open socache DBM file `%s' for "
                      "iterating", ctx->data_file);
         return rv;
@@ -543,7 +543,7 @@ static apr_status_t socache_dbm_iterate(ap_socache_instance_t *ctx,
                              (unsigned char *)dbmkey.dptr, dbmkey.dsize,
                              (unsigned char *)dbmval.dptr + sizeof(apr_time_t),
                              dbmval.dsize - sizeof(apr_time_t), pool);
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(00816)
                          "dbm `%s' entry iterated", ctx->data_file);
             if (rv != APR_SUCCESS)
                 return rv;
@@ -553,7 +553,7 @@ static apr_status_t socache_dbm_iterate(ap_socache_instance_t *ctx,
     apr_dbm_close(dbm);
 
     if (rv != APR_SUCCESS && rv != APR_EOF) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00817)
                      "Failure reading first/next socache DBM file `%s' record",
                      ctx->data_file);
         return rv;
diff --git a/modules/cache/mod_socache_dc.c b/modules/cache/mod_socache_dc.c
index 78a92b9..9739a97 100644
--- a/modules/cache/mod_socache_dc.c
+++ b/modules/cache/mod_socache_dc.c
@@ -74,10 +74,10 @@ static apr_status_t socache_dc_init(ap_socache_instance_t *ctx,
 #endif
     ctx->dc = DC_CTX_new(ctx->target, SESSION_CTX_FLAGS);
     if (!ctx->dc) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "distributed scache failed to obtain context");
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00738) "distributed scache failed to obtain context");
         return APR_EGENERAL;
     }
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, "distributed scache context initialised");
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(00739) "distributed scache context initialised");
 
     return APR_SUCCESS;
 }
@@ -104,10 +104,10 @@ static apr_status_t socache_dc_store(ap_socache_instance_t *ctx, server_rec *s,
     /* Send the serialised session to the distributed cache context */
     if (!DC_CTX_add_session(ctx->dc, id, idlen, der, der_len,
                             apr_time_msec(expiry))) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "distributed scache 'store' failed");
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00740) "distributed scache 'store' failed");
         return APR_EGENERAL;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "distributed scache 'store' successful");
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00741) "distributed scache 'store' successful");
     return APR_SUCCESS;
 }
 
@@ -120,15 +120,15 @@ static apr_status_t socache_dc_retrieve(ap_socache_instance_t *ctx, server_rec *
 
     /* Retrieve any corresponding session from the distributed cache context */
     if (!DC_CTX_get_session(ctx->dc, id, idlen, dest, *destlen, &data_len)) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "distributed scache 'retrieve' MISS");
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00742) "distributed scache 'retrieve' MISS");
         return APR_NOTFOUND;
     }
     if (data_len > *destlen) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "distributed scache 'retrieve' OVERFLOW");
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00743) "distributed scache 'retrieve' OVERFLOW");
         return APR_ENOSPC;
     }
     *destlen = data_len;
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "distributed scache 'retrieve' HIT");
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00744) "distributed scache 'retrieve' HIT");
     return APR_SUCCESS;
 }
 
@@ -138,17 +138,17 @@ static apr_status_t socache_dc_remove(ap_socache_instance_t *ctx,
 {
     /* Remove any corresponding session from the distributed cache context */
     if (!DC_CTX_remove_session(ctx->dc, id, idlen)) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "distributed scache 'remove' MISS");
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00745) "distributed scache 'remove' MISS");
         return APR_NOTFOUND;
     } else {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "distributed scache 'remove' HIT");
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00746) "distributed scache 'remove' HIT");
         return APR_SUCCESS;
     }
 }
 
 static void socache_dc_status(ap_socache_instance_t *ctx, request_rec *r, int flags)
 {
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00747)
                   "distributed scache 'socache_dc_status'");
     ap_rprintf(r, "cache type: <b>DC (Distributed Cache)</b>, "
                " target: <b>%s</b><br>", ctx->target);
diff --git a/modules/cache/mod_socache_memcache.c b/modules/cache/mod_socache_memcache.c
index 3f1b250..1aa8b7d 100644
--- a/modules/cache/mod_socache_memcache.c
+++ b/modules/cache/mod_socache_memcache.c
@@ -102,7 +102,7 @@ static apr_status_t socache_mc_init(ap_socache_instance_t *ctx,
 
     rv = apr_memcache_create(p, nservers, 0, &ctx->mc);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00785)
                      "Failed to create Memcache Object of '%d' size.",
                      nservers);
         return rv;
@@ -119,13 +119,13 @@ static apr_status_t socache_mc_init(ap_socache_instance_t *ctx,
 
         rv = apr_parse_addr_port(&host_str, &scope_id, &port, split, p);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00786)
                          "Failed to Parse memcache Server: '%s'", split);
             return rv;
         }
 
         if (host_str == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00787)
                          "Failed to Parse Server, "
                          "no hostname specified: '%s'", split);
             return APR_EINVAL;
@@ -143,7 +143,7 @@ static apr_status_t socache_mc_init(ap_socache_instance_t *ctx,
                                         MC_DEFAULT_SERVER_TTL,
                                         &st);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00788)
                          "Failed to Create memcache Server: %s:%d",
                          host_str, port);
             return rv;
@@ -151,7 +151,7 @@ static apr_status_t socache_mc_init(ap_socache_instance_t *ctx,
 
         rv = apr_memcache_add_server(ctx->mc, st);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00789)
                          "Failed to Add memcache Server: %s:%d",
                          host_str, port);
             return rv;
@@ -215,7 +215,7 @@ static apr_status_t socache_mc_store(ap_socache_instance_t *ctx, server_rec *s,
     rv = apr_memcache_set(ctx->mc, buf, (char*)ucaData, nData, 0, 0);
 
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00790)
                      "scache_mc: error setting key '%s' "
                      "with %d bytes of data", buf, nData);
         return rv;
@@ -243,13 +243,13 @@ static apr_status_t socache_mc_retrieve(ap_socache_instance_t *ctx, server_rec *
     rv = apr_memcache_getp(ctx->mc, p, buf, &data, &data_len, NULL);
     if (rv) {
         if (rv != APR_NOTFOUND) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00791)
                          "scache_mc: 'retrieve' FAIL");
         }
         return rv;
     }
     else if (data_len > *destlen) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00792)
                      "scache_mc: 'retrieve' OVERFLOW");
         return APR_ENOMEM;
     }
@@ -274,7 +274,7 @@ static apr_status_t socache_mc_remove(ap_socache_instance_t *ctx, server_rec *s,
     rv = apr_memcache_delete(ctx->mc, buf, 0);
 
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(00793)
                      "scache_mc: error deleting key '%s' ",
                      buf);
     }
diff --git a/modules/cache/mod_socache_shmcb.c b/modules/cache/mod_socache_shmcb.c
index 710dd52..ff4defd 100644
--- a/modules/cache/mod_socache_shmcb.c
+++ b/modules/cache/mod_socache_shmcb.c
@@ -351,7 +351,7 @@ static apr_status_t socache_shmcb_init(ap_socache_instance_t *ctx,
          * configured successfully; the ap_server_root_relative call
          * above will return NULL for invalid paths. */
         if (ctx->data_file == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00818)
                          "Could not use default path '%s' for shmcb socache",
                          ctx->data_file);
             return APR_EINVAL;
@@ -365,7 +365,7 @@ static apr_status_t socache_shmcb_init(ap_socache_instance_t *ctx,
     }
 
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00819)
                      "Could not allocate shared memory segment for shmcb "
                      "socache");
         return rv;
@@ -375,11 +375,11 @@ static apr_status_t socache_shmcb_init(ap_socache_instance_t *ctx,
     shm_segsize = apr_shm_size_get(ctx->shm);
     if (shm_segsize < (5 * sizeof(SHMCBHeader))) {
         /* the segment is ridiculously small, bail out */
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00820)
                      "shared memory segment too small");
         return APR_ENOSPC;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00821)
                  "shmcb_init allocated %" APR_SIZE_T_FMT
                  " bytes of shared memory",
                  shm_segsize);
@@ -393,14 +393,14 @@ static apr_status_t socache_shmcb_init(ap_socache_instance_t *ctx,
     while ((num_idx / num_subcache) < (2 * num_subcache))
         num_subcache /= 2;
     num_idx /= num_subcache;
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00822)
                  "for %" APR_SIZE_T_FMT " bytes (%" APR_SIZE_T_FMT
                  " including header), recommending %u subcaches, "
                  "%u indexes each", shm_segsize,
                  shm_segsize + sizeof(SHMCBHeader), num_subcache, num_idx);
     if (num_idx < 5) {
         /* we're still too small, bail out */
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00823)
                      "shared memory segment too small");
         return APR_ENOSPC;
     }
@@ -428,17 +428,17 @@ static apr_status_t socache_shmcb_init(ap_socache_instance_t *ctx,
     header->index_num = num_idx;
 
     /* Output trace info */
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00824)
                  "shmcb_init_memory choices follow");
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00825)
                  "subcache_num = %u", header->subcache_num);
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00826)
                  "subcache_size = %u", header->subcache_size);
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00827)
                  "subcache_data_offset = %u", header->subcache_data_offset);
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00828)
                  "subcache_data_size = %u", header->subcache_data_size);
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00829)
                  "index_num = %u", header->index_num);
     /* The header is done, make the caches empty */
     for (loop = 0; loop < header->subcache_num; loop++) {
@@ -446,7 +446,7 @@ static apr_status_t socache_shmcb_init(ap_socache_instance_t *ctx,
         subcache->idx_pos = subcache->idx_used = 0;
         subcache->data_pos = subcache->data_used = 0;
     }
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(00830)
                  "Shared memory socache initialised");
     /* Success ... */
 
@@ -472,19 +472,19 @@ static apr_status_t socache_shmcb_store(ap_socache_instance_t *ctx,
     SHMCBSubcache *subcache = SHMCB_MASK(header, id);
     int tryreplace;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00831)
                  "socache_shmcb_store (0x%02x -> subcache %d)",
                  SHMCB_MASK_DBG(header, id));
     /* XXX: Says who?  Why shouldn't this be acceptable, or padded if not? */
     if (idlen < 4) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "unusably short id provided "
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00832) "unusably short id provided "
                 "(%u bytes)", idlen);
         return APR_EINVAL;
     }
     tryreplace = shmcb_subcache_remove(s, header, subcache, id, idlen);
     if (shmcb_subcache_store(s, header, subcache, encoded,
                              len_encoded, id, idlen, expiry)) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00833)
                      "can't store an socache entry!");
         return APR_ENOSPC;
     }
@@ -494,7 +494,7 @@ static apr_status_t socache_shmcb_store(ap_socache_instance_t *ctx,
     else {
         header->stat_stores++;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00834)
                  "leaving socache_shmcb_store successfully");
     return APR_SUCCESS;
 }
@@ -509,7 +509,7 @@ static apr_status_t socache_shmcb_retrieve(ap_socache_instance_t *ctx,
     SHMCBSubcache *subcache = SHMCB_MASK(header, id);
     int rv;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00835)
                  "socache_shmcb_retrieve (0x%02x -> subcache %d)",
                  SHMCB_MASK_DBG(header, id));
 
@@ -520,7 +520,7 @@ static apr_status_t socache_shmcb_retrieve(ap_socache_instance_t *ctx,
         header->stat_retrieves_hit++;
     else
         header->stat_retrieves_miss++;
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00836)
                  "leaving socache_shmcb_retrieve successfully");
 
     return rv == 0 ? APR_SUCCESS : APR_NOTFOUND;
@@ -534,11 +534,11 @@ static apr_status_t socache_shmcb_remove(ap_socache_instance_t *ctx,
     SHMCBSubcache *subcache = SHMCB_MASK(header, id);
     apr_status_t rv;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00837)
                  "socache_shmcb_remove (0x%02x -> subcache %d)",
                  SHMCB_MASK_DBG(header, id));
     if (idlen < 4) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, "unusably short id provided "
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00838) "unusably short id provided "
                 "(%u bytes)", idlen);
         return APR_EINVAL;
     }
@@ -549,7 +549,7 @@ static apr_status_t socache_shmcb_remove(ap_socache_instance_t *ctx,
         header->stat_removes_miss++;
         rv = APR_NOTFOUND;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00839)
                  "leaving socache_shmcb_remove successfully");
 
     return rv;
@@ -567,7 +567,7 @@ static void socache_shmcb_status(ap_socache_instance_t *ctx,
     int index_pct, cache_pct;
 
     AP_DEBUG_ASSERT(header->subcache_num > 0);
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "inside shmcb_status");
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00840) "inside shmcb_status");
     /* Perform the iteration inside the mutex to avoid corruption or invalid
      * pointer arithmetic. The rest of our logic uses read-only header data so
      * doesn't need the lock. */
@@ -627,7 +627,7 @@ static void socache_shmcb_status(ap_socache_instance_t *ctx,
     ap_rprintf(r, "total removes since starting: <b>%lu</b> hit, "
                "<b>%lu</b> miss<br>", header->stat_removes_hit,
                header->stat_removes_miss);
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "leaving shmcb_status");
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00841) "leaving shmcb_status");
 }
 
 static apr_status_t socache_shmcb_iterate(ap_socache_instance_t *instance,
@@ -680,7 +680,7 @@ static void shmcb_subcache_expire(server_rec *s, SHMCBHeader *header,
     if (!loop)
         /* Nothing to do */
         return;
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00842)
                  "expiring %u and reclaiming %u removed socache entries",
                  expired, freed);
     if (loop == subcache->idx_used) {
@@ -700,7 +700,7 @@ static void shmcb_subcache_expire(server_rec *s, SHMCBHeader *header,
         subcache->data_pos = idx->data_pos;
     }
     header->stat_expiries += expired;
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00843)
                  "we now have %u socache entries", subcache->idx_used);
 }
 
@@ -716,7 +716,7 @@ static int shmcb_subcache_store(server_rec *s, SHMCBHeader *header,
 
     /* Sanity check the input */
     if (total_len > header->subcache_data_size) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00844)
                      "inserting socache entry larger (%d) than subcache data area (%d)",
                      total_len, header->subcache_data_size);
         return -1;
@@ -734,7 +734,7 @@ static int shmcb_subcache_store(server_rec *s, SHMCBHeader *header,
         unsigned int loop = 0;
 
         idx = SHMCB_INDEX(subcache, subcache->idx_pos);
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00845)
                      "about to force-expire, subcache: idx_used=%d, "
                      "data_used=%d", subcache->idx_used, subcache->data_used);
         do {
@@ -761,7 +761,7 @@ static int shmcb_subcache_store(server_rec *s, SHMCBHeader *header,
             loop++;
         } while (header->subcache_data_size - subcache->data_used < total_len);
 
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00846)
                      "finished force-expire, subcache: idx_used=%d, "
                      "data_used=%d", subcache->idx_used, subcache->data_used);
     }
@@ -797,10 +797,10 @@ static int shmcb_subcache_store(server_rec *s, SHMCBHeader *header,
     idx->id_len = id_len;
     idx->removed = 0;
     subcache->idx_used++;
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00847)
                  "insert happened at idx=%d, data=(%u:%u)", new_idx,
                  id_offset, data_offset);
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00848)
                  "finished insert, subcache: idx_pos/idx_used=%d/%d, "
                  "data_pos/data_used=%d/%d",
                  subcache->idx_pos, subcache->idx_used,
@@ -833,7 +833,7 @@ static int shmcb_subcache_retrieve(server_rec *s, SHMCBHeader *header,
             && shmcb_cyclic_memcmp(header->subcache_data_size,
                                    SHMCB_DATA(header, subcache),
                                    idx->data_pos, id, idx->id_len) == 0) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00849)
                          "match at idx=%d, data=%d", pos, idx->data_pos);
             if (idx->expires > now) {
                 unsigned int data_offset;
@@ -855,7 +855,7 @@ static int shmcb_subcache_retrieve(server_rec *s, SHMCBHeader *header,
             else {
                 /* Already stale, quietly remove and treat as not-found */
                 idx->removed = 1;
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00850)
                              "shmcb_subcache_retrieve discarding expired entry");
                 return -1;
             }
@@ -865,7 +865,7 @@ static int shmcb_subcache_retrieve(server_rec *s, SHMCBHeader *header,
         pos = SHMCB_CYCLIC_INCREMENT(pos, 1, header->index_num);
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00851)
                  "shmcb_subcache_retrieve found no match");
     return -1;
 }
@@ -888,12 +888,12 @@ static int shmcb_subcache_remove(server_rec *s, SHMCBHeader *header,
             && shmcb_cyclic_memcmp(header->subcache_data_size,
                                    SHMCB_DATA(header, subcache),
                                    idx->data_pos, id, idx->id_len) == 0) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00852)
                          "possible match at idx=%d, data=%d", pos, idx->data_pos);
 
             /* Found the matching entry, remove it quietly. */
             idx->removed = 1;
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00853)
                          "shmcb_subcache_remove removing matching entry");
             return 0;
         }
@@ -928,7 +928,7 @@ static apr_status_t shmcb_subcache_iterate(ap_socache_instance_t *instance,
         /* Only consider 'idx' if the "removed" flag isn't set. */
         if (!idx->removed) {
 
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00854)
                          "iterating idx=%d, data=%d", pos, idx->data_pos);
             if (idx->expires > now) {
                 unsigned char *id = *buf;
@@ -970,7 +970,7 @@ static apr_status_t shmcb_subcache_iterate(ap_socache_instance_t *instance,
 
                 rv = iterator(instance, s, userctx, id, idx->id_len,
                               dest, dest_len, pool);
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s,
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, s, APLOGNO(00855)
                              "shmcb entry iterated");
                 if (rv != APR_SUCCESS)
                     return rv;
@@ -978,7 +978,7 @@ static apr_status_t shmcb_subcache_iterate(ap_socache_instance_t *instance,
             else {
                 /* Already stale, quietly remove and treat as not-found */
                 idx->removed = 1;
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00856)
                              "shmcb_subcache_iterate discarding expired entry");
             }
         }
diff --git a/modules/cluster/mod_heartbeat.c b/modules/cluster/mod_heartbeat.c
index 45d7c6b..1dc4a91 100644
--- a/modules/cluster/mod_heartbeat.c
+++ b/modules/cluster/mod_heartbeat.c
@@ -86,21 +86,21 @@ static int hb_monitor(hb_ctx_t *ctx, apr_pool_t *p)
                                SOCK_DGRAM, APR_PROTO_UDP, p);
         if (rv) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, rv,
-                         NULL, "Heartbeat: apr_socket_create failed");
+                         NULL, APLOGNO(02097) "Heartbeat: apr_socket_create failed");
             break;
         }
 
         rv = apr_mcast_loopback(sock, 1);
         if (rv) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, rv,
-                         NULL, "Heartbeat: apr_mcast_loopback failed");
+                         NULL, APLOGNO(02098) "Heartbeat: apr_mcast_loopback failed");
             break;
         }
 
         rv = apr_socket_sendto(sock, ctx->mcast_addr, 0, buf, &len);
         if (rv) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, rv,
-                         NULL, "Heartbeat: apr_socket_sendto failed");
+                         NULL, APLOGNO(02099) "Heartbeat: apr_socket_sendto failed");
             break;
         }
     } while (0);
diff --git a/modules/cluster/mod_heartmonitor.c b/modules/cluster/mod_heartmonitor.c
index 3c2b414..036e49c 100644
--- a/modules/cluster/mod_heartmonitor.c
+++ b/modules/cluster/mod_heartmonitor.c
@@ -81,14 +81,14 @@ static apr_status_t hm_listen(hm_ctx_t *ctx)
                            SOCK_DGRAM, APR_PROTO_UDP, ctx->p);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02068)
                      "Failed to create listening socket.");
         return rv;
     }
 
     rv = apr_socket_opt_set(ctx->sock, APR_SO_REUSEADDR, 1);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02069)
                      "Failed to set APR_SO_REUSEADDR to 1 on socket.");
         return rv;
     }
@@ -96,14 +96,14 @@ static apr_status_t hm_listen(hm_ctx_t *ctx)
 
     rv = apr_socket_opt_set(ctx->sock, APR_SO_NONBLOCK, 1);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02070)
                      "Failed to set APR_SO_NONBLOCK to 1 on socket.");
         return rv;
     }
 
     rv = apr_socket_bind(ctx->sock, ctx->mcast_addr);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02071)
                      "Failed to bind on socket.");
         return rv;
     }
@@ -111,14 +111,14 @@ static apr_status_t hm_listen(hm_ctx_t *ctx)
     rv = apr_mcast_join(ctx->sock, ctx->mcast_addr, NULL, NULL);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02072)
                      "Failed to join multicast group");
         return rv;
     }
 
     rv = apr_mcast_loopback(ctx->sock, 1);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02073)
                      "Failed to accept localhost mulitcast on socket.");
         return rv;
     }
@@ -240,7 +240,7 @@ static apr_status_t hm_file_update_stat(hm_ctx_t *ctx, hm_server_t *s, apr_pool_
     rv = apr_file_mktemp(&fp, path, APR_CREATE | APR_WRITE, pool);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02074)
                      "Unable to open tmp file: %s", path);
         return rv;
     }
@@ -257,7 +257,7 @@ static apr_status_t hm_file_update_stat(hm_ctx_t *ctx, hm_server_t *s, apr_pool_
 
         rv = apr_file_info_get(&fi, APR_FINFO_SIZE | APR_FINFO_MTIME, fpin);
         if (rv) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02075)
                          "Unable to read file: %s", ctx->storage_path);
             return rv;
         }
@@ -280,7 +280,7 @@ static apr_status_t hm_file_update_stat(hm_ctx_t *ctx, hm_server_t *s, apr_pool_
                                         APR_BLOCK_READ, sizeof(buf));
 
             if (rv) {
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02076)
                              "Unable to read from file: %s", ctx->storage_path);
                 return rv;
             }
@@ -350,14 +350,14 @@ static apr_status_t hm_file_update_stat(hm_ctx_t *ctx, hm_server_t *s, apr_pool_
 
     rv = apr_file_flush(fp);
     if (rv) {
-      ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+      ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02077)
                    "Unable to flush file: %s", path);
       return rv;
     }
 
     rv = apr_file_close(fp);
     if (rv) {
-      ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+      ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02078)
                    "Unable to close file: %s", path);
       return rv;
     }
@@ -366,7 +366,7 @@ static apr_status_t hm_file_update_stat(hm_ctx_t *ctx, hm_server_t *s, apr_pool_
                             APR_FPROT_UREAD | APR_FPROT_GREAD |
                             APR_FPROT_WREAD);
     if (rv && rv != APR_INCOMPLETE && rv != APR_ENOTIMPL) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02079)
                      "Unable to set file permissions on %s",
                      path);
         return rv;
@@ -375,7 +375,7 @@ static apr_status_t hm_file_update_stat(hm_ctx_t *ctx, hm_server_t *s, apr_pool_
     rv = apr_file_rename(path, ctx->storage_path, pool);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02080)
                      "Unable to move file: %s -> %s", path,
                      ctx->storage_path);
         return rv;
@@ -403,7 +403,7 @@ static apr_status_t hm_file_update_stats(hm_ctx_t *ctx, apr_pool_t *p)
     rv = apr_file_mktemp(&fp, path, APR_CREATE | APR_WRITE, p);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02081)
                      "Unable to open tmp file: %s", path);
         return rv;
     }
@@ -429,14 +429,14 @@ static apr_status_t hm_file_update_stats(hm_ctx_t *ctx, apr_pool_t *p)
 
     rv = apr_file_flush(fp);
     if (rv) {
-      ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+      ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02082)
                    "Unable to flush file: %s", path);
       return rv;
     }
 
     rv = apr_file_close(fp);
     if (rv) {
-      ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+      ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02083)
                    "Unable to close file: %s", path);
       return rv;
     }
@@ -445,7 +445,7 @@ static apr_status_t hm_file_update_stats(hm_ctx_t *ctx, apr_pool_t *p)
                             APR_FPROT_UREAD | APR_FPROT_GREAD |
                             APR_FPROT_WREAD);
     if (rv && rv != APR_INCOMPLETE && rv != APR_ENOTIMPL) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02084)
                      "Unable to set file permissions on %s",
                      path);
         return rv;
@@ -454,7 +454,7 @@ static apr_status_t hm_file_update_stats(hm_ctx_t *ctx, apr_pool_t *p)
     rv = apr_file_rename(path, ctx->storage_path, p);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02085)
                      "Unable to move file: %s -> %s", path,
                      ctx->storage_path);
         return rv;
@@ -534,7 +534,7 @@ static void hm_processmsg(hm_ctx_t *ctx, apr_pool_t *p,
         int port = 80;
         hm_server_t *s;
         /* TODO: REMOVE ME BEFORE PRODUCTION (????) */
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ctx->s, APLOGNO(02086)
                      "%pI busy=%s ready=%s", from,
                      apr_table_get(tbl, "busy"), apr_table_get(tbl, "ready"));
 
@@ -550,7 +550,7 @@ static void hm_processmsg(hm_ctx_t *ctx, apr_pool_t *p,
         s->seen = apr_time_now();
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ctx->s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ctx->s, APLOGNO(02087)
                      "malformed message from %pI",
                      from);
     }
@@ -570,11 +570,11 @@ static apr_status_t hm_recv(hm_ctx_t *ctx, apr_pool_t *p)
     rv = apr_socket_recvfrom(&from, ctx->sock, 0, buf, &len);
 
     if (APR_STATUS_IS_EAGAIN(rv)) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, "would block");
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02088) "would block");
         return APR_SUCCESS;
     }
     else if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, "recvfrom failed");
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02089) "recvfrom failed");
         return rv;
     }
 
@@ -599,12 +599,12 @@ static apr_status_t hm_watchdog_callback(int state, void *data,
             rv = hm_listen(ctx);
             if (rv) {
                 ctx->status = rv;
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s, APLOGNO(02090)
                              "Unable to listen for connections!");
             }
             else {
                 ctx->keep_running = 1;
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ctx->s,
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ctx->s, APLOGNO(02091)
                              "%s listener started.",
                              HM_WATHCHDOG_NAME);
             }
@@ -646,7 +646,7 @@ static apr_status_t hm_watchdog_callback(int state, void *data,
             }
         break;
         case AP_WATCHDOG_STATE_STOPPING:
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ctx->s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ctx->s, APLOGNO(02092)
                          "stopping %s listener.",
                          HM_WATHCHDOG_NAME);
 
@@ -672,7 +672,7 @@ static int hm_post_config(apr_pool_t *p, apr_pool_t *plog,
     hm_watchdog_get_instance = APR_RETRIEVE_OPTIONAL_FN(ap_watchdog_get_instance);
     hm_watchdog_register_callback = APR_RETRIEVE_OPTIONAL_FN(ap_watchdog_register_callback);
     if (!hm_watchdog_get_instance || !hm_watchdog_register_callback) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(02093)
                      "mod_watchdog is required");
         return !OK;
     }
@@ -702,7 +702,7 @@ static int hm_post_config(apr_pool_t *p, apr_pool_t *plog,
                                   HM_WATHCHDOG_NAME,
                                   0, 1, p);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(02094)
                      "Failed to create watchdog instance (%s)",
                      HM_WATHCHDOG_NAME);
         return !OK;
@@ -713,12 +713,12 @@ static int hm_post_config(apr_pool_t *p, apr_pool_t *plog,
                                        ctx,
                                        hm_watchdog_callback);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(02095)
                      "Failed to register watchdog callback (%s)",
                      HM_WATHCHDOG_NAME);
         return !OK;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(02096)
                  "wd callback %s", HM_WATHCHDOG_NAME);
     return OK;
 }
diff --git a/modules/core/mod_so.c b/modules/core/mod_so.c
index 5f44f81..13ecd96 100644
--- a/modules/core/mod_so.c
+++ b/modules/core/mod_so.c
@@ -184,7 +184,7 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
         modi = &modie[i];
         if (modi->name != NULL && strcmp(modi->name, modname) == 0) {
             ap_log_perror(APLOG_MARK, APLOG_WARNING, 0,
-                          cmd->pool, "module %s is already loaded, skipping",
+                          cmd->pool, APLOGNO(01574) "module %s is already loaded, skipping",
                           modname);
             return NULL;
         }
@@ -242,7 +242,7 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
                           apr_dso_error(modhandle, my_error, sizeof(my_error)),
                           NULL);
     }
-    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool,
+    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, APLOGNO(01575)
                  "loaded module %s", modname);
 
     /*
@@ -324,7 +324,7 @@ static const char *load_file(cmd_parms *cmd, void *dummy, const char *filename)
                           NULL);
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL, APLOGNO(01576)
                  "loaded file %s", filename);
 
     return NULL;
@@ -391,7 +391,7 @@ static void dump_loaded_modules(apr_pool_t *p, server_rec *s)
 
 static const char *load_file(cmd_parms *cmd, void *dummy, const char *filename)
 {
-    ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, cmd->pool,
+    ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, cmd->pool, APLOGNO(01577)
                  "WARNING: LoadFile not supported on this platform");
     return NULL;
 }
@@ -399,7 +399,7 @@ static const char *load_file(cmd_parms *cmd, void *dummy, const char *filename)
 static const char *load_module(cmd_parms *cmd, void *dummy,
                                const char *modname, const char *filename)
 {
-    ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, cmd->pool,
+    ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, cmd->pool, APLOGNO(01578)
                  "WARNING: LoadModule not supported on this platform");
     return NULL;
 }
diff --git a/modules/core/mod_watchdog.c b/modules/core/mod_watchdog.c
index 7fad72e..68820e8 100644
--- a/modules/core/mod_watchdog.c
+++ b/modules/core/mod_watchdog.c
@@ -451,7 +451,7 @@ static int wd_post_config_hook(apr_pool_t *pconf, apr_pool_t *plog,
     {
         const char *ppid = getenv("AP_PARENT_PID");
         if (ppid && *ppid) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01570)
                 "[%" APR_PID_T_FMT " - %s] "
                 "child second stage post config hook",
                 getpid(), ppid);
@@ -494,7 +494,7 @@ static int wd_post_config_hook(apr_pool_t *pconf, apr_pool_t *plog,
                      * Create the watchdog thread
                      */
                     if ((rv = wd_startup(w, wd_server_conf->pool)) != APR_SUCCESS) {
-                        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+                        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(01571)
                                 "Watchdog: Failed to create parent worker thread.");
                         return rv;
                     }
@@ -504,7 +504,7 @@ static int wd_post_config_hook(apr_pool_t *pconf, apr_pool_t *plog,
         }
     }
     if (wd_server_conf->parent_workers) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01572)
                      "Spawned %d parent worker threads.",
                      wd_server_conf->parent_workers);
     }
@@ -579,7 +579,7 @@ static void wd_child_init_hook(apr_pool_t *p, server_rec *s)
                  * Kick of the watchdog
                  */
                 if ((rv = wd_startup(w, wd_server_conf->pool)) != APR_SUCCESS) {
-                    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+                    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(01573)
                                  "Watchdog: Failed to create worker thread.");
                     /* No point to continue */
                     return;
diff --git a/modules/database/mod_dbd.c b/modules/database/mod_dbd.c
index 69206cd..5ff1ea2 100644
--- a/modules/database/mod_dbd.c
+++ b/modules/database/mod_dbd.c
@@ -521,7 +521,7 @@ static apr_status_t dbd_construct(void **data_ptr,
 
     rv = apr_pool_create(&rec_pool, pool);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, cfg->server,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, cfg->server, APLOGNO(00624)
                      "Failed to create memory pool");
         return rv;
     }
@@ -538,20 +538,20 @@ static apr_status_t dbd_construct(void **data_ptr,
     rv = apr_dbd_get_driver(rec->pool, cfg->name, &rec->driver);
     if (rv != APR_SUCCESS) {
         if (APR_STATUS_IS_ENOTIMPL(rv)) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server, APLOGNO(00625)
                          "driver for %s not available", cfg->name);
         }
         else if (APR_STATUS_IS_EDSOOPEN(rv)) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server, APLOGNO(00626)
                          "can't find driver for %s", cfg->name);
         }
         else if (APR_STATUS_IS_ESYMNOTFOUND(rv)) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server, APLOGNO(00627)
                          "driver for %s is invalid or corrupted",
                          cfg->name);
         }
         else {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server, APLOGNO(00628)
                          "mod_dbd not compatible with APR in get_driver");
         }
         apr_pool_destroy(rec->pool);
@@ -562,11 +562,11 @@ static apr_status_t dbd_construct(void **data_ptr,
     if (rv != APR_SUCCESS) {
         switch (rv) {
         case APR_EGENERAL:
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server, APLOGNO(00629)
                          "Can't connect to %s: %s", cfg->name, err);
             break;
         default:
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server, APLOGNO(00630)
                          "mod_dbd not compatible with APR in open");
             break;
         }
@@ -583,7 +583,7 @@ static apr_status_t dbd_construct(void **data_ptr,
      */
     rv = apr_pool_create(&prepared_pool, rec->pool);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, cfg->server,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, cfg->server, APLOGNO(00631)
                      "Failed to create memory pool");
 
         apr_pool_destroy(rec->pool);
@@ -593,7 +593,7 @@ static apr_status_t dbd_construct(void **data_ptr,
     rv = dbd_prepared_init(prepared_pool, cfg, rec);
     if (rv != APR_SUCCESS) {
         const char *errmsg = apr_dbd_error(rec->driver, rec->handle, rv);
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, cfg->server, APLOGNO(00632)
                      "failed to prepare SQL statements: %s",
                      (errmsg ? errmsg : "[???]"));
 
@@ -647,7 +647,7 @@ static apr_status_t dbd_setup(server_rec *s, dbd_group_t *group)
                             dbd_construct, dbd_destruct, group,
                             group->pool);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00633)
                      "failed to initialise");
         return rv;
     }
@@ -669,7 +669,7 @@ static apr_status_t dbd_setup_init(apr_pool_t *pool, server_rec *s)
 
         rv2 = apr_pool_create(&group->pool, pool);
         if (rv2 != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv2, s,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv2, s, APLOGNO(00634)
                          "Failed to create reslist cleanup memory pool");
             return rv2;
         }
@@ -689,7 +689,7 @@ static apr_status_t dbd_setup_init(apr_pool_t *pool, server_rec *s)
         rv2 = apr_thread_mutex_create(&group->mutex,
                                       APR_THREAD_MUTEX_DEFAULT, pool);
         if (rv2 != APR_SUCCESS) {
-             ap_log_error(APLOG_MARK, APLOG_CRIT, rv2, s,
+             ap_log_error(APLOG_MARK, APLOG_CRIT, rv2, s, APLOGNO(00635)
                           "Failed to create thread mutex");
              return rv2;
         }
@@ -703,7 +703,7 @@ static void dbd_child_init(apr_pool_t *p, server_rec *s)
 {
   apr_status_t rv = dbd_setup_init(p, s);
   if (rv) {
-    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00636)
                  "child init failed!");
   }
 }
@@ -723,7 +723,7 @@ static apr_status_t dbd_setup_lock(server_rec *s, dbd_group_t *group)
 
     rv2 = apr_thread_mutex_lock(group->mutex);
     if (rv2 != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv2, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv2, s, APLOGNO(00637)
                      "Failed to acquire thread mutex");
         return rv2;
     }
@@ -734,7 +734,7 @@ static apr_status_t dbd_setup_lock(server_rec *s, dbd_group_t *group)
 
     rv2 = apr_thread_mutex_unlock(group->mutex);
     if (rv2 != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv2, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv2, s, APLOGNO(00638)
                      "Failed to release thread mutex");
         if (rv == APR_SUCCESS) {
             rv = rv2;
@@ -782,7 +782,7 @@ static apr_status_t dbd_check(apr_pool_t *pool, server_rec *s, ap_dbd_t *rec)
     }
 
     svr = ap_get_module_config(s->module_config, &dbd_module);
-    ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+    ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00639)
                  "DBD [%s] Error: %s", svr->cfg->name, errmsg);
     return rv;
 }
diff --git a/modules/dav/fs/dbm.c b/modules/dav/fs/dbm.c
index 785efb0..53a97e9 100644
--- a/modules/dav/fs/dbm.c
+++ b/modules/dav/fs/dbm.c
@@ -97,7 +97,7 @@ static dav_error * dav_fs_dbm_error(dav_db *db, apr_pool_t *p,
         errcode = 1;
         errstr = "Could not open property database.";
         if (APR_STATUS_IS_EDSOOPEN(status))
-            ap_log_error(APLOG_MARK, APLOG_CRIT, status, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, status, ap_server_conf, APLOGNO(00576)
             "The DBM driver could not be loaded");
     }
     else {
@@ -494,8 +494,8 @@ static void dav_propdb_close(dav_db *db)
 
         err = dav_dbm_store(db, key, value);
         if (err != NULL)
-            ap_log_error(APLOG_MARK, APLOG_WARNING, err->aprerr,
-                         ap_server_conf, "Error writing propdb: %s", err->desc);
+            ap_log_error(APLOG_MARK, APLOG_WARNING, err->aprerr, ap_server_conf,
+                         APLOGNO(00577) "Error writing propdb: %s", err->desc);
     }
 
     dav_dbm_close(db);
diff --git a/modules/dav/main/mod_dav.c b/modules/dav/main/mod_dav.c
index 4f84240..b505917 100644
--- a/modules/dav/main/mod_dav.c
+++ b/modules/dav/main/mod_dav.c
@@ -181,13 +181,13 @@ static void *dav_merge_dir_config(apr_pool_t *p, void *base, void *overrides)
     newconf->provider = DAV_INHERIT_VALUE(parent, child, provider);
     if (parent->provider_name != NULL) {
         if (child->provider_name == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(00578)
                          "\"DAV Off\" cannot be used to turn off a subtree "
                          "of a DAV-enabled location.");
         }
         else if (strcasecmp(child->provider_name,
                             parent->provider_name) != 0) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(00579)
                          "A subtree cannot specify a different DAV provider "
                          "than its parent.");
         }
@@ -656,7 +656,7 @@ DAV_DECLARE(int) dav_get_depth(request_rec *r, int def_depth)
 
     /* The caller will return an HTTP_BAD_REQUEST. This will augment the
      * default message that Apache provides. */
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00580)
                   "An invalid Depth header was specified.");
     return -1;
 }
@@ -679,7 +679,7 @@ static int dav_get_overwrite(request_rec *r)
 
     /* The caller will return an HTTP_BAD_REQUEST. This will augment the
      * default message that Apache provides. */
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00581)
                   "An invalid Overwrite header was specified.");
     return -1;
 }
@@ -1186,14 +1186,14 @@ static int dav_method_delete(request_rec *r)
 
     if (resource->collection && depth != DAV_INFINITY) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00582)
                       "Depth must be \"infinity\" for DELETE of a collection.");
         return HTTP_BAD_REQUEST;
     }
 
     if (!resource->collection && depth == 1) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00583)
                       "Depth of \"1\" is not allowed for DELETE.");
         return HTTP_BAD_REQUEST;
     }
@@ -1611,7 +1611,7 @@ static int dav_method_options(request_rec *r)
     /* note: doc == NULL if no request body */
 
     if (doc && !dav_validate_root(doc, "options")) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00584)
                       "The \"options\" element was not found.");
         return HTTP_BAD_REQUEST;
     }
@@ -2046,7 +2046,7 @@ static int dav_method_propfind(request_rec *r)
 
     if (doc && !dav_validate_root(doc, "propfind")) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00585)
                       "The \"propfind\" element was not found.");
         return HTTP_BAD_REQUEST;
     }
@@ -2067,7 +2067,7 @@ static int dav_method_propfind(request_rec *r)
         /* "propfind" element must have one of the above three children */
 
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00586)
                       "The \"propfind\" element does not contain one of "
                       "the required child elements (the specific command).");
         return HTTP_BAD_REQUEST;
@@ -2299,7 +2299,7 @@ static int dav_method_proppatch(request_rec *r)
 
     if (doc == NULL || !dav_validate_root(doc, "propertyupdate")) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00587)
                       "The request body does not contain "
                       "a \"propertyupdate\" element.");
         return HTTP_BAD_REQUEST;
@@ -2362,7 +2362,7 @@ static int dav_method_proppatch(request_rec *r)
             dav_auto_checkin(r, resource, 1 /*undo*/, 0 /*unlock*/, &av_info);
 
             /* This supplies additional information for the default message. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00588)
                           "A \"prop\" element is missing inside "
                           "the propertyupdate command.");
             return HTTP_BAD_REQUEST;
@@ -2441,7 +2441,7 @@ static int process_mkcol_body(request_rec *r)
     if (tenc) {
         if (strcasecmp(tenc, "chunked")) {
             /* Use this instead of Apache's default error string */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00589)
                           "Unknown Transfer-Encoding %s", tenc);
             return HTTP_NOT_IMPLEMENTED;
         }
@@ -2457,7 +2457,7 @@ static int process_mkcol_body(request_rec *r)
 
         if (*pos != '\0') {
             /* This supplies additional information for the default message. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00590)
                           "Invalid Content-Length %s", lenp);
             return HTTP_BAD_REQUEST;
         }
@@ -2649,7 +2649,7 @@ static int dav_method_copymove(request_rec *r, int is_move)
     }
     if (dest == NULL) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00591)
                       "The request is missing a Destination header.");
         return HTTP_BAD_REQUEST;
     }
@@ -2658,7 +2658,7 @@ static int dav_method_copymove(request_rec *r, int is_move)
     if (lookup.rnew == NULL) {
         if (lookup.err.status == HTTP_BAD_REQUEST) {
             /* This supplies additional information for the default message. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00592)
                           "%s", lookup.err.desc);
             return HTTP_BAD_REQUEST;
         }
@@ -2737,13 +2737,13 @@ static int dav_method_copymove(request_rec *r, int is_move)
     }
     if (depth == 1) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00593)
                       "Depth must be \"0\" or \"infinity\" for COPY or MOVE.");
         return HTTP_BAD_REQUEST;
     }
     if (is_move && is_dir && depth != DAV_INFINITY) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00594)
                       "Depth must be \"infinity\" when moving a collection.");
         return HTTP_BAD_REQUEST;
     }
@@ -3032,7 +3032,7 @@ static int dav_method_lock(request_rec *r)
 
     depth = dav_get_depth(r, DAV_INFINITY);
     if (depth != 0 && depth != DAV_INFINITY) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00595)
                       "Depth must be 0 or \"infinity\" for LOCK.");
         return HTTP_BAD_REQUEST;
     }
@@ -3205,7 +3205,7 @@ static int dav_method_unlock(request_rec *r)
 
     if ((const_locktoken_txt = apr_table_get(r->headers_in,
                                              "Lock-Token")) == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00596)
                       "Unlock failed (%s):  "
                       "No Lock-Token specified in header", r->filename);
         return HTTP_BAD_REQUEST;
@@ -3315,7 +3315,7 @@ static int dav_method_vsn_control(request_rec *r)
         apr_size_t tsize;
 
         if (!dav_validate_root(doc, "version-control")) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00597)
                           "The request body does not contain "
                           "a \"version-control\" element.");
             return HTTP_BAD_REQUEST;
@@ -3323,14 +3323,14 @@ static int dav_method_vsn_control(request_rec *r)
 
         /* get the version URI */
         if ((child = dav_find_child(doc->root, "version")) == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00598)
                           "The \"version-control\" element does not contain "
                           "a \"version\" element.");
             return HTTP_BAD_REQUEST;
         }
 
         if ((child = dav_find_child(child, "href")) == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00599)
                           "The \"version\" element does not contain "
                           "an \"href\" element.");
             return HTTP_BAD_REQUEST;
@@ -3340,7 +3340,7 @@ static int dav_method_vsn_control(request_rec *r)
         apr_xml_to_text(r->pool, child, APR_XML_X2T_INNER, NULL, NULL,
                         &target, &tsize);
         if (tsize == 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00600)
                           "An \"href\" element does not contain a URI.");
             return HTTP_BAD_REQUEST;
         }
@@ -3492,7 +3492,7 @@ static int dav_method_checkout(request_rec *r)
 
         if (!dav_validate_root(doc, "checkout")) {
             /* This supplies additional information for the default msg. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00601)
                           "The request body, if present, must be a "
                           "DAV:checkout element.");
             return HTTP_BAD_REQUEST;
@@ -3539,7 +3539,7 @@ static int dav_method_checkout(request_rec *r)
                     */
 
                     /* This supplies additional info for the default msg. */
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00602)
                                   "Within the DAV:activity-set element, the "
                                   "DAV:new element must be used, or at least "
                                   "one DAV:href must be specified.");
@@ -3692,7 +3692,7 @@ static int dav_method_checkin(request_rec *r)
     if (doc != NULL) {
         if (!dav_validate_root(doc, "checkin")) {
             /* This supplies additional information for the default msg. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00603)
                           "The request body, if present, must be a "
                           "DAV:checkin element.");
             return HTTP_BAD_REQUEST;
@@ -3780,7 +3780,7 @@ static int dav_method_update(request_rec *r)
 
     if (doc == NULL || !dav_validate_root(doc, "update")) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00604)
                       "The request body does not contain "
                       "an \"update\" element.");
         return HTTP_BAD_REQUEST;
@@ -3792,14 +3792,14 @@ static int dav_method_update(request_rec *r)
     else if ((child = dav_find_child(doc->root, "version")) != NULL) {
         /* get the href element */
         if ((child = dav_find_child(child, "href")) == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00605)
                           "The version element does not contain "
                           "an \"href\" element.");
             return HTTP_BAD_REQUEST;
         }
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00606)
                       "The \"update\" element does not contain "
                       "a \"label-name\" or \"version\" element.");
         return HTTP_BAD_REQUEST;
@@ -3807,7 +3807,7 @@ static int dav_method_update(request_rec *r)
 
     /* a depth greater than zero is only allowed for a label */
     if (!is_label && depth != 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00607)
                       "Depth must be zero for UPDATE with a version");
         return HTTP_BAD_REQUEST;
     }
@@ -3816,7 +3816,7 @@ static int dav_method_update(request_rec *r)
     apr_xml_to_text(r->pool, child, APR_XML_X2T_INNER, NULL, NULL,
                     &target, &tsize);
     if (tsize == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00608)
                       "A \"label-name\" or \"href\" element does not contain "
                       "any content.");
         return HTTP_BAD_REQUEST;
@@ -3849,7 +3849,7 @@ static int dav_method_update(request_rec *r)
         if (lookup.rnew == NULL) {
             if (lookup.err.status == HTTP_BAD_REQUEST) {
                 /* This supplies additional information for the default message. */
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00609)
                               "%s", lookup.err.desc);
                 return HTTP_BAD_REQUEST;
             }
@@ -3996,7 +3996,7 @@ static int dav_method_label(request_rec *r)
 
     if (doc == NULL || !dav_validate_root(doc, "label")) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00610)
                       "The request body does not contain "
                       "a \"label\" element.");
         return HTTP_BAD_REQUEST;
@@ -4013,7 +4013,7 @@ static int dav_method_label(request_rec *r)
         ctx.label_op = DAV_LABEL_REMOVE;
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00611)
                       "The \"label\" element does not contain "
                       "an \"add\", \"set\", or \"remove\" element.");
         return HTTP_BAD_REQUEST;
@@ -4021,7 +4021,7 @@ static int dav_method_label(request_rec *r)
 
     /* get the label string */
     if ((child = dav_find_child(child, "label-name")) == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00612)
                       "The label command element does not contain "
                       "a \"label-name\" element.");
         return HTTP_BAD_REQUEST;
@@ -4030,7 +4030,7 @@ static int dav_method_label(request_rec *r)
     apr_xml_to_text(r->pool, child, APR_XML_X2T_INNER, NULL, NULL,
                     &ctx.label, &tsize);
     if (tsize == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00613)
                       "A \"label-name\" element does not contain "
                       "a label name.");
         return HTTP_BAD_REQUEST;
@@ -4098,7 +4098,7 @@ static int dav_method_report(request_rec *r)
         return result;
     if (doc == NULL) {
         /* This supplies additional information for the default msg. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00614)
                       "The request body must specify a report.");
         return HTTP_BAD_REQUEST;
     }
@@ -4173,7 +4173,7 @@ static int dav_method_make_workspace(request_rec *r)
 
     if (doc == NULL
         || !dav_validate_root(doc, "mkworkspace")) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00615)
                       "The request body does not contain "
                       "a \"mkworkspace\" element.");
         return HTTP_BAD_REQUEST;
@@ -4307,7 +4307,7 @@ static int dav_method_merge(request_rec *r)
 
     if (doc == NULL || !dav_validate_root(doc, "merge")) {
         /* This supplies additional information for the default msg. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00616)
                       "The request body must be present and must be a "
                       "DAV:merge element.");
         return HTTP_BAD_REQUEST;
@@ -4315,14 +4315,14 @@ static int dav_method_merge(request_rec *r)
 
     if ((source_elem = dav_find_child(doc->root, "source")) == NULL) {
         /* This supplies additional information for the default msg. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00617)
                       "The DAV:merge element must contain a DAV:source "
                       "element.");
         return HTTP_BAD_REQUEST;
     }
     if ((href_elem = dav_find_child(source_elem, "href")) == NULL) {
         /* This supplies additional information for the default msg. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00618)
                       "The DAV:source element must contain a DAV:href "
                       "element.");
         return HTTP_BAD_REQUEST;
@@ -4335,7 +4335,7 @@ static int dav_method_merge(request_rec *r)
     if (lookup.rnew == NULL) {
         if (lookup.err.status == HTTP_BAD_REQUEST) {
             /* This supplies additional information for the default message. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00619)
                           "%s", lookup.err.desc);
             return HTTP_BAD_REQUEST;
         }
@@ -4448,7 +4448,7 @@ static int dav_method_bind(request_rec *r)
     dest = apr_table_get(r->headers_in, "Destination");
     if (dest == NULL) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00620)
                       "The request is missing a Destination header.");
         return HTTP_BAD_REQUEST;
     }
@@ -4457,7 +4457,7 @@ static int dav_method_bind(request_rec *r)
     if (lookup.rnew == NULL) {
         if (lookup.err.status == HTTP_BAD_REQUEST) {
             /* This supplies additional information for the default message. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00621)
                           "%s", lookup.err.desc);
             return HTTP_BAD_REQUEST;
         }
@@ -4621,7 +4621,7 @@ static int dav_handler(request_rec *r)
     /* Reject requests with an unescaped hash character, as these may
      * be more destructive than the user intended. */
     if (r->parsed_uri.fragment != NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00622)
                      "buggy client used un-escaped hash in Request-URI");
         return dav_error_response(r, HTTP_BAD_REQUEST,
                                   "The request was invalid: the URI included "
diff --git a/modules/dav/main/util_lock.c b/modules/dav/main/util_lock.c
index b402a99..6ff70ef 100644
--- a/modules/dav/main/util_lock.c
+++ b/modules/dav/main/util_lock.c
@@ -718,7 +718,7 @@ DAV_DECLARE(int) dav_get_resource_state(request_rec *r,
         if (err != NULL) {
             /* ### don't log an error. return err. add higher-level desc. */
 
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00623)
                           "Failed to query lock-null status for %s",
                           r->filename);
 
diff --git a/modules/echo/mod_echo.c b/modules/echo/mod_echo.c
index 49a9d93..e2c4562 100644
--- a/modules/echo/mod_echo.c
+++ b/modules/echo/mod_echo.c
@@ -152,7 +152,7 @@ static int process_echo_connection(conn_rec *c)
                                   APR_BLOCK_READ, 0)) != APR_SUCCESS)) {
             apr_brigade_cleanup(bb);
             if (!APR_STATUS_IS_EOF(rv) && ! APR_STATUS_IS_TIMEUP(rv))
-                ap_log_error(APLOG_MARK, APLOG_INFO, rv, c->base_server,
+                ap_log_error(APLOG_MARK, APLOG_INFO, rv, c->base_server, APLOGNO(01611)
                              "ProtocolEcho: Failure reading from %s",
                              c->peer_ip);
             break;
@@ -161,7 +161,7 @@ static int process_echo_connection(conn_rec *c)
         /* Something horribly wrong happened.  Someone didn't block! */
         if (APR_BRIGADE_EMPTY(bb)) {
             apr_brigade_cleanup(bb);
-            ap_log_error(APLOG_MARK, APLOG_INFO, rv, c->base_server,
+            ap_log_error(APLOG_MARK, APLOG_INFO, rv, c->base_server, APLOGNO(01612)
                          "ProtocolEcho: Error - read empty brigade from %s!",
                          c->peer_ip);
             break;
@@ -179,7 +179,7 @@ static int process_echo_connection(conn_rec *c)
         APR_BRIGADE_INSERT_TAIL(bb, b);
         rv = ap_pass_brigade(c->output_filters, bb);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_INFO, rv, c->base_server,
+            ap_log_error(APLOG_MARK, APLOG_INFO, rv, c->base_server, APLOGNO(01613)
                          "ProtocolEcho: Failure writing to %s",
                          c->peer_ip);
             break;
diff --git a/modules/examples/mod_example_hooks.c b/modules/examples/mod_example_hooks.c
index 4a3bfb3..6f8a1e7 100644
--- a/modules/examples/mod_example_hooks.c
+++ b/modules/examples/mod_example_hooks.c
@@ -328,7 +328,7 @@ static x_cfg *our_cconfig(const conn_rec *c)
 static void example_log_each(apr_pool_t *p, server_rec *s, const char *note)
 {
     if (s != NULL) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "mod_example: %s",
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(02062) "mod_example: %s",
                      note);
     } else {
         apr_file_t *out = NULL;
diff --git a/modules/examples/mod_example_ipc.c b/modules/examples/mod_example_ipc.c
index a911f0b..7688764 100644
--- a/modules/examples/mod_example_ipc.c
+++ b/modules/examples/mod_example_ipc.c
@@ -141,7 +141,7 @@ static int exipc_post_config(apr_pool_t *pconf, apr_pool_t *plog,
      */
     rs = apr_temp_dir_get(&tempdir, pconf);
     if (APR_SUCCESS != rs) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rs, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rs, s, APLOGNO(02063)
                      "Failed to find temporary directory");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -159,7 +159,7 @@ static int exipc_post_config(apr_pool_t *pconf, apr_pool_t *plog,
     rs = apr_shm_create(&exipc_shm, sizeof(exipc_data),
                         (const char *) shmfilename, pconf);
     if (APR_SUCCESS != rs) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rs, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rs, s, APLOGNO(02064)
                      "Failed to create shared memory segment on file %s",
                      shmfilename);
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -204,7 +204,7 @@ static void exipc_child_init(apr_pool_t *p, server_rec *s)
                                      apr_global_mutex_lockfile(exipc_mutex),
                                      p);
     if (APR_SUCCESS != rs) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rs, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rs, s, APLOGNO(02065)
                      "Failed to reopen mutex %s in child",
                      exipc_mutex_type);
         /* There's really nothing else we can do here, since This
@@ -261,14 +261,14 @@ static int exipc_handler(request_rec *r)
                 break; /* Out of the loop */
             } else {
                 /* Some error, log and bail */
-                ap_log_error(APLOG_MARK, APLOG_ERR, rs, r->server,
+                ap_log_error(APLOG_MARK, APLOG_ERR, rs, r->server, APLOGNO(02066)
                              "Child %ld failed to acquire lock",
                              (long int)getpid());
                 break; /* Out of the loop without having the lock */
             }
         } else {
             /* Some other error, log and bail */
-            ap_log_error(APLOG_MARK, APLOG_ERR, rs, r->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rs, r->server, APLOGNO(02067)
                          "Child %ld failed to try and acquire lock",
                          (long int)getpid());
             break; /* Out of the loop without having the lock */
diff --git a/modules/experimental/mod_noloris.c b/modules/experimental/mod_noloris.c
index 11567cf..d5450c1 100644
--- a/modules/experimental/mod_noloris.c
+++ b/modules/experimental/mod_noloris.c
@@ -69,7 +69,7 @@ static int noloris_conn(conn_rec *conn)
     while (shm_rec[0] != '\0') {
         if (!strcmp(shm_rec, conn->peer_ip)) {
             apr_socket_t *csd = ap_get_conn_socket(conn);
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, conn,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, conn, APLOGNO(02059)
                           "Dropping connection from banned IP %s",
                           conn->peer_ip);
             apr_socket_close(csd);
@@ -148,7 +148,7 @@ static int noloris_monitor(apr_pool_t *pool, server_rec *s)
         if (*n >= default_max_connections) {
             /* if this isn't a trusted proxy, we mark it as bad */
             if (!apr_hash_get(trusted, ip, APR_HASH_KEY_STRING)) {
-                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(02060)
                        "noloris: banning %s with %d connections in READ state",
                        ip, *n);
                 strcpy(shm_rec, ip);
@@ -168,7 +168,7 @@ static int noloris_post(apr_pool_t *pconf, apr_pool_t *ptmp, apr_pool_t *plog,
 
     rv = apr_shm_create(&shm, shm_size, NULL, pconf);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(02061)
                      "Failed to create shm segment; mod_noloris disabled");
         apr_hash_clear(trusted);
         shm = NULL;
diff --git a/modules/filters/mod_charset_lite.c b/modules/filters/mod_charset_lite.c
index 2b720bd..31cf21e 100644
--- a/modules/filters/mod_charset_lite.c
+++ b/modules/filters/mod_charset_lite.c
@@ -213,7 +213,7 @@ static int find_code_page(request_rec *r)
     /* If we don't have a full directory configuration, bail out.
      */
     if (!dc->charset_source || !dc->charset_default) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01448)
                       "incomplete configuration: src %s, dst %s",
                       dc->charset_source ? dc->charset_source : "unspecified",
                       dc->charset_default ? dc->charset_default : "unspecified");
@@ -271,7 +271,7 @@ static int find_code_page(request_rec *r)
         rv = apr_xlate_open(&input_ctx->xlate, dc->charset_source,
                             dc->charset_default, r->pool);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01449)
                           "can't open translation %s->%s",
                           dc->charset_default, dc->charset_source);
             return HTTP_INTERNAL_SERVER_ERROR;
@@ -506,7 +506,7 @@ static void log_xlate_error(ap_filter_t *f, apr_status_t rv)
     default:
         msg = "xlate filter - returning error";
     }
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01450)
                   "%s", msg);
 }
 
@@ -582,7 +582,7 @@ static void chk_filter_chain(ap_filter_t *f)
                             const char *symbol = output ? "->" : "<-";
 
                             ap_log_rerror(APLOG_MARK, APLOG_DEBUG,
-                                          0, f->r,
+                                          0, f->r, APLOGNO(01451)
                                           "%s %s - disabling "
                                           "translation %s%s%s; existing "
                                           "translation %s%s%s",
@@ -600,7 +600,7 @@ static void chk_filter_chain(ap_filter_t *f)
                         const char *symbol = output ? "->" : "<-";
 
                         ap_log_rerror(APLOG_MARK, APLOG_ERR,
-                                      0, f->r,
+                                      0, f->r, APLOGNO(01452)
                                       "chk_filter_chain() - can't disable "
                                       "translation %s%s%s; existing "
                                       "translation %s%s%s",
@@ -811,7 +811,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
             rv = apr_xlate_open(&ctx->xlate,
                                 dc->charset_default, dc->charset_source, f->r->pool);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01453)
                               "can't open translation %s->%s",
                               dc->charset_source, dc->charset_default);
                 ctx->noop = 1;
diff --git a/modules/filters/mod_deflate.c b/modules/filters/mod_deflate.c
index ba537e4..0876cb4 100644
--- a/modules/filters/mod_deflate.c
+++ b/modules/filters/mod_deflate.c
@@ -635,7 +635,7 @@ static apr_status_t deflate_out_filter(ap_filter_t *f,
 
             if (zRC != Z_OK) {
                 deflateEnd(&ctx->stream);
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01383)
                               "unable to init Zlib: "
                               "deflateInit2 returned %d: URL %s",
                               zRC, r->uri);
@@ -736,7 +736,7 @@ static apr_status_t deflate_out_filter(ap_filter_t *f,
             b = apr_bucket_pool_create(buf, VALIDATION_SIZE, r->pool,
                                        f->c->bucket_alloc);
             APR_BRIGADE_INSERT_TAIL(ctx->bb, b);
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01384)
                           "Zlib: Compressed %ld to %ld : URL %s",
                           ctx->stream.total_in, ctx->stream.total_out, r->uri);
 
@@ -788,7 +788,7 @@ static apr_status_t deflate_out_filter(ap_filter_t *f,
             zRC = flush_libz_buffer(ctx, c, f->c->bucket_alloc, deflate,
                                     Z_SYNC_FLUSH, NO_UPDATE_CRC);
             if (zRC != Z_OK) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01385)
                               "Zlib error %d flushing zlib output buffer (%s)",
                               zRC, ctx->stream.msg);
                 return APR_EGENERAL;
@@ -847,7 +847,7 @@ static apr_status_t deflate_out_filter(ap_filter_t *f,
             zRC = deflate(&(ctx->stream), Z_NO_FLUSH);
 
             if (zRC != Z_OK) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01386)
                               "Zlib error %d deflating data (%s)", zRC,
                               ctx->stream.msg);
                 return APR_EGENERAL;
@@ -933,13 +933,13 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
         if (len != 10 ||
             deflate_hdr[0] != deflate_magic[0] ||
             deflate_hdr[1] != deflate_magic[1]) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, "Zlib: Invalid header");
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01387) "Zlib: Invalid header");
             return APR_EGENERAL;
         }
 
         /* We can't handle flags for now. */
         if (deflate_hdr[3] != 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01388)
                           "Zlib: Unsupported flags %02x", (int)deflate_hdr[3]);
             return APR_EGENERAL;
         }
@@ -949,7 +949,7 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
         if (zRC != Z_OK) {
             f->ctx = NULL;
             inflateEnd(&ctx->stream);
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01389)
                           "unable to init Zlib: "
                           "inflateInit2 returned %d: URL %s",
                           zRC, r->uri);
@@ -983,7 +983,7 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
             /* If we actually see the EOS, that means we screwed up! */
             if (APR_BUCKET_IS_EOS(bkt)) {
                 inflateEnd(&ctx->stream);
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01390)
                               "Encountered EOS bucket in inflate filter (bug?)");
                 return APR_EGENERAL;
             }
@@ -993,7 +993,7 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
                 zRC = inflate(&(ctx->stream), Z_SYNC_FLUSH);
                 if (zRC != Z_OK) {
                     inflateEnd(&ctx->stream);
-                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01391)
                                   "Zlib error %d inflating data (%s)", zRC,
                                   ctx->stream.msg);
                     return APR_EGENERAL;
@@ -1044,7 +1044,7 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
 
                 if (zRC != Z_OK) {
                     inflateEnd(&ctx->stream);
-                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01392)
                                   "Zlib error %d inflating data (%s)", zRC,
                                   ctx->stream.msg);
                     return APR_EGENERAL;
@@ -1053,7 +1053,7 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
             if (zRC == Z_STREAM_END) {
                 apr_bucket *tmp_heap, *eos;
 
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01393)
                               "Zlib: Inflated %ld to %ld : URL %s",
                               ctx->stream.total_in, ctx->stream.total_out,
                               r->uri);
@@ -1072,7 +1072,7 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
                     compCRC = getLong(ctx->stream.next_in);
                     if (ctx->crc != compCRC) {
                         inflateEnd(&ctx->stream);
-                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01394)
                                       "Zlib: CRC error inflating data");
                         return APR_EGENERAL;
                     }
@@ -1080,7 +1080,7 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
                     compLen = getLong(ctx->stream.next_in);
                     if (ctx->stream.total_out != compLen) {
                         inflateEnd(&ctx->stream);
-                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01395)
                                       "Zlib: Length %ld of inflated data does "
                                       "not match expected value %ld",
                                       ctx->stream.total_out, compLen);
@@ -1091,7 +1091,7 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
                     /* FIXME: We need to grab the 8 verification bytes
                      * from the wire! */
                     inflateEnd(&ctx->stream);
-                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01396)
                                   "Verification data not available (bug?)");
                     return APR_EGENERAL;
                 }
@@ -1202,7 +1202,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
         if (zRC != Z_OK) {
             f->ctx = NULL;
             inflateEnd(&ctx->stream);
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01397)
                           "unable to init Zlib: "
                           "inflateInit2 returned %d: URL %s",
                           zRC, r->uri);
@@ -1256,7 +1256,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
              */
             flush_libz_buffer(ctx, c, f->c->bucket_alloc, inflate, Z_SYNC_FLUSH,
                               UPDATE_CRC);
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01398)
                           "Zlib: Inflated %ld to %ld : URL %s",
                           ctx->stream.total_in, ctx->stream.total_out, r->uri);
 
@@ -1264,20 +1264,20 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
                 unsigned long compCRC, compLen;
                 compCRC = getLong(ctx->validation_buffer);
                 if (ctx->crc != compCRC) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01399)
                                   "Zlib: Checksum of inflated stream invalid");
                     return APR_EGENERAL;
                 }
                 ctx->validation_buffer += VALIDATION_SIZE / 2;
                 compLen = getLong(ctx->validation_buffer);
                 if (ctx->stream.total_out != compLen) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01400)
                                   "Zlib: Length of inflated stream invalid");
                     return APR_EGENERAL;
                 }
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01401)
                               "Zlib: Validation bytes not present");
                 return APR_EGENERAL;
             }
@@ -1304,7 +1304,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
             zRC = flush_libz_buffer(ctx, c, f->c->bucket_alloc, inflate,
                                     Z_SYNC_FLUSH, UPDATE_CRC);
             if (zRC != Z_OK) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01402)
                               "Zlib error %d flushing inflate buffer (%s)",
                               zRC, ctx->stream.msg);
                 return APR_EGENERAL;
@@ -1336,7 +1336,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
         /* first bucket contains zlib header */
         if (!ctx->inflate_init++) {
             if (len < 10) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01403)
                               "Insufficient data for inflate");
                 return APR_EGENERAL;
             }
@@ -1344,7 +1344,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
                 zlib_method = data[2];
                 zlib_flags = data[3];
                 if (zlib_method != Z_DEFLATED) {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01404)
                                   "inflate: data not deflated!");
                     ap_remove_output_filter(f);
                     return ap_pass_brigade(f->next, bb);
@@ -1352,7 +1352,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
                 if (data[0] != deflate_magic[0] ||
                     data[1] != deflate_magic[1] ||
                     (zlib_flags & RESERVED) != 0) {
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01405)
                                       "inflate: bad header");
                     return APR_EGENERAL ;
                 }
@@ -1364,7 +1364,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
                bytes += ((unsigned int)(data[1])) << 8;
                bytes += 2;
                if (len < bytes) {
-                   ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                   ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01406)
                                  "inflate: extra field too big (not "
                                  "supported)");
                    return APR_EGENERAL;
@@ -1402,7 +1402,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
                 ctx->validation_buffer_length += copy_size;
             }
             if (ctx->stream.avail_in) {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01407)
                               "Zlib: %d bytes of garbage at the end of "
                               "compressed stream.", ctx->stream.avail_in);
                 /*
@@ -1446,7 +1446,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
                                                      VALIDATION_SIZE);
                 if (ctx->stream.avail_in > VALIDATION_SIZE) {
                     ctx->validation_buffer_length = VALIDATION_SIZE;
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01408)
                                   "Zlib: %d bytes of garbage at the end of "
                                   "compressed stream.",
                                   ctx->stream.avail_in - VALIDATION_SIZE);
@@ -1460,7 +1460,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
             }
 
             if (zRC != Z_OK) {
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01409)
                               "Zlib error %d inflating data (%s)", zRC,
                               ctx->stream.msg);
                 return APR_EGENERAL;
diff --git a/modules/filters/mod_ext_filter.c b/modules/filters/mod_ext_filter.c
index 1e3beab..d223e94 100644
--- a/modules/filters/mod_ext_filter.c
+++ b/modules/filters/mod_ext_filter.c
@@ -477,7 +477,7 @@ static apr_status_t init_ext_filter_process(ap_filter_t *f)
                             ctx->procattr,
                             ctx->p);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, f->r, APLOGNO(01458)
                       "couldn't create child process to run `%s'",
                       ctx->filter->command);
         return rc;
@@ -565,7 +565,7 @@ static apr_status_t init_filter_instance(ap_filter_t *f)
     /* look for the user-defined filter */
     ctx->filter = find_filter_def(f->r->server, f->frec->name);
     if (!ctx->filter) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01459)
                       "couldn't find definition of filter '%s'",
                       f->frec->name);
         return APR_EINVAL;
@@ -655,7 +655,7 @@ static apr_status_t drain_available_output(ap_filter_t *f,
         rv = apr_file_read(ctx->proc->out, buf, &len);
         if (rv && !APR_STATUS_IS_EAGAIN(rv))
            lvl = APLOG_DEBUG;
-        ap_log_rerror(APLOG_MARK, lvl, rv, r,
+        ap_log_rerror(APLOG_MARK, lvl, rv, r, APLOGNO(01460)
                       "apr_file_read(child output), len %" APR_SIZE_T_FMT,
                       !rv ? len : -1);
         if (rv != APR_SUCCESS) {
@@ -686,7 +686,7 @@ static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data,
                        &tmplen);
         bytes_written += tmplen;
         if (rv != APR_SUCCESS && !APR_STATUS_IS_EAGAIN(rv)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01461)
                           "apr_file_write(child input), len %" APR_SIZE_T_FMT,
                           tmplen);
             return rv;
@@ -705,7 +705,7 @@ static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data,
                 rv = apr_pollset_poll(ctx->pollset, f->r->server->timeout,
                                       &num_events, &pdesc);
                 if (rv != APR_SUCCESS && !APR_STATUS_IS_EINTR(rv)) {
-                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, f->r,
+                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, f->r, APLOGNO(01462)
                                   "apr_pollset_poll()");
                     /* some error such as APR_TIMEUP */
                     return rv;
@@ -760,7 +760,7 @@ static int ef_unified_filter(ap_filter_t *f, apr_bucket_brigade *bb)
 
         rv = apr_bucket_read(b, &data, &len, APR_BLOCK_READ);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "apr_bucket_read()");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01463) "apr_bucket_read()");
             return rv;
         }
 
@@ -781,7 +781,7 @@ static int ef_unified_filter(ap_filter_t *f, apr_bucket_brigade *bb)
          * that will cause the child to finish generating output
          */
         if ((rv = apr_file_close(ctx->proc->in)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01464)
                           "apr_file_close(child input)");
             return rv;
         }
@@ -791,7 +791,7 @@ static int ef_unified_filter(ap_filter_t *f, apr_bucket_brigade *bb)
         rv = apr_file_pipe_timeout_set(ctx->proc->out,
                                        r->server->timeout);
         if (rv) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01465)
                           "apr_file_pipe_timeout_set(child output)");
             return rv;
         }
@@ -803,7 +803,7 @@ static int ef_unified_filter(ap_filter_t *f, apr_bucket_brigade *bb)
         rv = apr_file_read(ctx->proc->out, buf, &len);
         if (rv && !APR_STATUS_IS_EOF(rv) && !APR_STATUS_IS_EAGAIN(rv))
             lvl = APLOG_ERR;
-        ap_log_rerror(APLOG_MARK, lvl, rv, r,
+        ap_log_rerror(APLOG_MARK, lvl, rv, r, APLOGNO(01466)
                       "apr_file_read(child output), len %" APR_SIZE_T_FMT,
                       !rv ? len : -1);
         if (APR_STATUS_IS_EAGAIN(rv)) {
@@ -841,7 +841,7 @@ static apr_status_t ef_output_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     if (!ctx) {
         if ((rv = init_filter_instance(f)) != APR_SUCCESS) {
             ctx = f->ctx;
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01467)
                           "can't initialise output filter %s: %s",
                           f->frec->name,
                           (ctx->dc->onfail == 1) ? "removing" : "aborting");
@@ -873,12 +873,12 @@ static apr_status_t ef_output_filter(ap_filter_t *f, apr_bucket_brigade *bb)
 
     rv = ef_unified_filter(f, bb);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01468)
                       "ef_unified_filter() failed");
     }
 
     if ((rv = ap_pass_brigade(f->next, bb)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(01469)
                       "ap_pass_brigade() failed");
     }
     return rv;
@@ -894,7 +894,7 @@ static int ef_input_filter(ap_filter_t *f, apr_bucket_brigade *bb,
     if (!ctx) {
         if ((rv = init_filter_instance(f)) != APR_SUCCESS) {
             ctx = f->ctx;
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01470)
                           "can't initialise input filter %s: %s",
                           f->frec->name,
                           (ctx->dc->onfail == 1) ? "removing" : "aborting");
diff --git a/modules/filters/mod_filter.c b/modules/filters/mod_filter.c
index 936cc52..32d8bd3 100644
--- a/modules/filters/mod_filter.c
+++ b/modules/filters/mod_filter.c
@@ -83,12 +83,12 @@ static void filter_trace(conn_rec *c, int debug, const char *fname,
     case 0:        /* normal, operational use */
         return;
     case 1:        /* mod_diagnostics level */
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, "%s", fname);
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01375) "%s", fname);
         for (b = APR_BRIGADE_FIRST(bb);
              b != APR_BRIGADE_SENTINEL(bb);
              b = APR_BUCKET_NEXT(b)) {
 
-            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01376)
                           "%s: type: %s, length: %" APR_SIZE_T_FMT,
                           fname, b->type->name ? b->type->name : "(unknown)",
                           b->length);
@@ -107,14 +107,14 @@ static int filter_init(ap_filter_t *f)
     harness_ctx *fctx = apr_pcalloc(f->r->pool, sizeof(harness_ctx));
     for (p = filter->providers; p; p = p->next) {
         if (p->frec->filter_init_func == filter_init) {
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c, APLOGNO(01377)
                           "Chaining of FilterProviders not supported");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
         else if (p->frec->filter_init_func) {
             f->ctx = NULL;
             if ((err = p->frec->filter_init_func(f)) != OK) {
-                ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c,
+                ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c, APLOGNO(01378)
                               "filter_init for %s failed", p->frec->name);
                 return err;   /* if anyone errors out here, so do we */
             }
@@ -150,7 +150,7 @@ static int filter_lookup(ap_filter_t *f, ap_filter_rec_t *filter)
         if (provider->expr) {
             match = ap_expr_exec(r, provider->expr, &err);
             if (err) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01379)
                               "Error evaluating filter dispatch condition: %s",
                               err);
                 match = 0;
@@ -640,7 +640,7 @@ static void filter_insert(request_rec *r)
     for (p = cfg->chain; p; p = p->next) {
         filter = apr_hash_get(cfg->live_filters, p->fname, APR_HASH_KEY_STRING);
         if (filter == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01380)
                           "Unknown filter %s not added", p->fname);
             continue;
         }
diff --git a/modules/filters/mod_include.c b/modules/filters/mod_include.c
index 7a182b3..ffca232 100644
--- a/modules/filters/mod_include.c
+++ b/modules/filters/mod_include.c
@@ -659,13 +659,13 @@ static const char *get_include_var(const char *var, include_ctx_t *ctx)
          * v.s. empty strings on an empty match is deliberate.
          */
         if (!re || !re->have_match) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01329)
                 "regex capture $%" APR_SIZE_T_FMT " refers to no regex in %s",
                 idx, r->filename);
             return NULL;
         }
         else if (re->nsub < idx || idx >= AP_MAX_REG_MATCH) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01330)
                           "regex capture $%" APR_SIZE_T_FMT
                           " is out of range (last regex was: '%s') in %s",
                           idx, re->rexp, r->filename);
@@ -828,7 +828,7 @@ static char *ap_ssi_parse_string(include_ctx_t *ctx, const char *in, char *out,
             if (*++p == '{') {
                 ep = ap_strchr_c(++p, '}');
                 if (!ep) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Missing '}' on "
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01331) "Missing '}' on "
                                   "variable \"%s\" in %s", p, r->filename);
                     break;
                 }
@@ -1382,7 +1382,7 @@ static int parse_expr(include_ctx_t *ctx, const char *expr, int *was_error)
         case TOKEN_AND:
         case TOKEN_OR:
             if (!current->left || !current->right) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01332)
                               "Invalid expression \"%s\" in file %s",
                               expr, r->filename);
                 *was_error = 1;
@@ -1447,7 +1447,7 @@ static int parse_expr(include_ctx_t *ctx, const char *expr, int *was_error)
                 current->left->token.type != TOKEN_STRING ||
                 (current->right->token.type != TOKEN_STRING &&
                  current->right->token.type != TOKEN_RE)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01333)
                             "Invalid expression \"%s\" in file %s",
                             expr, r->filename);
                 *was_error = 1;
@@ -1482,7 +1482,7 @@ static int parse_expr(include_ctx_t *ctx, const char *expr, int *was_error)
             if (!current->left || !current->right ||
                 current->left->token.type != TOKEN_STRING ||
                 current->right->token.type != TOKEN_STRING) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01334)
                               "Invalid expression \"%s\" in file %s",
                               expr, r->filename);
                 *was_error = 1;
@@ -1530,7 +1530,7 @@ static int parse_expr(include_ctx_t *ctx, const char *expr, int *was_error)
             if (current->left || !current->right ||
                 (current->right->token.type != TOKEN_STRING &&
                  current->right->token.type != TOKEN_RE)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01335)
                             "Invalid expression \"%s\" in file %s: Token '-A' must be followed by a URI string.",
                             expr, r->filename);
                 *was_error = 1;
@@ -1546,7 +1546,7 @@ static int parse_expr(include_ctx_t *ctx, const char *expr, int *was_error)
             }
             else {
                 current->value = 0;
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rr->status, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rr->status, r, APLOGNO(01336)
                               "mod_include: The tested "
                               "subrequest -A \"%s\" returned an error code.",
                               current->right->token.value);
@@ -1596,7 +1596,7 @@ static int parse_ap_expr(include_ctx_t *ctx, const char *expr, int *was_error)
     err = ap_expr_parse(ctx->r->pool, ctx->r->pool, &expr_info, expr,
                         include_expr_lookup);
     if (err) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(01337)
                       "Could not parse expr \"%s\" in %s: %s", expr,
                       ctx->r->filename, err);
         *was_error = 1;
@@ -1632,7 +1632,7 @@ static int parse_ap_expr(include_ctx_t *ctx, const char *expr, int *was_error)
     eval_ctx->info = &expr_info;
     ret = ap_expr_exec_ctx(eval_ctx);
     if (ret < 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(01338)
                       "Could not evaluate expr \"%s\" in %s: %s", expr,
                       ctx->r->filename, ctx->intern->expr_err);
         *was_error = 1;
@@ -1743,7 +1743,7 @@ static int find_file(request_rec *r, const char *directive, const char *tag,
             return 0;
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unable to get "
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01339) "unable to get "
                           "information about \"%s\" in parsed file %s",
                           tag_val, r->filename);
             ap_destroy_sub_req(rr);
@@ -1751,7 +1751,7 @@ static int find_file(request_rec *r, const char *directive, const char *tag,
         }
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown parameter \"%s\" "
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01340) "unknown parameter \"%s\" "
                       "to tag %s in %s", tag, directive, r->filename);
         return -1;
     }
@@ -1776,7 +1776,8 @@ static apr_status_t handle_include(include_ctx_t *ctx, ap_filter_t *f,
         ap_log_rerror(APLOG_MARK,
                       (ctx->flags & SSI_FLAG_PRINTING)
                           ? APLOG_ERR : APLOG_WARNING,
-                      0, r, "missing argument for include element in %s",
+                      0, r, APLOGNO(01341)
+                      "missing argument for include element in %s",
                       r->filename);
     }
 
@@ -1804,7 +1805,7 @@ static apr_status_t handle_include(include_ctx_t *ctx, ap_filter_t *f,
 
         if (strcmp(tag, "virtual") && strcmp(tag, "file") && strcmp(tag,
                 "onerror")) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown parameter "
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01342) "unknown parameter "
                           "\"%s\" to tag include in %s", tag, r->filename);
             SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
             break;
@@ -1906,7 +1907,8 @@ static apr_status_t handle_echo(include_ctx_t *ctx, ap_filter_t *f,
         ap_log_rerror(APLOG_MARK,
                       (ctx->flags & SSI_FLAG_PRINTING)
                           ? APLOG_ERR : APLOG_WARNING,
-                      0, r, "missing argument for echo element in %s",
+                      0, r, APLOGNO(01343)
+                      "missing argument for echo element in %s",
                       r->filename);
     }
 
@@ -1969,7 +1971,7 @@ static apr_status_t handle_echo(include_ctx_t *ctx, ap_filter_t *f,
                         echo_text = ap_pbase64decode(ctx->dpool, echo_text);
                     }
                     else {
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown value "
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01344) "unknown value "
                                       "\"%s\" to parameter \"decoding\" of tag echo in "
                                       "%s", token, r->filename);
                         SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
@@ -2001,7 +2003,7 @@ static apr_status_t handle_echo(include_ctx_t *ctx, ap_filter_t *f,
                         echo_text = buf;
                     }
                     else {
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown value "
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01345) "unknown value "
                                       "\"%s\" to parameter \"encoding\" of tag echo in "
                                       "%s", token, r->filename);
                         SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
@@ -2033,7 +2035,7 @@ static apr_status_t handle_echo(include_ctx_t *ctx, ap_filter_t *f,
             encoding = tag_val;
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown parameter "
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01346) "unknown parameter "
                           "\"%s\" in tag echo of %s", tag, r->filename);
             SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
             break;
@@ -2057,7 +2059,8 @@ static apr_status_t handle_config(include_ctx_t *ctx, ap_filter_t *f,
         ap_log_rerror(APLOG_MARK,
                       (ctx->flags & SSI_FLAG_PRINTING)
                           ? APLOG_ERR : APLOG_WARNING,
-                      0, r, "missing argument for config element in %s",
+                      0, r, APLOGNO(01347)
+                      "missing argument for config element in %s",
                       r->filename);
     }
 
@@ -2114,7 +2117,7 @@ static apr_status_t handle_config(include_ctx_t *ctx, ap_filter_t *f,
                 ctx->flags &= SSI_FLAG_SIZE_ABBREV;
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown value "
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01348) "unknown value "
                               "\"%s\" to parameter \"sizefmt\" of tag config "
                               "in %s", parsed_string, r->filename);
                 SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
@@ -2122,7 +2125,7 @@ static apr_status_t handle_config(include_ctx_t *ctx, ap_filter_t *f,
             }
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown parameter "
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01349) "unknown parameter "
                           "\"%s\" to tag config in %s", tag, r->filename);
             SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
             break;
@@ -2144,7 +2147,8 @@ static apr_status_t handle_fsize(include_ctx_t *ctx, ap_filter_t *f,
         ap_log_rerror(APLOG_MARK,
                       (ctx->flags & SSI_FLAG_PRINTING)
                           ? APLOG_ERR : APLOG_WARNING,
-                      0, r, "missing argument for fsize element in %s",
+                      0, r, APLOGNO(01350)
+                      "missing argument for fsize element in %s",
                       r->filename);
     }
 
@@ -2231,7 +2235,8 @@ static apr_status_t handle_flastmod(include_ctx_t *ctx, ap_filter_t *f,
         ap_log_rerror(APLOG_MARK,
                       (ctx->flags & SSI_FLAG_PRINTING)
                           ? APLOG_ERR : APLOG_WARNING,
-                      0, r, "missing argument for flastmod element in %s",
+                      0, r, APLOGNO(01351)
+                      "missing argument for flastmod element in %s",
                       r->filename);
     }
 
@@ -2292,9 +2297,10 @@ static apr_status_t handle_if(include_ctx_t *ctx, ap_filter_t *f,
         ap_log_rerror(APLOG_MARK,
                       (ctx->flags & SSI_FLAG_PRINTING)
                           ? APLOG_ERR : APLOG_WARNING,
-                      0, r, (ctx->argc)
-                                ? "too many arguments for if element in %s"
-                                : "missing expr argument for if element in %s",
+                      0, r,
+                      (ctx->argc)
+                      ? APLOGNO(01352) "too many arguments for if element in %s"
+                      : APLOGNO(01353) "missing expr argument for if element in %s",
                       r->filename);
     }
 
@@ -2311,14 +2317,14 @@ static apr_status_t handle_if(include_ctx_t *ctx, ap_filter_t *f,
     ap_ssi_get_tag_and_value(ctx, &tag, &expr, SSI_VALUE_RAW);
 
     if (strcmp(tag, "expr")) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown parameter \"%s\" "
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01354) "unknown parameter \"%s\" "
                       "to tag if in %s", tag, r->filename);
         SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
         return APR_SUCCESS;
     }
 
     if (!expr) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "missing expr value for if "
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01355) "missing expr value for if "
                       "element in %s", r->filename);
         SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
         return APR_SUCCESS;
@@ -2364,9 +2370,10 @@ static apr_status_t handle_elif(include_ctx_t *ctx, ap_filter_t *f,
     if (ctx->argc != 1) {
         ap_log_rerror(APLOG_MARK,
                       (!(ctx->if_nesting_level)) ? APLOG_ERR : APLOG_WARNING,
-                      0, r, (ctx->argc)
-                                ? "too many arguments for if element in %s"
-                                : "missing expr argument for if element in %s",
+                      0, r,
+                      (ctx->argc)
+                      ? APLOGNO(01356) "too many arguments for if element in %s"
+                      : APLOGNO(01357) "missing expr argument for if element in %s",
                       r->filename);
     }
 
@@ -2382,14 +2389,14 @@ static apr_status_t handle_elif(include_ctx_t *ctx, ap_filter_t *f,
     ap_ssi_get_tag_and_value(ctx, &tag, &expr, SSI_VALUE_RAW);
 
     if (strcmp(tag, "expr")) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown parameter \"%s\" "
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01358) "unknown parameter \"%s\" "
                       "to tag if in %s", tag, r->filename);
         SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
         return APR_SUCCESS;
     }
 
     if (!expr) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "missing expr in elif "
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01359) "missing expr in elif "
                       "statement: %s", r->filename);
         SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
         return APR_SUCCESS;
@@ -2433,7 +2440,8 @@ static apr_status_t handle_else(include_ctx_t *ctx, ap_filter_t *f,
     if (ctx->argc) {
         ap_log_rerror(APLOG_MARK,
                       (!(ctx->if_nesting_level)) ? APLOG_ERR : APLOG_WARNING,
-                      0, r, "else directive does not take tags in %s",
+                      0, r, APLOGNO(01360)
+                      "else directive does not take tags in %s",
                       r->filename);
     }
 
@@ -2472,7 +2480,8 @@ static apr_status_t handle_endif(include_ctx_t *ctx, ap_filter_t *f,
     if (ctx->argc) {
         ap_log_rerror(APLOG_MARK,
                       (!(ctx->if_nesting_level)) ? APLOG_ERR : APLOG_WARNING,
-                      0, r, "endif directive does not take tags in %s",
+                      0, r, APLOGNO(01361)
+                      "endif directive does not take tags in %s",
                       r->filename);
     }
 
@@ -2510,7 +2519,8 @@ static apr_status_t handle_set(include_ctx_t *ctx, ap_filter_t *f,
         ap_log_rerror(APLOG_MARK,
                       (ctx->flags & SSI_FLAG_PRINTING)
                           ? APLOG_ERR : APLOG_WARNING,
-                      0, r, "missing argument for set element in %s",
+                      0, r,
+                      APLOGNO(01362) "missing argument for set element in %s",
                       r->filename);
     }
 
@@ -2556,7 +2566,7 @@ static apr_status_t handle_set(include_ctx_t *ctx, ap_filter_t *f,
             char *parsed_string;
 
             if (!var) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "variable must "
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01363) "variable must "
                               "precede value in set directive in %s",
                               r->filename);
                 SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
@@ -2596,7 +2606,7 @@ static apr_status_t handle_set(include_ctx_t *ctx, ap_filter_t *f,
                         parsed_string = ap_pbase64decode(ctx->dpool, parsed_string);
                     }
                     else {
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown value "
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01364) "unknown value "
                                       "\"%s\" to parameter \"decoding\" of tag set in "
                                       "%s", token, r->filename);
                         SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
@@ -2628,7 +2638,7 @@ static apr_status_t handle_set(include_ctx_t *ctx, ap_filter_t *f,
                         parsed_string = buf;
                     }
                     else {
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown value "
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01365) "unknown value "
                                       "\"%s\" to parameter \"encoding\" of tag set in "
                                       "%s", token, r->filename);
                         SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
@@ -2648,7 +2658,7 @@ static apr_status_t handle_set(include_ctx_t *ctx, ap_filter_t *f,
                            apr_pstrdup(p, parsed_string));
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Invalid tag for set "
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01366) "Invalid tag for set "
                           "directive in %s", r->filename);
             SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
             break;
@@ -2673,7 +2683,8 @@ static apr_status_t handle_printenv(include_ctx_t *ctx, ap_filter_t *f,
         ap_log_rerror(APLOG_MARK,
                       (ctx->flags & SSI_FLAG_PRINTING)
                           ? APLOG_ERR : APLOG_WARNING,
-                      0, r, "printenv directive does not take tags in %s",
+                      0, r,
+                      APLOGNO(01367) "printenv directive does not take tags in %s",
                       r->filename);
     }
 
@@ -3045,7 +3056,7 @@ static apr_size_t find_directive(include_ctx_t *ctx, const char *data,
 
         if (!intern->directive_len) {
             intern->error = 1;
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, "missing "
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(01368) "missing "
                           "directive name in parsed document %s",
                           ctx->r->filename);
         }
@@ -3181,7 +3192,7 @@ static apr_size_t find_argument(include_ctx_t *ctx, const char *data,
             intern->current_arg->name_len = 0;
             intern->error = 1;
 
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, "missing "
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(01369) "missing "
                           "argument name for value to tag %s in %s",
                           apr_pstrmemdup(ctx->r->pool, intern->directive,
                                          intern->directive_len),
@@ -3213,7 +3224,7 @@ static apr_size_t find_argument(include_ctx_t *ctx, const char *data,
                                                  intern->current_arg->name_len);
         if (!intern->current_arg->name_len) {
             intern->error = 1;
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, "missing "
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(01370) "missing "
                           "argument name for value to tag %s in %s",
                           apr_pstrmemdup(ctx->r->pool, intern->directive,
                                          intern->directive_len),
@@ -3689,7 +3700,7 @@ static apr_status_t send_parsed_content(ap_filter_t *f, apr_bucket_brigade *bb)
                     }
                 }
                 else {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01371)
                                   "unknown directive \"%s\" in parsed doc %s",
                                   apr_pstrmemdup(r->pool, intern->directive,
                                                  intern->directive_len),
@@ -3726,7 +3737,7 @@ static apr_status_t send_parsed_content(ap_filter_t *f, apr_bucket_brigade *bb)
             }
         }
         else if (PARSE_PRE_HEAD != intern->state) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01372)
                           "SSI directive was not properly finished at the end "
                           "of parsed document %s", r->filename);
             if (ctx->flags & SSI_FLAG_PRINTING) {
@@ -3735,7 +3746,7 @@ static apr_status_t send_parsed_content(ap_filter_t *f, apr_bucket_brigade *bb)
         }
 
         if (!(ctx->flags & SSI_FLAG_PRINTING)) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01373)
                           "missing closing endif directive in parsed document"
                           " %s", r->filename);
         }
@@ -3807,7 +3818,7 @@ static apr_status_t includes_filter(ap_filter_t *f, apr_bucket_brigade *b)
                                                        &include_module);
 
     if (!(ap_allow_options(r) & OPT_INCLUDES)) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01374)
                       "mod_include: Options +Includes (or IncludesNoExec) "
                       "wasn't set, INCLUDES filter removed");
         ap_remove_output_filter(f);
diff --git a/modules/filters/mod_proxy_html.c b/modules/filters/mod_proxy_html.c
index 7bde1ba..54e3259 100644
--- a/modules/filters/mod_proxy_html.c
+++ b/modules/filters/mod_proxy_html.c
@@ -385,12 +385,12 @@ static void pstartElement(void *ctxt, const xmlChar *uname,
         }
     }
     if (!desc && enforce) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, ctx->f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, ctx->f->r, APLOGNO(01416)
                       "Bogus HTML element %s dropped", name);
         return;
     }
     if (desc && desc->depr && (enforce == 2)) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, ctx->f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, ctx->f->r, APLOGNO(01417)
                       "Deprecated HTML element %s dropped", name);
         return;
     }
@@ -414,12 +414,12 @@ static void pstartElement(void *ctxt, const xmlChar *uname,
             if (desc && enforce > 0) {
                 switch (htmlAttrAllowed(desc, (xmlChar*)*a, 2-enforce)) {
                 case HTML_INVALID:
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, ctx->f->r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, ctx->f->r, APLOGNO(01418)
                                   "Bogus HTML attribute %s of %s dropped",
                                   *a, name);
                     continue;
                 case HTML_DEPRECATED:
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, ctx->f->r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, ctx->f->r, APLOGNO(01419)
                                   "Deprecated HTML attribute %s of %s dropped",
                                   *a, name);
                     continue;
@@ -636,7 +636,7 @@ static void pstartElement(void *ctxt, const xmlChar *uname,
 
     if ((enforce > 0) && (required_attrs > 0)) {
         /* if there are more required attributes than we found then complain */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, ctx->f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, ctx->f->r, APLOGNO(01420)
                       "HTML element %s is missing %d required attributes",
                       name, required_attrs);
     }
@@ -753,7 +753,7 @@ static void fixup_rules(saxctxt *ctx)
             const char *err;
             int ok = ap_expr_exec(r, p->cond, &err);
             if (err) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01421)
                               "Error evaluating expr: %s", err);
             }
             if (ok == 0) {
@@ -887,7 +887,7 @@ static int proxy_html_filter(ap_filter_t *f, apr_bucket_brigade *bb)
                 if (!xml2enc_charset ||
                     (xml2enc_charset(f->r, &enc, &cenc) != APR_SUCCESS)) {
                     if (!xml2enc_charset)
-                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, f->r,
+                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, f->r, APLOGNO(01422)
                      "No i18n support found.  Install mod_xml2enc if required");
                     enc = XML_CHAR_ENCODING_NONE;
                     ap_set_content_type(f->r, "text/html;charset=utf-8");
@@ -924,7 +924,7 @@ static int proxy_html_filter(ap_filter_t *f, apr_bucket_brigade *bb)
                                           apr_pool_cleanup_null);
 #ifndef USE_OLD_LIBXML2
                 if (xmlopts = xmlCtxtUseOptions(ctxt->parser, xmlopts), xmlopts)
-                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, f->r,
+                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, f->r, APLOGNO(01423)
                                   "Unsupported parser opts %x", xmlopts);
 #endif
                 if (ctxt->cfg->metafix)
@@ -942,7 +942,7 @@ static int proxy_html_filter(ap_filter_t *f, apr_bucket_brigade *bb)
             }
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01424)
                           "Error in bucket read");
         }
     }
@@ -1233,7 +1233,7 @@ static int mod_proxy_html(apr_pool_t *p, apr_pool_t *p1, apr_pool_t *p2)
     xml2enc_charset = APR_RETRIEVE_OPTIONAL_FN(xml2enc_charset);
     xml2enc_filter = APR_RETRIEVE_OPTIONAL_FN(xml2enc_filter);
     if (!xml2enc_charset) {
-        ap_log_perror(APLOG_MARK, APLOG_NOTICE, 0, p2,
+        ap_log_perror(APLOG_MARK, APLOG_NOTICE, 0, p2, APLOGNO(01425)
                       "I18n support in mod_proxy_html requires mod_xml2enc. "
                       "Without it, non-ASCII characters in proxied pages are "
                       "likely to display incorrectly.");
diff --git a/modules/filters/mod_ratelimit.c b/modules/filters/mod_ratelimit.c
index df4e6b8..028de36 100644
--- a/modules/filters/mod_ratelimit.c
+++ b/modules/filters/mod_ratelimit.c
@@ -66,7 +66,7 @@ rate_limit_filter(ap_filter_t *f, apr_bucket_brigade *input_bb)
     apr_bucket_brigade *bb = input_bb;
 
     if (f->c->aborted) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, "rl: conn aborted");
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01454) "rl: conn aborted");
         apr_brigade_cleanup(bb);
         return APR_ECONNABORTED;
     }
@@ -146,7 +146,7 @@ rate_limit_filter(ap_filter_t *f, apr_bucket_brigade *input_bb)
 
             if (rv != APR_SUCCESS) {
                 ctx->state = RATE_ERROR;
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01455)
                               "rl: full speed brigade pass failed.");
             }
         }
@@ -187,7 +187,7 @@ rate_limit_filter(ap_filter_t *f, apr_bucket_brigade *input_bb)
                 rv = apr_brigade_partition(bb, ctx->chunk_size, &stop_point);
                 if (rv != APR_SUCCESS && rv != APR_INCOMPLETE) {
                     ctx->state = RATE_ERROR;
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01456)
                                   "rl: partition failed.");
                     break;
                 }
@@ -218,7 +218,7 @@ rate_limit_filter(ap_filter_t *f, apr_bucket_brigade *input_bb)
 
                 if (rv != APR_SUCCESS) {
                     ctx->state = RATE_ERROR;
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01457)
                                   "rl: brigade pass failed.");
                     break;
                 }
diff --git a/modules/filters/mod_reflector.c b/modules/filters/mod_reflector.c
index 18074d1..469df8e 100644
--- a/modules/filters/mod_reflector.c
+++ b/modules/filters/mod_reflector.c
@@ -157,7 +157,7 @@ static int reflector_handler(request_rec * r)
                 status = ap_pass_brigade(r->output_filters, bbout);
                 if (status != APR_SUCCESS) {
                     /* no way to know what type of error occurred */
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(01410)
                              "reflector_handler: ap_pass_brigade returned %i",
                                   status);
                     return HTTP_INTERNAL_SERVER_ERROR;
diff --git a/modules/filters/mod_reqtimeout.c b/modules/filters/mod_reqtimeout.c
index 324ded7..825fb07 100644
--- a/modules/filters/mod_reqtimeout.c
+++ b/modules/filters/mod_reqtimeout.c
@@ -310,7 +310,7 @@ static apr_status_t reqtimeout_filter(ap_filter_t *f,
 
 out:
     if (APR_STATUS_IS_TIMEUP(rv)) {
-        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c,
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c, APLOGNO(01382)
                       "Request %s read timeout", ccfg->type);
         /*
          * If we allow a normal lingering close, the client may keep this
diff --git a/modules/filters/mod_request.c b/modules/filters/mod_request.c
index 77842c6..ae59ab6 100644
--- a/modules/filters/mod_request.c
+++ b/modules/filters/mod_request.c
@@ -98,7 +98,7 @@ static apr_status_t keep_body_filter(ap_filter_t *f, apr_bucket_brigade *b,
             if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)
                 || endstr == lenp || *endstr || ctx->remaining < 0) {
 
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01411)
                               "Invalid Content-Length");
 
                 ap_remove_input_filter(f);
@@ -109,7 +109,7 @@ static apr_status_t keep_body_filter(ap_filter_t *f, apr_bucket_brigade *b,
              * time, stop it here if it is invalid.
              */
             if (dconf->keep_body < ctx->remaining) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01412)
                           "Requested content-length of %" APR_OFF_T_FMT
                           " is larger than the configured limit"
                           " of %" APR_OFF_T_FMT, ctx->remaining, dconf->keep_body);
@@ -136,7 +136,7 @@ static apr_status_t keep_body_filter(ap_filter_t *f, apr_bucket_brigade *b,
             apr_brigade_cleanup(f->r->kept_body);
             f->r->kept_body = NULL;
         }
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01413)
                       "Requested content-length of %" APR_OFF_T_FMT
                       " is larger than the configured limit"
                       " of %" APR_OFF_T_FMT, len, ctx->keep_body);
@@ -233,12 +233,12 @@ static apr_status_t kept_body_filter(ap_filter_t *f, apr_bucket_brigade *b,
 
     /* send part of the kept_body */
     if ((rv = apr_brigade_partition(kept_body, ctx->offset, &ec)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01414)
                       "apr_brigade_partition() failed on kept_body at %" APR_OFF_T_FMT, ctx->offset);
         return rv;
     }
     if ((rv = apr_brigade_partition(kept_body, ctx->offset + readbytes, &e2)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01415)
                       "apr_brigade_partition() failed on kept_body at %" APR_OFF_T_FMT, ctx->offset + readbytes);
         return rv;
     }
diff --git a/modules/filters/mod_sed.c b/modules/filters/mod_sed.c
index dd776c4..8d93aad 100644
--- a/modules/filters/mod_sed.c
+++ b/modules/filters/mod_sed.c
@@ -64,7 +64,7 @@ module AP_MODULE_DECLARE_DATA sed_module;
 static apr_status_t log_sed_errf(void *data, const char *error)
 {
     request_rec *r = (request_rec *) data;
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "%s", error);
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01381) "%s", error);
     return APR_SUCCESS;
 }
 
diff --git a/modules/filters/mod_substitute.c b/modules/filters/mod_substitute.c
index 3fd0ad0..15cd8ee 100644
--- a/modules/filters/mod_substitute.c
+++ b/modules/filters/mod_substitute.c
@@ -531,7 +531,7 @@ static apr_status_t substitute_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     return APR_SUCCESS;
 err:
     if (rv == APR_ENOMEM)
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, "Line too long, URI %s",
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01328) "Line too long, URI %s",
                       f->r->uri);
     apr_pool_clear(ctx->tpool);
     return rv;
diff --git a/modules/filters/mod_xml2enc.c b/modules/filters/mod_xml2enc.c
index e2588b8..fd54444 100644
--- a/modules/filters/mod_xml2enc.c
+++ b/modules/filters/mod_xml2enc.c
@@ -101,7 +101,7 @@ static apr_status_t xml2enc_filter(request_rec* r, const char* enc,
     }
     else {
         rv = APR_EGENERAL;
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01426)
                       "xml2enc: bad mode %x", mode);
     }
     if (rv == APR_SUCCESS) {
@@ -115,7 +115,7 @@ static apr_status_t xml2enc_filter(request_rec* r, const char* enc,
         ap_add_output_filter("xml2enc", ctx, r, r->connection);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01427)
                       "xml2enc: Charset %s not supported.", enc) ;
     }
     return rv;
@@ -148,7 +148,7 @@ static void fix_skipto(request_rec* r, xml2ctx* ctx)
                     ctx->bytes -= (p-ctx->buf);
                     ctx->buf = p ;
                     found = 1;
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01428)
                                   "Skipped to first <%s> element",
                                   starts[i].val) ;
                     break;
@@ -157,7 +157,7 @@ static void fix_skipto(request_rec* r, xml2ctx* ctx)
             p = ap_strchr(p+1, '<');
         }
         if (p == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01429)
                           "Failed to find start of recognised HTML!");
         }
     }
@@ -174,7 +174,7 @@ static void sniff_encoding(request_rec* r, xml2ctx* ctx)
     const char* ctype = r->content_type;
 
     if (ctype) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01430)
                       "Content-Type is %s", ctype) ;
 
         /* If we've got it in the HTTP headers, there's nothing to do */
@@ -182,7 +182,7 @@ static void sniff_encoding(request_rec* r, xml2ctx* ctx)
             p += 8 ;
             if (ctx->encoding = apr_pstrndup(r->pool, p, strcspn(p, " ;") ),
                 ctx->encoding) {
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01431)
                               "Got charset %s from HTTP headers", ctx->encoding) ;
                 ctx->xml2enc = xmlParseCharEncoding(ctx->encoding);
             }
@@ -194,7 +194,7 @@ static void sniff_encoding(request_rec* r, xml2ctx* ctx)
         ctx->xml2enc = xmlDetectCharEncoding((const xmlChar*)ctx->buf,
                                              ctx->bytes); 
         if (HAVE_ENCODING(ctx->xml2enc)) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01432)
                           "Got charset from XML rules.") ;
             ctx->encoding = xmlGetCharEncodingName(ctx->xml2enc);
         }
@@ -219,7 +219,7 @@ static void sniff_encoding(request_rec* r, xml2ctx* ctx)
                     ctx->encoding) {
                     ctx->xml2enc = xmlParseCharEncoding(ctx->encoding);
                     if (HAVE_ENCODING(ctx->xml2enc))
-                        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01433)
                                       "Got charset %s from HTML META", ctx->encoding) ;
                 }
             }
@@ -249,14 +249,14 @@ static void sniff_encoding(request_rec* r, xml2ctx* ctx)
             ctx->encoding = cfg->default_charset?cfg->default_charset:"ISO-8859-1";
         }
         /* Unsupported charset. Can we get (iconv) support through apr_xlate? */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01434)
                       "Charset %s not supported by libxml2; trying apr_xlate",
                       ctx->encoding);
         if (apr_xlate_open(&ctx->convset, "UTF-8", ctx->encoding, r->pool)
             == APR_SUCCESS) {
             ctx->xml2enc = XML_CHAR_ENCODING_UTF8 ;
         } else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01435)
                           "Charset %s not supported.  Consider aliasing it?",
                           ctx->encoding) ;
         }
@@ -264,7 +264,7 @@ static void sniff_encoding(request_rec* r, xml2ctx* ctx)
 
     if (!HAVE_ENCODING(ctx->xml2enc)) {
         /* Use configuration default as a last resort */
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01436)
                   "No usable charset information; using configuration default");
         ctx->xml2enc = (cfg->default_encoding == XML_CHAR_ENCODING_NONE)
                         ? XML_CHAR_ENCODING_8859_1 : cfg->default_encoding ;
@@ -417,7 +417,7 @@ static apr_status_t xml2enc_ffunc(ap_filter_t* f, apr_bucket_brigade* bb)
                      * Save remaining data for next time round
                      */
           
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r, APLOGNO(01437)
                                   "xml2enc: Setting aside %" APR_SIZE_T_FMT
                                   " unconverted bytes", bytes);
                     rv = ap_fflush(f->next, ctx->bbnext);
@@ -434,7 +434,7 @@ static apr_status_t xml2enc_ffunc(ap_filter_t* f, apr_bucket_brigade* bb)
                     APR_BUCKET_REMOVE(b);
                     apr_bucket_destroy(b);
                 }
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r, APLOGNO(01438)
                               "xml2enc: consuming %" APR_SIZE_T_FMT
                               " bytes flattened", bytes);
             }
@@ -443,7 +443,7 @@ static apr_status_t xml2enc_ffunc(ap_filter_t* f, apr_bucket_brigade* bb)
                                      APR_BLOCK_READ);
                 APR_BUCKET_REMOVE(b);
                 bdestroy = b;  /* can't destroy until finished with the data */
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r, APLOGNO(01439)
                               "xml2enc: consuming %" APR_SIZE_T_FMT
                               " bytes from bucket", bytes);
             }
@@ -461,7 +461,7 @@ static apr_status_t xml2enc_ffunc(ap_filter_t* f, apr_bucket_brigade* bb)
                         b = apr_bucket_transient_create(buf+(bytes - insz), insz,
                                                         bb->bucket_alloc);
                         APR_BRIGADE_INSERT_HEAD(bb, b);
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r, APLOGNO(01440)
                                       "xml2enc: reinserting %" APR_SIZE_T_FMT
                                       " unconsumed bytes from bucket", insz);
                         break;
@@ -469,7 +469,7 @@ static apr_status_t xml2enc_ffunc(ap_filter_t* f, apr_bucket_brigade* bb)
                     ctx->bytes = (apr_size_t)ctx->bblen;
                     rv = apr_xlate_conv_buffer(ctx->convset, buf+(bytes - insz),
                                                &insz, ctx->buf, &ctx->bytes);
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, f->r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, f->r, APLOGNO(01441)
                                   "xml2enc: converted %" APR_SIZE_T_FMT
                                   "/%" APR_OFF_T_FMT " bytes", consumed - insz,
                                   ctx->bblen - ctx->bytes);
@@ -477,7 +477,7 @@ static apr_status_t xml2enc_ffunc(ap_filter_t* f, apr_bucket_brigade* bb)
                     rv2 = ap_fwrite(f->next, ctx->bbnext, ctx->buf,
                                     (apr_size_t)ctx->bblen - ctx->bytes);
                     if (rv2 != APR_SUCCESS) {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv2, f->r,
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv2, f->r, APLOGNO(01442)
                                       "ap_fwrite failed");
                         return rv2;
                     }
@@ -485,14 +485,14 @@ static apr_status_t xml2enc_ffunc(ap_filter_t* f, apr_bucket_brigade* bb)
                     case APR_SUCCESS:
                         continue;
                     case APR_EINCOMPLETE:
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r, APLOGNO(01443)
                                       "INCOMPLETE");
                         continue;     /* If outbuf too small, go round again.
                                        * If it was inbuf, we'll break out when
                                        * we test ctx->bytes == ctx->bblen
                                        */
                     case APR_EINVAL: /* try skipping one bad byte */
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01444)
                                    "Skipping invalid byte(s) in input stream!");
                         --insz;
                         continue;
@@ -500,19 +500,19 @@ static apr_status_t xml2enc_ffunc(ap_filter_t* f, apr_bucket_brigade* bb)
                         /* Erk!  What's this?
                          * Bail out, flush, and hope to eat the buf raw
                          */
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01445)
                                       "Failed to convert input; trying it raw") ;
                         ctx->convset = NULL;
                         rv = ap_fflush(f->next, ctx->bbnext);
                         if (rv != APR_SUCCESS)
-                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, f->r,
+                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, f->r, APLOGNO(01446)
                                           "ap_fflush failed");
                         else
                             rv = ap_pass_brigade(f->next, ctx->bbnext);
                     }
                 }
             } else {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, APLOGNO(01447)
                               "xml2enc: error reading data") ;
             }
             if (bdestroy)
diff --git a/modules/generators/mod_asis.c b/modules/generators/mod_asis.c
index fbf1396..1fc1438 100644
--- a/modules/generators/mod_asis.c
+++ b/modules/generators/mod_asis.c
@@ -44,14 +44,14 @@ static int asis_handler(request_rec *r)
     }
 
     if (r->finfo.filetype == APR_NOFILE) {
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01233)
                     "File does not exist: %s", r->filename);
         return HTTP_NOT_FOUND;
     }
 
     if ((rv = apr_file_open(&f, r->filename, APR_READ,
                 APR_OS_DEFAULT, r->pool)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01234)
                     "file permissions deny server access: %s", r->filename);
         return HTTP_FORBIDDEN;
     }
@@ -85,7 +85,7 @@ static int asis_handler(request_rec *r)
 
         rv = apr_file_seek(f, APR_CUR, &pos);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01235)
                           "mod_asis: failed to find end-of-headers position "
                           "for %s", r->filename);
             apr_file_close(f);
@@ -99,7 +99,7 @@ static int asis_handler(request_rec *r)
         APR_BRIGADE_INSERT_TAIL(bb, b);
         rv = ap_pass_brigade(r->output_filters, bb);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01236)
                           "mod_asis: ap_pass_brigade failed for file %s", r->filename);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
diff --git a/modules/generators/mod_autoindex.c b/modules/generators/mod_autoindex.c
index b688867..bf8005e 100644
--- a/modules/generators/mod_autoindex.c
+++ b/modules/generators/mod_autoindex.c
@@ -2023,7 +2023,7 @@ static int index_directory(request_rec *r,
     char *charset;
 
     if ((status = apr_dir_open(&thedir, name, r->pool)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01275)
                       "Can't open directory for index: %s", r->filename);
         return HTTP_FORBIDDEN;
     }
@@ -2310,7 +2310,7 @@ static int handle_autoindex(request_rec *r)
     else {
         const char *index_names = apr_table_get(r->notes, "dir-index-names");
 
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01276)
                       "Cannot serve directory %s: No matching DirectoryIndex (%s) found, and "
                       "server-generated directory index forbidden by "
                       "Options directive",
diff --git a/modules/generators/mod_cgi.c b/modules/generators/mod_cgi.c
index db45295..385bb36 100644
--- a/modules/generators/mod_cgi.c
+++ b/modules/generators/mod_cgi.c
@@ -210,7 +210,7 @@ static apr_status_t log_script_err(request_rec *r, apr_file_t *script_err)
         if (newline) {
             *newline = '\0';
         }
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01215)
                       "%s", argsbuffer);
     }
 
@@ -449,7 +449,7 @@ static apr_status_t run_cgi_child(apr_file_t **script_out,
                                         e_info->addrspace)) != APR_SUCCESS) ||
         ((rc = apr_procattr_child_errfn_set(procattr, cgi_child_errfn)) != APR_SUCCESS)) {
         /* Something bad happened, tell the world. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(01216)
                       "couldn't set child process attributes: %s", r->filename);
     }
     else {
@@ -587,7 +587,7 @@ static apr_bucket *cgi_bucket_create(request_rec *r,
     /* Create the pollset */
     rv = apr_pollset_create(&data->pollset, 2, r->pool, 0);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01217)
                      "apr_pollset_create(); check system or user limits");
         return NULL;
     }
@@ -599,7 +599,7 @@ static apr_bucket *cgi_bucket_create(request_rec *r,
     fd.client_data = (void *)1;
     rv = apr_pollset_add(data->pollset, &fd);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01218)
                      "apr_pollset_add(); check system or user limits");
         return NULL;
     }
@@ -608,7 +608,7 @@ static apr_bucket *cgi_bucket_create(request_rec *r,
     fd.client_data = (void *)2;
     rv = apr_pollset_add(data->pollset, &fd);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01219)
                      "apr_pollset_add(); check system or user limits");
         return NULL;
     }
@@ -690,7 +690,7 @@ static apr_status_t cgi_bucket_read(apr_bucket *b, const char **str,
         rv = apr_pollset_poll(data->pollset, timeout, &num, &results);
         if (APR_STATUS_IS_TIMEUP(rv)) {
             if (timeout) {
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, data->r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, data->r, APLOGNO(01220)
                               "Timeout waiting for output from CGI script %s",
                               data->r->filename);
                 return rv;
@@ -703,7 +703,7 @@ static apr_status_t cgi_bucket_read(apr_bucket *b, const char **str,
             continue;
         }
         else if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, data->r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, data->r, APLOGNO(01221)
                           "poll failed waiting for CGI child");
             return rv;
         }
@@ -820,7 +820,7 @@ static int cgi_handler(request_rec *r)
 
     /* build the command line */
     if ((rv = cgi_build_command(&command, &argv, r, p, &e_info)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01222)
                       "don't know how to spawn child process: %s",
                       r->filename);
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -829,7 +829,7 @@ static int cgi_handler(request_rec *r)
     /* run the script in its own process */
     if ((rv = run_cgi_child(&script_out, &script_in, &script_err,
                             command, argv, r, p, &e_info)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01223)
                       "couldn't spawn child process: %s", r->filename);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -852,11 +852,11 @@ static int cgi_handler(request_rec *r)
 
         if (rv != APR_SUCCESS) {
             if (APR_STATUS_IS_TIMEUP(rv)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01224)
                               "Timeout during reading request entity data");
                 return HTTP_REQUEST_TIME_OUT;
             }
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01225)
                           "Error reading request entity data");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -1130,7 +1130,7 @@ static apr_status_t include_cmd(include_ctx_t *ctx, ap_filter_t *f,
 
     if ((rv = cgi_build_command(&command, &argv, r, r->pool,
                                 &e_info)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01226)
                       "don't know how to spawn cmd child process: %s",
                       r->filename);
         return rv;
@@ -1140,7 +1140,7 @@ static apr_status_t include_cmd(include_ctx_t *ctx, ap_filter_t *f,
     if ((rv = run_cgi_child(&script_out, &script_in, &script_err,
                             command, argv, r, r->pool,
                             &e_info)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01227)
                       "couldn't spawn child process: %s", r->filename);
         return rv;
     }
@@ -1183,7 +1183,7 @@ static apr_status_t handle_exec(include_ctx_t *ctx, ap_filter_t *f,
     }
 
     if (ctx->flags & SSI_FLAG_NO_EXEC) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "exec used but not allowed "
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01228) "exec used but not allowed "
                       "in %s", r->filename);
         SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
         return APR_SUCCESS;
@@ -1203,7 +1203,7 @@ static apr_status_t handle_exec(include_ctx_t *ctx, ap_filter_t *f,
 
             rv = include_cmd(ctx, f, bb, parsed_string);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "execution failure "
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01229) "execution failure "
                               "for parameter \"%s\" to tag exec in file %s",
                               tag, r->filename);
                 SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
@@ -1218,14 +1218,14 @@ static apr_status_t handle_exec(include_ctx_t *ctx, ap_filter_t *f,
 
             rv = include_cgi(ctx, f, bb, parsed_string);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "invalid CGI ref "
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01230) "invalid CGI ref "
                               "\"%s\" in %s", tag_val, file);
                 SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
                 break;
             }
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown parameter "
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01231) "unknown parameter "
                           "\"%s\" to tag exec in %s", tag, file);
             SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
             break;
diff --git a/modules/generators/mod_cgid.c b/modules/generators/mod_cgid.c
index 83e6dc1..1e4aaf6 100644
--- a/modules/generators/mod_cgid.c
+++ b/modules/generators/mod_cgid.c
@@ -290,11 +290,11 @@ static void cgid_maint(int reason, void *data, apr_wait_t status)
             }
             if (!stopping) {
                 if (status == DAEMON_STARTUP_ERROR) {
-                    ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf,
+                    ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf, APLOGNO(01238)
                                  "cgid daemon failed to initialize");
                 }
                 else {
-                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
+                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(01239)
                                  "cgid daemon process died, restarting");
                     cgid_start(root_pool, root_server, proc);
                 }
@@ -319,7 +319,7 @@ static void cgid_maint(int reason, void *data, apr_wait_t status)
              * guarantee the same permissions as when the socket was created.
              */
             if (unlink(sockname) < 0 && errno != ENOENT) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, errno, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_ERR, errno, ap_server_conf, APLOGNO(01240)
                              "Couldn't unlink unix domain socket %s",
                              sockname);
             }
@@ -588,7 +588,7 @@ static void cgid_child_errfn(apr_pool_t *pool, apr_status_t err,
      * have r->headers_in and possibly other storage referenced by
      * ap_log_rerror()
      */
-    ap_log_error(APLOG_MARK, APLOG_ERR, err, r->server, "%s", description);
+    ap_log_error(APLOG_MARK, APLOG_ERR, err, r->server, APLOGNO(01241) "%s", description);
 }
 
 static int cgid_server(void *data)
@@ -614,7 +614,7 @@ static int cgid_server(void *data)
     apr_hook_sort_all();
 
     if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, APLOGNO(01242)
                      "Couldn't create unix domain socket");
         return errno;
     }
@@ -623,7 +623,7 @@ static int cgid_server(void *data)
     rc = bind(sd, (struct sockaddr *)server_addr, server_addr_len);
     umask(omask); /* can't fail, so can't clobber errno */
     if (rc < 0) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, APLOGNO(01243)
                      "Couldn't bind unix domain socket %s",
                      sockname);
         return errno;
@@ -632,21 +632,21 @@ static int cgid_server(void *data)
     /* Not all flavors of unix use the current umask for AF_UNIX perms */
     rv = apr_file_perms_set(sockname, APR_FPROT_UREAD|APR_FPROT_UWRITE|APR_FPROT_UEXECUTE);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, main_server,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, main_server, APLOGNO(01244)
                      "Couldn't set permissions on unix domain socket %s",
                      sockname);
         return rv;
     }
 
     if (listen(sd, DEFAULT_CGID_LISTENBACKLOG) < 0) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, APLOGNO(01245)
                      "Couldn't listen on unix domain socket");
         return errno;
     }
 
     if (!geteuid()) {
         if (chown(sockname, ap_unixd_config.user_id, -1) < 0) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, APLOGNO(01246)
                          "Couldn't change owner of unix domain socket %s",
                          sockname);
             return errno;
@@ -693,7 +693,7 @@ static int cgid_server(void *data)
 #endif
             if (errno != EINTR) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, errno,
-                             (server_rec *)data,
+                             (server_rec *)data, APLOGNO(01247)
                              "Error accepting on cgid socket");
             }
             continue;
@@ -705,14 +705,14 @@ static int cgid_server(void *data)
         stat = get_req(sd2, r, &argv0, &env, &cgid_req);
         if (stat != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR, stat,
-                         main_server,
+                         main_server, APLOGNO(01248)
                          "Error reading request on cgid socket");
             close(sd2);
             continue;
         }
 
         if (cgid_req.ppid != parent_pid) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, main_server,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, main_server, APLOGNO(01249)
                          "CGI request received from wrong server instance; "
                          "see ScriptSock directive");
             close(sd2);
@@ -727,7 +727,7 @@ static int cgid_server(void *data)
             rv = sock_write(sd2, &pid, sizeof(pid));
             if (rv != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, rv,
-                             main_server,
+                             main_server, APLOGNO(01250)
                              "Error writing pid %" APR_PID_T_FMT " to handler", pid);
             }
             close(sd2);
@@ -786,7 +786,7 @@ static int cgid_server(void *data)
              * ap_log_rerror() won't work because the header table used by
              * ap_log_rerror() hasn't been replicated in the phony r
              */
-            ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server, APLOGNO(01251)
                          "couldn't set child process attributes: %s", r->filename);
 
             procnew->pid = 0; /* no process to clean up */
@@ -824,7 +824,7 @@ static int cgid_server(void *data)
                  * ap_log_rerror() won't work because the header table used by
                  * ap_log_rerror() hasn't been replicated in the phony r
                  */
-                ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server,
+                ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server, APLOGNO(01252)
                              "couldn't create child process: %d: %s", rc,
                              apr_filepath_name_get(r->filename));
 
@@ -865,7 +865,7 @@ static int cgid_start(apr_pool_t *p, server_rec *main_server,
 
     daemon_should_exit = 0; /* clear setting from previous generation */
     if ((daemon_pid = fork()) < 0) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, APLOGNO(01253)
                      "mod_cgid: Couldn't spawn cgid daemon process");
         return DECLINED;
     }
@@ -925,7 +925,7 @@ static int cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
         tmp_sockname = ap_server_root_relative(p, sockname);
         if (strlen(tmp_sockname) > sizeof(server_addr->sun_path) - 1) {
             tmp_sockname[sizeof(server_addr->sun_path)] = '\0';
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, main_server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, main_server, APLOGNO(01254)
                         "The length of the ScriptSock path exceeds maximum, "
                         "truncating to %s", tmp_sockname);
         }
@@ -1191,11 +1191,11 @@ static int connect_to_daemon(int *sdptr, request_rec *r,
         ++connect_tries;
         if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
             return log_scripterror(r, conf, HTTP_INTERNAL_SERVER_ERROR, errno,
-                                   "unable to create socket to cgi daemon");
+                                   APLOGNO(01255) "unable to create socket to cgi daemon");
         }
         if (connect(sd, (struct sockaddr *)server_addr, server_addr_len) < 0) {
             if (errno == ECONNREFUSED && connect_tries < DEFAULT_CONNECT_ATTEMPTS) {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, errno, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, errno, r, APLOGNO(01256)
                               "connect #%d to cgi daemon failed, sleeping before retry",
                               connect_tries);
                 close(sd);
@@ -1206,7 +1206,7 @@ static int connect_to_daemon(int *sdptr, request_rec *r,
             }
             else {
                 close(sd);
-                return log_scripterror(r, conf, HTTP_SERVICE_UNAVAILABLE, errno,
+                return log_scripterror(r, conf, HTTP_SERVICE_UNAVAILABLE, errno, APLOGNO(01257)
                                        "unable to connect to cgi daemon after multiple tries");
             }
         }
@@ -1217,7 +1217,7 @@ static int connect_to_daemon(int *sdptr, request_rec *r,
         }
         /* gotta try again, but make sure the cgid daemon is still around */
         if (kill(daemon_pid, 0) != 0) {
-            return log_scripterror(r, conf, HTTP_SERVICE_UNAVAILABLE, errno,
+            return log_scripterror(r, conf, HTTP_SERVICE_UNAVAILABLE, errno, APLOGNO(01258)
                                    "cgid daemon is gone; is Apache terminating?");
         }
     }
@@ -1291,14 +1291,14 @@ static apr_status_t cleanup_nonchild_process(request_rec *r, pid_t pid)
     if (dead_yet(pid, apr_time_from_sec(3)) == APR_SUCCESS) {
         return APR_SUCCESS;
     }
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01259)
                   "CGI process %" APR_PID_T_FMT " didn't exit, sending SIGKILL",
                   pid);
     kill(pid, SIGKILL);
     if (dead_yet(pid, apr_time_from_sec(3)) == APR_SUCCESS) {
         return APR_SUCCESS;
     }
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01260)
                   "CGI process %" APR_PID_T_FMT " didn't exit, sending SIGKILL again",
                   pid);
     kill(pid, SIGKILL);
@@ -1338,7 +1338,7 @@ static apr_status_t cleanup_script(void *vptr)
     }
 
     if (pid == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, info->r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, info->r, APLOGNO(01261)
                       "daemon couldn't find CGI process for connection %lu",
                       info->conn_id);
         return APR_EGENERAL;
@@ -1380,12 +1380,12 @@ static int cgid_handler(request_rec *r)
     argv0 = r->filename;
 
     if (!(ap_allow_options(r) & OPT_EXECCGI) && !is_scriptaliased(r)) {
-        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,
+        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, APLOGNO(01262)
                 "Options ExecCGI is off in this directory");
     }
 
     if (nph && is_included) {
-        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,
+        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, APLOGNO(01263)
                 "attempt to include NPH CGI script");
     }
 
@@ -1394,12 +1394,12 @@ static int cgid_handler(request_rec *r)
 #error at mod_cgi.c for required code in this path.
 #else
     if (r->finfo.filetype == APR_NOFILE) {
-        return log_scripterror(r, conf, HTTP_NOT_FOUND, 0,
+        return log_scripterror(r, conf, HTTP_NOT_FOUND, 0, APLOGNO(01264)
                 "script not found or unable to stat");
     }
 #endif
     if (r->finfo.filetype == APR_DIR) {
-        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,
+        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, APLOGNO(01265)
                 "attempt to invoke directory as script");
     }
 
@@ -1407,13 +1407,13 @@ static int cgid_handler(request_rec *r)
         r->path_info && *r->path_info)
     {
         /* default to accept */
-        return log_scripterror(r, conf, HTTP_NOT_FOUND, 0,
+        return log_scripterror(r, conf, HTTP_NOT_FOUND, 0, APLOGNO(01266)
                                "AcceptPathInfo off disallows user's path");
     }
 /*
     if (!ap_suexec_enabled) {
         if (!ap_can_exec(&r->finfo))
-            return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,
+            return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, APLOGNO(01267)
                                    "file permissions deny server execution");
     }
 */
@@ -1427,7 +1427,7 @@ static int cgid_handler(request_rec *r)
 
     rv = send_req(sd, r, argv0, env, CGI_REQ);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01268)
                      "write to cgi daemon process");
     }
 
@@ -1466,11 +1466,11 @@ static int cgid_handler(request_rec *r)
 
         if (rv != APR_SUCCESS) {
             if (APR_STATUS_IS_TIMEUP(rv)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01269)
                               "Timeout during reading request entity data");
                 return HTTP_REQUEST_TIME_OUT;
             }
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01270)
                           "Error reading request entity data");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -1810,7 +1810,7 @@ static apr_status_t handle_exec(include_ctx_t *ctx, ap_filter_t *f,
     }
 
     if (ctx->flags & SSI_FLAG_NO_EXEC) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "exec used but not allowed "
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01271) "exec used but not allowed "
                       "in %s", r->filename);
         SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
         return APR_SUCCESS;
@@ -1830,7 +1830,7 @@ static apr_status_t handle_exec(include_ctx_t *ctx, ap_filter_t *f,
 
             rv = include_cmd(ctx, f, bb, parsed_string);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01272)
                               "execution failure for parameter \"%s\" "
                               "to tag exec in file %s", tag, r->filename);
                 SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
@@ -1845,14 +1845,14 @@ static apr_status_t handle_exec(include_ctx_t *ctx, ap_filter_t *f,
 
             rv = include_cgi(ctx, f, bb, parsed_string);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "invalid CGI ref "
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01273) "invalid CGI ref "
                               "\"%s\" in %s", tag_val, file);
                 SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
                 break;
             }
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "unknown parameter "
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01274) "unknown parameter "
                           "\"%s\" to tag exec in %s", tag, file);
             SSI_CREATE_ERROR_BUCKET(ctx, f, bb);
             break;
diff --git a/modules/generators/mod_status.c b/modules/generators/mod_status.c
index 47f5988..ced19ed 100644
--- a/modules/generators/mod_status.c
+++ b/modules/generators/mod_status.c
@@ -245,7 +245,7 @@ static int status_handler(request_rec *r)
     tu = ts = tcu = tcs = 0;
 
     if (!ap_exists_scoreboard_image()) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01237)
                       "Server status unavailable in inetd mode");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
diff --git a/modules/generators/mod_suexec.c b/modules/generators/mod_suexec.c
index 9a7d2cf..75e9640 100644
--- a/modules/generators/mod_suexec.c
+++ b/modules/generators/mod_suexec.c
@@ -97,7 +97,7 @@ static int suexec_post_config(apr_pool_t *p, apr_pool_t *plog,
                           s->process->pool);
 
     if ((reported == NULL) && ap_unixd_config.suexec_enabled) {
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s, APLOGNO(01232)
                      "suEXEC mechanism enabled (wrapper: %s)", SUEXEC_BIN);
 
         apr_pool_userdata_set((void *)1, SUEXEC_POST_CONFIG_USERDATA,
diff --git a/modules/http/byterange_filter.c b/modules/http/byterange_filter.c
index 14c7630..b2c678d 100644
--- a/modules/http/byterange_filter.c
+++ b/modules/http/byterange_filter.c
@@ -305,7 +305,7 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
 
     r->status = HTTP_PARTIAL_CONTENT;
     r->range = apr_array_pstrcat(r->pool, merged, ',');
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01583)
                   "Range: %s | %s (%d : %d : %"APR_OFF_T_FMT")",
                   it, r->range, *overlaps, *reversals, clength);
 
@@ -551,7 +551,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(ap_filter_t *f,
 
         rv = copy_brigade_range(bb, tmpbb, range_start, range_end);
         if (rv != APR_SUCCESS ) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01584)
                           "copy_brigade_range() failed [%" APR_OFF_T_FMT
                           "-%" APR_OFF_T_FMT ",%" APR_OFF_T_FMT "]",
                           range_start, range_end, clength);
diff --git a/modules/http/http_filters.c b/modules/http/http_filters.c
index acc4fe1..500b5cf 100644
--- a/modules/http/http_filters.c
+++ b/modules/http/http_filters.c
@@ -267,12 +267,12 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
                 /* Something that isn't in HTTP, unless some future
                  * edition defines new transfer ecodings, is unsupported.
                  */
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)
                               "Unknown Transfer-Encoding: %s", tenc);
                 return bail_out_on_error(ctx, f, HTTP_NOT_IMPLEMENTED);
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, f->r, APLOGNO(01586)
                   "Unknown Transfer-Encoding: %s; using Content-Length", tenc);
                 tenc = NULL;
             }
@@ -289,7 +289,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
                 || endstr == lenp || *endstr || ctx->remaining < 0) {
 
                 ctx->remaining = 0;
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)
                               "Invalid Content-Length");
 
                 return bail_out_on_error(ctx, f, HTTP_REQUEST_ENTITY_TOO_LARGE);
@@ -299,7 +299,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
              * time, stop it here if it is invalid.
              */
             if (ctx->limit && ctx->limit < ctx->remaining) {
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)
                           "Requested content-length of %" APR_OFF_T_FMT
                           " is larger than the configured limit"
                           " of %" APR_OFF_T_FMT, ctx->remaining, ctx->limit);
@@ -392,7 +392,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
 
             /* Detect chunksize error (such as overflow) */
             if (rv != APR_SUCCESS || ctx->remaining < 0) {
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, "Error reading first chunk %s ",
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01589) "Error reading first chunk %s ",
                               (ctx->remaining < 0) ? "(overflow)" : "");
                 ctx->remaining = 0; /* Reset it in case we have to
                                      * come back here later */
@@ -498,7 +498,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
 
                 /* Detect chunksize error (such as overflow) */
                 if (rv != APR_SUCCESS || ctx->remaining < 0) {
-                    ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, "Error reading chunk %s ",
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590) "Error reading chunk %s ",
                                   (ctx->remaining < 0) ? "(overflow)" : "");
                     ctx->remaining = 0; /* Reset it in case we have to
                                          * come back here later */
@@ -567,7 +567,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
          * really count.  This seems to be up for interpretation.  */
         ctx->limit_used += totalread;
         if (ctx->limit < ctx->limit_used) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01591)
                           "Read content-length of %" APR_OFF_T_FMT
                           " is larger than the configured limit"
                           " of %" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);
@@ -1471,12 +1471,12 @@ AP_DECLARE(int) ap_setup_client_block(request_rec *r, int read_policy)
 
     if (tenc) {
         if (strcasecmp(tenc, "chunked")) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01592)
                           "Unknown Transfer-Encoding %s", tenc);
             return HTTP_NOT_IMPLEMENTED;
         }
         if (r->read_body == REQUEST_CHUNKED_ERROR) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01593)
                           "chunked Transfer-Encoding forbidden: %s", r->uri);
             return (lenp) ? HTTP_BAD_REQUEST : HTTP_LENGTH_REQUIRED;
         }
@@ -1489,7 +1489,7 @@ AP_DECLARE(int) ap_setup_client_block(request_rec *r, int read_policy)
         if (apr_strtoff(&r->remaining, lenp, &endstr, 10)
             || *endstr || r->remaining < 0) {
             r->remaining = 0;
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01594)
                           "Invalid Content-Length");
             return HTTP_BAD_REQUEST;
         }
@@ -1497,7 +1497,7 @@ AP_DECLARE(int) ap_setup_client_block(request_rec *r, int read_policy)
 
     if ((r->read_body == REQUEST_NO_BODY)
         && (r->read_chunked || (r->remaining > 0))) {
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01595)
                       "%s with body is not allowed for %s", r->method, r->uri);
         return HTTP_REQUEST_ENTITY_TOO_LARGE;
     }
diff --git a/modules/http/http_protocol.c b/modules/http/http_protocol.c
index 0e7d346..1016547 100644
--- a/modules/http/http_protocol.c
+++ b/modules/http/http_protocol.c
@@ -497,7 +497,7 @@ AP_DECLARE(int) ap_method_register(apr_pool_t *p, const char *methname)
         /* The method registry  has run out of dynamically
          * assignable method numbers. Log this and return M_INVALID.
          */
-        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, p,
+        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, p, APLOGNO(01610)
                       "Maximum new request methods %d reached while "
                       "registering method %s.",
                       METHOD_NUMBER_LAST, methname);
diff --git a/modules/http/http_request.c b/modules/http/http_request.c
index 36cff2d..2788ec9 100644
--- a/modules/http/http_request.c
+++ b/modules/http/http_request.c
@@ -99,7 +99,7 @@ AP_DECLARE(void) ap_die(int type, request_rec *r)
          * next->frec == ap_http_header_filter
          */
         if (next) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01579)
                           "Custom error page caused AP_FILTER_ERROR");
             type = HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -208,7 +208,7 @@ AP_DECLARE(void) ap_die(int type, request_rec *r)
              * dying with a recursive server error...
              */
             recursive_error = HTTP_INTERNAL_SERVER_ERROR;
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01580)
                         "Invalid error redirection directive: %s",
                         custom_response);
         }
@@ -376,7 +376,7 @@ void ap_process_request(request_rec *r)
              * It is still safe to use r / r->pool here as the eor bucket
              * could not have been destroyed in the event of a timeout.
              */
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, r, APLOGNO(01581)
                           "Timeout while writing data for URI %s to the"
                           " client", r->unparsed_uri);
         }
@@ -500,7 +500,7 @@ static request_rec *internal_internal_redirect(const char *new_uri,
             nextf = f->next;
 
             if (f->r == r && f->frec != ap_subreq_core_filter_handle) {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01582)
                               "dropping filter '%s' in internal redirect from %s to %s",
                               f->frec->name, r->unparsed_uri, new_uri);
 
diff --git a/modules/http/mod_mime.c b/modules/http/mod_mime.c
index 390707d..9e44554 100644
--- a/modules/http/mod_mime.c
+++ b/modules/http/mod_mime.c
@@ -440,7 +440,7 @@ static int mime_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
 
     types_confname = ap_server_root_relative(p, types_confname);
     if (!types_confname) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s, APLOGNO(01596)
                      "Invalid mime types config path %s",
                      (const char *)ap_get_module_config(s->module_config,
                                                         &mime_module));
@@ -448,7 +448,7 @@ static int mime_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
     }
     if ((status = ap_pcfg_openfile(&f, ptemp, types_confname))
                 != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, status, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, status, s, APLOGNO(01597)
                      "could not open mime types config file %s.",
                      types_confname);
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -562,7 +562,7 @@ static content_type *analyze_ct(request_rec *r, const char *s)
         cp++;
     }
     if (!*cp) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01598)
                      "mod_mime: analyze_ct: cannot get media type from '%s'",
                      (const char *) mp);
         return (NULL);
@@ -572,7 +572,7 @@ static content_type *analyze_ct(request_rec *r, const char *s)
         cp++;
     } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));
     if (!*cp || (*cp == ';')) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01599)
                      "Cannot get media type from '%s'",
                      (const char *) mp);
         return (NULL);
@@ -581,7 +581,7 @@ static content_type *analyze_ct(request_rec *r, const char *s)
         cp++;
     }
     if (*cp != '/') {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01600)
                      "mod_mime: analyze_ct: cannot get media type from '%s'",
                      (const char *) mp);
         return (NULL);
@@ -595,7 +595,7 @@ static content_type *analyze_ct(request_rec *r, const char *s)
         cp++;
     }
     if (!*cp) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01601)
                      "Cannot get media subtype.");
         return (NULL);
     }
@@ -616,7 +616,7 @@ static content_type *analyze_ct(request_rec *r, const char *s)
     cp++; /* skip the ';' */
     cp = zap_sp(cp);
     if (cp == NULL || *cp == '\0') {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01602)
                      "Cannot get media parameter.");
         return (NULL);
     }
@@ -637,14 +637,14 @@ static content_type *analyze_ct(request_rec *r, const char *s)
             else if (*cp == '=') {
                 attribute = zap_sp_and_dup(p, mp, cp, NULL);
                 if (attribute == NULL || *attribute == '\0') {
-                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01603)
                                  "Cannot get media parameter.");
                     return (NULL);
                 }
                 cp++;
                 cp = zap_sp(cp);
                 if (cp == NULL || *cp == '\0') {
-                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01604)
                                  "Cannot get media parameter.");
                     return (NULL);
                 }
@@ -652,7 +652,7 @@ static content_type *analyze_ct(request_rec *r, const char *s)
                 continue;
             }
             else {
-                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01605)
                              "Cannot get media parameter.");
                 return (NULL);
             }
@@ -681,14 +681,14 @@ static content_type *analyze_ct(request_rec *r, const char *s)
                             cp++;
                         }
                         if (*cp != ';' && *cp != '\0') {
-                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01606)
                                          "Cannot get media parameter.");
                             return(NULL);
                         }
                         quoted = 0;
                     }
                     else {
-                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01607)
                                      "Cannot get media parameter.");
                         return (NULL);
                     }
@@ -703,7 +703,7 @@ static content_type *analyze_ct(request_rec *r, const char *s)
                         break;
                     }
                     else {
-                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01608)
                                      "Cannot get media parameter.");
                         return (NULL);
                     }
@@ -711,7 +711,7 @@ static content_type *analyze_ct(request_rec *r, const char *s)
             }
             value = zap_sp_and_dup(p, mp, cp, NULL);
             if (value == NULL || *value == '\0') {
-                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
+                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01609)
                              "Cannot get media parameter.");
                 return (NULL);
             }
diff --git a/modules/ldap/util_ldap.c b/modules/ldap/util_ldap.c
index 92f17ed..46840ad 100644
--- a/modules/ldap/util_ldap.c
+++ b/modules/ldap/util_ldap.c
@@ -322,7 +322,7 @@ static int uldap_connection_init(request_rec *r,
         /* Now that we have an ldap struct, add it to the referral list for rebinds. */
         rc = apr_ldap_rebind_add(ldc->rebind_pool, ldc->ldap, ldc->binddn, ldc->bindpw);
         if (rc != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server, APLOGNO(01277)
                     "LDAP: Unable to add rebind cross reference entry. Out of memory?");
             uldap_connection_unbind(ldc);
             ldc->reason = "LDAP: Unable to add rebind cross reference entry.";
@@ -366,7 +366,7 @@ static int uldap_connection_init(request_rec *r,
 
     if (ldc->ChaseReferrals == AP_LDAP_CHASEREFERRALS_ON) {
         /* Set options for rebind and referrals. */
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01278)
                 "LDAP: Setting referrals to %s.",
                 ((ldc->ChaseReferrals == AP_LDAP_CHASEREFERRALS_ON) ? "On" : "Off"));
         apr_ldap_set_option(r->pool, ldc->ldap,
@@ -375,7 +375,7 @@ static int uldap_connection_init(request_rec *r,
                     LDAP_OPT_ON : LDAP_OPT_OFF),
                 &(result));
         if (result->rc != LDAP_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01279)
                     "Unable to set LDAP_OPT_REFERRALS option to %s: %d.",
                     ((ldc->ChaseReferrals == AP_LDAP_CHASEREFERRALS_ON) ? "On" : "Off"),
                     result->rc);
@@ -387,7 +387,7 @@ static int uldap_connection_init(request_rec *r,
 
         if ((ldc->ReferralHopLimit != AP_LDAP_HOPLIMIT_UNSET) && ldc->ChaseReferrals == AP_LDAP_CHASEREFERRALS_ON) {
             /* Referral hop limit - only if referrals are enabled and a hop limit is explicitly requested */
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01280)
                     "Setting referral hop limit to %d.",
                     ldc->ReferralHopLimit);
             apr_ldap_set_option(r->pool, ldc->ldap,
@@ -395,7 +395,7 @@ static int uldap_connection_init(request_rec *r,
                     (void *)&ldc->ReferralHopLimit,
                     &(result));
             if (result->rc != LDAP_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01281)
                         "Unable to set LDAP_OPT_REFHOPLIMIT option to %d: %d.",
                         ldc->ReferralHopLimit,
                         result->rc);
@@ -442,7 +442,7 @@ static int uldap_connection_init(request_rec *r,
         rc = apr_ldap_set_option(r->pool, ldc->ldap, LDAP_OPT_NETWORK_TIMEOUT,
                                  (void *)&connectionTimeout, &(result));
         if (APR_SUCCESS != rc) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(01282)
                              "LDAP: Could not set the connection timeout");
         }
     }
@@ -461,7 +461,7 @@ static int uldap_connection_init(request_rec *r,
         rc = apr_ldap_set_option(r->pool, ldc->ldap, LDAP_OPT_TIMEOUT,
                                  st->opTimeout, &(result));
         if (APR_SUCCESS != rc) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(01283)
                              "LDAP: Could not set LDAP_OPT_TIMEOUT");
         }
     }
@@ -588,7 +588,7 @@ static int uldap_connection_open(request_rec *r,
                           "(try %d)", failures);
         }
         else if (rc == LDAP_TIMEOUT) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01284)
                           "ldap_simple_bind() timed out on %s "
                           "connection, dropped by firewall?",
                           new_connection ? "new" : "reused");
@@ -776,7 +776,7 @@ static util_ldap_connection_t *
     if (!l) {
         apr_pool_t *newpool;
         if (apr_pool_create(&newpool, NULL) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(01285)
                           "util_ldap: Failed to create memory pool");
 #if APR_HAS_THREADS
             apr_thread_mutex_unlock(st->mutex);
@@ -823,7 +823,7 @@ static util_ldap_connection_t *
 
         if (l->ChaseReferrals == AP_LDAP_CHASEREFERRALS_ON) {
             if (apr_pool_create(&(l->rebind_pool), l->pool) != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(01286)
                               "util_ldap: Failed to create memory pool");
 #if APR_HAS_THREADS
                 apr_thread_mutex_unlock(st->mutex);
@@ -1136,7 +1136,7 @@ start_over:
                 junk = util_ald_cache_insert(curl->compare_cache,
                                              &the_compare_node);
                 if (junk == NULL) {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01287)
                                   "cache_compare: Cache insertion failure.");
                 }
             }
@@ -1427,7 +1427,7 @@ static int uldap_cache_check_subgroups(request_rec *r,
                 if (compare_nodep->subgroupList) {
                     /* Make a local copy of the subgroup list */
                     int i;
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01288)
                                   "Making local copy of SGL for "
                                   "group (%s)(objectClass=%s) ",
                                   dn, (char *)sgc_ents[base_sgcIndex].name);
@@ -1453,13 +1453,13 @@ static int uldap_cache_check_subgroups(request_rec *r,
 
     if (!tmp_local_sgl && !sgl_cached_empty) {
         /* No Cached SGL, retrieve from LDAP */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01289)
                       "no cached SGL for %s, retrieving from LDAP", dn);
         tmp_local_sgl = uldap_get_subgroups(r, ldc, url, dn, subgroupAttrs,
                                             subgroupclasses);
         if (!tmp_local_sgl) {
             /* No SGL aailable via LDAP either */
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "no subgroups for %s",
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01290) "no subgroups for %s",
                           dn);
         }
 
@@ -1486,14 +1486,14 @@ static int uldap_cache_check_subgroups(request_rec *r,
              * based on the objectClass, but we can't call the compare function
              * while we already hold the cache lock -- only the insert.
              */
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01291)
                           "Cache entry for %s doesn't exist", dn);
             the_compare_node.result = LDAP_COMPARE_TRUE;
             util_ald_cache_insert(curl->compare_cache, &the_compare_node);
             compare_nodep = util_ald_cache_fetch(curl->compare_cache,
                                                  &the_compare_node);
             if (compare_nodep == NULL) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01292)
                               "util_ldap: Couldn't retrieve group entry "
                               "for %s from cache",
                               dn);
@@ -1514,7 +1514,7 @@ static int uldap_cache_check_subgroups(request_rec *r,
             else {
                 util_compare_subgroup_t *sgl_copy =
                     util_ald_sgl_dup(curl->compare_cache, tmp_local_sgl);
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01293)
                              "Copying local SGL of len %d for group %s into cache",
                              tmp_local_sgl->len, dn);
                 if (sgl_copy) {
@@ -1526,7 +1526,7 @@ static int uldap_cache_check_subgroups(request_rec *r,
                     compare_nodep->sgl_processed = 1;
                 }
                 else {
-                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(01294)
                                  "Copy of SGL failed to obtain shared memory, "
                                  "couldn't update cache");
                 }
@@ -1559,7 +1559,7 @@ static int uldap_cache_check_subgroups(request_rec *r,
              * 4.A. We found the user in the subgroup. Return
              * LDAP_COMPARE_TRUE.
              */
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01295)
                           "Found user %s in a subgroup (%s) at level %d of %d.",
                           r->user, group, cur_subgroup_depth+1,
                           max_subgroup_depth);
@@ -1569,7 +1569,7 @@ static int uldap_cache_check_subgroups(request_rec *r,
              * 4.B. We didn't find the user in this subgroup, so recurse into
              * it and keep looking.
              */
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01296)
                           "User %s not found in subgroup (%s) at level %d of "
                           "%d.", r->user, group, cur_subgroup_depth+1,
                           max_subgroup_depth);
@@ -2082,7 +2082,7 @@ static const char *util_ldap_set_cache_bytes(cmd_parms *cmd, void *dummy,
 
     st->cache_bytes = atol(bytes);
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01297)
                  "ldap cache: Setting shared memory cache size to "
                  "%" APR_SIZE_T_FMT " bytes.",
                  st->cache_bytes);
@@ -2109,7 +2109,7 @@ static const char *util_ldap_set_cache_file(cmd_parms *cmd, void *dummy,
         st->cache_file = NULL;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01298)
                  "LDAP cache: Setting shared memory cache file to %s bytes.",
                  st->cache_file);
 
@@ -2130,7 +2130,7 @@ static const char *util_ldap_set_cache_ttl(cmd_parms *cmd, void *dummy,
 
     st->search_cache_ttl = atol(ttl) * 1000000;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01299)
                  "ldap cache: Setting cache TTL to %ld microseconds.",
                  st->search_cache_ttl);
 
@@ -2154,7 +2154,7 @@ static const char *util_ldap_set_cache_entries(cmd_parms *cmd, void *dummy,
         st->search_cache_size = 0;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01300)
                  "ldap cache: Setting search cache size to %ld entries.",
                  st->search_cache_size);
 
@@ -2175,7 +2175,7 @@ static const char *util_ldap_set_opcache_ttl(cmd_parms *cmd, void *dummy,
 
     st->compare_cache_ttl = atol(ttl) * 1000000;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01301)
                  "ldap cache: Setting operation cache TTL to %ld microseconds.",
                  st->compare_cache_ttl);
 
@@ -2199,7 +2199,7 @@ static const char *util_ldap_set_opcache_entries(cmd_parms *cmd, void *dummy,
         st->compare_cache_size = 0;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01302)
                  "ldap cache: Setting operation cache size to %ld entries.",
                  st->compare_cache_size);
 
@@ -2330,7 +2330,7 @@ static const char *util_ldap_set_trusted_global_cert(cmd_parms *cmd,
         return "Certificate type was not specified.";
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01303)
                       "LDAP: SSL trusted global cert - %s (type %s)",
                        file, type);
 
@@ -2349,7 +2349,7 @@ static const char *util_ldap_set_trusted_global_cert(cmd_parms *cmd,
             ((rv = apr_stat (&finfo, cert->path, APR_FINFO_MIN, cmd->pool))
                 != APR_SUCCESS))
         {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cmd->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cmd->server, APLOGNO(01304)
                          "LDAP: Could not open SSL trusted certificate "
                          "authority file - %s",
                          cert->path == NULL ? file : cert->path);
@@ -2410,7 +2410,7 @@ static const char *util_ldap_set_trusted_client_cert(cmd_parms *cmd,
         return "Certificate type was not specified.";
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01305)
                       "LDAP: SSL trusted client cert - %s (type %s)",
                        file, type);
 
@@ -2429,7 +2429,7 @@ static const char *util_ldap_set_trusted_client_cert(cmd_parms *cmd,
             ((rv = apr_stat (&finfo, cert->path, APR_FINFO_MIN, cmd->pool))
                 != APR_SUCCESS))
         {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cmd->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, cmd->server, APLOGNO(01306)
                          "LDAP: Could not open SSL client certificate "
                          "file - %s",
                          cert->path == NULL ? file : cert->path);
@@ -2457,7 +2457,7 @@ static const char *util_ldap_set_trusted_mode(cmd_parms *cmd, void *dummy,
     (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config,
                                               &ldap_module);
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01307)
                       "LDAP: SSL trusted mode - %s",
                        mode);
 
@@ -2493,7 +2493,7 @@ static const char *util_ldap_set_verify_srv_cert(cmd_parms *cmd,
         return err;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01308)
                       "LDAP: SSL verify server certificate - %s",
                       mode?"TRUE":"FALSE");
 
@@ -2521,11 +2521,11 @@ static const char *util_ldap_set_connection_timeout(cmd_parms *cmd,
 #ifdef LDAP_OPT_NETWORK_TIMEOUT
     st->connectionTimeout = atol(ttl);
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01309)
                  "ldap connection: Setting connection timeout to %ld seconds.",
                  st->connectionTimeout);
 #else
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, cmd->server, APLOGNO(01310)
                  "LDAP: Connection timeout option not supported by the "
                  "LDAP SDK in use." );
 #endif
@@ -2540,7 +2540,7 @@ static const char *util_ldap_set_chase_referrals(cmd_parms *cmd,
 {
     util_ldap_config_t *dc =  config;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01311)
                       "LDAP: Setting referral chasing %s",
                       (mode == AP_LDAP_CHASEREFERRALS_ON) ? "ON" : "OFF");
 
@@ -2583,7 +2583,7 @@ static const char *util_ldap_set_referral_hop_limit(cmd_parms *cmd,
         return "LDAPReferralHopLimit must be greater than zero (Use 'LDAPReferrals Off' to disable referral chasing)";
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01312)
                  "LDAP: Limit chased referrals to maximum of %d hops.",
                  dc->ReferralHopLimit);
 
@@ -2635,13 +2635,13 @@ static const char *util_ldap_set_op_timeout(cmd_parms *cmd,
         st->opTimeout = NULL;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01313)
                  "ldap connection: Setting op timeout to %ld seconds.",
                  timeout);
 
 #ifndef LDAP_OPT_TIMEOUT
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01314)
                  "LDAP: LDAP_OPT_TIMEOUT option not supported by the "
                  "LDAP library in use. Using LDAPTimeout value as search "
                  "timeout only." );
@@ -2879,7 +2879,7 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
 #endif
         result = util_ldap_cache_init(p, st);
         if (result != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, result, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, result, s, APLOGNO(01315)
                          "LDAP cache: could not create shared memory segment");
             return DONE;
         }
@@ -2902,7 +2902,7 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
             st_vhost->cache_rmm = st->cache_rmm;
             st_vhost->cache_file = st->cache_file;
             st_vhost->util_ldap_cache = st->util_ldap_cache;
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, result, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, result, s, APLOGNO(01316)
                          "LDAP merging Shared Cache conf: shm=0x%pp rmm=0x%pp "
                          "for VHOST: %s", st->cache_shm, st->cache_rmm,
                          s_vhost->server_hostname);
@@ -2912,7 +2912,7 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
 #if APR_HAS_SHARED_MEMORY
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01317)
                      "LDAP cache: LDAPSharedCacheSize is zero, disabling "
                      "shared memory cache");
     }
@@ -2924,7 +2924,7 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
         apr_ldap_err_t *result = NULL;
         apr_ldap_info(p, &(result));
         if (result != NULL) {
-            ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, "%s", result->reason);
+            ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01318) "%s", result->reason);
         }
     }
 
@@ -2948,12 +2948,12 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (APR_SUCCESS == rc) {
         st->ssl_supported = 1;
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01319)
                      "LDAP: SSL support available" );
     }
     else {
         st->ssl_supported = 0;
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01320)
                      "LDAP: SSL support unavailable%s%s",
                      result_err ? ": " : "",
                      result_err ? result_err->reason : "");
@@ -2977,7 +2977,7 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
     if (st->debug_level > 0) {
         result = ldap_set_option(NULL, AP_LDAP_OPT_DEBUG, &st->debug_level);
         if (result != LDAP_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01321)
                     "LDAP: Could not set the LDAP library debug level to %d:(%d) %s",
                     st->debug_level, result, ldap_err2string(result));
         }
@@ -2998,7 +2998,7 @@ static void util_ldap_child_init(apr_pool_t *p, server_rec *s)
     sts = apr_global_mutex_child_init(&st->util_ldap_cache_lock,
               apr_global_mutex_lockfile(st->util_ldap_cache_lock), p);
     if (sts != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, sts, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, sts, s, APLOGNO(01322)
                      "Failed to initialise global mutex %s in child process",
                      ldap_cache_mutex_type);
     }
diff --git a/modules/ldap/util_ldap_cache_mgr.c b/modules/ldap/util_ldap_cache_mgr.c
index 1998c13..8267577 100644
--- a/modules/ldap/util_ldap_cache_mgr.c
+++ b/modules/ldap/util_ldap_cache_mgr.c
@@ -461,7 +461,7 @@ void *util_ald_cache_insert(util_ald_cache_t *cache, void *payload)
         util_ald_cache_purge(cache);
         if (cache->numentries >= cache->maxentries) {
             /* if the purge was not effective, we leave now to avoid an overflow */
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(01323)
                          "Purge of LDAP cache failed");
             return NULL;
         }
@@ -474,7 +474,7 @@ void *util_ald_cache_insert(util_ald_cache_t *cache, void *payload)
          * XXX: The cache management should be rewritten to work
          * properly when LDAPSharedCacheSize is too small.
          */
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL, APLOGNO(01324)
                      "LDAPSharedCacheSize is too small. Increase it or "
                      "reduce LDAPCacheEntries/LDAPOpCacheEntries!");
         if (cache->numentries < cache->fullmark) {
@@ -489,7 +489,7 @@ void *util_ald_cache_insert(util_ald_cache_t *cache, void *payload)
         node = (util_cache_node_t *)util_ald_alloc(cache,
                                                    sizeof(util_cache_node_t));
         if (node == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(01325)
                          "Could not allocate memory for LDAP cache entry");
             return NULL;
         }
@@ -502,7 +502,7 @@ void *util_ald_cache_insert(util_ald_cache_t *cache, void *payload)
          * XXX: The cache management should be rewritten to work
          * properly when LDAPSharedCacheSize is too small.
          */
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL, APLOGNO(01326)
                      "LDAPSharedCacheSize is too small. Increase it or "
                      "reduce LDAPCacheEntries/LDAPOpCacheEntries!");
         if (cache->numentries < cache->fullmark) {
@@ -516,7 +516,7 @@ void *util_ald_cache_insert(util_ald_cache_t *cache, void *payload)
         util_ald_cache_purge(cache);
         tmp_payload = (*cache->copy)(cache, payload);
         if (tmp_payload == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(01327)
                          "Could not allocate memory for LDAP cache value");
             util_ald_free(cache, node);
             return NULL;
diff --git a/modules/loggers/mod_log_config.c b/modules/loggers/mod_log_config.c
index e3b050a..2b3cd53 100644
--- a/modules/loggers/mod_log_config.c
+++ b/modules/loggers/mod_log_config.c
@@ -1088,7 +1088,7 @@ static int config_log_transaction(request_rec *r, config_log_state *cls,
         const char *err;
         int rc = ap_expr_exec(r, cls->condition_expr, &err);
         if (rc < 0)
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(00644)
                            "Error evaluating log condition: %s", err);
         if (rc <= 0)
             return DECLINED;
@@ -1116,13 +1116,13 @@ static int config_log_transaction(request_rec *r, config_log_state *cls,
         len += strl[i] = strlen(strs[i]);
     }
     if (!log_writer) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00645)
                 "log writer isn't correctly setup");
          return HTTP_INTERNAL_SERVER_ERROR;
     }
     rv = log_writer(r, cls->log_writer, strs, strl, format->nelts, len);
     if (rv != APR_SUCCESS)
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, "Error writing to %s",
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, rv, r, APLOGNO(00646) "Error writing to %s",
                       cls->fname);
     return OK;
 }
@@ -1474,7 +1474,7 @@ static void init_child(apr_pool_t *p, server_rec *s)
                                              APR_THREAD_MUTEX_DEFAULT,
                                              p);
                 if (rv != APR_SUCCESS) {
-                    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+                    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00647)
                                  "could not initialize buffered log mutex, "
                                  "transfer log may become corrupted");
                     this->mutex.type = apr_anylock_none;
@@ -1556,13 +1556,13 @@ static void *ap_default_log_writer_init(apr_pool_t *p, server_rec *s,
         apr_status_t rv;
 
         if (!fname) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s, APLOGNO(00648)
                             "invalid transfer log path %s.", name);
             return NULL;
         }
         rv = apr_file_open(&fd, fname, xfer_flags, xfer_perms, p);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00649)
                             "could not open transfer log file %s.", fname);
             return NULL;
         }
diff --git a/modules/loggers/mod_log_debug.c b/modules/loggers/mod_log_debug.c
index 4ccf9c9..c4dc2a0 100644
--- a/modules/loggers/mod_log_debug.c
+++ b/modules/loggers/mod_log_debug.c
@@ -67,7 +67,7 @@ static void do_debug_log(request_rec *r, const char *hookname)
         if (entry->condition) {
             int ret = ap_expr_exec(r, entry->condition, &err);
             if (err) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00640)
                               "Can't evaluate condition: %s", err);
                 continue;
             }
@@ -76,14 +76,14 @@ static void do_debug_log(request_rec *r, const char *hookname)
         }
         msg = ap_expr_str_exec(r, entry->msg_expr, &err);
         if (err)
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00641)
                           "Can't evaluate message expression: %s", err);
         if (APLOGrdebug(r))
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, "%s (%s hook, %s:%d)",
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00642) "%s (%s hook, %s:%d)",
                            msg, hookname, entry->msg_expr->filename,
                            entry->msg_expr->line_number);
         else
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, "%s", msg);
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00643) "%s", msg);
     }
 }
 
diff --git a/modules/loggers/mod_log_forensic.c b/modules/loggers/mod_log_forensic.c
index 8e23dd8..7a333dc 100644
--- a/modules/loggers/mod_log_forensic.c
+++ b/modules/loggers/mod_log_forensic.c
@@ -81,7 +81,7 @@ static int open_log(server_rec *s, apr_pool_t *p)
 
         pl = ap_open_piped_log(p, pname);
         if (pl == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00650)
                          "couldn't spawn forensic log pipe %s", cfg->logname);
             return 0;
         }
@@ -94,7 +94,7 @@ static int open_log(server_rec *s, apr_pool_t *p)
         if ((rv = apr_file_open(&cfg->fd, fname,
                                 APR_WRITE | APR_APPEND | APR_CREATE,
                                 APR_OS_DEFAULT, p)) != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00651)
                          "could not open forensic log file %s.", fname);
             return 0;
         }
diff --git a/modules/lua/lua_config.c b/modules/lua/lua_config.c
index 84356d7..0e67565 100644
--- a/modules/lua/lua_config.c
+++ b/modules/lua/lua_config.c
@@ -158,7 +158,7 @@ static const struct luaL_Reg cfg_methods[] = {
 static int cmd_foo(lua_State *L)
 {
     cmd_parms *cmd = check_cmd_parms(L, 1);
-    ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server, "FOO!");
+    ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server, APLOGNO(01479) "FOO!");
     return 0;
 }
 
diff --git a/modules/lua/lua_request.c b/modules/lua/lua_request.c
index 5d7d8f5..cce3a9c 100644
--- a/modules/lua/lua_request.c
+++ b/modules/lua/lua_request.c
@@ -30,7 +30,7 @@ void ap_lua_rstack_dump(lua_State *L, request_rec *r, const char *msg)
     int i;
     int top = lua_gettop(L);
 
-    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, "Lua Stack Dump: [%s]", msg);
+    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01484) "Lua Stack Dump: [%s]", msg);
 
     for (i = 1; i <= top; i++) {
         int t = lua_type(L, i);
@@ -194,7 +194,7 @@ static int req_add_output_filter(lua_State *L)
 {
     request_rec *r = ap_lua_check_request_rec(L, 1);
     const char *name = luaL_checkstring(L, 2);
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "adding output filter %s",
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01485) "adding output filter %s",
                   name);
     ap_add_output_filter(name, L, r, r->connection);
     return 0;
@@ -383,7 +383,7 @@ static int req_dispatch(lua_State *L)
         case APL_REQ_FUNTYPE_TABLE:{
                 apr_table_t *rs;
                 req_field_apr_table_f func = (req_field_apr_table_f)rft->fun;
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01486)
                               "request_rec->dispatching %s -> apr table",
                               name);
                 rs = (*func)(r);
@@ -393,7 +393,7 @@ static int req_dispatch(lua_State *L)
 
         case APL_REQ_FUNTYPE_LUACFUN:{
                 lua_CFunction func = (lua_CFunction)rft->fun;
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01487)
                               "request_rec->dispatching %s -> lua_CFunction",
                               name);
                 lua_pushcfunction(L, func);
@@ -402,7 +402,7 @@ static int req_dispatch(lua_State *L)
         case APL_REQ_FUNTYPE_STRING:{
                 req_field_string_f func = (req_field_string_f)rft->fun;
                 char *rs;
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01488)
                               "request_rec->dispatching %s -> string", name);
                 rs = (*func) (r);
                 lua_pushstring(L, rs);
@@ -411,7 +411,7 @@ static int req_dispatch(lua_State *L)
         case APL_REQ_FUNTYPE_INT:{
                 req_field_int_f func = (req_field_int_f)rft->fun;
                 int rs;
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01489)
                               "request_rec->dispatching %s -> int", name);
                 rs = (*func) (r);
                 lua_pushnumber(L, rs);
@@ -420,7 +420,7 @@ static int req_dispatch(lua_State *L)
         case APL_REQ_FUNTYPE_BOOLEAN:{
                 req_field_int_f func = (req_field_int_f)rft->fun;
                 int rs;
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01490)
                               "request_rec->dispatching %s -> boolean", name);
                 rs = (*func) (r);
                 lua_pushboolean(L, rs);
@@ -429,7 +429,7 @@ static int req_dispatch(lua_State *L)
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "nothing for %s", name);
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01491) "nothing for %s", name);
     return 0;
 }
 
diff --git a/modules/lua/lua_vmprep.c b/modules/lua/lua_vmprep.c
index b2836e3..308ffe6 100644
--- a/modules/lua/lua_vmprep.c
+++ b/modules/lua/lua_vmprep.c
@@ -308,7 +308,7 @@ static int loadjitmodule(lua_State *L, apr_pool_t *lifecycle_pool) {
     lua_concat(L, 2);
     if (lua_pcall(L, 1, 1, 0)) {
         const char *msg = lua_tostring(L, -1);
-        ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, lifecycle_pool,
+        ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, lifecycle_pool, APLOGNO(01480)
                       "Failed to init LuaJIT: %s", msg);
         return 1;
     }
@@ -353,7 +353,7 @@ static apr_status_t vm_construct(void **vm, void *params, apr_pool_t *lifecycle_
     }
     else {
         int rc;
-        ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, lifecycle_pool,
+        ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, lifecycle_pool, APLOGNO(01481)
             "loading lua file %s", spec->file);
         rc = luaL_loadfile(L, spec->file);
         if (rc != 0) {
@@ -372,7 +372,7 @@ static apr_status_t vm_construct(void **vm, void *params, apr_pool_t *lifecycle_
                     err = "unknown error";
                     break;
             }
-            ap_log_perror(APLOG_MARK, APLOG_ERR, 0, lifecycle_pool,
+            ap_log_perror(APLOG_MARK, APLOG_ERR, 0, lifecycle_pool, APLOGNO(01482)
                 "Loading lua file %s: %s",
                 spec->file, err);
             return APR_EBADF;
@@ -403,7 +403,7 @@ AP_LUA_DECLARE(lua_State*)ap_lua_get_lua_state(apr_pool_t *lifecycle_pool,
                               lifecycle_pool) == APR_SUCCESS) {
       
       if(L==NULL) {
-        ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, lifecycle_pool,
+        ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, lifecycle_pool, APLOGNO(01483)
                       "creating lua_State with file %s", spec->file);
         /* not available, so create */
         
diff --git a/modules/lua/mod_lua.c b/modules/lua/mod_lua.c
index 53dbdab..de4acee 100644
--- a/modules/lua/mod_lua.c
+++ b/modules/lua/mod_lua.c
@@ -60,7 +60,7 @@ static void report_lua_error(lua_State *L, request_rec *r)
     ap_rputs(lua_response, r);
     ap_rputs("</p>\n", r);
 
-    ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, r->pool, "Lua error: %s",
+    ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, r->pool, APLOGNO(01471) "Lua error: %s",
                   lua_response);
 }
 
@@ -90,7 +90,7 @@ static int lua_handler(request_rec *r)
         return DECLINED;
     }
   
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "handling [%s] in mod_lua",
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01472) "handling [%s] in mod_lua",
                   r->filename);
     dcfg = ap_get_module_config(r->per_dir_config, &lua_module);
 
@@ -109,7 +109,7 @@ static int lua_handler(request_rec *r)
         spec->cb = &lua_open_callback;
         spec->cb_arg = NULL;
       
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01473)
                       "request details scope:%u, filename:%s, function:%s",
                       spec->scope,
                       spec->file,
@@ -142,10 +142,10 @@ static int lua_handler(request_rec *r)
             ap_rputs("Unable to compile VM, see logs", r);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "got a vm!");
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01474) "got a vm!");
         lua_getglobal(L, "handle");
         if (!lua_isfunction(L, -1)) {
-            ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(01475)
                           "lua: Unable to find function %s in %s",
                           "handle",
                           spec->file);
@@ -203,7 +203,7 @@ static int lua_request_rec_hook_harness(request_rec *r, const char *name, int ap
             apr_filepath_merge(&spec->file, server_cfg->root_path,
                                spec->file, APR_FILEPATH_NOTRELATIVE, r->pool);
 
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01476)
                           "request details scope:%u, filename:%s, function:%s",
                           spec->scope,
                           spec->file,
@@ -230,7 +230,7 @@ static int lua_request_rec_hook_harness(request_rec *r, const char *name, int ap
             L = ap_lua_get_lua_state(pool, spec);
 
             if (!L) {
-                ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(01477)
                               "lua: Failed to obtain lua interpreter for %s %s",
                               hook_spec->function_name, hook_spec->file_name);
                 return HTTP_INTERNAL_SERVER_ERROR;
@@ -239,7 +239,7 @@ static int lua_request_rec_hook_harness(request_rec *r, const char *name, int ap
             if (hook_spec->function_name != NULL) {
                 lua_getglobal(L, hook_spec->function_name);
                 if (!lua_isfunction(L, -1)) {
-                    ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(01478)
                                   "lua: Unable to find function %s in %s",
                                   hook_spec->function_name,
                                   hook_spec->file_name);
diff --git a/modules/mappers/mod_actions.c b/modules/mappers/mod_actions.c
index e1691c9..c311a3b 100644
--- a/modules/mappers/mod_actions.c
+++ b/modules/mappers/mod_actions.c
@@ -187,7 +187,7 @@ static int action_handler(request_rec *r)
 
     if (action && (t = apr_table_get(conf->action_types, action))) {
         if (*t++ == '0' && r->finfo.filetype == APR_NOFILE) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00652)
                           "File does not exist: %s", r->filename);
             return HTTP_NOT_FOUND;
         }
diff --git a/modules/mappers/mod_alias.c b/modules/mappers/mod_alias.c
index e0a17ea..0740cef 100644
--- a/modules/mappers/mod_alias.c
+++ b/modules/mappers/mod_alias.c
@@ -137,7 +137,7 @@ static const char *add_alias_internal(cmd_parms *cmd, void *dummy,
 
             if (  (!alias->regexp &&  alias_matches(fake, alias->fake) > 0)
                 || (alias->regexp && !ap_regexec(alias->regexp, fake, 0, NULL, 0))) {
-                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00671)
                              "The %s directive in %s at line %d will probably "
                              "never match because it overlaps an earlier "
                              "%sAlias%s.",
@@ -383,7 +383,7 @@ static char *try_alias_list(request_rec *r, apr_array_header_t *aliases,
                        }
                     }
                     else {
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00672)
                                       "Regex substitution in '%s' failed. "
                                       "Replacement too long?", alias->real);
                         return PREGSUB_ERROR;
@@ -454,14 +454,14 @@ static int translate_alias_redir(request_rec *r)
                 char *orig_target = ret;
 
                 ret = ap_construct_url(r->pool, ret, r);
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00673)
                               "incomplete redirection target of '%s' for "
                               "URI '%s' modified to '%s'",
                               orig_target, r->uri, ret);
             }
             if (!ap_is_url(ret)) {
                 status = HTTP_INTERNAL_SERVER_ERROR;
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00674)
                               "cannot redirect '%s' to '%s'; "
                               "target is not a valid absoluteURI or abs_path",
                               r->uri, ret);
@@ -505,14 +505,14 @@ static int fixup_redir(request_rec *r)
                 char *orig_target = ret;
 
                 ret = ap_construct_url(r->pool, ret, r);
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00675)
                               "incomplete redirection target of '%s' for "
                               "URI '%s' modified to '%s'",
                               orig_target, r->uri, ret);
             }
             if (!ap_is_url(ret)) {
                 status = HTTP_INTERNAL_SERVER_ERROR;
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00676)
                               "cannot redirect '%s' to '%s'; "
                               "target is not a valid absoluteURI or abs_path",
                               r->uri, ret);
diff --git a/modules/mappers/mod_imagemap.c b/modules/mappers/mod_imagemap.c
index c3de930..d7b01dd 100644
--- a/modules/mappers/mod_imagemap.c
+++ b/modules/mappers/mod_imagemap.c
@@ -374,7 +374,7 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
     /* must be a relative URL to be combined with base */
     if (ap_strchr_c(base, '/') == NULL && (!strncmp(value, "../", 3)
         || !strcmp(value, ".."))) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00677)
                     "invalid base directive in map file: %s", r->uri);
         return NULL;
     }
@@ -434,7 +434,7 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
                                    value */
         }
         else if (directory) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00678)
                         "invalid directory name in map file: %s", r->uri);
             return NULL;
         }
@@ -844,7 +844,7 @@ static int imap_handler_internal(request_rec *r)
                                                  we failed. They lose! */
 
 need_2_fields:
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00679)
                 "map file %s, line %d syntax error: requires at "
                 "least two fields", r->uri, imap->line_number);
     /* fall through */
diff --git a/modules/mappers/mod_negotiation.c b/modules/mappers/mod_negotiation.c
index 0d3c764..cba118c 100644
--- a/modules/mappers/mod_negotiation.c
+++ b/modules/mappers/mod_negotiation.c
@@ -685,7 +685,7 @@ static void parse_negotiate_header(request_rec *r, negotiation_state *neg)
     }
 
 #ifdef NEG_DEBUG
-    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00680)
             "dont_fiddle_headers=%d use_rvsa=%d ua_supports_trans=%d "
             "send_alternates=%d, may_choose=%d",
             neg->dont_fiddle_headers, neg->use_rvsa,
@@ -916,7 +916,7 @@ static char *lcase_header_name_return_body(char *header, request_rec *r)
     }
 
     if (!*cp) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00681)
                       "Syntax error in type map, no ':' in %s for header %s",
                       r->filename, header);
         return NULL;
@@ -927,7 +927,7 @@ static char *lcase_header_name_return_body(char *header, request_rec *r)
     } while (*cp && apr_isspace(*cp));
 
     if (!*cp) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00682)
                       "Syntax error in type map --- no header body: %s for %s",
                       r->filename, header);
         return NULL;
@@ -955,7 +955,7 @@ static int read_type_map(apr_file_t **map, negotiation_state *neg,
 
     if ((status = apr_file_open(map, rr->filename, APR_READ | APR_BUFFERED,
                 APR_OS_DEFAULT, neg->pool)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00683)
                       "cannot access type map file: %s", rr->filename);
         if (APR_STATUS_IS_ENOTDIR(status) || APR_STATUS_IS_ENOENT(status)) {
             return HTTP_NOT_FOUND;
@@ -999,7 +999,7 @@ static int read_type_map(apr_file_t **map, negotiation_state *neg,
                 body1 = ap_get_token(neg->pool, &body, 0);
                 if (apr_strtoff(&number, body1, &errp, 10) != APR_SUCCESS
                     || *errp || number < 0) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00684)
                                   "Parse error in type map, Content-Length: "
                                   "'%s' in %s is invalid.",
                                   body1, r->filename);
@@ -1034,7 +1034,7 @@ static int read_type_map(apr_file_t **map, negotiation_state *neg,
                 while (--eol >= tag && apr_isspace(*eol))
                     *eol = '\0';
                 if ((mime_info.body = get_body(buffer, &len, tag, *map)) < 0) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00685)
                                   "Syntax error in type map, no end tag '%s'"
                                   "found in %s for Body: content.",
                                   tag, r->filename);
@@ -1119,7 +1119,7 @@ static int read_types_multi(negotiation_state *neg)
 
     if ((status = apr_dir_open(&dirp, neg->dir_name,
                                neg->pool)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00686)
                     "cannot read directory for multi: %s", neg->dir_name);
         return HTTP_FORBIDDEN;
     }
@@ -1291,7 +1291,7 @@ static int read_types_multi(negotiation_state *neg)
      * request must die.
      */
     if (anymatch && !neg->avail_vars->nelts) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00687)
                       "Negotiation: discovered file(s) matching request: %s"
                       " (None could be negotiated).",
                       r->filename);
@@ -2063,7 +2063,7 @@ static int is_variant_better_rvsa(negotiation_state *neg, var_rec *variant,
     */
 
 #ifdef NEG_DEBUG
-    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00688)
            "Variant: file=%s type=%s lang=%s sourceq=%1.3f "
            "mimeq=%1.3f langq=%1.3f charq=%1.3f encq=%1.3f "
            "q=%1.5f definite=%d",
@@ -2134,7 +2134,7 @@ static int is_variant_better(negotiation_state *neg, var_rec *variant,
      */
 
 #ifdef NEG_DEBUG
-    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00689)
            "Variant: file=%s type=%s lang=%s sourceq=%1.3f "
            "mimeq=%1.3f langq=%1.3f langidx=%d charq=%1.3f encq=%1.3f ",
             (variant->file_name ? variant->file_name : ""),
@@ -2903,7 +2903,7 @@ static int do_negotiation(request_rec *r, negotiation_state *neg,
         }
 
         if (!*bestp) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00690)
                           "no acceptable variant: %s", r->filename);
             return HTTP_NOT_ACCEPTABLE;
         }
diff --git a/modules/mappers/mod_rewrite.c b/modules/mappers/mod_rewrite.c
index d29cb45..970faff 100644
--- a/modules/mappers/mod_rewrite.c
+++ b/modules/mappers/mod_rewrite.c
@@ -1118,7 +1118,7 @@ static char *select_random_value_part(request_rec *r, char *value)
 static void rewrite_child_errfn(apr_pool_t *p, apr_status_t err,
                                 const char *desc)
 {
-    ap_log_error(APLOG_MARK, APLOG_ERR, err, NULL, "%s", desc);
+    ap_log_error(APLOG_MARK, APLOG_ERR, err, NULL, APLOGNO(00653) "%s", desc);
 }
 
 static apr_status_t rewritemap_program_child(apr_pool_t *p,
@@ -1194,7 +1194,7 @@ static apr_status_t run_rewritemap_programs(server_rec *s, apr_pool_t *p)
         rc = rewritemap_program_child(p, map->argv[0], map->argv,
                                       &fpout, &fpin);
         if (rc != APR_SUCCESS || fpin == NULL || fpout == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rc, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rc, s, APLOGNO(00654)
                          "mod_rewrite: could not start RewriteMap "
                          "program %s", map->checkfile);
             return rc;
@@ -1225,7 +1225,7 @@ static char *lookup_map_txtfile(request_rec *r, const char *file, char *key)
     if ((rv = apr_file_open(&fp, file, APR_READ|APR_BUFFERED, APR_OS_DEFAULT,
                             r->pool)) != APR_SUCCESS)
     {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00655)
                       "mod_rewrite: can't open text RewriteMap file %s", file);
         return NULL;
     }
@@ -1287,7 +1287,7 @@ static char *lookup_map_dbmfile(request_rec *r, const char *file,
     if ((rv = apr_dbm_open_ex(&dbmfp, dbmtype, file, APR_DBM_READONLY,
                               APR_OS_DEFAULT, r->pool)) != APR_SUCCESS)
     {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00656)
                       "mod_rewrite: can't open DBM RewriteMap %s", file);
         return NULL;
     }
@@ -1323,7 +1323,7 @@ static char *lookup_map_dbd(request_rec *r, char *key, const char *label)
                           stmt, 0, key, NULL);
     if (rv != 0) {
         errmsg = apr_dbd_error(db->driver, db->handle, rv);
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00657)
                       "rewritemap: error %s querying for %s", errmsg, key);
         return NULL;
     }
@@ -1341,7 +1341,7 @@ static char *lookup_map_dbd(request_rec *r, char *key, const char *label)
     }
     if (rv != -1) {
         errmsg = apr_dbd_error(db->driver, db->handle, rv);
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00658)
                       "rewritemap: error %s looking up %s", errmsg, key);
     }
     switch (n) {
@@ -1391,7 +1391,7 @@ static char *lookup_map_program(request_rec *r, apr_file_t *fpin,
     if (rewrite_mapr_lock_acquire) {
         rv = apr_global_mutex_lock(rewrite_mapr_lock_acquire);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00659)
                           "apr_global_mutex_lock(rewrite_mapr_lock_acquire) "
                           "failed");
             return NULL; /* Maybe this should be fatal? */
@@ -1503,7 +1503,7 @@ static char *lookup_map_program(request_rec *r, apr_file_t *fpin,
     if (rewrite_mapr_lock_acquire) {
         rv = apr_global_mutex_unlock(rewrite_mapr_lock_acquire);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00660)
                           "apr_global_mutex_unlock(rewrite_mapr_lock_acquire) "
                           "failed");
             return NULL; /* Maybe this should be fatal? */
@@ -1546,7 +1546,7 @@ static char *lookup_map(request_rec *r, char *name, char *key)
     case MAPTYPE_TXT:
         rv = apr_stat(&st, s->checkfile, APR_FINFO_MIN, r->pool);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00661)
                           "mod_rewrite: can't access text RewriteMap file %s",
                           s->checkfile);
             return NULL;
@@ -1587,7 +1587,7 @@ static char *lookup_map(request_rec *r, char *name, char *key)
     case MAPTYPE_DBM:
         rv = apr_stat(&st, s->checkfile, APR_FINFO_MIN, r->pool);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00662)
                           "mod_rewrite: can't access DBM RewriteMap file %s",
                           s->checkfile);
         }
@@ -1596,7 +1596,7 @@ static char *lookup_map(request_rec *r, char *name, char *key)
 
             rv = apr_stat(&st2, s->checkfile2, APR_FINFO_MIN, r->pool);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00663)
                               "mod_rewrite: can't access DBM RewriteMap "
                               "file %s", s->checkfile2);
             }
@@ -2887,7 +2887,7 @@ static const char *cmd_rewriteoptions(cmd_parms *cmd,
             options |= OPTION_NOSLASH;
         }
         else if (!strncasecmp(w, "MaxRedirects=", 13)) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00664)
                          "RewriteOptions: MaxRedirects option has been "
                          "removed in favor of the global "
                          "LimitInternalRecursion directive and will be "
@@ -3302,7 +3302,7 @@ static const char *cmd_rewritecond(cmd_parms *cmd, void *in_dconf,
     if ((newcond->ptype != CONDPAT_REGEX) &&
         (newcond->ptype < CONDPAT_STR_LT || newcond->ptype > CONDPAT_STR_GE) &&
         (newcond->flags & CONDFLAG_NOCASE)) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00665)
                      "RewriteCond: NoCase option for non-regex pattern '%s' "
                      "is not supported and will be ignored. (%s:%d)", a2,
                      cmd->directive->filename, cmd->directive->line_num);
@@ -4345,7 +4345,7 @@ static void init_child(apr_pool_t *p, server_rec *s)
         rv = apr_global_mutex_child_init(&rewrite_mapr_lock_acquire,
                  apr_global_mutex_lockfile(rewrite_mapr_lock_acquire), p);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00666)
                          "mod_rewrite: could not init rewrite_mapr_lock_acquire"
                          " in child");
         }
@@ -4353,7 +4353,7 @@ static void init_child(apr_pool_t *p, server_rec *s)
 
     /* create the lookup cache */
     if (!init_cache(p)) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00667)
                      "mod_rewrite: could not init map cache in child");
     }
 }
@@ -4426,7 +4426,7 @@ static int hook_uri2file(request_rec *r)
 
     /* Check that the URI is valid. */
     if (!r->uri || r->uri[0] != '/') {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00668)
                      "Invalid URI in request %s", r->the_request);
         return HTTP_BAD_REQUEST;
     }
@@ -4517,7 +4517,7 @@ static int hook_uri2file(request_rec *r)
              * we can actually use it!
              */
             if (!proxy_available) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00669)
                               "attempt to make remote request from mod_rewrite "
                               "without proxy enabled: %s", r->filename);
                 return HTTP_FORBIDDEN;
@@ -4739,7 +4739,7 @@ static int hook_fixup(request_rec *r)
      */
     if (!(ap_allow_options(r) & (OPT_SYM_LINKS | OPT_SYM_OWNER))) {
         /* FollowSymLinks is mandatory! */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00670)
                      "Options FollowSymLinks and SymLinksIfOwnerMatch are both off, "
                      "so the RewriteRule directive is also forbidden "
                      "due to its similar ability to circumvent directory restrictions : "
diff --git a/modules/metadata/mod_cern_meta.c b/modules/metadata/mod_cern_meta.c
index c2f2267..fe704f1 100644
--- a/modules/metadata/mod_cern_meta.c
+++ b/modules/metadata/mod_cern_meta.c
@@ -231,7 +231,7 @@ static int scan_meta_file(request_rec *r, apr_file_t *f)
         /* if we see a bogus header don't ignore it. Shout and scream */
 
         if (!(l = strchr(w, ':'))) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01560)
                 "malformed header in meta file: %s", r->filename);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -307,7 +307,7 @@ static int add_cern_meta_data(request_rec *r)
     }
     else {
         /* no last slash, buh?! */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01561)
             "internal error in mod_cern_meta: %s", r->filename);
         /* should really barf, but hey, let's be friends... */
         return DECLINED;
@@ -342,7 +342,7 @@ static int add_cern_meta_data(request_rec *r)
         if (APR_STATUS_IS_ENOENT(retcode)) {
             return DECLINED;
         }
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01562)
             "meta file permissions deny server access: %s", metafilename);
         return HTTP_FORBIDDEN;
     }
diff --git a/modules/metadata/mod_env.c b/modules/metadata/mod_env.c
index 38932d8..ab8889a 100644
--- a/modules/metadata/mod_env.c
+++ b/modules/metadata/mod_env.c
@@ -101,7 +101,7 @@ static const char *add_env_module_vars_passed(cmd_parms *cmd, void *sconf_,
         apr_table_setn(vars, arg, apr_pstrdup(cmd->pool, env_var));
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(01506)
                      "PassEnv variable %s was undefined", arg);
     }
 
diff --git a/modules/metadata/mod_expires.c b/modules/metadata/mod_expires.c
index f8a9946..2ef3d89 100644
--- a/modules/metadata/mod_expires.c
+++ b/modules/metadata/mod_expires.c
@@ -423,7 +423,7 @@ static int set_expiration_fields(request_rec *r, const char *code,
         /* expecting the add_* routines to be case-hardened this
          * is just a reminder that module is beta
          */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01500)
                     "internal error: bad expires code: %s", r->filename);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index 6a552c4..d3a1555 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -660,7 +660,7 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
             const char *err = NULL;
             int eval = ap_expr_exec(r, hdr->expr, &err);
             if (err) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01501)
                               "Failed to evaluate expression (%s) - ignoring",
                               err);
             }
@@ -797,7 +797,7 @@ static apr_status_t ap_headers_output_filter(ap_filter_t *f,
     headers_conf *dirconf = ap_get_module_config(f->r->per_dir_config,
                                                  &headers_module);
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, f->r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, f->r->server, APLOGNO(01502)
                  "headers: ap_headers_output_filter()");
 
     /* do the fixup */
@@ -822,7 +822,7 @@ static apr_status_t ap_headers_error_filter(ap_filter_t *f,
 
     dirconf = ap_get_module_config(f->r->per_dir_config,
                                     &headers_module);
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, f->r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, f->r->server, APLOGNO(01503)
                  "headers: ap_headers_error_filter()");
 
     /*
@@ -876,7 +876,7 @@ static apr_status_t ap_headers_early(request_rec *r)
 
     return DECLINED;
 err:
-    ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(01504)
                   "Regular expression replacement failed (replacement too long?)");
     return HTTP_INTERNAL_SERVER_ERROR;
 }
diff --git a/modules/metadata/mod_ident.c b/modules/metadata/mod_ident.c
index 1ba5208..8464680 100644
--- a/modules/metadata/mod_ident.c
+++ b/modules/metadata/mod_ident.c
@@ -95,7 +95,7 @@ static apr_status_t rfc1413_connect(apr_socket_t **newsock, conn_rec *conn,
                               0, conn->pool)) != APR_SUCCESS) {
         /* This should not fail since we have a numeric address string
          * as the host. */
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv, APLOGNO(01492)
                      "rfc1413: apr_sockaddr_info_get(%s) failed",
                      conn->local_ip);
         return rv;
@@ -106,7 +106,7 @@ static apr_status_t rfc1413_connect(apr_socket_t **newsock, conn_rec *conn,
                               RFC1413_PORT, 0, conn->pool)) != APR_SUCCESS) {
         /* This should not fail since we have a numeric address string
          * as the host. */
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv, APLOGNO(01493)
                      "rfc1413: apr_sockaddr_info_get(%s) failed",
                      conn->peer_ip);
         return rv;
@@ -115,13 +115,13 @@ static apr_status_t rfc1413_connect(apr_socket_t **newsock, conn_rec *conn,
     if ((rv = apr_socket_create(newsock,
                                 localsa->family, /* has to match */
                                 SOCK_STREAM, 0, conn->pool)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv, APLOGNO(01494)
                      "rfc1413: error creating query socket");
         return rv;
     }
 
     if ((rv = apr_socket_timeout_set(*newsock, timeout)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv, APLOGNO(01495)
                      "rfc1413: error setting query socket timeout");
         apr_socket_close(*newsock);
         return rv;
@@ -137,7 +137,7 @@ static apr_status_t rfc1413_connect(apr_socket_t **newsock, conn_rec *conn,
  */
 
     if ((rv = apr_socket_bind(*newsock, localsa)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv, APLOGNO(01496)
                      "rfc1413: Error binding query socket to local port");
         apr_socket_close(*newsock);
         return rv;
@@ -181,7 +181,7 @@ static apr_status_t rfc1413_query(apr_socket_t *sock, conn_rec *conn,
         apr_status_t status;
         status  = apr_socket_send(sock, buffer+i, &j);
         if (status != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv, APLOGNO(01497)
                          "write: rfc1413: error sending request");
             return status;
         }
@@ -207,7 +207,7 @@ static apr_status_t rfc1413_query(apr_socket_t *sock, conn_rec *conn,
         apr_status_t status;
         status = apr_socket_recv(sock, buffer+i, &j);
         if (status != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv, APLOGNO(01498)
                          "read: rfc1413: error reading response");
             return status;
         }
diff --git a/modules/metadata/mod_mime_magic.c b/modules/metadata/mod_mime_magic.c
index 3e99b11..03226ac 100644
--- a/modules/metadata/mod_mime_magic.c
+++ b/modules/metadata/mod_mime_magic.c
@@ -548,7 +548,7 @@ static int magic_rsl_add(request_rec *r, const char *str)
 
     /* make sure we have a list to put it in */
     if (!req_dat) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EINVAL, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EINVAL, r, APLOGNO(01507)
                     MODNAME ": request config should not be NULL");
         if (!(req_dat = magic_set_config(r))) {
             /* failure */
@@ -650,7 +650,7 @@ static char *rsl_strdup(request_rec *r, int start_frag, int start_pos, int len)
     /* clean up and return */
     result[res_pos] = 0;
 #if MIME_MAGIC_DEBUG
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01508)
              MODNAME ": rsl_strdup() %d chars: %s", res_pos - 1, result);
 #endif
     return result;
@@ -723,7 +723,7 @@ static int magic_rsl_to_request(request_rec *r)
                 else {
                     /* should not be possible */
                     /* abandon malfunctioning module */
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01509)
                                 MODNAME ": bad state %d (ws)", state);
                     return DECLINED;
                 }
@@ -767,7 +767,7 @@ static int magic_rsl_to_request(request_rec *r)
                 else {
                     /* should not be possible */
                     /* abandon malfunctioning module */
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01510)
                                 MODNAME ": bad state %d (ns)", state);
                     return DECLINED;
                 }
@@ -803,7 +803,7 @@ static int magic_rsl_to_request(request_rec *r)
     /* detect memory allocation or other errors */
     if (!r->content_type ||
         (state == rsl_encoding && !r->content_encoding)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01511)
                       MODNAME ": unexpected state %d; could be caused by bad "
                       "data in magic file",
                       state);
@@ -842,7 +842,7 @@ static int magic_process(request_rec *r)
 
     if (apr_file_open(&fd, r->filename, APR_READ, APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
         /* We can't open it, but we were able to stat it. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01512)
                     MODNAME ": can't read `%s'", r->filename);
         /* let some other handler decide what the problem is */
         return DECLINED;
@@ -853,7 +853,7 @@ static int magic_process(request_rec *r)
      */
     nbytes = sizeof(buf) - 1;
     if ((result = apr_file_read(fd, (char *) buf, &nbytes)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, result, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, result, r, APLOGNO(01513)
                     MODNAME ": read failed: %s", r->filename);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -927,13 +927,13 @@ static int apprentice(server_rec *s, apr_pool_t *p)
     const char *fname = ap_server_root_relative(p, conf->magicfile);
 
     if (!fname) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s, APLOGNO(01514)
                      MODNAME ": Invalid magic file path %s", conf->magicfile);
         return -1;
     }
     if ((result = apr_file_open(&f, fname, APR_READ | APR_BUFFERED,
                                 APR_OS_DEFAULT, p)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, result, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, result, s, APLOGNO(01515)
                      MODNAME ": can't read magic file %s", fname);
         return -1;
     }
@@ -983,28 +983,28 @@ static int apprentice(server_rec *s, apr_pool_t *p)
     (void) apr_file_close(f);
 
 #if MIME_MAGIC_DEBUG
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01516)
                 MODNAME ": apprentice conf=%x file=%s m=%s m->next=%s last=%s",
                 conf,
                 conf->magicfile ? conf->magicfile : "NULL",
                 conf->magic ? "set" : "NULL",
                 (conf->magic && conf->magic->next) ? "set" : "NULL",
                 conf->last ? "set" : "NULL");
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01517)
                 MODNAME ": apprentice read %d lines, %d rules, %d errors",
                 lineno, rule, errs);
 #endif
 
 #if MIME_MAGIC_DEBUG
     prevm = 0;
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01518)
                 MODNAME ": apprentice test");
     for (m = conf->magic; m; m = m->next) {
         if (apr_isprint((((unsigned long) m) >> 24) & 255) &&
             apr_isprint((((unsigned long) m) >> 16) & 255) &&
             apr_isprint((((unsigned long) m) >> 8) & 255) &&
             apr_isprint(((unsigned long) m) & 255)) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01519)
                         MODNAME ": apprentice: POINTER CLOBBERED! "
                         "m=\"%c%c%c%c\" line=%d",
                         (((unsigned long) m) >> 24) & 255,
@@ -1051,7 +1051,7 @@ static unsigned long signextend(server_rec *s, struct magic *m, unsigned long v)
         case STRING:
             break;
         default:
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01520)
                         MODNAME ": can't happen: m->type=%d", m->type);
             return -1;
         }
@@ -1099,7 +1099,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
     /* get offset, then skip over it */
     m->offset = (int) strtol(l, &t, 0);
     if (l == t) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv, APLOGNO(01521)
                     MODNAME ": offset %s invalid", l);
     }
     l = t;
@@ -1122,7 +1122,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
                 m->in.type = BYTE;
                 break;
             default:
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv, APLOGNO(01522)
                         MODNAME ": indirect offset type %c invalid", *l);
                 break;
             }
@@ -1139,7 +1139,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
         else
             t = l;
         if (*t++ != ')') {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv, APLOGNO(01523)
                         MODNAME ": missing ')' in indirect offset");
         }
         l = t;
@@ -1213,7 +1213,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
         l += NLEDATE;
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv, APLOGNO(01524)
                     MODNAME ": type %s invalid", l);
         return -1;
     }
@@ -1275,7 +1275,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
     apr_cpystrn(m->desc, l, sizeof(m->desc));
 
 #if MIME_MAGIC_DEBUG
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, serv,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, serv, APLOGNO(01525)
                 MODNAME ": parse line=%d m=%x next=%x cont=%d desc=%s",
                 lineno, m, m->next, m->cont_level, m->desc);
 #endif /* MIME_MAGIC_DEBUG */
@@ -1318,7 +1318,7 @@ static char *getstr(server_rec *serv, register char *s, register char *p,
         if (apr_isspace(c))
             break;
         if (p >= pmax) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv, APLOGNO(01526)
                         MODNAME ": string too long: %s", origs);
             break;
         }
@@ -1464,7 +1464,7 @@ static int fsmagic(request_rec *r, const char *fn)
         /* We used stat(), the only possible reason for this is that the
          * symlink is broken.
          */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01527)
                     MODNAME ": broken symlink (%s)", fn);
         return HTTP_INTERNAL_SERVER_ERROR;
     case APR_SOCK:
@@ -1473,7 +1473,7 @@ static int fsmagic(request_rec *r, const char *fn)
     case APR_REG:
         break;
     default:
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01528)
                       MODNAME ": invalid file type %d.", r->finfo.filetype);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -1540,7 +1540,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
     struct magic *m;
 
 #if MIME_MAGIC_DEBUG
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01529)
                 MODNAME ": match conf=%x file=%s m=%s m->next=%s last=%s",
                 conf,
                 conf->magicfile ? conf->magicfile : "NULL",
@@ -1555,7 +1555,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
             apr_isprint((((unsigned long) m) >> 16) & 255) &&
             apr_isprint((((unsigned long) m) >> 8) & 255) &&
             apr_isprint(((unsigned long) m) & 255)) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01530)
                         MODNAME ": match: POINTER CLOBBERED! "
                         "m=\"%c%c%c%c\"",
                         (((unsigned long) m) >> 24) & 255,
@@ -1570,7 +1570,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
     for (m = conf->magic; m; m = m->next) {
 #if MIME_MAGIC_DEBUG
         rule_counter++;
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01531)
                     MODNAME ": line=%d desc=%s", m->lineno, m->desc);
 #endif
 
@@ -1590,7 +1590,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
             while (m_cont && (m_cont->cont_level != 0)) {
 #if MIME_MAGIC_DEBUG
                 rule_counter++;
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01532)
                         MODNAME ": line=%d mc=%x mc->next=%x cont=%d desc=%s",
                             m_cont->lineno, m_cont,
                             m_cont->next, m_cont->cont_level,
@@ -1609,7 +1609,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
         /* if we get here, the main entry rule was a match */
         /* this will be the last run through the loop */
 #if MIME_MAGIC_DEBUG
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01533)
                     MODNAME ": rule matched, line=%d type=%d %s",
                     m->lineno, m->type,
                     (m->type == STRING) ? m->value.s : "");
@@ -1633,7 +1633,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
         m = m->next;
         while (m && (m->cont_level != 0)) {
 #if MIME_MAGIC_DEBUG
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01534)
                         MODNAME ": match line=%d cont=%d type=%d %s",
                         m->lineno, m->cont_level, m->type,
                         (m->type == STRING) ? m->value.s : "");
@@ -1677,13 +1677,13 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
             m = m->next;
         }
 #if MIME_MAGIC_DEBUG
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01535)
                     MODNAME ": matched after %d rules", rule_counter);
 #endif
         return 1;  /* all through */
     }
 #if MIME_MAGIC_DEBUG
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01536)
                 MODNAME ": failed after %d rules", rule_counter);
 #endif
     return 0;  /* no match at all */
@@ -1729,7 +1729,7 @@ static void mprint(request_rec *r, union VALUETYPE *p, struct magic *m)
         (void) magic_rsl_printf(r, m->desc, pp);
         return;
     default:
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01537)
                     MODNAME ": invalid m->type (%d) in mprint().",
                     m->type);
         return;
@@ -1775,7 +1775,7 @@ static int mconvert(request_rec *r, union VALUETYPE *p, struct magic *m)
             ((p->hl[3] << 24) | (p->hl[2] << 16) | (p->hl[1] << 8) | (p->hl[0]));
         return 1;
     default:
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01538)
                     MODNAME ": invalid type %d in mconvert().", m->type);
         return 0;
     }
@@ -1827,7 +1827,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     int matched;
 
     if ((m->value.s[0] == 'x') && (m->value.s[1] == '\0')) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01539)
                     MODNAME ": BOINK");
         return 1;
     }
@@ -1872,7 +1872,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
         break;
     default:
         /*  bogosity, pretend that it just wasn't a match */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01540)
                     MODNAME ": invalid type %d in mcheck().", m->type);
         return 0;
     }
@@ -1882,7 +1882,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     switch (m->reln) {
     case 'x':
 #if MIME_MAGIC_DEBUG
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01541)
                     "%lu == *any* = 1", v);
 #endif
         matched = 1;
@@ -1891,7 +1891,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     case '!':
         matched = v != l;
 #if MIME_MAGIC_DEBUG
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01542)
                     "%lu != %lu = %d", v, l, matched);
 #endif
         break;
@@ -1899,7 +1899,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     case '=':
         matched = v == l;
 #if MIME_MAGIC_DEBUG
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01543)
                     "%lu == %lu = %d", v, l, matched);
 #endif
         break;
@@ -1908,14 +1908,14 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
         if (m->flag & UNSIGNED) {
             matched = v > l;
 #if MIME_MAGIC_DEBUG
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01544)
                         "%lu > %lu = %d", v, l, matched);
 #endif
         }
         else {
             matched = (long) v > (long) l;
 #if MIME_MAGIC_DEBUG
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01545)
                         "%ld > %ld = %d", v, l, matched);
 #endif
         }
@@ -1925,14 +1925,14 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
         if (m->flag & UNSIGNED) {
             matched = v < l;
 #if MIME_MAGIC_DEBUG
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01546)
                         "%lu < %lu = %d", v, l, matched);
 #endif
         }
         else {
             matched = (long) v < (long) l;
 #if MIME_MAGIC_DEBUG
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01547)
                         "%ld < %ld = %d", v, l, matched);
 #endif
         }
@@ -1941,7 +1941,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     case '&':
         matched = (v & l) == l;
 #if MIME_MAGIC_DEBUG
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01548)
                     "((%lx & %lx) == %lx) = %d", v, l, l, matched);
 #endif
         break;
@@ -1949,7 +1949,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     case '^':
         matched = (v & l) != l;
 #if MIME_MAGIC_DEBUG
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01549)
                     "((%lx & %lx) != %lx) = %d", v, l, l, matched);
 #endif
         break;
@@ -1957,7 +1957,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     default:
         /* bogosity, pretend it didn't match */
         matched = 0;
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01550)
                     MODNAME ": mcheck: can't happen: invalid relation %d.",
                     m->reln);
         break;
@@ -2137,7 +2137,7 @@ static int create_uncompress_child(struct uncompress_parms *parm, apr_pool_t *cn
                               ap_make_dirstr_parent(r->pool, r->filename)) != APR_SUCCESS) ||
         (apr_procattr_cmdtype_set(procattr, APR_PROGRAM_PATH) != APR_SUCCESS)) {
         /* Something bad happened, tell the world. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_ENOPROC, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_ENOPROC, r, APLOGNO(01551)
                "couldn't setup child process: %s", r->filename);
     }
     else {
@@ -2152,7 +2152,7 @@ static int create_uncompress_child(struct uncompress_parms *parm, apr_pool_t *cn
 
         if (rc != APR_SUCCESS) {
             /* Bad things happened. Everyone should have cleaned up. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_ENOPROC, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_ENOPROC, r, APLOGNO(01552)
                           MODNAME ": could not execute `%s'.",
                           compr[parm->method].argv[0]);
         }
@@ -2184,7 +2184,7 @@ static int uncompress(request_rec *r, int method,
         return -1;
 
     if ((rv = create_uncompress_child(&parm, sub_context, &pipe_out)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01553)
                     MODNAME ": couldn't spawn uncompress process: %s", r->uri);
         return -1;
     }
@@ -2193,7 +2193,7 @@ static int uncompress(request_rec *r, int method,
     rv = apr_file_read(pipe_out, *newch, &n);
     if (n == 0) {
         apr_pool_destroy(sub_context);
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01554)
             MODNAME ": read failed from uncompress of %s", r->filename);
         return -1;
     }
@@ -2300,7 +2300,7 @@ static int revision_suffix(request_rec *r)
     request_rec *sub;
 
 #if MIME_MAGIC_DEBUG
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01555)
                 MODNAME ": revision_suffix checking %s", r->filename);
 #endif /* MIME_MAGIC_DEBUG */
 
@@ -2319,7 +2319,7 @@ static int revision_suffix(request_rec *r)
     result = 0;
     sub_filename = apr_pstrndup(r->pool, r->filename, suffix_pos);
 #if MIME_MAGIC_DEBUG
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01556)
                 MODNAME ": subrequest lookup for %s", sub_filename);
 #endif /* MIME_MAGIC_DEBUG */
     sub = ap_sub_req_lookup_file(sub_filename, r, NULL);
@@ -2328,7 +2328,7 @@ static int revision_suffix(request_rec *r)
     if (sub->content_type) {
         ap_set_content_type(r, apr_pstrdup(r->pool, sub->content_type));
 #if MIME_MAGIC_DEBUG
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01557)
                     MODNAME ": subrequest %s got %s",
                     sub_filename, r->content_type);
 #endif /* MIME_MAGIC_DEBUG */
@@ -2379,14 +2379,14 @@ static int magic_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server
                 return OK;
 #if MIME_MAGIC_DEBUG
             prevm = 0;
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01558)
                         MODNAME ": magic_init 1 test");
             for (m = conf->magic; m; m = m->next) {
                 if (apr_isprint((((unsigned long) m) >> 24) & 255) &&
                     apr_isprint((((unsigned long) m) >> 16) & 255) &&
                     apr_isprint((((unsigned long) m) >> 8) & 255) &&
                     apr_isprint(((unsigned long) m) & 255)) {
-                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01559)
                                 MODNAME ": magic_init 1: POINTER CLOBBERED! "
                                 "m=\"%c%c%c%c\" line=%d",
                                 (((unsigned long) m) >> 24) & 255,
diff --git a/modules/metadata/mod_remoteip.c b/modules/metadata/mod_remoteip.c
index c72e8d8..363d812 100644
--- a/modules/metadata/mod_remoteip.c
+++ b/modules/metadata/mod_remoteip.c
@@ -298,7 +298,7 @@ static int remoteip_modify_request(request_rec *r)
                                    APR_UNSPEC, temp_sa->port,
                                    APR_IPV4_ADDR_OK, r->pool);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG,  rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG,  rv, r, APLOGNO(01568)
                           "RemoteIP: Header %s value of %s cannot be parsed "
                           "as a client IP",
                           config->header_name, parse_remote);
@@ -337,7 +337,7 @@ static int remoteip_modify_request(request_rec *r)
                       && ((temp_sa->sa.sin6.sin6_addr.s6_addr[0] & 0xe0) != 0x20))
 #endif
         )) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG,  rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG,  rv, r, APLOGNO(01569)
                           "RemoteIP: Header %s value of %s appears to be "
                           "a private IP or nonsensical.  Ignored",
                           config->header_name, parse_remote);
diff --git a/modules/metadata/mod_setenvif.c b/modules/metadata/mod_setenvif.c
index 5a2ee71..dbbf34d 100644
--- a/modules/metadata/mod_setenvif.c
+++ b/modules/metadata/mod_setenvif.c
@@ -608,7 +608,7 @@ static int match_headers(request_rec *r)
                                            replaced);
                         }
                         else {
-                            ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
+                            ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(01505)
                                           "Regular expression replacement "
                                           "failed for '%s', value too long?",
                                           elts[j].key);
diff --git a/modules/metadata/mod_unique_id.c b/modules/metadata/mod_unique_id.c
index d28ecaa..8bd858f 100644
--- a/modules/metadata/mod_unique_id.c
+++ b/modules/metadata/mod_unique_id.c
@@ -171,7 +171,7 @@ static int unique_id_global_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *pt
      * be unique as the physical address of the machine
      */
     if ((rv = apr_gethostname(str, sizeof(str) - 1, p)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, main_server,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, main_server, APLOGNO(01563)
           "unable to find hostname of the server");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -180,14 +180,14 @@ static int unique_id_global_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *pt
         global_in_addr = sockaddr->sa.sin.sin_addr.s_addr;
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, main_server,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, main_server, APLOGNO(01564)
                     "unable to find IPv4 address of \"%s\"", str);
 #if APR_HAVE_IPV6
         if ((rv = apr_sockaddr_info_get(&sockaddr, str, AF_INET6, 0, 0, p)) == APR_SUCCESS) {
             memcpy(&global_in_addr,
                    (char *)sockaddr->ipaddr_ptr + sockaddr->ipaddr_len - sizeof(global_in_addr),
                    sizeof(global_in_addr));
-            ap_log_error(APLOG_MARK, APLOG_ALERT, rv, main_server,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, rv, main_server, APLOGNO(01565)
                          "using low-order bits of IPv6 address "
                          "as if they were unique");
         }
@@ -197,7 +197,7 @@ static int unique_id_global_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *pt
     }
 
     apr_sockaddr_ip_get(&ipaddrstr, sockaddr);
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, main_server, "using ip addr %s",
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, main_server, APLOGNO(01566) "using ip addr %s",
                  ipaddrstr);
 
     /*
@@ -240,7 +240,7 @@ static void unique_id_child_init(apr_pool_t *p, server_rec *s)
      * global_init ... but oh well.
      */
     if ((pid_t)cur_unique_id.pid != pid) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(01567)
                     "oh no! pids are greater than 32-bits!  I'm broken!");
     }
 
diff --git a/modules/metadata/mod_usertrack.c b/modules/metadata/mod_usertrack.c
index d94f283..390adb9 100644
--- a/modules/metadata/mod_usertrack.c
+++ b/modules/metadata/mod_usertrack.c
@@ -237,7 +237,7 @@ static int spot_cookie(request_rec *r)
                     err = 1;
             }
             if (err) {
-                ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(01499)
                               "Failed to extract cookie value (out of mem?)");
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
diff --git a/modules/proxy/ajp_header.c b/modules/proxy/ajp_header.c
index 310b825..4c7aad0 100644
--- a/modules/proxy/ajp_header.c
+++ b/modules/proxy/ajp_header.c
@@ -226,7 +226,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
     ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r, "Into ajp_marshal_into_msgb");
 
     if ((method = sc_for_req_method_by_id(r)) == UNKNOWN_METHOD) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00967)
                "ajp_marshal_into_msgb - No such method %s",
                r->method);
         return AJP_EBAD_METHOD;
@@ -254,7 +254,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
         ajp_msg_append_uint8(msg, is_ssl)                        ||
         ajp_msg_append_uint16(msg, (apr_uint16_t) num_headers)) {
 
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00968)
                "ajp_marshal_into_msgb: "
                "Error appending the message begining");
         return APR_EGENERAL;
@@ -267,7 +267,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
 
         if ((sc = sc_for_req_header(elts[i].key)) != UNKNOWN_METHOD) {
             if (ajp_msg_append_uint16(msg, (apr_uint16_t)sc)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00969)
                        "ajp_marshal_into_msgb: "
                        "Error appending the header name");
                 return AJP_EOVERFLOW;
@@ -275,7 +275,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
         }
         else {
             if (ajp_msg_append_string(msg, elts[i].key)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00970)
                        "ajp_marshal_into_msgb: "
                        "Error appending the header name");
                 return AJP_EOVERFLOW;
@@ -283,7 +283,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
         }
 
         if (ajp_msg_append_string(msg, elts[i].val)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00971)
                    "ajp_marshal_into_msgb: "
                    "Error appending the header value");
             return AJP_EOVERFLOW;
@@ -308,7 +308,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
     if (r->user) {
         if (ajp_msg_append_uint8(msg, SC_A_REMOTE_USER) ||
             ajp_msg_append_string(msg, r->user)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00972)
                    "ajp_marshal_into_msgb: "
                    "Error appending the remote user");
             return AJP_EOVERFLOW;
@@ -317,7 +317,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
     if (r->ap_auth_type) {
         if (ajp_msg_append_uint8(msg, SC_A_AUTH_TYPE) ||
             ajp_msg_append_string(msg, r->ap_auth_type)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00973)
                    "ajp_marshal_into_msgb: "
                    "Error appending the auth type");
             return AJP_EOVERFLOW;
@@ -327,7 +327,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
     if (uri->query) {
         if (ajp_msg_append_uint8(msg, SC_A_QUERY_STRING) ||
             ajp_msg_append_string(msg, uri->query)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00974)
                    "ajp_marshal_into_msgb: "
                    "Error appending the query string");
             return AJP_EOVERFLOW;
@@ -336,7 +336,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
     if ((session_route = apr_table_get(r->notes, "session-route"))) {
         if (ajp_msg_append_uint8(msg, SC_A_JVM_ROUTE) ||
             ajp_msg_append_string(msg, session_route)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00975)
                    "ajp_marshal_into_msgb: "
                    "Error appending the jvm route");
             return AJP_EOVERFLOW;
@@ -359,7 +359,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
             && envvar[0]) {
             if (ajp_msg_append_uint8(msg, SC_A_SSL_CERT)
                 || ajp_msg_append_string(msg, envvar)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00976)
                               "ajp_marshal_into_msgb: "
                               "Error appending the SSL certificates");
                 return AJP_EOVERFLOW;
@@ -371,7 +371,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
             && envvar[0]) {
             if (ajp_msg_append_uint8(msg, SC_A_SSL_CIPHER)
                 || ajp_msg_append_string(msg, envvar)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00977)
                               "ajp_marshal_into_msgb: "
                               "Error appending the SSL ciphers");
                 return AJP_EOVERFLOW;
@@ -383,7 +383,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
             && envvar[0]) {
             if (ajp_msg_append_uint8(msg, SC_A_SSL_SESSION)
                 || ajp_msg_append_string(msg, envvar)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00978)
                               "ajp_marshal_into_msgb: "
                               "Error appending the SSL session");
                 return AJP_EOVERFLOW;
@@ -397,7 +397,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
 
             if (ajp_msg_append_uint8(msg, SC_A_SSL_KEY_SIZE)
                 || ajp_msg_append_uint16(msg, (unsigned short) atoi(envvar))) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00979)
                               "ajp_marshal_into_msgb: "
                               "Error appending the SSL key size");
                 return APR_EGENERAL;
@@ -417,7 +417,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
         if (ajp_msg_append_uint8(msg, SC_A_REQ_ATTRIBUTE) ||
             ajp_msg_append_string(msg, key)   ||
             ajp_msg_append_string(msg, val)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00980)
                     "ajp_marshal_into_msgb: "
                     "Error appending attribute %s=%s",
                     key, val);
@@ -432,7 +432,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
             if (ajp_msg_append_uint8(msg, SC_A_REQ_ATTRIBUTE) ||
                 ajp_msg_append_string(msg, elts[i].key + 4)   ||
                 ajp_msg_append_string(msg, elts[i].val)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00981)
                         "ajp_marshal_into_msgb: "
                         "Error appending attribute %s=%s",
                         elts[i].key, elts[i].val);
@@ -442,7 +442,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
     }
 
     if (ajp_msg_append_uint8(msg, SC_A_ARE_DONE)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00982)
                "ajp_marshal_into_msgb: "
                "Error appending the message end");
         return AJP_EOVERFLOW;
@@ -497,7 +497,7 @@ static apr_status_t ajp_unmarshal_response(ajp_msg_t *msg,
     rc = ajp_msg_get_uint16(msg, &status);
 
     if (rc != APR_SUCCESS) {
-         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00983)
                 "ajp_unmarshal_response: Null status");
         return rc;
     }
@@ -552,7 +552,7 @@ static apr_status_t ajp_unmarshal_response(ajp_msg_t *msg,
             ajp_msg_get_uint16(msg, &name);
             stringname = long_res_header_for_sc(name);
             if (stringname == NULL) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00984)
                        "ajp_unmarshal_response: "
                        "No such sc (%08x)",
                        name);
@@ -562,7 +562,7 @@ static apr_status_t ajp_unmarshal_response(ajp_msg_t *msg,
             name = 0;
             rc = ajp_msg_get_string(msg, &stringname);
             if (rc != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00985)
                        "ajp_unmarshal_response: "
                        "Null header name");
                 return rc;
@@ -572,7 +572,7 @@ static apr_status_t ajp_unmarshal_response(ajp_msg_t *msg,
 
         rc = ajp_msg_get_string(msg, &value);
         if (rc != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00986)
                    "ajp_unmarshal_response: "
                    "Null header value");
             return rc;
@@ -624,14 +624,14 @@ apr_status_t ajp_send_header(apr_socket_t *sock,
 
     rc = ajp_msg_create(r->pool, buffsize, &msg);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00987)
                "ajp_send_header: ajp_msg_create failed");
         return rc;
     }
 
     rc = ajp_marshal_into_msgb(msg, r, uri);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00988)
                "ajp_send_header: ajp_marshal_into_msgb failed");
         return rc;
     }
@@ -639,7 +639,7 @@ apr_status_t ajp_send_header(apr_socket_t *sock,
     rc = ajp_ilink_send(sock, msg);
     ajp_msg_log(r, msg, "ajp_send_header: ajp_ilink_send packet dump");
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00989)
                "ajp_send_header: ajp_ilink_send failed");
         return rc;
     }
@@ -661,7 +661,7 @@ apr_status_t ajp_read_header(apr_socket_t *sock,
     if (*msg) {
         rc = ajp_msg_reuse(*msg);
         if (rc != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00990)
                    "ajp_read_header: ajp_msg_reuse failed");
             return rc;
         }
@@ -669,7 +669,7 @@ apr_status_t ajp_read_header(apr_socket_t *sock,
     else {
         rc = ajp_msg_create(r->pool, buffsize, msg);
         if (rc != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00991)
                    "ajp_read_header: ajp_msg_create failed");
             return rc;
         }
@@ -677,14 +677,14 @@ apr_status_t ajp_read_header(apr_socket_t *sock,
     ajp_msg_reset(*msg);
     rc = ajp_ilink_receive(sock, *msg);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00992)
                "ajp_read_header: ajp_ilink_receive failed");
         return rc;
     }
     ajp_msg_log(r, *msg, "ajp_read_header: ajp_ilink_receive packet dump");
     rc = ajp_msg_peek_uint8(*msg, &result);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00993)
                       "ajp_read_header: ajp_msg_peek_uint8 failed");
         return rc;
     }
@@ -714,12 +714,12 @@ apr_status_t ajp_parse_header(request_rec  *r, proxy_dir_conf *conf,
 
     rc = ajp_msg_get_uint8(msg, &result);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00994)
                "ajp_parse_headers: ajp_msg_get_byte failed");
         return rc;
     }
     if (result != CMD_AJP13_SEND_HEADERS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00995)
                "ajp_parse_headers: wrong type %s (0x%02x) expecting %s (0x%02x)",
                ajp_type_str(result), result,
                ajp_type_str(CMD_AJP13_SEND_HEADERS), CMD_AJP13_SEND_HEADERS);
@@ -738,12 +738,12 @@ apr_status_t  ajp_parse_data(request_rec  *r, ajp_msg_t *msg,
 
     rc = ajp_msg_get_uint8(msg, &result);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00996)
                "ajp_parse_data: ajp_msg_get_byte failed");
         return rc;
     }
     if (result != CMD_AJP13_SEND_BODY_CHUNK) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00997)
                "ajp_parse_data: wrong type %s (0x%02x) expecting %s (0x%02x)",
                ajp_type_str(result), result,
                ajp_type_str(CMD_AJP13_SEND_BODY_CHUNK), CMD_AJP13_SEND_BODY_CHUNK);
@@ -765,7 +765,7 @@ apr_status_t  ajp_parse_data(request_rec  *r, ajp_msg_t *msg,
      */
     expected_len = msg->len - (AJP_HEADER_LEN + AJP_HEADER_SZ_LEN + 1 + 1);
     if (*len != expected_len) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00998)
                "ajp_parse_data: Wrong chunk length. Length of chunk is %i,"
                " expected length is %i.", *len, expected_len);
         return AJP_EBAD_HEADER;
@@ -783,12 +783,12 @@ apr_status_t ajp_parse_reuse(request_rec *r, ajp_msg_t *msg,
 
     rc = ajp_msg_get_uint8(msg, &result);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00999)
                "ajp_parse_reuse: ajp_msg_get_byte failed");
         return rc;
     }
     if (result != CMD_AJP13_END_RESPONSE) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01000)
                "ajp_parse_reuse: wrong type %s (0x%02x) expecting %s (0x%02x)",
                ajp_type_str(result), result,
                ajp_type_str(CMD_AJP13_END_RESPONSE), CMD_AJP13_END_RESPONSE);
diff --git a/modules/proxy/ajp_link.c b/modules/proxy/ajp_link.c
index f8e32ac..4f8a9ef 100644
--- a/modules/proxy/ajp_link.c
+++ b/modules/proxy/ajp_link.c
@@ -34,7 +34,7 @@ apr_status_t ajp_ilink_send(apr_socket_t *sock, ajp_msg_t *msg)
 
         status = apr_socket_send(sock, buf, &written);
         if (status != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, status, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR, status, NULL, APLOGNO(01029)
                           "ajp_ilink_send(): send failed");
             return status;
         }
@@ -82,7 +82,7 @@ apr_status_t ajp_ilink_receive(apr_socket_t *sock, ajp_msg_t *msg)
     status = ilink_read(sock, msg->buf, hlen);
 
     if (status != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, status, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, status, NULL, APLOGNO(01030)
                      "ajp_ilink_receive() can't receive header");
         return (APR_STATUS_IS_TIMEUP(status) ? APR_TIMEUP : AJP_ENO_HEADER);
     }
@@ -90,7 +90,7 @@ apr_status_t ajp_ilink_receive(apr_socket_t *sock, ajp_msg_t *msg)
     status = ajp_msg_check_header(msg, &blen);
 
     if (status != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(01031)
                      "ajp_ilink_receive() received bad header");
         return AJP_EBAD_HEADER;
     }
@@ -98,14 +98,14 @@ apr_status_t ajp_ilink_receive(apr_socket_t *sock, ajp_msg_t *msg)
     status = ilink_read(sock, msg->buf + hlen, blen);
 
     if (status != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, status, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, status, NULL, APLOGNO(01032)
                      "ajp_ilink_receive() error while receiving message body "
                      "of length %" APR_SIZE_T_FMT,
                      hlen);
         return AJP_EBAD_MESSAGE;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL, APLOGNO(01033)
                  "ajp_ilink_receive() received packet len=%" APR_SIZE_T_FMT
                  "type=%d",
                   blen, (int)msg->buf[hlen]);
diff --git a/modules/proxy/ajp_msg.c b/modules/proxy/ajp_msg.c
index d5f47b3..69e232a 100644
--- a/modules/proxy/ajp_msg.c
+++ b/modules/proxy/ajp_msg.c
@@ -151,7 +151,7 @@ apr_status_t ajp_msg_check_header(ajp_msg_t *msg, apr_size_t *len)
     if (!((head[0] == 0x41 && head[1] == 0x42) ||
           (head[0] == 0x12 && head[1] == 0x34))) {
 
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(01080)
                       "ajp_msg_check_header() got bad signature %02x%02x",
                       head[0], head[1]);
 
@@ -162,7 +162,7 @@ apr_status_t ajp_msg_check_header(ajp_msg_t *msg, apr_size_t *len)
     msglen += (head[3] & 0xFF);
 
     if (msglen > msg->max_size) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(01081)
                      "ajp_msg_check_header() incoming message is "
                      "too big %" APR_SIZE_T_FMT ", max is %" APR_SIZE_T_FMT,
                      msglen, msg->max_size);
@@ -578,7 +578,7 @@ apr_status_t ajp_msg_create(apr_pool_t *pool, apr_size_t size, ajp_msg_t **rmsg)
 apr_status_t ajp_msg_copy(ajp_msg_t *smsg, ajp_msg_t *dmsg)
 {
     if (smsg->len > smsg->max_size) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(01082)
                      "ajp_msg_copy(): destination buffer too "
                      "small %" APR_SIZE_T_FMT ", max size is %" APR_SIZE_T_FMT,
                      smsg->len, smsg->max_size);
diff --git a/modules/proxy/ajp_utils.c b/modules/proxy/ajp_utils.c
index b9ccab5..567af91 100644
--- a/modules/proxy/ajp_utils.c
+++ b/modules/proxy/ajp_utils.c
@@ -35,14 +35,14 @@ apr_status_t ajp_handle_cping_cpong(apr_socket_t *sock,
 
     rc = ajp_msg_create(r->pool, AJP_PING_PONG_SZ, &msg);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01007)
                "ajp_handle_cping_cpong: ajp_msg_create failed");
         return rc;
     }
 
     rc = ajp_msg_serialize_cping(msg);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01008)
                "ajp_handle_cping_cpong: ajp_marshal_into_msgb failed");
         return rc;
     }
@@ -50,14 +50,14 @@ apr_status_t ajp_handle_cping_cpong(apr_socket_t *sock,
     rc = ajp_ilink_send(sock, msg);
     ajp_msg_log(r, msg, "ajp_handle_cping_cpong: ajp_ilink_send packet dump");
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01009)
                "ajp_handle_cping_cpong: ajp_ilink_send failed");
         return rc;
     }
 
     rc = apr_socket_timeout_get(sock, &org);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01010)
                "ajp_handle_cping_cpong: apr_socket_timeout_get failed");
         return rc;
     }
@@ -65,7 +65,7 @@ apr_status_t ajp_handle_cping_cpong(apr_socket_t *sock,
     /* Set CPING/CPONG response timeout */
     rc = apr_socket_timeout_set(sock, timeout);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01011)
                "ajp_handle_cping_cpong: apr_socket_timeout_set failed");
         return rc;
     }
@@ -74,7 +74,7 @@ apr_status_t ajp_handle_cping_cpong(apr_socket_t *sock,
     /* Read CPONG reply */
     rv = ajp_ilink_receive(sock, msg);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01012)
                "ajp_handle_cping_cpong: ajp_ilink_receive failed");
         goto cleanup;
     }
@@ -82,12 +82,12 @@ apr_status_t ajp_handle_cping_cpong(apr_socket_t *sock,
     ajp_msg_log(r, msg, "ajp_handle_cping_cpong: ajp_ilink_receive packet dump");
     rv = ajp_msg_get_uint8(msg, &result);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01013)
                "ajp_handle_cping_cpong: invalid CPONG message");
         goto cleanup;
     }
     if (result != CMD_AJP13_CPONG) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01014)
                "ajp_handle_cping_cpong: awaited CPONG, received %d ",
                result);
         rv = APR_EGENERAL;
@@ -98,7 +98,7 @@ cleanup:
     /* Restore original socket timeout */
     rc = apr_socket_timeout_set(sock, org);
     if (rc != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01015)
                "ajp_handle_cping_cpong: apr_socket_timeout_set failed");
         return rc;
     }
diff --git a/modules/proxy/balancers/mod_lbmethod_bybusyness.c b/modules/proxy/balancers/mod_lbmethod_bybusyness.c
index 2b3124e..9185f22 100644
--- a/modules/proxy/balancers/mod_lbmethod_bybusyness.c
+++ b/modules/proxy/balancers/mod_lbmethod_bybusyness.c
@@ -48,7 +48,7 @@ static proxy_worker *find_best_bybusyness(proxy_balancer *balancer,
         }
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01211)
                  "proxy: Entering bybusyness for BALANCER (%s)",
                  balancer->s->name);
 
@@ -109,7 +109,7 @@ static proxy_worker *find_best_bybusyness(proxy_balancer *balancer,
 
     if (mycandidate) {
         mycandidate->s->lbstatus -= total_factor;
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01212)
                      "proxy: bybusyness selected worker \"%s\" : busy %" APR_SIZE_T_FMT " : lbstatus %d",
                      mycandidate->s->name, mycandidate->s->busy, mycandidate->s->lbstatus);
 
diff --git a/modules/proxy/balancers/mod_lbmethod_byrequests.c b/modules/proxy/balancers/mod_lbmethod_byrequests.c
index 0efa81d..015de12 100644
--- a/modules/proxy/balancers/mod_lbmethod_byrequests.c
+++ b/modules/proxy/balancers/mod_lbmethod_byrequests.c
@@ -92,7 +92,7 @@ static proxy_worker *find_best_byrequests(proxy_balancer *balancer,
         }
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01207)
                  "proxy: Entering byrequests for BALANCER (%s)",
                  balancer->s->name);
 
@@ -139,7 +139,7 @@ static proxy_worker *find_best_byrequests(proxy_balancer *balancer,
 
     if (mycandidate) {
         mycandidate->s->lbstatus -= total_factor;
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01208)
                      "proxy: byrequests selected worker \"%s\" : busy %" APR_SIZE_T_FMT " : lbstatus %d",
                      mycandidate->s->name, mycandidate->s->busy, mycandidate->s->lbstatus);
 
diff --git a/modules/proxy/balancers/mod_lbmethod_bytraffic.c b/modules/proxy/balancers/mod_lbmethod_bytraffic.c
index ef15dee..ee24515 100644
--- a/modules/proxy/balancers/mod_lbmethod_bytraffic.c
+++ b/modules/proxy/balancers/mod_lbmethod_bytraffic.c
@@ -64,7 +64,7 @@ static proxy_worker *find_best_bytraffic(proxy_balancer *balancer,
         }
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01209)
                  "proxy: Entering bytraffic for BALANCER (%s)",
                  balancer->s->name);
 
@@ -112,7 +112,7 @@ static proxy_worker *find_best_bytraffic(proxy_balancer *balancer,
     } while (cur_lbset <= max_lbset && !mycandidate);
 
     if (mycandidate) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01210)
                      "proxy: bytraffic selected worker \"%s\" : busy %" APR_SIZE_T_FMT,
                      mycandidate->s->name, mycandidate->s->busy);
 
diff --git a/modules/proxy/balancers/mod_lbmethod_heartbeat.c b/modules/proxy/balancers/mod_lbmethod_heartbeat.c
index 407951c..94f23d0 100644
--- a/modules/proxy/balancers/mod_lbmethod_heartbeat.c
+++ b/modules/proxy/balancers/mod_lbmethod_heartbeat.c
@@ -289,7 +289,7 @@ static proxy_worker *find_best_hb(proxy_balancer *balancer,
     rv = read_heartbeats(ctx->path, servers, tpool);
 
     if (rv) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01213)
                       "lb_heartbeat: Unable to read heartbeats at '%s'",
                       ctx->path);
         apr_pool_destroy(tpool);
@@ -303,7 +303,7 @@ static proxy_worker *find_best_hb(proxy_balancer *balancer,
         server = apr_hash_get(servers, (*worker)->s->hostname, APR_HASH_KEY_STRING);
 
         if (!server) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(01214)
                       "lb_heartbeat: No server for worker %s", (*worker)->s->name);
             continue;
         }
diff --git a/modules/proxy/examples/mod_lbmethod_rr.c b/modules/proxy/examples/mod_lbmethod_rr.c
index 2ed3134..adb28d8 100644
--- a/modules/proxy/examples/mod_lbmethod_rr.c
+++ b/modules/proxy/examples/mod_lbmethod_rr.c
@@ -49,7 +49,7 @@ static proxy_worker *find_best_roundrobin(proxy_balancer *balancer,
     int checked_standby;
     rr_data *ctx;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01116)
                  "proxy: Entering roundrobin for BALANCER %s (%d)",
                  balancer->name, (int)getpid());
 
@@ -58,13 +58,13 @@ static proxy_worker *find_best_roundrobin(proxy_balancer *balancer,
         /* UGLY */
         ctx = apr_pcalloc(r->server->process->pconf, sizeof(rr_data));
         balancer->context = (void *)ctx;
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01117)
                  "proxy: Creating roundrobin ctx for BALANCER %s (%d)",
                  balancer->name, (int)getpid());
     } else {
         ctx = (rr_data *)balancer->context;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01118)
                  "proxy: roundrobin index: %d (%d)",
                  ctx->index, (int)getpid());
 
diff --git a/modules/proxy/mod_proxy.c b/modules/proxy/mod_proxy.c
index 16df3a1..24f552e 100644
--- a/modules/proxy/mod_proxy.c
+++ b/modules/proxy/mod_proxy.c
@@ -579,7 +579,7 @@ PROXY_DECLARE(int) ap_proxy_trans_match(request_rec *r, struct proxy_alias *ent,
             found = ap_pregsub(r->pool, real, use_uri, AP_MAX_REG_MATCH,
                     (use_uri == r->uri) ? regm : reg1);
             if (!found) {
-                ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(01135)
                               "Substitution in regular expression failed. "
                               "Replacement too long?");
                 return HTTP_INTERNAL_SERVER_ERROR;
@@ -624,7 +624,7 @@ PROXY_DECLARE(int) ap_proxy_trans_match(request_rec *r, struct proxy_alias *ent,
         /* We made a reducing transformation, so we can't safely use
          * unparsed_uri.  Safe fallback is to ignore nocanon.
          */
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01136)
                 "Unescaped URL path matched ProxyPass; ignoring unsafe nocanon");
     }
 
@@ -663,7 +663,7 @@ static int proxy_trans(request_rec *r)
 
     /* Check that the URI is valid. */
     if (!r->uri || r->uri[0] != '/') {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01137)
                      "Invalid URI in request %s", r->the_request);
         return HTTP_BAD_REQUEST;
     }
@@ -831,7 +831,7 @@ static int proxy_needsdomain(request_rec *r, const char *url, const char *domain
                            APR_URI_UNP_REVEALPASSWORD);
 
     apr_table_setn(r->headers_out, "Location", nuri);
-    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01138)
                   "Domain missing: %s sent to %s%s%s", r->uri,
                   apr_uri_unparse(r->pool, &r->parsed_uri,
                                   APR_URI_UNP_OMITUSERINFO),
@@ -917,7 +917,7 @@ static int proxy_handler(request_rec *r)
             apr_table_setn(r->notes, "error-notes",
                            "TRACE forbidden by server configuration");
             apr_table_setn(r->notes, "verbose-error-to", "*");
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01139)
                           "TRACE forbidden by server configuration");
             return HTTP_METHOD_NOT_ALLOWED;
         }
@@ -935,7 +935,7 @@ static int proxy_handler(request_rec *r)
             apr_table_setn(r->notes, "error-notes",
                            "TRACE with request body is not allowed");
             apr_table_setn(r->notes, "verbose-error-to", "*");
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01140)
                           "TRACE with request body is not allowed");
             return HTTP_REQUEST_ENTITY_TOO_LARGE;
         }
@@ -944,7 +944,7 @@ static int proxy_handler(request_rec *r)
     uri = r->filename + 6;
     p = strchr(uri, ':');
     if (p == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01141)
                       "proxy_handler no URL in %s", r->filename);
         return HTTP_BAD_REQUEST;
     }
@@ -1010,7 +1010,7 @@ static int proxy_handler(request_rec *r)
                                 strlen(ents[i].scheme)) == 0)) {
 
                     /* handle the scheme */
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01142)
                                   "Trying to run scheme_handler against proxy");
                     access_status = proxy_run_scheme_handler(r, worker,
                                                              conf, url,
@@ -1062,7 +1062,7 @@ static int proxy_handler(request_rec *r)
         */
 
         /* handle the scheme */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01143)
                       "Running scheme %s handler (attempt %d)",
                       scheme, attempts);
         AP_PROXY_RUN(r, worker, conf, url, attempts);
@@ -1104,7 +1104,7 @@ static int proxy_handler(request_rec *r)
              max_attempts > attempts++);
 
     if (DECLINED == access_status) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01144)
                       "No protocol handler was valid for the URL %s. "
                       "If you are using a DSO version of mod_proxy, make sure "
                       "the proxy submodules are included in the configuration "
@@ -1490,14 +1490,14 @@ static const char *
             PROXY_COPY_CONF_PARAMS(worker, conf);
         } else {
             reuse = 1;
-            ap_log_error(APLOG_MARK, APLOG_INFO, 0, cmd->server,
+            ap_log_error(APLOG_MARK, APLOG_INFO, 0, cmd->server, APLOGNO(01145)
                          "Sharing worker '%s' instead of creating new worker '%s'",
                          worker->s->name, new->real);
         }
 
         for (i = 0; i < arr->nelts; i++) {
             if (reuse) {
-                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(01146)
                              "Ignoring parameter '%s=%s' for worker '%s' because of worker sharing",
                              elts[i].key, elts[i].val, worker->s->name);
             } else {
@@ -1929,18 +1929,18 @@ static const char *add_member(cmd_parms *cmd, void *dummy, const char *arg)
     /* Try to find existing worker */
     worker = ap_proxy_get_worker(cmd->temp_pool, balancer, conf, name);
     if (!worker) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01147)
                      "Defining worker '%s' for balancer '%s'",
                      name, balancer->s->name);
         if ((err = ap_proxy_define_worker(cmd->pool, &worker, balancer, conf, name, 0)) != NULL)
             return apr_pstrcat(cmd->temp_pool, "BalancerMember ", err, NULL);
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, APLOGNO(01148)
                      "Defined worker '%s' for balancer '%s'",
                      worker->s->name, balancer->s->name);
         PROXY_COPY_CONF_PARAMS(worker, conf);
     } else {
         reuse = 1;
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, cmd->server, APLOGNO(01149)
                      "Sharing worker '%s' instead of creating new worker '%s'",
                      worker->s->name, name);
     }
@@ -1949,7 +1949,7 @@ static const char *add_member(cmd_parms *cmd, void *dummy, const char *arg)
     elts = (const apr_table_entry_t *)arr->elts;
     for (i = 0; i < arr->nelts; i++) {
         if (reuse) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(01150)
                          "Ignoring parameter '%s=%s' for worker '%s' because of worker sharing",
                          elts[i].key, elts[i].val, worker->s->name);
         } else {
diff --git a/modules/proxy/mod_proxy_ajp.c b/modules/proxy/mod_proxy_ajp.c
index 350ab4f..93cb153 100644
--- a/modules/proxy/mod_proxy_ajp.c
+++ b/modules/proxy/mod_proxy_ajp.c
@@ -50,7 +50,7 @@ static int proxy_ajp_canon(request_rec *r, char *url)
      */
     err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
     if (err) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "error parsing URL %s: %s",
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00867) "error parsing URL %s: %s",
                       url, err);
         return HTTP_BAD_REQUEST;
     }
@@ -208,7 +208,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
     status = ajp_send_header(conn->sock, r, maxsize, uri);
     if (status != APR_SUCCESS) {
         conn->close++;
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00868)
                       "request failed to %pI (%s)",
                       conn->worker->cp->addr,
                       conn->worker->s->hostname);
@@ -235,7 +235,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
     if (status != APR_SUCCESS) {
         /* We had a failure: Close connection to backend */
         conn->close++;
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00869)
                       "ajp_alloc_data_msg failed");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -245,7 +245,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
     tenc = apr_table_get(r->headers_in, "Transfer-Encoding");
     if (tenc && (strcasecmp(tenc, "chunked") == 0)) {
         /* The AJP protocol does not want body data yet */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "request is chunked");
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00870) "request is chunked");
     } else {
         /* Get client provided Content-Length header */
         content_length = get_content_length(r);
@@ -256,7 +256,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
         if (status != APR_SUCCESS) {
             /* We had a failure: Close connection to backend */
             conn->close++;
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00871)
                           "ap_get_brigade failed");
             apr_brigade_destroy(input_brigade);
             return HTTP_BAD_REQUEST;
@@ -264,11 +264,11 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
 
         /* have something */
         if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "APR_BUCKET_IS_EOS");
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00872) "APR_BUCKET_IS_EOS");
         }
 
         /* Try to send something */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00873)
                       "data to read (max %" APR_SIZE_T_FMT
                       " at %" APR_SIZE_T_FMT ")", bufsiz, msg->pos);
 
@@ -277,13 +277,13 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
             /* We had a failure: Close connection to backend */
             conn->close++;
             apr_brigade_destroy(input_brigade);
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00874)
                           "apr_brigade_flatten");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
         apr_brigade_cleanup(input_brigade);
 
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00875)
                       "got %" APR_SIZE_T_FMT " bytes of data", bufsiz);
         if (bufsiz > 0) {
             status = ajp_send_data_msg(conn->sock, msg, bufsiz);
@@ -292,7 +292,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                 /* We had a failure: Close connection to backend */
                 conn->close++;
                 apr_brigade_destroy(input_brigade);
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00876)
                               "send failed to %pI (%s)",
                               conn->worker->cp->addr,
                               conn->worker->s->hostname);
@@ -306,7 +306,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
             send_body = 1;
         }
         else if (content_length > 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00877)
                           "read zero bytes, expecting"
                           " %" APR_OFF_T_FMT " bytes",
                           content_length);
@@ -332,7 +332,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
         /* We had a failure: Close connection to backend */
         conn->close++;
         apr_brigade_destroy(input_brigade);
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00878)
                       "read response failed from %pI (%s)",
                       conn->worker->cp->addr,
                       conn->worker->s->hostname);
@@ -379,7 +379,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                         /* This is the end */
                         bufsiz = 0;
                         havebody = 0;
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00879)
                                       "APR_BUCKET_IS_EOS");
                     } else {
                         status = ap_get_brigade(r->input_filters, input_brigade,
@@ -387,7 +387,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                                                 APR_BLOCK_READ,
                                                 maxsize - AJP_HEADER_SZ);
                         if (status != APR_SUCCESS) {
-                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r,
+                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00880)
                                           "ap_get_brigade failed");
                             output_failed = 1;
                             break;
@@ -397,7 +397,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                                                      &bufsiz);
                         apr_brigade_cleanup(input_brigade);
                         if (status != APR_SUCCESS) {
-                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r,
+                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00881)
                                          "apr_brigade_flatten failed");
                             output_failed = 1;
                             break;
@@ -409,7 +409,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                     status = ajp_send_data_msg(conn->sock, msg, bufsiz);
                     ajp_msg_log(r, msg, "ajp_send_data_msg after CMD_AJP13_GET_BODY_CHUNK: ajp_ilink_send packet dump");
                     if (status != APR_SUCCESS) {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00882)
                                       "ajp_send_data_msg failed");
                         backend_failed = 1;
                         break;
@@ -420,7 +420,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                      * something is wrong TC asks for more body but we are
                      * already at the end of the body data
                      */
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00883)
                                   "ap_proxy_ajp_request error read after end");
                     backend_failed = 1;
                 }
@@ -431,7 +431,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                      * Backend already send us the headers.
                      */
                     backend_failed = 1;
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00884)
                                   "Backend sent headers twice.");
                     break;
                 }
@@ -446,7 +446,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                     if ((buf = apr_table_get(r->headers_out, wa))) {
                         apr_table_set(r->err_headers_out, wa, buf);
                     } else {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00885)
                                       "ap_proxy_ajp_request: origin server "
                                       "sent 401 without WWW-Authenticate header");
                     }
@@ -470,7 +470,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                                 APR_BRIGADE_INSERT_TAIL(output_brigade, e);
                             }
                             else {
-                                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00886)
                                               "Ignoring flush message "
                                               "received before headers");
                             }
@@ -509,7 +509,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                         if (headers_sent) {
                             if (ap_pass_brigade(r->output_filters,
                                                 output_brigade) != APR_SUCCESS) {
-                                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00887)
                                               "error processing body.%s",
                                               r->connection->aborted ?
                                               " Client aborted connection." : "");
@@ -538,7 +538,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                     APR_BRIGADE_INSERT_TAIL(output_brigade, e);
                     if (ap_pass_brigade(r->output_filters,
                                         output_brigade) != APR_SUCCESS) {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00888)
                                       "error processing end");
                         output_failed = 1;
                     }
@@ -578,7 +578,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                                  (ajp_msg_t **)&(conn->data));
         if (status != APR_SUCCESS) {
             backend_failed = 1;
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00889)
                           "ajp_read_header failed");
             break;
         }
@@ -593,7 +593,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
     apr_brigade_cleanup(output_brigade);
 
     if (backend_failed || output_failed) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00890)
                       "Processing of request failed backend: %i, "
                       "output: %i", backend_failed, output_failed);
         /* We had a failure: Close connection to backend */
@@ -604,7 +604,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
         }
     }
     else if (!request_ended) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00891)
                       "Processing of request didn't terminate cleanly");
         /* We had a failure: Close connection to backend */
         conn->close++;
@@ -619,7 +619,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
         conn->close++;
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00892)
                       "got response from %pI (%s)",
                       conn->worker->cp->addr,
                       conn->worker->s->hostname);
@@ -638,7 +638,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
     }
 
     if (backend_failed) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00893)
                       "dialog to %pI (%s) failed",
                       conn->worker->cp->addr,
                       conn->worker->s->hostname);
@@ -721,10 +721,10 @@ static int proxy_ajp_handler(request_rec *r, proxy_worker *worker,
 
 
     if (strncasecmp(url, "ajp:", 4) != 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "declining URL %s", url);
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00894) "declining URL %s", url);
         return DECLINED;
     }
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "serving URL %s", url);
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00895) "serving URL %s", url);
 
     /* create space for state information */
     status = ap_proxy_acquire_connection(scheme, &backend, worker,
@@ -754,7 +754,7 @@ static int proxy_ajp_handler(request_rec *r, proxy_worker *worker,
 
         /* Step Two: Make the Connection */
         if (ap_proxy_connect_backend(scheme, backend, worker, r->server)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00896)
                           "failed to make connection to backend: %s",
                           backend->hostname);
             status = HTTP_SERVICE_UNAVAILABLE;
@@ -773,7 +773,7 @@ static int proxy_ajp_handler(request_rec *r, proxy_worker *worker,
              */
             if (status != APR_SUCCESS) {
                 backend->close++;
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00897)
                               "cping/cpong failed to %pI (%s)",
                               worker->cp->addr, worker->s->hostname);
                 status = HTTP_SERVICE_UNAVAILABLE;
diff --git a/modules/proxy/mod_proxy_balancer.c b/modules/proxy/mod_proxy_balancer.c
index d88a8bb..0bfa8a4 100644
--- a/modules/proxy/mod_proxy_balancer.c
+++ b/modules/proxy/mod_proxy_balancer.c
@@ -77,7 +77,7 @@ static int proxy_balancer_canon(request_rec *r, char *url)
      */
     err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
     if (err) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01157)
                       "error parsing URL %s: %s",
                       url, err);
         return HTTP_BAD_REQUEST;
@@ -117,7 +117,7 @@ static void init_balancer_members(apr_pool_t *p, server_rec *s,
     for (i = 0; i < balancer->workers->nelts; i++) {
         int worker_is_initialized;
         proxy_worker *worker = *workers;
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01158)
                      "Looking at %s -> %s initialized?", balancer->s->name, worker->s->name);
         worker_is_initialized = PROXY_WORKER_IS_INITIALIZED(worker);
         if (!worker_is_initialized) {
@@ -278,7 +278,7 @@ static proxy_worker *find_session_route(proxy_balancer *balancer,
     /* Try to find the sticky route inside url */
     *route = get_path_param(r->pool, *url, balancer->s->sticky_path, balancer->s->scolonsep);
     if (*route) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01159)
                      "Found value %s for stickysession %s",
                      *route, balancer->s->sticky_path);
         *sticky_used =  balancer->s->sticky_path;
@@ -287,7 +287,7 @@ static proxy_worker *find_session_route(proxy_balancer *balancer,
         *route = get_cookie_param(r, balancer->s->sticky);
         if (*route) {
             *sticky_used =  balancer->s->sticky;
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01160)
                          "Found value %s for stickysession %s",
                          *route, balancer->s->sticky);
         }
@@ -299,7 +299,7 @@ static proxy_worker *find_session_route(proxy_balancer *balancer,
     if ((*route) && ((*route = strchr(*route, '.')) != NULL ))
         (*route)++;
     if ((*route) && (**route)) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "Found route %s", *route);
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01161) "Found route %s", *route);
         /* We have a route in path or in cookie
          * Find the worker that has this route defined.
          */
@@ -310,7 +310,7 @@ static proxy_worker *find_session_route(proxy_balancer *balancer,
              * the route supplied by the client.
              */
             apr_table_setn(r->subprocess_env, "BALANCER_ROUTE_CHANGED", "1");
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01162)
                           "Route changed from %s to %s",
                           *route, worker->s->route);
         }
@@ -327,7 +327,7 @@ static proxy_worker *find_best_worker(proxy_balancer *balancer,
     apr_status_t rv;
 
     if ((rv = PROXY_THREAD_LOCK(balancer)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01163)
                       "%s: Lock failed for find_best_worker()",
                       balancer->s->name);
         return NULL;
@@ -339,7 +339,7 @@ static proxy_worker *find_best_worker(proxy_balancer *balancer,
         candidate->s->elected++;
 
     if ((rv = PROXY_THREAD_UNLOCK(balancer)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01164)
                       "%s: Unlock failed for find_best_worker()",
                       balancer->s->name);
     }
@@ -430,7 +430,7 @@ static void force_recovery(proxy_balancer *balancer, server_rec *s)
         for (i = 0; i < balancer->workers->nelts; i++, worker++) {
             ++(*worker)->s->retries;
             (*worker)->s->status &= ~PROXY_WORKER_IN_ERROR;
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01165)
                          "%s: Forcing recovery for worker (%s)",
                          balancer->s->name, (*worker)->s->hostname);
         }
@@ -462,7 +462,7 @@ static int proxy_balancer_pre_request(proxy_worker **worker,
      * XXX: perhaps we need the process lock here
      */
     if ((rv = PROXY_THREAD_LOCK(*balancer)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01166)
                       "%s: Lock failed for pre_request", (*balancer)->s->name);
         return DECLINED;
     }
@@ -523,11 +523,11 @@ static int proxy_balancer_pre_request(proxy_worker **worker,
             workers++;
         }
         if (member_of) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01167)
                           "%s: All workers are in error state for route (%s)",
                           (*balancer)->s->name, route);
             if ((rv = PROXY_THREAD_UNLOCK(*balancer)) != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01168)
                               "%s: Unlock failed for pre_request",
                               (*balancer)->s->name);
             }
@@ -536,7 +536,7 @@ static int proxy_balancer_pre_request(proxy_worker **worker,
     }
 
     if ((rv = PROXY_THREAD_UNLOCK(*balancer)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01169)
                       "%s: Unlock failed for pre_request",
                       (*balancer)->s->name);
     }
@@ -544,11 +544,11 @@ static int proxy_balancer_pre_request(proxy_worker **worker,
         runtime = find_best_worker(*balancer, r);
         if (!runtime) {
             if ((*balancer)->workers->nelts) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01170)
                               "%s: All workers are in error state",
                               (*balancer)->s->name);
             } else {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01171)
                               "%s: No workers in balancer",
                               (*balancer)->s->name);
             }
@@ -596,7 +596,7 @@ static int proxy_balancer_pre_request(proxy_worker **worker,
         apr_table_setn(r->subprocess_env,
                        "BALANCER_SESSION_ROUTE", route);
     }
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01172)
                   "%s: worker (%s) rewritten to %s",
                   (*balancer)->s->name, (*worker)->s->name, *url);
 
@@ -612,7 +612,7 @@ static int proxy_balancer_post_request(proxy_worker *worker,
     apr_status_t rv;
 
     if ((rv = PROXY_THREAD_LOCK(balancer)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01173)
                       "%s: Lock failed for post_request",
                       balancer->s->name);
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -623,7 +623,7 @@ static int proxy_balancer_post_request(proxy_worker *worker,
         for (i = 0; i < balancer->errstatuses->nelts; i++) {
             int val = ((int *)balancer->errstatuses->elts)[i];
             if (r->status == val) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01174)
                               "%s:  Forcing recovery for worker (%s), "
                               "failonstatus %d",
                               balancer->s->name, worker->s->name, val);
@@ -635,10 +635,10 @@ static int proxy_balancer_post_request(proxy_worker *worker,
     }
 
     if ((rv = PROXY_THREAD_UNLOCK(balancer)) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01175)
                       "%s: Unlock failed for post_request", balancer->s->name);
     }
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01176)
                   "proxy_balancer_post_request for (%s)", balancer->s->name);
 
     if (worker && worker->s->busy)
@@ -719,7 +719,7 @@ static int balancer_post_config(apr_pool_t *pconf, apr_pool_t *plog,
     storage = ap_lookup_provider(AP_SLOTMEM_PROVIDER_GROUP, "shared",
                                  AP_SLOTMEM_PROVIDER_VERSION);
     if (!storage) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01177)
                      "ap_lookup_provider %s failed: is mod_slotmem_shm loaded??",
                      AP_SLOTMEM_PROVIDER_GROUP);
         return !OK;
@@ -738,7 +738,7 @@ static int balancer_post_config(apr_pool_t *pconf, apr_pool_t *plog,
 
         if (conf->balancers->nelts) {
             conf->max_balancers = conf->balancers->nelts + conf->bgrowth;
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "Doing balancers create: %d, %d (%d)",
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01178) "Doing balancers create: %d, %d (%d)",
                          (int)ALIGNED_PROXY_BALANCER_SHARED_SIZE,
                          (int)conf->balancers->nelts, conf->max_balancers);
 
@@ -746,7 +746,7 @@ static int balancer_post_config(apr_pool_t *pconf, apr_pool_t *plog,
                                  ALIGNED_PROXY_BALANCER_SHARED_SIZE,
                                  conf->max_balancers, AP_SLOTMEM_TYPE_PREGRAB, pconf);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, "balancer slotmem_create failed");
+                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01179) "balancer slotmem_create failed");
                 return !OK;
             }
             conf->bslot = new;
@@ -767,7 +767,7 @@ static int balancer_post_config(apr_pool_t *pconf, apr_pool_t *plog,
             rv = ap_global_mutex_create(&(balancer->gmutex), NULL, balancer_mutex_type,
                                         balancer->s->sname, s, pconf, 0);
             if (rv != APR_SUCCESS || !balancer->gmutex) {
-                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
+                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01180)
                              "mutex creation of %s : %s failed", balancer_mutex_type,
                              balancer->s->sname);
                 return HTTP_INTERNAL_SERVER_ERROR;
@@ -778,21 +778,21 @@ static int balancer_post_config(apr_pool_t *pconf, apr_pool_t *plog,
 
             /* setup shm for balancers */
             if ((rv = storage->grab(conf->bslot, &index)) != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, "balancer slotmem_grab failed");
+                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01181) "balancer slotmem_grab failed");
                 return !OK;
 
             }
             if ((rv = storage->dptr(conf->bslot, index, (void *)&bshm)) != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, "balancer slotmem_dptr failed");
+                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01182) "balancer slotmem_dptr failed");
                 return !OK;
             }
             if ((rv = ap_proxy_share_balancer(balancer, bshm, index)) != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, "Cannot share balancer");
+                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01183) "Cannot share balancer");
                 return !OK;
             }
 
             /* create slotmem slots for workers */
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "Doing workers create: %s (%s), %d, %d",
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01184) "Doing workers create: %s (%s), %d, %d",
                          balancer->s->name, balancer->s->sname,
                          (int)ALIGNED_PROXY_WORKER_SHARED_SIZE,
                          (int)balancer->max_workers);
@@ -801,7 +801,7 @@ static int balancer_post_config(apr_pool_t *pconf, apr_pool_t *plog,
                                  ALIGNED_PROXY_WORKER_SHARED_SIZE,
                                  balancer->max_workers, AP_SLOTMEM_TYPE_PREGRAB, pconf);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, "worker slotmem_create failed");
+                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01185) "worker slotmem_create failed");
                 return !OK;
             }
             balancer->wslot = new;
@@ -817,16 +817,16 @@ static int balancer_post_config(apr_pool_t *pconf, apr_pool_t *plog,
 
                 worker = *workers;
                 if ((rv = storage->grab(balancer->wslot, &index)) != APR_SUCCESS) {
-                    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, "worker slotmem_grab failed");
+                    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01186) "worker slotmem_grab failed");
                     return !OK;
 
                 }
                 if ((rv = storage->dptr(balancer->wslot, index, (void *)&shm)) != APR_SUCCESS) {
-                    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, "worker slotmem_dptr failed");
+                    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01187) "worker slotmem_dptr failed");
                     return !OK;
                 }
                 if ((rv = ap_proxy_share_worker(worker, shm, index)) != APR_SUCCESS) {
-                    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, "Cannot share worker");
+                    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(01188) "Cannot share worker");
                     return !OK;
                 }
                 worker->s->updated = tstamp;
@@ -930,13 +930,13 @@ static int balancer_handler(request_rec *r)
     balancer = (proxy_balancer *)conf->balancers->elts;
     for (i = 0; i < conf->balancers->nelts; i++, balancer++) {
         if ((rv = PROXY_THREAD_LOCK(balancer)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01189)
                           "%s: Lock failed for balancer_handler",
                           balancer->s->name);
         }
         ap_proxy_sync_balancer(balancer, r->server, conf);
         if ((rv = PROXY_THREAD_UNLOCK(balancer)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01190)
                           "%s: Unlock failed for balancer_handler",
                           balancer->s->name);
         }
@@ -944,7 +944,7 @@ static int balancer_handler(request_rec *r)
 
     if (r->args && (r->method_number == M_GET)) {
         const char *allowed[] = { "w", "b", "nonce", NULL };
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "parsing r->args");
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01191) "parsing r->args");
 
         push2table(r->args, params, allowed, r->pool);
     }
@@ -991,7 +991,7 @@ static int balancer_handler(request_rec *r)
         const char *val;
         int was_usable = PROXY_WORKER_IS_USABLE(wsel);
 
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "settings worker params");
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01192) "settings worker params");
 
         if ((val = apr_table_get(params, "w_lf"))) {
             int ival = atoi(val);
@@ -1041,7 +1041,7 @@ static int balancer_handler(request_rec *r)
     if (bsel && ok2change) {
         const char *val;
         int ival;
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01193)
                       "settings balancer params");
         if ((val = apr_table_get(params, "b_lbm"))) {
             if ((strlen(val) < (sizeof(bsel->s->lbpname)-1)) &&
@@ -1096,7 +1096,7 @@ static int balancer_handler(request_rec *r)
             nworker = ap_proxy_get_worker(conf->pool, bsel, conf, val);
             if (!nworker && storage->num_free_slots(bsel->wslot)) {
                 if ((rv = PROXY_GLOBAL_LOCK(bsel)) != APR_SUCCESS) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01194)
                                   "%s: Lock failed for adding worker",
                                   bsel->s->name);
                 }
@@ -1106,40 +1106,40 @@ static int balancer_handler(request_rec *r)
                     proxy_worker_shared *shm;
                     PROXY_COPY_CONF_PARAMS(nworker, conf);
                     if ((rv = storage->grab(bsel->wslot, &index)) != APR_SUCCESS) {
-                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r, APLOGNO(01195)
                                       "worker slotmem_grab failed");
                         if ((rv = PROXY_GLOBAL_UNLOCK(bsel)) != APR_SUCCESS) {
-                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01196)
                                           "%s: Unlock failed for adding worker",
                                           bsel->s->name);
                         }
                         return HTTP_BAD_REQUEST;
                     }
                     if ((rv = storage->dptr(bsel->wslot, index, (void *)&shm)) != APR_SUCCESS) {
-                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r, APLOGNO(01197)
                                       "worker slotmem_dptr failed");
                         if ((rv = PROXY_GLOBAL_UNLOCK(bsel)) != APR_SUCCESS) {
-                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01198)
                                           "%s: Unlock failed for adding worker",
                                           bsel->s->name);
                         }
                         return HTTP_BAD_REQUEST;
                     }
                     if ((rv = ap_proxy_share_worker(nworker, shm, index)) != APR_SUCCESS) {
-                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r, APLOGNO(01199)
                                       "Cannot share worker");
                         if ((rv = PROXY_GLOBAL_UNLOCK(bsel)) != APR_SUCCESS) {
-                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01200)
                                           "%s: Unlock failed for adding worker",
                                           bsel->s->name);
                         }
                         return HTTP_BAD_REQUEST;
                     }
                     if ((rv = ap_proxy_initialize_worker(nworker, r->server, conf->pool)) != APR_SUCCESS) {
-                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_EMERG, rv, r, APLOGNO(01201)
                                       "Cannot init worker");
                         if ((rv = PROXY_GLOBAL_UNLOCK(bsel)) != APR_SUCCESS) {
-                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01202)
                                           "%s: Unlock failed for adding worker",
                                           bsel->s->name);
                         }
@@ -1151,7 +1151,7 @@ static int balancer_handler(request_rec *r)
                     ap_proxy_set_wstatus('D', 1, nworker);
                 }
                 if ((rv = PROXY_GLOBAL_UNLOCK(bsel)) != APR_SUCCESS) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01203)
                                   "%s: Unlock failed for adding worker",
                                   bsel->s->name);
                 }
@@ -1162,7 +1162,7 @@ static int balancer_handler(request_rec *r)
     }
 
     action = ap_construct_url(r->pool, r->uri, r);
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "genning page");
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01204) "genning page");
 
     if (apr_table_get(params, "xml")) {
         ap_set_content_type(r, "text/xml");
@@ -1419,7 +1419,7 @@ static void balancer_child_init(apr_pool_t *p, server_rec *s)
             unsigned int num;
             storage->attach(&(conf->bslot), conf->id, &size, &num, p);
             if (!conf->bslot) {
-                ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, "slotmem_attach failed");
+                ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01205) "slotmem_attach failed");
                 exit(1); /* Ugly, but what else? */
             }
         }
@@ -1429,7 +1429,7 @@ static void balancer_child_init(apr_pool_t *p, server_rec *s)
             rv = ap_proxy_initialize_balancer(balancer, s, p);
 
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(01206)
                              "Failed to init balancer %s in child",
                              balancer->s->name);
                 exit(1); /* Ugly, but what else? */
diff --git a/modules/proxy/mod_proxy_connect.c b/modules/proxy/mod_proxy_connect.c
index c60bdcf..9a14eb7 100644
--- a/modules/proxy/mod_proxy_connect.c
+++ b/modules/proxy/mod_proxy_connect.c
@@ -164,7 +164,7 @@ static int proxy_connect_transfer(request_rec *r, conn_rec *c_i, conn_rec *c_o,
 #ifdef DEBUGGING
             len = -1;
             apr_brigade_length(bb, 0, &len);
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01016)
                           "read %" APR_OFF_T_FMT
                           " bytes from %s", len, name);
 #endif
@@ -173,12 +173,12 @@ static int proxy_connect_transfer(request_rec *r, conn_rec *c_i, conn_rec *c_o,
                 ap_fflush(c_o->output_filters, bb);
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01017)
                               "error on %s - ap_pass_brigade",
                               name);
             }
         } else if (!APR_STATUS_IS_EAGAIN(rv)) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(01018)
                           "error on %s - ap_get_brigade",
                           name);
         }
@@ -243,7 +243,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
                                          NULL));
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01019)
                   "connecting %s to %s:%d", url, uri.hostname, uri.port);
 
     /* do a DNS lookup for the destination host */
@@ -326,7 +326,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
 
     if ((rv = apr_pollset_create(&pollset, 2, r->pool, 0)) != APR_SUCCESS) {
         apr_socket_close(sock);
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01020)
                       "error apr_pollset_create()");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -353,7 +353,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
                                         c->id, c->sbh, c->bucket_alloc);
     if (!backconn) {
         /* peer reset */
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01021)
                       "an error occurred creating a new connection "
                       "to %pI (%s)", connect_addr, connectname);
         apr_socket_close(sock);
@@ -363,7 +363,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
     rc = ap_run_pre_connection(backconn, sock);
     if (rc != OK && rc != DONE) {
         backconn->aborted = 1;
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01022)
                       "pre_connection setup failed (%d)", rc);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -435,11 +435,11 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
                 continue;
             }
             apr_socket_close(sock);
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "error apr_poll()");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01023) "error apr_poll()");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
 #ifdef DEBUGGING
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01024)
                       "woke from poll(), i=%d", pollcnt);
 #endif
 
@@ -450,7 +450,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
                 pollevent = cur->rtnevents;
                 if (pollevent & APR_POLLIN) {
 #ifdef DEBUGGING
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01025)
                                   "sock was readable");
 #endif
                     rv = proxy_connect_transfer(r, backconn, c, bb, "sock");
@@ -458,7 +458,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
                 else if ((pollevent & APR_POLLERR)
                          || (pollevent & APR_POLLHUP)) {
                          rv = APR_EPIPE;
-                         ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r,
+                         ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(01026)
                                        "err/hup on backconn");
                 }
                 if (rv != APR_SUCCESS)
@@ -468,7 +468,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
                 pollevent = cur->rtnevents;
                 if (pollevent & APR_POLLIN) {
 #ifdef DEBUGGING
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01027)
                                   "client was readable");
 #endif
                     rv = proxy_connect_transfer(r, c, backconn, bb, "client");
@@ -476,7 +476,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
             }
             else {
                 rv = APR_EBADF;
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01028)
                               "unknown socket in pollset");
             }
 
diff --git a/modules/proxy/mod_proxy_express.c b/modules/proxy/mod_proxy_express.c
index 2d874f9..a7abd6b 100644
--- a/modules/proxy/mod_proxy_express.c
+++ b/modules/proxy/mod_proxy_express.c
@@ -122,13 +122,13 @@ static int xlate_name(request_rec *r)
         return DECLINED;
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "proxy_express: Enabled");
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01001) "proxy_express: Enabled");
     if (!sconf->dbmfile || (r->filename && strncmp(r->filename, "proxy:", 6) == 0)) {
         /* it should be go on as an internal proxy request */
         return DECLINED;
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01002)
                   "proxy_express: Opening DBM file: %s (%s)",
                   sconf->dbmfile, sconf->dbmtype);
     rv = apr_dbm_open_ex(&db, sconf->dbmtype, sconf->dbmfile, APR_DBM_READONLY,
@@ -138,7 +138,7 @@ static int xlate_name(request_rec *r)
     }
 
     name = ap_get_server_name(r);
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01003)
                   "proxy_express: looking for %s", name);
     key.dptr = (char *)name;
     key.dsize = strlen(key.dptr);
@@ -154,13 +154,13 @@ static int xlate_name(request_rec *r)
         return DECLINED;
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01004)
                   "proxy_express: found %s -> %s", name, backend);
     r->filename = apr_pstrcat(r->pool, "proxy:", backend, r->uri, NULL);
     r->handler = "proxy-server";
     r->proxyreq = PROXYREQ_REVERSE;
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01005)
                   "proxy_express: rewritten as: %s", r->filename);
 
     ralias = (struct proxy_alias *)dconf->raliases->elts;
@@ -182,7 +182,7 @@ static int xlate_name(request_rec *r)
 
     /* Didn't find one... add it */
     if (!ralias) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01006)
                       "proxy_express: adding PPR entry");
         ralias = apr_array_push(dconf->raliases);
         ralias->fake = "/";
diff --git a/modules/proxy/mod_proxy_fcgi.c b/modules/proxy/mod_proxy_fcgi.c
index b8d9b84..3d08f51 100644
--- a/modules/proxy/mod_proxy_fcgi.c
+++ b/modules/proxy/mod_proxy_fcgi.c
@@ -91,7 +91,7 @@ static int proxy_fcgi_canon(request_rec *r, char *url)
 
     err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
     if (err) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01059)
                       "error parsing URL %s: %s", url, err);
         return HTTP_BAD_REQUEST;
     }
@@ -116,13 +116,13 @@ static int proxy_fcgi_canon(request_rec *r, char *url)
     r->filename = apr_pstrcat(r->pool, "proxy:fcgi://", host, sport, "/",
                               path, NULL);
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01060)
                   "set r->filename to %s", r->filename);
 
     if (apr_table_get(r->subprocess_env, "proxy-fcgi-pathinfo")) {
         r->path_info = apr_pstrcat(r->pool, "/", path, NULL);
 
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01061)
                       "set r->path_info to %s", r->path_info);
     }
 
@@ -317,7 +317,7 @@ static apr_status_t send_environment(proxy_conn_rec *conn, request_rec *r,
         vallen = strlen(elts[i].val);
 
 #ifdef FCGI_DUMP_ENV_VARS
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01062)
                       "sending env var '%s' value '%s'",
                       elts[i].key, elts[i].val);
 #endif
@@ -333,7 +333,7 @@ static apr_status_t send_environment(proxy_conn_rec *conn, request_rec *r,
 
         /* The cast of bodylen is safe since FCGI_MAX_ENV_SIZE is for sure an int */
         if (envlen > FCGI_MAX_ENV_SIZE) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01063)
                           "truncating environment to %d bytes and %d elements",
                           (int)bodylen, i);
             break;
@@ -499,7 +499,7 @@ static void dump_header_to_log(request_rec *r, unsigned char fheader[],
         if (i >= 20) {
             i = 0;
 
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01064)
                           "HEADER: %s %s", asc_line, hex_line);
 
             memset(asc_line, 0, sizeof(asc_line));
@@ -534,11 +534,11 @@ static void dump_header_to_log(request_rec *r, unsigned char fheader[],
     }
 
     if (i != 1) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "HEADER: %s %s",
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01065) "HEADER: %s %s",
                       asc_line, hex_line);
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "HEADER: -EOH-");
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01066) "HEADER: -EOH-");
 #endif
 }
 
@@ -671,7 +671,7 @@ static apr_status_t dispatch(proxy_conn_rec *conn, proxy_dir_conf *conf,
             dump_header_to_log(r, farray, readbuflen);
 
             if (readbuflen != FCGI_HEADER_LEN) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01067)
                               "Failed to read entire header "
                               "got %" APR_SIZE_T_FMT " wanted %d",
                               readbuflen, FCGI_HEADER_LEN);
@@ -682,7 +682,7 @@ static apr_status_t dispatch(proxy_conn_rec *conn, proxy_dir_conf *conf,
             fcgi_header_from_array(&header, farray);
 
             if (header.version != FCGI_VERSION) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01068)
                               "Got bogus version %d", (int) header.version);
                 rv = APR_EINVAL;
                 break;
@@ -694,7 +694,7 @@ static apr_status_t dispatch(proxy_conn_rec *conn, proxy_dir_conf *conf,
             rid |= header.requestIdB0;
 
             if (rid != request_id) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01069)
                               "Got bogus rid %d, expected %d",
                               rid, request_id);
                 rv = APR_EINVAL;
@@ -749,7 +749,7 @@ recv_again:
                                 tmp_b = apr_bucket_eos_create(c->bucket_alloc);
                                 APR_BRIGADE_INSERT_TAIL(ob, tmp_b);
                                 ap_pass_brigade(r->output_filters, ob);
-                                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01070)
                                               "Error parsing script headers");
                                 r->status = status;
                                 rv = APR_EINVAL;
@@ -828,7 +828,7 @@ recv_again:
             case FCGI_STDERR:
                 /* TODO: Should probably clean up this logging a bit... */
                 if (clen) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01071)
                                   "Got error '%s'", readbuf);
                 }
 
@@ -843,7 +843,7 @@ recv_again:
                 break;
 
             default:
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01072)
                               "Got bogus record %d", type);
                 break;
             }
@@ -890,7 +890,7 @@ static int fcgi_do_request(apr_pool_t *p, request_rec *r,
     /* Step 1: Send FCGI_BEGIN_REQUEST */
     rv = send_begin_request(conn, request_id);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01073)
                       "Failed Writing Request to %s:", server_portstr);
         conn->close = 1;
         return HTTP_SERVICE_UNAVAILABLE;
@@ -899,7 +899,7 @@ static int fcgi_do_request(apr_pool_t *p, request_rec *r,
     /* Step 2: Send Environment via FCGI_PARAMS */
     rv = send_environment(conn, r, request_id);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01074)
                       "Failed writing Environment to %s:", server_portstr);
         conn->close = 1;
         return HTTP_SERVICE_UNAVAILABLE;
@@ -908,7 +908,7 @@ static int fcgi_do_request(apr_pool_t *p, request_rec *r,
     /* Step 3: Read records from the back end server and handle them. */
     rv = dispatch(conn, conf, r, request_id);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01075)
                       "Error dispatching request to %s:", server_portstr);
         conn->close = 1;
         return HTTP_SERVICE_UNAVAILABLE;
@@ -939,7 +939,7 @@ static int proxy_fcgi_handler(request_rec *r, proxy_worker *worker,
 
     apr_uri_t *uri = apr_palloc(r->pool, sizeof(*uri));
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01076)
                   "url: %s proxyname: %s proxyport: %d",
                  url, proxyname, proxyport);
 
@@ -947,11 +947,11 @@ static int proxy_fcgi_handler(request_rec *r, proxy_worker *worker,
         url += 5;
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "declining URL %s", url);
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01077) "declining URL %s", url);
         return DECLINED;
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "serving URL %s", url);
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01078) "serving URL %s", url);
 
     /* Create space for state information */
     if (! backend) {
@@ -985,7 +985,7 @@ static int proxy_fcgi_handler(request_rec *r, proxy_worker *worker,
 
     /* Step Two: Make the Connection */
     if (ap_proxy_connect_backend(FCGI_SCHEME, backend, worker, r->server)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01079)
                       "failed to make connection to backend: %s",
                       backend->hostname);
         status = HTTP_SERVICE_UNAVAILABLE;
diff --git a/modules/proxy/mod_proxy_fdpass.c b/modules/proxy/mod_proxy_fdpass.c
index 83b0e98..26a7b13 100644
--- a/modules/proxy/mod_proxy_fdpass.c
+++ b/modules/proxy/mod_proxy_fdpass.c
@@ -49,7 +49,7 @@ static int proxy_fdpass_canon(request_rec *r, char *url)
 
     r->filename = apr_pstrcat(r->pool, "proxy:fd://", path, NULL);
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01151)
                   "set r->filename to %s", r->filename);
     return OK;
 }
@@ -195,7 +195,7 @@ static int proxy_fdpass_handler(request_rec *r, proxy_worker *worker,
     rv = get_socket_from_path(r->pool, url, &sock);
 
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01152)
                       "Failed to connect to '%s'", url);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -208,7 +208,7 @@ static int proxy_fdpass_handler(request_rec *r, proxy_worker *worker,
                                                        flush_method, "0");
 
         if (!flush) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01153)
                           "Unable to find configured flush provider '%s'",
                           flush_method);
             return HTTP_INTERNAL_SERVER_ERROR;
@@ -224,7 +224,7 @@ static int proxy_fdpass_handler(request_rec *r, proxy_worker *worker,
 
     rv = send_socket(r->pool, sock, clientsock);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "send_socket failed:");
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01154) "send_socket failed:");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
@@ -237,7 +237,7 @@ static int proxy_fdpass_handler(request_rec *r, proxy_worker *worker,
         rv = apr_socket_create(&dummy, APR_INET, SOCK_STREAM, APR_PROTO_TCP,
                                r->connection->pool);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01155)
                           "failed to create dummy socket");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -264,7 +264,7 @@ static int standard_flush(request_rec *r)
     status = ap_pass_brigade(r->output_filters, bb);
 
     if (status != OK) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01156)
                       "ap_pass_brigade failed:");
         return status;
     }
diff --git a/modules/proxy/mod_proxy_ftp.c b/modules/proxy/mod_proxy_ftp.c
index e7ee166..c57d7c0 100644
--- a/modules/proxy/mod_proxy_ftp.c
+++ b/modules/proxy/mod_proxy_ftp.c
@@ -614,7 +614,7 @@ static apr_status_t proxy_send_dir_filter(ap_filter_t *f,
             filename = strrchr(ctx->buffer, ' ');
             if (filename == NULL) {
                 /* Line is broken.  Ignore it. */
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01034)
                               "proxy_ftp: could not parse line %s",
                               ctx->buffer);
                 /* erase buffer for next time around */
@@ -844,7 +844,7 @@ static int ftp_unauthorized(request_rec *r, int log_it)
      * guessing attempts)
      */
     if (log_it)
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01035)
                       "missing or failed auth to %s",
                       apr_uri_unparse(r->pool,
                                  &r->parsed_uri, APR_URI_UNP_OMITPATHINFO));
@@ -1030,13 +1030,13 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
         password = "apache-proxy@";
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01036)
                   "connecting %s to %s:%d", url, connectname, connectport);
 
     if (worker->s->is_address_reusable) {
         if (!worker->cp->addr) {
             if ((err = PROXY_THREAD_LOCK(worker->balancer)) != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, err, r, "lock");
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, err, r, APLOGNO(01037) "lock");
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
         }
@@ -1055,7 +1055,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
     if (worker->s->is_address_reusable && !worker->cp->addr) {
         worker->cp->addr = connect_addr;
         if ((uerr = PROXY_THREAD_UNLOCK(worker->balancer)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, uerr, r, "unlock");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, uerr, r, APLOGNO(01038) "unlock");
         }
     }
     /*
@@ -1099,7 +1099,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
 
 
     if (ap_proxy_connect_backend("FTP", backend, worker, r->server)) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01039)
                       "an error occurred creating a new connection to %pI (%s)",
                       connect_addr, connectname);
         proxy_ftp_cleanup(r, backend);
@@ -1338,7 +1338,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                               "EPSV contacting remote host on port %d", data_port);
 
                 if ((rv = apr_socket_create(&data_sock, connect_addr->family, SOCK_STREAM, 0, r->pool)) != APR_SUCCESS) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01040)
                                   "error creating EPSV socket");
                     proxy_ftp_cleanup(r, backend);
                     return HTTP_INTERNAL_SERVER_ERROR;
@@ -1347,14 +1347,14 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                 if (conf->recv_buffer_size > 0
                         && (rv = apr_socket_opt_set(data_sock, APR_SO_RCVBUF,
                                                     conf->recv_buffer_size))) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01041)
                                   "apr_socket_opt_set(SO_RCVBUF): Failed to "
                                   "set ProxyReceiveBufferSize, using default");
                 }
 
                 rv = apr_socket_opt_set(data_sock, APR_TCP_NODELAY, 1);
                 if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01042)
                                   "apr_socket_opt_set(APR_TCP_NODELAY): "
                                   "Failed to set");
                 }
@@ -1365,7 +1365,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                 apr_sockaddr_info_get(&epsv_addr, data_ip, connect_addr->family, data_port, 0, p);
                 rv = apr_socket_connect(data_sock, epsv_addr);
                 if (rv != APR_SUCCESS) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01043)
                                   "EPSV attempt to connect to %pI failed - "
                                   "Firewall/NAT?", epsv_addr);
                     return ftp_proxyerror(r, backend, HTTP_BAD_GATEWAY, apr_psprintf(r->pool,
@@ -1424,12 +1424,12 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
 
                 apr_sockaddr_t *pasv_addr;
                 apr_port_t pasvport = (p1 << 8) + p0;
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01044)
                               "PASV contacting host %d.%d.%d.%d:%d",
                               h3, h2, h1, h0, pasvport);
 
                 if ((rv = apr_socket_create(&data_sock, connect_addr->family, SOCK_STREAM, 0, r->pool)) != APR_SUCCESS) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01045)
                                   "error creating PASV socket");
                     proxy_ftp_cleanup(r, backend);
                     return HTTP_INTERNAL_SERVER_ERROR;
@@ -1438,13 +1438,13 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                 if (conf->recv_buffer_size > 0
                         && (rv = apr_socket_opt_set(data_sock, APR_SO_RCVBUF,
                                                     conf->recv_buffer_size))) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01046)
                                   "apr_socket_opt_set(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
                 }
 
                 rv = apr_socket_opt_set(data_sock, APR_TCP_NODELAY, 1);
                 if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01047)
                                   "apr_socket_opt_set(APR_TCP_NODELAY): "
                                   "Failed to set");
                 }
@@ -1453,7 +1453,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                 apr_sockaddr_info_get(&pasv_addr, apr_psprintf(p, "%d.%d.%d.%d", h3, h2, h1, h0), connect_addr->family, pasvport, 0, p);
                 rv = apr_socket_connect(data_sock, pasv_addr);
                 if (rv != APR_SUCCESS) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01048)
                                   "PASV attempt to connect to %pI failed - Firewall/NAT?", pasv_addr);
                     return ftp_proxyerror(r, backend, HTTP_BAD_GATEWAY, apr_psprintf(r->pool,
                                                                            "PASV attempt to connect to %pI failed - firewall/NAT?", pasv_addr));
@@ -1474,7 +1474,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
         unsigned int h0, h1, h2, h3, p0, p1;
 
         if ((rv = apr_socket_create(&local_sock, connect_addr->family, SOCK_STREAM, 0, r->pool)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01049)
                           "error creating local socket");
             proxy_ftp_cleanup(r, backend);
             return HTTP_INTERNAL_SERVER_ERROR;
@@ -1486,7 +1486,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
         if ((rv = apr_socket_opt_set(local_sock, APR_SO_REUSEADDR, one))
                 != APR_SUCCESS) {
 #ifndef _OSD_POSIX              /* BS2000 has this option "always on" */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01050)
                           "error setting reuseaddr option");
             proxy_ftp_cleanup(r, backend);
             return HTTP_INTERNAL_SERVER_ERROR;
@@ -1496,7 +1496,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
         apr_sockaddr_info_get(&local_addr, local_ip, APR_UNSPEC, local_port, 0, r->pool);
 
         if ((rv = apr_socket_bind(local_sock, local_addr)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01051)
                           "error binding to ftp data socket %pI", local_addr);
             proxy_ftp_cleanup(r, backend);
             return HTTP_INTERNAL_SERVER_ERROR;
@@ -1504,7 +1504,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
 
         /* only need a short queue */
         if ((rv = apr_socket_listen(local_sock, 2)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01052)
                           "error listening to ftp data socket %pI", local_addr);
             proxy_ftp_cleanup(r, backend);
             return HTTP_INTERNAL_SERVER_ERROR;
@@ -1849,7 +1849,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                 break;
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01053)
                               "failed to accept data connection");
                 proxy_ftp_cleanup(r, backend);
                 return HTTP_BAD_GATEWAY;
@@ -1865,7 +1865,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
          * the peer reset the connection already; ap_run_create_connection() closed
          * the socket
          */
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01054)
                       "an error occurred creating the transfer connection");
         proxy_ftp_cleanup(r, backend);
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -1879,7 +1879,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
     /* set up the connection filters */
     rc = ap_run_pre_connection(data, data_sock);
     if (rc != OK && rc != DONE) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01055)
                       "pre_connection setup failed (%d)", rc);
         data->aborted = 1;
         proxy_ftp_cleanup(r, backend);
@@ -1917,7 +1917,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
             {
                 apr_off_t readbytes;
                 apr_brigade_length(bb, 0, &readbytes);
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server, APLOGNO(01056)
                              "proxy: readbytes: %#x", readbytes);
             }
 #endif
@@ -1939,7 +1939,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                     apr_socket_close(data_sock);
                 }
                 data_sock = NULL;
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01057)
                               "data connection closed");
                 /* signal that we must leave */
                 finish = TRUE;
@@ -1972,7 +1972,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
     if (data_sock) {
         ap_flush_conn(data);
         apr_socket_close(data_sock);
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "data connection closed");
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01058) "data connection closed");
     }
 
     /* Retrieve the final response for the RETR or LIST commands */
diff --git a/modules/proxy/mod_proxy_http.c b/modules/proxy/mod_proxy_http.c
index b3186b5..98451ef 100644
--- a/modules/proxy/mod_proxy_http.c
+++ b/modules/proxy/mod_proxy_http.c
@@ -62,7 +62,7 @@ static int proxy_http_canon(request_rec *r, char *url)
     port = def_port;
     err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
     if (err) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01083)
                       "error parsing URL %s: %s", url, err);
         return HTTP_BAD_REQUEST;
     }
@@ -267,7 +267,7 @@ static int pass_brigade(apr_bucket_alloc_t *bucket_alloc,
         p_conn->worker->s->transferred += transferred;
     status = ap_pass_brigade(origin->output_filters, bb);
     if (status != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01084)
                       "pass request body failed to %pI (%s)",
                       p_conn->addr, p_conn->hostname);
         if (origin->aborted) {
@@ -440,7 +440,7 @@ static int stream_reqbody_cl(apr_pool_t *p,
         status = apr_strtoff(&cl_val, old_cl_val, &endstr, 10);
 
         if (status || *endstr || endstr == old_cl_val || cl_val < 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01085)
                           "could not parse request Content-Length (%s)",
                           old_cl_val);
             return HTTP_BAD_REQUEST;
@@ -477,7 +477,7 @@ static int stream_reqbody_cl(apr_pool_t *p,
          * Prevents HTTP Response Splitting.
          */
         if (bytes_streamed > cl_val) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01086)
                           "read more bytes of request body than expected "
                           "(got %" APR_OFF_T_FMT ", expected %" APR_OFF_T_FMT ")",
                           bytes_streamed, cl_val);
@@ -530,7 +530,7 @@ static int stream_reqbody_cl(apr_pool_t *p,
     }
 
     if (bytes_streamed != cl_val) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01087)
                       "client %s given Content-Length did not match"
                       " number of body bytes read", r->connection->peer_ip);
         return HTTP_BAD_REQUEST;
@@ -588,7 +588,7 @@ static int spool_reqbody_cl(apr_pool_t *p,
              * temporary file on disk.
              */
             if (bytes_spooled + bytes > limit) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01088)
                               "Request body is larger than the configured "
                               "limit of %" APR_OFF_T_FMT, limit);
                 return HTTP_REQUEST_ENTITY_TOO_LARGE;
@@ -600,7 +600,7 @@ static int spool_reqbody_cl(apr_pool_t *p,
 
                 status = apr_temp_dir_get(&temp_dir, p);
                 if (status != APR_SUCCESS) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01089)
                                   "search for temporary directory failed");
                     return HTTP_INTERNAL_SERVER_ERROR;
                 }
@@ -609,7 +609,7 @@ static int spool_reqbody_cl(apr_pool_t *p,
                                    APR_FILEPATH_NATIVE, p);
                 status = apr_file_mktemp(&tmpfile, template, 0, p);
                 if (status != APR_SUCCESS) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01090)
                                   "creation of temporary file in directory "
                                   "%s failed", temp_dir);
                     return HTTP_INTERNAL_SERVER_ERROR;
@@ -629,7 +629,7 @@ static int spool_reqbody_cl(apr_pool_t *p,
                     if (apr_file_name_get(&tmpfile_name, tmpfile) != APR_SUCCESS) {
                         tmpfile_name = "(unknown)";
                     }
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01091)
                                   "write to temporary file %s failed",
                                   tmpfile_name);
                     return HTTP_INTERNAL_SERVER_ERROR;
@@ -781,7 +781,7 @@ int ap_proxy_http_request(apr_pool_t *p, request_rec *r,
         const char* hostname = apr_table_get(r->headers_in,"Host");
         if (!hostname) {
             hostname =  r->server->server_hostname;
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01092)
                           "no HTTP 0.9 request (with no host line) "
                           "on incoming request and preserve host set "
                           "forcing hostname to be %s for uri %s",
@@ -993,13 +993,13 @@ int ap_proxy_http_request(apr_pool_t *p, request_rec *r,
      * do not modify add_te_chunked's logic
      */
     if (old_te_val && strcasecmp(old_te_val, "chunked") != 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01093)
                       "%s Transfer-Encoding is not supported", old_te_val);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     if (old_cl_val && old_te_val) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01094)
                       "client %s (%s) requested Transfer-Encoding "
                       "chunked body with Content-Length (C-L ignored)",
                       c->peer_ip, c->remote_host ? c->remote_host: "");
@@ -1023,7 +1023,7 @@ int ap_proxy_http_request(apr_pool_t *p, request_rec *r,
                                 AP_MODE_READBYTES, APR_BLOCK_READ,
                                 MAX_MEM_SPOOL - bytes_read);
         if (status != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01095)
                           "prefetch request body failed to %pI (%s)"
                           " from %s (%s)",
                           p_conn->addr, p_conn->hostname ? p_conn->hostname: "",
@@ -1045,7 +1045,7 @@ int ap_proxy_http_request(apr_pool_t *p, request_rec *r,
          */
         status = ap_save_brigade(NULL, &input_brigade, &temp_brigade, p);
         if (status != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(01096)
                           "processing prefetched request body failed"
                           " to %pI (%s) from %s (%s)",
                           p_conn->addr, p_conn->hostname ? p_conn->hostname: "",
@@ -1185,7 +1185,7 @@ skip_body:
 
     if (rv != OK) {
         /* apr_status_t value has been logged in lower level method */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01097)
                       "pass request body failed to %pI (%s) from %s (%s)",
                       p_conn->addr, p_conn->hostname ? p_conn->hostname: "",
                       c->peer_ip, c->remote_host ? c->remote_host: "");
@@ -1291,14 +1291,14 @@ static void ap_proxy_read_headers(request_rec *r, request_rec *rr,
                      * the first line of the response.
                      */
                     if (saw_headers) {
-                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01098)
                                       "Starting body due to bogus non-header "
                                       "in headers returned by %s (%s)",
                                       r->uri, r->method);
                         *pread_len = len;
                         return ;
                     } else {
-                         ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                         ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01099)
                                        "No HTTP headers returned by %s (%s)",
                                        r->uri, r->method);
                         return ;
@@ -1306,7 +1306,7 @@ static void ap_proxy_read_headers(request_rec *r, request_rec *rr,
                 }
             }
             /* this is the psc->badopt == bad_ignore case */
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01100)
                           "Ignoring bogus HTTP header returned by %s (%s)",
                           r->uri, r->method);
             continue;
@@ -1434,7 +1434,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
             apr_status_t rc;
             rc = apr_socket_timeout_set(backend->sock, worker->s->ping_timeout);
             if (rc != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(01101)
                               "could not set 100-Continue timeout");
             }
         }
@@ -1463,11 +1463,11 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
             rc = ap_proxygetline(tmp_bb, buffer, sizeof(buffer), backend->r, 0, &len);
         }
         if (len <= 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(01102)
                           "error reading status line from remote "
                           "server %s:%d", backend->hostname, backend->port);
             if (APR_STATUS_IS_TIMEUP(rc)) {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "read timeout");
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01103) "read timeout");
                 if (do_100_continue) {
                     return ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE, "Timeout on 100-Continue");
                 }
@@ -1487,7 +1487,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                 !APR_STATUS_IS_TIMEUP(rc)) {
                 apr_bucket *eos;
 
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01104)
                               "Closing connection to client because"
                               " reading from backend server %s:%d failed."
                               " Number of keepalives %i", backend->hostname,
@@ -1522,7 +1522,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                 return OK;
             }
             else if (!c->keepalives) {
-                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01105)
                                    "NOT Closing connection to client"
                                    " although reading from backend server %s:%d"
                                    " failed.",
@@ -1593,7 +1593,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                                   &pread_len);
 
             if (r->headers_out == NULL) {
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01106)
                               "bad HTTP/%d.%d header returned by %s (%s)",
                               major, minor, r->uri, r->method);
                 backend->close += 1;
@@ -1633,7 +1633,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                  * XXX: We aught to treat such a response as uncachable
                  */
                 apr_table_unset(r->headers_out, "Content-Length");
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01107)
                               "server %s:%d returned Transfer-Encoding"
                               " and Content-Length",
                               backend->hostname, backend->port);
@@ -1740,7 +1740,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
              * policies and maybe also add option to bail out with 502
              */
             else if (strcasecmp(policy, "Suppress")) {
-                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01108)
                               "undefined proxy interim response policy");
             }
         }
@@ -1754,7 +1754,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
             if ((buf = apr_table_get(r->headers_out, wa))) {
                 apr_table_set(r->err_headers_out, wa, buf);
             } else {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01109)
                               "origin server sent 401 without "
                               "WWW-Authenticate header");
             }
@@ -1878,7 +1878,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                          * our backend bailed on us. Pass along a 502 error
                          * error bucket
                          */
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01110)
                                       "error reading response");
                         ap_proxy_backend_broke(r, bb);
                         ap_pass_brigade(r->output_filters, bb);
@@ -1893,7 +1893,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                     backend->worker->s->read += readbytes;
 #if DEBUGGING
                     {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01111)
                                   "readbytes: %#x", readbytes);
                     }
 #endif
@@ -2051,7 +2051,7 @@ static int proxy_http_handler(request_rec *r, proxy_worker *worker,
     /* is it for us? */
     if (strcmp(scheme, "https") == 0) {
         if (!ap_proxy_ssl_enable(NULL)) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01112)
                           "HTTPS: declining URL %s (mod_ssl not configured?)",
                           url);
             return DECLINED;
@@ -2060,7 +2060,7 @@ static int proxy_http_handler(request_rec *r, proxy_worker *worker,
         proxy_function = "HTTPS";
     }
     else if (!(strcmp(scheme, "http") == 0 || (strcmp(scheme, "ftp") == 0 && proxyname))) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "HTTP: declining URL %s",
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01113) "HTTP: declining URL %s",
                       url);
         return DECLINED; /* only interested in HTTP, or FTP via proxy */
     }
@@ -2110,7 +2110,7 @@ static int proxy_http_handler(request_rec *r, proxy_worker *worker,
 
         /* Step Two: Make the Connection */
         if (ap_proxy_connect_backend(proxy_function, backend, worker, r->server)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01114)
                           "HTTP: failed to make connection to backend: %s",
                           backend->hostname);
             status = HTTP_SERVICE_UNAVAILABLE;
@@ -2141,7 +2141,7 @@ static int proxy_http_handler(request_rec *r, proxy_worker *worker,
                                         conf, uri, locurl, server_portstr)) != OK) {
             if ((status == HTTP_SERVICE_UNAVAILABLE) && worker->s->ping_timeout_set) {
                 backend->close = 1;
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, status, r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, status, r, APLOGNO(01115)
                               "HTTP: 100-Continue failed to %pI (%s)",
                               worker->cp->addr, worker->s->hostname);
                 retry++;
diff --git a/modules/proxy/mod_proxy_scgi.c b/modules/proxy/mod_proxy_scgi.c
index 3fe1b80..c457a6f 100644
--- a/modules/proxy/mod_proxy_scgi.c
+++ b/modules/proxy/mod_proxy_scgi.c
@@ -184,7 +184,7 @@ static int scgi_canon(request_rec *r, char *url)
 
     err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
     if (err) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00857)
                       "error parsing URL %s: %s", url, err);
         return HTTP_BAD_REQUEST;
     }
@@ -224,7 +224,7 @@ static int sendall(proxy_conn_rec *conn, const char *buf, apr_size_t length,
     while (length > 0) {
         written = length;
         if ((rv = apr_socket_send(conn->sock, buf, &written)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00858)
                           "sending data to %s:%u failed",
                           conn->hostname, conn->port);
             return HTTP_SERVICE_UNAVAILABLE;
@@ -335,7 +335,7 @@ static int send_request_body(request_rec *r, proxy_conn_rec *conn)
             readlen = ap_get_client_block(r, buf, AP_IOBUFSIZE);
         }
         if (readlen == -1) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00859)
                           "receiving request body failed");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -370,7 +370,7 @@ static int pass_response(request_rec *r, proxy_conn_rec *conn)
     status = ap_scan_script_header_err_brigade_ex(r, bb, NULL,
                                                   APLOG_MODULE_INDEX);
     if (status != OK) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00860)
                       "error reading response headers from %s:%u",
                       conn->hostname, conn->port);
         r->status_line = NULL;
@@ -390,7 +390,7 @@ static int pass_response(request_rec *r, proxy_conn_rec *conn)
         if (location) {
             scgi_request_config *req_conf = apr_palloc(r->pool,
                                                        sizeof(*req_conf));
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00861)
                           "Found %s: %s - preparing subrequest.",
                           conf->sendfile, location);
 
@@ -441,7 +441,7 @@ static int scgi_request_status(int *status, request_rec *r)
                                             &proxy_scgi_module))) {
         switch (req_conf->type) {
         case scgi_internal_redirect:
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00862)
                           "Internal redirect to %s", req_conf->location);
 
             r->status_line = NULL;
@@ -456,7 +456,7 @@ static int scgi_request_status(int *status, request_rec *r)
             /* break; */
 
         case scgi_sendfile:
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00863)
                           "File subrequest to %s", req_conf->location);
             do {
                 request_rec *rr;
@@ -472,7 +472,7 @@ static int scgi_request_status(int *status, request_rec *r)
                     ap_run_sub_req(rr);
                 }
                 else {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00864)
                                   "Subrequest to file '%s' not possible. "
                                   "(rr->status=%d, rr->finfo.filetype=%d)",
                                   req_conf->location, rr->status,
@@ -505,7 +505,7 @@ static int scgi_handler(request_rec *r, proxy_worker *worker,
     char dummy;
 
     if (strncasecmp(url, SCHEME "://", sizeof(SCHEME) + 2)) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00865)
                       "declining URL %s", url);
         return DECLINED;
     }
@@ -528,7 +528,7 @@ static int scgi_handler(request_rec *r, proxy_worker *worker,
 
     /* Step Two: Make the Connection */
     if (ap_proxy_connect_backend(__FUNCTION__, backend, worker, r->server)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00866)
                       "failed to make connection to backend: %s:%u",
                       backend->hostname, backend->port);
         status = HTTP_SERVICE_UNAVAILABLE;
diff --git a/modules/proxy/mod_serf.c b/modules/proxy/mod_serf.c
index 063a14d..8f0ce7c 100644
--- a/modules/proxy/mod_serf.c
+++ b/modules/proxy/mod_serf.c
@@ -79,7 +79,7 @@ static void timed_cleanup_callback(void *baton)
 
     /* Causes all serf connections to unregister from the event mpm */
     if (ctx->rstatus) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, ctx->rstatus, ctx->r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, ctx->rstatus, ctx->r, APLOGNO(01119)
                       "serf: request returned: %d", ctx->rstatus);
         ctx->r->status = HTTP_OK;
         apr_pool_destroy(ctx->serf_pool);
@@ -114,7 +114,7 @@ static void closed_connection(serf_connection_t *conn,
     if (why) {
         /* justin says that error handling isn't done yet. hah. */
         /* XXXXXX: review */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, why, ctx->r, "Closed Connection Error");
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, why, ctx->r, APLOGNO(01120) "Closed Connection Error");
         ctx->rstatus = HTTP_INTERNAL_SERVER_ERROR;
     }
 
@@ -281,7 +281,7 @@ static apr_status_t handle_response(serf_request_t *request,
             return APR_SUCCESS;
         }
 
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, ctx->r, "serf_bucket_response_status...");
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, ctx->r, APLOGNO(01121) "serf_bucket_response_status...");
 
         ctx->rstatus = HTTP_INTERNAL_SERVER_ERROR;
 
@@ -303,7 +303,7 @@ static apr_status_t handle_response(serf_request_t *request,
         rv = serf_bucket_read(response, AP_IOBUFSIZE, &data, &len);
 
         if (SERF_BUCKET_READ_ERROR(rv)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, ctx->r, "serf_bucket_read(response)");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, ctx->r, APLOGNO(01122) "serf_bucket_read(response)");
             return rv;
         }
 
@@ -433,7 +433,7 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
                                conf->url.hostname,
                                APR_HASH_KEY_STRING);
         if (!cluster) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01123)
                           "SerfCluster: unable to find cluster %s", conf->url.hostname);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -441,13 +441,13 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
         cp = ap_lookup_provider(AP_SERF_CLUSTER_PROVIDER, cluster->provider, "0");
 
         if (cp == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01124)
                           "SerfCluster: unable to find provider %s", cluster->provider);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
 
         if (cp->list_servers == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01125)
                           "SerfCluster: %s is missing list servers provider.", cluster->provider);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -458,13 +458,13 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
                               &servers);
 
         if (rc != OK) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(01126)
                           "SerfCluster: %s list servers returned failure", cluster->provider);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
 
         if (servers == NULL || apr_is_empty_array(servers)) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(01127)
                           "SerfCluster: %s failed to provide a list of servers", cluster->provider);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -485,14 +485,14 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
     }
 
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "Unable to resolve: %s", conf->url.hostname);
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01128) "Unable to resolve: %s", conf->url.hostname);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     if (mpm_supprts_serf) {
         serfme = ap_lookup_provider("mpm_serf", "instance", "0");
         if (!serfme) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "mpm lied to us about supporting serf.");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01129) "mpm lied to us about supporting serf.");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
     }
@@ -533,7 +533,7 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
 
         rv = apr_file_mktemp(&fp, "mod_serf_buffer.XXXXXX", 0, pool);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "Unable to create temp request body buffer file.");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01130) "Unable to create temp request body buffer file.");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
 
@@ -543,14 +543,14 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
             if (rv > 0) {
                 rv = apr_file_write_full(fp, buf, rv, NULL);
                 if (rv) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "failed to read request body");
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01131) "failed to read request body");
                     return HTTP_INTERNAL_SERVER_ERROR;
                 }
             }
         } while(rv > 0);
 
         if (rv < 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "failed to read request body");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01132) "failed to read request body");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
 
@@ -579,7 +579,7 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
             }
 
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "serf_context_run() for %pI", address);
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01133) "serf_context_run() for %pI", address);
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
 
@@ -961,7 +961,7 @@ static int hb_list_servers(void *baton,
     rv = read_heartbeats(path, tmpservers, tpool);
 
     if (rv) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01134)
                       "SerfCluster: Heartbeat unable to read '%s'", path);
         apr_pool_destroy(tpool);
         return HTTP_INTERNAL_SERVER_ERROR;
diff --git a/modules/proxy/proxy_util.c b/modules/proxy/proxy_util.c
index 79d8e15..727809a 100644
--- a/modules/proxy/proxy_util.c
+++ b/modules/proxy/proxy_util.c
@@ -516,7 +516,7 @@ PROXY_DECLARE(int) ap_proxyerror(request_rec *r, int statuscode, const char *mes
     apr_table_setn(r->notes, "verbose-error-to", apr_pstrdup(r->pool, "*"));
 
     r->status_line = apr_psprintf(r->pool, "%3.3u Proxy Error", statuscode);
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "%s returned by %s", message,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00898) "%s returned by %s", message,
                   r->uri);
     return statuscode;
 }
@@ -541,7 +541,7 @@ static const char *
     err = ap_proxy_canon_netloc(r->pool, &url, &user, &password, &host, &port);
 
     if (err != NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "%s", err);
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00899) "%s", err);
     }
 
     r->hostname = host;
@@ -644,7 +644,7 @@ PROXY_DECLARE(int) ap_proxy_is_ipaddr(struct dirconn_entry *This, apr_pool_t *p)
         bits = 8 * quads;
 
         if (bits != 32) {     /* no warning for fully qualified IP address */
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00900)
                          "Warning: NetMask not supplied with IP-Addr; guessing: %s/%ld",
                          inet_ntoa(This->addr), bits);
         }
@@ -653,11 +653,11 @@ PROXY_DECLARE(int) ap_proxy_is_ipaddr(struct dirconn_entry *This, apr_pool_t *p)
     This->mask.s_addr = htonl(APR_INADDR_NONE << (32 - bits));
 
     if (*addr == '\0' && (This->addr.s_addr & ~This->mask.s_addr) != 0) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00901)
                      "Warning: NetMask and IP-Addr disagree in %s/%ld",
                      inet_ntoa(This->addr), bits);
         This->addr.s_addr &= This->mask.s_addr;
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00902)
                      "         Set to %s/%ld", inet_ntoa(This->addr), bits);
     }
 
@@ -694,22 +694,22 @@ static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r)
 
         if (This->addr.s_addr == (addr.s_addr & This->mask.s_addr)) {
 #if DEBUGGING
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00903)
                          "1)IP-Match: %s[%s] <-> ", host, inet_ntoa(addr));
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00904)
                          "%s/", inet_ntoa(This->addr));
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00905)
                          "%s", inet_ntoa(This->mask));
 #endif
             return 1;
         }
 #if DEBUGGING
         else {
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00906)
                          "1)IP-NoMatch: %s[%s] <-> ", host, inet_ntoa(addr));
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00907)
                          "%s/", inet_ntoa(This->addr));
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00908)
                          "%s", inet_ntoa(This->mask));
         }
 #endif
@@ -720,7 +720,7 @@ static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r)
         if (apr_sockaddr_info_get(&reqaddr, host, APR_UNSPEC, 0, 0, r->pool)
             != APR_SUCCESS) {
 #if DEBUGGING
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00909)
              "2)IP-NoMatch: hostname=%s msg=Host not found", host);
 #endif
             return 0;
@@ -732,22 +732,22 @@ static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r)
             ip = (struct in_addr *) reqaddr->ipaddr_ptr;
             if (This->addr.s_addr == (ip->s_addr & This->mask.s_addr)) {
 #if DEBUGGING
-                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00910)
                              "3)IP-Match: %s[%s] <-> ", host, inet_ntoa(*ip));
-                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00911)
                              "%s/", inet_ntoa(This->addr));
-                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00912)
                              "%s", inet_ntoa(This->mask));
 #endif
                 return 1;
             }
 #if DEBUGGING
             else {
-                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00913)
                              "3)IP-NoMatch: %s[%s] <-> ", host, inet_ntoa(*ip));
-                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00914)
                              "%s/", inet_ntoa(This->addr));
-                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00915)
                              "%s", inet_ntoa(This->mask));
             }
 #endif
@@ -915,7 +915,7 @@ PROXY_DECLARE(int) ap_proxy_checkproxyblock(request_rec *r, proxy_server_conf *c
                       uri_addr->hostname, npent[j].name);
         if ((npent[j].name && ap_strstr_c(uri_addr->hostname, npent[j].name))
             || npent[j].name[0] == '*') {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(00916)
                           "connect to remote machine %s blocked: name %s "
                           "matched", uri_addr->hostname, npent[j].name);
             return HTTP_FORBIDDEN;
@@ -931,7 +931,7 @@ PROXY_DECLARE(int) ap_proxy_checkproxyblock(request_rec *r, proxy_server_conf *c
                               "ProxyBlock comparing %s and %s", conf_ip,
                               uri_ip);
                 if (!apr_strnatcasecmp(conf_ip, uri_ip)) {
-                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(00917)
                                  "connect to remote machine %s blocked: "
                                  "IP %s matched", uri_addr->hostname, conf_ip);
                     return HTTP_FORBIDDEN;
@@ -1452,7 +1452,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_balancer(proxy_balancer *balance
     unsigned int num;
 
     if (!storage) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(00918)
                      "no provider for %s", balancer->s->name);
         return APR_EGENERAL;
     }
@@ -1461,7 +1461,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_balancer(proxy_balancer *balance
      * mutex and then attach to the shared worker shm
      */
     if (!balancer->gmutex) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(00919)
                      "no mutex %s", balancer->s->name);
         return APR_EGENERAL;
     }
@@ -1471,7 +1471,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_balancer(proxy_balancer *balance
                                      apr_global_mutex_lockfile(balancer->gmutex),
                                      p);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s, APLOGNO(00920)
                      "Failed to reopen mutex %s in child",
                      balancer->s->name);
         return rv;
@@ -1480,7 +1480,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_balancer(proxy_balancer *balance
     /* now attach */
     storage->attach(&(balancer->wslot), balancer->s->sname, &size, &num, p);
     if (!balancer->wslot) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, "slotmem_attach failed");
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(00921) "slotmem_attach failed");
         return APR_EGENERAL;
     }
     if (balancer->lbmethod && balancer->lbmethod->reset)
@@ -1489,7 +1489,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_balancer(proxy_balancer *balance
     if (balancer->tmutex == NULL) {
         rv = apr_thread_mutex_create(&(balancer->tmutex), APR_THREAD_MUTEX_DEFAULT, p);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(00922)
                          "can not create balancer thread mutex");
             return rv;
         }
@@ -1552,7 +1552,7 @@ static apr_status_t connection_cleanup(void *theconn)
 
     /* Sanity check: Did we already return the pooled connection? */
     if (conn->inreslist) {
-        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, conn->pool,
+        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, conn->pool, APLOGNO(00923)
                       "Pooled connection 0x%pp for worker %s has been"
                       " already returned to the connection pool.", conn,
                       worker->s->name);
@@ -1875,11 +1875,11 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_worker(proxy_worker *worker, ser
 
     if (worker->s->status & PROXY_WORKER_INITIALIZED) {
         /* The worker is already initialized */
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00924)
                      "worker %s shared already initialized", worker->s->name);
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00925)
                      "initializing worker %s shared", worker->s->name);
         /* Set default parameters */
         if (!worker->s->retry_set) {
@@ -1915,17 +1915,17 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_worker(proxy_worker *worker, ser
 
     /* What if local is init'ed and shm isn't?? Even possible? */
     if (worker->local_status & PROXY_WORKER_INITIALIZED) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00926)
                      "worker %s local already initialized", worker->s->name);
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00927)
                      "initializing worker %s local", worker->s->name);
         /* Now init local worker data */
         if (worker->tmutex == NULL) {
             rv = apr_thread_mutex_create(&(worker->tmutex), APR_THREAD_MUTEX_DEFAULT, p);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00928)
                              "can not create worker thread mutex");
                 return rv;
             }
@@ -1933,7 +1933,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_worker(proxy_worker *worker, ser
         if (worker->cp == NULL)
             init_conn_pool(p, worker);
         if (worker->cp == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00929)
                          "can not create connection pool");
             return APR_EGENERAL;
         }
@@ -1949,7 +1949,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_worker(proxy_worker *worker, ser
                                       conn_pool_cleanup,
                                       apr_pool_cleanup_null);
 
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00930)
                 "initialized pool in child %" APR_PID_T_FMT " for (%s) min=%d max=%d smax=%d",
                  getpid(), worker->s->hostname, worker->s->min,
                  worker->s->hmax, worker->s->smax);
@@ -1966,7 +1966,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_worker(proxy_worker *worker, ser
             rv = connection_constructor(&conn, worker, worker->cp->pool);
             worker->cp->conn = conn;
 
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00931)
                  "initialized single connection worker in child %" APR_PID_T_FMT " for (%s)",
                  getpid(), worker->s->hostname);
         }
@@ -1985,13 +1985,13 @@ static int ap_proxy_retry_worker(const char *proxy_function, proxy_worker *worke
         if (apr_time_now() > worker->s->error_time + worker->s->retry) {
             ++worker->s->retries;
             worker->s->status &= ~PROXY_WORKER_IN_ERROR;
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00932)
                          "%s: worker for (%s) has been marked for retry",
                          proxy_function, worker->s->hostname);
             return OK;
         }
         else {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00933)
                          "%s: too soon to retry worker for (%s)",
                          proxy_function, worker->s->hostname);
             return DECLINED;
@@ -2053,7 +2053,7 @@ PROXY_DECLARE(int) ap_proxy_pre_request(proxy_worker **worker,
     }
     else if (access_status == DECLINED && *balancer != NULL) {
         /* All the workers are busy */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00934)
                       "all workers are busy.  Unable to serve %s", *url);
         access_status = HTTP_SERVICE_UNAVAILABLE;
     }
@@ -2093,7 +2093,7 @@ PROXY_DECLARE(int) ap_proxy_connect_to_backend(apr_socket_t **newsock,
         if ((rv = apr_socket_create(newsock, backend_addr->family,
                                     SOCK_STREAM, 0, r->pool)) != APR_SUCCESS) {
             loglevel = backend_addr->next ? APLOG_DEBUG : APLOG_ERR;
-            ap_log_rerror(APLOG_MARK, loglevel, rv, r,
+            ap_log_rerror(APLOG_MARK, loglevel, rv, r, APLOGNO(00935)
                           "%s: error creating fam %d socket for target %s",
                           proxy_function, backend_addr->family, backend_name);
             /*
@@ -2108,14 +2108,14 @@ PROXY_DECLARE(int) ap_proxy_connect_to_backend(apr_socket_t **newsock,
         if (conf->recv_buffer_size > 0 &&
             (rv = apr_socket_opt_set(*newsock, APR_SO_RCVBUF,
                                      conf->recv_buffer_size))) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00936)
                           "apr_socket_opt_set(SO_RCVBUF): Failed to set "
                           "ProxyReceiveBufferSize, using default");
         }
 
         rv = apr_socket_opt_set(*newsock, APR_TCP_NODELAY, 1);
         if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00937)
                           "apr_socket_opt_set(APR_TCP_NODELAY): "
                           "Failed to set");
         }
@@ -2135,7 +2135,7 @@ PROXY_DECLARE(int) ap_proxy_connect_to_backend(apr_socket_t **newsock,
         if (conf->source_address) {
             rv = apr_socket_bind(*newsock, conf->source_address);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00938)
                               "%s: failed to bind socket to local address",
                               proxy_function);
             }
@@ -2148,7 +2148,7 @@ PROXY_DECLARE(int) ap_proxy_connect_to_backend(apr_socket_t **newsock,
         if (rv != APR_SUCCESS) {
             apr_socket_close(*newsock);
             loglevel = backend_addr->next ? APLOG_DEBUG : APLOG_ERR;
-            ap_log_rerror(APLOG_MARK, loglevel, rv, r,
+            ap_log_rerror(APLOG_MARK, loglevel, rv, r, APLOGNO(00939)
                           "%s: attempt to connect to %pI (%s) failed",
                           proxy_function, backend_addr, backend_name);
             backend_addr = backend_addr->next;
@@ -2171,7 +2171,7 @@ PROXY_DECLARE(int) ap_proxy_acquire_connection(const char *proxy_function,
         ap_proxy_retry_worker(proxy_function, worker, s);
 
         if (!PROXY_WORKER_IS_USABLE(worker)) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00940)
                          "%s: disabled connection for (%s)",
                          proxy_function, worker->s->hostname);
             return HTTP_SERVICE_UNAVAILABLE;
@@ -2194,12 +2194,12 @@ PROXY_DECLARE(int) ap_proxy_acquire_connection(const char *proxy_function,
     }
 
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00941)
                      "%s: failed to acquire connection for (%s)",
                      proxy_function, worker->s->hostname);
         return HTTP_SERVICE_UNAVAILABLE;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00942)
                  "%s: has acquired connection for (%s)",
                  proxy_function, worker->s->hostname);
 
@@ -2214,7 +2214,7 @@ PROXY_DECLARE(int) ap_proxy_release_connection(const char *proxy_function,
                                                proxy_conn_rec *conn,
                                                server_rec *s)
 {
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00943)
                 "%s: has released connection for (%s)",
                 proxy_function, conn->worker->s->hostname);
     connection_cleanup(conn);
@@ -2252,7 +2252,7 @@ ap_proxy_determine_connection(apr_pool_t *p, request_rec *r,
         uri->port = apr_uri_port_of_scheme(uri->scheme);
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00944)
                  "connecting %s to %s:%d", *url, uri->hostname, uri->port);
 
     /*
@@ -2325,7 +2325,7 @@ ap_proxy_determine_connection(apr_pool_t *p, request_rec *r,
     }
     else if (!worker->cp->addr) {
         if ((err = PROXY_THREAD_LOCK(worker)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, err, r, "lock");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, err, r, APLOGNO(00945) "lock");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
 
@@ -2341,7 +2341,7 @@ ap_proxy_determine_connection(apr_pool_t *p, request_rec *r,
                                     worker->cp->pool);
         conn->addr = worker->cp->addr;
         if ((uerr = PROXY_THREAD_UNLOCK(worker)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, uerr, r, "unlock");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, uerr, r, APLOGNO(00946) "unlock");
         }
     }
     else {
@@ -2375,7 +2375,7 @@ ap_proxy_determine_connection(apr_pool_t *p, request_rec *r,
         return ap_proxyerror(r, HTTP_FORBIDDEN,
                              "Connect to remote machine blocked");
     }
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00947)
                  "connected %s to %s:%d", *url, conn->hostname, conn->port);
     return OK;
 }
@@ -2468,7 +2468,7 @@ static apr_status_t send_http_connect(proxy_conn_rec *backend,
     forward_info *forward = (forward_info *)backend->forward;
     int len = 0;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00948)
                  "CONNECT: sending the CONNECT request for %s:%d "
                  "to the remote proxy %pI (%s)",
                  forward->target_host, forward->target_port,
@@ -2522,7 +2522,7 @@ static apr_status_t send_http_connect(proxy_conn_rec *backend,
         /* Only scan for three character status code */
         char code_str[4];
 
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00949)
                      "send_http_connect: response from the forward proxy: %s",
                      buffer);
 
@@ -2533,7 +2533,7 @@ static apr_status_t send_http_connect(proxy_conn_rec *backend,
                 status = APR_SUCCESS;
             }
             else {
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00950)
                              "send_http_connect: the forward proxy returned code is '%s'",
                              code_str);
             status = APR_INCOMPLETE;
@@ -2564,7 +2564,7 @@ PROXY_DECLARE(int) ap_proxy_connect_backend(const char *proxy_function,
     if (conn->sock) {
         if (!(connected = is_socket_connected(conn->sock))) {
             socket_cleanup(conn);
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00951)
                          "%s: backend socket is disconnected.",
                          proxy_function);
         }
@@ -2574,7 +2574,7 @@ PROXY_DECLARE(int) ap_proxy_connect_backend(const char *proxy_function,
                                 SOCK_STREAM, APR_PROTO_TCP,
                                 conn->scpool)) != APR_SUCCESS) {
             loglevel = backend_addr->next ? APLOG_DEBUG : APLOG_ERR;
-            ap_log_error(APLOG_MARK, loglevel, rv, s,
+            ap_log_error(APLOG_MARK, loglevel, rv, s, APLOGNO(00952)
                          "%s: error creating fam %d socket for target %s",
                          proxy_function,
                          backend_addr->family,
@@ -2592,14 +2592,14 @@ PROXY_DECLARE(int) ap_proxy_connect_backend(const char *proxy_function,
         if (worker->s->recv_buffer_size > 0 &&
             (rv = apr_socket_opt_set(newsock, APR_SO_RCVBUF,
                                      worker->s->recv_buffer_size))) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00953)
                          "apr_socket_opt_set(SO_RCVBUF): Failed to set "
                          "ProxyReceiveBufferSize, using default");
         }
 
         rv = apr_socket_opt_set(newsock, APR_TCP_NODELAY, 1);
         if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {
-             ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+             ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00954)
                           "apr_socket_opt_set(APR_TCP_NODELAY): "
                           "Failed to set");
         }
@@ -2621,7 +2621,7 @@ PROXY_DECLARE(int) ap_proxy_connect_backend(const char *proxy_function,
         if (worker->s->keepalive) {
             if ((rv = apr_socket_opt_set(newsock,
                             APR_SO_KEEPALIVE, 1)) != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+                ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00955)
                              "apr_socket_opt_set(SO_KEEPALIVE): Failed to set"
                              " Keepalive");
             }
@@ -2636,7 +2636,7 @@ PROXY_DECLARE(int) ap_proxy_connect_backend(const char *proxy_function,
             local_addr->pool = conn->pool;
             rv = apr_socket_bind(newsock, local_addr);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+                ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(00956)
                     "%s: failed to bind socket to local address",
                     proxy_function);
             }
@@ -2649,7 +2649,7 @@ PROXY_DECLARE(int) ap_proxy_connect_backend(const char *proxy_function,
         if (rv != APR_SUCCESS) {
             apr_socket_close(newsock);
             loglevel = backend_addr->next ? APLOG_DEBUG : APLOG_ERR;
-            ap_log_error(APLOG_MARK, loglevel, rv, s,
+            ap_log_error(APLOG_MARK, loglevel, rv, s, APLOGNO(00957)
                          "%s: attempt to connect to %pI (%s) failed",
                          proxy_function,
                          backend_addr,
@@ -2684,7 +2684,7 @@ PROXY_DECLARE(int) ap_proxy_connect_backend(const char *proxy_function,
                     conn->sock = NULL;
                     apr_socket_close(newsock);
                     loglevel = backend_addr->next ? APLOG_DEBUG : APLOG_ERR;
-                    ap_log_error(APLOG_MARK, loglevel, rv, s,
+                    ap_log_error(APLOG_MARK, loglevel, rv, s, APLOGNO(00958)
                                  "%s: attempt to connect to %s:%d "
                                  "via http CONNECT through %pI (%s) failed",
                                  proxy_function,
@@ -2708,7 +2708,7 @@ PROXY_DECLARE(int) ap_proxy_connect_backend(const char *proxy_function,
         !(worker->s->status & PROXY_WORKER_IGNORE_ERRORS)) {
         worker->s->error_time = apr_time_now();
         worker->s->status |= PROXY_WORKER_IN_ERROR;
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00959)
             "ap_proxy_connect_backend disabling worker for (%s) for %"
             APR_TIME_T_FMT "s",
             worker->s->hostname, apr_time_sec(worker->s->retry));
@@ -2755,7 +2755,7 @@ PROXY_DECLARE(int) ap_proxy_connection_create(const char *proxy_function,
          * closed the socket
          */
         ap_log_error(APLOG_MARK, APLOG_DEBUG, 0,
-                     s, "%s: an error occurred creating a "
+                     s, APLOGNO(00960) "%s: an error occurred creating a "
                      "new connection to %pI (%s)", proxy_function,
                      backend_addr, conn->hostname);
         /* XXX: Will be closed when proxy_conn is closed */
@@ -2767,7 +2767,7 @@ PROXY_DECLARE(int) ap_proxy_connection_create(const char *proxy_function,
     if (conn->is_ssl) {
         if (!ap_proxy_ssl_enable(conn->connection)) {
             ap_log_error(APLOG_MARK, APLOG_ERR, 0,
-                         s, "%s: failed to enable ssl support "
+                         s, APLOGNO(00961) "%s: failed to enable ssl support "
                          "for %pI (%s)", proxy_function,
                          backend_addr, conn->hostname);
             return HTTP_INTERNAL_SERVER_ERROR;
@@ -2778,7 +2778,7 @@ PROXY_DECLARE(int) ap_proxy_connection_create(const char *proxy_function,
         ap_proxy_ssl_disable(conn->connection);
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00962)
                  "%s: connection complete to %pI (%s)",
                  proxy_function, backend_addr, conn->hostname);
 
@@ -2792,7 +2792,7 @@ PROXY_DECLARE(int) ap_proxy_connection_create(const char *proxy_function,
     rc = ap_run_pre_connection(conn->connection, conn->sock);
     if (rc != OK && rc != DONE) {
         conn->connection->aborted = 1;
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00963)
                      "%s: pre_connection setup failed (%d)",
                      proxy_function, rc);
         return rc;
@@ -2875,7 +2875,7 @@ ap_proxy_buckets_lifetime_transform(request_rec *r, apr_bucket_brigade *from,
             APR_BRIGADE_INSERT_TAIL(to, new);
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00964)
                           "Unhandled bucket type of type %s in"
                           " ap_proxy_buckets_lifetime_transform", e->type->name);
             apr_bucket_delete(e);
@@ -2982,7 +2982,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_sync_balancer(proxy_balancer *b, server_rec
         int found;
         apr_status_t rv;
         if ((rv = storage->dptr(b->wslot, (unsigned int)index, (void *)&shm)) != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, "worker slotmem_dptr failed");
+            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(00965) "worker slotmem_dptr failed");
             return APR_EGENERAL;
         }
         /* account for possible "holes" in the slotmem
@@ -3010,7 +3010,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_sync_balancer(proxy_balancer *b, server_rec
             (*runtime)->s = shm;
             (*runtime)->tmutex = NULL;
             if ((rv = ap_proxy_initialize_worker(*runtime, s, conf->pool)) != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, "Cannot init worker");
+                ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(00966) "Cannot init worker");
                 return rv;
             }
         }
diff --git a/modules/session/mod_session.c b/modules/session/mod_session.c
index a56fcd3..3e1275b 100644
--- a/modules/session/mod_session.c
+++ b/modules/session/mod_session.c
@@ -104,7 +104,7 @@ static apr_status_t ap_session_load(request_rec * r, session_rec ** z)
 
     /* should the session be loaded at all? */
     if (!session_included(r, dconf)) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01814)
                       "excluded by configuration for: %s", r->uri);
         return APR_SUCCESS;
     }
@@ -112,13 +112,13 @@ static apr_status_t ap_session_load(request_rec * r, session_rec ** z)
     /* load the session from the session hook */
     rv = ap_run_session_load(r, &zz);
     if (DECLINED == rv) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01815)
                       "session is enabled but no session modules have been configured, "
                       "session not loaded: %s", r->uri);
         return APR_EGENERAL;
     }
     else if (OK != rv) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01816)
                       "error while loading the session, "
                       "session not loaded: %s", r->uri);
         return rv;
@@ -139,7 +139,7 @@ static apr_status_t ap_session_load(request_rec * r, session_rec ** z)
     else {
         rv = ap_run_session_decode(r, zz);
         if (OK != rv) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01817)
                           "error while decoding the session, "
                           "session not loaded: %s", r->uri);
             return rv;
@@ -178,13 +178,13 @@ static apr_status_t ap_session_save(request_rec * r, session_rec * z)
 
         /* sanity checks, should we try save at all? */
         if (z->written) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01818)
                           "attempt made to save the session twice, "
                           "session not saved: %s", r->uri);
             return APR_EGENERAL;
         }
         if (z->expiry && z->expiry < now) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01819)
                           "attempt made to save a session when the session had already expired, "
                           "session not saved: %s", r->uri);
             return APR_EGENERAL;
@@ -199,7 +199,7 @@ static apr_status_t ap_session_save(request_rec * r, session_rec * z)
         /* encode the session */
         rv = ap_run_session_encode(r, z);
         if (OK != rv) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01820)
                           "error while encoding the session, "
                           "session not saved: %s", r->uri);
             return rv;
@@ -208,13 +208,13 @@ static apr_status_t ap_session_save(request_rec * r, session_rec * z)
         /* try the save */
         rv = ap_run_session_save(r, z);
         if (DECLINED == rv) {
-            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01821)
                           "session is enabled but no session modules have been configured, "
                           "session not saved: %s", r->uri);
             return APR_EGENERAL;
         }
         else if (OK != rv) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01822)
                           "error while saving the session, "
                           "session not saved: %s", r->uri);
             return rv;
diff --git a/modules/session/mod_session_crypto.c b/modules/session/mod_session_crypto.c
index 6715402..f9e831d 100644
--- a/modules/session/mod_session_crypto.c
+++ b/modules/session/mod_session_crypto.c
@@ -71,7 +71,7 @@ static apr_status_t crypt_init(request_rec *r,
 
     res = apr_crypto_get_block_key_types(&ciphers, f);
     if (APR_SUCCESS != res) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r, APLOGNO(01823)
                 "no ciphers returned by APR. "
                 "session encryption not possible");
         return res;
@@ -104,7 +104,7 @@ static apr_status_t crypt_init(request_rec *r,
         }
         options[offset] = 0;
 
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r, APLOGNO(01824)
                 "cipher '%s' not recognised by crypto driver. "
                 "session encryption not possible, options: %s", dconf->cipher, options);
 
@@ -158,26 +158,26 @@ static apr_status_t encrypt_string(request_rec * r, const apr_crypto_t *f,
             (unsigned char *) (&salt), sizeof(apr_uuid_t),
             *cipher, APR_MODE_CBC, 1, 4096, f, r->pool);
     if (APR_STATUS_IS_ENOKEY(res)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r, APLOGNO(01825)
                 "the passphrase '%s' was empty", passphrase);
     }
     if (APR_STATUS_IS_EPADDING(res)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r, APLOGNO(01826)
                 "padding is not supported for cipher");
     }
     if (APR_STATUS_IS_EKEYTYPE(res)) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r, APLOGNO(01827)
                 "the key type is not known");
     }
     if (APR_SUCCESS != res) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r, APLOGNO(01828)
                 "encryption could not be configured.");
         return res;
     }
 
     res = apr_crypto_block_encrypt_init(&block, &iv, key, &blockSize, r->pool);
     if (APR_SUCCESS != res) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r, APLOGNO(01829)
                 "apr_crypto_block_encrypt_init failed");
         return res;
     }
@@ -186,13 +186,13 @@ static apr_status_t encrypt_string(request_rec * r, const apr_crypto_t *f,
     res = apr_crypto_block_encrypt(&encrypt, &encryptlen, (unsigned char *)in,
             strlen(in), block);
     if (APR_SUCCESS != res) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r, APLOGNO(01830)
                 "apr_crypto_block_encrypt failed");
         return res;
     }
     res = apr_crypto_block_encrypt_finish(encrypt + encryptlen, &tlen, block);
     if (APR_SUCCESS != res) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r, APLOGNO(01831)
                 "apr_crypto_block_encrypt_finish failed");
         return res;
     }
@@ -258,29 +258,29 @@ static apr_status_t decrypt_string(request_rec * r, const apr_crypto_t *f,
                 (unsigned char *)decoded, sizeof(apr_uuid_t),
                 *cipher, APR_MODE_CBC, 1, 4096, f, r->pool);
         if (APR_STATUS_IS_ENOKEY(res)) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r, APLOGNO(01832)
                     "the passphrase '%s' was empty", passphrase);
             continue;
         }
         else if (APR_STATUS_IS_EPADDING(res)) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r, APLOGNO(01833)
                     "padding is not supported for cipher");
             continue;
         }
         else if (APR_STATUS_IS_EKEYTYPE(res)) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r, APLOGNO(01834)
                     "the key type is not known");
             continue;
         }
         else if (APR_SUCCESS != res) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r, APLOGNO(01835)
                     "encryption could not be configured.");
             continue;
         }
 
         /* sanity check - decoded too short? */
         if (decodedlen < (sizeof(apr_uuid_t) + ivSize)) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r, APLOGNO(01836)
                     "too short to decrypt, skipping");
             res = APR_ECRYPT;
             continue;
@@ -293,7 +293,7 @@ static apr_status_t decrypt_string(request_rec * r, const apr_crypto_t *f,
         res = apr_crypto_block_decrypt_init(&block, &blockSize, (unsigned char *)slider, key,
                 r->pool);
         if (APR_SUCCESS != res) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r, APLOGNO(01837)
                     "apr_crypto_block_decrypt_init failed");
             continue;
         }
@@ -306,7 +306,7 @@ static apr_status_t decrypt_string(request_rec * r, const apr_crypto_t *f,
         res = apr_crypto_block_decrypt(&decrypted, &decryptedlen,
                 (unsigned char *)slider, len, block);
         if (res) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r, APLOGNO(01838)
                     "apr_crypto_block_decrypt failed");
             continue;
         }
@@ -314,7 +314,7 @@ static apr_status_t decrypt_string(request_rec * r, const apr_crypto_t *f,
 
         res = apr_crypto_block_decrypt_finish(decrypted + decryptedlen, &tlen, block);
         if (APR_SUCCESS != res) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r, APLOGNO(01839)
                     "apr_crypto_block_decrypt_finish failed");
             continue;
         }
@@ -325,7 +325,7 @@ static apr_status_t decrypt_string(request_rec * r, const apr_crypto_t *f,
     }
 
     if (APR_SUCCESS != res) {
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, res, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, res, r, APLOGNO(01840)
                 "decryption failed");
     }
 
@@ -352,7 +352,7 @@ static apr_status_t session_crypto_encode(request_rec * r, session_rec * z)
         apr_pool_userdata_get((void **)&f, CRYPTO_KEY, r->server->process->pconf);
         res = encrypt_string(r, f, dconf, z->encoded, &encoded);
         if (res != OK) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, res, r, APLOGNO(01841)
                     "encrypt session failed");
             return res;
         }
@@ -384,7 +384,7 @@ static apr_status_t session_crypto_decode(request_rec * r,
                 r->server->process->pconf);
         res = decrypt_string(r, f, dconf, z->encoded, &encoded);
         if (res != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, res, r, APLOGNO(01842)
                     "decrypt session failed, wrong passphrase?");
             return res;
         }
@@ -421,31 +421,31 @@ static int session_crypto_init(apr_pool_t *p, apr_pool_t *plog,
 
         rv = apr_crypto_init(p);
         if (APR_SUCCESS != rv) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(01843)
                     "APR crypto could not be initialised");
             return rv;
         }
 
         rv = apr_crypto_get_driver(&driver, conf->library, conf->params, &err, p);
         if (APR_EREINIT == rv) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s, APLOGNO(01844)
                     "warning: crypto for '%s' was already initialised, "
                     "using existing configuration", conf->library);
             rv = APR_SUCCESS;
         }
         if (APR_SUCCESS != rv && err) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(01845)
                     "%s", err->msg);
             return rv;
         }
         if (APR_ENOTIMPL == rv) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(01846)
                     "The crypto library '%s' could not be found",
                     conf->library);
             return rv;
         }
         if (APR_SUCCESS != rv || !driver) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(01847)
                     "The crypto library '%s' could not be loaded",
                     conf->library);
             return rv;
@@ -453,13 +453,13 @@ static int session_crypto_init(apr_pool_t *p, apr_pool_t *plog,
 
         rv = apr_crypto_make(&f, driver, conf->params, p);
         if (APR_SUCCESS != rv) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(01848)
                     "The crypto library '%s' could not be initialised",
                     conf->library);
             return rv;
         }
 
-        ap_log_error(APLOG_MARK, APLOG_INFO, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_INFO, rv, s, APLOGNO(01849)
                 "The crypto library '%s' was loaded successfully",
                 conf->library);
 
diff --git a/modules/session/mod_session_dbd.c b/modules/session/mod_session_dbd.c
index 8e8e2f0..a1fbdc7 100644
--- a/modules/session/mod_session_dbd.c
+++ b/modules/session/mod_session_dbd.c
@@ -66,7 +66,7 @@ static apr_status_t dbd_init(request_rec *r, const char *query, ap_dbd_t **dbdp,
         session_dbd_prepare_fn = APR_RETRIEVE_OPTIONAL_FN(ap_dbd_prepare);
         session_dbd_acquire_fn = APR_RETRIEVE_OPTIONAL_FN(ap_dbd_acquire);
         if (!session_dbd_prepare_fn || !session_dbd_acquire_fn) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01850)
                           "You must load mod_dbd to enable AuthDBD functions");
             return APR_EGENERAL;
         }
@@ -74,14 +74,14 @@ static apr_status_t dbd_init(request_rec *r, const char *query, ap_dbd_t **dbdp,
 
     dbd = session_dbd_acquire_fn(r);
     if (!dbd) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01851)
                       "failed to acquire database connection");
         return APR_EGENERAL;
     }
 
     statement = apr_hash_get(dbd->prepared, query, APR_HASH_KEY_STRING);
     if (!statement) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01852)
                       "failed to find the prepared statement called '%s'", query);
         return APR_EGENERAL;
     }
@@ -109,7 +109,7 @@ static apr_status_t dbd_load(request_rec * r, const char *key, const char **val)
                                                       &session_dbd_module);
 
     if (conf->selectlabel == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01853)
                       "no SessionDBDselectlabel has been specified");
         return APR_EGENERAL;
     }
@@ -121,7 +121,7 @@ static apr_status_t dbd_load(request_rec * r, const char *key, const char **val)
     rv = apr_dbd_pvbselect(dbd->driver, r->pool, dbd->handle, &res, statement,
                           0, key, &expiry, NULL);
     if (rv) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01854)
                       "query execution error saving session '%s' "
                       "in database using query '%s': %s", key, conf->selectlabel,
                       apr_dbd_error(dbd->driver, dbd->handle, rv));
@@ -131,7 +131,7 @@ static apr_status_t dbd_load(request_rec * r, const char *key, const char **val)
          rv != -1;
          rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1)) {
         if (rv != 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01855)
                           "error retrieving results while saving '%s' "
                           "in database using query '%s': %s", key, conf->selectlabel,
                            apr_dbd_error(dbd->driver, dbd->handle, rv));
@@ -263,7 +263,7 @@ static apr_status_t dbd_save(request_rec * r, const char *key, const char *val,
                                                       &session_dbd_module);
 
     if (conf->updatelabel == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01856)
                       "no SessionDBDupdatelabel has been specified");
         return APR_EGENERAL;
     }
@@ -275,7 +275,7 @@ static apr_status_t dbd_save(request_rec * r, const char *key, const char *val,
     rv = apr_dbd_pvbquery(dbd->driver, r->pool, dbd->handle, &rows, statement,
                           val, &expiry, key, NULL);
     if (rv) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01857)
                       "query execution error updating session '%s' "
                       "using database query '%s': %s", key, conf->updatelabel,
                       apr_dbd_error(dbd->driver, dbd->handle, rv));
@@ -291,7 +291,7 @@ static apr_status_t dbd_save(request_rec * r, const char *key, const char *val,
     }
 
     if (conf->insertlabel == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01858)
                       "no SessionDBDinsertlabel has been specified");
         return APR_EGENERAL;
     }
@@ -303,7 +303,7 @@ static apr_status_t dbd_save(request_rec * r, const char *key, const char *val,
     rv = apr_dbd_pvbquery(dbd->driver, r->pool, dbd->handle, &rows, statement,
                           val, &expiry, key, NULL);
     if (rv) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01859)
                       "query execution error inserting session '%s' "
                       "in database with '%s': %s", key, conf->insertlabel,
                       apr_dbd_error(dbd->driver, dbd->handle, rv));
@@ -318,7 +318,7 @@ static apr_status_t dbd_save(request_rec * r, const char *key, const char *val,
         return APR_SUCCESS;
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01860)
                   "the session insert query did not cause any rows to be added "
                   "to the database for session '%s', session not inserted", key);
 
@@ -340,14 +340,14 @@ static apr_status_t dbd_remove(request_rec * r, const char *key)
                                                       &session_dbd_module);
     ap_dbd_t *dbd = session_dbd_acquire_fn(r);
     if (dbd == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01861)
                       "failed to acquire database connection to remove "
                       "session with key '%s'", key);
         return APR_EGENERAL;
     }
 
     if (conf->deletelabel == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01862)
                       "no SessionDBDdeletelabel has been specified");
         return APR_EGENERAL;
     }
@@ -355,7 +355,7 @@ static apr_status_t dbd_remove(request_rec * r, const char *key)
     statement = apr_hash_get(dbd->prepared, conf->deletelabel,
                              APR_HASH_KEY_STRING);
     if (statement == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01863)
                       "prepared statement could not be found for "
                       "SessionDBDdeletelabel with the label '%s'",
                       conf->deletelabel);
@@ -364,7 +364,7 @@ static apr_status_t dbd_remove(request_rec * r, const char *key)
     rv = apr_dbd_pvbquery(dbd->driver, r->pool, dbd->handle, &rows, statement,
                           key, NULL);
     if (rv != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01864)
                       "query execution error removing session '%s' "
                       "from database", key);
         return rv;
@@ -461,7 +461,7 @@ static apr_status_t session_dbd_save(request_rec * r, session_rec * z)
             return OK;
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01865)
                "peruser sessions can only be saved if a user is logged in, "
                           "session not saved: %s", r->uri);
         }
diff --git a/modules/ssl/mod_ssl.c b/modules/ssl/mod_ssl.c
index 424a8f6..ad8d06e 100644
--- a/modules/ssl/mod_ssl.c
+++ b/modules/ssl/mod_ssl.c
@@ -360,7 +360,7 @@ int ssl_proxy_enable(conn_rec *c)
     sc = mySrvConfig(sslconn->server);
 
     if (!sc->proxy_enabled) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(01961)
                       "SSL Proxy requested for %s but not enabled "
                       "[Hint: SSLProxyEngine]", sc->vhost_id);
 
@@ -424,7 +424,7 @@ int ssl_init_ssl_connection(conn_rec *c, request_rec *r)
      * so we can detach later.
      */
     if (!(ssl = SSL_new(mctx->ssl_ctx))) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(01962)
                       "Unable to create a new SSL connection from the SSL "
                       "context");
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, server);
@@ -440,7 +440,7 @@ int ssl_init_ssl_connection(conn_rec *c, request_rec *r)
     if (!SSL_set_session_id_context(ssl, (unsigned char *)vhost_md5,
                                     APR_MD5_DIGESTSIZE*2))
     {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(01963)
                       "Unable to set session id context to '%s'", vhost_md5);
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, server);
 
@@ -528,7 +528,7 @@ static int ssl_hook_pre_connection(conn_rec *c, void *csd)
      * later access inside callback functions
      */
 
-    ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,
+    ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(01964)
                   "Connection to child %ld established "
                   "(server %s)", c->id, sc->vhost_id);
 
diff --git a/modules/ssl/ssl_engine_init.c b/modules/ssl/ssl_engine_init.c
index b539c23..ba801d7 100644
--- a/modules/ssl/ssl_engine_init.c
+++ b/modules/ssl/ssl_engine_init.c
@@ -46,7 +46,7 @@ static void ssl_add_version_components(apr_pool_t *p,
 
     ap_add_version_component(p, libver);
 
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01876)
                  "%s compiled against Server: %s, Library: %s",
                  modver, AP_SERVER_BASEVERSION, incver);
 }
@@ -83,7 +83,7 @@ static int ssl_tmp_key_init_rsa(server_rec *s,
 
     if (FIPS_mode() && bits < 1024) {
         mc->pTmpKeys[idx] = NULL;
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01877)
                      "Init: Skipping generating temporary "
                      "%d bit RSA private key in FIPS mode", bits);
         return OK;
@@ -99,7 +99,7 @@ static int ssl_tmp_key_init_rsa(server_rec *s,
           || !BN_set_word(bn_f4, RSA_F4)
           || !RSA_generate_key_ex(tkey, bits, bn_f4, NULL))
         {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01878)
                          "Init: Failed to generate temporary "
                          "%d bit RSA private key", bits);
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, s);
@@ -112,7 +112,7 @@ static int ssl_tmp_key_init_rsa(server_rec *s,
     if (!(mc->pTmpKeys[idx] =
           RSA_generate_key(bits, RSA_F4, NULL, NULL)))
     {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01879)
                      "Init: Failed to generate temporary "
                      "%d bit RSA private key", bits);
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, s);
@@ -132,7 +132,7 @@ static int ssl_tmp_key_init_dh(server_rec *s,
 
     if (FIPS_mode() && bits < 1024) {
         mc->pTmpKeys[idx] = NULL;
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01880)
                      "Init: Skipping generating temporary "
                      "%d bit DH parameters in FIPS mode", bits);
         return OK;
@@ -143,7 +143,7 @@ static int ssl_tmp_key_init_dh(server_rec *s,
     if (!(mc->pTmpKeys[idx] =
           ssl_dh_GetTmpParam(bits)))
     {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01881)
                      "Init: Failed to generate temporary "
                      "%d bit DH parameters", bits);
         return !OK;
@@ -191,7 +191,7 @@ int ssl_init_Module(apr_pool_t *p, apr_pool_t *plog,
     server_rec *s;
 
     if (SSLeay() < SSL_LIBRARY_VERSION) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, base_server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, base_server, APLOGNO(01882)
                      "Init: this version of mod_ssl was compiled against "
                      "a newer library (%s, version currently loaded is %s)"
                      " - may result in undefined or erroneous behavior",
@@ -278,7 +278,7 @@ int ssl_init_Module(apr_pool_t *p, apr_pool_t *plog,
     ssl_init_Engine(base_server, p);
 #endif
 
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01883)
                  "Init: Initialized %s library", SSL_LIBRARY_NAME);
 
     /*
@@ -292,18 +292,18 @@ int ssl_init_Module(apr_pool_t *p, apr_pool_t *plog,
     if(sc->fips) {
         if (!FIPS_mode()) {
             if (FIPS_mode_set(1)) {
-                ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s, APLOGNO(01884)
                              "Operating in SSL FIPS mode");
             }
             else {
-                ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, "FIPS mode failed");
+                ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01885) "FIPS mode failed");
                 ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
                 ssl_die();
             }
         }
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s, APLOGNO(01886)
                      "SSL FIPS mode disabled");
     }
 #endif
@@ -338,7 +338,7 @@ int ssl_init_Module(apr_pool_t *p, apr_pool_t *plog,
     /*
      *  initialize servers
      */
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, base_server,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, base_server, APLOGNO(01887)
                  "Init: Initializing (virtual) servers for SSL");
 
     for (s = base_server; s; s = s->next) {
@@ -383,7 +383,7 @@ void ssl_init_Engine(server_rec *s, apr_pool_t *p)
 
     if (mc->szCryptoDevice) {
         if (!(e = ENGINE_by_id(mc->szCryptoDevice))) {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01888)
                          "Init: Failed to load Crypto Device API `%s'",
                          mc->szCryptoDevice);
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
@@ -395,13 +395,13 @@ void ssl_init_Engine(server_rec *s, apr_pool_t *p)
         }
 
         if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01889)
                          "Init: Failed to enable Crypto Device API `%s'",
                          mc->szCryptoDevice);
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
             ssl_die();
         }
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01890)
                      "Init: loaded Crypto Device API `%s'",
                      mc->szCryptoDevice);
 
@@ -420,7 +420,7 @@ static void ssl_init_server_check(server_rec *s,
      * possibility that the user forgot to set them.
      */
     if (!mctx->pks->cert_files[0] && !mctx->pkcs7) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01891)
                 "No SSL Certificate set [hint: SSLCertificateFile]");
         ssl_die();
     }
@@ -435,7 +435,7 @@ static void ssl_init_server_check(server_rec *s,
 #endif
         )
     {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01892)
                 "Illegal attempt to re-initialise SSL for server "
                 "(SSLEngine On should go in the VirtualHost, not in global scope.)");
         ssl_die();
@@ -451,7 +451,7 @@ static void ssl_init_ctx_tls_extensions(server_rec *s,
     /*
      * Configure TLS extensions support
      */
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01893)
                  "Configuring TLS extension handling");
 
     /*
@@ -460,7 +460,7 @@ static void ssl_init_ctx_tls_extensions(server_rec *s,
     if (!SSL_CTX_set_tlsext_servername_callback(mctx->ssl_ctx,
                           ssl_callback_ServerNameIndication) ||
         !SSL_CTX_set_tlsext_servername_arg(mctx->ssl_ctx, mctx)) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01894)
                      "Unable to initialize TLS servername extension "
                      "callback (incompatible OpenSSL version?)");
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
@@ -650,7 +650,7 @@ static void ssl_init_ctx_verify(server_rec *s,
                                            mctx->auth.ca_cert_file,
                                            mctx->auth.ca_cert_path))
         {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01895)
                     "Unable to configure verify locations "
                     "for client authentication");
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
@@ -666,7 +666,7 @@ static void ssl_init_ctx_verify(server_rec *s,
                                           mctx->auth.ca_cert_file,
                                           mctx->auth.ca_cert_path);
         if (sk_X509_NAME_num(ca_list) <= 0) {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01896)
                     "Unable to determine list of acceptable "
                     "CA certificates for client authentication");
             ssl_die();
@@ -683,7 +683,7 @@ static void ssl_init_ctx_verify(server_rec *s,
         ca_list = SSL_CTX_get_client_CA_list(ctx);
 
         if (sk_X509_NAME_num(ca_list) == 0) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(01897)
                          "Init: Oops, you want to request client "
                          "authentication, but no CAs are known for "
                          "verification!?  [Hint: SSLCACertificate*]");
@@ -711,7 +711,7 @@ static void ssl_init_ctx_cipher_suite(server_rec *s,
                  suite);
 
     if (!SSL_CTX_set_cipher_list(ctx, suite)) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01898)
                 "Unable to configure permitted SSL ciphers");
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
         ssl_die();
@@ -734,7 +734,7 @@ static void ssl_init_ctx_crl(server_rec *s,
     if (!(mctx->crl_file || mctx->crl_path)) {
         if (mctx->crl_check_mode == SSL_CRLCHECK_LEAF ||
             mctx->crl_check_mode == SSL_CRLCHECK_CHAIN) {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01899)
                          "Host %s: CRL checking has been enabled, but "
                          "neither %sCARevocationFile nor %sCARevocationPath "
                          "is configured", mctx->sc->vhost_id, cfgp, cfgp);
@@ -743,12 +743,12 @@ static void ssl_init_ctx_crl(server_rec *s,
         return;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01900)
                  "Configuring certificate revocation facility");
 
     if (!store || !X509_STORE_load_locations(store, mctx->crl_file,
                                              mctx->crl_path)) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01901)
                      "Host %s: unable to configure X.509 CRL storage "
                      "for certificate revocation", mctx->sc->vhost_id);
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
@@ -769,7 +769,7 @@ static void ssl_init_ctx_crl(server_rec *s,
     if (crlflags) {
         X509_STORE_set_flags(store, crlflags);
     } else {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(01902)
                      "Host %s: X.509 CRL storage locations configured, "
                      "but CRL checking (%sCARevocationCheck) is not "
                      "enabled", mctx->sc->vhost_id, cfgp);
@@ -829,12 +829,12 @@ static void ssl_init_ctx_cert_chain(server_rec *s,
                                       (char *)chain,
                                       skip_first, NULL);
     if (n < 0) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01903)
                 "Failed to configure CA certificate chain!");
         ssl_die();
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01904)
                  "Configuring server certificate chain "
                  "(%d CA certificate%s)",
                  n, n == 1 ? "" : "s");
@@ -993,7 +993,7 @@ static void ssl_check_public_cert(server_rec *s,
      */
 
     if (SSL_X509_isSGC(cert)) {
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01905)
                      "%s server certificate enables "
                      "Server Gated Cryptography (SGC)",
                      ssl_asn1_keystr(type));
@@ -1001,14 +1001,14 @@ static void ssl_check_public_cert(server_rec *s,
 
     if (SSL_X509_getBC(cert, &is_ca, &pathlen)) {
         if (is_ca) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(01906)
                          "%s server certificate is a CA certificate "
                          "(BasicConstraints: CA == TRUE !?)",
                          ssl_asn1_keystr(type));
         }
 
         if (pathlen > 0) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(01907)
                          "%s server certificate is not a leaf certificate "
                          "(BasicConstraints: pathlen == %d > 0 !?)",
                          ssl_asn1_keystr(type), pathlen);
@@ -1049,7 +1049,7 @@ static void ssl_check_public_cert(server_rec *s,
                  !strcasecmp(id[i]+1, cp)) ||
                 !strcasecmp(id[i], s->server_hostname)) {
                 matched = TRUE;
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01908)
                              "%sID '%s' in %s certificate configured "
                              "for %s matches server name",
                              is_wildcard ? "Wildcard " : "",
@@ -1060,7 +1060,7 @@ static void ssl_check_public_cert(server_rec *s,
         }
 
         if (matched == FALSE) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(01909)
                          "%s certificate configured for %s does NOT include "
                          "an ID which matches the server name",
                          ssl_asn1_keystr(type), (mySrvConfig(s))->vhost_id);
@@ -1101,7 +1101,7 @@ static void ssl_init_server_certs(server_rec *s,
         || have_ecc
 #endif
 )) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01910)
 #ifndef OPENSSL_NO_EC
                 "Oops, no RSA, DSA or ECC server certificate found "
 #else
@@ -1126,7 +1126,7 @@ static void ssl_init_server_certs(server_rec *s,
         || have_ecc
 #endif
           )) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01911)
 #ifndef OPENSSL_NO_EC
                 "Oops, no RSA, DSA or ECC server private key found?!");
 #else
@@ -1151,7 +1151,7 @@ static void ssl_init_server_certs(server_rec *s,
             }
 
             if (mctx->sc->default_ticket == NULL) {
-                ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01912)
                             "Misconfigured TLS Tickets.  Couldn't find key named '%s'",
                             mctx->sc->default_ticket_name);
                 ssl_die();
@@ -1162,7 +1162,7 @@ static void ssl_init_server_certs(server_rec *s,
         }
 
         if (!SSL_CTX_set_tlsext_ticket_key_cb(mctx->ssl_ctx, ssl_callback_tlsext_tickets)) {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01913)
                         "Unable to initialize TLS session ticket extension "
                         "(incompatible OpenSSL version?)");
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
@@ -1333,7 +1333,7 @@ void ssl_init_ConfigureServer(server_rec *s,
     /* Initialize the server if SSL is enabled or optional.
      */
     if ((sc->enabled == SSL_ENABLED_TRUE) || (sc->enabled == SSL_ENABLED_OPTIONAL)) {
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01914)
                      "Configuring server for SSL protocol");
         ssl_init_server_ctx(s, p, ptemp, sc);
     }
@@ -1362,7 +1362,7 @@ void ssl_init_CheckServers(server_rec *base_server, apr_pool_t *p)
 
         if ((sc->enabled == SSL_ENABLED_TRUE) && (s->port == DEFAULT_HTTP_PORT)) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, 0,
-                         base_server,
+                         base_server, APLOGNO(01915)
                          "Init: (%s) You configured HTTPS(%d) "
                          "on the standard HTTP(%d) port!",
                          ssl_util_vhostid(p, s),
@@ -1371,7 +1371,7 @@ void ssl_init_CheckServers(server_rec *base_server, apr_pool_t *p)
 
         if ((sc->enabled == SSL_ENABLED_FALSE) && (s->port == DEFAULT_HTTPS_PORT)) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, 0,
-                         base_server,
+                         base_server, APLOGNO(01916)
                          "Init: (%s) You configured HTTP(%d) "
                          "on the standard HTTPS(%d) port!",
                          ssl_util_vhostid(p, s),
@@ -1429,7 +1429,7 @@ void ssl_init_CheckServers(server_rec *base_server, apr_pool_t *p)
     }
 
     if (conflict) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, base_server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, base_server, APLOGNO(01917)
 #ifdef OPENSSL_NO_TLSEXT
                      "Init: You should not use name-based "
                      "virtual hosts in conjunction with SSL!!");
diff --git a/modules/ssl/ssl_engine_io.c b/modules/ssl/ssl_engine_io.c
index a1d9f6a..2ffe21f 100644
--- a/modules/ssl/ssl_engine_io.c
+++ b/modules/ssl/ssl_engine_io.c
@@ -664,7 +664,7 @@ static apr_status_t ssl_io_input_read(bio_filter_in_ctx_t *inctx,
                     continue;  /* Blocking and nothing yet?  Try again. */
                 }
                 else {
-                    ap_log_cerror(APLOG_MARK, APLOG_INFO, inctx->rc, c,
+                    ap_log_cerror(APLOG_MARK, APLOG_INFO, inctx->rc, c, APLOGNO(01991)
                                   "SSL input filter read failed.");
                 }
             }
@@ -672,7 +672,7 @@ static apr_status_t ssl_io_input_read(bio_filter_in_ctx_t *inctx,
                 /*
                  * Log SSL errors and any unexpected conditions.
                  */
-                ap_log_cerror(APLOG_MARK, APLOG_INFO, inctx->rc, c,
+                ap_log_cerror(APLOG_MARK, APLOG_INFO, inctx->rc, c, APLOGNO(01992)
                               "SSL library error %d reading data", ssl_err);
                 ssl_log_ssl_error(SSLLOG_MARK, APLOG_INFO, mySrvFromConn(c));
 
@@ -776,14 +776,14 @@ static apr_status_t ssl_filter_write(ap_filter_t *f,
             outctx->rc = APR_EAGAIN;
         }
         else if (ssl_err == SSL_ERROR_SYSCALL) {
-            ap_log_cerror(APLOG_MARK, APLOG_INFO, outctx->rc, c,
+            ap_log_cerror(APLOG_MARK, APLOG_INFO, outctx->rc, c, APLOGNO(01993)
                           "SSL output filter write failed.");
         }
         else /* if (ssl_err == SSL_ERROR_SSL) */ {
             /*
              * Log SSL errors
              */
-            ap_log_cerror(APLOG_MARK, APLOG_INFO, outctx->rc, c,
+            ap_log_cerror(APLOG_MARK, APLOG_INFO, outctx->rc, c, APLOGNO(01994)
                           "SSL library error %d writing data", ssl_err);
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_INFO, mySrvFromConn(c));
         }
@@ -800,7 +800,7 @@ static apr_status_t ssl_filter_write(ap_filter_t *f,
             reason = "likely due to failed renegotiation";
         }
 
-        ap_log_cerror(APLOG_MARK, APLOG_INFO, outctx->rc, c,
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, outctx->rc, c, APLOGNO(01995)
                       "failed to write %" APR_SSIZE_T_FMT
                       " of %" APR_SIZE_T_FMT " bytes (%s)",
                       len - (apr_size_t)res, len, reason);
@@ -852,7 +852,7 @@ static apr_status_t ssl_io_filter_error(ap_filter_t *f,
     switch (status) {
     case MODSSL_ERROR_HTTP_ON_HTTPS:
             /* log the situation */
-            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c,
+            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c, APLOGNO(01996)
                          "SSL handshake failed: HTTP spoken on HTTPS port; "
                          "trying to send HTML error page");
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_INFO, sslconn->server);
@@ -868,7 +868,7 @@ static apr_status_t ssl_io_filter_error(ap_filter_t *f,
         bucket = ap_bucket_error_create(HTTP_BAD_REQUEST, NULL,
                                         f->c->pool,
                                         f->c->bucket_alloc);
-        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c,
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c, APLOGNO(01997)
                       "SSL handshake failed: sending 502");
         break;
 
@@ -900,6 +900,7 @@ static void ssl_filter_io_shutdown(ssl_filter_ctx_t *filter_ctx,
     SSLConnRec *sslconn = myConnConfig(c);
     int shutdown_type;
     int loglevel = APLOG_DEBUG;
+    const char *logno;
 
     if (!ssl) {
         return;
@@ -944,6 +945,7 @@ static void ssl_filter_io_shutdown(ssl_filter_ctx_t *filter_ctx,
     if (abortive) {
         shutdown_type = SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN;
         type = "abortive";
+        logno = APLOGNO(01998);
         loglevel = APLOG_INFO;
     }
     else switch (sslconn->shutdown_type) {
@@ -952,12 +954,14 @@ static void ssl_filter_io_shutdown(ssl_filter_ctx_t *filter_ctx,
            (violates the SSL/TLS standard!) */
         shutdown_type = SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN;
         type = "unclean";
+        logno = APLOGNO(01999);
         break;
       case SSL_SHUTDOWN_TYPE_ACCURATE:
         /* send close notify and wait for clients close notify
            (standard compliant, but usually causes connection hangs) */
         shutdown_type = 0;
         type = "accurate";
+        logno = APLOGNO(02000);
         break;
       default:
         /*
@@ -968,6 +972,7 @@ static void ssl_filter_io_shutdown(ssl_filter_ctx_t *filter_ctx,
            (standard compliant and safe, so it's the DEFAULT!) */
         shutdown_type = SSL_RECEIVED_SHUTDOWN;
         type = "standard";
+        logno = APLOGNO(02001);
         break;
     }
 
@@ -977,9 +982,9 @@ static void ssl_filter_io_shutdown(ssl_filter_ctx_t *filter_ctx,
     /* and finally log the fact that we've closed the connection */
     if (APLOG_CS_IS_LEVEL(c, mySrvFromConn(c), loglevel)) {
         ap_log_cserror(APLOG_MARK, loglevel, 0, c, mySrvFromConn(c),
-                       "Connection closed to child %ld with %s shutdown "
+                       "%sConnection closed to child %ld with %s shutdown "
                        "(server %s)",
-                       c->id, type,
+                       logno, c->id, type,
                        ssl_util_vhostid(c->pool, mySrvFromConn(c)));
     }
 
@@ -1064,7 +1069,7 @@ static apr_status_t ssl_io_filter_handshake(ssl_filter_ctx_t *filter_ctx)
                               "SNI extension for SSL Proxy request set to '%s'",
                               hostname_note);
             } else {
-                ap_log_cerror(APLOG_MARK, APLOG_WARNING, 0, c,
+                ap_log_cerror(APLOG_MARK, APLOG_WARNING, 0, c, APLOGNO(02002)
                               "Failed to set SNI extension for SSL Proxy "
                               "request to '%s'", hostname_note);
                 ssl_log_ssl_error(SSLLOG_MARK, APLOG_WARNING, server);
@@ -1073,7 +1078,7 @@ static apr_status_t ssl_io_filter_handshake(ssl_filter_ctx_t *filter_ctx)
 #endif
 
         if ((n = SSL_connect(filter_ctx->pssl)) <= 0) {
-            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,
+            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(02003)
                           "SSL Proxy connect failed");
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_INFO, server);
             /* ensure that the SSL structures etc are freed, etc: */
@@ -1089,7 +1094,7 @@ static apr_status_t ssl_io_filter_handshake(ssl_filter_ctx_t *filter_ctx)
                      X509_get_notBefore(cert)) >= 0)
                 || (X509_cmp_current_time(
                      X509_get_notAfter(cert)) <= 0)) {
-                ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,
+                ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(02004)
                               "SSL Proxy: Peer certificate is expired");
                 if (cert) {
                     X509_free(cert);
@@ -1109,7 +1114,7 @@ static apr_status_t ssl_io_filter_handshake(ssl_filter_ctx_t *filter_ctx)
                                       "SSL_CLIENT_S_DN_CN");
             apr_table_unset(c->notes, "proxy-request-hostname");
             if (strcasecmp(hostname, hostname_note)) {
-                ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,
+                ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(02005)
                               "SSL Proxy: Peer certificate CN mismatch:"
                               " Certificate CN: %s Requested hostname: %s",
                               hostname, hostname_note);
@@ -1138,7 +1143,7 @@ static apr_status_t ssl_io_filter_handshake(ssl_filter_ctx_t *filter_ctx)
              * was transferred. That's not a real error and can occur
              * sporadically with some clients.
              */
-            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, c,
+            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, c, APLOGNO(02006)
                          "SSL handshake stopped: connection was closed");
         }
         else if (ssl_err == SSL_ERROR_WANT_READ) {
@@ -1161,7 +1166,7 @@ static apr_status_t ssl_io_filter_handshake(ssl_filter_ctx_t *filter_ctx)
             return MODSSL_ERROR_HTTP_ON_HTTPS;
         }
         else if (ssl_err == SSL_ERROR_SYSCALL) {
-            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rc, c,
+            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rc, c, APLOGNO(02007)
                           "SSL handshake interrupted by system "
                           "[Hint: Stop button pressed in browser?!]");
         }
@@ -1169,7 +1174,7 @@ static apr_status_t ssl_io_filter_handshake(ssl_filter_ctx_t *filter_ctx)
             /*
              * Log SSL errors and any unexpected conditions.
              */
-            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, c,
+            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, c, APLOGNO(02008)
                           "SSL library error %d in handshake "
                           "(server %s)", ssl_err,
                           ssl_util_vhostid(c->pool, server));
@@ -1204,7 +1209,7 @@ static apr_status_t ssl_io_filter_handshake(ssl_filter_ctx_t *filter_ctx)
              * optional_no_ca doesn't appear to work as advertised
              * in 1.x
              */
-            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,
+            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(02009)
                           "SSL client authentication failed, "
                           "accepting certificate based on "
                           "\"SSLVerifyClient optional_no_ca\" "
@@ -1216,7 +1221,7 @@ static apr_status_t ssl_io_filter_handshake(ssl_filter_ctx_t *filter_ctx)
                 sslconn->verify_error :
                 X509_verify_cert_error_string(verify_result);
 
-            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,
+            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(02010)
                          "SSL client authentication failed: %s",
                          error ? error : "unknown");
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_INFO, server);
@@ -1244,7 +1249,7 @@ static apr_status_t ssl_io_filter_handshake(ssl_filter_ctx_t *filter_ctx)
     if ((sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE) &&
         !sslconn->client_cert)
     {
-        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c, APLOGNO(02011)
                       "No acceptable peer certificate available");
 
         ssl_filter_io_shutdown(filter_ctx, c, 1);
@@ -1447,7 +1452,7 @@ static apr_status_t ssl_io_filter_coalesce(ap_filter_t *f,
 
             if (APR_BUCKET_IS_METADATA(e)
                 || e->length == (apr_size_t)-1) {
-                ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c,
+                ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c, APLOGNO(02012)
                               "unexpected bucket type during coalesce");
                 break; /* non-fatal error; break out */
             }
@@ -1460,7 +1465,7 @@ static apr_status_t ssl_io_filter_coalesce(ap_filter_t *f,
                  * non-block/flush/block.  */
                 rv = apr_bucket_read(e, &data, &len, APR_BLOCK_READ);
                 if (rv) {
-                    ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, f->c,
+                    ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, f->c, APLOGNO(02013)
                                   "coalesce failed to read from data bucket");
                     return AP_FILTER_ERROR;
                 }
@@ -1468,7 +1473,7 @@ static apr_status_t ssl_io_filter_coalesce(ap_filter_t *f,
                 /* Be paranoid. */
                 if (len > sizeof ctx->buffer
                     || (len + ctx->bytes > sizeof ctx->buffer)) {
-                    ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c,
+                    ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c, APLOGNO(02014)
                                   "unexpected coalesced bucket data length");
                     break; /* non-fatal error; break out */
                 }
@@ -1650,7 +1655,7 @@ int ssl_io_buffer_fill(request_rec *r, apr_size_t maxlen)
         rv = ap_get_brigade(r->proto_input_filters, tempb, AP_MODE_READBYTES,
                             APR_BLOCK_READ, 8192);
         if (rv) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02015)
                           "could not read request body for SSL buffer");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -1669,7 +1674,7 @@ int ssl_io_buffer_fill(request_rec *r, apr_size_t maxlen)
             } else if (!APR_BUCKET_IS_METADATA(e)) {
                 rv = apr_bucket_read(e, &data, &len, APR_BLOCK_READ);
                 if (rv != APR_SUCCESS) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02016)
                                   "could not read bucket for SSL buffer");
                     return HTTP_INTERNAL_SERVER_ERROR;
                 }
@@ -1678,7 +1683,7 @@ int ssl_io_buffer_fill(request_rec *r, apr_size_t maxlen)
 
             rv = apr_bucket_setaside(e, r->pool);
             if (rv != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02017)
                               "could not setaside bucket for SSL buffer");
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
@@ -1693,7 +1698,7 @@ int ssl_io_buffer_fill(request_rec *r, apr_size_t maxlen)
 
         /* Fail if this exceeds the maximum buffer size. */
         if (total > maxlen) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02018)
                           "request body exceeds maximum size (%" APR_SIZE_T_FMT
                           ") for SSL buffer", maxlen);
             return HTTP_REQUEST_ENTITY_TOO_LARGE;
@@ -1759,7 +1764,7 @@ static apr_status_t ssl_io_filter_buffer(ap_filter_t *f,
         /* Partition the buffered brigade. */
         rv = apr_brigade_partition(ctx->bb, bytes, &e);
         if (rv && rv != APR_INCOMPLETE) {
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, f->c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, f->c, APLOGNO(02019)
                           "could not partition buffered SSL brigade");
             ap_remove_input_filter(f);
             return rv;
@@ -1789,7 +1794,7 @@ static apr_status_t ssl_io_filter_buffer(ap_filter_t *f,
         rv = apr_brigade_split_line(bb, ctx->bb, block, bytes);
 
         if (rv) {
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, f->c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, f->c, APLOGNO(02020)
                           "could not split line from buffered SSL brigade");
             ap_remove_input_filter(f);
             return rv;
diff --git a/modules/ssl/ssl_engine_kernel.c b/modules/ssl/ssl_engine_kernel.c
index cd003f0..297b446 100644
--- a/modules/ssl/ssl_engine_kernel.c
+++ b/modules/ssl/ssl_engine_kernel.c
@@ -48,7 +48,7 @@ static apr_status_t upgrade_connection(request_rec *r)
     apr_status_t rv;
     SSL *ssl;
 
-    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02028)
                   "upgrading connection to TLS");
 
     bb = apr_brigade_create(r->pool, conn->bucket_alloc);
@@ -62,7 +62,7 @@ static apr_status_t upgrade_connection(request_rec *r)
     }
 
     if (rv) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02029)
                       "failed to send 101 interim response for connection "
                       "upgrade");
         return rv;
@@ -78,7 +78,7 @@ static apr_status_t upgrade_connection(request_rec *r)
     SSL_do_handshake(ssl);
 
     if (SSL_get_state(ssl) != SSL_ST_OK) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02030)
                       "TLS upgrade handshake failed: not accepted by client!?");
 
         return APR_ECONNABORTED;
@@ -193,7 +193,7 @@ int ssl_hook_ReadReq(request_rec *r)
          * with either no hostname or a different hostname.
          */
         if (!r->hostname) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(02031)
                         "Hostname %s provided via SNI, but no hostname"
                         " provided in HTTP request", servername);
             return HTTP_BAD_REQUEST;
@@ -203,7 +203,7 @@ int ssl_hook_ReadReq(request_rec *r)
             return HTTP_BAD_REQUEST;
         }
         if (strcasecmp(host, servername)) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(02032)
                         "Hostname %s provided via SNI and hostname %s provided"
                         " via HTTP are different", servername, host);
             return HTTP_BAD_REQUEST;
@@ -220,7 +220,7 @@ int ssl_hook_ReadReq(request_rec *r)
          * server config we used for handshaking or in our current server.
          * This should avoid insecure configuration by accident.
          */
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server, APLOGNO(02033)
                      "No hostname was provided via SNI for a name based"
                      " virtual host");
         return HTTP_FORBIDDEN;
@@ -232,7 +232,7 @@ int ssl_hook_ReadReq(request_rec *r)
      * Log information about incoming HTTPS requests
      */
     if (APLOGrinfo(r) && ap_is_initial_req(r)) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02034)
                      "%s HTTPS request received for child %ld (server %s)",
                      (r->connection->keepalives <= 0 ?
                      "Initial (No.1)" :
@@ -996,7 +996,7 @@ int ssl_hook_UserCheck(request_rec *r)
             password = auth_line;
 
             if ((username[0] == '/') && strEQ(password, "password")) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02035)
                     "Encountered FakeBasicAuth spoof: %s", username);
                 return HTTP_FORBIDDEN;
             }
@@ -1044,7 +1044,7 @@ int ssl_hook_UserCheck(request_rec *r)
                             NULL);
     apr_table_setn(r->headers_in, "Authorization", auth_line);
 
-    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02036)
                   "Faking HTTP Basic Auth header: \"Authorization: %s\"",
                   auth_line);
 
@@ -1457,7 +1457,7 @@ int ssl_callback_SSLVerify(int ok, X509_STORE_CTX *ctx)
     if (ssl_verify_error_is_optional(errnum) &&
         (verify == SSL_CVERIFY_OPTIONAL_NO_CA))
     {
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, conn,
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, conn, APLOGNO(02037)
                       "Certificate Verification: Verifiable Issuer is "
                       "configured as optional, therefore we're accepting "
                       "the certificate");
@@ -1493,7 +1493,7 @@ int ssl_callback_SSLVerify(int ok, X509_STORE_CTX *ctx)
         if (ssl_verify_error_is_optional(errnum)) {
             X509_STORE_CTX_set_error(ctx, X509_V_ERR_APPLICATION_VERIFICATION);
             errnum = X509_V_ERR_APPLICATION_VERIFICATION;
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, conn,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, conn, APLOGNO(02038)
                           "cannot perform OCSP validation for cert "
                           "if issuer has not been verified "
                           "(optional_no_ca configured)");
@@ -1517,7 +1517,7 @@ int ssl_callback_SSLVerify(int ok, X509_STORE_CTX *ctx)
                             "Certificate Verification: Error (%d): %s",
                             errnum, X509_verify_cert_error_string(errnum));
         } else {
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, conn,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, conn, APLOGNO(02039)
                           "Certificate Verification: Error (%d): %s",
                           errnum, X509_verify_cert_error_string(errnum));
         }
@@ -1541,7 +1541,7 @@ int ssl_callback_SSLVerify(int ok, X509_STORE_CTX *ctx)
     }
 
     if (errdepth > depth) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, conn,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, conn, APLOGNO(02040)
                       "Certificate Verification: Certificate Chain too long "
                       "(chain has %d certificates, but maximum allowed are "
                       "only %d)",
@@ -1875,7 +1875,7 @@ static void log_tracing_state(const SSL *ssl, conn_rec *c,
      * right after a finished handshake.
      */
     if (where & SSL_CB_HANDSHAKE_DONE) {
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(02041)
                       "Connection: Client IP: %s, Protocol: %s, "
                       "Cipher: %s (%s/%s bits)",
                       ssl_var_lookup(NULL, s, c, NULL, "REMOTE_ADDR"),
@@ -1916,7 +1916,7 @@ void ssl_callback_Info(const SSL *ssl, int where, int rc)
         if (state == SSL3_ST_SR_CLNT_HELLO_A
             || state == SSL23_ST_SR_CLNT_HELLO_A) {
             scr->reneg_state = RENEG_ABORT;
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(02042)
                           "rejecting client initiated renegotiation");
         }
     }
@@ -1947,13 +1947,13 @@ int ssl_callback_ServerNameIndication(SSL *ssl, int *al, modssl_ctx_t *mctx)
         if (c) {
             if (ap_vhost_iterate_given_conn(c, ssl_find_vhost,
                                             (void *)servername)) {
-                ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+                ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(02043)
                               "SSL virtual host for servername %s found",
                               servername);
                 return SSL_TLSEXT_ERR_OK;
             }
             else {
-                ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+                ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(02044)
                               "No matching SSL virtual host for servername "
                               "%s found (using default/first virtual host)",
                               servername);
diff --git a/modules/ssl/ssl_engine_log.c b/modules/ssl/ssl_engine_log.c
index 31861ca..271ecc5 100644
--- a/modules/ssl/ssl_engine_log.c
+++ b/modules/ssl/ssl_engine_log.c
@@ -94,7 +94,7 @@ void ssl_log_ssl_error(const char *file, int line, int level, server_rec *s)
         annotation = ssl_log_annotation(err);
 
         ap_log_error(file, line, APLOG_MODULE_INDEX, level, 0, s,
-                     "SSL Library Error: %s%s%s%s%s%s",
+                     APLOGNO(02021) "SSL Library Error: %s%s%s%s%s%s",
                      /* %s */
                      err,
                      /* %s%s%s */
@@ -135,7 +135,7 @@ static void ssl_log_cert_error(const char *file, int line, int level,
              */
             int maxdnlen = (HUGE_STRING_LEN - msglen - 300) / 2;
 
-            BIO_puts(bio, " [subject: ");
+            BIO_puts(bio, APLOGNO(02022) " [subject: ");
             name = SSL_X509_NAME_to_string(p, X509_get_subject_name(cert),
                                            maxdnlen);
             if (!strIsEmpty(name)) {
@@ -174,7 +174,7 @@ static void ssl_log_cert_error(const char *file, int line, int level,
     }
     else {
         apr_snprintf(buf + msglen, sizeof buf - msglen,
-                     " [certificate: -not available-]");
+                     APLOGNO(02023) " [certificate: -not available-]");
     }
 
     if (r) {
diff --git a/modules/ssl/ssl_engine_mutex.c b/modules/ssl/ssl_engine_mutex.c
index c7f8582..e915a16 100644
--- a/modules/ssl/ssl_engine_mutex.c
+++ b/modules/ssl/ssl_engine_mutex.c
@@ -72,11 +72,11 @@ int ssl_mutex_reinit(server_rec *s, apr_pool_t *p)
                                           lockfile,
                                           p)) != APR_SUCCESS) {
         if (lockfile)
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(02024)
                          "Cannot reinit %s mutex with file `%s'",
                          SSL_CACHE_MUTEX_TYPE, lockfile);
         else
-            ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s, APLOGNO(02025)
                          "Cannot reinit %s mutex", SSL_CACHE_MUTEX_TYPE);
         return FALSE;
     }
@@ -89,7 +89,7 @@ int ssl_mutex_on(server_rec *s)
     apr_status_t rv;
 
     if ((rv = apr_global_mutex_lock(mc->pMutex)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s, APLOGNO(02026)
                      "Failed to acquire SSL session cache lock");
         return FALSE;
     }
@@ -102,7 +102,7 @@ int ssl_mutex_off(server_rec *s)
     apr_status_t rv;
 
     if ((rv = apr_global_mutex_unlock(mc->pMutex)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s, APLOGNO(02027)
                      "Failed to release SSL session cache lock");
         return FALSE;
     }
diff --git a/modules/ssl/ssl_engine_ocsp.c b/modules/ssl/ssl_engine_ocsp.c
index b6920bf..4c22b18 100644
--- a/modules/ssl/ssl_engine_ocsp.c
+++ b/modules/ssl/ssl_engine_ocsp.c
@@ -73,7 +73,7 @@ static apr_uri_t *determine_responder_uri(SSLSrvConfigRec *sc, X509 *cert,
     }
 
     if (s == NULL) {
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01918)
                       "no OCSP responder specified in certificate and "
                       "no default configured");
         return NULL;
@@ -81,13 +81,13 @@ static apr_uri_t *determine_responder_uri(SSLSrvConfigRec *sc, X509 *cert,
 
     rv = apr_uri_parse(p, s, u);
     if (rv || !u->hostname) {
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c,
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(01919)
                       "failed to parse OCSP responder URI '%s'", s);
         return NULL;
     }
 
     if (strcasecmp(u->scheme, "http") != 0) {
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c,
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(01920)
                       "cannot handle OCSP responder URI '%s'", s);
         return NULL;
     }
@@ -111,7 +111,7 @@ static OCSP_REQUEST *create_request(X509_STORE_CTX *ctx, X509 *cert,
     *certid = OCSP_cert_to_id(NULL, cert, ctx->current_issuer);
     if (!*certid || !OCSP_request_add0_id(req, *certid)) {
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, s);
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01921)
                      "could not retrieve certificate id");
         return NULL;
     }
@@ -155,7 +155,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
         int r = OCSP_response_status(response);
 
         if (r != OCSP_RESPONSE_STATUS_SUCCESSFUL) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01922)
                          "OCSP response not successful: %d", rc);
             rc = V_OCSP_CERTSTATUS_UNKNOWN;
         }
@@ -165,7 +165,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
         basicResponse = OCSP_response_get1_basic(response);
         if (!basicResponse) {
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, s);
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(01923)
                           "could not retrieve OCSP basic response");
             rc = V_OCSP_CERTSTATUS_UNKNOWN;
         }
@@ -173,7 +173,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
 
     if (rc == V_OCSP_CERTSTATUS_GOOD) {
         if (OCSP_check_nonce(request, basicResponse) != 1) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01924)
                         "Bad OCSP responder answer (bad nonce)");
             rc = V_OCSP_CERTSTATUS_UNKNOWN;
         }
@@ -183,7 +183,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
         /* TODO: allow flags configuration. */
         if (OCSP_basic_verify(basicResponse, NULL, ctx->ctx, 0) != 1) {
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, s);
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01925)
                         "failed to verify the OCSP response");
             rc = V_OCSP_CERTSTATUS_UNKNOWN;
         }
diff --git a/modules/ssl/ssl_engine_pphrase.c b/modules/ssl/ssl_engine_pphrase.c
index ca26e24..b71e686 100644
--- a/modules/ssl/ssl_engine_pphrase.c
+++ b/modules/ssl/ssl_engine_pphrase.c
@@ -701,12 +701,12 @@ int ssl_pphrase_Handle_CB(char *buf, int bufsize, int verify, void *srv)
 
         if (sc->server->pphrase_dialog_type == SSL_PPTYPE_PIPE) {
             if (!readtty) {
-                ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01965)
                              "Init: Creating pass phrase dialog pipe child "
                              "'%s'", sc->server->pphrase_dialog_path);
                 if (ssl_pipe_child_create(p, sc->server->pphrase_dialog_path)
                         != APR_SUCCESS) {
-                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01966)
                                  "Init: Failed to create pass phrase pipe '%s'",
                                  sc->server->pphrase_dialog_path);
                     PEMerr(PEM_F_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);
@@ -714,7 +714,7 @@ int ssl_pphrase_Handle_CB(char *buf, int bufsize, int verify, void *srv)
                     return (-1);
                 }
             }
-            ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01967)
                          "Init: Requesting pass phrase via piped dialog");
         }
         else { /* sc->server->pphrase_dialog_type == SSL_PPTYPE_BUILTIN */
@@ -731,7 +731,7 @@ int ssl_pphrase_Handle_CB(char *buf, int bufsize, int verify, void *srv)
              */
             apr_file_open_stdout(&writetty, p);
 
-            ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01968)
                          "Init: Requesting pass phrase via builtin terminal "
                          "dialog");
 #endif
@@ -790,7 +790,7 @@ int ssl_pphrase_Handle_CB(char *buf, int bufsize, int verify, void *srv)
         const char **argv = apr_palloc(p, sizeof(char *) * 4);
         char *result;
 
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01969)
                      "Init: Requesting pass phrase from dialog filter "
                      "program (%s)", cmd);
 
diff --git a/modules/ssl/ssl_engine_rand.c b/modules/ssl/ssl_engine_rand.c
index d3521f5..df25d8f 100644
--- a/modules/ssl/ssl_engine_rand.c
+++ b/modules/ssl/ssl_engine_rand.c
@@ -124,7 +124,7 @@ int ssl_rand_seed(server_rec *s, apr_pool_t *p, ssl_rsctx_t nCtx, char *prefix)
                  "%sSeeding PRNG with %d bytes of entropy", prefix, nDone);
 
     if (RAND_status() == 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(01990)
                      "%sPRNG still contains insufficient entropy!", prefix);
 
     return nDone;
diff --git a/modules/ssl/ssl_engine_vars.c b/modules/ssl/ssl_engine_vars.c
index 4155bc3..0d0be67 100644
--- a/modules/ssl/ssl_engine_vars.c
+++ b/modules/ssl/ssl_engine_vars.c
@@ -895,7 +895,7 @@ apr_array_header_t *ssl_ext_list(apr_pool_t *p, conn_rec *c, int peer,
      */
     oid = OBJ_txt2obj(extension, 0);
     if (!oid) {
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01970)
                       "could not parse OID '%s'", extension);
         ERR_clear_error();
         return NULL;
@@ -931,7 +931,7 @@ apr_array_header_t *ssl_ext_list(apr_pool_t *p, conn_rec *c, int peer,
                 BIO_get_mem_ptr(bio, &buf);
                 *ptr = apr_pstrmemdup(p, buf->data, buf->length);
             } else {
-                ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+                ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01971)
                               "Found an extension '%s', but failed to "
                               "create a string from it", extension);
             }
diff --git a/modules/ssl/ssl_scache.c b/modules/ssl/ssl_scache.c
index e75c4c6..2c8d1bc 100644
--- a/modules/ssl/ssl_scache.c
+++ b/modules/ssl/ssl_scache.c
@@ -61,7 +61,7 @@ void ssl_scache_init(server_rec *s, apr_pool_t *p)
         rv = mc->stapling_cache->init(mc->stapling_cache_context,
                                      "mod_ssl-stapling", &hints, s, p);
         if (rv) {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01872)
                          "Could not initialize stapling cache. Exiting.");
             ssl_die();
         }
@@ -73,7 +73,7 @@ void ssl_scache_init(server_rec *s, apr_pool_t *p)
      * But we can operate without it, of course.
      */
     if (mc->sesscache == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(01873)
                      "Init: Session Cache is not configured "
                      "[hint: SSLSessionCache]");
         return;
@@ -86,7 +86,7 @@ void ssl_scache_init(server_rec *s, apr_pool_t *p)
 
     rv = mc->sesscache->init(mc->sesscache_context, "mod_ssl-session", &hints, s, p);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01874)
                      "Could not initialize session cache. Exiting.");
         ssl_die();
     }
@@ -120,7 +120,7 @@ BOOL ssl_scache_store(server_rec *s, UCHAR *id, int idlen,
     /* Serialise the session. */
     len = i2d_SSL_SESSION(sess, NULL);
     if (len > sizeof encoded) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01875)
                      "session is too big (%u bytes)", len);
         return FALSE;
     }
diff --git a/modules/ssl/ssl_util_ocsp.c b/modules/ssl/ssl_util_ocsp.c
index 06ff993..48700c7 100644
--- a/modules/ssl/ssl_util_ocsp.c
+++ b/modules/ssl/ssl_util_ocsp.c
@@ -68,14 +68,14 @@ static apr_socket_t *send_request(BIO *request, const apr_uri_t *uri,
 
     rv = apr_sockaddr_info_get(&sa, uri->hostname, APR_UNSPEC, uri->port, 0, p);
     if (rv) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(01972)
                       "could not resolve address of OCSP responder %s",
                       uri->hostinfo);
         return NULL;
     }
 
     /* establish a connection to the OCSP responder */
-    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01973)
                   "connecting to OCSP responder '%s'", uri->hostinfo);
 
     /* Cycle through address until a connect() succeeds. */
@@ -93,7 +93,7 @@ static apr_socket_t *send_request(BIO *request, const apr_uri_t *uri,
     }
 
     if (sa == NULL) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(01974)
                       "could not connect to OCSP responder '%s'",
                       uri->hostinfo);
         apr_socket_close(sd);
@@ -101,7 +101,7 @@ static apr_socket_t *send_request(BIO *request, const apr_uri_t *uri,
     }
 
     /* send the request and get a response */
-    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01975)
                  "sending request to OCSP responder");
 
     while ((len = BIO_read(request, buf, sizeof buf)) > 0) {
@@ -118,7 +118,7 @@ static apr_socket_t *send_request(BIO *request, const apr_uri_t *uri,
 
         if (rv) {
             apr_socket_close(sd);
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(01976)
                           "failed to send request to OCSP responder '%s'",
                           uri->hostinfo);
             return NULL;
@@ -141,20 +141,20 @@ static char *get_line(apr_bucket_brigade *bbout, apr_bucket_brigade *bbin,
 
     rv = apr_brigade_split_line(bbout, bbin, APR_BLOCK_READ, 8192);
     if (rv) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(01977)
                       "failed reading line from OCSP server");
         return NULL;
     }
 
     rv = apr_brigade_pflatten(bbout, &line, &len, p);
     if (rv) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(01978)
                       "failed reading line from OCSP server");
         return NULL;
     }
 
     if (len && line[len-1] != APR_ASCII_LF) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(01979)
                       "response header line too long from OCSP server");
         return NULL;
     }
@@ -193,7 +193,7 @@ static OCSP_RESPONSE *read_response(apr_socket_t *sd, BIO *bio, conn_rec *c,
     if (!line || strncmp(line, "HTTP/", 5)
         || (line = ap_strchr(line, ' ')) == NULL
         || (code = apr_atoi64(++line)) < 200 || code > 299) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(01980)
                       "bad response from OCSP server: %s",
                       line ? line : "(none)");
         return NULL;
@@ -205,18 +205,18 @@ static OCSP_RESPONSE *read_response(apr_socket_t *sd, BIO *bio, conn_rec *c,
     count = 0;
     while ((line = get_line(tmpbb, bb, c, p)) != NULL && line[0]
            && ++count < MAX_HEADERS) {
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01981)
                       "OCSP response header: %s", line);
     }
 
     if (count == MAX_HEADERS) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(01982)
                       "could not read response headers from OCSP server, "
                       "exceeded maximum count (%u)", MAX_HEADERS);
         return NULL;
     }
     else if (!line) {
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(01983)
                       "could not read response header from OCSP server");
         return NULL;
     }
@@ -231,23 +231,23 @@ static OCSP_RESPONSE *read_response(apr_socket_t *sd, BIO *bio, conn_rec *c,
 
         rv = apr_bucket_read(e, &data, &len, APR_BLOCK_READ);
         if (rv == APR_EOF || (rv == APR_SUCCESS && len == 0)) {
-            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01984)
                           "OCSP response: got EOF");
             break;
         }
         if (rv != APR_SUCCESS) {
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(01985)
                           "error reading response from OCSP server");
             return NULL;
         }
         count += len;
         if (count > MAX_CONTENT) {
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(01986)
                           "OCSP response size exceeds %u byte limit",
                           MAX_CONTENT);
             return NULL;
         }
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(01987)
                       "OCSP response: got %" APR_SIZE_T_FMT
                       " bytes, %" APR_SIZE_T_FMT " total", len, count);
 
@@ -263,7 +263,7 @@ static OCSP_RESPONSE *read_response(apr_socket_t *sd, BIO *bio, conn_rec *c,
     response = d2i_OCSP_RESPONSE_bio(bio, NULL);
     if (response == NULL) {
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, mySrvFromConn(c));
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(01988)
                       "failed to decode OCSP response data");
     }
 
@@ -282,7 +282,7 @@ OCSP_RESPONSE *modssl_dispatch_ocsp_request(const apr_uri_t *uri,
     bio = serialize_request(request, uri);
     if (bio == NULL) {
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, mySrvFromConn(c));
-        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(01989)
                       "could not serialize OCSP request");
         return NULL;
     }
diff --git a/modules/ssl/ssl_util_stapling.c b/modules/ssl/ssl_util_stapling.c
index 5ebd306..c294bf3 100644
--- a/modules/ssl/ssl_util_stapling.c
+++ b/modules/ssl/ssl_util_stapling.c
@@ -160,7 +160,7 @@ static certinfo *stapling_get_cert_info(server_rec *s, modssl_ctx_t *mctx,
     cinf = X509_get_ex_data(x, stapling_ex_idx);
     if (cinf && cinf->cid)
         return cinf;
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, APLOGNO(01926)
                  "stapling_get_cert_info: stapling not supported for certificate");
     return NULL;
 }
@@ -189,13 +189,13 @@ static BOOL stapling_cache_response(server_rec *s, modssl_ctx_t *mctx,
     resp_derlen = i2d_OCSP_RESPONSE(rsp, NULL) + 1;
 
     if (resp_derlen <= 0) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01927)
                      "OCSP stapling response encode error??");
         return FALSE;
     }
 
     if (resp_derlen > sizeof resp_der) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01928)
                      "OCSP stapling response too big (%u bytes)", resp_derlen);
         return FALSE;
     }
@@ -220,7 +220,7 @@ static BOOL stapling_cache_response(server_rec *s, modssl_ctx_t *mctx,
                                    cinf->idx, sizeof(cinf->idx),
                                    expiry, resp_der, resp_derlen, pool);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01929)
                      "stapling_cache_response: OCSP response session store error!");
         return FALSE;
     }
@@ -243,12 +243,12 @@ static BOOL stapling_get_cached_response(server_rec *s, OCSP_RESPONSE **prsp,
                                       cinf->idx, sizeof(cinf->idx),
                                       resp_der, &resp_derlen, pool);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01930)
                      "stapling_get_cached_response: cache miss");
         return TRUE;
     }
     if (resp_derlen <= 1) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01931)
                      "stapling_get_cached_response: response length invalid??");
         return TRUE;
     }
@@ -263,11 +263,11 @@ static BOOL stapling_get_cached_response(server_rec *s, OCSP_RESPONSE **prsp,
     resp_derlen--;
     rsp = d2i_OCSP_RESPONSE(NULL, &p, resp_derlen);
     if (!rsp) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01932)
                      "stapling_get_cached_response: response parse error??");
         return TRUE;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01933)
                  "stapling_get_cached_response: cache hit");
 
     *prsp = rsp;
@@ -312,7 +312,7 @@ static int stapling_check_response(server_rec *s, modssl_ctx_t *mctx,
     bs = OCSP_response_get1_basic(rsp);
     if (bs == NULL) {
         /* If we can't parse response just pass it to client */
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01934)
                      "stapling_check_response: Error Parsing Response!");
         return SSL_TLSEXT_ERR_OK;
     }
@@ -320,7 +320,7 @@ static int stapling_check_response(server_rec *s, modssl_ctx_t *mctx,
     if (!OCSP_resp_find_status(bs, cinf->cid, &status, &reason, &rev,
                                &thisupd, &nextupd)) {
         /* If ID not present just pass back to client */
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01935)
                      "stapling_check_response: certificate ID not present in response!");
     }
     else {
@@ -336,11 +336,11 @@ static int stapling_check_response(server_rec *s, modssl_ctx_t *mctx,
              * retrieved from cache and it is expected to subsequently expire
              */
             if (pok) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01936)
                              "stapling_check_response: response times invalid");
             }
             else {
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01937)
                              "stapling_check_response: cached response expired");
             }
 
@@ -371,7 +371,7 @@ static BOOL stapling_renew_response(server_rec *s, modssl_ctx_t *mctx, SSL *ssl,
 
     *prsp = NULL;
     /* Build up OCSP query from server certificate info */
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01938)
                  "stapling_renew_response: querying responder");
 
     req = OCSP_REQUEST_new();
@@ -401,14 +401,14 @@ static BOOL stapling_renew_response(server_rec *s, modssl_ctx_t *mctx, SSL *ssl,
 
     ok = apr_uri_parse(vpool, ocspuri, &uri);
     if (ok != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01939)
                      "stapling_renew_response: Error parsing uri %s",
                       ocspuri);
         rv = FALSE;
         goto done;
     }
     else if (strcmp(uri.scheme, "http")) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01940)
                      "stapling_renew_response: Unsupported uri %s", ocspuri);
         rv = FALSE;
         goto done;
@@ -424,7 +424,7 @@ static BOOL stapling_renew_response(server_rec *s, modssl_ctx_t *mctx, SSL *ssl,
     apr_pool_destroy(vpool);
 
     if (!*prsp) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01941)
                      "stapling_renew_response: responder error");
         if (mctx->stapling_fake_trylater) {
             *prsp = OCSP_response_create(OCSP_RESPONSE_STATUS_TRYLATER, NULL);
@@ -437,22 +437,22 @@ static BOOL stapling_renew_response(server_rec *s, modssl_ctx_t *mctx, SSL *ssl,
         int response_status = OCSP_response_status(*prsp);
 
         if (response_status == OCSP_RESPONSE_STATUS_SUCCESSFUL) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01942)
                         "stapling_renew_response: query response received");
             stapling_check_response(s, mctx, cinf, *prsp, &ok);
             if (ok == FALSE) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01943)
                              "stapling_renew_response: error in retreived response!");
             }
         }
         else {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01944)
                          "stapling_renew_response: responder error %s",
                          OCSP_response_status_str(response_status));
         }
     }
     if (stapling_cache_response(s, mctx, *prsp, cinf, ok, pool) == FALSE) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01945)
                      "stapling_renew_response: error caching response!");
     }
 
@@ -504,12 +504,12 @@ int ssl_stapling_mutex_reinit(server_rec *s, apr_pool_t *p)
     if ((rv = apr_global_mutex_child_init(&mc->stapling_mutex,
                                           lockfile, p)) != APR_SUCCESS) {
         if (lockfile) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s, APLOGNO(01946)
                          "Cannot reinit %s mutex with file `%s'",
                          SSL_STAPLING_MUTEX_TYPE, lockfile);
         }
         else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s, APLOGNO(01947)
                          "Cannot reinit %s mutex", SSL_STAPLING_MUTEX_TYPE);
         }
         return FALSE;
@@ -523,7 +523,7 @@ static int stapling_mutex_on(server_rec *s)
     apr_status_t rv;
 
     if ((rv = apr_global_mutex_lock(mc->stapling_mutex)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s, APLOGNO(01948)
                      "Failed to acquire OCSP stapling lock");
         return FALSE;
     }
@@ -536,7 +536,7 @@ static int stapling_mutex_off(server_rec *s)
     apr_status_t rv;
 
     if ((rv = apr_global_mutex_unlock(mc->stapling_mutex)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, s, APLOGNO(01949)
                      "Failed to release OCSP stapling lock");
         return FALSE;
     }
@@ -562,12 +562,12 @@ static int stapling_cb(SSL *ssl, void *arg)
     BOOL ok;
 
     if (sc->server->stapling_enabled != TRUE) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01950)
                      "stapling_cb: OCSP Stapling disabled");
         return SSL_TLSEXT_ERR_NOACK;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01951)
                  "stapling_cb: OCSP Stapling callback called");
 
     cinf = stapling_get_cert_info(s, mctx, ssl);
@@ -575,7 +575,7 @@ static int stapling_cb(SSL *ssl, void *arg)
         return SSL_TLSEXT_ERR_NOACK;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01952)
                  "stapling_cb: retrieved cached certificate data");
 
     /* Check to see if we already have a response for this certificate */
@@ -589,7 +589,7 @@ static int stapling_cb(SSL *ssl, void *arg)
 
     if (rsp) {
         /* see if response is acceptable */
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01953)
                      "stapling_cb: retrieved cached response");
         rv = stapling_check_response(s, mctx, cinf, rsp, NULL);
         if (rv == SSL_TLSEXT_ERR_ALERT_FATAL) {
@@ -619,13 +619,13 @@ static int stapling_cb(SSL *ssl, void *arg)
     }
 
     if (rsp == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01954)
                      "stapling_cb: renewing cached response");
         rv = stapling_renew_response(s, mctx, ssl, cinf, &rsp, conn->pool);
 
         if (rv == FALSE) {
             stapling_mutex_off(s);
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01955)
                          "stapling_cb: fatal error");
             return SSL_TLSEXT_ERR_ALERT_FATAL;
         }
@@ -633,13 +633,13 @@ static int stapling_cb(SSL *ssl, void *arg)
     stapling_mutex_off(s);
 
     if (rsp) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01956)
                      "stapling_cb: setting response");
         if (!stapling_set_response(ssl, rsp))
             return SSL_TLSEXT_ERR_ALERT_FATAL;
         return SSL_TLSEXT_ERR_OK;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01957)
                  "stapling_cb: no response available");
 
     return SSL_TLSEXT_ERR_NOACK;
@@ -653,12 +653,12 @@ void modssl_init_stapling(server_rec *s, apr_pool_t *p, apr_pool_t *ptemp,
     SSLModConfigRec *mc = myModConfig(s);
 
     if (mc->stapling_cache == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01958)
                      "SSLStapling: no stapling cache available");
         ssl_die();
     }
     if (ssl_stapling_mutex_init(s, ptemp) == FALSE) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(01959)
                      "SSLStapling: cannot initialise stapling mutex");
         ssl_die();
     }
@@ -682,7 +682,7 @@ void modssl_init_stapling(server_rec *s, apr_pool_t *p, apr_pool_t *ptemp,
         mctx->stapling_responder_timeout = 10 * APR_USEC_PER_SEC;
     }
     SSL_CTX_set_tlsext_status_cb(ctx, stapling_cb);
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "OCSP stapling initialized");
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01960) "OCSP stapling initialized");
 }
 
 #endif
diff --git a/modules/test/mod_dialup.c b/modules/test/mod_dialup.c
index 1bcc3eb..93e9743 100644
--- a/modules/test/mod_dialup.c
+++ b/modules/test/mod_dialup.c
@@ -86,7 +86,7 @@ dialup_send_pulse(dialup_baton_t *db)
         apr_brigade_cleanup(db->tmpbb);
 
         if (status != OK) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, db->r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, db->r, APLOGNO(01867)
                           "dialup: pulse: ap_pass_brigade failed:");
             return status;
         }
@@ -120,7 +120,7 @@ dialup_callback(void *baton)
         return;
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, db->r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, db->r, APLOGNO(01868)
                       "dialup: pulse returned: %d", status);
         db->r->status = HTTP_OK;
         ap_die(status, db->r);
@@ -177,7 +177,7 @@ dialup_handler(request_rec *r)
 
     status = ap_meets_conditions(r);
     if (status != OK) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01869)
                       "dialup: declined, meets conditions, good luck core handler");
         return DECLINED;
     }
@@ -206,7 +206,7 @@ dialup_handler(request_rec *r)
 
     status = dialup_send_pulse(db);
     if (status != SUSPENDED && status != DONE) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01870)
                       "dialup: failed, send pulse");
         return status;
     }
diff --git a/modules/test/mod_optional_fn_export.c b/modules/test/mod_optional_fn_export.c
index 358275a..5dccfc9 100644
--- a/modules/test/mod_optional_fn_export.c
+++ b/modules/test/mod_optional_fn_export.c
@@ -25,7 +25,7 @@
 
 static int TestOptionalFn(const char *szStr)
 {
-    ap_log_error(APLOG_MARK,APLOG_ERR,OK,NULL,
+    ap_log_error(APLOG_MARK,APLOG_ERR,OK,NULL, APLOGNO(01871)
                  "Optional function test said: %s",szStr);
 
     return OK;
diff --git a/modules/test/mod_optional_hook_import.c b/modules/test/mod_optional_hook_import.c
index 9a18852..12da318 100644
--- a/modules/test/mod_optional_hook_import.c
+++ b/modules/test/mod_optional_hook_import.c
@@ -21,7 +21,7 @@
 
 static int ImportOptionalHookTestHook(const char *szStr)
 {
-    ap_log_error(APLOG_MARK,APLOG_ERR,OK,NULL,"Optional hook test said: %s",
+    ap_log_error(APLOG_MARK,APLOG_ERR,OK,NULL, APLOGNO(01866)"Optional hook test said: %s",
                  szStr);
 
     return OK;
diff --git a/os/bs2000/os.c b/os/bs2000/os.c
index 0869ff4..9dc776d 100644
--- a/os/bs2000/os.c
+++ b/os/bs2000/os.c
@@ -85,7 +85,7 @@ int os_init_job_environment(server_rec *server, const char *user_name, int one_p
 
         type = forktype = bs2_noFORK;
 
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, server, APLOGNO(02170)
                      "The debug mode of Apache should only "
                      "be started by an unprivileged user!");
         return 0;
@@ -115,7 +115,7 @@ pid_t os_fork(const char *user)
         pid = ufork(username);
         if (pid == -1 && errno == EPERM) {
             ap_log_error(APLOG_MARK, APLOG_EMERG, errno,
-                         ap_server_conf, "ufork: Possible mis-configuration "
+                         ap_server_conf, APLOGNO(02171) "ufork: Possible mis-configuration "
                          "for user %s - Aborting.", user);
             exit(1);
         }
diff --git a/os/unix/unixd.c b/os/unix/unixd.c
index e29fb16..360b935 100644
--- a/os/unix/unixd.c
+++ b/os/unix/unixd.c
@@ -69,7 +69,7 @@ AP_DECLARE(void) ap_unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
     limit = *plimit;
     if ((getrlimit(type, limit)) != 0)  {
         *plimit = NULL;
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, cmd->server, APLOGNO(02172)
                      "%s: getrlimit failed", cmd->cmd->name);
         return;
     }
@@ -83,7 +83,7 @@ AP_DECLARE(void) ap_unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
         }
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server, APLOGNO(02173)
                      "Invalid parameters for %s", cmd->cmd->name);
         return;
     }
@@ -96,7 +96,7 @@ AP_DECLARE(void) ap_unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
     if (geteuid()) {
         limit->rlim_cur = cur;
         if (max && (max > limit->rlim_max)) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server, APLOGNO(02174)
                          "Must be uid 0 to raise maximum %s", cmd->cmd->name);
         }
         else if (max) {
@@ -113,7 +113,7 @@ AP_DECLARE(void) ap_unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
     }
 #else
 
-    ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server, APLOGNO(02175)
                  "Platform does not support rlimit for %s", cmd->cmd->name);
 #endif
 }
@@ -307,7 +307,7 @@ AP_DECLARE(apr_status_t) ap_unixd_accept(void **accepted, ap_listen_rec *lr,
 #ifdef _OSD_POSIX
         apr_os_sock_get(&sockdes, csd);
         if (sockdes >= FD_SETSIZE) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf, APLOGNO(02176)
                          "new file descriptor %d is too large; you probably need "
                          "to rebuild Apache with a larger FD_SETSIZE "
                          "(currently %d)",
@@ -414,7 +414,7 @@ AP_DECLARE(apr_status_t) ap_unixd_accept(void **accepted, ap_listen_rec *lr,
              * Ben Hyde noted that temporary ENETDOWN situations
              * occur in mobile IP.
              */
-            ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf, APLOGNO(02177)
                          "apr_socket_accept: giving up.");
             return APR_EGENERAL;
 #endif /*ENETDOWN*/
@@ -425,11 +425,11 @@ AP_DECLARE(apr_status_t) ap_unixd_accept(void **accepted, ap_listen_rec *lr,
              * Do not print an error in this case.
              */
             if (!lr->active) {
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, status, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, status, ap_server_conf, APLOGNO(02178)
                              "apr_socket_accept failed for inactive listener");
                 return status;
             }
-            ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf, APLOGNO(02179)
                          "apr_socket_accept: (client socket)");
             return APR_EGENERAL;
     }
@@ -496,7 +496,7 @@ int os_init_job_environment(server_rec *server, const char *user_name, int one_p
 
         type = forktype = bs2_noFORK;
 
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, server, APLOGNO(02180)
                      "The debug mode of Apache should only "
                      "be started by an unprivileged user!");
         return 0;
@@ -526,7 +526,7 @@ pid_t os_fork(const char *user)
         pid = ufork(username);
         if (pid == -1 && errno == EPERM) {
             ap_log_error(APLOG_MARK, APLOG_EMERG, errno,
-                         ap_server_conf, "ufork: Possible mis-configuration "
+                         ap_server_conf, APLOGNO(02181) "ufork: Possible mis-configuration "
                          "for user %s - Aborting.", user);
             exit(1);
         }
diff --git a/server/config.c b/server/config.c
index 4a0fc1a..d141b75 100644
--- a/server/config.c
+++ b/server/config.c
@@ -433,7 +433,7 @@ AP_CORE_DECLARE(int) ap_invoke_handler(request_rec *r)
     r->handler = old_handler;
 
     if (result == DECLINED && r->handler && r->filename) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(00523)
             "handler \"%s\" not found for: %s", r->handler, r->filename);
     }
     if ((result != OK) && (result != DONE) && (result != DECLINED) && (result != SUSPENDED)
@@ -447,7 +447,7 @@ AP_CORE_DECLARE(int) ap_invoke_handler(request_rec *r)
          */
         ignore = apr_table_get(r->notes, "HTTP_IGNORE_RANGE");
         if (!ignore) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00524)
                           "Handler for %s returned invalid result code %d",
                           r->handler, result);
             result = HTTP_INTERNAL_SERVER_ERROR;
@@ -666,7 +666,7 @@ AP_DECLARE(void) ap_remove_module(module *m)
 
         if (!modp) {
             /* Uh-oh, this module doesn't exist */
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(00525)
                          "Cannot remove module %s: not found in module list",
                          m->name);
             return;
@@ -2004,11 +2004,11 @@ AP_DECLARE(int) ap_process_config_tree(server_rec *s,
     errmsg = ap_walk_config(conftree, &parms, s->lookup_defaults);
     if (errmsg) {
         if (parms.err_directive)
-            ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, p,
+            ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, p, APLOGNO(00526)
                           "Syntax error on line %d of %s:",
                           parms.err_directive->line_num,
                           parms.err_directive->filename);
-        ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, p,
+        ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, p, APLOGNO(00527)
                      "%s", errmsg);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -2070,7 +2070,7 @@ AP_CORE_DECLARE(int) ap_parse_htaccess(ap_conf_vector_t **result,
             ap_cfg_closefile(f);
 
             if (errmsg) {
-                ap_log_rerror(APLOG_MARK, APLOG_ALERT, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ALERT, 0, r, APLOGNO(00528)
                               "%s: %s", filename, errmsg);
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
@@ -2081,7 +2081,7 @@ AP_CORE_DECLARE(int) ap_parse_htaccess(ap_conf_vector_t **result,
         else {
             if (!APR_STATUS_IS_ENOENT(status)
                 && !APR_STATUS_IS_ENOTDIR(status)) {
-                ap_log_rerror(APLOG_MARK, APLOG_CRIT, status, r,
+                ap_log_rerror(APLOG_MARK, APLOG_CRIT, status, r, APLOGNO(00529)
                               "%s pcfg_openfile: unable to check htaccess file, "
                               "ensure it is readable and that '%s' "
                               "is executable",
@@ -2272,7 +2272,7 @@ static server_rec *init_server_config(process_rec *process, apr_pool_t *p)
                                NULL, APR_UNSPEC, 0, 0, p);
     if (rv != APR_SUCCESS) {
         /* should we test here for rv being an EAIERR? */
-        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, rv, NULL, APLOGNO(00530)
                      "initialisation: bug or getaddrinfo fail");
         return NULL;
     }
@@ -2337,7 +2337,7 @@ AP_DECLARE(server_rec*) ap_read_config(process_rec *process, apr_pool_t *ptemp,
     error = process_command_config(s, ap_server_pre_read_config, conftree,
                                    p, ptemp);
     if (error) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, 0, NULL, "%s: %s",
+        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, 0, NULL, APLOGNO(00531) "%s: %s",
                      ap_server_argv0, error);
         return NULL;
     }
@@ -2349,21 +2349,21 @@ AP_DECLARE(server_rec*) ap_read_config(process_rec *process, apr_pool_t *ptemp,
 
     if (!confname) {
         ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT,
-                     APR_EBADPATH, NULL, "Invalid config file path %s",
+                     APR_EBADPATH, NULL, APLOGNO(00532) "Invalid config file path %s",
                      filename);
         return NULL;
     }
 
     error = ap_process_resource_config(s, confname, conftree, p, ptemp);
     if (error) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, 0, NULL, APLOGNO(00533)
                      "%s: %s", ap_server_argv0, error);
         return NULL;
     }
 
     error = ap_check_mpm();
     if (error) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, 0, NULL, APLOGNO(00534)
                      "%s: Configuration error: %s", ap_server_argv0, error);
         return NULL;
     }
@@ -2372,7 +2372,7 @@ AP_DECLARE(server_rec*) ap_read_config(process_rec *process, apr_pool_t *ptemp,
                                    p, ptemp);
 
     if (error) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, 0, NULL, "%s: %s",
+        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, 0, NULL, APLOGNO(00535) "%s: %s",
                      ap_server_argv0, error);
         return NULL;
     }
diff --git a/server/core.c b/server/core.c
index cd96ef7..e85b888 100644
--- a/server/core.c
+++ b/server/core.c
@@ -973,7 +973,7 @@ AP_DECLARE(const char *) ap_get_server_name(request_rec *r)
             retval = r->hostname ? r->hostname : r->server->server_hostname;
             break;
         default:
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00109)
                          "ap_get_server_name: Invalid UCN Option somehow");
             retval = "localhost";
             break;
@@ -1036,7 +1036,7 @@ AP_DECLARE(apr_port_t) ap_get_server_port(const request_rec *r)
                        ap_default_port(r);
             break;
         default:
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00110)
                          "ap_get_server_port: Invalid UCN Option somehow");
             port = ap_default_port(r);
             break;
@@ -1218,7 +1218,7 @@ AP_DECLARE(const char *) ap_resolve_env(apr_pool_t *p, const char * word)
                 }
                 else {
                     if (ap_strchr(name, ':') == 0)
-                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
+                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL, APLOGNO(00111)
                                      "Config variable ${%s} is not defined",
                                      name);
                     current->string = s;
@@ -1416,7 +1416,7 @@ static const char *set_document_root(cmd_parms *cmd, void *dummy,
         || !ap_is_directory(cmd->pool, arg)) {
         if (cmd->server->is_virtual) {
             ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0,
-                          cmd->pool,
+                          cmd->pool, APLOGNO(00112)
                           "Warning: DocumentRoot [%s] does not exist",
                           arg);
             conf->ap_document_root = arg;
@@ -1481,7 +1481,7 @@ static const char *set_error_document(cmd_parms *cmd, void *conf_,
     /* The entry should be ignored if it is a full URL for a 401 error */
 
     if (error_number == 401 && what == REMOTE_PATH) {
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, cmd->server, APLOGNO(00113)
                      "cannot use a full URL in a 401 ErrorDocument "
                      "directive --- ignoring!");
     }
@@ -1583,7 +1583,7 @@ static const char *set_override(cmd_parms *cmd, void *d_, const char *l)
 
     /* Throw a warning if we're in <Location> or <Files> */
     if (ap_check_cmd_context(cmd, NOT_IN_LOCATION | NOT_IN_FILES)) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00114)
                      "Useless use of AllowOverride in line %d of %s.",
                      cmd->directive->line_num, cmd->directive->filename);
     }
@@ -1643,7 +1643,7 @@ static const char *set_override_list(cmd_parms *cmd, void *d_, int argc, char *c
 
     /* Throw a warning if we're in <Location> or <Files> */
     if (ap_check_cmd_context(cmd, NOT_IN_LOCATION | NOT_IN_FILES)) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00115)
                      "Useless use of AllowOverrideList in line %d of %s.",
                      cmd->directive->line_num, cmd->directive->filename);
     }
@@ -1663,7 +1663,7 @@ static const char *set_override_list(cmd_parms *cmd, void *d_, int argc, char *c
             if (result)
                 apr_table_set(d->override_list, argv[i], "1");
             else
-                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00116)
                              "Discarding unrecognized directive `%s' in AllowOverrideList.",
                              argv[i]);
         }
@@ -1775,7 +1775,7 @@ static const char *set_default_type(cmd_parms *cmd, void *d_,
                                    const char *arg)
 {
     if ((strcasecmp(arg, "off") != 0) && (strcasecmp(arg, "none") != 0)) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00117)
               "Ignoring deprecated use of DefaultType in line %d of %s.",
                      cmd->directive->line_num, cmd->directive->filename);
     }
@@ -3362,7 +3362,7 @@ AP_DECLARE(size_t) ap_get_limit_xml_body(const request_rec *r)
 static const char *no_set_limit(cmd_parms *cmd, void *conf_,
                                 const char *arg, const char *arg2)
 {
-    ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server, APLOGNO(00118)
                 "%s not supported on this platform", cmd->cmd->name);
 
     return NULL;
@@ -3420,7 +3420,7 @@ static const char *set_recursion_limit(cmd_parms *cmd, void *dummy,
         return "The recursion limit must be greater than zero.";
     }
     if (limit < 4) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00119)
                      "Limiting internal redirects to very low numbers may "
                      "cause normal requests to fail.");
     }
@@ -3434,7 +3434,7 @@ static const char *set_recursion_limit(cmd_parms *cmd, void *dummy,
             return "The recursion limit must be greater than zero.";
         }
         if (limit < 4) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00120)
                          "Limiting the subrequest depth to a very low level may"
                          " cause normal requests to fail.");
         }
@@ -3449,20 +3449,20 @@ static void log_backtrace(const request_rec *r)
 {
     const request_rec *top = r;
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00121)
                   "r->uri = %s", r->uri ? r->uri : "(unexpectedly NULL)");
 
     while (top && (top->prev || top->main)) {
         if (top->prev) {
             top = top->prev;
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00122)
                           "redirected from r->uri = %s",
                           top->uri ? top->uri : "(unexpectedly NULL)");
         }
 
         if (!top->prev && top->main) {
             top = top->main;
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00123)
                           "subrequested from r->uri = %s",
                           top->uri ? top->uri : "(unexpectedly NULL)");
         }
@@ -3490,7 +3490,7 @@ AP_DECLARE(int) ap_is_recursion_limit_exceeded(const request_rec *r)
         if (top->prev) {
             if (++redirects >= rlimit) {
                 /* uuh, too much. */
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00124)
                               "Request exceeded the limit of %d internal "
                               "redirects due to probable configuration error. "
                               "Use 'LimitInternalRecursion' to increase the "
@@ -3510,7 +3510,7 @@ AP_DECLARE(int) ap_is_recursion_limit_exceeded(const request_rec *r)
         if (!top->prev && top->main) {
             if (++subreqs >= slimit) {
                 /* uuh, too much. */
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00125)
                               "Request exceeded the limit of %d subrequest "
                               "nesting levels due to probable configuration "
                               "error. Use 'LimitInternalRecursion' to increase "
@@ -4071,7 +4071,7 @@ AP_DECLARE_NONSTD(int) ap_core_translate(request_rec *r)
         return HTTP_FORBIDDEN;
     }
     if (!r->uri || ((r->uri[0] != '/') && strcmp(r->uri, "*"))) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00126)
                      "Invalid URI in request %s", r->the_request);
         return HTTP_BAD_REQUEST;
     }
@@ -4102,7 +4102,7 @@ AP_DECLARE_NONSTD(int) ap_core_translate(request_rec *r)
                                  APR_FILEPATH_TRUENAME
                                | APR_FILEPATH_SECUREROOT, r->pool))
                 != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00127)
                      "Cannot map %s to file", r->the_request);
         return HTTP_FORBIDDEN;
     }
@@ -4202,7 +4202,7 @@ static int default_handler(request_rec *r)
 
     if (r->method_number == M_GET || r->method_number == M_POST) {
         if (r->finfo.filetype == APR_NOFILE) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00128)
                           "File does not exist: %s", r->filename);
             return HTTP_NOT_FOUND;
         }
@@ -4211,7 +4211,7 @@ static int default_handler(request_rec *r)
          * raw I/O on a dir.
          */
         if (r->finfo.filetype == APR_DIR) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00129)
                           "Attempt to serve directory: %s", r->filename);
             return HTTP_NOT_FOUND;
         }
@@ -4220,7 +4220,7 @@ static int default_handler(request_rec *r)
             r->path_info && *r->path_info)
         {
             /* default to reject */
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00130)
                           "File does not exist: %s",
                           apr_pstrcat(r->pool, r->filename, r->path_info, NULL));
             return HTTP_NOT_FOUND;
@@ -4240,7 +4240,7 @@ static int default_handler(request_rec *r)
             req_cfg = ap_get_core_module_config(r->request_config);
             if (!req_cfg->deliver_script) {
                 /* The flag hasn't been set for this request. Punt. */
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00131)
                               "This resource does not accept the %s method.",
                               r->method);
                 return HTTP_METHOD_NOT_ALLOWED;
@@ -4253,7 +4253,7 @@ static int default_handler(request_rec *r)
                             | AP_SENDFILE_ENABLED(d->enable_sendfile)
 #endif
                                     , 0, r->pool)) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00132)
                           "file permissions deny server access: %s", r->filename);
             return HTTP_FORBIDDEN;
         }
@@ -4295,7 +4295,7 @@ static int default_handler(request_rec *r)
         }
         else {
             /* no way to know what type of error occurred */
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00133)
                           "default_handler: ap_pass_brigade returned %i",
                           status);
             return HTTP_INTERNAL_SERVER_ERROR;
@@ -4310,10 +4310,10 @@ static int default_handler(request_rec *r)
             if (r->the_request
                 && r->the_request[0] == 0x16
                 && (r->the_request[1] == 0x2 || r->the_request[1] == 0x3)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00134)
                               "Invalid method in request %s - possible attempt to establish SSL connection on non-SSL port", r->the_request);
             } else {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00135)
                               "Invalid method in request %s", r->the_request);
             }
             return HTTP_NOT_IMPLEMENTED;
@@ -4369,7 +4369,7 @@ static int core_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pte
     ap_setup_make_content_type(pconf);
     ap_setup_auth_internal(ptemp);
     if (!sys_privileges) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, NULL, APLOGNO(00136)
                      "Server MUST relinquish startup privileges before "
                      "accepting connections.  Please ensure mod_unixd "
                      "or other system security module is loaded.");
@@ -4490,7 +4490,7 @@ static conn_rec *core_create_conn(apr_pool_t *ptrans, server_rec *server,
     c->pool = ptrans;
     if ((rv = apr_socket_addr_get(&c->local_addr, APR_LOCAL, csd))
         != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_INFO, rv, server,
+        ap_log_error(APLOG_MARK, APLOG_INFO, rv, server, APLOGNO(00137)
                      "apr_socket_addr_get(APR_LOCAL)");
         apr_socket_close(csd);
         return NULL;
@@ -4499,7 +4499,7 @@ static conn_rec *core_create_conn(apr_pool_t *ptrans, server_rec *server,
     apr_sockaddr_ip_get(&c->local_ip, c->local_addr);
     if ((rv = apr_socket_addr_get(&c->peer_addr, APR_REMOTE, csd))
         != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_INFO, rv, server,
+        ap_log_error(APLOG_MARK, APLOG_INFO, rv, server, APLOGNO(00138)
                      "apr_socket_addr_get(APR_REMOTE)");
         apr_socket_close(csd);
         return NULL;
@@ -4533,7 +4533,7 @@ static int core_pre_connection(conn_rec *c, void *csd)
         /* expected cause is that the client disconnected already,
          * hence the debug level
          */
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c,
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00139)
                       "apr_socket_opt_set(APR_TCP_NODELAY)");
     }
 
@@ -4546,7 +4546,7 @@ static int core_pre_connection(conn_rec *c, void *csd)
     rv = apr_socket_timeout_set(csd, c->base_server->timeout);
     if (rv != APR_SUCCESS) {
         /* expected cause is that the client disconnected already */
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c,
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00140)
                       "apr_socket_timeout_set");
     }
 
@@ -4628,7 +4628,7 @@ AP_CORE_DECLARE(void) ap_init_rng(apr_pool_t *p)
     if (rv == APR_SUCCESS)
         return;
 error:
-    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00141)
                  "Could not initialize random number generator");
     exit(1);
 }
diff --git a/server/core_filters.c b/server/core_filters.c
index 24f1f1f..686513f 100644
--- a/server/core_filters.c
+++ b/server/core_filters.c
@@ -798,7 +798,7 @@ static apr_status_t sendfile_nonblocking(apr_socket_t *s,
     apr_size_t bytes_written = 0;
 
     if (!APR_BUCKET_IS_FILE(bucket)) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, c->base_server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, c->base_server, APLOGNO(00006)
                      "core_filter: sendfile_nonblocking: "
                      "this should never happen");
         return APR_EGENERAL;
diff --git a/server/listen.c b/server/listen.c
index fd23231..a4935aa 100644
--- a/server/listen.c
+++ b/server/listen.c
@@ -56,7 +56,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
 #ifndef WIN32
     stat = apr_socket_opt_set(s, APR_SO_REUSEADDR, one);
     if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(00067)
                       "make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)",
                       server->bind_addr);
         apr_socket_close(s);
@@ -66,7 +66,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
 
     stat = apr_socket_opt_set(s, APR_SO_KEEPALIVE, one);
     if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(00068)
                       "make_sock: for address %pI, apr_socket_opt_set: (SO_KEEPALIVE)",
                       server->bind_addr);
         apr_socket_close(s);
@@ -77,7 +77,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
     if (server->bind_addr->family == APR_INET6) {
         stat = apr_socket_opt_set(s, APR_IPV6_V6ONLY, v6only_setting);
         if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
-            ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,
+            ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(00069)
                           "make_sock: for address %pI, apr_socket_opt_set: "
                           "(IPV6_V6ONLY)",
                           server->bind_addr);
@@ -109,7 +109,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
     if (send_buffer_size) {
         stat = apr_socket_opt_set(s, APR_SO_SNDBUF,  send_buffer_size);
         if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
-            ap_log_perror(APLOG_MARK, APLOG_WARNING, stat, p,
+            ap_log_perror(APLOG_MARK, APLOG_WARNING, stat, p, APLOGNO(00070)
                           "make_sock: failed to set SendBufferSize for "
                           "address %pI, using default",
                           server->bind_addr);
@@ -119,7 +119,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
     if (receive_buffer_size) {
         stat = apr_socket_opt_set(s, APR_SO_RCVBUF, receive_buffer_size);
         if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
-            ap_log_perror(APLOG_MARK, APLOG_WARNING, stat, p,
+            ap_log_perror(APLOG_MARK, APLOG_WARNING, stat, p, APLOGNO(00071)
                           "make_sock: failed to set ReceiveBufferSize for "
                           "address %pI, using default",
                           server->bind_addr);
@@ -132,7 +132,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
 #endif
 
     if ((stat = apr_socket_bind(s, server->bind_addr)) != APR_SUCCESS) {
-        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, stat, p,
+        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, stat, p, APLOGNO(00072)
                       "make_sock: could not bind to address %pI",
                       server->bind_addr);
         apr_socket_close(s);
@@ -140,7 +140,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
     }
 
     if ((stat = apr_socket_listen(s, ap_listenbacklog)) != APR_SUCCESS) {
-        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, stat, p,
+        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, stat, p, APLOGNO(00073)
                       "make_sock: unable to listen for connections "
                       "on address %pI",
                       server->bind_addr);
@@ -161,7 +161,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
      */
     stat = apr_socket_opt_set(s, APR_SO_REUSEADDR, one);
     if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p, APLOGNO(00074)
                     "make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)",
                      server->bind_addr);
         apr_socket_close(s);
@@ -216,14 +216,14 @@ static void ap_apply_accept_filter(apr_pool_t *p, ap_listen_rec *lis,
         rv = apr_socket_accept_filter(s, apr_pstrdup(p, accf),
                                       apr_pstrdup(p,""));
         if (rv != APR_SUCCESS && !APR_STATUS_IS_ENOTIMPL(rv)) {
-            ap_log_perror(APLOG_MARK, APLOG_WARNING, rv, p,
+            ap_log_perror(APLOG_MARK, APLOG_WARNING, rv, p, APLOGNO(00075)
                           "Failed to enable the '%s' Accept Filter",
                           accf);
         }
 #else
         rv = apr_socket_opt_set(s, APR_TCP_DEFER_ACCEPT, 30);
         if (rv != APR_SUCCESS && !APR_STATUS_IS_ENOTIMPL(rv)) {
-            ap_log_perror(APLOG_MARK, APLOG_WARNING, rv, p,
+            ap_log_perror(APLOG_MARK, APLOG_WARNING, rv, p, APLOGNO(00076)
                               "Failed to enable APR_TCP_DEFER_ACCEPT");
         }
 #endif
@@ -282,7 +282,7 @@ static const char *alloc_listener(process_rec *process, char *addr,
     if ((status = apr_sockaddr_info_get(&sa, addr, APR_UNSPEC, port, 0,
                                         process->pool))
         != APR_SUCCESS) {
-        ap_log_perror(APLOG_MARK, APLOG_CRIT, status, process->pool,
+        ap_log_perror(APLOG_MARK, APLOG_CRIT, status, process->pool, APLOGNO(00077)
                       "alloc_listener: failed to set up sockaddr for %s",
                       addr);
         return "Listen setup failed";
@@ -320,7 +320,7 @@ static const char *alloc_listener(process_rec *process, char *addr,
         }
 #endif
         if (status != APR_SUCCESS) {
-            ap_log_perror(APLOG_MARK, APLOG_CRIT, status, process->pool,
+            ap_log_perror(APLOG_MARK, APLOG_CRIT, status, process->pool, APLOGNO(00078)
                           "alloc_listener: failed to get a socket for %s",
                           addr);
             return "Listen setup failed";
@@ -498,7 +498,7 @@ static int open_listeners(apr_pool_t *pool)
 
         status = apr_socket_opt_set(lr->sd, APR_SO_NONBLOCK, use_nonblock);
         if (status != APR_SUCCESS) {
-            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, status, pool,
+            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_ERR, status, pool, APLOGNO(00079)
                           "unable to control socket non-blocking status");
             return -1;
         }
diff --git a/server/log.c b/server/log.c
index 4b73a45..70c37e0 100644
--- a/server/log.c
+++ b/server/log.c
@@ -248,14 +248,14 @@ AP_DECLARE(apr_status_t) ap_replace_stderr_log(apr_pool_t *p,
     char *filename = ap_server_root_relative(p, fname);
     if (!filename) {
         ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT,
-                     APR_EBADPATH, NULL, "Invalid -E error log file %s",
+                     APR_EBADPATH, NULL, APLOGNO(00085) "Invalid -E error log file %s",
                      fname);
         return APR_EBADPATH;
     }
     if ((rc = apr_file_open(&stderr_file, filename,
                             APR_APPEND | APR_WRITE | APR_CREATE | APR_LARGEFILE,
                             APR_OS_DEFAULT, p)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL, APLOGNO(00086)
                      "%s: could not open error log file %s.",
                      ap_server_argv0, fname);
         return rc;
@@ -288,7 +288,7 @@ AP_DECLARE(apr_status_t) ap_replace_stderr_log(apr_pool_t *p,
         stderr_pool = NULL;
 
     if (rc != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rc, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rc, NULL, APLOGNO(00087)
                      "unable to replace stderr with error log file");
     }
     return rc;
@@ -297,7 +297,7 @@ AP_DECLARE(apr_status_t) ap_replace_stderr_log(apr_pool_t *p,
 static void log_child_errfn(apr_pool_t *pool, apr_status_t err,
                             const char *description)
 {
-    ap_log_error(APLOG_MARK, APLOG_ERR, err, NULL,
+    ap_log_error(APLOG_MARK, APLOG_ERR, err, NULL, APLOGNO(00088)
                  "%s", description);
 }
 
@@ -387,7 +387,7 @@ static int open_error_log(server_rec *s, int is_main, apr_pool_t *p)
          * child inherits the parents stderr. */
         rc = log_child(p, fname, &dummy, cmdtype, is_main);
         if (rc != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL, APLOGNO(00089)
                          "Couldn't start ErrorLog process '%s'.",
                          s->error_fname + 1);
             return DONE;
@@ -421,7 +421,7 @@ static int open_error_log(server_rec *s, int is_main, apr_pool_t *p)
     else {
         fname = ap_server_root_relative(p, s->error_fname);
         if (!fname) {
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, APR_EBADPATH, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, APR_EBADPATH, NULL, APLOGNO(00090)
                          "%s: Invalid error log path %s.",
                          ap_server_argv0, s->error_fname);
             return DONE;
@@ -429,7 +429,7 @@ static int open_error_log(server_rec *s, int is_main, apr_pool_t *p)
         if ((rc = apr_file_open(&s->error_log, fname,
                                APR_APPEND | APR_WRITE | APR_CREATE | APR_LARGEFILE,
                                APR_OS_DEFAULT, p)) != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL, APLOGNO(00091)
                          "%s: could not open error log file %s.",
                          ap_server_argv0, fname);
             return DONE;
@@ -480,7 +480,7 @@ int ap_open_logs(apr_pool_t *pconf, apr_pool_t *p /* plog */,
         apr_file_flush(s_main->error_log);
         rv = apr_file_dup2(stderr_log, s_main->error_log, stderr_p);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s_main,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s_main, APLOGNO(00092)
                          "unable to replace stderr with error_log");
         }
         else {
@@ -510,7 +510,7 @@ int ap_open_logs(apr_pool_t *pconf, apr_pool_t *p /* plog */,
      *      errno-as-apr_status_t is also non-portable
      */
     if (replace_stderr && freopen("/dev/null", "w", stderr) == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, errno, s_main,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, errno, s_main, APLOGNO(00093)
                      "unable to replace stderr with /dev/null");
     }
 
@@ -1385,7 +1385,7 @@ AP_DECLARE(void) ap_log_command_line(apr_pool_t *plog, server_rec *s)
             strcat(result, " ");
         }
     }
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s, APLOGNO(00094)
                  "Command line: '%s'", result);
 }
 
@@ -1397,11 +1397,11 @@ AP_DECLARE(void) ap_remove_pid(apr_pool_t *p, const char *rel_fname)
     if (fname != NULL) {
         rv = apr_file_remove(fname, p);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00095)
                          "failed to remove PID file %s", fname);
         }
         else {
-            ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00096)
                          "removed PID file %s (pid=%" APR_PID_T_FMT ")",
                          fname, getpid());
         }
@@ -1424,7 +1424,7 @@ AP_DECLARE(void) ap_log_pid(apr_pool_t *p, const char *filename)
     fname = ap_server_root_relative(p, filename);
     if (!fname) {
         ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, APR_EBADPATH,
-                     NULL, "Invalid PID file path %s, ignoring.", filename);
+                     NULL, APLOGNO(00097) "Invalid PID file path %s, ignoring.", filename);
         return;
     }
 
@@ -1438,7 +1438,7 @@ AP_DECLARE(void) ap_log_pid(apr_pool_t *p, const char *filename)
          *      that may screw up scripts written to do something
          *      based on the last modification time of the pid file.
          */
-        ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, p,
+        ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, p, APLOGNO(00098)
                       "pid file %s overwritten -- Unclean "
                       "shutdown of previous Apache run?",
                       fname);
@@ -1448,9 +1448,9 @@ AP_DECLARE(void) ap_log_pid(apr_pool_t *p, const char *filename)
                             APR_WRITE | APR_CREATE | APR_TRUNCATE,
                             APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD, p))
         != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, APLOGNO(00099)
                      "could not create %s", fname);
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(00100)
                      "%s: could not log pid to file %s",
                      ap_server_argv0, fname);
         exit(1);
@@ -1477,7 +1477,7 @@ AP_DECLARE(apr_status_t) ap_read_pid(apr_pool_t *p, const char *filename,
     fname = ap_server_root_relative(p, filename);
     if (!fname) {
         ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, APR_EBADPATH,
-                     NULL, "Invalid PID file path %s, ignoring.", filename);
+                     NULL, APLOGNO(00101) "Invalid PID file path %s, ignoring.", filename);
         return APR_EGENERAL;
     }
 
@@ -1512,7 +1512,7 @@ AP_DECLARE(void) ap_log_assert(const char *szExp, const char *szFile,
     char time_str[APR_CTIME_LEN];
 
     apr_ctime(time_str, apr_time_now());
-    ap_log_error(APLOG_MARK, APLOG_CRIT, 0, NULL,
+    ap_log_error(APLOG_MARK, APLOG_CRIT, 0, NULL, APLOGNO(00102)
                  "[%s] file %s, line %d, assertion \"%s\" failed",
                  time_str, szFile, nLine, szExp);
 #if defined(WIN32)
@@ -1550,7 +1550,7 @@ static apr_status_t piped_log_spawn(piped_log *pl)
         ((status = apr_procattr_error_check_set(procattr, 1)) != APR_SUCCESS)) {
         char buf[120];
         /* Something bad happened, give up and go away. */
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00103)
                      "piped_log_spawn: unable to setup child process '%s': %s",
                      pl->program, apr_strerror(status, buf, sizeof(buf)));
     }
@@ -1578,7 +1578,7 @@ static apr_status_t piped_log_spawn(piped_log *pl)
         else {
             char buf[120];
             /* Something bad happened, give up and go away. */
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00104)
                          "unable to start piped log program '%s': %s",
                          pl->program, apr_strerror(status, buf, sizeof(buf)));
         }
@@ -1603,20 +1603,20 @@ static void piped_log_maintenance(int reason, void *data, apr_wait_t status)
         apr_proc_other_child_unregister(pl);
         stats = ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state);
         if (stats != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00105)
                          "can't query MPM state; not restarting "
                          "piped log program '%s'",
                          pl->program);
         }
         else if (mpm_state != AP_MPMQ_STOPPING) {
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00106)
                          "piped log program '%s' failed unexpectedly",
                          pl->program);
             if ((stats = piped_log_spawn(pl)) != APR_SUCCESS) {
                 /* what can we do?  This could be the error log we're having
                  * problems opening up... */
                 char buf[120];
-                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+                ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00107)
                              "piped_log_maintenance: unable to respawn '%s': %s",
                              pl->program, apr_strerror(stats, buf, sizeof(buf)));
             }
@@ -1709,7 +1709,7 @@ AP_DECLARE(piped_log *) ap_open_piped_log_ex(apr_pool_t *p,
 
     rc = log_child(p, program, &dummy, cmdtype, 0);
     if (rc != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, rc, NULL, APLOGNO(00108)
                      "Couldn't start piped log process '%s'.",
                      (program == NULL) ? "NULL" : program);
         return NULL;
diff --git a/server/main.c b/server/main.c
index 778e812..204d66c 100644
--- a/server/main.c
+++ b/server/main.c
@@ -480,8 +480,8 @@ int main(int argc, const char * const argv[])
 
     error = ap_setup_prelinked_modules(process);
     if (error) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_EMERG, 0, NULL, "%s: %s",
-                     ap_server_argv0, error);
+        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_EMERG, 0, NULL, APLOGNO(00012)
+                     "%s: %s", ap_server_argv0, error);
         destroy_and_exit_process(process, 1);
     }
 
@@ -632,7 +632,7 @@ int main(int argc, const char * const argv[])
 
     if (ap_run_pre_config(pconf, plog, ptemp) != OK) {
         ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR, 0,
-                     NULL, "Pre-configuration failed");
+                     NULL, APLOGNO(00013) "Pre-configuration failed");
         destroy_and_exit_process(process, 1);
     }
 
@@ -650,7 +650,7 @@ int main(int argc, const char * const argv[])
 
         if (ap_run_check_config(pconf, plog, ptemp, ap_server_conf) != OK) {
             ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR, 0,
-                         NULL, "Configuration check failed");
+                         NULL, APLOGNO(00014) "Configuration check failed");
             destroy_and_exit_process(process, 1);
         }
 
@@ -689,13 +689,13 @@ int main(int argc, const char * const argv[])
 
     if ( ap_run_open_logs(pconf, plog, ptemp, ap_server_conf) != OK) {
         ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
-                     0, NULL, "Unable to open logs");
+                     0, NULL, APLOGNO(00015) "Unable to open logs");
         destroy_and_exit_process(process, 1);
     }
 
     if ( ap_run_post_config(pconf, plog, ptemp, ap_server_conf) != OK) {
         ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR, 0,
-                     NULL, "Configuration Failed");
+                     NULL, APLOGNO(00016) "Configuration Failed");
         destroy_and_exit_process(process, 1);
     }
 
@@ -732,7 +732,7 @@ int main(int argc, const char * const argv[])
 
         if (ap_run_pre_config(pconf, plog, ptemp) != OK) {
             ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
-                         0, NULL, "Pre-configuration failed");
+                         0, NULL, APLOGNO(00017) "Pre-configuration failed");
             destroy_and_exit_process(process, 1);
         }
 
@@ -751,20 +751,20 @@ int main(int argc, const char * const argv[])
 
         if (ap_run_check_config(pconf, plog, ptemp, ap_server_conf) != OK) {
             ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR, 0,
-                         NULL, "Configuration check failed");
+                         NULL, APLOGNO(00018) "Configuration check failed");
             destroy_and_exit_process(process, 1);
         }
 
         apr_pool_clear(plog);
         if (ap_run_open_logs(pconf, plog, ptemp, ap_server_conf) != OK) {
             ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
-                         0, NULL, "Unable to open logs");
+                         0, NULL, APLOGNO(00019) "Unable to open logs");
             destroy_and_exit_process(process, 1);
         }
 
         if (ap_run_post_config(pconf, plog, ptemp, ap_server_conf) != OK) {
             ap_log_error(APLOG_MARK, APLOG_STARTUP |APLOG_ERR,
-                         0, NULL, "Configuration Failed");
+                         0, NULL, APLOGNO(00020) "Configuration Failed");
             destroy_and_exit_process(process, 1);
         }
 
diff --git a/server/mpm/event/event.c b/server/mpm/event/event.c
index d0f40d0..2949b33 100644
--- a/server/mpm/event/event.c
+++ b/server/mpm/event/event.c
@@ -402,7 +402,7 @@ static void disable_listensocks(int process_slot)
 static void enable_listensocks(int process_slot)
 {
     int i;
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00457)
                  "Accepting new connections again: "
                  "%u active conns, %u idle workers",
                  apr_atomic_read32(&connection_count),
@@ -567,7 +567,7 @@ static void event_note_child_started(int slot, pid_t pid)
 
 static void event_note_child_lost_slot(int slot, pid_t newpid)
 {
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00458)
                  "pid %" APR_PID_T_FMT " taking over scoreboard slot from "
                  "%" APR_PID_T_FMT "%s",
                  newpid,
@@ -698,22 +698,22 @@ static void set_signals(void)
 
     sa.sa_handler = sig_term;
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00459)
                      "sigaction(SIGTERM)");
 #ifdef AP_SIG_GRACEFUL_STOP
     if (sigaction(AP_SIG_GRACEFUL_STOP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00460)
                      "sigaction(" AP_SIG_GRACEFUL_STOP_STRING ")");
 #endif
 #ifdef SIGINT
     if (sigaction(SIGINT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00461)
                      "sigaction(SIGINT)");
 #endif
 #ifdef SIGXCPU
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXCPU, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00462)
                      "sigaction(SIGXCPU)");
 #endif
 #ifdef SIGXFSZ
@@ -722,13 +722,13 @@ static void set_signals(void)
      * rather than terminate the process. */
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGXFSZ, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00463)
                      "sigaction(SIGXFSZ)");
 #endif
 #ifdef SIGPIPE
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGPIPE, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00464)
                      "sigaction(SIGPIPE)");
 #endif
 
@@ -738,10 +738,10 @@ static void set_signals(void)
     sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
     sa.sa_handler = restart;
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00465)
                      "sigaction(SIGHUP)");
     if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00466)
                      "sigaction(" AP_SIG_GRACEFUL_STRING ")");
 #else
     if (!one_process) {
@@ -793,7 +793,7 @@ static void process_pollop(pollset_op_t *op)
     rv = apr_pollset_add(event_pollset, &op->cs->pfd);
 
     if (rv != APR_SUCCESS && !APR_STATUS_IS_EEXIST(rv)) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00467)
                      "%s: apr_pollset_add failure", op->tag);
     }
 }
@@ -882,7 +882,7 @@ static int stop_lingering_close(event_conn_state_t *cs, ap_equeue_t *eq)
                  "socket reached timeout in lingering-close state");
     rv = apr_socket_close(csd);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, "error closing socket");
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00468) "error closing socket");
         AP_DEBUG_ASSERT(0);
     }
     apr_pool_clear(cs->p);
@@ -937,7 +937,7 @@ static int process_socket(apr_thread_t *thd, apr_pool_t * p, apr_socket_t * sock
 
         rc = ap_run_pre_connection(c, sock);
         if (rc != OK && rc != DONE) {
-            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
+            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(00469)
                           "process_socket: connection aborted");
             c->aborted = 1;
         }
@@ -999,7 +999,7 @@ read_request:
         }
         rv = output_filter->frec->filter_func.out_func(output_filter, NULL);
         if (rv != APR_SUCCESS) {
-            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c,
+            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00470)
                           "network write failure in core output filter");
             cs->pub.state = CONN_STATE_LINGER;
         }
@@ -1218,7 +1218,7 @@ static apr_status_t push2worker(const apr_pollfd_t * pfd,
         apr_bucket_alloc_destroy(cs->bucket_alloc);
         apr_socket_close(cs->pfd.desc.s);
         ap_log_error(APLOG_MARK, APLOG_CRIT, rc,
-                     ap_server_conf, "push2worker: ap_queue_push failed");
+                     ap_server_conf, APLOGNO(00471) "push2worker: ap_queue_push failed");
         apr_pool_clear(cs->p);
         ap_push_pool(worker_queue_info, cs->p);
     }
@@ -1258,7 +1258,7 @@ static void get_worker(int *have_idle_worker_p, int blocking, int *all_busy)
         *all_busy = 1;
     }
     else if (!APR_STATUS_IS_EOF(rc)) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rc, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rc, ap_server_conf, APLOGNO(00472)
                      "ap_queue_info_wait_for_idler failed.  "
                      "Attempting to shutdown process gracefully");
         signal_threads(ST_GRACEFUL);
@@ -1383,7 +1383,7 @@ static void process_timeout_queue(struct timeout_queue *q,
         last = cs;
         rv = apr_pollset_remove(event_pollset, &cs->pfd);
         if (rv != APR_SUCCESS && !APR_STATUS_IS_NOTFOUND(rv)) {
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, cs->c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, cs->c, APLOGNO(00473)
                           "apr_pollset_remove failed");
         }
         cs = APR_RING_NEXT(cs, timeout_list);
@@ -1907,7 +1907,7 @@ static void create_listener_thread(thread_starter * ts)
     rv = apr_thread_create(&ts->listener, thread_attr, listener_thread,
                            my_info, pchild);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, APLOGNO(00474)
                      "apr_thread_create: unable to create listener thread");
         /* let the parent decide how bad this really is */
         clean_child_exit(APEXIT_CHILDSICK);
@@ -2083,13 +2083,13 @@ static void join_workers(apr_thread_t * listener, apr_thread_t ** threads)
             ++iter;
         }
         if (iter >= 10) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00475)
                          "the listener thread didn't stop accepting");
         }
         else {
             rv = apr_thread_join(&thread_rv, listener);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00476)
                              "apr_thread_join: unable to join listener thread");
             }
         }
@@ -2099,7 +2099,7 @@ static void join_workers(apr_thread_t * listener, apr_thread_t ** threads)
         if (threads[i]) {       /* if we ever created this thread */
             rv = apr_thread_join(&thread_rv, threads[i]);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00477)
                              "apr_thread_join: unable to join worker "
                              "thread %d", i);
             }
@@ -2117,7 +2117,7 @@ static void join_start_thread(apr_thread_t * start_thread_id)
                                  */
     rv = apr_thread_join(&thread_rv, start_thread_id);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00478)
                      "apr_thread_join: unable to join the start " "thread");
     }
 }
@@ -2157,7 +2157,7 @@ static void child_main(int child_num_arg)
      */
     rv = apr_setup_signal_thread();
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf, APLOGNO(00479)
                      "Couldn't initialize signal thread");
         clean_child_exit(APEXIT_CHILDFATAL);
     }
@@ -2194,7 +2194,7 @@ static void child_main(int child_num_arg)
     rv = apr_thread_create(&start_thread_id, thread_attr, start_threads,
                            ts, pchild);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, APLOGNO(00480)
                      "apr_thread_create: unable to create worker thread");
         /* let the parent decide how bad this really is */
         clean_child_exit(APEXIT_CHILDSICK);
@@ -2293,7 +2293,7 @@ static int make_child(server_rec * s, int slot)
     }
 
     if ((pid = fork()) == -1) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, APLOGNO(00481)
                      "fork: Unable to fork new process");
 
         /* fork didn't succeed.  There's no need to touch the scoreboard;
@@ -2320,7 +2320,7 @@ static int make_child(server_rec * s, int slot)
                                    PROCESSOR_CLASS_ANY);
         if (status != OK)
             ap_log_error(APLOG_MARK, APLOG_DEBUG, errno,
-                         ap_server_conf,
+                         ap_server_conf, APLOGNO(00482)
                          "processor unbind failed");
 #endif
         RAISE_SIGSTOP(MAKE_CHILD);
@@ -2467,7 +2467,7 @@ static void perform_idle_server_maintenance(void)
             shutdown_pending = 1;
             child_fatal = 1;
             ap_log_error(APLOG_MARK, APLOG_ALERT, 0,
-                         ap_server_conf,
+                         ap_server_conf, APLOGNO(00483)
                          "No active workers found..."
                          " Apache is exiting!");
             /* the child already logged the failure details */
@@ -2489,7 +2489,7 @@ static void perform_idle_server_maintenance(void)
             if (active_thread_count >= ap_daemons_limit * threads_per_child) {
                 if (!retained->maxclients_reported) {
                     /* only report this condition once */
-                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
+                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00484)
                                  "server reached MaxRequestWorkers setting, "
                                  "consider raising the MaxRequestWorkers "
                                  "setting");
@@ -2497,7 +2497,7 @@ static void perform_idle_server_maintenance(void)
                 }
             }
             else {
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00485)
                              "scoreboard is full, not at MaxRequestWorkers");
             }
             retained->idle_spawn_rate = 1;
@@ -2507,7 +2507,7 @@ static void perform_idle_server_maintenance(void)
                 free_length = retained->idle_spawn_rate;
             }
             if (retained->idle_spawn_rate >= 8) {
-                ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00486)
                              "server seems busy, (you may need "
                              "to increase StartServers, ThreadsPerChild "
                              "or Min/MaxSpareThreads), "
@@ -2563,7 +2563,7 @@ static void server_main_loop(int remaining_children_to_start)
                     return;
                 }
                 else {
-                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf,
+                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf, APLOGNO(00487)
                                  "Ignoring fatal error in child of previous "
                                  "generation (pid %ld).",
                                  (long)pid.pid);
@@ -2614,7 +2614,7 @@ static void server_main_loop(int remaining_children_to_start)
                  * scoreboard.  Somehow we don't know about this child.
                  */
                 ap_log_error(APLOG_MARK, APLOG_WARNING, 0,
-                             ap_server_conf,
+                             ap_server_conf, APLOGNO(00488)
                              "long lost child came home! (pid %ld)",
                              (long) pid.pid);
             }
@@ -2689,10 +2689,10 @@ static int event_run(apr_pool_t * _pconf, apr_pool_t * plog, server_rec * s)
         retained->hold_off_on_exponential_spawning = 10;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00489)
                  "%s configured -- resuming normal operations",
                  ap_get_server_description());
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00490)
                  "Server built: %s", ap_get_server_built());
     ap_log_command_line(plog, s);
 
@@ -2713,7 +2713,7 @@ static int event_run(apr_pool_t * _pconf, apr_pool_t * plog, server_rec * s)
             /* cleanup pid file on normal shutdown */
             ap_remove_pid(pconf, ap_pid_fname);
             ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
-                         ap_server_conf, "caught SIGTERM, shutting down");
+                         ap_server_conf, APLOGNO(00491) "caught SIGTERM, shutting down");
         }
         return DONE;
     } else if (shutdown_pending) {
@@ -2732,7 +2732,7 @@ static int event_run(apr_pool_t * _pconf, apr_pool_t * plog, server_rec * s)
         if (!child_fatal) {
             /* cleanup pid file on normal shutdown */
             ap_remove_pid(pconf, ap_pid_fname);
-            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00492)
                          "caught " AP_SIG_GRACEFUL_STOP_STRING
                          ", shutting down gracefully");
         }
@@ -2788,7 +2788,7 @@ static int event_run(apr_pool_t * _pconf, apr_pool_t * plog, server_rec * s)
     ap_scoreboard_image->global->running_generation = retained->my_generation;
 
     if (retained->is_graceful) {
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00493)
                      AP_SIG_GRACEFUL_STRING
                      " received.  Doing graceful restart");
         /* wake up the children...time to die.  But we'll have more soon */
@@ -2809,7 +2809,7 @@ static int event_run(apr_pool_t * _pconf, apr_pool_t * plog, server_rec * s)
 
         ap_reclaim_child_processes(1,  /* Start with SIGTERM */
                                    event_note_child_killed);
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00494)
                      "SIGHUP received.  Attempting to restart");
     }
 
@@ -2885,7 +2885,7 @@ static int event_pre_config(apr_pool_t * pconf, apr_pool_t * plog,
         rv = apr_pollset_create(&event_pollset, 1, plog,
                                 APR_POLLSET_WAKEABLE|APR_POLLSET_NOCOPY);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00495)
                          "apr_pollset_create failed; check system or user limits");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -2897,7 +2897,7 @@ static int event_pre_config(apr_pool_t * pconf, apr_pool_t * plog,
             rv = apr_proc_detach(no_detach ? APR_PROC_DETACH_FOREGROUND
                                  : APR_PROC_DETACH_DAEMONIZE);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00496)
                              "apr_proc_detach failed");
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
@@ -2932,14 +2932,14 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (server_limit > MAX_SERVER_LIMIT) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00497)
                          "WARNING: ServerLimit of %d exceeds compile-time "
                          "limit of", server_limit);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " %d servers, decreasing to %d.",
                          MAX_SERVER_LIMIT, MAX_SERVER_LIMIT);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00498)
                          "ServerLimit of %d exceeds compile-time limit "
                          "of %d, decreasing to match",
                          server_limit, MAX_SERVER_LIMIT);
@@ -2948,11 +2948,11 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (server_limit < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00499)
                          "WARNING: ServerLimit of %d not allowed, "
                          "increasing to 1.", server_limit);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00500)
                          "ServerLimit of %d not allowed, increasing to 1",
                          server_limit);
         }
@@ -2967,7 +2967,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (server_limit != retained->first_server_limit) {
         /* don't need a startup console version here */
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00501)
                      "changing ServerLimit to %d from original value of %d "
                      "not allowed during restart",
                      server_limit, retained->first_server_limit);
@@ -2976,14 +2976,14 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (thread_limit > MAX_THREAD_LIMIT) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00502)
                          "WARNING: ThreadLimit of %d exceeds compile-time "
                          "limit of", thread_limit);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " %d threads, decreasing to %d.",
                          MAX_THREAD_LIMIT, MAX_THREAD_LIMIT);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00503)
                          "ThreadLimit of %d exceeds compile-time limit "
                          "of %d, decreasing to match",
                          thread_limit, MAX_THREAD_LIMIT);
@@ -2992,11 +2992,11 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (thread_limit < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00504)
                          "WARNING: ThreadLimit of %d not allowed, "
                          "increasing to 1.", thread_limit);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00505)
                          "ThreadLimit of %d not allowed, increasing to 1",
                          thread_limit);
         }
@@ -3011,7 +3011,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (thread_limit != retained->first_thread_limit) {
         /* don't need a startup console version here */
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00506)
                      "changing ThreadLimit to %d from original value of %d "
                      "not allowed during restart",
                      thread_limit, retained->first_thread_limit);
@@ -3020,7 +3020,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (threads_per_child > thread_limit) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00507)
                          "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
                          "of", threads_per_child);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -3030,7 +3030,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
                          " To increase, please see the ThreadLimit "
                          "directive.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00508)
                          "ThreadsPerChild of %d exceeds ThreadLimit "
                          "of %d, decreasing to match",
                          threads_per_child, thread_limit);
@@ -3039,11 +3039,11 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (threads_per_child < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00509)
                          "WARNING: ThreadsPerChild of %d not allowed, "
                          "increasing to 1.", threads_per_child);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00510)
                          "ThreadsPerChild of %d not allowed, increasing to 1",
                          threads_per_child);
         }
@@ -3052,7 +3052,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (max_workers < threads_per_child) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00511)
                          "WARNING: MaxRequestWorkers of %d is less than "
                          "ThreadsPerChild of", max_workers);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -3062,7 +3062,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " as the number of threads in a single server.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00512)
                          "MaxRequestWorkers of %d is less than ThreadsPerChild "
                          "of %d, increasing to match",
                          max_workers, threads_per_child);
@@ -3076,7 +3076,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
         int tmp_max_workers = ap_daemons_limit * threads_per_child;
 
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00513)
                          "WARNING: MaxRequestWorkers of %d is not an integer "
                          "multiple of", max_workers);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -3087,7 +3087,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
                          " for a maximum of %d servers.",
                          ap_daemons_limit);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00514)
                          "MaxRequestWorkers of %d is not an integer multiple "
                          "of ThreadsPerChild of %d, decreasing to nearest "
                          "multiple %d", max_workers, threads_per_child,
@@ -3098,7 +3098,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (ap_daemons_limit > server_limit) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00515)
                          "WARNING: MaxRequestWorkers of %d would require %d "
                          "servers and ", max_workers, ap_daemons_limit);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -3108,7 +3108,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
                          " To increase, please see the ServerLimit "
                          "directive.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00516)
                          "MaxRequestWorkers of %d would require %d servers and "
                          "exceed ServerLimit of %d, decreasing to %d",
                          max_workers, ap_daemons_limit, server_limit,
@@ -3120,11 +3120,11 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
     /* ap_daemons_to_start > ap_daemons_limit checked in ap_mpm_run() */
     if (ap_daemons_to_start < 0) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00517)
                          "WARNING: StartServers of %d not allowed, "
                          "increasing to 1.", ap_daemons_to_start);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00518)
                          "StartServers of %d not allowed, increasing to 1",
                          ap_daemons_to_start);
         }
@@ -3133,7 +3133,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (min_spare_threads < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00519)
                          "WARNING: MinSpareThreads of %d not allowed, "
                          "increasing to 1", min_spare_threads);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -3141,7 +3141,7 @@ static int event_check_config(apr_pool_t *p, apr_pool_t *plog,
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " Please read the documentation.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00520)
                          "MinSpareThreads of %d not allowed, increasing to 1",
                          min_spare_threads);
         }
@@ -3221,7 +3221,7 @@ static const char *set_max_workers(cmd_parms * cmd, void *dummy,
         return err;
     }
     if (!strcasecmp(cmd->cmd->name, "MaxClients")) {
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL, APLOGNO(00521)
                      "MaxClients is deprecated, use MaxRequestWorkers "
                      "instead.");
     }
diff --git a/server/mpm/event/pod.c b/server/mpm/event/pod.c
index 2c5d897..5deed8b 100644
--- a/server/mpm/event/pod.c
+++ b/server/mpm/event/pod.c
@@ -91,7 +91,7 @@ static apr_status_t pod_signal_internal(ap_event_pod_t * pod, int graceful)
 
     rv = apr_file_write(pod->pod_out, &char_of_death, &one);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, APLOGNO(00522)
                      "write pipe_of_death");
     }
     return rv;
diff --git a/server/mpm/mpmt_os2/mpmt_os2.c b/server/mpm/mpmt_os2/mpmt_os2.c
index 10362df..3bd360d 100644
--- a/server/mpm/mpmt_os2/mpmt_os2.c
+++ b/server/mpm/mpmt_os2/mpmt_os2.c
@@ -161,7 +161,7 @@ static int mpmt_os2_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
         is_parent_process = TRUE;
 
         if (ap_setup_listeners(ap_server_conf) < 1) {
-            ap_log_error(APLOG_MARK, APLOG_ALERT, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, 0, s, APLOGNO(00200)
                          "no listening sockets available, shutting down");
             return 1;
         }
@@ -174,7 +174,7 @@ static int mpmt_os2_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
 
         if (!restart) {
             ap_remove_pid(pconf, ap_pid_fname);
-            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00201)
                          "caught SIGTERM, shutting down");
             return 1;
         }
@@ -201,7 +201,7 @@ static char master_main()
     set_signals();
 
     if (ap_setup_listeners(ap_server_conf) < 1) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, 0, s, APLOGNO(00202)
                      "no listening sockets available, shutting down");
         return FALSE;
     }
@@ -217,7 +217,7 @@ static char master_main()
                            PAG_READ|PAG_WRITE|PAG_COMMIT);
 
     if (rc) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, APR_FROM_OS_ERROR(rc), s,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, APR_FROM_OS_ERROR(rc), s, APLOGNO(00203)
                      "failure allocating shared memory, shutting down");
         return FALSE;
     }
@@ -234,7 +234,7 @@ static char master_main()
     rc = DosCreateMutexSem(NULL, &ap_mpm_accept_mutex, DC_SEM_SHARED, FALSE);
 
     if (rc) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, APR_FROM_OS_ERROR(rc), s,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, APR_FROM_OS_ERROR(rc), s, APLOGNO(00204)
                      "failure creating accept mutex, shutting down");
         return FALSE;
     }
@@ -249,7 +249,7 @@ static char master_main()
                                PAG_COMMIT|PAG_READ|PAG_WRITE);
 
         if (rc) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf, APLOGNO(00205)
                          "unable to allocate shared memory for scoreboard , exiting");
             return FALSE;
         }
@@ -258,10 +258,10 @@ static char master_main()
     }
 
     ap_scoreboard_image->global->restart_time = apr_time_now();
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00206)
                 "%s configured -- resuming normal operations",
                 ap_get_server_description());
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00207)
                 "Server built: %s", ap_get_server_built());
     if (one_process) {
         ap_scoreboard_image->parent[0].pid = getpid();
@@ -339,7 +339,7 @@ static void spawn_child(int slot)
                     ppib->pib_pchcmd, NULL, &proc_rc, progname);
 
     if (rc) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf, APLOGNO(00208)
                      "error spawning child, slot %d", slot);
     }
 
@@ -382,17 +382,17 @@ static void set_signals()
     sa.sa_handler = sig_term;
 
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00209) "sigaction(SIGTERM)");
 
     if (sigaction(SIGINT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGINT)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00210) "sigaction(SIGINT)");
 
     sa.sa_handler = sig_restart;
 
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGHUP)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00211) "sigaction(SIGHUP)");
     if (sigaction(SIGUSR1, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGUSR1)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00212) "sigaction(SIGUSR1)");
 }
 
 
@@ -492,11 +492,11 @@ static int mpmt_os2_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (ap_daemons_to_start < 0) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00213)
                          "WARNING: StartServers of %d not allowed, "
                          "increasing to 1.", ap_daemons_to_start);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00214)
                          "StartServers of %d not allowed, increasing to 1",
                          ap_daemons_to_start);
         }
@@ -505,7 +505,7 @@ static int mpmt_os2_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (ap_min_spare_threads < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00215)
                          "WARNING: MinSpareThreads of %d not allowed, "
                          "increasing to 1", ap_min_spare_threads);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -513,7 +513,7 @@ static int mpmt_os2_check_config(apr_pool_t *p, apr_pool_t *plog,
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " Please read the documentation.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00216)
                          "MinSpareThreads of %d not allowed, increasing to 1",
                          ap_min_spare_threads);
         }
diff --git a/server/mpm/mpmt_os2/mpmt_os2_child.c b/server/mpm/mpmt_os2/mpmt_os2_child.c
index fd5afba..ca9f594 100644
--- a/server/mpm/mpmt_os2/mpmt_os2_child.c
+++ b/server/mpm/mpmt_os2/mpmt_os2_child.c
@@ -117,7 +117,7 @@ void ap_mpm_child_main(apr_pool_t *pconf)
     rc = DosCreateEventSem(NULL, &shutdown_event, 0, FALSE);
 
     if (rc) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf, APLOGNO(00189)
                      "unable to create shutdown semaphore, exiting");
         clean_child_exit(APEXIT_CHILDFATAL);
     }
@@ -127,7 +127,7 @@ void ap_mpm_child_main(apr_pool_t *pconf)
                               PAG_READ|PAG_WRITE);
 
     if (rc) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf, APLOGNO(00190)
                      "scoreboard not readable in child, exiting");
         clean_child_exit(APEXIT_CHILDFATAL);
     }
@@ -139,7 +139,7 @@ void ap_mpm_child_main(apr_pool_t *pconf)
     rc = DosOpenMutexSem(NULL, &ap_mpm_accept_mutex);
 
     if (rc) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf, APLOGNO(00191)
                      "accept mutex couldn't be accessed in child, exiting");
         clean_child_exit(APEXIT_CHILDFATAL);
     }
@@ -148,7 +148,7 @@ void ap_mpm_child_main(apr_pool_t *pconf)
     for (child_slot = 0; ap_scoreboard_image->parent[child_slot].pid != my_pid && child_slot < HARD_SERVER_LIMIT; child_slot++);
 
     if (child_slot == HARD_SERVER_LIMIT) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00192)
                      "child pid not found in scoreboard, exiting");
         clean_child_exit(APEXIT_CHILDFATAL);
     }
@@ -162,7 +162,7 @@ void ap_mpm_child_main(apr_pool_t *pconf)
     rc = DosCreateQueue(&workq, QUE_FIFO, apr_psprintf(pchild, "/queues/httpd/work.%d", my_pid));
 
     if (rc) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf, APLOGNO(00193)
                      "unable to create work queue, exiting");
         clean_child_exit(APEXIT_CHILDFATAL);
     }
@@ -235,7 +235,7 @@ void ap_mpm_child_main(apr_pool_t *pconf)
 
         if (rv != APR_SUCCESS) {
             if (!APR_STATUS_IS_EINTR(rv)) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00194)
                              "apr_socket_accept");
                 clean_child_exit(APEXIT_CHILDFATAL);
             }
@@ -319,7 +319,7 @@ ULONG APIENTRY thread_exception_handler(EXCEPTIONREPORTRECORD *pReportRec,
 
     if (pReportRec->ExceptionNum == XCPT_ACCESS_VIOLATION ||
         pReportRec->ExceptionNum == XCPT_INTEGER_DIVIDE_BY_ZERO) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00195)
                      "caught exception in worker thread, initiating child shutdown pid=%d", getpid());
         for (c=0; c<HARD_THREAD_LIMIT; c++) {
             if (ap_scoreboard_image->servers[child_slot][c].tid == _gettid()) {
@@ -370,7 +370,7 @@ static void worker_main(void *vpArg)
                       apr_psprintf(pchild, "/queues/httpd/work.%d", getpid()));
 
     if (rc) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf, APLOGNO(00196)
                      "unable to open work queue, exiting");
         ap_scoreboard_image->servers[child_slot][thread_slot].tid = 0;
     }
@@ -424,7 +424,7 @@ static void server_maintenance(void *vpArg)
                       apr_psprintf(pchild, "/queues/httpd/work.%d", getpid()));
 
     if (rc) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_FROM_OS_ERROR(rc), ap_server_conf, APLOGNO(00197)
                      "unable to open work queue in maintenance thread");
         return;
     }
@@ -479,10 +479,10 @@ static void set_signals()
     sa.sa_handler = sig_term;
 
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00198) "sigaction(SIGTERM)");
 
     sa.sa_handler = sig_hup;
 
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGHUP)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00199) "sigaction(SIGHUP)");
 }
diff --git a/server/mpm/netware/mpm_netware.c b/server/mpm/netware/mpm_netware.c
index 1f3ee97..7784049 100644
--- a/server/mpm/netware/mpm_netware.c
+++ b/server/mpm/netware/mpm_netware.c
@@ -405,7 +405,7 @@ void worker_main(void *arg)
 
             if (srv <= 0) {
                 if (srv < 0) {
-                    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+                    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00217)
                         "select() failed on listen socket");
                     apr_thread_yield();
                 }
@@ -504,14 +504,14 @@ void worker_main(void *arg)
                         * Ben Hyde noted that temporary ENETDOWN situations
                         * occur in mobile IP.
                         */
-                        ap_log_error(APLOG_MARK, APLOG_EMERG, stat, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_EMERG, stat, ap_server_conf, APLOGNO(00218)
                             "apr_socket_accept: giving up.");
                         clean_child_exit(APEXIT_CHILDFATAL, my_worker_num, ptrans,
                                          bucket_alloc);
                 }
 #endif
                 else {
-                        ap_log_error(APLOG_MARK, APLOG_ERR, stat, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_ERR, stat, ap_server_conf, APLOGNO(00219)
                             "apr_socket_accept: (client socket)");
                         clean_child_exit(1, my_worker_num, ptrans, bucket_alloc);
                 }
@@ -680,7 +680,7 @@ static void perform_idle_server_maintenance(apr_pool_t *p)
             static int reported = 0;
 
             if (!reported) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00220)
                     "server reached MaxRequestWorkers setting, consider"
                     " raising the MaxRequestWorkers setting");
                 reported = 1;
@@ -689,7 +689,7 @@ static void perform_idle_server_maintenance(apr_pool_t *p)
         }
         else {
             if (idle_spawn_rate >= 8) {
-                ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00221)
                     "server seems busy, (you may need "
                     "to increase StartServers, or Min/MaxSpareServers), "
                     "spawning %d children, there are %d idle, and "
@@ -830,7 +830,7 @@ static int setup_listeners(server_rec *s)
     int sockdes;
 
     if (ap_setup_listeners(s) < 1 ) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, 0, s, APLOGNO(00222)
             "no listening sockets available, shutting down");
         return -1;
     }
@@ -870,7 +870,7 @@ static int netware_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     ap_server_conf = s;
 
     if (setup_listeners(s)) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, status, s,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, status, s, APLOGNO(00223)
             "no listening sockets available, shutting down");
         return -1;
     }
@@ -910,10 +910,10 @@ static int netware_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         hold_screen_on_exit = 0;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00224)
             "%s configured -- resuming normal operations",
             ap_get_server_description());
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00225)
             "Server built: %s", ap_get_server_built());
     ap_log_command_line(plog, s);
     show_server_data();
@@ -938,7 +938,7 @@ static int netware_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     shutdown_listeners();*/
 
     if (shutdown_pending) { /* Got an unload from the console */
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00226)
             "caught SIGTERM, shutting down");
 
         while (worker_thread_count > 0) {
@@ -958,7 +958,7 @@ static int netware_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         ++ap_my_generation;
         ap_scoreboard_image->global->running_generation = ap_my_generation;
 
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00227)
                 "Graceful restart requested, doing restart");
 
         /* Wait for all of the threads to terminate before initiating the restart */
@@ -1018,7 +1018,7 @@ static int netware_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (ap_threads_limit > HARD_THREAD_LIMIT) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00228)
                          "WARNING: MaxThreads of %d exceeds compile-time "
                          "limit of", ap_threads_limit);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -1030,7 +1030,7 @@ static int netware_check_config(apr_pool_t *p, apr_pool_t *plog,
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " server/mpm/netware%s.", MPM_HARD_LIMITS_FILE);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00229)
                          "MaxThreads of %d exceeds compile-time limit "
                          "of %d, decreasing to match",
                          ap_threads_limit, HARD_THREAD_LIMIT);
@@ -1040,7 +1040,7 @@ static int netware_check_config(apr_pool_t *p, apr_pool_t *plog,
     else if (ap_threads_limit < 1) {
         if (startup) {
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
-                         "WARNING: MaxThreads of %d not allowed, "
+                         APLOGNO(00230) "WARNING: MaxThreads of %d not allowed, "
                          "increasing to 1.", ap_threads_limit);
         } else {
             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
@@ -1055,11 +1055,11 @@ static int netware_check_config(apr_pool_t *p, apr_pool_t *plog,
      */
     if (ap_threads_to_start < 0) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00231)
                          "WARNING: StartThreads of %d not allowed, "
                          "increasing to 1.", ap_threads_to_start);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00232)
                          "StartThreads of %d not allowed, increasing to 1",
                          ap_threads_to_start);
         }
@@ -1068,7 +1068,7 @@ static int netware_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (ap_threads_min_free < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00233)
                          "WARNING: MinSpareThreads of %d not allowed, "
                          "increasing to 1", ap_threads_min_free);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -1076,7 +1076,7 @@ static int netware_check_config(apr_pool_t *p, apr_pool_t *plog,
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " Please read the documentation.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00234)
                          "MinSpareThreads of %d not allowed, increasing to 1",
                          ap_threads_min_free);
         }
diff --git a/server/mpm/prefork/prefork.c b/server/mpm/prefork/prefork.c
index 5c382c9..5de88e3 100644
--- a/server/mpm/prefork/prefork.c
+++ b/server/mpm/prefork/prefork.c
@@ -175,7 +175,7 @@ static void chdir_for_gprof(void)
                            APR_GREAD | APR_GEXECUTE |
                            APR_WREAD | APR_WEXECUTE, pconf);
         if(res != APR_SUCCESS && !APR_STATUS_IS_EEXIST(res)) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, res, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_ERR, res, ap_server_conf, APLOGNO(00142)
                          "gprof: error creating directory %s", dir);
         }
     }
@@ -235,11 +235,11 @@ static void accept_mutex_on(void)
 
         if (retained->my_generation !=
             ap_scoreboard_image->global->running_generation) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, ap_server_conf, "%s", msg);
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, ap_server_conf, APLOGNO(00143) "%s", msg);
             clean_child_exit(0);
         }
         else {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf, "%s", msg);
+            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf, APLOGNO(00144) "%s", msg);
             exit(APEXIT_CHILDFATAL);
         }
     }
@@ -253,14 +253,14 @@ static void accept_mutex_off(void)
 
         if (retained->my_generation !=
             ap_scoreboard_image->global->running_generation) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, ap_server_conf, "%s", msg);
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, ap_server_conf, APLOGNO(00145) "%s", msg);
             /* don't exit here... we have a connection to
              * process, after which point we'll see that the
              * generation changed and we'll exit cleanly
              */
         }
         else {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf, "%s", msg);
+            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf, APLOGNO(00146) "%s", msg);
             exit(APEXIT_CHILDFATAL);
         }
     }
@@ -402,20 +402,20 @@ static void set_signals(void)
 
     sa.sa_handler = sig_term;
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00147) "sigaction(SIGTERM)");
 #ifdef AP_SIG_GRACEFUL_STOP
     if (sigaction(AP_SIG_GRACEFUL_STOP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00148)
                      "sigaction(" AP_SIG_GRACEFUL_STOP_STRING ")");
 #endif
 #ifdef SIGINT
     if (sigaction(SIGINT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGINT)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00149) "sigaction(SIGINT)");
 #endif
 #ifdef SIGXCPU
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXCPU, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGXCPU)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00150) "sigaction(SIGXCPU)");
 #endif
 #ifdef SIGXFSZ
     /* For systems following the LFS standard, ignoring SIGXFSZ allows
@@ -423,12 +423,12 @@ static void set_signals(void)
      * rather than terminate the process. */
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGXFSZ, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGXFSZ)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00151) "sigaction(SIGXFSZ)");
 #endif
 #ifdef SIGPIPE
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGPIPE, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGPIPE)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00152) "sigaction(SIGPIPE)");
 #endif
 
     /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy
@@ -438,9 +438,9 @@ static void set_signals(void)
     sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
     sa.sa_handler = restart;
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGHUP)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00153) "sigaction(SIGHUP)");
     if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(" AP_SIG_GRACEFUL_STRING ")");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00154) "sigaction(" AP_SIG_GRACEFUL_STRING ")");
 #else
     if (!one_process) {
 #ifdef SIGXCPU
@@ -528,7 +528,7 @@ static void child_main(int child_num_arg)
                                        lockfile,
                                        pchild);
     if (status != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf, APLOGNO(00155)
                      "Couldn't initialize cross-process lock in child "
                      "(%s) (%s)",
                      lockfile ? lockfile : "none",
@@ -549,7 +549,7 @@ static void child_main(int child_num_arg)
     /* Set up the pollfd array */
     status = apr_pollset_create(&pollset, num_listensocks, pchild, 0);
     if (status != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf, APLOGNO(00156)
                      "Couldn't create pollset in child; check system or user limits");
         clean_child_exit(APEXIT_CHILDSICK); /* assume temporary resource issue */
     }
@@ -564,7 +564,7 @@ static void child_main(int child_num_arg)
 
         status = apr_pollset_add(pollset, &pfd);
         if (status != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf, APLOGNO(00157)
                          "Couldn't add listener to pollset; check system or user limits");
             clean_child_exit(APEXIT_CHILDSICK);
         }
@@ -639,7 +639,7 @@ static void child_main(int child_num_arg)
                      * occasionally, and we'd loop forever due to it.
                      */
                     ap_log_error(APLOG_MARK, APLOG_ERR, status,
-                                 ap_server_conf, "apr_pollset_poll: (listen)");
+                                 ap_server_conf, APLOGNO(00158) "apr_pollset_poll: (listen)");
                     SAFE_ACCEPT(accept_mutex_off());
                     clean_child_exit(1);
                 }
@@ -750,7 +750,7 @@ static int make_child(server_rec *s, int slot)
 #else
     if ((pid = fork()) == -1) {
 #endif
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, "fork: Unable to fork new process");
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, APLOGNO(00159) "fork: Unable to fork new process");
 
         /* fork didn't succeed. Fix the scoreboard or else
          * it will say SERVER_STARTING forever and ever
@@ -776,7 +776,7 @@ static int make_child(server_rec *s, int slot)
                                    PROCESSOR_CLASS_ANY);
         if (status != OK) {
             ap_log_error(APLOG_MARK, APLOG_DEBUG, errno,
-                         ap_server_conf, "processor unbind failed");
+                         ap_server_conf, APLOGNO(00160) "processor unbind failed");
         }
 #endif
         RAISE_SIGSTOP(MAKE_CHILD);
@@ -875,7 +875,7 @@ static void perform_idle_server_maintenance(apr_pool_t *p)
         if (free_length == 0) {
             /* only report this condition once */
             if (!retained->maxclients_reported) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00161)
                             "server reached MaxRequestWorkers setting, consider"
                             " raising the MaxRequestWorkers setting");
                 retained->maxclients_reported = 1;
@@ -884,7 +884,7 @@ static void perform_idle_server_maintenance(apr_pool_t *p)
         }
         else {
             if (retained->idle_spawn_rate >= 8) {
-                ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00162)
                     "server seems busy, (you may need "
                     "to increase StartServers, or Min/MaxSpareServers), "
                     "spawning %d children, there are %d idle, and "
@@ -976,13 +976,13 @@ static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         retained->hold_off_on_exponential_spawning = 10;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00163)
                 "%s configured -- resuming normal operations",
                 ap_get_server_description());
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00164)
                 "Server built: %s", ap_get_server_built());
     ap_log_command_line(plog, s);
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00165)
                 "Accept mutex: %s (default: %s)",
                 apr_proc_mutex_name(accept_mutex),
                 apr_proc_mutex_defname());
@@ -1018,7 +1018,7 @@ static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                     return DONE;
                 }
                 else {
-                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf,
+                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf, APLOGNO(00166)
                                  "Ignoring fatal error in child of previous "
                                  "generation (pid %ld).",
                                  (long)pid.pid);
@@ -1056,7 +1056,7 @@ static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                  * child.
                  */
                 ap_log_error(APLOG_MARK, APLOG_WARNING,
-                            0, ap_server_conf,
+                            0, ap_server_conf, APLOGNO(00167)
                             "long lost child came home! (pid %ld)", (long)pid.pid);
             }
             /* Don't perform idle maintenance when a child dies,
@@ -1091,14 +1091,14 @@ static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
          * Kill child processes, tell them to call child_exit, etc...
          */
         if (ap_unixd_killpg(getpgrp(), SIGTERM) < 0) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "killpg SIGTERM");
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00168) "killpg SIGTERM");
         }
         ap_reclaim_child_processes(1, /* Start with SIGTERM */
                                    prefork_note_child_killed);
 
         /* cleanup pid file on normal shutdown */
         ap_remove_pid(pconf, ap_pid_fname);
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00169)
                     "caught SIGTERM, shutting down");
 
         return DONE;
@@ -1132,7 +1132,7 @@ static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
         /* cleanup pid file */
         ap_remove_pid(pconf, ap_pid_fname);
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00170)
            "caught " AP_SIG_GRACEFUL_STOP_STRING ", shutting down gracefully");
 
         if (ap_graceful_shutdown_timeout) {
@@ -1185,7 +1185,7 @@ static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     ap_scoreboard_image->global->running_generation = retained->my_generation;
 
     if (retained->is_graceful) {
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00171)
                     "Graceful restart requested, doing restart");
 
         /* kill off the idle ones */
@@ -1213,11 +1213,11 @@ static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     else {
         /* Kill 'em off */
         if (ap_unixd_killpg(getpgrp(), SIGHUP) < 0) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "killpg SIGHUP");
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00172) "killpg SIGHUP");
         }
         ap_reclaim_child_processes(0, /* Not when just starting up */
                                    prefork_note_child_killed);
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00173)
                     "SIGHUP received.  Attempting to restart");
     }
 
@@ -1295,7 +1295,7 @@ static int prefork_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp
             rv = apr_proc_detach(no_detach ? APR_PROC_DETACH_FOREGROUND
                                            : APR_PROC_DETACH_DAEMONIZE);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00174)
                              "apr_proc_detach failed");
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
@@ -1327,14 +1327,14 @@ static int prefork_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (server_limit > MAX_SERVER_LIMIT) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00175)
                          "WARNING: ServerLimit of %d exceeds compile-time "
                          "limit of", server_limit);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " %d servers, decreasing to %d.",
                          MAX_SERVER_LIMIT, MAX_SERVER_LIMIT);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00176)
                          "ServerLimit of %d exceeds compile-time limit "
                          "of %d, decreasing to match",
                          server_limit, MAX_SERVER_LIMIT);
@@ -1343,11 +1343,11 @@ static int prefork_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (server_limit < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00177)
                          "WARNING: ServerLimit of %d not allowed, "
                          "increasing to 1.", server_limit);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00178)
                          "ServerLimit of %d not allowed, increasing to 1",
                          server_limit);
         }
@@ -1362,7 +1362,7 @@ static int prefork_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (server_limit != retained->first_server_limit) {
         /* don't need a startup console version here */
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00179)
                      "changing ServerLimit to %d from original value of %d "
                      "not allowed during restart",
                      server_limit, retained->first_server_limit);
@@ -1371,7 +1371,7 @@ static int prefork_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (ap_daemons_limit > server_limit) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00180)
                          "WARNING: MaxRequestWorkers of %d exceeds ServerLimit "
                          "value of", ap_daemons_limit);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -1381,7 +1381,7 @@ static int prefork_check_config(apr_pool_t *p, apr_pool_t *plog,
                          " To increase, please see the ServerLimit "
                          "directive.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00181)
                          "MaxRequestWorkers of %d exceeds ServerLimit value "
                          "of %d, decreasing to match",
                          ap_daemons_limit, server_limit);
@@ -1390,11 +1390,11 @@ static int prefork_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (ap_daemons_limit < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00182)
                          "WARNING: MaxRequestWorkers of %d not allowed, "
                          "increasing to 1.", ap_daemons_limit);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00183)
                          "MaxRequestWorkers of %d not allowed, increasing to 1",
                          ap_daemons_limit);
         }
@@ -1404,11 +1404,11 @@ static int prefork_check_config(apr_pool_t *p, apr_pool_t *plog,
     /* ap_daemons_to_start > ap_daemons_limit checked in prefork_run() */
     if (ap_daemons_to_start < 0) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00184)
                          "WARNING: StartServers of %d not allowed, "
                          "increasing to 1.", ap_daemons_to_start);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00185)
                          "StartServers of %d not allowed, increasing to 1",
                          ap_daemons_to_start);
         }
@@ -1417,7 +1417,7 @@ static int prefork_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (ap_daemons_min_free < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00186)
                          "WARNING: MinSpareServers of %d not allowed, "
                          "increasing to 1", ap_daemons_min_free);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -1425,7 +1425,7 @@ static int prefork_check_config(apr_pool_t *p, apr_pool_t *plog,
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " Please read the documentation.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00187)
                          "MinSpareServers of %d not allowed, increasing to 1",
                          ap_daemons_min_free);
         }
@@ -1496,7 +1496,7 @@ static const char *set_max_clients (cmd_parms *cmd, void *dummy, const char *arg
         return err;
     }
     if (!strcasecmp(cmd->cmd->name, "MaxClients")) {
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL, APLOGNO(00188)
                      "MaxClients is deprecated, use MaxRequestWorkers "
                      "instead.");
     }
diff --git a/server/mpm/simple/simple_api.c b/server/mpm/simple/simple_api.c
index 6de5226..b118b05 100644
--- a/server/mpm/simple/simple_api.c
+++ b/server/mpm/simple/simple_api.c
@@ -113,7 +113,7 @@ simple_open_logs(apr_pool_t * p,
 
     if (nsock < 1) {
         ap_log_error(APLOG_MARK, APLOG_ALERT, 0,
-                     s,
+                     s, APLOGNO(00256)
                      "simple_open_logs: no listening sockets available, shutting down");
         return DONE;
     }
@@ -132,7 +132,7 @@ simple_pre_config(apr_pool_t * pconf, apr_pool_t * plog, apr_pool_t * ptemp)
     rv = simple_core_init_once();
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00257)
                      "simple_core_init_once: Fatal Error Encountered");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -161,7 +161,7 @@ simple_pre_config(apr_pool_t * pconf, apr_pool_t * plog, apr_pool_t * ptemp)
         }
 
         if (rv) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00258)
                          "simple_pre_config: apr_proc_detach(%s) failed",
                          sc->run_foreground ? "FOREGROUND" : "DAEMONIZE");
             return HTTP_INTERNAL_SERVER_ERROR;
@@ -178,28 +178,28 @@ simple_check_config(apr_pool_t * p, apr_pool_t * plog,
     simple_core_t *sc = simple_core_get();
 
     if (sc->procmgr.proc_count > SIMPLE_MAX_PROC) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(00259)
                      "simple_check_config: SimpleProcCount must be at most %d",
                      SIMPLE_MAX_PROC);
         return !OK;
     }
 
     if (sc->procmgr.proc_count < SIMPLE_MIN_PROC) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(00260)
                      "simple_check_config: SimpleProcCount must be at least %d",
                      SIMPLE_MIN_PROC);
         return !OK;
     }
 
     if (sc->procmgr.thread_count > SIMPLE_MAX_THREADS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(00261)
                      "simple_check_config: SimpleThreadCount must be at most %d",
                      SIMPLE_MAX_THREADS);
         return !OK;
     }
 
     if (sc->procmgr.thread_count < SIMPLE_MIN_THREADS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, APLOGNO(00262)
                      "simple_check_config: SimpleThreadCount must be at least %d",
                      SIMPLE_MIN_THREADS);
         return !OK;
diff --git a/server/mpm/simple/simple_children.c b/server/mpm/simple/simple_children.c
index 0476f59..ef12bcb 100644
--- a/server/mpm/simple/simple_children.c
+++ b/server/mpm/simple/simple_children.c
@@ -73,7 +73,7 @@ static int simple_spawn_child(simple_core_t * sc)
             pid = fork();
             if (pid == -1) {
                 rv = errno;
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00245)
                              "simple_spawn_child: Unable to fork new process");
                 return rv;
             }
diff --git a/server/mpm/simple/simple_core.c b/server/mpm/simple/simple_core.c
index aa68211..24843be 100644
--- a/server/mpm/simple/simple_core.c
+++ b/server/mpm/simple/simple_core.c
@@ -64,7 +64,7 @@ apr_status_t simple_core_init_once(void)
     rv = apr_thread_mutex_create(&sc->mtx, 0, sc->pool);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00246)
                      "simple_core_init_once: apr_thread_mutex_create failed.");
         return rv;
     }
diff --git a/server/mpm/simple/simple_io.c b/server/mpm/simple/simple_io.c
index c3d5373..0ba0cee 100644
--- a/server/mpm/simple/simple_io.c
+++ b/server/mpm/simple/simple_io.c
@@ -40,7 +40,7 @@ static void simple_io_timeout_cb(simple_core_t * sc, void *baton)
     cs = NULL;
 #endif
 
-    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf, APLOGNO(00247)
                  "io timeout hit (?)");
 }
 
@@ -69,7 +69,7 @@ static apr_status_t simple_io_process(simple_conn_t * scon)
         if (scon->pfd.reqevents != 0) {
             rv = apr_pollcb_remove(sc->pollcb, &scon->pfd);
             if (rv) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00248)
                              "simple_io_process: apr_pollcb_remove failure");
                 /*AP_DEBUG_ASSERT(rv == APR_SUCCESS);*/
             }
@@ -99,7 +99,7 @@ static apr_status_t simple_io_process(simple_conn_t * scon)
                                                            NULL);
 
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, APLOGNO(00249)
                              "network write failure in core output filter");
                 scon->cs.state = CONN_STATE_LINGER;
             }
@@ -123,7 +123,7 @@ static apr_status_t simple_io_process(simple_conn_t * scon)
 
                 if (rv != APR_SUCCESS) {
                     ap_log_error(APLOG_MARK, APLOG_WARNING, rv,
-                                 ap_server_conf,
+                                 ap_server_conf, APLOGNO(00250)
                                  "apr_pollcb_add: failed in write completion");
                     AP_DEBUG_ASSERT(rv == APR_SUCCESS);
                 }
@@ -160,7 +160,7 @@ static apr_status_t simple_io_process(simple_conn_t * scon)
             rv = apr_pollcb_add(sc->pollcb, &scon->pfd);
 
             if (rv) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00251)
                              "process_socket: apr_pollcb_add failure in read request line");
                 AP_DEBUG_ASSERT(rv == APR_SUCCESS);
             }
@@ -185,7 +185,7 @@ static void *simple_io_invoke(apr_thread_t * thread, void *baton)
     rv = simple_io_process(scon);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, ap_server_conf, APLOGNO(00252)
                      "simple_io_invoke: simple_io_process failed (?)");
     }
 
@@ -227,7 +227,7 @@ static void *simple_io_setup_conn(apr_thread_t * thread, void *baton)
 
     rv = ap_run_pre_connection(scon->c, scon->sock);
     if (rv != OK && rv != DONE) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00253)
                      "simple_io_setup_conn: connection aborted");
         scon->c->aborted = 1;
     }
@@ -237,7 +237,7 @@ static void *simple_io_setup_conn(apr_thread_t * thread, void *baton)
     rv = simple_io_process(scon);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, ap_server_conf, APLOGNO(00254)
                      "simple_io_setup_conn: simple_io_process failed (?)");
     }
 
@@ -265,7 +265,7 @@ apr_status_t simple_io_accept(simple_core_t * sc, simple_sb_t * sb)
          *
          * Need to discuss this on dev@
          */
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00255)
                      "simple_io_accept: apr_socket_accept failed");
         return APR_SUCCESS;
     }
diff --git a/server/mpm/simple/simple_run.c b/server/mpm/simple/simple_run.c
index 86ba246..6eb70ca 100644
--- a/server/mpm/simple/simple_run.c
+++ b/server/mpm/simple/simple_run.c
@@ -59,7 +59,7 @@ static apr_status_t simple_setup_workers(simple_core_t * sc)
                                 sc->procmgr.thread_count, sc->pool);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00235)
                      "simple_setup_workers: apr_thread_pool_create with %d threads failed",
                      sc->procmgr.thread_count);
         return rv;
@@ -89,7 +89,7 @@ static apr_status_t simple_setup_listeners(simple_core_t * sc)
 
         rv = apr_socket_opt_set(pfd->desc.s, APR_SO_NONBLOCK, 1);
         if (rv) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00236)
                          "simple_setup_workers: apr_socket_opt_set(APR_SO_NONBLOCK = 1) failed on %pI",
                          lr->bind_addr);
             return rv;
@@ -97,7 +97,7 @@ static apr_status_t simple_setup_listeners(simple_core_t * sc)
 
         rv = apr_pollcb_add(sc->pollcb, pfd);
         if (rv) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00237)
                          "simple_setup_workers: apr_pollcb_add failed on %pI",
                          lr->bind_addr);
             return rv;
@@ -236,7 +236,7 @@ void simple_single_process_hack(simple_core_t * sc)
     /* Normally this is only ran in the child processes, but we want to do it here too... */
     rv = simple_setup_listeners(sc);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00238)
                      "simple_single_child_hack: simple_setup_listeners failed");
     }
 }
@@ -246,7 +246,7 @@ static int simple_setup_privs(simple_core_t * sc)
     int rv = ap_run_drop_privileges(sc->pool, ap_server_conf);
 
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00239)
                      "simple_setup_privs: ap_run_drop_privileges failed");
         return rv;
     }
@@ -269,7 +269,7 @@ static int simple_setup_pollcb(simple_core_t * sc)
         }
     }
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00240)
                    "simple_setup_pollcb: apr_pollcb_create failed for all possible backends!");
         return rv;
     }
@@ -292,14 +292,14 @@ int simple_child_loop(simple_core_t * sc)
 
     rv = simple_setup_workers(sc);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00241)
                      "simple_child_loop: simple_setup_workers failed");
         return !OK;
     }
 
     rv = simple_setup_listeners(sc);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00242)
                      "simple_child_loop: simple_setup_sockets failed");
         return !OK;
     }
@@ -326,14 +326,14 @@ int simple_main_loop(simple_core_t * sc)
 
     rv = simple_setup_workers(sc);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00243)
                      "simple_main_loop: simple_setup_workers failed");
         return !OK;
     }
 
     rv = simple_main_setup_timers(sc);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00244)
                      "simple_main_loop: simple_setup_timers failed");
         return !OK;
     }
diff --git a/server/mpm/winnt/child.c b/server/mpm/winnt/child.c
index 1f82013..ab4fddc 100644
--- a/server/mpm/winnt/child.c
+++ b/server/mpm/winnt/child.c
@@ -166,7 +166,7 @@ static winnt_conn_ctx_t *mpm_get_completion_context(int *timeout)
                 /* All workers are busy, need to wait for one */
                 static int reported = 0;
                 if (!reported) {
-                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
+                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00326)
                                  "Server ran out of threads to serve "
                                  "requests. Consider raising the "
                                  "ThreadsPerChild setting");
@@ -184,7 +184,7 @@ static winnt_conn_ctx_t *mpm_get_completion_context(int *timeout)
                 else {
                     if (rv == WAIT_TIMEOUT) {
                         /* somewhat-normal condition where threads are busy */
-                        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00327)
                                      "mpm_get_completion_context: Failed to get a "
                                      "free context within 1 second");
                         *timeout = 1;
@@ -192,7 +192,7 @@ static winnt_conn_ctx_t *mpm_get_completion_context(int *timeout)
                     else {
                         /* should be the unexpected, generic WAIT_FAILED */
                         ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_os_error(),
-                                     ap_server_conf,
+                                     ap_server_conf, APLOGNO(00328)
                                      "mpm_get_completion_context: "
                                      "WaitForSingleObject failed to get free context");
                     }
@@ -216,7 +216,7 @@ static winnt_conn_ctx_t *mpm_get_completion_context(int *timeout)
                 if (context->overlapped.hEvent == NULL) {
                     /* Hopefully this is a temporary condition ... */
                     ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_os_error(),
-                                 ap_server_conf,
+                                 ap_server_conf, APLOGNO(00329)
                                  "mpm_get_completion_context: "
                                  "CreateEvent failed.");
 
@@ -230,7 +230,7 @@ static winnt_conn_ctx_t *mpm_get_completion_context(int *timeout)
                 rv = apr_pool_create_ex(&context->ptrans, pchild, NULL,
                                         allocator);
                 if (rv != APR_SUCCESS) {
-                    ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
+                    ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, APLOGNO(00330)
                                  "mpm_get_completion_context: Failed "
                                  "to create the transaction pool.");
                     CloseHandle(context->overlapped.hEvent);
@@ -305,7 +305,7 @@ static unsigned int __stdcall winnt_accept(void *lr_)
     else {
         accf = 0;
         accf_name = "none";
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf, APLOGNO(00331)
                      "winnt_accept: unrecognized AcceptFilter '%s', "
                      "only 'data', 'connect' or 'none' are valid. "
                      "Using 'none' instead", accf_name);
@@ -316,7 +316,7 @@ static unsigned int __stdcall winnt_accept(void *lr_)
 #if APR_HAVE_IPV6
     if (getsockname(nlsd, (struct sockaddr *)&ss_listen, &namelen) == SOCKET_ERROR) {
         ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_netos_error(),
-                     ap_server_conf,
+                     ap_server_conf, APLOGNO(00332)
                      "winnt_accept: getsockname error on listening socket, "
                      "is IPv6 available?");
         return 1;
@@ -344,14 +344,14 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
         rv = WSAEventSelect(nlsd, events[2], FD_ACCEPT);
         if (rv) {
             ap_log_error(APLOG_MARK, APLOG_ERR,
-                         apr_get_netos_error(), ap_server_conf,
+                         apr_get_netos_error(), ap_server_conf, APLOGNO(00333)
                          "WSAEventSelect() failed.");
             CloseHandle(events[2]);
             return 1;
         }
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00334)
                  "Child: Accept thread listening on %s:%d using AcceptFilter %s",
                  lr->bind_addr->hostname ? lr->bind_addr->hostname : "*",
                  lr->bind_addr->port, accf_name);
@@ -366,7 +366,7 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
                     /* Hopefully a temporary condition in the provider? */
                     ++err_count;
                     if (err_count > MAX_ACCEPTEX_ERR_COUNT) {
-                        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf, APLOGNO(00335)
                                      "winnt_accept: Too many failures grabbing a "
                                      "connection ctx.  Aborting.");
                         break;
@@ -402,7 +402,7 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
 
             if (context->accept_socket == INVALID_SOCKET) {
                 ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(),
-                             ap_server_conf,
+                             ap_server_conf, APLOGNO(00336)
                              "winnt_accept: Failed to allocate an accept socket. "
                              "Temporary resource constraint? Try again.");
                 Sleep(100);
@@ -454,12 +454,12 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
                     context->accept_socket = INVALID_SOCKET;
                     ++err_count;
                     if (err_count > MAX_ACCEPTEX_ERR_COUNT) {
-                        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00337)
                                      "Child: Encountered too many AcceptEx "
                                      "faults accepting client connections. "
                                      "Possible causes: dynamic address renewal, "
                                      "or incompatible VPN or firewall software. ");
-                        ap_log_error(APLOG_MARK, APLOG_NOTICE, rv, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_NOTICE, rv, ap_server_conf, APLOGNO(00338)
                                      "winnt_mpm: falling back to "
                                      "'AcceptFilter none'.");
                         err_count = 0;
@@ -475,10 +475,10 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
                     context->accept_socket = INVALID_SOCKET;
                     ++err_count;
                     if (err_count > MAX_ACCEPTEX_ERR_COUNT) {
-                        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00339)
                                      "Child: Encountered too many AcceptEx "
                                      "faults accepting client connections.");
-                        ap_log_error(APLOG_MARK, APLOG_NOTICE, rv, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_NOTICE, rv, ap_server_conf, APLOGNO(00340)
                                      "winnt_mpm: falling back to "
                                      "'AcceptFilter none'.");
                         err_count = 0;
@@ -501,7 +501,7 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
                                              &context->overlapped,
                                              &BytesRead, FALSE)) {
                         ap_log_error(APLOG_MARK, APLOG_WARNING,
-                                     apr_get_os_error(), ap_server_conf,
+                                     apr_get_os_error(), ap_server_conf, APLOGNO(00341)
                              "winnt_accept: Asynchronous AcceptEx failed.");
                         closesocket(context->accept_socket);
                         context->accept_socket = INVALID_SOCKET;
@@ -533,7 +533,7 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
                            SO_UPDATE_ACCEPT_CONTEXT, (char *)&nlsd,
                            sizeof(nlsd))) {
                 ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(),
-                             ap_server_conf,
+                             ap_server_conf, APLOGNO(00342)
                              "setsockopt(SO_UPDATE_ACCEPT_CONTEXT) failed.");
                 /* Not a failure condition. Keep running. */
             }
@@ -601,14 +601,14 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
                     || rv == APR_FROM_OS_ERROR(WSAEINPROGRESS)
                     || rv == APR_FROM_OS_ERROR(WSAEWOULDBLOCK) ) {
                     ap_log_error(APLOG_MARK, APLOG_DEBUG,
-                                 rv, ap_server_conf,
+                                 rv, ap_server_conf, APLOGNO(00343)
                                  "accept() failed, retrying.");
                     continue;
                 }
 
                 /* A more serious error than 'retry', log it */
                 ap_log_error(APLOG_MARK, APLOG_WARNING,
-                             rv, ap_server_conf,
+                             rv, ap_server_conf, APLOGNO(00344)
                              "accept() failed.");
 
                 if (   rv == APR_FROM_OS_ERROR(WSAEMFILE)
@@ -617,7 +617,7 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
                     Sleep(100);
                     ++err_count;
                     if (err_count > MAX_ACCEPTEX_ERR_COUNT) {
-                        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00345)
                                      "Child: Encountered too many accept() "
                                      "resource faults, aborting.");
                         break;
@@ -638,13 +638,13 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
             context->sa_server_len = sizeof(context->buff) / 2;
             if (getsockname(context->accept_socket, context->sa_server,
                             &context->sa_server_len) == SOCKET_ERROR) {
-                ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(), ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(), ap_server_conf, APLOGNO(00346)
                              "getsockname failed");
                 continue;
             }
             if ((getpeername(context->accept_socket, context->sa_client,
                              &context->sa_client_len)) == SOCKET_ERROR) {
-                ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(), ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(), ap_server_conf, APLOGNO(00347)
                              "getpeername failed");
                 memset(&context->sa_client, '\0', sizeof(context->sa_client));
             }
@@ -683,7 +683,7 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
         SetEvent(exit_event);
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf, APLOGNO(00348)
                  "Child: Accept thread exiting.");
     return 0;
 }
@@ -712,7 +712,7 @@ static winnt_conn_ctx_t *winnt_get_connection(winnt_conn_ctx_t *context)
                                        &CompKey, &pol, INFINITE);
         if (!rc) {
             rc = apr_get_os_error();
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, rc, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, rc, ap_server_conf, APLOGNO(00349)
                          "Child: GetQueuedComplationStatus returned %d",
                          rc);
             continue;
@@ -942,7 +942,7 @@ void child_main(apr_pool_t *pconf)
     /* Initialize the child_events */
     max_requests_per_child_event = CreateEvent(NULL, TRUE, FALSE, NULL);
     if (!max_requests_per_child_event) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00350)
                      "Child: Failed to create a max_requests event.");
         exit(APEXIT_CHILDINIT);
     }
@@ -956,12 +956,12 @@ void child_main(apr_pool_t *pconf)
      */
     status = apr_proc_mutex_lock(start_mutex);
     if (status != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf, APLOGNO(00351)
                      "Child: Failed to acquire the start_mutex. "
                      "Process will exit.");
         exit(APEXIT_CHILDINIT);
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf, APLOGNO(00352)
                  "Child: Acquired the start mutex.");
 
     /*
@@ -974,7 +974,7 @@ void child_main(apr_pool_t *pconf)
     qwait_event = CreateEvent(NULL, TRUE, FALSE, NULL);
     if (!qwait_event) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(),
-                     ap_server_conf,
+                     ap_server_conf, APLOGNO(00353)
                      "Child: Failed to create a qwait event.");
         exit(APEXIT_CHILDINIT);
     }
@@ -982,7 +982,7 @@ void child_main(apr_pool_t *pconf)
     /*
      * Create the pool of worker threads
      */
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf, APLOGNO(00354)
                  "Child: Starting %d worker threads.", ap_threads_per_child);
     child_handles = (HANDLE) apr_pcalloc(pchild, ap_threads_per_child
                                                   * sizeof(HANDLE));
@@ -1002,7 +1002,7 @@ void child_main(apr_pool_t *pconf)
                                             stack_res_flag, &tid);
             if (child_handles[i] == 0) {
                 ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(),
-                             ap_server_conf,
+                             ap_server_conf, APLOGNO(00355)
                              "Child: CreateThread failed. Unable to "
                              "create all worker threads. Created %d of the %d "
                              "threads requested with the ThreadsPerChild "
@@ -1078,13 +1078,13 @@ void child_main(apr_pool_t *pconf)
             if (rv == WAIT_FAILED) {
             /* Something serious is wrong */
             ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(),
-                         ap_server_conf,
+                         ap_server_conf, APLOGNO(00356)
                          "Child: WAIT_FAILED -- shutting down server");
             break;
         }
         else if (cld == 0) {
             /* Exit event was signaled */
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf, APLOGNO(00357)
                          "Child: Exit event signaled. Child process is "
                          "ending.");
             break;
@@ -1093,7 +1093,7 @@ void child_main(apr_pool_t *pconf)
             /* MaxConnectionsPerChild event set by the worker threads.
              * Signal the parent to restart
              */
-            ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf, APLOGNO(00358)
                          "Child: Process exiting because it reached "
                          "MaxConnectionsPerChild. Signaling the parent to "
                          "restart a new child process.");
@@ -1134,11 +1134,11 @@ void child_main(apr_pool_t *pconf)
      */
     rv = apr_proc_mutex_unlock(start_mutex);
     if (rv == APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, ap_server_conf, APLOGNO(00359)
                      "Child: Released the start mutex");
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00360)
                      "Child: Failure releasing the start mutex");
     }
 
@@ -1146,7 +1146,7 @@ void child_main(apr_pool_t *pconf)
      * Post worker threads blocked on the ThreadDispatch IOCompletion port
      */
     while (g_blocked_threads > 0) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf, APLOGNO(00361)
                      "Child: %d threads blocked on the completion port",
                      g_blocked_threads);
         for (i=g_blocked_threads; i > 0; i--) {
@@ -1187,7 +1187,7 @@ void child_main(apr_pool_t *pconf)
             /* Every 30 seconds give an update */
             if ((time_remains % 30000) == 0) {
                 ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS,
-                             ap_server_conf,
+                             ap_server_conf, APLOGNO(00362)
                              "Child: Waiting %d more seconds "
                              "for %d worker threads to finish.",
                              time_remains / 1000, threads_created);
@@ -1231,7 +1231,7 @@ void child_main(apr_pool_t *pconf)
 
     /* Kill remaining threads off the hard way */
     if (threads_created) {
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf, APLOGNO(00363)
                      "Child: Terminating %d threads that failed to exit.",
                      threads_created);
     }
@@ -1245,7 +1245,7 @@ void child_main(apr_pool_t *pconf)
             ap_update_child_status_from_indexes(0, *score_idx, SERVER_DEAD, NULL);
         }
     }
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf, APLOGNO(00364)
                  "Child: All worker threads have exited.");
 
     apr_thread_mutex_destroy(child_lock);
diff --git a/server/mpm/winnt/mpm_winnt.c b/server/mpm/winnt/mpm_winnt.c
index 2a74fe7..cdf7cac 100644
--- a/server/mpm/winnt/mpm_winnt.c
+++ b/server/mpm/winnt/mpm_winnt.c
@@ -246,13 +246,13 @@ AP_DECLARE(void) ap_signal_parent(ap_signal_parent_e type)
         /* Um, problem, can't signal the parent, which means we can't
          * signal ourselves to die. Ignore for now...
          */
-        ap_log_error(APLOG_MARK, APLOG_EMERG, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, apr_get_os_error(), ap_server_conf, APLOGNO(00382)
                      "OpenEvent on %s event", signal_name);
         return;
     }
     if (SetEvent(e) == 0) {
         /* Same problem as above */
-        ap_log_error(APLOG_MARK, APLOG_EMERG, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, apr_get_os_error(), ap_server_conf, APLOGNO(00383)
                      "SetEvent on %s event", signal_name);
         CloseHandle(e);
         return;
@@ -286,7 +286,7 @@ static void get_handles_from_parent(server_rec *s, HANDLE *child_exit_event,
     if (!ReadFile(pipe, &ready_event, sizeof(HANDLE),
                   &BytesRead, (LPOVERLAPPED) NULL)
         || (BytesRead != sizeof(HANDLE))) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00384)
                      "Child: Unable to retrieve the ready event from the parent");
         exit(APEXIT_CHILDINIT);
     }
@@ -297,7 +297,7 @@ static void get_handles_from_parent(server_rec *s, HANDLE *child_exit_event,
     if (!ReadFile(pipe, child_exit_event, sizeof(HANDLE),
                   &BytesRead, (LPOVERLAPPED) NULL)
         || (BytesRead != sizeof(HANDLE))) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00385)
                      "Child: Unable to retrieve the exit event from the parent");
         exit(APEXIT_CHILDINIT);
     }
@@ -305,14 +305,14 @@ static void get_handles_from_parent(server_rec *s, HANDLE *child_exit_event,
     if (!ReadFile(pipe, &os_start, sizeof(os_start),
                   &BytesRead, (LPOVERLAPPED) NULL)
         || (BytesRead != sizeof(os_start))) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00386)
                      "Child: Unable to retrieve the start_mutex from the parent");
         exit(APEXIT_CHILDINIT);
     }
     *child_start_mutex = NULL;
     if ((rv = apr_os_proc_mutex_put(child_start_mutex, &os_start, s->process->pool))
             != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00387)
                      "Child: Unable to access the start_mutex from the parent");
         exit(APEXIT_CHILDINIT);
     }
@@ -320,21 +320,21 @@ static void get_handles_from_parent(server_rec *s, HANDLE *child_exit_event,
     if (!ReadFile(pipe, &hScore, sizeof(hScore),
                   &BytesRead, (LPOVERLAPPED) NULL)
         || (BytesRead != sizeof(hScore))) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00388)
                      "Child: Unable to retrieve the scoreboard from the parent");
         exit(APEXIT_CHILDINIT);
     }
     *scoreboard_shm = NULL;
     if ((rv = apr_os_shm_put(scoreboard_shm, &hScore, s->process->pool))
             != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00389)
                      "Child: Unable to access the scoreboard from the parent");
         exit(APEXIT_CHILDINIT);
     }
 
     rv = ap_reopen_scoreboard(s->process->pool, scoreboard_shm, 1);
     if (rv || !(sb_shared = apr_shm_baseaddr_get(*scoreboard_shm))) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00390)
                      "Child: Unable to reopen the scoreboard from the parent");
         exit(APEXIT_CHILDINIT);
     }
@@ -343,7 +343,7 @@ static void get_handles_from_parent(server_rec *s, HANDLE *child_exit_event,
      */
     ap_init_scoreboard(sb_shared);
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00391)
                  "Child: Retrieved our scoreboard from the parent.");
 }
 
@@ -365,64 +365,64 @@ static int send_handles_to_child(apr_pool_t *p,
 
     if (!DuplicateHandle(hCurrentProcess, child_ready_event, hProcess, &hDup,
         EVENT_MODIFY_STATE | SYNCHRONIZE, FALSE, 0)) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00392)
                      "Parent: Unable to duplicate the ready event handle for the child");
         return -1;
     }
     if ((rv = apr_file_write_full(child_in, &hDup, sizeof(hDup), &BytesWritten))
             != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00393)
                      "Parent: Unable to send the exit event handle to the child");
         return -1;
     }
     if (!DuplicateHandle(hCurrentProcess, child_exit_event, hProcess, &hDup,
                          EVENT_MODIFY_STATE | SYNCHRONIZE, FALSE, 0)) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00394)
                      "Parent: Unable to duplicate the exit event handle for the child");
         return -1;
     }
     if ((rv = apr_file_write_full(child_in, &hDup, sizeof(hDup), &BytesWritten))
             != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00395)
                      "Parent: Unable to send the exit event handle to the child");
         return -1;
     }
     if ((rv = apr_os_proc_mutex_get(&os_start, child_start_mutex)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00396)
                      "Parent: Unable to retrieve the start mutex for the child");
         return -1;
     }
     if (!DuplicateHandle(hCurrentProcess, os_start, hProcess, &hDup,
                          SYNCHRONIZE, FALSE, 0)) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00397)
                      "Parent: Unable to duplicate the start mutex to the child");
         return -1;
     }
     if ((rv = apr_file_write_full(child_in, &hDup, sizeof(hDup), &BytesWritten))
             != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00398)
                      "Parent: Unable to send the start mutex to the child");
         return -1;
     }
     if ((rv = apr_os_shm_get(&hScore, scoreboard_shm)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00399)
                      "Parent: Unable to retrieve the scoreboard handle for the child");
         return -1;
     }
     if (!DuplicateHandle(hCurrentProcess, hScore, hProcess, &hDup,
                          FILE_MAP_READ | FILE_MAP_WRITE, FALSE, 0)) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00400)
                      "Parent: Unable to duplicate the scoreboard handle to the child");
         return -1;
     }
     if ((rv = apr_file_write_full(child_in, &hDup, sizeof(hDup), &BytesWritten))
             != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00401)
                      "Parent: Unable to send the scoreboard handle to the child");
         return -1;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00402)
                  "Parent: Sent the scoreboard to the child");
     return 0;
 }
@@ -458,12 +458,12 @@ static void get_listeners_from_parent(server_rec *s)
      * pipe = GetStdHandle(STD_INPUT_HANDLE);
      */
     for (lr = ap_listeners; lr; lr = lr->next, ++lcnt) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00403)
                      "Child: Waiting for data for listening socket %pI",
                      lr->bind_addr);
         if (!ReadFile(pipe, &WSAProtocolInfo, sizeof(WSAPROTOCOL_INFO),
                       &BytesRead, (LPOVERLAPPED) NULL)) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00404)
                          "Child: Unable to read socket data from parent");
             exit(APEXIT_CHILDINIT);
         }
@@ -471,19 +471,19 @@ static void get_listeners_from_parent(server_rec *s)
         nsd = WSASocket(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO,
                         &WSAProtocolInfo, 0, 0);
         if (nsd == INVALID_SOCKET) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_netos_error(), ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_netos_error(), ap_server_conf, APLOGNO(00405)
                          "Child: WSASocket failed to open the inherited socket");
             exit(APEXIT_CHILDINIT);
         }
 
         if (!SetHandleInformation((HANDLE)nsd, HANDLE_FLAG_INHERIT, 0)) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), ap_server_conf, APLOGNO(00406)
                          "Child: SetHandleInformation failed");
         }
         apr_os_sock_put(&lr->sd, &nsd, s->process->pool);
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00407)
                  "Child: retrieved %d listeners from parent", lcnt);
 }
 
@@ -505,12 +505,12 @@ static int send_listeners_to_child(apr_pool_t *p, DWORD dwProcessId,
         apr_os_sock_t nsd;
         lpWSAProtocolInfo = apr_pcalloc(p, sizeof(WSAPROTOCOL_INFO));
         apr_os_sock_get(&nsd, lr->sd);
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf, APLOGNO(00408)
                      "Parent: Duplicating socket %d (%pI) and sending it to child process %lu",
                      nsd, lr->bind_addr, dwProcessId);
         if (WSADuplicateSocket(nsd, dwProcessId,
                                lpWSAProtocolInfo) == SOCKET_ERROR) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_netos_error(), ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_netos_error(), ap_server_conf, APLOGNO(00409)
                          "Parent: WSADuplicateSocket failed for socket %d. Check the FAQ.", nsd);
             return -1;
         }
@@ -518,13 +518,13 @@ static int send_listeners_to_child(apr_pool_t *p, DWORD dwProcessId,
         if ((rv = apr_file_write_full(child_in, lpWSAProtocolInfo,
                                       sizeof(WSAPROTOCOL_INFO), &BytesWritten))
                 != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00410)
                          "Parent: Unable to write duplicated socket %d to the child.", nsd);
             return -1;
         }
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00411)
                  "Parent: Sent %d listeners to child %lu", lcnt, dwProcessId);
     return 0;
 }
@@ -564,7 +564,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     apr_procattr_detach_set(attr, 1);
     if (((rv = apr_filepath_get(&cwd, 0, ptemp)) != APR_SUCCESS)
            || ((rv = apr_procattr_dir_set(attr, cwd)) != APR_SUCCESS)) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00412)
                      "Parent: Failed to get the current path");
     }
 
@@ -574,7 +574,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
          */
         if ((rv = ap_os_proc_filepath(&cmd, ptemp))
                 != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, ERROR_BAD_PATHNAME, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, ERROR_BAD_PATHNAME, ap_server_conf, APLOGNO(00413)
                          "Parent: Failed to get full path of %s",
                          ap_server_conf->process->argv[0]);
             apr_pool_destroy(ptemp);
@@ -595,7 +595,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     /* Create a pipe to send handles to the child */
     if ((rv = apr_procattr_io_set(attr, APR_FULL_BLOCK,
                                   APR_NO_PIPE, APR_NO_PIPE)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00414)
                         "Parent: Unable to create child stdin pipe.");
         apr_pool_destroy(ptemp);
         return -1;
@@ -604,7 +604,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     /* Create the child_ready_event */
     waitlist[waitlist_ready] = CreateEvent(NULL, TRUE, FALSE, NULL);
     if (!waitlist[waitlist_ready]) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00415)
                      "Parent: Could not create ready event for child process");
         apr_pool_destroy (ptemp);
         return -1;
@@ -613,7 +613,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     /* Create the child_exit_event */
     hExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
     if (!hExitEvent) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00416)
                      "Parent: Could not create exit event for child process");
         apr_pool_destroy(ptemp);
         CloseHandle(waitlist[waitlist_ready]);
@@ -633,7 +633,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     rv = apr_proc_create(&new_child, cmd, (const char * const *)args,
                          (const char * const *)env, attr, ptemp);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00417)
                      "Parent: Failed to create the child process.");
         apr_pool_destroy(ptemp);
         CloseHandle(hExitEvent);
@@ -642,7 +642,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
         return -1;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf, APLOGNO(00418)
                  "Parent: Created child process %d", new_child.pid);
 
     if (send_handles_to_child(ptemp, waitlist[waitlist_ready], hExitEvent,
@@ -767,7 +767,7 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
                         &child_exit_event, &child_pid);
     if (rv < 0)
     {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00419)
                      "master_main: create child process failed. Exiting.");
         shutdown_pending = 1;
         goto die_now;
@@ -791,23 +791,23 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
     cld = rv - WAIT_OBJECT_0;
     if (rv == WAIT_FAILED) {
         /* Something serious is wrong */
-        ap_log_error(APLOG_MARK,APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+        ap_log_error(APLOG_MARK,APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00420)
                      "master_main: WaitForMultipleObjects WAIT_FAILED -- doing server shutdown");
         shutdown_pending = 1;
     }
     else if (rv == WAIT_TIMEOUT) {
         /* Hey, this cannot happen */
-        ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s, APLOGNO(00421)
                      "master_main: WaitForMultipleObjects with INFINITE wait exited with WAIT_TIMEOUT");
         shutdown_pending = 1;
     }
     else if (cld == SHUTDOWN_HANDLE) {
         /* shutdown_event signalled */
         shutdown_pending = 1;
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, s,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, s, APLOGNO(00422)
                      "Parent: Received shutdown signal -- Shutting down the server.");
         if (ResetEvent(shutdown_event) == 0) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s, APLOGNO(00423)
                          "ResetEvent(shutdown_event)");
         }
     }
@@ -816,14 +816,14 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
          * then signal the child process to exit.
          */
         restart_pending = 1;
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s, APLOGNO(00424)
                      "Parent: Received restart signal -- Restarting the server.");
         if (ResetEvent(restart_event) == 0) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s, APLOGNO(00425)
                          "Parent: ResetEvent(restart_event) failed.");
         }
         if (SetEvent(child_exit_event) == 0) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s, APLOGNO(00426)
                          "Parent: SetEvent for child process %pp failed.",
                          event_handles[CHILD_HANDLE]);
         }
@@ -843,14 +843,14 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
         if (   exitcode == APEXIT_CHILDFATAL
             || exitcode == APEXIT_CHILDINIT
             || exitcode == APEXIT_INIT) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf, APLOGNO(00427)
                          "Parent: child process exited with status %lu -- Aborting.", exitcode);
             shutdown_pending = 1;
         }
         else {
             int i;
             restart_pending = 1;
-            ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf, APLOGNO(00428)
                          "Parent: child process exited with status %lu -- Restarting.", exitcode);
             for (i = 0; i < ap_threads_per_child; i++) {
                 ap_update_child_status_from_indexes(0, i, SERVER_DEAD, NULL);
@@ -885,20 +885,20 @@ die_now:
         }
         /* Signal the child processes to exit */
         if (SetEvent(child_exit_event) == 0) {
-                ap_log_error(APLOG_MARK,APLOG_ERR, apr_get_os_error(), ap_server_conf,
+                ap_log_error(APLOG_MARK,APLOG_ERR, apr_get_os_error(), ap_server_conf, APLOGNO(00429)
                              "Parent: SetEvent for child process %pp failed",
                              event_handles[CHILD_HANDLE]);
         }
         if (event_handles[CHILD_HANDLE]) {
             rv = WaitForSingleObject(event_handles[CHILD_HANDLE], timeout);
             if (rv == WAIT_OBJECT_0) {
-                ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
+                ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf, APLOGNO(00430)
                              "Parent: Child process exited successfully.");
                 CloseHandle(event_handles[CHILD_HANDLE]);
                 event_handles[CHILD_HANDLE] = NULL;
             }
             else {
-                ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
+                ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf, APLOGNO(00431)
                              "Parent: Forcing termination of child process %pp",
                              event_handles[CHILD_HANDLE]);
                 TerminateProcess(event_handles[CHILD_HANDLE], 1);
@@ -1108,7 +1108,7 @@ static void winnt_rewrite_args(process_rec *process)
      */
     if ((rv = ap_os_proc_filepath(&binpath, process->pconf))
             != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK,APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK,APLOG_CRIT, rv, NULL, APLOGNO(00432)
                      "Failed to get the full path of %s", process->argv[0]);
         exit(APEXIT_INIT);
     }
@@ -1255,7 +1255,7 @@ static void winnt_rewrite_args(process_rec *process)
     {
         if (service_set == APR_SUCCESS)
         {
-            ap_log_error(APLOG_MARK,APLOG_ERR, 0, NULL,
+            ap_log_error(APLOG_MARK,APLOG_ERR, 0, NULL, APLOGNO(00433)
                  "%s: Service is already installed.", service_name);
             exit(APEXIT_INIT);
         }
@@ -1281,26 +1281,26 @@ static void winnt_rewrite_args(process_rec *process)
             rv = mpm_merge_service_args(process->pool, mpm_new_argv,
                                         fixed_args);
             if (rv == APR_SUCCESS) {
-                ap_log_error(APLOG_MARK,APLOG_INFO, 0, NULL,
+                ap_log_error(APLOG_MARK,APLOG_INFO, 0, NULL, APLOGNO(00434)
                              "Using ConfigArgs of the installed service "
                              "\"%s\".", service_name);
             }
             else  {
-                ap_log_error(APLOG_MARK,APLOG_WARNING, rv, NULL,
+                ap_log_error(APLOG_MARK,APLOG_WARNING, rv, NULL, APLOGNO(00435)
                              "No installed ConfigArgs for the service "
                              "\"%s\", using Apache defaults.", service_name);
             }
         }
         else
         {
-            ap_log_error(APLOG_MARK,APLOG_ERR, service_set, NULL,
+            ap_log_error(APLOG_MARK,APLOG_ERR, service_set, NULL, APLOGNO(00436)
                  "No installed service named \"%s\".", service_name);
             exit(APEXIT_INIT);
         }
     }
     if (strcasecmp(signal_arg, "install") && service_set && service_set != SERVICE_UNSET)
     {
-        ap_log_error(APLOG_MARK,APLOG_ERR, service_set, NULL,
+        ap_log_error(APLOG_MARK,APLOG_ERR, service_set, NULL, APLOGNO(00437)
              "No installed service named \"%s\".", service_name);
         exit(APEXIT_INIT);
     }
@@ -1367,7 +1367,7 @@ static int winnt_pre_config(apr_pool_t *pconf_, apr_pool_t *plog, apr_pool_t *pt
 
     if (!strcasecmp(signal_arg, "runservice")
             && (service_to_start_success != APR_SUCCESS)) {
-        ap_log_error(APLOG_MARK,APLOG_CRIT, service_to_start_success, NULL,
+        ap_log_error(APLOG_MARK,APLOG_CRIT, service_to_start_success, NULL, APLOGNO(00438)
                      "%s: Unable to start the service manager.",
                      service_name);
         exit(APEXIT_INIT);
@@ -1415,14 +1415,14 @@ static int winnt_check_config(apr_pool_t *pconf, apr_pool_t *plog,
 
     if (thread_limit > MAX_THREAD_LIMIT) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00439)
                          "WARNING: ThreadLimit of %d exceeds compile-time "
                          "limit of", thread_limit);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " %d threads, decreasing to %d.",
                          MAX_THREAD_LIMIT, MAX_THREAD_LIMIT);
         } else if (is_parent) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00440)
                          "ThreadLimit of %d exceeds compile-time limit "
                          "of %d, decreasing to match",
                          thread_limit, MAX_THREAD_LIMIT);
@@ -1431,11 +1431,11 @@ static int winnt_check_config(apr_pool_t *pconf, apr_pool_t *plog,
     }
     else if (thread_limit < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00441)
                          "WARNING: ThreadLimit of %d not allowed, "
                          "increasing to 1.", thread_limit);
         } else if (is_parent) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00442)
                          "ThreadLimit of %d not allowed, increasing to 1",
                          thread_limit);
         }
@@ -1451,7 +1451,7 @@ static int winnt_check_config(apr_pool_t *pconf, apr_pool_t *plog,
     else if (thread_limit != first_thread_limit) {
         /* Don't need a startup console version here */
         if (is_parent) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00443)
                          "changing ThreadLimit to %d from original value "
                          "of %d not allowed during restart",
                          thread_limit, first_thread_limit);
@@ -1461,7 +1461,7 @@ static int winnt_check_config(apr_pool_t *pconf, apr_pool_t *plog,
 
     if (ap_threads_per_child > thread_limit) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00444)
                          "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
                          "of", ap_threads_per_child);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -1471,7 +1471,7 @@ static int winnt_check_config(apr_pool_t *pconf, apr_pool_t *plog,
                          " To increase, please see the ThreadLimit "
                          "directive.");
         } else if (is_parent) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00445)
                          "ThreadsPerChild of %d exceeds ThreadLimit "
                          "of %d, decreasing to match",
                          ap_threads_per_child, thread_limit);
@@ -1480,11 +1480,11 @@ static int winnt_check_config(apr_pool_t *pconf, apr_pool_t *plog,
     }
     else if (ap_threads_per_child < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00446)
                          "WARNING: ThreadsPerChild of %d not allowed, "
                          "increasing to 1.", ap_threads_per_child);
         } else if (is_parent) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00447)
                          "ThreadsPerChild of %d not allowed, increasing to 1",
                          ap_threads_per_child);
         }
@@ -1571,7 +1571,7 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
              */
             shutdown_event = CreateEvent(sa, FALSE, FALSE, signal_shutdown_name);
             if (!shutdown_event) {
-                ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00448)
                              "Parent: Cannot create shutdown event %s", signal_shutdown_name);
                 CleanNullACL((void *)sa);
                 return HTTP_INTERNAL_SERVER_ERROR;
@@ -1583,7 +1583,7 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
             restart_event = CreateEvent(sa, FALSE, FALSE, signal_restart_name);
             if (!restart_event) {
                 CloseHandle(shutdown_event);
-                ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf, APLOGNO(00449)
                              "Parent: Cannot create restart event %s", signal_restart_name);
                 CleanNullACL((void *)sa);
                 return HTTP_INTERNAL_SERVER_ERROR;
@@ -1598,7 +1598,7 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
                                         APR_LOCK_DEFAULT,
                                         ap_server_conf->process->pool);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK,APLOG_ERR, rv, ap_server_conf,
+                ap_log_error(APLOG_MARK,APLOG_ERR, rv, ap_server_conf, APLOGNO(00450)
                              "%s: Unable to create the start_mutex.",
                              service_name);
                 return HTTP_INTERNAL_SERVER_ERROR;
@@ -1641,7 +1641,7 @@ static int winnt_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, s
 
     if (ap_setup_listeners(s) < 1) {
         ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0,
-                     NULL, "no listening sockets available, shutting down");
+                     NULL, APLOGNO(00451) "no listening sockets available, shutting down");
         return DONE;
     }
 
@@ -1673,7 +1673,7 @@ static void winnt_child_init(apr_pool_t *pchild, struct server_rec *s)
         rv = apr_proc_mutex_create(&start_mutex, signal_name_prefix,
                                    APR_LOCK_DEFAULT, s->process->pool);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK,APLOG_ERR, rv, ap_server_conf,
+            ap_log_error(APLOG_MARK,APLOG_ERR, rv, ap_server_conf, APLOGNO(00452)
                          "%s child: Unable to init the start_mutex.",
                          service_name);
             exit(APEXIT_CHILDINIT);
@@ -1705,22 +1705,22 @@ static int winnt_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
     {
         /* The child process or in one_process (debug) mode
          */
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf, APLOGNO(00453)
                      "Child process is running");
 
         child_main(pconf);
 
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, ap_server_conf, APLOGNO(00454)
                      "Child process is exiting");
         return DONE;
     }
     else
     {
         /* A real-honest to goodness parent */
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00455)
                      "%s configured -- resuming normal operations",
                      ap_get_server_description());
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00456)
                      "Server built: %s", ap_get_server_built());
         ap_log_command_line(plog, s);
 
diff --git a/server/mpm/winnt/service.c b/server/mpm/winnt/service.c
index 1c145be..bf5f021 100644
--- a/server/mpm/winnt/service.c
+++ b/server/mpm/winnt/service.c
@@ -314,7 +314,7 @@ static void __stdcall service_nt_main_fn(DWORD argc, LPTSTR *argv)
     if (!(ctx->hServiceStatus = RegisterServiceCtrlHandlerEx(argv[0], service_nt_ctrl, ctx)))
     {
         ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(),
-                     NULL, "Failure registering service handler");
+                     NULL, APLOGNO(00365) "Failure registering service handler");
         return;
     }
 
@@ -369,7 +369,7 @@ static DWORD WINAPI service_nt_dispatch_thread(LPVOID nada)
     {
         /* This is a genuine failure of the SCM. */
         rv = apr_get_os_error();
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, APLOGNO(00366)
                      "Error starting service control dispatcher");
     }
 
@@ -433,7 +433,7 @@ apr_status_t mpm_merge_service_args(apr_pool_t *p,
     }
     if (rv != APR_SUCCESS) {
         if (rv == ERROR_FILE_NOT_FOUND) {
-            ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL, APLOGNO(00367)
                          "No ConfigArgs registered for %s, perhaps "
                          "this service is not installed?",
                          mpm_service_name);
@@ -571,7 +571,7 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
     if (GetModuleFileName(NULL, exe_path, sizeof(exe_path)) == 0)
     {
         apr_status_t rv = apr_get_os_error();
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, APLOGNO(00368)
                      "GetModuleFileName failed");
         return rv;
     }
@@ -580,7 +580,7 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
                                  SC_MANAGER_CREATE_SERVICE);
     if (!schSCManager) {
         rv = apr_get_os_error();
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, APLOGNO(00369)
                      "Failed to open the WinNT service manager, perhaps "
                      "you forgot to log in as Adminstrator?");
         return (rv);
@@ -639,7 +639,7 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
         if (!schService)
         {
             rv = apr_get_os_error();
-            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, APLOGNO(00370)
                          "Failed to create WinNT Service Profile");
             CloseServiceHandle(schSCManager);
             return (rv);
@@ -661,7 +661,7 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
         ap_regkey_close(key);
     }
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, APLOGNO(00371)
                      "%s: Failed to store the ConfigArgs in the registry.",
                      mpm_display_name);
         return (rv);
@@ -683,7 +683,7 @@ apr_status_t mpm_service_uninstall(void)
                                  SC_MANAGER_CONNECT);
     if (!schSCManager) {
         rv = apr_get_os_error();
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, APLOGNO(00372)
                      "Failed to open the WinNT service manager.");
         return (rv);
     }
@@ -693,7 +693,7 @@ apr_status_t mpm_service_uninstall(void)
 
     if (!schService) {
         rv = apr_get_os_error();
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, APLOGNO(00373)
                         "%s: OpenService failed", mpm_display_name);
         return (rv);
     }
@@ -711,7 +711,7 @@ apr_status_t mpm_service_uninstall(void)
 
     if (DeleteService(schService) == 0) {
         rv = apr_get_os_error();
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, APLOGNO(00374)
                      "%s: Failed to delete the service.", mpm_display_name);
         return (rv);
     }
@@ -760,7 +760,7 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
                                  SC_MANAGER_CONNECT);
     if (!schSCManager) {
         rv = apr_get_os_error();
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, APLOGNO(00375)
                      "Failed to open the WinNT service manager");
         return (rv);
     }
@@ -770,7 +770,7 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
                              SERVICE_START | SERVICE_QUERY_STATUS);
     if (!schService) {
         rv = apr_get_os_error();
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, APLOGNO(00376)
                      "%s: Failed to open the service.", mpm_display_name);
         CloseServiceHandle(schSCManager);
         return (rv);
@@ -778,7 +778,7 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
 
     if (QueryServiceStatus(schService, &globdat.ssStatus)
         && (globdat.ssStatus.dwCurrentState == SERVICE_RUNNING)) {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, 0, NULL, APLOGNO(00377)
                      "Service %s is already started!", mpm_display_name);
         CloseServiceHandle(schService);
         CloseServiceHandle(schSCManager);
@@ -805,7 +805,7 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
     if (rv == APR_SUCCESS)
         fprintf(stderr,"The %s service is running.\n", mpm_display_name);
     else
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00378)
                      "%s: Failed to start the service process.",
                      mpm_display_name);
 
@@ -825,7 +825,7 @@ void mpm_signal_service(apr_pool_t *ptemp, int signal)
                                  SC_MANAGER_CONNECT);
 
     if (!schSCManager) {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), NULL, APLOGNO(00379)
                      "Failed to open the NT Service Manager");
         return;
     }
@@ -838,14 +838,14 @@ void mpm_signal_service(apr_pool_t *ptemp, int signal)
 
     if (schService == NULL) {
         /* Could not open the service */
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), NULL, APLOGNO(00380)
                      "Failed to open the %s Service", mpm_display_name);
         CloseServiceHandle(schSCManager);
         return;
     }
 
     if (!QueryServiceStatus(schService, &globdat.ssStatus)) {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), NULL, APLOGNO(00381)
                      "Query of Service %s failed", mpm_display_name);
         CloseServiceHandle(schService);
         CloseServiceHandle(schSCManager);
diff --git a/server/mpm/worker/pod.c b/server/mpm/worker/pod.c
index c39930b..86f7b39 100644
--- a/server/mpm/worker/pod.c
+++ b/server/mpm/worker/pod.c
@@ -90,7 +90,7 @@ static apr_status_t pod_signal_internal(ap_worker_pod_t *pod, int graceful)
 
     rv = apr_file_write(pod->pod_out, &char_of_death, &one);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, APLOGNO(00325)
                      "write pipe_of_death");
     }
     return rv;
diff --git a/server/mpm/worker/worker.c b/server/mpm/worker/worker.c
index 64612ac..75f15eb 100644
--- a/server/mpm/worker/worker.c
+++ b/server/mpm/worker/worker.c
@@ -396,7 +396,7 @@ static void worker_note_child_started(int slot, pid_t pid)
 
 static void worker_note_child_lost_slot(int slot, pid_t newpid)
 {
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00263)
                  "pid %" APR_PID_T_FMT " taking over scoreboard slot from "
                  "%" APR_PID_T_FMT "%s",
                  newpid,
@@ -522,22 +522,22 @@ static void set_signals(void)
 
     sa.sa_handler = sig_term;
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00264)
                      "sigaction(SIGTERM)");
 #ifdef AP_SIG_GRACEFUL_STOP
     if (sigaction(AP_SIG_GRACEFUL_STOP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00265)
                      "sigaction(" AP_SIG_GRACEFUL_STOP_STRING ")");
 #endif
 #ifdef SIGINT
     if (sigaction(SIGINT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00266)
                      "sigaction(SIGINT)");
 #endif
 #ifdef SIGXCPU
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXCPU, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00267)
                      "sigaction(SIGXCPU)");
 #endif
 #ifdef SIGXFSZ
@@ -546,13 +546,13 @@ static void set_signals(void)
      * rather than terminate the process. */
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGXFSZ, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00268)
                      "sigaction(SIGXFSZ)");
 #endif
 #ifdef SIGPIPE
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGPIPE, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00269)
                      "sigaction(SIGPIPE)");
 #endif
 
@@ -562,10 +562,10 @@ static void set_signals(void)
     sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
     sa.sa_handler = restart;
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00270)
                      "sigaction(SIGHUP)");
     if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, APLOGNO(00271)
                      "sigaction(" AP_SIG_GRACEFUL_STRING ")");
 #else
     if (!one_process) {
@@ -665,13 +665,13 @@ static void accept_mutex_error(const char *func, apr_status_t rv, int process_sl
     else if (requests_this_child == INT_MAX
         || ((requests_this_child == ap_max_requests_per_child)
             && ap_max_requests_per_child)) {
-        ap_log_error(APLOG_MARK, level, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, level, rv, ap_server_conf, APLOGNO(00272)
                      "apr_proc_mutex_%s failed "
                      "before this child process served any requests.",
                      func);
         clean_child_exit(APEXIT_CHILDSICK);
     }
-    ap_log_error(APLOG_MARK, level, rv, ap_server_conf,
+    ap_log_error(APLOG_MARK, level, rv, ap_server_conf, APLOGNO(00273)
                  "apr_proc_mutex_%s failed. Attempting to "
                  "shutdown process gracefully.", func);
     signal_threads(ST_GRACEFUL);
@@ -871,7 +871,7 @@ static void * APR_THREAD_FUNC listener_thread(apr_thread_t *thd, void * dummy)
                     ap_scoreboard_image->global->running_generation) {
                     level = APLOG_DEBUG; /* common to get these at restart time */
                 }
-                ap_log_error(APLOG_MARK, level, rv, ap_server_conf,
+                ap_log_error(APLOG_MARK, level, rv, ap_server_conf, APLOGNO(00274)
                              "apr_proc_mutex_unlock failed. Attempting to "
                              "shutdown process gracefully.");
                 signal_threads(ST_GRACEFUL);
@@ -1013,7 +1013,7 @@ static void create_listener_thread(thread_starter *ts)
     rv = apr_thread_create(&ts->listener, thread_attr, listener_thread,
                            my_info, pchild);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, APLOGNO(00275)
                      "apr_thread_create: unable to create listener thread");
         /* let the parent decide how bad this really is */
         clean_child_exit(APEXIT_CHILDSICK);
@@ -1159,13 +1159,13 @@ static void join_workers(apr_thread_t *listener, apr_thread_t **threads)
             ++iter;
         }
         if (iter >= 10) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00276)
                          "the listener thread didn't exit");
         }
         else {
             rv = apr_thread_join(&thread_rv, listener);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00277)
                              "apr_thread_join: unable to join listener thread");
             }
         }
@@ -1182,7 +1182,7 @@ static void join_workers(apr_thread_t *listener, apr_thread_t **threads)
 
             rv = apr_thread_join(&thread_rv, threads[i]);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00278)
                              "apr_thread_join: unable to join worker "
                              "thread %d",
                              i);
@@ -1201,7 +1201,7 @@ static void join_start_thread(apr_thread_t *start_thread_id)
                                 */
     rv = apr_thread_join(&thread_rv, start_thread_id);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00279)
                      "apr_thread_join: unable to join the start "
                      "thread");
     }
@@ -1229,7 +1229,7 @@ static void child_main(int child_num_arg)
                                                apr_proc_mutex_lockfile(accept_mutex),
                                                pchild));
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf, APLOGNO(00280)
                      "Couldn't initialize cross-process lock in child");
         clean_child_exit(APEXIT_CHILDFATAL);
     }
@@ -1248,7 +1248,7 @@ static void child_main(int child_num_arg)
      */
     rv = apr_setup_signal_thread();
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf, APLOGNO(00281)
                      "Couldn't initialize signal thread");
         clean_child_exit(APEXIT_CHILDFATAL);
     }
@@ -1286,7 +1286,7 @@ static void child_main(int child_num_arg)
     rv = apr_thread_create(&start_thread_id, thread_attr, start_threads,
                            ts, pchild);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, APLOGNO(00282)
                      "apr_thread_create: unable to create worker thread");
         /* let the parent decide how bad this really is */
         clean_child_exit(APEXIT_CHILDSICK);
@@ -1382,7 +1382,7 @@ static int make_child(server_rec *s, int slot)
     }
 
     if ((pid = fork()) == -1) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, APLOGNO(00283)
                      "fork: Unable to fork new process");
         /* fork didn't succeed.  There's no need to touch the scoreboard;
          * if we were trying to replace a failed child process, then
@@ -1408,7 +1408,7 @@ static int make_child(server_rec *s, int slot)
                                PROCESSOR_CLASS_ANY);
         if (status != OK)
             ap_log_error(APLOG_MARK, APLOG_DEBUG, errno,
-                         ap_server_conf,
+                         ap_server_conf, APLOGNO(00284)
                          "processor unbind failed");
 #endif
         RAISE_SIGSTOP(MAKE_CHILD);
@@ -1552,7 +1552,7 @@ static void perform_idle_server_maintenance(void)
             shutdown_pending = 1;
             child_fatal = 1;
             ap_log_error(APLOG_MARK, APLOG_ALERT, 0,
-                         ap_server_conf,
+                         ap_server_conf, APLOGNO(00285)
                          "No active workers found..."
                          " Apache is exiting!");
             /* the child already logged the failure details */
@@ -1577,7 +1577,7 @@ static void perform_idle_server_maintenance(void)
                 if (0 == idle_thread_count) {
                     if (!retained->maxclients_reported) {
                         /* only report this condition once */
-                        ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00286)
                                      "server reached MaxRequestWorkers "
                                      "setting, consider raising the "
                                      "MaxRequestWorkers setting");
@@ -1585,7 +1585,7 @@ static void perform_idle_server_maintenance(void)
                     }
                 } else {
                     if (!retained->near_maxclients_reported) {
-                        ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
+                        ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00287)
                                      "server is within MinSpareThreads of "
                                      "MaxRequestWorkers, consider raising the "
                                      "MaxRequestWorkers setting");
@@ -1595,7 +1595,7 @@ static void perform_idle_server_maintenance(void)
             }
             else {
                 ap_log_error(APLOG_MARK, APLOG_ERR, 0,
-                             ap_server_conf,
+                             ap_server_conf, APLOGNO(00288)
                              "scoreboard is full, not at MaxRequestWorkers");
             }
             retained->idle_spawn_rate = 1;
@@ -1606,7 +1606,7 @@ static void perform_idle_server_maintenance(void)
             }
             if (retained->idle_spawn_rate >= 8) {
                 ap_log_error(APLOG_MARK, APLOG_INFO, 0,
-                             ap_server_conf,
+                             ap_server_conf, APLOGNO(00289)
                              "server seems busy, (you may need "
                              "to increase StartServers, ThreadsPerChild "
                              "or Min/MaxSpareThreads), "
@@ -1662,7 +1662,7 @@ static void server_main_loop(int remaining_children_to_start)
                     return;
                 }
                 else {
-                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf,
+                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf, APLOGNO(00290)
                                  "Ignoring fatal error in child of previous "
                                  "generation (pid %ld).",
                                  (long)pid.pid);
@@ -1711,7 +1711,7 @@ static void server_main_loop(int remaining_children_to_start)
                  * scoreboard.  Somehow we don't know about this child.
                  */
                 ap_log_error(APLOG_MARK, APLOG_WARNING, 0,
-                             ap_server_conf,
+                             ap_server_conf, APLOGNO(00291)
                              "long lost child came home! (pid %ld)",
                              (long)pid.pid);
             }
@@ -1795,13 +1795,13 @@ static int worker_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         retained->hold_off_on_exponential_spawning = 10;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00292)
                 "%s configured -- resuming normal operations",
                 ap_get_server_description());
-    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00293)
                 "Server built: %s", ap_get_server_built());
     ap_log_command_line(plog, s);
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(00294)
                 "Accept mutex: %s (default: %s)",
                 apr_proc_mutex_name(accept_mutex),
                 apr_proc_mutex_defname());
@@ -1822,7 +1822,7 @@ static int worker_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
             /* cleanup pid file on normal shutdown */
             ap_remove_pid(pconf, ap_pid_fname);
             ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
-                         ap_server_conf, "caught SIGTERM, shutting down");
+                         ap_server_conf, APLOGNO(00295) "caught SIGTERM, shutting down");
         }
         return DONE;
     } else if (shutdown_pending) {
@@ -1841,7 +1841,7 @@ static int worker_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         if (!child_fatal) {
             /* cleanup pid file on normal shutdown */
             ap_remove_pid(pconf, ap_pid_fname);
-            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00296)
                          "caught " AP_SIG_GRACEFUL_STOP_STRING
                          ", shutting down gracefully");
         }
@@ -1897,7 +1897,7 @@ static int worker_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     ap_scoreboard_image->global->running_generation = retained->my_generation;
 
     if (retained->is_graceful) {
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00297)
                      AP_SIG_GRACEFUL_STRING " received.  Doing graceful restart");
         /* wake up the children...time to die.  But we'll have more soon */
         ap_worker_pod_killpg(pod, ap_daemons_limit, TRUE);
@@ -1917,7 +1917,7 @@ static int worker_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
         ap_reclaim_child_processes(1, /* Start with SIGTERM */
                                    worker_note_child_killed);
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf, APLOGNO(00298)
                     "SIGHUP received.  Attempting to restart");
     }
 
@@ -1997,7 +1997,7 @@ static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
             rv = apr_proc_detach(no_detach ? APR_PROC_DETACH_FOREGROUND
                                            : APR_PROC_DETACH_DAEMONIZE);
             if (rv != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00299)
                              "apr_proc_detach failed");
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
@@ -2032,14 +2032,14 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (server_limit > MAX_SERVER_LIMIT) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00300)
                          "WARNING: ServerLimit of %d exceeds compile-time "
                          "limit of", server_limit);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " %d servers, decreasing to %d.",
                          MAX_SERVER_LIMIT, MAX_SERVER_LIMIT);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00301)
                          "ServerLimit of %d exceeds compile-time limit "
                          "of %d, decreasing to match",
                          server_limit, MAX_SERVER_LIMIT);
@@ -2048,11 +2048,11 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (server_limit < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00302)
                          "WARNING: ServerLimit of %d not allowed, "
                          "increasing to 1.", server_limit);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00303)
                          "ServerLimit of %d not allowed, increasing to 1",
                          server_limit);
         }
@@ -2067,7 +2067,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (server_limit != retained->first_server_limit) {
         /* don't need a startup console version here */
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00304)
                      "changing ServerLimit to %d from original value of %d "
                      "not allowed during restart",
                      server_limit, retained->first_server_limit);
@@ -2076,14 +2076,14 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (thread_limit > MAX_THREAD_LIMIT) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00305)
                          "WARNING: ThreadLimit of %d exceeds compile-time "
                          "limit of", thread_limit);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " %d threads, decreasing to %d.",
                          MAX_THREAD_LIMIT, MAX_THREAD_LIMIT);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00306)
                          "ThreadLimit of %d exceeds compile-time limit "
                          "of %d, decreasing to match",
                          thread_limit, MAX_THREAD_LIMIT);
@@ -2092,11 +2092,11 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (thread_limit < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00307)
                          "WARNING: ThreadLimit of %d not allowed, "
                          "increasing to 1.", thread_limit);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00308)
                          "ThreadLimit of %d not allowed, increasing to 1",
                          thread_limit);
         }
@@ -2111,7 +2111,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (thread_limit != retained->first_thread_limit) {
         /* don't need a startup console version here */
-        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00309)
                      "changing ThreadLimit to %d from original value of %d "
                      "not allowed during restart",
                      thread_limit, retained->first_thread_limit);
@@ -2120,7 +2120,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (threads_per_child > thread_limit) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00310)
                          "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
                          "of", threads_per_child);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -2130,7 +2130,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
                          " To increase, please see the ThreadLimit "
                          "directive.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00311)
                          "ThreadsPerChild of %d exceeds ThreadLimit "
                          "of %d, decreasing to match",
                          threads_per_child, thread_limit);
@@ -2139,11 +2139,11 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else if (threads_per_child < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00312)
                          "WARNING: ThreadsPerChild of %d not allowed, "
                          "increasing to 1.", threads_per_child);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00313)
                          "ThreadsPerChild of %d not allowed, increasing to 1",
                          threads_per_child);
         }
@@ -2152,7 +2152,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (max_workers < threads_per_child) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00314)
                          "WARNING: MaxRequestWorkers of %d is less than "
                          "ThreadsPerChild of", max_workers);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -2162,7 +2162,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " as the number of threads in a single server.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00315)
                          "MaxRequestWorkers of %d is less than ThreadsPerChild "
                          "of %d, increasing to match",
                          max_workers, threads_per_child);
@@ -2176,7 +2176,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
         int tmp_max_workers = ap_daemons_limit * threads_per_child;
 
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00316)
                          "WARNING: MaxRequestWorkers of %d is not an integer "
                          "multiple of", max_workers);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -2187,7 +2187,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
                          " for a maximum of %d servers.",
                          ap_daemons_limit);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00317)
                          "MaxRequestWorkers of %d is not an integer multiple of "
                          "ThreadsPerChild of %d, decreasing to nearest "
                          "multiple %d", max_workers, threads_per_child,
@@ -2198,7 +2198,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (ap_daemons_limit > server_limit) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00318)
                          "WARNING: MaxRequestWorkers of %d would require %d "
                          "servers and ", max_workers, ap_daemons_limit);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -2208,7 +2208,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
                          " To increase, please see the ServerLimit "
                          "directive.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00319)
                          "MaxRequestWorkers of %d would require %d servers and "
                          "exceed ServerLimit of %d, decreasing to %d",
                          max_workers, ap_daemons_limit, server_limit,
@@ -2220,11 +2220,11 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
     /* ap_daemons_to_start > ap_daemons_limit checked in worker_run() */
     if (ap_daemons_to_start < 0) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00320)
                          "WARNING: StartServers of %d not allowed, "
                          "increasing to 1.", ap_daemons_to_start);
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00321)
                          "StartServers of %d not allowed, increasing to 1",
                          ap_daemons_to_start);
         }
@@ -2233,7 +2233,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
 
     if (min_spare_threads < 1) {
         if (startup) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL, APLOGNO(00322)
                          "WARNING: MinSpareThreads of %d not allowed, "
                          "increasing to 1", min_spare_threads);
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
@@ -2241,7 +2241,7 @@ static int worker_check_config(apr_pool_t *p, apr_pool_t *plog,
             ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_STARTUP, 0, NULL,
                          " Please read the documentation.");
         } else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s, APLOGNO(00323)
                          "MinSpareThreads of %d not allowed, increasing to 1",
                          min_spare_threads);
         }
@@ -2319,7 +2319,7 @@ static const char *set_max_workers (cmd_parms *cmd, void *dummy,
         return err;
     }
     if (!strcasecmp(cmd->cmd->name, "MaxClients")) {
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL, APLOGNO(00324)
                      "MaxClients is deprecated, use MaxRequestWorkers "
                      "instead.");
     }
diff --git a/server/mpm_common.c b/server/mpm_common.c
index 6791cca..0cd65e5 100644
--- a/server/mpm_common.c
+++ b/server/mpm_common.c
@@ -211,7 +211,7 @@ void ap_sock_disable_nagle(apr_socket_t *s)
     apr_status_t status = apr_socket_opt_set(s, APR_TCP_NODELAY, 1);
 
     if (status != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, status, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, status, ap_server_conf, APLOGNO(00542)
                      "apr_socket_opt_set: (TCP_NODELAY)");
     }
 }
@@ -226,7 +226,7 @@ AP_DECLARE(uid_t) ap_uname2id(const char *name)
         return (atoi(&name[1]));
 
     if (!(ent = getpwnam(name))) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00543)
                      "%s: bad user name %s", ap_server_argv0, name);
         exit(1);
     }
@@ -244,7 +244,7 @@ AP_DECLARE(gid_t) ap_gname2id(const char *name)
         return (atoi(&name[1]));
 
     if (!(ent = getgrnam(name))) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00544)
                      "%s: bad group name %s", ap_server_argv0, name);
         exit(1);
     }
@@ -318,7 +318,7 @@ const char *ap_mpm_set_max_requests(cmd_parms *cmd, void *dummy,
     }
 
     if (!strcasecmp(cmd->cmd->name, "MaxRequestsPerChild")) {
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL, APLOGNO(00545)
                      "MaxRequestsPerChild is deprecated, use "
                      "MaxConnectionsPerChild instead.");
     }
@@ -505,7 +505,7 @@ void ap_core_child_status(server_rec *s, pid_t pid,
     case MPM_CHILD_EXITED:
         status_msg = "exited";
         if (cur == APR_RING_SENTINEL(geninfo, mpm_gen_info_t, link)) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00546)
                          "no record of generation %d of exiting child %" APR_PID_T_FMT,
                          gen, pid);
         }
diff --git a/server/mpm_unix.c b/server/mpm_unix.c
index 96c5e4e..6b1d6ee 100644
--- a/server/mpm_unix.c
+++ b/server/mpm_unix.c
@@ -137,7 +137,7 @@ static int reclaim_one_pid(pid_t pid, action_t action)
     case SEND_SIGTERM:
         /* ok, now it's being annoying */
         ap_log_error(APLOG_MARK, APLOG_WARNING,
-                     0, ap_server_conf,
+                     0, ap_server_conf, APLOGNO(00045)
                      "child process %" APR_PID_T_FMT
                      " still did not exit, "
                      "sending a SIGTERM",
@@ -147,7 +147,7 @@ static int reclaim_one_pid(pid_t pid, action_t action)
 
     case SEND_SIGKILL:
         ap_log_error(APLOG_MARK, APLOG_ERR,
-                     0, ap_server_conf,
+                     0, ap_server_conf, APLOGNO(00046)
                      "child process %" APR_PID_T_FMT
                      " still did not exit, "
                      "sending a SIGKILL",
@@ -162,7 +162,7 @@ static int reclaim_one_pid(pid_t pid, action_t action)
          * after the restart.
          */
         ap_log_error(APLOG_MARK, APLOG_ERR,
-                     0, ap_server_conf,
+                     0, ap_server_conf, APLOGNO(00047)
                      "could not make child process %" APR_PID_T_FMT
                      " exit, "
                      "attempting to continue anyway",
@@ -337,7 +337,7 @@ apr_status_t ap_mpm_safe_kill(pid_t pid, int sig)
     else if (rv != APR_CHILD_NOTDONE) {
         /* The child is already dead and reaped, or was a bogus pid -
          * log this either way. */
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, rv, ap_server_conf, APLOGNO(00048)
                      "cannot send signal %d to pid %ld (non-child or "
                      "already dead)", sig, (long)pid);
         return APR_EINVAL;
@@ -357,7 +357,7 @@ apr_status_t ap_mpm_safe_kill(pid_t pid, int sig)
     }
 
     if (pg != getpgrp()) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_ALERT, 0, ap_server_conf, APLOGNO(00049)
                      "refusing to send signal %d to pid %ld outside "
                      "process group", sig, (long)pid);
         return APR_EINVAL;
@@ -388,7 +388,7 @@ int ap_process_child_status(apr_proc_t *pid, apr_exit_why_e why, int status)
 
         if (status == APEXIT_CHILDFATAL) {
             ap_log_error(APLOG_MARK, APLOG_ALERT,
-                         0, ap_server_conf,
+                         0, ap_server_conf, APLOGNO(00050)
                          "Child %" APR_PID_T_FMT
                          " returned a Fatal error... Apache is exiting!",
                          pid->pid);
@@ -411,7 +411,7 @@ int ap_process_child_status(apr_proc_t *pid, apr_exit_why_e why, int status)
         default:
             if (APR_PROC_CHECK_CORE_DUMP(why)) {
                 ap_log_error(APLOG_MARK, APLOG_NOTICE,
-                             0, ap_server_conf,
+                             0, ap_server_conf, APLOGNO(00051)
                              "child pid %ld exit signal %s (%d), "
                              "possible coredump in %s",
                              (long)pid->pid, sigdesc, signum,
@@ -419,7 +419,7 @@ int ap_process_child_status(apr_proc_t *pid, apr_exit_why_e why, int status)
             }
             else {
                 ap_log_error(APLOG_MARK, APLOG_NOTICE,
-                             0, ap_server_conf,
+                             0, ap_server_conf, APLOGNO(00052)
                              "child pid %ld exit signal %s (%d)",
                              (long)pid->pid, sigdesc, signum);
             }
@@ -493,7 +493,7 @@ static apr_status_t pod_signal_internal(ap_pod_t *pod)
 
     rv = apr_file_write(pod->pod_out, &char_of_death, &one);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, APLOGNO(00053)
                      "write pipe_of_death");
     }
 
@@ -534,7 +534,7 @@ static apr_status_t dummy_connection(ap_pod_t *pod)
 
     rv = apr_socket_create(&sock, lp->bind_addr->family, SOCK_STREAM, 0, p);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, APLOGNO(00054)
                      "get socket to connect to listener");
         apr_pool_destroy(p);
         return rv;
@@ -548,7 +548,7 @@ static apr_status_t dummy_connection(ap_pod_t *pod)
      */
     rv = apr_socket_timeout_set(sock, apr_time_from_sec(3));
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, APLOGNO(00055)
                      "set timeout on socket to connect to listener");
         apr_socket_close(sock);
         apr_pool_destroy(p);
@@ -567,7 +567,7 @@ static apr_status_t dummy_connection(ap_pod_t *pod)
             log_level = APLOG_DEBUG;
         }
 
-        ap_log_error(APLOG_MARK, log_level, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, log_level, rv, ap_server_conf, APLOGNO(00056)
                      "connect to listener on %pI", lp->bind_addr);
     }
 
@@ -636,7 +636,7 @@ static const char *dash_k_arg_noarg = "noarg";
 static int send_signal(pid_t pid, int sig)
 {
     if (kill(pid, sig) < 0) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, errno, NULL,
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, errno, NULL, APLOGNO(00057)
                      "sending signal to server");
         return 1;
     }
@@ -655,9 +655,9 @@ int ap_signal_server(int *exit_status, apr_pool_t *pconf)
     rv = ap_read_pid(pconf, ap_pid_fname, &otherpid);
     if (rv != APR_SUCCESS) {
         if (!APR_STATUS_IS_ENOENT(rv)) {
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, rv, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, rv, NULL, APLOGNO(00058)
                          "Error retrieving pid file %s", ap_pid_fname);
-            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, APLOGNO(00059)
                          "Remove it before continuing if it is corrupted.");
             *exit_status = 1;
             return 1;
@@ -848,7 +848,7 @@ static void sig_coredump(int sig)
      */
     if (getpid() == parent_pid) {
         ap_log_error(APLOG_MARK, APLOG_NOTICE,
-                     0, ap_server_conf,
+                     0, ap_server_conf, APLOGNO(00060)
                      "seg fault or similar nasty error detected "
                      "in the parent process");
         /* XXX we can probably add some rudimentary cleanup code here,
@@ -890,26 +890,26 @@ apr_status_t ap_fatal_signal_setup(server_rec *s, apr_pool_t *in_pconf)
 
     sa.sa_handler = sig_coredump;
     if (sigaction(SIGSEGV, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGSEGV)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, APLOGNO(00061) "sigaction(SIGSEGV)");
 #ifdef SIGBUS
     if (sigaction(SIGBUS, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGBUS)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, APLOGNO(00062) "sigaction(SIGBUS)");
 #endif
 #ifdef SIGABORT
     if (sigaction(SIGABORT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGABORT)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, APLOGNO(00063) "sigaction(SIGABORT)");
 #endif
 #ifdef SIGABRT
     if (sigaction(SIGABRT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGABRT)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, APLOGNO(00064) "sigaction(SIGABRT)");
 #endif
 #ifdef SIGILL
     if (sigaction(SIGILL, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGILL)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, APLOGNO(00065) "sigaction(SIGILL)");
 #endif
 #ifdef SIGFPE
     if (sigaction(SIGFPE, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, "sigaction(SIGFPE)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, s, APLOGNO(00066) "sigaction(SIGFPE)");
 #endif
 
 #else /* NO_USE_SIGACTION */
diff --git a/server/protocol.c b/server/protocol.c
index a79adaa..f44cd21 100644
--- a/server/protocol.c
+++ b/server/protocol.c
@@ -666,7 +666,7 @@ static int read_request_line(request_rec *r, apr_bucket_brigade *bb)
         && !r->parsed_uri.scheme 
         && uri[0] != '/'
         && !(uri[0] == '*' && uri[1] == '\0')) {
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00559)
                       "invalid request-URI %s", uri);
         r->args = NULL;
         r->hostname = NULL;
@@ -719,8 +719,8 @@ static int table_do_fn_check_lengths(void *r_, const char *key,
                                "\n<pre>\n",
                                ap_escape_html(r->pool, key),
                                "</pre>\n", NULL));
-    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, "Request header exceeds "
-                  "LimitRequestFieldSize after merging: %s", key);
+    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00560) "Request header "
+                  "exceeds LimitRequestFieldSize after merging: %s", key);
     return 0;
 }
 
@@ -779,7 +779,7 @@ AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb
                                            "<pre>\n",
                                            ap_escape_html(r->pool, field),
                                            "</pre>\n", NULL));
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00561)
                               "Request header exceeds LimitRequestFieldSize: "
                               "%.*s", field_name_len(field), field);
             }
@@ -809,7 +809,7 @@ AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb
                                                "<pre>\n",
                                                ap_escape_html(r->pool, last_field),
                                                "</pre>\n", NULL));
-                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00562)
                                   "Request header exceeds LimitRequestFieldSize "
                                   "after folding: %.*s",
                                   field_name_len(last_field), last_field);
@@ -838,7 +838,7 @@ AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb
                     apr_table_setn(r->notes, "error-notes",
                                    "The number of request header fields "
                                    "exceeds this server's limit.");
-                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00563)
                                   "Number of request headers exceeds "
                                   "LimitRequestFields");
                     return;
@@ -854,7 +854,7 @@ AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb
                                                ap_escape_html(r->pool,
                                                               last_field),
                                                "</pre>\n", NULL));
-                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00564)
                                   "Request header field is missing ':' "
                                   "separator: %.*s", (int)LOG_NAME_MAX_LEN,
                                   last_field);
@@ -991,12 +991,12 @@ request_rec *ap_read_request(conn_rec *conn)
         if (r->status == HTTP_REQUEST_URI_TOO_LARGE
             || r->status == HTTP_BAD_REQUEST) {
             if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00565)
                               "request failed: URI too long (longer than %d)",
                               r->server->limit_req_line);
             }
             else if (r->method == NULL) {
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00566)
                               "request failed: invalid characters in URI");
             }
             ap_send_error_response(r, 0);
@@ -1033,7 +1033,7 @@ request_rec *ap_read_request(conn_rec *conn)
     if (!r->assbackwards) {
         ap_get_mime_headers_core(r, tmp_bb);
         if (r->status != HTTP_OK) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00567)
                           "request failed: error reading the headers");
             ap_send_error_response(r, 0);
             ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
@@ -1058,7 +1058,7 @@ request_rec *ap_read_request(conn_rec *conn)
              * headers! Have to dink things just to make sure the error message
              * comes through...
              */
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00568)
                           "client sent invalid HTTP/0.9 request: HEAD %s",
                           r->uri);
             r->header_only = 0;
@@ -1100,7 +1100,7 @@ request_rec *ap_read_request(conn_rec *conn)
          * a Host: header, and the server MUST respond with 400 if it doesn't.
          */
         r->status = HTTP_BAD_REQUEST;
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00569)
                       "client sent HTTP/1.1 request without hostname "
                       "(see RFC2616 section 14.23): %s", r->uri);
     }
@@ -1143,7 +1143,7 @@ request_rec *ap_read_request(conn_rec *conn)
         }
         else {
             r->status = HTTP_EXPECTATION_FAILED;
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00570)
                           "client sent an unrecognized expectation value of "
                           "Expect: %s", expect);
             ap_send_error_response(r, 0);
@@ -1267,7 +1267,7 @@ AP_DECLARE(void) ap_note_auth_failure(request_rec *r)
     }
     else {
         ap_log_rerror(APLOG_MARK, APLOG_ERR,
-                      0, r, "need AuthType to note auth failure: %s", r->uri);
+                      0, r, APLOGNO(00571) "need AuthType to note auth failure: %s", r->uri);
     }
 }
 
@@ -1294,7 +1294,7 @@ AP_DECLARE(int) ap_get_basic_auth_pw(request_rec *r, const char **pw)
 
     if (!ap_auth_name(r)) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR,
-                      0, r, "need AuthName: %s", r->uri);
+                      0, r, APLOGNO(00572) "need AuthName: %s", r->uri);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
@@ -1305,7 +1305,7 @@ AP_DECLARE(int) ap_get_basic_auth_pw(request_rec *r, const char **pw)
 
     if (strcasecmp(ap_getword(r->pool, &auth_line, ' '), "Basic")) {
         /* Client tried to authenticate using wrong auth scheme */
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00573)
                       "client used wrong authentication scheme: %s", r->uri);
         ap_note_auth_failure(r);
         return HTTP_UNAUTHORIZED;
@@ -1399,7 +1399,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_content_length_filter(
                 continue;
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00574)
                               "ap_content_length_filter: "
                               "apr_bucket_read() failed");
                 return rv;
@@ -1754,7 +1754,7 @@ AP_DECLARE(void) ap_send_interim_response(request_rec *r, int send_headers)
         return;
     }
     if (!ap_is_HTTP_INFO(r->status)) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00575)
                       "Status is %d - not sending interim response", r->status);
         return;
     }
diff --git a/server/request.c b/server/request.c
index 71122cf..dae8739 100644
--- a/server/request.c
+++ b/server/request.c
@@ -99,7 +99,7 @@ static int auth_internal_per_conf_providers = 0;
 static int decl_die(int status, const char *phase, request_rec *r)
 {
     if (status == DECLINED) {
-        ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r, APLOGNO(00025)
                       "configuration error:  couldn't %s: %s", phase, r->uri);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -134,7 +134,7 @@ AP_DECLARE(int) ap_process_request_internal(request_rec *r)
         if (access_status) {
             if (access_status == HTTP_NOT_FOUND) {
                 if (! d->allow_encoded_slashes) {
-                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00026)
                                   "found %%2f (encoded '/') in URI "
                                   "(decoded='%s'), returning 404",
                                   r->parsed_uri.path);
@@ -235,7 +235,7 @@ AP_DECLARE(int) ap_process_request_internal(request_rec *r)
                 }
                 if (r->user == NULL) {
                     /* don't let buggy authn module crash us in authz */
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00027)
                                   "Buggy authn provider failed to set user for %s",
                                   r->uri);
                     access_status = HTTP_INTERNAL_SERVER_ERROR;
@@ -270,7 +270,7 @@ AP_DECLARE(int) ap_process_request_internal(request_rec *r)
                 }
                 if (r->user == NULL) {
                     /* don't let buggy authn module crash us in authz */
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00028)
                                   "Buggy authn provider failed to set user for %s",
                                   r->uri);
                     access_status = HTTP_INTERNAL_SERVER_ERROR;
@@ -558,7 +558,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
      * handler.  Leave INFO notes here for module debugging.
      */
     if (r->filename == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00029)
                       "Module bug?  Request filename is missing for URI %s",
                       r->uri);
        return OK;
@@ -571,7 +571,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
     if ((rv = apr_filepath_merge(&entry_dir, NULL, r->filename,
                                  APR_FILEPATH_NOTRELATIVE, r->pool))
                   != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00030)
                       "Module bug?  Request filename path %s is invalid or "
                       "or not absolute for uri %s",
                       r->filename, r->uri);
@@ -683,7 +683,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
                      * with a HTTP_FORBIDDEN in case we hit a race condition
                      * here.
                      */
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00031)
                                   "access to %s failed; stat of '%s' failed.",
                                   r->uri, r->filename);
                     return r->status = HTTP_FORBIDDEN;
@@ -692,7 +692,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
                     /* Is this a possibly acceptable symlink? */
                     if ((res = resolve_symlink(r->filename, &thisinfo,
                                                opts, r->pool)) != OK) {
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00032)
                                       "Symbolic link not allowed "
                                       "or link target not accessible: %s",
                                       r->filename);
@@ -762,7 +762,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
                                          r->path_info,
                                          APR_FILEPATH_NOTABOVEROOT, r->pool))
                 != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00033)
                               "dir_walk error, path_info %s is not relative "
                               "to the filename path %s for uri %s",
                               r->path_info, r->filename, r->uri);
@@ -829,7 +829,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
 #endif
 
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00034)
                           "dir_walk error, could not determine the root "
                           "path of filename %s%s for uri %s",
                           r->filename, r->path_info, r->uri);
@@ -1093,7 +1093,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
                 break;
             }
             else if (APR_STATUS_IS_EACCES(rv)) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00035)
                               "access to %s denied because search "
                               "permissions are missing on a component "
                               "of the path", r->uri);
@@ -1104,7 +1104,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
                 /* If we hit ENOTDIR, we must have over-optimized, deny
                  * rather than assume not found.
                  */
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00036)
                               "access to %s failed", r->uri);
                 return r->status = HTTP_FORBIDDEN;
             }
@@ -1126,7 +1126,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
                  */
                 if ((res = resolve_symlink(r->filename, &thisinfo,
                                            opts.opts, r->pool)) != OK) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00037)
                                   "Symbolic link not allowed "
                                   "or link target not accessible: %s",
                                   r->filename);
@@ -1143,7 +1143,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
                 break;
             }
             else if (thisinfo.filetype != APR_DIR) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00038)
                               "Forbidden: %s doesn't point to "
                               "a file or directory",
                               r->filename);
@@ -1679,7 +1679,7 @@ AP_DECLARE(int) ap_if_walk(request_rec *r)
             rc = ap_expr_exec(r, entry_core->condition, &err);
             if (rc <= 0) {
                 if (rc < 0)
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00039)
                                   "Failed to evaluate <If > condition: %s",
                                   err);
                 prev_result = 0;
diff --git a/server/scoreboard.c b/server/scoreboard.c
index 56246e4..72aa070 100644
--- a/server/scoreboard.c
+++ b/server/scoreboard.c
@@ -182,7 +182,7 @@ static apr_status_t create_namebased_scoreboard(apr_pool_t *pool,
 
     rv = apr_shm_create(&ap_scoreboard_shm, scoreboard_size, fname, pool);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00001)
                      "unable to create or access scoreboard \"%s\" "
                      "(name-based shared memory failure)", fname);
         return rv;
@@ -207,7 +207,7 @@ static apr_status_t open_scoreboard(apr_pool_t *pconf)
      */
     rv = apr_pool_create(&global_pool, NULL);
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00002)
                      "Fatal error: unable to create global pool "
                      "for use by the scoreboard");
         return rv;
@@ -218,7 +218,7 @@ static apr_status_t open_scoreboard(apr_pool_t *pconf)
         /* make sure it's an absolute pathname */
         fname = ap_server_root_relative(pconf, ap_scoreboard_fname);
         if (!fname) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, APR_EBADPATH, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, APR_EBADPATH, ap_server_conf, APLOGNO(00003)
                          "Fatal error: Invalid Scoreboard path %s",
                          ap_scoreboard_fname);
             return APR_EBADPATH;
@@ -229,7 +229,7 @@ static apr_status_t open_scoreboard(apr_pool_t *pconf)
         rv = apr_shm_create(&ap_scoreboard_shm, scoreboard_size, NULL,
                             global_pool); /* anonymous shared memory */
         if ((rv != APR_SUCCESS) && (rv != APR_ENOTIMPL)) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf, APLOGNO(00004)
                          "Unable to create or access scoreboard "
                          "(anonymous shared memory failure)");
             return rv;
@@ -257,7 +257,7 @@ apr_status_t ap_reopen_scoreboard(apr_pool_t *p, apr_shm_t **shm, int detached)
         return APR_SUCCESS;
     }
     if (apr_shm_size_get(ap_scoreboard_shm) < scoreboard_size) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf, APLOGNO(00005)
                      "Fatal error: shared scoreboard too small for child!");
         apr_shm_detach(ap_scoreboard_shm);
         ap_scoreboard_shm = NULL;
diff --git a/server/util.c b/server/util.c
index 7fda13c..b16aead 100644
--- a/server/util.c
+++ b/server/util.c
@@ -819,7 +819,7 @@ AP_DECLARE(char *) ap_getword_conf(apr_pool_t *p, const char **line)
 AP_DECLARE(int) ap_cfg_closefile(ap_configfile_t *cfp)
 {
 #ifdef DEBUG
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL, APLOGNO(00551)
         "Done with config file %s", cfp->name);
 #endif
     return (cfp->close == NULL) ? 0 : cfp->close(cfp->param);
@@ -854,7 +854,7 @@ AP_DECLARE(apr_status_t) ap_pcfg_openfile(ap_configfile_t **ret_cfg,
 #endif
 
     if (name == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(00552)
                "Internal error: pcfg_openfile() called with NULL filename");
         return APR_EBADF;
     }
@@ -862,7 +862,7 @@ AP_DECLARE(apr_status_t) ap_pcfg_openfile(ap_configfile_t **ret_cfg,
     status = apr_file_open(&file, name, APR_READ | APR_BUFFERED,
                            APR_OS_DEFAULT, p);
 #ifdef DEBUG
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL, APLOGNO(00553)
                 "Opening config file %s (%s)",
                 name, (status != APR_SUCCESS) ?
                 apr_strerror(status, buf, sizeof(buf)) : "successful");
@@ -880,7 +880,7 @@ AP_DECLARE(apr_status_t) ap_pcfg_openfile(ap_configfile_t **ret_cfg,
 #else
         strcmp(name, "/dev/null") != 0) {
 #endif /* WIN32 || OS2 */
-        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(00554)
                      "Access to file %s denied by server: not a regular file",
                      name);
         apr_file_close(file);
@@ -1074,7 +1074,7 @@ static int cfg_trim_line(char *buf)
     if (start != buf)
         memmove(buf, start, end - start + 2);
 #ifdef DEBUG_CFG_LINES
-    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, NULL, "Read config: '%s'", buf);
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, NULL, APLOGNO(00555) "Read config: '%s'", buf);
 #endif
     return end - start + 1;
 }
@@ -2053,7 +2053,7 @@ char *ap_get_local_host(apr_pool_t *a)
     char *hostname;
 
     if (apr_gethostname(str, sizeof(str) - 1, a) != APR_SUCCESS) {
-        ap_log_perror(APLOG_MARK, APLOG_STARTUP | APLOG_WARNING, 0, a,
+        ap_log_perror(APLOG_MARK, APLOG_STARTUP | APLOG_WARNING, 0, a, APLOGNO(00556)
                      "%s: apr_gethostname() failed to determine ServerName",
                      ap_server_argv0);
     } else {
@@ -2070,7 +2070,7 @@ char *ap_get_local_host(apr_pool_t *a)
                 server_hostname = apr_pstrdup(a, hostname);
             }
         } else {
-            ap_log_perror(APLOG_MARK, APLOG_STARTUP | APLOG_WARNING, 0, a,
+            ap_log_perror(APLOG_MARK, APLOG_STARTUP | APLOG_WARNING, 0, a, APLOGNO(00557)
                          "%s: apr_sockaddr_info_get() failed for %s",
                          ap_server_argv0, str);
         }
@@ -2079,7 +2079,7 @@ char *ap_get_local_host(apr_pool_t *a)
     if (!server_hostname)
         server_hostname = apr_pstrdup(a, "127.0.0.1");
 
-    ap_log_perror(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0, a,
+    ap_log_perror(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0, a, APLOGNO(00558)
                  "%s: Could not reliably determine the server's fully qualified "
                  "domain name, using %s. Set the 'ServerName' directive globally "
                  "to suppress this message",
diff --git a/server/util_cookies.c b/server/util_cookies.c
index e79d5f5..dc8c457 100644
--- a/server/util_cookies.c
+++ b/server/util_cookies.c
@@ -55,7 +55,7 @@ AP_DECLARE(apr_status_t) ap_cookie_write(request_rec * r, const char *name, cons
     /* create RFC2109 compliant cookie */
     rfc2109 = apr_pstrcat(r->pool, name, "=", val, ";", buffer,
                           attrs && *attrs ? attrs : DEFAULT_ATTRS, NULL);
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, LOG_PREFIX
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00007) LOG_PREFIX
                   "user '%s' set cookie: '%s'", r->user, rfc2109);
 
     /* write the cookie to the header table(s) provided */
@@ -97,7 +97,7 @@ AP_DECLARE(apr_status_t) ap_cookie_write2(request_rec * r, const char *name2, co
     /* create RFC2965 compliant cookie */
     rfc2965 = apr_pstrcat(r->pool, name2, "=", val, ";", buffer,
                           attrs2 && *attrs2 ? attrs2 : DEFAULT_ATTRS, NULL);
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, LOG_PREFIX
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00008) LOG_PREFIX
                   "user '%s' set cookie2: '%s'", r->user, rfc2965);
 
     /* write the cookie to the header table(s) provided */
@@ -125,7 +125,7 @@ AP_DECLARE(apr_status_t) ap_cookie_remove(request_rec * r, const char *name, con
     /* create RFC2109 compliant cookie */
     const char *rfc2109 = apr_pstrcat(r->pool, name, "=;Max-Age=0;",
                                 attrs ? attrs : CLEAR_ATTRS, NULL);
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, LOG_PREFIX
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00009) LOG_PREFIX
                   "user '%s' removed cookie: '%s'", r->user, rfc2109);
 
     /* write the cookie to the header table(s) provided */
@@ -153,7 +153,7 @@ AP_DECLARE(apr_status_t) ap_cookie_remove2(request_rec * r, const char *name2, c
     /* create RFC2965 compliant cookie */
     const char *rfc2965 = apr_pstrcat(r->pool, name2, "=;Max-Age=0;",
                                 attrs2 ? attrs2 : CLEAR_ATTRS, NULL);
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, LOG_PREFIX
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00010) LOG_PREFIX
                   "user '%s' removed cookie2: '%s'", r->user, rfc2965);
 
     /* write the cookie to the header table(s) provided */
@@ -256,7 +256,7 @@ AP_DECLARE(apr_status_t) ap_cookie_read(request_rec * r, const char *name, const
                  extract_cookie_line, (void *) &v, r->headers_in,
                  "Cookie", "Cookie2", NULL);
     if (v.duplicated) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00011) LOG_PREFIX
          "client submitted cookie '%s' more than once: %s", v.name, r->uri);
         return APR_EGENERAL;
     }
diff --git a/server/util_ebcdic.c b/server/util_ebcdic.c
index 67cd3d3..1a8c0ba 100644
--- a/server/util_ebcdic.c
+++ b/server/util_ebcdic.c
@@ -34,35 +34,35 @@ apr_status_t ap_init_ebcdic(apr_pool_t *pool)
 
     rv = apr_xlate_open(&ap_hdrs_to_ascii, "ISO-8859-1", APR_DEFAULT_CHARSET, pool);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, APLOGNO(00040)
                      "apr_xlate_open() failed");
         return rv;
     }
 
     rv = apr_xlate_open(&ap_hdrs_from_ascii, APR_DEFAULT_CHARSET, "ISO-8859-1", pool);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, APLOGNO(00041)
                      "apr_xlate_open() failed");
         return rv;
     }
 
     rv = apr_MD5InitEBCDIC(ap_hdrs_to_ascii);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, APLOGNO(00042)
                      "apr_MD5InitEBCDIC() failed");
         return rv;
     }
 
     rv = apr_base64init_ebcdic(ap_hdrs_to_ascii, ap_hdrs_from_ascii);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, APLOGNO(00043)
                      "apr_base64init_ebcdic() failed");
         return rv;
     }
 
     rv = apr_SHA1InitEBCDIC(ap_hdrs_to_ascii);
     if (rv) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, APLOGNO(00044)
                      "apr_SHA1InitEBCDIC() failed");
         return rv;
     }
diff --git a/server/util_expr_eval.c b/server/util_expr_eval.c
index d4233e4..ffb7ba5 100644
--- a/server/util_expr_eval.c
+++ b/server/util_expr_eval.c
@@ -806,7 +806,7 @@ AP_DECLARE(int) ap_expr_exec_ctx(ap_expr_eval_ctx_t *ctx)
     if (ctx->info->flags & AP_EXPR_FLAG_STRING_RESULT) {
         *ctx->result_string = ap_expr_eval_word(ctx, ctx->info->root_node);
         if (*ctx->err != NULL) {
-            ap_log_rerror(LOG_MARK(ctx->info), APLOG_ERR, 0, ctx->r,
+            ap_log_rerror(LOG_MARK(ctx->info), APLOG_ERR, 0, ctx->r, APLOGNO(00536)
                           "Evaluation of expression from %s:%d failed: %s",
                           ctx->info->filename, ctx->info->line_number, *ctx->err);
             return -1;
@@ -821,7 +821,7 @@ AP_DECLARE(int) ap_expr_exec_ctx(ap_expr_eval_ctx_t *ctx)
     else {
         rc = ap_expr_eval(ctx, ctx->info->root_node);
         if (*ctx->err != NULL) {
-            ap_log_rerror(LOG_MARK(ctx->info), APLOG_ERR, 0, ctx->r,
+            ap_log_rerror(LOG_MARK(ctx->info), APLOG_ERR, 0, ctx->r, APLOGNO(00537)
                           "Evaluation of expression from %s:%d failed: %s",
                           ctx->info->filename, ctx->info->line_number, *ctx->err);
             return -1;
@@ -1076,7 +1076,7 @@ static const char *unescape_func(ap_expr_eval_ctx_t *ctx, const void *data,
     int ret = ap_unescape_url_keep2f(result, 0);
     if (ret == OK)
         return result;
-    ap_log_rerror(LOG_MARK(ctx->info), APLOG_DEBUG, 0, ctx->r,
+    ap_log_rerror(LOG_MARK(ctx->info), APLOG_DEBUG, 0, ctx->r, APLOGNO(00538)
                   "%s %% escape in unescape('%s') at %s:%d",
                   ret == HTTP_BAD_REQUEST ? "Bad" : "Forbidden", arg,
                   ctx->info->filename, ctx->info->line_number);
diff --git a/server/util_filter.c b/server/util_filter.c
index 7e204f2..204d47d 100644
--- a/server/util_filter.c
+++ b/server/util_filter.c
@@ -294,7 +294,7 @@ static ap_filter_t *add_any_filter_handle(ap_filter_rec_t *frec, void *ctx,
             outf = r_filters;
         }
         else {
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(00080)
                           "a content filter was added without a request: %s", frec->name);
             return NULL;
         }
@@ -304,7 +304,7 @@ static ap_filter_t *add_any_filter_handle(ap_filter_rec_t *frec, void *ctx,
             outf = p_filters;
         }
         else {
-            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
+            ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(00081)
                           "a protocol filter was added without a request: %s", frec->name);
             return NULL;
         }
@@ -401,7 +401,7 @@ static ap_filter_t *add_any_filter(const char *name, void *ctx,
         }
     }
 
-    ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, r ? r->connection : c,
+    ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, r ? r->connection : c, APLOGNO(00082)
                   "an unknown filter was not added: %s", name);
     return NULL;
 }
@@ -553,7 +553,7 @@ AP_DECLARE(apr_status_t) ap_pass_brigade_fchk(request_rec *r,
     if (rv != APR_SUCCESS) {
         if (rv != AP_FILTER_ERROR) {
             if (!fmt)
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r,
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(00083)
                               "ap_pass_brigade returned %d", rv);
             else {
                 va_list ap;
@@ -561,7 +561,7 @@ AP_DECLARE(apr_status_t) ap_pass_brigade_fchk(request_rec *r,
                 va_start(ap, fmt);
                 res = apr_pvsprintf(r->pool, fmt, ap);
                 va_end(ap);
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, "%s", res);
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, r, APLOGNO(00084) "%s", res);
             }
             return HTTP_INTERNAL_SERVER_ERROR;
         }
diff --git a/server/util_mutex.c b/server/util_mutex.c
index c5c1bf0..0ff9483 100644
--- a/server/util_mutex.c
+++ b/server/util_mutex.c
@@ -372,21 +372,21 @@ static mutex_cfg_t *mxcfg_lookup(apr_pool_t *p, const char *type)
 
 static void log_bad_create_options(server_rec *s, const char *type)
 {
-    ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(00021)
                  "Invalid options were specified when creating the %s mutex",
                  type);
 }
 
 static void log_unknown_type(server_rec *s, const char *type)
 {
-    ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(00022)
                  "Can't create mutex of unknown type %s", type);
 }
 
 static void log_create_failure(apr_status_t rv, server_rec *s, const char *type,
                                const char *fname)
 {
-    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
+    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(00023)
                  "Couldn't create the %s mutex %s%s%s", type,
                  fname ? "(file " : "",
                  fname ? fname : "",
@@ -396,7 +396,7 @@ static void log_create_failure(apr_status_t rv, server_rec *s, const char *type,
 #ifdef AP_NEED_SET_MUTEX_PERMS
 static void log_perms_failure(apr_status_t rv, server_rec *s, const char *type)
 {
-    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
+    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s, APLOGNO(00024)
                  "Couldn't set permissions on the %s mutex; "
                  "check User and Group directives",
                  type);
diff --git a/server/util_xml.c b/server/util_xml.c
index 6f31fe9..26f1c6e 100644
--- a/server/util_xml.c
+++ b/server/util_xml.c
@@ -85,7 +85,7 @@ AP_DECLARE(int) ap_xml_parse_input(request_rec * r, apr_xml_doc **pdoc)
 
             total_read += len;
             if (limit_xml_body && total_read > limit_xml_body) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00539)
                               "XML request body is larger than the configured "
                               "limit of %lu", (unsigned long)limit_xml_body);
                 result = HTTP_REQUEST_ENTITY_TOO_LARGE;
@@ -111,7 +111,7 @@ AP_DECLARE(int) ap_xml_parse_input(request_rec * r, apr_xml_doc **pdoc)
             *pdoc = NULL;
             return OK;
         }
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00540)
                       "XML parser error (at end). status=%d", status);
         return HTTP_BAD_REQUEST;
     }
@@ -123,7 +123,7 @@ AP_DECLARE(int) ap_xml_parse_input(request_rec * r, apr_xml_doc **pdoc)
 
   parser_error:
     (void) apr_xml_parser_geterror(parser, errbuf, sizeof(errbuf));
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00541)
                   "XML Parser Error: %s", errbuf);
 
     /* FALLTHRU */
diff --git a/server/vhost.c b/server/vhost.c
index 825708d..302e408 100644
--- a/server/vhost.c
+++ b/server/vhost.c
@@ -198,7 +198,7 @@ static const char *get_addresses(apr_pool_t *p, const char *w_,
     else {
         rv = apr_sockaddr_info_get(&my_addr, host, APR_UNSPEC, port, 0, p);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, APLOGNO(00547)
                 "Could not resolve host name %s -- ignoring!", host);
             return NULL;
         }
@@ -255,7 +255,7 @@ AP_DECLARE_NONSTD(const char *)ap_set_name_virtual_host(cmd_parms *cmd,
 {
     static int warnonce = 0;
     if (++warnonce == 1) {
-        ap_log_error(APLOG_MARK, APLOG_NOTICE|APLOG_STARTUP, APR_SUCCESS, NULL,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE|APLOG_STARTUP, APR_SUCCESS, NULL, APLOGNO(00548)
                      "NameVirtualHost has no effect and will be removed in the "
                      "next release %s:%d",
                      cmd->directive->filename,
@@ -643,7 +643,7 @@ AP_DECLARE(void) ap_fini_vhost_config(apr_pool_t *p, server_rec *main_s)
                     char *ipaddr_str;
 
                     apr_sockaddr_ip_get(&ipaddr_str, s->addrs->host_addr);
-                    ap_log_error(APLOG_MARK, APLOG_ERR, rv, main_s,
+                    ap_log_error(APLOG_MARK, APLOG_ERR, rv, main_s, APLOGNO(00549)
                                  "Failed to resolve server name "
                                  "for %s (check DNS) -- or specify an explicit "
                                  "ServerName",
@@ -754,7 +754,7 @@ static void fix_hostname(request_rec *r)
 
 bad:
     r->status = HTTP_BAD_REQUEST;
-    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00550)
                   "Client sent malformed Host header");
     return;
 }
