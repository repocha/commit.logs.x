commit 2b0d5d6a741ad6a8fe956eb3ccd99254d449d9d8
Author: Jeff Trawick <trawick@apache.org>
Date:   Fri May 17 11:33:10 2002 +0000

    stop using APLOG_NOERRNO in calls to ap_log_[pr]error()
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@95151 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/modules/aaa/mod_access.c b/modules/aaa/mod_access.c
index fb0be97..af377aa 100644
--- a/modules/aaa/mod_access.c
+++ b/modules/aaa/mod_access.c
@@ -321,7 +321,7 @@ static int check_dir_access(request_rec *r)
 
     if (ret == HTTP_FORBIDDEN
         && (ap_satisfies(r) != SATISFY_ANY || !ap_some_auth_required(r))) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
             "client denied by server configuration: %s",
             r->filename);
     }
diff --git a/modules/aaa/mod_auth.c b/modules/aaa/mod_auth.c
index f3afc21..2652fae 100644
--- a/modules/aaa/mod_auth.c
+++ b/modules/aaa/mod_auth.c
@@ -229,14 +229,14 @@ static int authenticate_basic_user(request_rec *r)
         if (!(conf->auth_authoritative)) {
             return DECLINED;
         }
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "user %s not found: %s", r->user, r->uri);
         ap_note_basic_auth_failure(r);
         return HTTP_UNAUTHORIZED;
     }
     invalid_pw = apr_password_validate(sent_pw, real_pw);
     if (invalid_pw != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "user %s: authentication failure for \"%s\": "
                       "Password Mismatch",
                       r->user, r->uri);
@@ -316,7 +316,7 @@ static int check_user_access(request_rec *r)
              * That something could be a missing "AuthAuthoritative off", but
              * more likely is a typo in the require directive.
              */
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "access to %s failed, reason: unknown require "
                           "directive:\"%s\"", r->uri, reqs[x].requirement);
         }
@@ -330,7 +330,7 @@ static int check_user_access(request_rec *r)
         return DECLINED;
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                   "access to %s failed, reason: user %s not allowed access",
                   r->uri, user);
         
diff --git a/modules/aaa/mod_auth_anon.c b/modules/aaa/mod_auth_anon.c
index 90fc0b4..61843e7 100644
--- a/modules/aaa/mod_auth_anon.c
+++ b/modules/aaa/mod_auth_anon.c
@@ -224,7 +224,7 @@ static int anon_authenticate_basic_user(request_rec *r)
 	       || ((strpbrk("@", sent_pw) != NULL)
 		   && (strpbrk(".", sent_pw) != NULL)))) {
 	if (conf->anon_auth_logemail && ap_is_initial_req(r)) {
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, APR_SUCCESS, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_INFO, APR_SUCCESS, r,
 			"Anonymous: Passwd <%s> Accepted",
 			sent_pw ? sent_pw : "\'none\'");
 	}
@@ -232,7 +232,7 @@ static int anon_authenticate_basic_user(request_rec *r)
     }
     else {
 	if (conf->anon_auth_authoritative) {
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, APR_SUCCESS, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_SUCCESS, r,
 			"Anonymous: Authoritative, Passwd <%s> not accepted",
 			sent_pw ? sent_pw : "\'none\'");
 	    return HTTP_UNAUTHORIZED;
diff --git a/modules/aaa/mod_auth_dbm.c b/modules/aaa/mod_auth_dbm.c
index 782412d..a88765d 100644
--- a/modules/aaa/mod_auth_dbm.c
+++ b/modules/aaa/mod_auth_dbm.c
@@ -231,7 +231,7 @@ static int dbm_authenticate_basic_user(request_rec *r)
                                conf->auth_dbmtype))) {
         if (!(conf->auth_dbmauthoritative))
             return DECLINED;
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "DBM user %s not found: %s", r->user, r->filename);
         ap_note_basic_auth_failure(r);
         return HTTP_UNAUTHORIZED;
@@ -243,7 +243,7 @@ static int dbm_authenticate_basic_user(request_rec *r)
     }
     invalid_pw = apr_password_validate(sent_pw, real_pw);
     if (invalid_pw != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "DBM user %s: authentication failure for \"%s\": "
                       "Password Mismatch",
                       r->user, r->uri);
@@ -290,7 +290,7 @@ static int dbm_check_auth(request_rec *r)
                                        conf->auth_dbmtype))) {
                 if (!(conf->auth_dbmauthoritative))
                     return DECLINED;
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "user %s not in DBM group file %s: %s",
                             user, conf->auth_dbmgrpfile, r->filename);
                 ap_note_basic_auth_failure(r);
@@ -306,7 +306,7 @@ static int dbm_check_auth(request_rec *r)
                         return OK;
                 }
             }
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "user %s not in right group: %s",
                           user, r->filename);
             ap_note_basic_auth_failure(r);
diff --git a/modules/aaa/mod_auth_digest.c b/modules/aaa/mod_auth_digest.c
index a82b119..763c235 100644
--- a/modules/aaa/mod_auth_digest.c
+++ b/modules/aaa/mod_auth_digest.c
@@ -239,7 +239,7 @@ module AP_MODULE_DECLARE_DATA auth_digest_module;
 
 static apr_status_t cleanup_tables(void *not_used)
 {
-    ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
+    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                   "Digest: cleaning up shared memory");
     fflush(stderr);
 
@@ -265,7 +265,7 @@ static apr_status_t initialize_secret(server_rec *s)
 {
     apr_status_t status;
 
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s,
                  "Digest: generating secret for digest authentication ...");
 
 #if APR_HAS_RANDOM
@@ -282,7 +282,7 @@ static apr_status_t initialize_secret(server_rec *s)
         return status;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, s, "Digest: done");
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s, "Digest: done");
 
     return APR_SUCCESS;
 }
@@ -510,7 +510,7 @@ static const char *set_qop(cmd_parms *cmd, void *config, const char *op)
     }
 
     if (!strcasecmp(op, "auth-int")) {
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
                      "Digest: WARNING: qop `auth-int' currently only works "
                      "correctly for responses with no entity");
     }
@@ -557,7 +557,7 @@ static const char *set_nonce_format(cmd_parms *cmd, void *config,
 static const char *set_nc_check(cmd_parms *cmd, void *config, int flag)
 {
     if (flag && !client_shm)
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0,
                      cmd->server, "Digest: WARNING: nonce-count checking "
                      "is not supported on platforms without shared-memory "
                      "support - disabling check");
@@ -570,7 +570,7 @@ static const char *set_algorithm(cmd_parms *cmd, void *config, const char *alg)
 {
     if (!strcasecmp(alg, "MD5-sess")) {
         if (!client_shm) {
-            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0,
                          cmd->server, "Digest: WARNING: algorithm `MD5-sess' "
                          "is not supported on platforms without shared-memory "
                          "support - reverting to MD5");
@@ -632,7 +632,7 @@ static const char *set_shmem_size(cmd_parms *cmd, void *config,
     if (num_buckets == 0) {
         num_buckets = 1;
     }
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
                  "Digest: Set shmem-size: %ld, num-buckets: %ld", shmem_size,
                  num_buckets);
 
@@ -748,11 +748,11 @@ static client_entry *get_client(unsigned long key, const request_rec *r)
     apr_global_mutex_unlock(client_lock);
 
     if (entry) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                       "get_client(): client %lu found", key);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                       "get_client(): client %lu not found", key);
     }
 
@@ -824,7 +824,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
     entry = (client_entry *)apr_rmm_malloc(client_rmm, sizeof(client_entry));
     if (!entry) {
         long num_removed = gc();
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
                      "Digest: gc'd %ld client entries. Total new clients: "
                      "%ld; Total removed clients: %ld; Total renewed clients: "
                      "%ld", num_removed,
@@ -847,7 +847,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
 
     apr_global_mutex_unlock(client_lock);
 
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
                  "allocated new client %lu", key);
 
     return entry;
@@ -1466,7 +1466,7 @@ static int check_nc(const request_rec *r, const digest_header_rec *resp,
 
     nc = strtol(snc, &endptr, 16);
     if (endptr < (snc+strlen(snc)) && !apr_isspace(*endptr)) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Digest: invalid nc %s received - not a number", snc);
         return !OK;
     }
@@ -1476,7 +1476,7 @@ static int check_nc(const request_rec *r, const digest_header_rec *resp,
     }
 
     if (nc != resp->client->nonce_count) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Digest: Warning, possible replay attack: nonce-count "
                       "check failed: %lu != %lu", nc,
                       resp->client->nonce_count);
@@ -1495,7 +1495,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
     char tmp, hash[NONCE_HASH_LEN+1];
 
     if (strlen(resp->nonce) != NONCE_LEN) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Digest: invalid nonce %s received - length is not %d",
                       resp->nonce, NONCE_LEN);
         note_digest_auth_failure(r, conf, resp, 1);
@@ -1510,7 +1510,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
     resp->nonce_time = nonce_time.time;
 
     if (strcmp(hash, resp->nonce+NONCE_TIME_LEN)) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Digest: invalid nonce %s received - hash is not %s",
                       resp->nonce, hash);
         note_digest_auth_failure(r, conf, resp, 1);
@@ -1519,7 +1519,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
 
     dt = r->request_time - nonce_time.time;
     if (conf->nonce_lifetime > 0 && dt < 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Digest: invalid nonce %s received - user attempted "
                       "time travel", resp->nonce);
         note_digest_auth_failure(r, conf, resp, 1);
@@ -1528,7 +1528,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
 
     if (conf->nonce_lifetime > 0) {
         if (dt > conf->nonce_lifetime) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0,r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0,r,
                           "Digest: user %s: nonce expired (%.2f seconds old "
                           "- max lifetime %.2f) - sending new nonce", 
                           r->user, ((double)dt)/APR_USEC_PER_SEC, 
@@ -1539,7 +1539,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
     }
     else if (conf->nonce_lifetime == 0 && resp->client) {
         if (memcmp(resp->client->last_nonce, resp->nonce, NONCE_LEN)) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                           "Digest: user %s: one-time-nonce mismatch - sending "
                           "new nonce", r->user);
             note_digest_auth_failure(r, conf, resp, 1);
@@ -1672,7 +1672,7 @@ static int authenticate_digest_user(request_rec *r)
     }
 
     if (!ap_auth_name(r)) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Digest: need AuthName: %s", r->uri);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -1702,12 +1702,12 @@ static int authenticate_digest_user(request_rec *r)
 
     if (resp->auth_hdr_sts != VALID) {
         if (resp->auth_hdr_sts == NOT_DIGEST) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Digest: client used wrong authentication scheme "
                           "`%s': %s", resp->scheme, r->uri);
         }
         else if (resp->auth_hdr_sts == INVALID) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Digest: missing user, realm, nonce, uri, digest, "
                           "cnonce, or nonce_count in authorization header: %s",
                           r->uri);
@@ -1730,7 +1730,7 @@ static int authenticate_digest_user(request_rec *r)
 
         copy_uri_components(&r_uri, resp->psd_request_uri, r);
         if (apr_uri_parse(r->pool, resp->uri, &d_uri) != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Digest: invalid uri <%s> in Authorization header",
                           resp->uri);
             return HTTP_BAD_REQUEST;
@@ -1748,7 +1748,7 @@ static int authenticate_digest_user(request_rec *r)
 
         if (r->method_number == M_CONNECT) {
             if (strcmp(resp->uri, r_uri.hostinfo)) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "Digest: uri mismatch - <%s> does not match "
                               "request-uri <%s>", resp->uri, r_uri.hostinfo);
                 return HTTP_BAD_REQUEST;
@@ -1776,7 +1776,7 @@ static int authenticate_digest_user(request_rec *r)
                 && (!d_uri.query || !r_uri.query
                     || strcmp(d_uri.query, r_uri.query)))
             ) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Digest: uri mismatch - <%s> does not match "
                           "request-uri <%s>", resp->uri, resp->raw_request_uri);
             return HTTP_BAD_REQUEST;
@@ -1784,7 +1784,7 @@ static int authenticate_digest_user(request_rec *r)
     }
 
     if (resp->opaque && resp->opaque_num == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Digest: received invalid opaque - got `%s'",
                       resp->opaque);
         note_digest_auth_failure(r, conf, resp, 0);
@@ -1792,7 +1792,7 @@ static int authenticate_digest_user(request_rec *r)
     }
 
     if (strcmp(resp->realm, conf->realm)) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Digest: realm mismatch - got `%s' but expected `%s'",
                       resp->realm, conf->realm);
         note_digest_auth_failure(r, conf, resp, 0);
@@ -1802,7 +1802,7 @@ static int authenticate_digest_user(request_rec *r)
     if (resp->algorithm != NULL
         && strcasecmp(resp->algorithm, "MD5")
         && strcasecmp(resp->algorithm, "MD5-sess")) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Digest: unknown algorithm `%s' received: %s",
                       resp->algorithm, r->uri);
         note_digest_auth_failure(r, conf, resp, 0);
@@ -1814,7 +1814,7 @@ static int authenticate_digest_user(request_rec *r)
     }
 
     if (!(conf->ha1 = get_hash(r, r->user, conf->realm, conf->pwfile))) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Digest: user `%s' in realm `%s' not found: %s",
                       r->user, conf->realm, r->uri);
         note_digest_auth_failure(r, conf, resp, 0);
@@ -1825,7 +1825,7 @@ static int authenticate_digest_user(request_rec *r)
     if (resp->message_qop == NULL) {
         /* old (rfc-2069) style digest */
         if (strcmp(resp->digest, old_digest(r, resp, conf->ha1))) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Digest: user %s: password mismatch: %s", r->user,
                           r->uri);
             note_digest_auth_failure(r, conf, resp, 0);
@@ -1845,7 +1845,7 @@ static int authenticate_digest_user(request_rec *r)
         if (!match
             && !(conf->qop_list[0] == NULL
                  && !strcasecmp(resp->message_qop, "auth"))) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Digest: invalid qop `%s' received: %s",
                           resp->message_qop, r->uri);
             note_digest_auth_failure(r, conf, resp, 0);
@@ -1858,7 +1858,7 @@ static int authenticate_digest_user(request_rec *r)
             return HTTP_INTERNAL_SERVER_ERROR;
         }
         if (strcmp(resp->digest, exp_digest)) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Digest: user %s: password mismatch: %s", r->user,
                           r->uri);
             note_digest_auth_failure(r, conf, resp, 0);
@@ -1996,7 +1996,7 @@ static int digest_check_auth(request_rec *r)
             }
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Digest: access to %s failed, reason: unknown "
                           "require directive \"%s\"",
                           r->uri, reqs[x].requirement);
@@ -2008,7 +2008,7 @@ static int digest_check_auth(request_rec *r)
         return OK;
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                   "Digest: access to %s failed, reason: user %s not "
                   "allowed access", r->uri, user);
 
@@ -2135,7 +2135,7 @@ static int add_auth_info(request_rec *r)
         if (resp->algorithm && !strcasecmp(resp->algorithm, "MD5-sess")) {
             ha1 = get_session_HA1(r, resp, conf, 0);
             if (!ha1) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "Digest: internal error: couldn't find session "
                               "info for user %s", resp->username);
                 return !OK;
diff --git a/modules/arch/win32/mod_isapi.c b/modules/arch/win32/mod_isapi.c
index 925f46d..e4cb1ab 100644
--- a/modules/arch/win32/mod_isapi.c
+++ b/modules/arch/win32/mod_isapi.c
@@ -189,7 +189,7 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
 	return NULL;
     }
     if (tmp.filetype != APR_REG) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, 0, cmd->server,
+	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
 	    "ISAPI: not a regular file, skipping %s", fspec);
 	return NULL;
     }
@@ -900,7 +900,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
 
     case HSE_REQ_GET_SSPI_INFO:
         if (cid->dconf.log_unsupported)
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                            "ISAPI: ServerSupportFunction HSE_REQ_GET_SSPI_INFO "
                            "is not supported: %s", r->filename);
         SetLastError(ERROR_INVALID_PARAMETER);
@@ -917,7 +917,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
                 r->args = apr_pstrdup(r->pool, (char*) buf_data);
         }
         if (cid->dconf.log_to_errlog)
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                           "ISAPI: %s: %s", cid->r->filename,
                           (char*) buf_data);
         return 1;
@@ -935,7 +935,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
             return 1;
         }
         if (cid->dconf.log_unsupported)
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                       "ISAPI: ServerSupportFunction HSE_REQ_IO_COMPLETION "
                       "is not supported: %s", r->filename);
         SetLastError(ERROR_INVALID_PARAMETER);
@@ -956,7 +956,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
 
         if (!cid->dconf.fake_async && (tf->dwFlags & HSE_IO_ASYNC)) {
             if (cid->dconf.log_unsupported)
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                          "ISAPI: ServerSupportFunction HSE_REQ_TRANSMIT_FILE "
                          "as HSE_IO_ASYNC is not supported: %s", r->filename);
             SetLastError(ERROR_INVALID_PARAMETER);
@@ -1080,7 +1080,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
 
     case HSE_REQ_REFRESH_ISAPI_ACL:
         if (cid->dconf.log_unsupported)
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                           "ISAPI: ServerSupportFunction "
                           "HSE_REQ_REFRESH_ISAPI_ACL "
                           "is not supported: %s", r->filename);
@@ -1097,7 +1097,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
         int res;
         if (!cid->dconf.fake_async) {
             if (cid->dconf.log_unsupported) 
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                             "ISAPI: asynchronous I/O not supported: %s", 
                             r->filename);
             SetLastError(ERROR_INVALID_PARAMETER);
@@ -1129,7 +1129,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
 
     case HSE_REQ_GET_IMPERSONATION_TOKEN:  /* Added in ISAPI 4.0 */
         if (cid->dconf.log_unsupported)
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                           "ISAPI: ServerSupportFunction "
                           "HSE_REQ_GET_IMPERSONATION_TOKEN "
                           "is not supported: %s", r->filename);
@@ -1207,7 +1207,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
 
     case HSE_REQ_ABORTIVE_CLOSE:
         if (cid->dconf.log_unsupported)
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                           "ISAPI: ServerSupportFunction HSE_REQ_ABORTIVE_CLOSE"
                           " is not supported: %s", r->filename);
         SetLastError(ERROR_INVALID_PARAMETER);
@@ -1215,7 +1215,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
 
     case HSE_REQ_GET_CERT_INFO_EX:  /* Added in ISAPI 4.0 */
         if (cid->dconf.log_unsupported)
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                           "ISAPI: ServerSupportFunction "
                           "HSE_REQ_GET_CERT_INFO_EX "
                           "is not supported: %s", r->filename);        
@@ -1253,7 +1253,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
 
     case HSE_REQ_CLOSE_CONNECTION:  /* Added after ISAPI 4.0 */
         if (cid->dconf.log_unsupported)
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                           "ISAPI: ServerSupportFunction "
                           "HSE_REQ_CLOSE_CONNECTION "
                           "is not supported: %s", r->filename);
@@ -1271,7 +1271,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
         /*  Undocumented - defined by the Microsoft Jan '00 Platform SDK
          */
         if (cid->dconf.log_unsupported)
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                           "ISAPI: ServerSupportFunction "
                           "HSE_REQ_EXTENSION_TRIGGER "
                           "is not supported: %s", r->filename);
@@ -1280,7 +1280,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
 
     default:
         if (cid->dconf.log_unsupported)
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                           "ISAPI: ServerSupportFunction (%d) not supported: "
                           "%s", HSE_code, r->filename);
         SetLastError(ERROR_INVALID_PARAMETER);
@@ -1454,7 +1454,7 @@ apr_status_t isapi_handler (request_rec *r)
 
     /* Check for a log message - and log it */
     if (cid->ecb->lpszLogData && *cid->ecb->lpszLogData)
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                       "ISAPI: %s: %s", r->filename, cid->ecb->lpszLogData);
 
     switch(rv) {
@@ -1502,7 +1502,7 @@ apr_status_t isapi_handler (request_rec *r)
                 break;
             }
             else if (cid->dconf.log_unsupported) {
-                 ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
+                 ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                                "ISAPI: asynch I/O result HSE_STATUS_PENDING "
                                "from HttpExtensionProc() is not supported: %s",
                                r->filename);
@@ -1550,7 +1550,7 @@ static int isapi_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pte
     
     loaded.hash = apr_hash_make(loaded.pool);
     if (!loaded.hash) {
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO, 0, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
                      "ISAPI: Failed to create module cache");
         return APR_EGENERAL;
     }
diff --git a/modules/arch/win32/mod_win32.c b/modules/arch/win32/mod_win32.c
index 1843563..cdc6aab 100644
--- a/modules/arch/win32/mod_win32.c
+++ b/modules/arch/win32/mod_win32.c
@@ -461,7 +461,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
             *type = APR_PROGRAM_PATH;
         }
         else {
-            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                  strict ? "No ExecCGI verb found for files of type '%s'."
                         : "No ExecCGI or Open verb found for files of type '%s'.", 
                  ext);
@@ -520,7 +520,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
         }
     }
     if (!interpreter) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "%s is not executable; ensure interpreted scripts have "
                       "\"#!\" first line", *cmd);
         return APR_EBADF;
diff --git a/modules/cache/mod_file_cache.c b/modules/cache/mod_file_cache.c
index ef172dd..0a58de0 100644
--- a/modules/cache/mod_file_cache.c
+++ b/modules/cache/mod_file_cache.c
@@ -209,12 +209,12 @@ static void cache_the_file(cmd_parms *cmd, const char *filename, int mmap)
 	return;
     }
     if (tmp.finfo.filetype != APR_REG) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, 0, cmd->server,
+	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
 	    "mod_file_cache: %s isn't a regular file, skipping", fspec);
 	return;
     }
     if (tmp.finfo.size > AP_MAX_SENDFILE) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, 0, cmd->server,
+	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
 	    "mod_file_cache: %s is too large to cache, skipping", fspec);
 	return;
     }
@@ -288,7 +288,7 @@ static const char *cachefilehandle(cmd_parms *cmd, void *dummy, const char *file
     cache_the_file(cmd, filename, 0);
 #else
     /* Sendfile not supported by this OS */
-    ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
                  "mod_file_cache: unable to cache file: %s. Sendfile is not supported on this OS", filename);
 #endif
     return NULL;
@@ -299,7 +299,7 @@ static const char *cachefilemmap(cmd_parms *cmd, void *dummy, const char *filena
     cache_the_file(cmd, filename, 1);
 #else
     /* MMAP not supported by this OS */
-    ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
                  "mod_file_cache: unable to cache file: %s. MMAP is not supported by this OS", filename);
 #endif
     return NULL;
diff --git a/modules/dav/main/mod_dav.c b/modules/dav/main/mod_dav.c
index 5822c06..b93e4b8 100644
--- a/modules/dav/main/mod_dav.c
+++ b/modules/dav/main/mod_dav.c
@@ -214,13 +214,13 @@ static void *dav_merge_dir_config(apr_pool_t *p, void *base, void *overrides)
     newconf->provider = DAV_INHERIT_VALUE(parent, child, provider);
     if (parent->provider_name != NULL) {
         if (child->provider_name == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
                          "\"DAV Off\" cannot be used to turn off a subtree "
                          "of a DAV-enabled location.");
         }
         else if (strcasecmp(child->provider_name,
                             parent->provider_name) != 0) {
-            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
                          "A subtree cannot specify a different DAV provider "
                          "than its parent.");
         }
@@ -551,7 +551,7 @@ static void dav_log_err(request_rec *r, dav_error *err, int level)
                           errscan->desc, errscan->status, errscan->error_id);
         }
         else {
-            ap_log_rerror(APLOG_MARK, level | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, level, 0, r,
                           "%s  [%d, #%d]",
                           errscan->desc, errscan->status, errscan->error_id);
         }
@@ -655,7 +655,7 @@ int dav_get_depth(request_rec *r, int def_depth)
 
     /* The caller will return an HTTP_BAD_REQUEST. This will augment the
      * default message that Apache provides. */
-    ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                   "An invalid Depth header was specified.");
     return -1;
 }
@@ -678,7 +678,7 @@ static int dav_get_overwrite(request_rec *r)
 
     /* The caller will return an HTTP_BAD_REQUEST. This will augment the
      * default message that Apache provides. */
-    ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                   "An invalid Overwrite header was specified.");
     return -1;
 }
@@ -1106,14 +1106,14 @@ static int dav_method_delete(request_rec *r)
 
     if (resource->collection && depth != DAV_INFINITY) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Depth must be \"infinity\" for DELETE of a collection.");
         return HTTP_BAD_REQUEST;
     }
 
     if (!resource->collection && depth == 1) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Depth of \"1\" is not allowed for DELETE.");
         return HTTP_BAD_REQUEST;
     }
@@ -1528,7 +1528,7 @@ static int dav_method_options(request_rec *r)
     /* note: doc == NULL if no request body */
 
     if (doc && !dav_validate_root(doc, "options")) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The \"options\" element was not found.");
         return HTTP_BAD_REQUEST;
     }
@@ -1922,7 +1922,7 @@ static int dav_method_propfind(request_rec *r)
 
     if (doc && !dav_validate_root(doc, "propfind")) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The \"propfind\" element was not found.");
         return HTTP_BAD_REQUEST;
     }
@@ -1944,7 +1944,7 @@ static int dav_method_propfind(request_rec *r)
         /* "propfind" element must have one of the above three children */
 
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The \"propfind\" element does not contain one of "
                       "the required child elements (the specific command).");
         return HTTP_BAD_REQUEST;
@@ -2165,7 +2165,7 @@ static int dav_method_proppatch(request_rec *r)
 
     if (doc == NULL || !dav_validate_root(doc, "propertyupdate")) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The request body does not contain "
                       "a \"propertyupdate\" element.");
         return HTTP_BAD_REQUEST;
@@ -2228,7 +2228,7 @@ static int dav_method_proppatch(request_rec *r)
             dav_auto_checkin(r, resource, 1 /*undo*/, 0 /*unlock*/, &av_info);
 
             /* This supplies additional information for the default message. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "A \"prop\" element is missing inside "
                           "the propertyupdate command.");
             return HTTP_BAD_REQUEST;
@@ -2307,7 +2307,7 @@ static int process_mkcol_body(request_rec *r)
     if (tenc) {
         if (strcasecmp(tenc, "chunked")) {
             /* Use this instead of Apache's default error string */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Unknown Transfer-Encoding %s", tenc);
             return HTTP_NOT_IMPLEMENTED;
         }
@@ -2323,7 +2323,7 @@ static int process_mkcol_body(request_rec *r)
 
         if (*pos != '\0') {
             /* This supplies additional information for the default message. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Invalid Content-Length %s", lenp);
             return HTTP_BAD_REQUEST;
         }
@@ -2519,7 +2519,7 @@ static int dav_method_copymove(request_rec *r, int is_move)
     }
     if (dest == NULL) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The request is missing a Destination header.");
         return HTTP_BAD_REQUEST;
     }
@@ -2528,7 +2528,7 @@ static int dav_method_copymove(request_rec *r, int is_move)
     if (lookup.rnew == NULL) {
         if (lookup.err.status == HTTP_BAD_REQUEST) {
             /* This supplies additional information for the default message. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           lookup.err.desc);
             return HTTP_BAD_REQUEST;
         }
@@ -2593,13 +2593,13 @@ static int dav_method_copymove(request_rec *r, int is_move)
     }
     if (depth == 1) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Depth must be \"0\" or \"infinity\" for COPY or MOVE.");
         return HTTP_BAD_REQUEST;
     }
     if (is_move && is_dir && depth != DAV_INFINITY) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Depth must be \"infinity\" when moving a collection.");
         return HTTP_BAD_REQUEST;
     }
@@ -2887,7 +2887,7 @@ static int dav_method_lock(request_rec *r)
 
     depth = dav_get_depth(r, DAV_INFINITY);
     if (depth != 0 && depth != DAV_INFINITY) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Depth must be 0 or \"infinity\" for LOCK.");
         return HTTP_BAD_REQUEST;
     }
@@ -3046,7 +3046,7 @@ static int dav_method_unlock(request_rec *r)
 
     if ((const_locktoken_txt = apr_table_get(r->headers_in,
                                              "Lock-Token")) == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Unlock failed (%s):  "
                       "No Lock-Token specified in header", r->filename);
         return HTTP_BAD_REQUEST;
@@ -3156,7 +3156,7 @@ static int dav_method_vsn_control(request_rec *r)
         apr_size_t tsize;
 
         if (!dav_validate_root(doc, "version-control")) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "The request body does not contain "
                           "a \"version-control\" element.");
             return HTTP_BAD_REQUEST;
@@ -3164,14 +3164,14 @@ static int dav_method_vsn_control(request_rec *r)
 
         /* get the version URI */
         if ((child = dav_find_child(doc->root, "version")) == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "The \"version-control\" element does not contain "
                           "a \"version\" element.");
             return HTTP_BAD_REQUEST;
         }
 
         if ((child = dav_find_child(child, "href")) == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "The \"version\" element does not contain "
                           "an \"href\" element.");
             return HTTP_BAD_REQUEST;
@@ -3181,7 +3181,7 @@ static int dav_method_vsn_control(request_rec *r)
         ap_xml_to_text(r->pool, child, AP_XML_X2T_INNER, NULL, NULL,
                        &target, &tsize);
         if (tsize == 0) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "An \"href\" element does not contain a URI.");
             return HTTP_BAD_REQUEST;
         }
@@ -3333,7 +3333,7 @@ static int dav_method_checkout(request_rec *r)
 
         if (!dav_validate_root(doc, "checkout")) {
             /* This supplies additional information for the default msg. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "The request body, if present, must be a "
                           "DAV:checkout element.");
             return HTTP_BAD_REQUEST;
@@ -3380,7 +3380,7 @@ static int dav_method_checkout(request_rec *r)
                     */
 
                     /* This supplies additional info for the default msg. */
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                   "Within the DAV:activity-set element, the "
                                   "DAV:new element must be used, or at least "
                                   "one DAV:href must be specified.");
@@ -3533,7 +3533,7 @@ static int dav_method_checkin(request_rec *r)
     if (doc != NULL) {
         if (!dav_validate_root(doc, "checkin")) {
             /* This supplies additional information for the default msg. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "The request body, if present, must be a "
                           "DAV:checkin element.");
             return HTTP_BAD_REQUEST;
@@ -3621,7 +3621,7 @@ static int dav_method_update(request_rec *r)
 
     if (doc == NULL || !dav_validate_root(doc, "update")) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The request body does not contain "
                       "an \"update\" element.");
         return HTTP_BAD_REQUEST;
@@ -3633,14 +3633,14 @@ static int dav_method_update(request_rec *r)
     else if ((child = dav_find_child(doc->root, "version")) != NULL) {
         /* get the href element */
         if ((child = dav_find_child(child, "href")) == NULL) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "The version element does not contain "
                           "an \"href\" element.");
             return HTTP_BAD_REQUEST;
         }
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The \"update\" element does not contain "
                       "a \"label-name\" or \"version\" element.");
         return HTTP_BAD_REQUEST;
@@ -3648,7 +3648,7 @@ static int dav_method_update(request_rec *r)
 
     /* a depth greater than zero is only allowed for a label */
     if (!is_label && depth != 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Depth must be zero for UPDATE with a version");
         return HTTP_BAD_REQUEST;
     }
@@ -3657,7 +3657,7 @@ static int dav_method_update(request_rec *r)
     ap_xml_to_text(r->pool, child, AP_XML_X2T_INNER, NULL, NULL,
                    &target, &tsize);
     if (tsize == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "A \"label-name\" or \"href\" element does not contain "
                       "any content.");
         return HTTP_BAD_REQUEST;
@@ -3690,7 +3690,7 @@ static int dav_method_update(request_rec *r)
         if (lookup.rnew == NULL) {
             if (lookup.err.status == HTTP_BAD_REQUEST) {
                 /* This supplies additional information for the default message. */
-                ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               lookup.err.desc);
                 return HTTP_BAD_REQUEST;
             }
@@ -3837,7 +3837,7 @@ static int dav_method_label(request_rec *r)
 
     if (doc == NULL || !dav_validate_root(doc, "label")) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The request body does not contain "
                       "a \"label\" element.");
         return HTTP_BAD_REQUEST;
@@ -3854,7 +3854,7 @@ static int dav_method_label(request_rec *r)
         ctx.label_op = DAV_LABEL_REMOVE;
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The \"label\" element does not contain "
                       "an \"add\", \"set\", or \"remove\" element.");
         return HTTP_BAD_REQUEST;
@@ -3862,7 +3862,7 @@ static int dav_method_label(request_rec *r)
 
     /* get the label string */
     if ((child = dav_find_child(child, "label-name")) == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The label command element does not contain "
                       "a \"label-name\" element.");
         return HTTP_BAD_REQUEST;
@@ -3871,7 +3871,7 @@ static int dav_method_label(request_rec *r)
     ap_xml_to_text(r->pool, child, AP_XML_X2T_INNER, NULL, NULL,
                    &ctx.label, &tsize);
     if (tsize == 0) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "A \"label-name\" element does not contain "
                       "a label name.");
         return HTTP_BAD_REQUEST;
@@ -3938,7 +3938,7 @@ static int dav_method_report(request_rec *r)
         return result;
     if (doc == NULL) {
         /* This supplies additional information for the default msg. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The request body must specify a report.");
         return HTTP_BAD_REQUEST;
     }
@@ -4000,7 +4000,7 @@ static int dav_method_make_workspace(request_rec *r)
 
     if (doc == NULL
         || !dav_validate_root(doc, "mkworkspace")) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The request body does not contain "
                       "a \"mkworkspace\" element.");
         return HTTP_BAD_REQUEST;
@@ -4125,7 +4125,7 @@ static int dav_method_merge(request_rec *r)
 
     if (doc == NULL || !dav_validate_root(doc, "merge")) {
         /* This supplies additional information for the default msg. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The request body must be present and must be a "
                       "DAV:merge element.");
         return HTTP_BAD_REQUEST;
@@ -4133,14 +4133,14 @@ static int dav_method_merge(request_rec *r)
 
     if ((source_elem = dav_find_child(doc->root, "source")) == NULL) {
         /* This supplies additional information for the default msg. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The DAV:merge element must contain a DAV:source "
                       "element.");
         return HTTP_BAD_REQUEST;
     }
     if ((href_elem = dav_find_child(source_elem, "href")) == NULL) {
         /* This supplies additional information for the default msg. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The DAV:source element must contain a DAV:href "
                       "element.");
         return HTTP_BAD_REQUEST;
@@ -4153,7 +4153,7 @@ static int dav_method_merge(request_rec *r)
     if (lookup.rnew == NULL) {
         if (lookup.err.status == HTTP_BAD_REQUEST) {
             /* This supplies additional information for the default message. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           lookup.err.desc);
             return HTTP_BAD_REQUEST;
         }
@@ -4266,7 +4266,7 @@ static int dav_method_bind(request_rec *r)
     dest = apr_table_get(r->headers_in, "Destination");
     if (dest == NULL) {
         /* This supplies additional information for the default message. */
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "The request is missing a Destination header.");
         return HTTP_BAD_REQUEST;
     }
@@ -4275,7 +4275,7 @@ static int dav_method_bind(request_rec *r)
     if (lookup.rnew == NULL) {
         if (lookup.err.status == HTTP_BAD_REQUEST) {
             /* This supplies additional information for the default message. */
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           lookup.err.desc);
             return HTTP_BAD_REQUEST;
         }
diff --git a/modules/dav/main/util_lock.c b/modules/dav/main/util_lock.c
index 052d39b..348248a 100644
--- a/modules/dav/main/util_lock.c
+++ b/modules/dav/main/util_lock.c
@@ -756,7 +756,7 @@ int dav_get_resource_state(request_rec *r, const dav_resource *resource)
         if (err != NULL) {
 	    /* ### don't log an error. return err. add higher-level desc. */
 
-	    ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		          "Failed to query lock-null status for %s",
 			  r->filename);
 
diff --git a/modules/experimental/mod_cache.c b/modules/experimental/mod_cache.c
index d10884b..097de3b 100644
--- a/modules/experimental/mod_cache.c
+++ b/modules/experimental/mod_cache.c
@@ -106,12 +106,12 @@ static int cache_url_handler(request_rec *r, int lookup)
     if (!(types = ap_cache_get_cachetype(r, conf, path))) {
         return DECLINED;
     }
-    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "cache: URL %s is being handled by %s", path, types);
 
     urllen = strlen(url);
     if (urllen > MAX_URL_LENGTH) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                      "cache: URL exceeds length threshold: %s", url);
         return DECLINED;
     }
@@ -156,7 +156,7 @@ static int cache_url_handler(request_rec *r, int lookup)
      * - TODO: Make MAX_URL_LENGTH a config directive?
      */
     if (conf->ignorecachecontrol_set == 1 && conf->ignorecachecontrol == 1 && auth == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
             "incoming request is asking for a uncached version of %s, but we know better and are ignoring it", url);
     }
     else {
@@ -165,7 +165,7 @@ static int cache_url_handler(request_rec *r, int lookup)
             /* delete the previously cached file */
             cache_remove_url(r, cache->types, url);
 
-            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                         "cache: no-store forbids caching of %s", url);
             return DECLINED;
         }
@@ -191,7 +191,7 @@ static int cache_url_handler(request_rec *r, int lookup)
     if (DECLINED == rv) {
         if (!lookup) {
             /* no existing cache file */
-            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                          "cache: no cache - add cache_in filter and DECLINE");
             /* add cache_in filter to cache this request */
             ap_add_output_filter("CACHE_IN", NULL, r, r->connection);
@@ -208,7 +208,7 @@ static int cache_url_handler(request_rec *r, int lookup)
             if (lookup) {
                 return OK;
             }
-            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                          "cache: fresh cache - add cache_out filter and "
                          "handle request");
 
@@ -244,11 +244,11 @@ static int cache_url_handler(request_rec *r, int lookup)
                 return DECLINED;
             }
 
-            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                          "cache: stale cache - test conditional");
             /* if conditional request */
             if (ap_cache_request_is_conditional(r)) {
-                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, 
                              r->server,
                              "cache: conditional - add cache_in filter and "
                              "DECLINE");
@@ -261,7 +261,7 @@ static int cache_url_handler(request_rec *r, int lookup)
             else {
                 /* fudge response into a conditional */
                 if (info && info->etag) {
-                    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
+                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, 
                                  r->server,
                                  "cache: nonconditional - fudge conditional "
                                  "by etag");
@@ -269,7 +269,7 @@ static int cache_url_handler(request_rec *r, int lookup)
                     apr_table_set(r->headers_in, "If-None-Match", info->etag);
                 }
                 else if (info && info->lastmods) {
-                    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
+                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, 
                                  r->server,
                                  "cache: nonconditional - fudge conditional "
                                  "by lastmod");
@@ -280,7 +280,7 @@ static int cache_url_handler(request_rec *r, int lookup)
                 }
                 else {
                     /* something else - pretend there was no cache */
-                    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
+                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, 
                                  r->server,
                                  "cache: nonconditional - no cached "
                                  "etag/lastmods - add cache_in and DECLINE");
@@ -290,7 +290,7 @@ static int cache_url_handler(request_rec *r, int lookup)
                     return DECLINED;
                 }
                 /* add cache_conditional filter */
-                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, 
                              r->server,
                              "cache: nonconditional - add cache_conditional and"
                              " DECLINE");
@@ -368,7 +368,7 @@ static int cache_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
 
 static int cache_conditional_filter(ap_filter_t *f, apr_bucket_brigade *in)
 {
-    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, f->r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, f->r->server,
                  "cache: running CACHE_CONDITIONAL filter");
 
     if (f->r->status == HTTP_NOT_MODIFIED) {
@@ -416,7 +416,7 @@ static int cache_in_filter(ap_filter_t *f, apr_bucket_brigade *in)
     (cache_request_rec *) ap_get_module_config(scache, &cache_module);
 
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, f->r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, f->r->server,
                  "cache: running CACHE_IN filter");
 
     /* check first whether running this filter has any point or not */
@@ -551,7 +551,7 @@ static int cache_in_filter(ap_filter_t *f, apr_bucket_brigade *in)
     /* or we've been asked not to cache it above */
         r->no_cache) {
 
-        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "cache: response is not cachable");
 
         /* remove this object from the cache 
@@ -647,7 +647,7 @@ static int cache_in_filter(ap_filter_t *f, apr_bucket_brigade *in)
         return ap_pass_brigade(f->next, in);
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "cache: Caching url: %s", url);
 
     /*
@@ -678,7 +678,7 @@ static int cache_in_filter(ap_filter_t *f, apr_bucket_brigade *in)
         dates = apr_pcalloc(r->pool, MAX_STRING_LEN);
         apr_rfc822_date(dates, now);
         ap_table_set(r->headers_out, "Date", dates);
-        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                      "cache: Added date header");
         info->date = date;
     }
@@ -699,7 +699,7 @@ static int cache_in_filter(ap_filter_t *f, apr_bucket_brigade *in)
         /* if its in the future, then replace by date */
         lastmod = date;
         lastmods = dates;
-        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, 
                      r->server,
                      "cache: Last modified is in the future, "
                      "replacing with now");
diff --git a/modules/experimental/mod_charset_lite.c b/modules/experimental/mod_charset_lite.c
index a01e5d3..2b1fc9f 100644
--- a/modules/experimental/mod_charset_lite.c
+++ b/modules/experimental/mod_charset_lite.c
@@ -244,7 +244,7 @@ static int find_code_page(request_rec *r)
     const char *mime_type;
 
     if (dc->debug >= DBGLVL_FLOW) {
-        ap_log_rerror(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK,APLOG_DEBUG, 0, r,
                       "uri: %s file: %s method: %d "
                       "imt: %s flags: %s%s%s %s->%s",
                       r->uri, r->filename, r->method_number,
@@ -259,7 +259,7 @@ static int find_code_page(request_rec *r)
      */
     if (!dc->charset_source || !dc->charset_default) {
         if (dc->debug >= DBGLVL_PMC) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                           "incomplete configuration: src %s, dst %s",
                           dc->charset_source ? dc->charset_source : "unspecified",
                           dc->charset_default ? dc->charset_default : "unspecified");
@@ -303,7 +303,7 @@ static int find_code_page(request_rec *r)
 #endif
         strncasecmp(mime_type, "message/", 8)) {
         if (dc->debug >= DBGLVL_GORY) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                           "mime type is %s; no translation selected",
                           mime_type);
         }
@@ -311,7 +311,7 @@ static int find_code_page(request_rec *r)
     }
 
     if (dc->debug >= DBGLVL_GORY) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                       "charset_source: %s charset_default: %s",
                       dc && dc->charset_source ? dc->charset_source : "(none)",
                       dc && dc->charset_default ? dc->charset_default : "(none)");
@@ -406,7 +406,7 @@ static void xlate_insert_filter(request_rec *r)
                                  r->connection);
         }
         else if (dc->debug >= DBGLVL_FLOW) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                           "xlate output filter not added implicitly because %s",
                           !reqinfo->output_ctx ? 
                           "no output configuration available" :
@@ -418,7 +418,7 @@ static void xlate_insert_filter(request_rec *r)
                                 r->connection);
         }
         else if (dc->debug >= DBGLVL_FLOW) {
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                           "xlate input filter not added implicitly because %s",
                           !reqinfo->input_ctx ?
                           "no input configuration available" :
@@ -548,22 +548,22 @@ static void log_xlate_error(ap_filter_t *f, apr_status_t rv)
     const char *msg;
     char msgbuf[100];
     int cur;
-    int flags = APLOG_ERR;
 
     switch(ctx->ees) {
     case EES_LIMIT:
-        flags |= APLOG_NOERRNO;
+        rv = 0;
         msg = "xlate filter - a built-in restriction was encountered";
         break;
     case EES_BAD_INPUT:
-        flags |= APLOG_NOERRNO;
+        rv = 0;
         msg = "xlate filter - an input character was invalid";
         break;
     case EES_BUCKET_READ:
+        rv = 0;
         msg = "xlate filter - bucket read routine failed";
         break;
     case EES_INCOMPLETE_CHAR:
-        flags |= APLOG_NOERRNO;
+        rv = 0;
         strcpy(msgbuf, "xlate filter - incomplete char at end of input - ");
         cur = 0;
         while (cur < ctx->saved) {
@@ -579,7 +579,7 @@ static void log_xlate_error(ap_filter_t *f, apr_status_t rv)
     default:
         msg = "xlate filter - returning error";
     }
-    ap_log_rerror(APLOG_MARK, flags, rv, f->r,
+    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
                   "%s", msg);
 }
 
@@ -655,7 +655,7 @@ static void chk_filter_chain(ap_filter_t *f)
                         if (debug >= DBGLVL_PMC) {
                             const char *symbol = output ? "->" : "<-";
 
-                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO,
+                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG,
                                           0, f->r,
                                           "%s %s - disabling "
                                           "translation %s%s%s; existing "
@@ -673,7 +673,7 @@ static void chk_filter_chain(ap_filter_t *f)
                     else {
                         const char *symbol = output ? "->" : "<-";
 
-                        ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR,
                                       0, f->r,
                                       "chk_filter_chain() - can't disable "
                                       "translation %s%s%s; existing "
@@ -859,7 +859,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     }
 
     if (dc->debug >= DBGLVL_GORY) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,
                      "xlate_out_filter() - "
                      "charset_source: %s charset_default: %s",
                      dc && dc->charset_source ? dc->charset_source : "(none)",
@@ -1017,7 +1017,7 @@ static int xlate_in_filter(ap_filter_t *f, apr_bucket_brigade *bb,
     }
 
     if (dc->debug >= DBGLVL_GORY) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,
                      "xlate_in_filter() - "
                      "charset_source: %s charset_default: %s",
                      dc && dc->charset_source ? dc->charset_source : "(none)",
diff --git a/modules/experimental/mod_disk_cache.c b/modules/experimental/mod_disk_cache.c
index e503473..650978a 100644
--- a/modules/experimental/mod_disk_cache.c
+++ b/modules/experimental/mod_disk_cache.c
@@ -348,7 +348,7 @@ static int create_entity(cache_handle_t *h, request_rec *r,
     h->write_headers = &write_headers;
     h->remove_entity = &remove_entity;
 
-    ap_log_error(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                  "disk_cache: Caching URL %s",  key);
 
     return OK;
@@ -422,7 +422,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *type, cons
     h->write_headers = &write_headers;
     h->remove_entity = &remove_entity;
 
-    ap_log_error(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                  "disk_cache: Serving Cached URL %s",  dobj->name);
     return OK;
 }
@@ -495,7 +495,7 @@ static apr_status_t read_headers(cache_handle_t *h, request_rec *r)
 
     apr_file_close(dobj->hfd);
 
-    ap_log_error(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                  "disk_cache: Served headers for URL %s",  dobj->name);
     return APR_SUCCESS;
 }
@@ -598,7 +598,7 @@ static apr_status_t write_headers(cache_handle_t *h, request_rec *r, cache_info
         /* XXX log message */
     }
 
-    ap_log_error(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, 0, r->server,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                  "disk_cache: Caching headers for URL %s",  dobj->name);
     return APR_SUCCESS;
 }
@@ -625,7 +625,7 @@ static apr_status_t write_body(cache_handle_t *h, request_rec *r, apr_bucket_bri
     }
     if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(b))) {
         file_cache_el_final(h, r);    /* Link to the perm file, and close the descriptor  */
-        ap_log_error(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, 0, r->server,
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                      "disk_cache: Cached body for URL %s",  dobj->name);
     }
 
diff --git a/modules/experimental/mod_ext_filter.c b/modules/experimental/mod_ext_filter.c
index f7132f0..e7ddee2 100644
--- a/modules/experimental/mod_ext_filter.c
+++ b/modules/experimental/mod_ext_filter.c
@@ -485,7 +485,7 @@ static apr_status_t init_filter_instance(ap_filter_t *f)
     /* look for the user-defined filter */
     ctx->filter = apr_hash_get(sc->h, f->frec->name, APR_HASH_KEY_STRING);
     if (!ctx->filter) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
                       "couldn't find definition of filter '%s'",
                       f->frec->name);
         return APR_EINVAL;
@@ -514,7 +514,7 @@ static apr_status_t init_filter_instance(ap_filter_t *f)
     }
 
     if (dc->debug >= DBGLVL_SHOWOPTIONS) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, f->r,
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,
                       "%sfiltering `%s' through `%s', cfg %s",
                       ctx->noop ? "skipping: " : "",
                       f->r->uri ? f->r->uri : f->r->filename,
@@ -619,7 +619,7 @@ static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data,
                  */
                 apr_sleep(100000); /* 100 milliseconds */
                 if (dc->debug >= DBGLVL_GORY) {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 
                                   0, f->r, "apr_sleep()");
                 }
 #endif /* APR_FILES_AS_SOCKETS */
diff --git a/modules/experimental/mod_mem_cache.c b/modules/experimental/mod_mem_cache.c
index 78dd376..1aec8ba 100644
--- a/modules/experimental/mod_mem_cache.c
+++ b/modules/experimental/mod_mem_cache.c
@@ -506,7 +506,7 @@ static int remove_entity(cache_handle_t *h)
         sconf->object_cnt--;
         sconf->cache_size -= mobj->m_len;
         obj->cleanup = 1;
-        ap_log_error(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, 0, NULL, "gcing a cache entry");
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL, "gcing a cache entry");
     }
 
     if (sconf->lock) {
diff --git a/modules/filters/mod_deflate.c b/modules/filters/mod_deflate.c
index 343f059..7acae7d 100644
--- a/modules/filters/mod_deflate.c
+++ b/modules/filters/mod_deflate.c
@@ -309,7 +309,7 @@ static apr_status_t deflate_out_filter(ap_filter_t *f,
 
         if (zRC != Z_OK) {
             f->ctx = NULL;
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "unable to init Zlib: "
                           "deflateInit2 returned %d: URL %s",
                           zRC, r->uri);
@@ -388,7 +388,7 @@ static apr_status_t deflate_out_filter(ap_filter_t *f,
 
             b = apr_bucket_pool_create(buf, 8, r->pool, f->c->bucket_alloc);
             APR_BRIGADE_INSERT_TAIL(ctx->bb, b);
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                           "Zlib: Compressed %ld to %ld : URL %s",
                           ctx->stream.total_in, ctx->stream.total_out, r->uri);
 
diff --git a/modules/filters/mod_include.c b/modules/filters/mod_include.c
index 7d29442..d8b993a 100644
--- a/modules/filters/mod_include.c
+++ b/modules/filters/mod_include.c
@@ -1075,7 +1075,7 @@ static char *ap_ssi_parse_string(request_rec *r, include_ctx_t *ctx,
                     start_of_var_name = in;
                     in = ap_strchr_c(in, '}');
                     if (in == NULL) {
-                        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR,
                                       0, r, "Missing '}' on variable \"%s\"",
                                       expansion);
                         *next = '\0';
@@ -1336,7 +1336,7 @@ static int handle_include(include_ctx_t *ctx, apr_bucket_brigade **bb,
                     error_fmt = "unable to include \"%s\" in parsed file %s";
                 }
                 if (error_fmt) {
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|loglevel,
+                    ap_log_rerror(APLOG_MARK, loglevel,
                                   0, r, error_fmt, tag_val, r->filename);
                     CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, 
                                         *inserted_head);
@@ -1348,7 +1348,7 @@ static int handle_include(include_ctx_t *ctx, apr_bucket_brigade **bb,
                 }
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "unknown parameter \"%s\" to tag include in %s",
                             tag, r->filename);
                 CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
@@ -1425,7 +1425,7 @@ static int handle_echo(include_ctx_t *ctx, apr_bucket_brigade **bb,
                 else if (!strcasecmp(tag_val, "url")) encode = E_URL;
                 else if (!strcasecmp(tag_val, "entity")) encode = E_ENTITY;
                 else {
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                            "unknown value \"%s\" to parameter \"encoding\" of "
                            "tag echo in %s", tag_val, r->filename);
                     CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, 
@@ -1433,7 +1433,7 @@ static int handle_echo(include_ctx_t *ctx, apr_bucket_brigade **bb,
                 }
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "unknown parameter \"%s\" in tag echo of %s",
                             tag, r->filename);
                 CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
@@ -1508,7 +1508,7 @@ static int handle_config(include_ctx_t *ctx, apr_bucket_brigade **bb,
             else {
                 apr_bucket *tmp_buck;
 
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "unknown parameter \"%s\" to tag config in %s",
                               tag, r->filename);
                 CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
@@ -1560,7 +1560,7 @@ static int find_file(request_rec *r, const char *directive, const char *tag,
 
         if (error_fmt) {
             ret = -1;
-            ap_log_rerror(APLOG_MARK, APLOG_ERR | (rv ? 0 : APLOG_NOERRNO),
+            ap_log_rerror(APLOG_MARK, APLOG_ERR,
                           rv, r, error_fmt, to_send, r->filename);
         }
 
@@ -1580,7 +1580,7 @@ static int find_file(request_rec *r, const char *directive, const char *tag,
             return 0;
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                         "unable to get information about \"%s\" "
                         "in parsed file %s",
                         tag_val, r->filename);
@@ -1589,7 +1589,7 @@ static int find_file(request_rec *r, const char *directive, const char *tag,
         }
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "unknown parameter \"%s\" to tag %s in %s",
                     tag, directive, r->filename);
         return -1;
@@ -1726,7 +1726,7 @@ static int re_check(request_rec *r, include_ctx_t *ctx,
 
     compiled = ap_pregcomp(r->pool, rexp, REG_EXTENDED | REG_NOSUB);
     if (compiled == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "unable to compile pattern \"%s\"", rexp);
         return -1;
     }
@@ -1981,7 +1981,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
                 current = current->right = new;
                 break;
             default:
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "Invalid expression \"%s\" in file %s",
                             expr, r->filename);
                 *was_error = 1;
@@ -2010,7 +2010,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
                 current = current->right = new;
                 break;
             default:
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "Invalid expression \"%s\" in file %s",
                             expr, r->filename);
                 *was_error = 1;
@@ -2026,7 +2026,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
             debug_pos += sizeof ("     Token: and/or\n");
 #endif
             if (current == (struct parse_node *) NULL) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "Invalid expression \"%s\" in file %s",
                             expr, r->filename);
                 *was_error = 1;
@@ -2052,7 +2052,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
                 case token_lbrace:
                     break;
                 default:
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                 "Invalid expression \"%s\" in file %s",
                                 expr, r->filename);
                     *was_error = 1;
@@ -2099,7 +2099,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
                 case token_lt:
                     break;
                 default:
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                   "Invalid expression \"%s\" in file %s",
                                   expr, r->filename);
                     *was_error = 1;
@@ -2133,7 +2133,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
             debug_pos += sizeof("     Token: eq/ne/ge/gt/le/lt\n");
 #endif
             if (current == (struct parse_node *) NULL) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "Invalid expression \"%s\" in file %s",
                               expr, r->filename);
                 *was_error = 1;
@@ -2159,7 +2159,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
                 case token_le:
                 case token_lt:
                 default:
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                 "Invalid expression \"%s\" in file %s",
                                 expr, r->filename);
                     *was_error = 1;
@@ -2195,7 +2195,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
                 current = current->parent;
             }
             if (current == (struct parse_node *) NULL) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "Unmatched ')' in \"%s\" in file %s",
                             expr, r->filename);
                 *was_error = 1;
@@ -2231,7 +2231,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
                 case token_re:
                 case token_group:
                 default:
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                 "Invalid expression \"%s\" in file %s",
                                 expr, r->filename);
                     *was_error = 1;
@@ -2276,7 +2276,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
             break;
 
         case token_re:
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "No operator before regex of expr \"%s\" in file %s",
                           expr, r->filename);
             *was_error = 1;
@@ -2291,7 +2291,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
 #endif
             if (current->left  == (struct parse_node *) NULL ||
                 current->right == (struct parse_node *) NULL) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "Invalid expression \"%s\" in file %s",
                               expr, r->filename);
                 *was_error = 1;
@@ -2359,7 +2359,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
                 (current->left->token.type != token_string) ||
                 ((current->right->token.type != token_string) &&
                  (current->right->token.type != token_re))) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "Invalid expression \"%s\" in file %s",
                             expr, r->filename);
                 *was_error = 1;
@@ -2416,7 +2416,7 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
                 (current->right == (struct parse_node *) NULL) ||
                 (current->left->token.type != token_string) ||
                 (current->right->token.type != token_string)) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "Invalid expression \"%s\" in file %s",
                             expr, r->filename);
                 *was_error = 1;
@@ -2499,21 +2499,21 @@ static int parse_expr(request_rec *r, include_ctx_t *ctx, const char *expr,
             break;
 
         case token_lbrace:
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                         "Unmatched '(' in \"%s\" in file %s",
                         expr, r->filename);
             *was_error = 1;
             return retval;
 
         case token_rbrace:
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                         "Unmatched ')' in \"%s\" in file %s",
                         expr, r->filename);
             *was_error = 1;
             return retval;
 
         default:
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "bad token type");
             *was_error = 1;
             return retval;
@@ -2586,7 +2586,7 @@ static int handle_if(include_ctx_t *ctx, apr_bucket_brigade **bb,
             ap_ssi_get_tag_and_value(ctx, &tag, &tag_val, 0);
             if (tag == NULL) {
                 if (expr == NULL) {
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                   "missing expr in if statement: %s", 
                                   r->filename);
                     CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, 
@@ -2635,7 +2635,7 @@ static int handle_if(include_ctx_t *ctx, apr_bucket_brigade **bb,
 #endif
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "unknown parameter \"%s\" to tag if in %s", tag, 
                             r->filename);
                 CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
@@ -2670,7 +2670,7 @@ static int handle_elif(include_ctx_t *ctx, apr_bucket_brigade **bb,
                     return (0);
                 }
                 if (expr == NULL) {
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                   "missing expr in elif statement: %s", 
                                   r->filename);
                     CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, 
@@ -2718,7 +2718,7 @@ static int handle_elif(include_ctx_t *ctx, apr_bucket_brigade **bb,
 #endif
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                "unknown parameter \"%s\" to tag if in %s", tag, 
                                r->filename);
                 CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
@@ -2740,7 +2740,7 @@ static int handle_else(include_ctx_t *ctx, apr_bucket_brigade **bb,
     if (!ctx->if_nesting_level) {
         ap_ssi_get_tag_and_value(ctx, &tag, &tag_val, 1);
         if ((tag != NULL) || (tag_val != NULL)) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                         "else directive does not take tags in %s", r->filename);
             if (ctx->flags & FLAG_PRINTING) {
                 CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
@@ -2774,7 +2774,7 @@ static int handle_endif(include_ctx_t *ctx, apr_bucket_brigade **bb,
     if (!ctx->if_nesting_level) {
         ap_ssi_get_tag_and_value(ctx, &tag, &tag_val, 1);
         if ((tag != NULL) || (tag_val != NULL)) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                        "endif directive does not take tags in %s", r->filename);
             CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
             return -1;
@@ -2827,7 +2827,7 @@ static int handle_set(include_ctx_t *ctx, apr_bucket_brigade **bb,
             }
             else if (!strcmp(tag, "value")) {
                 if (var == (char *) NULL) {
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                            "variable must precede value in set directive in %s",
                            r->filename);
                     CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, 
@@ -2840,7 +2840,7 @@ static int handle_set(include_ctx_t *ctx, apr_bucket_brigade **bb,
                                apr_pstrdup(p, parsed_string));
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "Invalid tag for set directive in %s", r->filename);
                 CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
                 return -1;
@@ -2899,7 +2899,7 @@ static int handle_printenv(include_ctx_t *ctx, apr_bucket_brigade **bb,
             return 0;
         }
         else {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                         "printenv directive does not take tags in %s", 
                         r->filename);
             CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
@@ -3065,7 +3065,7 @@ static apr_status_t send_parsed_content(apr_bucket_brigade **bb,
              */
             if (get_combined_directive(ctx, r, *bb, tmp_buf,
                                         TMP_BUF_SIZE) != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "mod_include: error copying directive in %s",
                             r->filename);
                 CREATE_ERROR_BUCKET(ctx, tmp_bkt, dptr, content_head);
@@ -3115,7 +3115,7 @@ static apr_status_t send_parsed_content(apr_bucket_brigade **bb,
                 }
             }
             else {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "unknown directive \"%s\" in parsed doc %s",
                               ctx->combined_tag, r->filename);
                 CREATE_ERROR_BUCKET(ctx, tmp_bkt, dptr, content_head);
@@ -3220,7 +3220,7 @@ static apr_status_t send_parsed_content(apr_bucket_brigade **bb,
     }
     else if (ctx->state == PARSED) {         /* Invalid internal condition... */
         apr_bucket *content_head = NULL, *tmp_bkt;
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Invalid mod_include state during file %s", r->filename);
         CREATE_ERROR_BUCKET(ctx, tmp_bkt, APR_BRIGADE_FIRST(*bb), content_head);
     }
diff --git a/modules/generators/mod_asis.c b/modules/generators/mod_asis.c
index acad669..92651cf 100644
--- a/modules/generators/mod_asis.c
+++ b/modules/generators/mod_asis.c
@@ -84,7 +84,7 @@ static int asis_handler(request_rec *r)
     if (r->method_number != M_GET)
 	return DECLINED;
     if (r->finfo.filetype == 0) {
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		    "File does not exist: %s", r->filename);
 	return HTTP_NOT_FOUND;
     }
diff --git a/modules/generators/mod_autoindex.c b/modules/generators/mod_autoindex.c
index 455b3b3..494d36d 100644
--- a/modules/generators/mod_autoindex.c
+++ b/modules/generators/mod_autoindex.c
@@ -2144,7 +2144,7 @@ static int handle_autoindex(request_rec *r)
         return index_directory(r, d);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Directory index forbidden by rule: %s", r->filename);
         return HTTP_FORBIDDEN;
     }
diff --git a/modules/generators/mod_cgi.c b/modules/generators/mod_cgi.c
index 70cdf96..716efbc 100644
--- a/modules/generators/mod_cgi.c
+++ b/modules/generators/mod_cgi.c
@@ -216,7 +216,7 @@ static int log_scripterror(request_rec *r, cgi_server_conf * conf, int ret,
     apr_file_t *f = NULL;
     apr_finfo_t finfo;
     char time_str[APR_CTIME_LEN];
-    int log_flags = rv ? APLOG_ERR : APLOG_NOERRNO | APLOG_ERR;
+    int log_flags = rv ? APLOG_ERR : APLOG_ERR;
 
     ap_log_rerror(APLOG_MARK, log_flags, rv, r, 
                   "%s: %s", error, r->filename);
@@ -258,7 +258,7 @@ static void log_script_err(request_rec *r, apr_file_t *script_err)
         if (newline) {
             *newline = '\0';
         }
-        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r, 
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, 
                       "%s", argsbuffer);            
     }
 }
@@ -946,7 +946,7 @@ static int handle_exec(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec
     *inserted_head = NULL;
     if (ctx->flags & FLAG_PRINTING) {
         if (ctx->flags & FLAG_NO_EXEC) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "exec used but not allowed in %s", r->filename);
             CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
         }
@@ -964,7 +964,7 @@ static int handle_exec(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec
                 if (!strcmp(tag, "cmd")) {
                     cgi_pfn_ps(r, ctx, tag_val, parsed_string, sizeof(parsed_string), 1);
                     if (include_cmd(ctx, bb, parsed_string, r, f) == -1) {
-                        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                     "execution failure for parameter \"%s\" "
                                     "to tag exec in file %s", tag, r->filename);
                         CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
@@ -980,13 +980,13 @@ static int handle_exec(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec
                     }
 
                     if (include_cgi(parsed_string, r, f->next, head_ptr, inserted_head) == -1) {
-                        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                     "invalid CGI ref \"%s\" in %s", tag_val, file);
                         CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
                     }
                 }
                 else {
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                 "unknown parameter \"%s\" to tag exec in %s", tag, file);
                     CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
                 }
diff --git a/modules/generators/mod_cgid.c b/modules/generators/mod_cgid.c
index 82b26b4..b5107ed 100644
--- a/modules/generators/mod_cgid.c
+++ b/modules/generators/mod_cgid.c
@@ -584,7 +584,7 @@ static int cgid_server(void *data)
         r->pool = ptrans; 
         rc = get_req(sd2, r, &argv0, &env, &req_type); 
         if (rc) {
-            ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                          main_server,
                          "Error reading request on cgid socket");
             close(sd2);
@@ -796,7 +796,7 @@ static int log_scripterror(request_rec *r, cgid_server_conf * conf, int ret,
     apr_file_t *f = NULL; 
     struct stat finfo; 
     char time_str[APR_CTIME_LEN];
-    int log_flags = rv ? APLOG_ERR : APLOG_NOERRNO | APLOG_ERR;
+    int log_flags = rv ? APLOG_ERR : APLOG_ERR;
 
     ap_log_rerror(APLOG_MARK, log_flags, rv, r, 
                 "%s: %s", error, r->filename); 
@@ -1444,7 +1444,7 @@ static int handle_exec(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec
     *inserted_head = NULL;
     if (ctx->flags & FLAG_PRINTING) {
         if (ctx->flags & FLAG_NO_EXEC) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "exec used but not allowed in %s", r->filename);
             CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
         }
@@ -1462,7 +1462,7 @@ static int handle_exec(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec
                 if (!strcmp(tag, "cmd")) {
                     cgid_pfn_ps(r, ctx, tag_val, parsed_string, sizeof(parsed_string), 1);
                     if (include_cmd(ctx, bb, parsed_string, r, f) == -1) {
-                        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                     "execution failure for parameter \"%s\" "
                                     "to tag exec in file %s", tag, r->filename);
                         CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
@@ -1479,13 +1479,13 @@ static int handle_exec(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec
                     }
 
                     if (include_cgi(parsed_string, r, f->next, head_ptr, inserted_head) == -1) {
-                        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                     "invalid CGI ref \"%s\" in %s", tag_val, file);
                         CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
                     }
                 }
                 else {
-                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                 "unknown parameter \"%s\" to tag exec in %s", tag, file);
                     CREATE_ERROR_BUCKET(ctx, tmp_buck, head_ptr, *inserted_head);
                 }
diff --git a/modules/generators/mod_status.c b/modules/generators/mod_status.c
index d0f0818..7c258e7 100644
--- a/modules/generators/mod_status.c
+++ b/modules/generators/mod_status.c
@@ -286,7 +286,7 @@ static int status_handler(request_rec *r)
     tu = ts = tcu = tcs = 0;
 
     if (!ap_exists_scoreboard_image()) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Server status unavailable in inetd mode");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
diff --git a/modules/generators/mod_suexec.c b/modules/generators/mod_suexec.c
index 7057773..0191955 100644
--- a/modules/generators/mod_suexec.c
+++ b/modules/generators/mod_suexec.c
@@ -138,7 +138,7 @@ static int suexec_post_config(apr_pool_t *p, apr_pool_t *plog,
                           s->process->pool);
 
     if ((reported == NULL) && unixd_config.suexec_enabled) {
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s,
                      "suEXEC mechanism enabled (wrapper: %s)", SUEXEC_BIN);
 
         apr_pool_userdata_setn((void *)1, SUEXEC_POST_CONFIG_USERDATA,
diff --git a/modules/http/http_protocol.c b/modules/http/http_protocol.c
index d8799fd..a41dca5 100644
--- a/modules/http/http_protocol.c
+++ b/modules/http/http_protocol.c
@@ -494,7 +494,7 @@ AP_DECLARE(int) ap_method_register(apr_pool_t *p, const char *methname)
         /* The method registry  has run out of dynamically
          * assignable method numbers. Log this and return M_INVALID.
          */
-        ap_log_perror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, p,
+        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, p,
                       "Maximum new request methods %d reached while "
                       "registering method %s.",
                       METHOD_NUMBER_LAST, methname);
@@ -806,7 +806,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
              * time, stop it here if it is invalid. 
              */ 
             if (ctx->limit && ctx->limit < ctx->remaining) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, f->r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
                           "Requested content-length of %" APR_OFF_T_FMT 
                           " is larger than the configured limit"
                           " of %" APR_OFF_T_FMT, ctx->remaining, ctx->limit);
@@ -935,7 +935,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
          * really count.  This seems to be up for interpretation.  */
         ctx->limit_used += totalread;
         if (ctx->limit < ctx->limit_used) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, f->r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
                           "Read content-length of %" APR_OFF_T_FMT 
                           " is larger than the configured limit"
                           " of %" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);
@@ -1593,12 +1593,12 @@ AP_DECLARE(int) ap_setup_client_block(request_rec *r, int read_policy)
 
     if (tenc) {
         if (strcasecmp(tenc, "chunked")) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Unknown Transfer-Encoding %s", tenc);
             return HTTP_NOT_IMPLEMENTED;
         }
         if (r->read_body == REQUEST_CHUNKED_ERROR) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "chunked Transfer-Encoding forbidden: %s", r->uri);
             return (lenp) ? HTTP_BAD_REQUEST : HTTP_LENGTH_REQUIRED;
         }
@@ -1612,7 +1612,7 @@ AP_DECLARE(int) ap_setup_client_block(request_rec *r, int read_policy)
             ++pos;
         }
         if (*pos != '\0') {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Invalid Content-Length %s", lenp);
             return HTTP_BAD_REQUEST;
         }
@@ -1622,7 +1622,7 @@ AP_DECLARE(int) ap_setup_client_block(request_rec *r, int read_policy)
 
     if ((r->read_body == REQUEST_NO_BODY)
         && (r->read_chunked || (r->remaining > 0))) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "%s with body is not allowed for %s", r->method, r->uri);
         return HTTP_REQUEST_ENTITY_TOO_LARGE;
     }
diff --git a/modules/http/http_request.c b/modules/http/http_request.c
index a73d9bd..d848916 100644
--- a/modules/http/http_request.c
+++ b/modules/http/http_request.c
@@ -197,7 +197,7 @@ AP_DECLARE(void) ap_die(int type, request_rec *r)
              * dying with a recursive server error...
              */
             recursive_error = HTTP_INTERNAL_SERVER_ERROR;
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                         "Invalid error redirection directive: %s",
                         custom_response);
         }
diff --git a/modules/metadata/mod_cern_meta.c b/modules/metadata/mod_cern_meta.c
index 3402308..27376b6 100644
--- a/modules/metadata/mod_cern_meta.c
+++ b/modules/metadata/mod_cern_meta.c
@@ -274,7 +274,7 @@ static int scan_meta_file(request_rec *r, apr_file_t *f)
 	/* if we see a bogus header don't ignore it. Shout and scream */
 
 	if (!(l = strchr(w, ':'))) {
- 	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+ 	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 			"malformed header in meta file: %s", r->filename);
 	    return HTTP_INTERNAL_SERVER_ERROR;
 	}
@@ -350,7 +350,7 @@ static int add_cern_meta_data(request_rec *r)
     }
     else {
 	/* no last slash, buh?! */
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		    "internal error in mod_cern_meta: %s", r->filename);
 	/* should really barf, but hey, let's be friends... */
 	return DECLINED;
diff --git a/modules/metadata/mod_env.c b/modules/metadata/mod_env.c
index c7e587c..94166d3 100644
--- a/modules/metadata/mod_env.c
+++ b/modules/metadata/mod_env.c
@@ -139,7 +139,7 @@ static const char *add_env_module_vars_passed(cmd_parms *cmd, void *sconf_,
         apr_table_setn(vars, arg, apr_pstrdup(cmd->pool, env_var));
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
                      "PassEnv variable %s was undefined", arg);
     }
 
diff --git a/modules/metadata/mod_expires.c b/modules/metadata/mod_expires.c
index 757e498..7de3efc 100644
--- a/modules/metadata/mod_expires.c
+++ b/modules/metadata/mod_expires.c
@@ -433,7 +433,7 @@ static int add_expires(request_rec *r)
 
     conf = (expires_dir_config *) ap_get_module_config(r->per_dir_config, &expires_module);
     if (conf == NULL) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "internal error: %s", r->filename);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -490,7 +490,7 @@ static int add_expires(request_rec *r)
         /* expecting the add_* routines to be case-hardened this 
          * is just a reminder that module is beta
          */
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "internal error: bad expires code: %s", r->filename);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index 06ac3db..dee922a 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -560,7 +560,7 @@ static apr_status_t ap_headers_output_filter(ap_filter_t *f,
     headers_conf *dirconf = ap_get_module_config(f->r->per_dir_config,
                                                  &headers_module);
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, f->r->server,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, f->r->server,
 		 "headers: ap_headers_output_filter()");
 
     /* do the fixup */
diff --git a/modules/metadata/mod_mime_magic.c b/modules/metadata/mod_mime_magic.c
index 10a692a..12346ec 100644
--- a/modules/metadata/mod_mime_magic.c
+++ b/modules/metadata/mod_mime_magic.c
@@ -590,7 +590,7 @@ static int magic_rsl_add(request_rec *r, char *str)
 
     /* make sure we have a list to put it in */
     if (!req_dat) {
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, APR_EINVAL, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EINVAL, r,
 		    MODNAME ": request config should not be NULL");
 	if (!(req_dat = magic_set_config(r))) {
 	    /* failure */
@@ -692,7 +692,7 @@ static char *rsl_strdup(request_rec *r, int start_frag, int start_pos, int len)
     /* clean up and return */
     result[res_pos] = 0;
 #if MIME_MAGIC_DEBUG
-    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 	     MODNAME ": rsl_strdup() %d chars: %s", res_pos - 1, result);
 #endif
     return result;
@@ -764,7 +764,7 @@ static int magic_rsl_to_request(request_rec *r)
 		else {
 		    /* should not be possible */
 		    /* abandon malfunctioning module */
-		    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, r,
+		    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 				MODNAME ": bad state %d (ws)", state);
 		    return DECLINED;
 		}
@@ -808,7 +808,7 @@ static int magic_rsl_to_request(request_rec *r)
 		else {
 		    /* should not be possible */
 		    /* abandon malfunctioning module */
-		    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, r,
+		    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 				MODNAME ": bad state %d (ns)", state);
 		    return DECLINED;
 		}
@@ -848,7 +848,7 @@ static int magic_rsl_to_request(request_rec *r)
     /* detect memory allocation or other errors */
     if (!r->content_type ||
 	(state == rsl_encoding && !r->content_encoding)) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, r,
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       MODNAME ": unexpected state %d; could be caused by bad "
                       "data in magic file",
                       state);
@@ -1018,28 +1018,28 @@ static int apprentice(server_rec *s, apr_pool_t *p)
     (void) apr_file_close(f);
 
 #if MIME_MAGIC_DEBUG
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
 		MODNAME ": apprentice conf=%x file=%s m=%s m->next=%s last=%s",
 		conf,
 		conf->magicfile ? conf->magicfile : "NULL",
 		conf->magic ? "set" : "NULL",
 		(conf->magic && conf->magic->next) ? "set" : "NULL",
 		conf->last ? "set" : "NULL");
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
 		MODNAME ": apprentice read %d lines, %d rules, %d errors",
 		lineno, rule, errs);
 #endif
 
 #if MIME_MAGIC_DEBUG
     prevm = 0;
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, s,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
 		MODNAME ": apprentice test");
     for (m = conf->magic; m; m = m->next) {
 	if (apr_isprint((((unsigned long) m) >> 24) & 255) &&
 	    apr_isprint((((unsigned long) m) >> 16) & 255) &&
 	    apr_isprint((((unsigned long) m) >> 8) & 255) &&
 	    apr_isprint(((unsigned long) m) & 255)) {
-	    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, s,
+	    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
 			MODNAME ": apprentice: POINTER CLOBBERED! "
 			"m=\"%c%c%c%c\" line=%d",
 			(((unsigned long) m) >> 24) & 255,
@@ -1086,7 +1086,7 @@ static unsigned long signextend(server_rec *s, struct magic *m, unsigned long v)
 	case STRING:
 	    break;
 	default:
-	    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, s,
+	    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
 			MODNAME ": can't happen: m->type=%d", m->type);
 	    return -1;
 	}
@@ -1134,7 +1134,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
     /* get offset, then skip over it */
     m->offset = (int) strtol(l, &t, 0);
     if (l == t) {
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, serv,
+	ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
 		    MODNAME ": offset %s invalid", l);
     }
     l = t;
@@ -1157,7 +1157,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
 		m->in.type = BYTE;
 		break;
 	    default:
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, serv,
+		ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
 			MODNAME ": indirect offset type %c invalid", *l);
 		break;
 	    }
@@ -1174,7 +1174,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
 	else
 	    t = l;
 	if (*t++ != ')') {
-	    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, serv,
+	    ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
 			MODNAME ": missing ')' in indirect offset");
 	}
 	l = t;
@@ -1248,7 +1248,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
 	l += NLEDATE;
     }
     else {
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, serv,
+	ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
 		    MODNAME ": type %s invalid", l);
 	return -1;
     }
@@ -1311,7 +1311,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
     m->desc[sizeof(m->desc) - 1] = '\0';
 
 #if MIME_MAGIC_DEBUG
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, serv,
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, serv,
 		MODNAME ": parse line=%d m=%x next=%x cont=%d desc=%s",
 		lineno, m, m->next, m->cont_level, m->desc);
 #endif /* MIME_MAGIC_DEBUG */
@@ -1354,7 +1354,7 @@ static char *getstr(server_rec *serv, register char *s, register char *p,
 	if (apr_isspace((unsigned char) c))
 	    break;
 	if (p >= pmax) {
-	    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, serv,
+	    ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
 			MODNAME ": string too long: %s", origs);
 	    break;
 	}
@@ -1500,7 +1500,7 @@ static int fsmagic(request_rec *r, const char *fn)
 	/* We used stat(), the only possible reason for this is that the
 	 * symlink is broken.
 	 */
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		    MODNAME ": broken symlink (%s)", fn);
 	return HTTP_INTERNAL_SERVER_ERROR;
     case APR_SOCK:
@@ -1509,7 +1509,7 @@ static int fsmagic(request_rec *r, const char *fn)
     case APR_REG:
 	break;
     default:
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		      MODNAME ": invalid file type %d.", r->finfo.filetype);
 	return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -1576,7 +1576,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
     struct magic *m;
 
 #if MIME_MAGIC_DEBUG
-    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		MODNAME ": match conf=%x file=%s m=%s m->next=%s last=%s",
 		conf,
 		conf->magicfile ? conf->magicfile : "NULL",
@@ -1591,7 +1591,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
 	    apr_isprint((((unsigned long) m) >> 16) & 255) &&
 	    apr_isprint((((unsigned long) m) >> 8) & 255) &&
 	    apr_isprint(((unsigned long) m) & 255)) {
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 			MODNAME ": match: POINTER CLOBBERED! "
 			"m=\"%c%c%c%c\"",
 			(((unsigned long) m) >> 24) & 255,
@@ -1606,7 +1606,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
     for (m = conf->magic; m; m = m->next) {
 #if MIME_MAGIC_DEBUG
 	rule_counter++;
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		    MODNAME ": line=%d desc=%s", m->lineno, m->desc);
 #endif
 
@@ -1626,7 +1626,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
 	    while (m_cont && (m_cont->cont_level != 0)) {
 #if MIME_MAGIC_DEBUG
 		rule_counter++;
-		ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+		ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 			MODNAME ": line=%d mc=%x mc->next=%x cont=%d desc=%s",
 			    m_cont->lineno, m_cont,
 			    m_cont->next, m_cont->cont_level,
@@ -1645,7 +1645,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
 	/* if we get here, the main entry rule was a match */
 	/* this will be the last run through the loop */
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		    MODNAME ": rule matched, line=%d type=%d %s",
 		    m->lineno, m->type,
 		    (m->type == STRING) ? m->value.s : "");
@@ -1669,7 +1669,7 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
 	m = m->next;
 	while (m && (m->cont_level != 0)) {
 #if MIME_MAGIC_DEBUG
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 			MODNAME ": match line=%d cont=%d type=%d %s",
 			m->lineno, m->cont_level, m->type,
 			(m->type == STRING) ? m->value.s : "");
@@ -1713,13 +1713,13 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
 	    m = m->next;
 	}
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		    MODNAME ": matched after %d rules", rule_counter);
 #endif
 	return 1;		/* all through */
     }
 #if MIME_MAGIC_DEBUG
-    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		MODNAME ": failed after %d rules", rule_counter);
 #endif
     return 0;			/* no match at all */
@@ -1765,7 +1765,7 @@ static void mprint(request_rec *r, union VALUETYPE *p, struct magic *m)
 	(void) magic_rsl_printf(r, m->desc, pp);
 	return;
     default:
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		    MODNAME ": invalid m->type (%d) in mprint().",
 		    m->type);
 	return;
@@ -1811,7 +1811,7 @@ static int mconvert(request_rec *r, union VALUETYPE *p, struct magic *m)
 	    ((p->hl[3] << 24) | (p->hl[2] << 16) | (p->hl[1] << 8) | (p->hl[0]));
 	return 1;
     default:
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		    MODNAME ": invalid type %d in mconvert().", m->type);
 	return 0;
     }
@@ -1863,7 +1863,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     int matched;
 
     if ((m->value.s[0] == 'x') && (m->value.s[1] == '\0')) {
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		    MODNAME ": BOINK");
 	return 1;
     }
@@ -1908,7 +1908,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
 	break;
     default:
 	/*  bogosity, pretend that it just wasn't a match */
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		    MODNAME ": invalid type %d in mcheck().", m->type);
 	return 0;
     }
@@ -1918,7 +1918,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     switch (m->reln) {
     case 'x':
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		    "%lu == *any* = 1", v);
 #endif
 	matched = 1;
@@ -1927,7 +1927,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     case '!':
 	matched = v != l;
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		    "%lu != %lu = %d", v, l, matched);
 #endif
 	break;
@@ -1935,7 +1935,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     case '=':
 	matched = v == l;
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		    "%lu == %lu = %d", v, l, matched);
 #endif
 	break;
@@ -1944,14 +1944,14 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
 	if (m->flag & UNSIGNED) {
 	    matched = v > l;
 #if MIME_MAGIC_DEBUG
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 			"%lu > %lu = %d", v, l, matched);
 #endif
 	}
 	else {
 	    matched = (long) v > (long) l;
 #if MIME_MAGIC_DEBUG
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 			"%ld > %ld = %d", v, l, matched);
 #endif
 	}
@@ -1961,14 +1961,14 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
 	if (m->flag & UNSIGNED) {
 	    matched = v < l;
 #if MIME_MAGIC_DEBUG
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 			"%lu < %lu = %d", v, l, matched);
 #endif
 	}
 	else {
 	    matched = (long) v < (long) l;
 #if MIME_MAGIC_DEBUG
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 			"%ld < %ld = %d", v, l, matched);
 #endif
 	}
@@ -1977,7 +1977,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     case '&':
 	matched = (v & l) == l;
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		    "((%lx & %lx) == %lx) = %d", v, l, l, matched);
 #endif
 	break;
@@ -1985,7 +1985,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     case '^':
 	matched = (v & l) != l;
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		    "((%lx & %lx) != %lx) = %d", v, l, l, matched);
 #endif
 	break;
@@ -1993,7 +1993,7 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     default:
 	/* bogosity, pretend it didn't match */
 	matched = 0;
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		    MODNAME ": mcheck: can't happen: invalid relation %d.",
 		    m->reln);
 	break;
@@ -2343,7 +2343,7 @@ static int revision_suffix(request_rec *r)
     request_rec *sub;
 
 #if MIME_MAGIC_DEBUG
-    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		MODNAME ": revision_suffix checking %s", r->filename);
 #endif /* MIME_MAGIC_DEBUG */
 
@@ -2362,7 +2362,7 @@ static int revision_suffix(request_rec *r)
     result = 0;
     sub_filename = apr_pstrndup(r->pool, r->filename, suffix_pos);
 #if MIME_MAGIC_DEBUG
-    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		MODNAME ": subrequest lookup for %s", sub_filename);
 #endif /* MIME_MAGIC_DEBUG */
     sub = ap_sub_req_lookup_file(sub_filename, r, NULL);
@@ -2371,7 +2371,7 @@ static int revision_suffix(request_rec *r)
     if (sub->content_type) {
 	ap_set_content_type(r, apr_pstrdup(r->pool, sub->content_type));
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
+	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
 		    MODNAME ": subrequest %s got %s",
 		    sub_filename, r->content_type);
 #endif /* MIME_MAGIC_DEBUG */
@@ -2422,14 +2422,14 @@ static int magic_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server
 		return OK;
 #if MIME_MAGIC_DEBUG
 	    prevm = 0;
-	    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, s,
+	    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
 			MODNAME ": magic_init 1 test");
 	    for (m = conf->magic; m; m = m->next) {
 		if (apr_isprint((((unsigned long) m) >> 24) & 255) &&
 		    apr_isprint((((unsigned long) m) >> 16) & 255) &&
 		    apr_isprint((((unsigned long) m) >> 8) & 255) &&
 		    apr_isprint(((unsigned long) m) & 255)) {
-		    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, s,
+		    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
 				MODNAME ": magic_init 1: POINTER CLOBBERED! "
 				"m=\"%c%c%c%c\" line=%d",
 				(((unsigned long) m) >> 24) & 255,
diff --git a/modules/metadata/mod_unique_id.c b/modules/metadata/mod_unique_id.c
index 3ade5c2..7c8b73f 100644
--- a/modules/metadata/mod_unique_id.c
+++ b/modules/metadata/mod_unique_id.c
@@ -234,7 +234,7 @@ static int unique_id_global_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *pt
     }
 
     apr_sockaddr_ip_get(&ipaddrstr, sockaddr);
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, main_server,
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, main_server,
                 "mod_unique_id: using ip addr %s",
                  ipaddrstr);
 
@@ -280,7 +280,7 @@ static void unique_id_child_init(apr_pool_t *p, server_rec *s)
      * global_init ... but oh well.
      */
     if ((pid_t)cur_unique_id.pid != pid) {
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_CRIT, 0, s,
+        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
                     "oh no! pids are greater than 32-bits!  I'm broken!");
     }
 
diff --git a/os/beos/beosd.c b/os/beos/beosd.c
index 90815ad..0c1aba2 100644
--- a/os/beos/beosd.c
+++ b/os/beos/beosd.c
@@ -124,7 +124,7 @@ AP_DECLARE(apr_status_t) beosd_accept(void **accepted, ap_listen_rec *lr,
         *accepted = csd;
         apr_os_sock_get(&sockdes, csd);
         if (sockdes >= FD_SETSIZE) {
-            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
                          "new file descriptor %d is too large; you probably need "
                          "to rebuild Apache with a larger FD_SETSIZE "
                          "(currently %d)",
diff --git a/os/bs2000/bs2login.c b/os/bs2000/bs2login.c
index 2a1de0d..ab2d342 100644
--- a/os/bs2000/bs2login.c
+++ b/os/bs2000/bs2login.c
@@ -142,7 +142,7 @@ static bs2_ForkType os_forktype(void)
 	strcmp(os_version.release, "02.0A") == 0 ||
 	strcmp(os_version.release, "02.1A") == 0)
     {
-	ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, NULL,
+	ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
 		     "Error: unsupported OS version. "
 		     "You may encounter problems.");
 	forktype = bs2_FORK;
@@ -217,7 +217,7 @@ int os_init_job_environment(server_rec *server, const char *user_name, int one_p
 
 	type = forktype = bs2_noFORK;
 
-	ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, server,
+	ap_log_error(APLOG_MARK, APLOG_ERR, 0, server,
 		     "The debug mode of Apache should only "
 		     "be started by an unprivileged user!");
 	return 0;
@@ -230,7 +230,7 @@ int os_init_job_environment(server_rec *server, const char *user_name, int one_p
     /* An Account is required for _rini() */
     if (bs2000_account == NULL)
     {
-	ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, 0, server,
+	ap_log_error(APLOG_MARK, APLOG_ALERT, 0, server,
 		     "No BS2000Account configured - cannot switch to User %s",
 		     user_name);
 	exit(APEXIT_CHILDFATAL);
diff --git a/os/unix/unixd.c b/os/unix/unixd.c
index 21ee63b..c854a39 100644
--- a/os/unix/unixd.c
+++ b/os/unix/unixd.c
@@ -276,7 +276,7 @@ AP_DECLARE(void) unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
         }
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, cmd->server,
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server,
                      "Invalid parameters for %s", cmd->cmd->name);
         return;
     }
@@ -289,7 +289,7 @@ AP_DECLARE(void) unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
     if (geteuid()) {
         limit->rlim_cur = cur;
         if (max) {
-            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, cmd->server,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server,
                          "Must be uid 0 to raise maximum %s", cmd->cmd->name);
         }
     }
@@ -303,7 +303,7 @@ AP_DECLARE(void) unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
     }
 #else
 
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, cmd->server,
+    ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server,
                  "Platform does not support rlimit for %s", cmd->cmd->name);
 #endif
 }
@@ -439,7 +439,7 @@ AP_DECLARE(apr_status_t) unixd_accept(void **accepted, ap_listen_rec *lr,
         *accepted = csd;
         apr_os_sock_get(&sockdes, csd);
         if (sockdes >= FD_SETSIZE) {
-            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
                          "new file descriptor %d is too large; you probably need "
                          "to rebuild Apache with a larger FD_SETSIZE "
                          "(currently %d)",
@@ -549,7 +549,7 @@ AP_DECLARE(apr_status_t) unixd_accept(void **accepted, ap_listen_rec *lr,
             return APR_EGENERAL;
             break;
         default:
-            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, ap_server_conf,
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf,
                          "select/accept error (%d)", status);
             return APR_EGENERAL;
 #else
