commit 0265857a78d75cd1f39392f91c3d21c9b22503db
Author: William A. Rowe Jr <wrowe@apache.org>
Date:   Thu Jan 10 00:28:00 2002 +0000

      This patch eliminated from the _SHARED_ segment of the scoreboard all
      pointer math.  This is required for portable scoreboards.
    
      vhost becomes the 'vhost name string' so it now survives ap_generation
      clicks.  next was apparently never used.
    
      This patch also accounts for the changes to the apr_shm api, and gives
      Win32 the magic of a shared scoreboard.
    
      Breakage aplenty on non-win32 platforms, I suspect, but this radical
      surgery, and culling of unused functions, was really, really needed.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@92791 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/CHANGES b/CHANGES
index 7dc7a76..cd8efd9 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,5 +1,9 @@
 Changes with Apache 2.0.31-dev
 
+  *) Moved several pointers out of the shared Scoreboard so it is
+     more portable, and will present the vhost name across server
+     generation restarts.  [William Rowe]
+
   *) Fix SSLPassPhraseDialog exec: and SSLRandomSeed exec:
      [Doug MacEachern]
 
diff --git a/include/scoreboard.h b/include/scoreboard.h
index c4c6637..30b8d97 100644
--- a/include/scoreboard.h
+++ b/include/scoreboard.h
@@ -100,23 +100,11 @@ extern "C" {
 /* Type used for generation indicies.  Startup and every restart cause a
  * new generation of children to be spawned.  Children within the same
  * generation share the same configuration information -- pointers to stuff
- * created at config time in the parent are valid across children.  For
- * example, the vhostrec pointer in the scoreboard below is valid in all
- * children of the same generation.
- *
- * The safe way to access the vhost pointer is like this:
- *
- * worker_score *ss = pointer to whichver slot is interesting;
- * process_score *ps = pointer to whichver slot is interesting;
- * server_rec *vh = ss->vhostrec;
- *
- * if (ps->generation != ap_my_generation) {
- *     vh = NULL;
- * }
- *
- * then if vh is not NULL it's valid in this child.
- *
- * This avoids various race conditions around restarts.
+ * created at config time in the parent are valid across children.  However,
+ * this can't work effectively with non-forked architectures.  So while the
+ * arrays in the scoreboard never change between the parent and forked
+ * children, so they do not require shm storage, the contents of the shm
+ * may contain no pointers.
  */
 typedef int ap_generation_t;
 
@@ -124,8 +112,9 @@ typedef int ap_generation_t;
  * Set by the MPM when the scoreboard is created.
  */
 typedef enum {
-    SB_SHARED = 1,
-    SB_NOT_SHARED = 2
+    SB_NOT_SHARED = 1,
+    SB_SHARED = 2,      /* PARENT */
+    SB_SHARED_CHILD = 3
 } ap_scoreboard_e;
 
 #define SB_WORKING  0  /* The server is busy and the child is useful. */
@@ -160,9 +149,7 @@ struct worker_score {
     apr_time_t last_used;
     char client[32];		/* Keep 'em small... */
     char request[64];		/* We just want an idea... */
-    server_rec *vhostrec;	/* What virtual host is being accessed? */
-                                /* SEE ABOVE FOR SAFE USAGE! */
-    worker_score *next;
+    char vhost[32];	        /* What virtual host is being accessed? */
 };
 
 typedef struct {
@@ -182,43 +169,41 @@ struct process_score{
                              */
 };
 
+/* Scoreboard is now in 'local' memory, since it isn't updated once created,
+ * even in forked architectures.  Child created-processes (non-fork) will
+ * set up these indicies into the (possibly relocated) shmem records.
+ */
 typedef struct {
-    global_score global;
+    global_score *global;
     process_score *parent;
     worker_score **servers;
 } scoreboard;
 
-#define KEY_LENGTH 16
-#define VALUE_LENGTH 64
-typedef struct {
-    char key[KEY_LENGTH];
-    char value[VALUE_LENGTH];
-} status_table_entry;
+typedef struct ap_sb_handle_t ap_sb_handle_t;
 
 AP_DECLARE(int) ap_exists_scoreboard_image(void);
-AP_DECLARE_NONSTD(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
-AP_DECLARE(void) ap_increment_counts(void *sbh, request_rec *r);
+AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sbh, request_rec *r);
 
+void ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
+apr_status_t reopen_scoreboard(apr_pool_t *p, int detached);
+void ap_init_scoreboard(void *shared_score);
 int ap_calc_scoreboard_size(void);
-void ap_init_scoreboard(void);
 apr_status_t ap_cleanup_scoreboard(void *d);
-
-AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p);
-
 void ap_sync_scoreboard_image(void);
 
-AP_DECLARE(void) ap_create_sb_handle(void **new_handle, apr_pool_t *p,
+AP_DECLARE(void) ap_create_sb_handle(ap_sb_handle_t **new_sbh, apr_pool_t *p,
                                      int child_num, int thread_num);
     
 void update_scoreboard_global(void);
 AP_DECLARE(int) find_child_by_pid(apr_proc_t *pid);
-AP_DECLARE(int) ap_update_child_status(void *sbh, int status, request_rec *r);
+AP_DECLARE(int) ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r);
 AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num, int thread_num,
                                                     int status, request_rec *r);
 void ap_time_process_request(int child_num, int thread_num, int status);
-AP_DECLARE(worker_score *) ap_get_servers_scoreboard(int x, int y);
-AP_DECLARE(process_score *) ap_get_parent_scoreboard(int x);
-AP_DECLARE(global_score *) ap_get_global_scoreboard(void);
+
+AP_DECLARE(worker_score *) ap_get_scoreboard_worker(int x, int y);
+AP_DECLARE(process_score *) ap_get_scoreboard_process(int x);
+AP_DECLARE(global_score *) ap_get_scoreboard_global(void);
 
 AP_DECLARE_DATA extern scoreboard *ap_scoreboard_image;
 AP_DECLARE_DATA extern const char *ap_scoreboard_fname;
diff --git a/modules/aaa/mod_auth_digest.c b/modules/aaa/mod_auth_digest.c
index 4949564..e82f04a 100644
--- a/modules/aaa/mod_auth_digest.c
+++ b/modules/aaa/mod_auth_digest.c
@@ -116,53 +116,11 @@
 #include "http_protocol.h"
 #include "apr_uri.h"
 #include "util_md5.h"
+#include "apr_shm.h"
+#include "apr_rmm.h"
 
-/* Disable shmem until pools/init gets sorted out - remove next line when fixed */
 #undef APR_HAS_SHARED_MEMORY
-#define APR_HAS_SHARED_MEMORY 0
-
-#if APR_HAS_SHARED_MEMORY
-#include "apr_shmem.h"
-#else
-/* just provide dummies - the code does run-time checks anyway */
-typedef   void apr_shmem_t;
-typedef   void apr_shm_name_t;
-
-/*
-static apr_status_t apr_shm_init(apr_shmem_t **m, apr_size_t reqsize, const char *file, apr_pool_t *cont) {
-    return APR_ENOTIMPL;
-}
-*/
-static apr_status_t apr_shm_destroy(apr_shmem_t *m) {
-    return APR_ENOTIMPL;
-}
-static void *apr_shm_malloc(apr_shmem_t *c, apr_size_t reqsize) {
-    return NULL;
-}
-/*
-static void *apr_shm_calloc(apr_shmem_t *shared, apr_size_t size) {
-    return NULL;
-}
-*/
-static apr_status_t apr_shm_free(apr_shmem_t *shared, void *free) {
-    return APR_ENOTIMPL;
-}
-/*
-static apr_status_t apr_shm_name_get(apr_shmem_t *c, apr_shm_name_t **name) {
-    return APR_ENOTIMPL;
-}
-static apr_status_t apr_shm_name_set(apr_shmem_t *c, apr_shm_name_t *name) {
-    return APR_ENOTIMPL;
-}
-static apr_status_t apr_shm_open(apr_shmem_t *c) {
-    return APR_ENOTIMPL;
-}
-static apr_status_t apr_shm_avail(apr_shmem_t *c, apr_size_t *avail) {
-    return APR_ENOTIMPL;
-}
-*/
-#endif /* ndef APR_HAS_SHARED_MEMORY */
-
+#define APR_HAS_SHARED_MEMORY 1
 
 /* struct to hold the configuration info */
 
@@ -253,8 +211,9 @@ static unsigned char secret[SECRET_LEN];
 
 /* client-list, opaque, and one-time-nonce stuff */
 
-static apr_shmem_t    *client_shm = NULL;
-static unsigned long *opaque_cntr;
+static apr_shm_t      *client_shm =  NULL;
+static apr_rmm_t      *client_rmm = NULL;
+static unsigned long  *opaque_cntr;
 static apr_time_t     *otn_counter;     /* one-time-nonce counter */
 static apr_lock_t     *client_lock = NULL;
 static apr_lock_t     *opaque_lock = NULL;
@@ -277,7 +236,7 @@ module AP_MODULE_DECLARE_DATA auth_digest_module;
 
 static apr_status_t cleanup_tables(void *not_used)
 {
-    ap_log_rerror(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
+    ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
                   "Digest: cleaning up shared memory");
     fflush(stderr);
 
@@ -343,13 +302,13 @@ static void initialize_tables(server_rec *s, apr_pool_t *ctx)
 
     /* set up client list */
 
-    sts = apr_shm_init(&client_shm, shmem_size, tmpnam(NULL), ctx);
+    sts = apr_shm_create(&client_shm, shmem_size, tmpnam(NULL), ctx);
     if (sts != APR_SUCCESS) {
         log_error_and_cleanup("failed to create shared memory segments", sts, s);
         return;
     }
 
-    client_list = apr_shm_malloc(client_shm, sizeof(*client_list) +
+    client_list = apr_rmm_malloc(client_rmm, sizeof(*client_list) +
                                             sizeof(client_entry*)*num_buckets);
     if (!client_list) {
         log_error_and_cleanup("failed to allocate shared memory", -1, s);
@@ -373,7 +332,7 @@ static void initialize_tables(server_rec *s, apr_pool_t *ctx)
 
     /* setup opaque */
 
-    opaque_cntr = apr_shm_malloc(client_shm, sizeof(*opaque_cntr));
+    opaque_cntr = apr_rmm_malloc(client_rmm, sizeof(*opaque_cntr));
     if (opaque_cntr == NULL) {
         log_error_and_cleanup("failed to allocate shared memory", -1, s);
         return;
@@ -391,7 +350,7 @@ static void initialize_tables(server_rec *s, apr_pool_t *ctx)
 
     /* setup one-time-nonce counter */
 
-    otn_counter = apr_shm_malloc(client_shm, sizeof(*otn_counter));
+    otn_counter = apr_rmm_malloc(client_rmm, sizeof(*otn_counter));
     if (otn_counter == NULL) {
         log_error_and_cleanup("failed to allocate shared memory", -1, s);
         return;
@@ -812,7 +771,7 @@ static long gc(void)
             client_list->table[idx] = NULL;
         }
         if (entry) {                    /* remove entry */
-            apr_shm_free(client_shm, entry);
+            apr_rmm_free(client_rmm, entry);
             num_removed++;
         }
     }
@@ -848,7 +807,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
 
     /* try to allocate a new entry */
 
-    entry = apr_shm_malloc(client_shm, sizeof(client_entry));
+    entry = apr_rmm_malloc(client_rmm, sizeof(client_entry));
     if (!entry) {
         long num_removed = gc();
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, s,
@@ -857,7 +816,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
                      "%ld", num_removed,
                      client_list->num_created - client_list->num_renewed,
                      client_list->num_removed, client_list->num_renewed);
-        entry = apr_shm_malloc(client_shm, sizeof(client_entry));
+        entry = apr_rmm_malloc(client_rmm, sizeof(client_entry));
         if (!entry) {
             return NULL;       /* give up */
         }
diff --git a/modules/generators/mod_status.c b/modules/generators/mod_status.c
index 18d9725..6970243 100644
--- a/modules/generators/mod_status.c
+++ b/modules/generators/mod_status.c
@@ -257,7 +257,6 @@ static int status_handler(request_rec *r)
     char *stat_buffer;
     pid_t *pid_buffer;
     clock_t tu, ts, tcu, tcs;
-    server_rec *vhost;
 
     if (strcmp(r->handler, STATUS_MAGIC_TYPE) && strcmp(r->handler, "server-status")) {
         return DECLINED;
@@ -525,11 +524,7 @@ static int status_handler(request_rec *r)
 	for (j = 0; j < thread_limit; ++j) {
 	    ws_record = ap_scoreboard_image->servers[i][j];
 	    ps_record = ap_scoreboard_image->parent[i];
-	    vhost = ws_record.vhostrec;
-	    if (ps_record.generation != ap_my_generation) {
-		vhost = NULL;
-	    }
-
+	    
 #if defined(NO_GETTIMEOFDAY)
 #ifdef HAVE_TIMES
 	    if (ws_record.start_time == (clock_t) 0)
@@ -636,8 +631,7 @@ static int status_handler(request_rec *r)
 			ap_rprintf(r, " <i>%s {%s}</i> <b>[%s]</b><br />\n\n",
 			    ap_escape_html(r->pool, ws_record.client),
 			    ap_escape_html(r->pool, ws_record.request),
-			    vhost ? ap_escape_html(r->pool, 
-				vhost->server_hostname) : "(unavailable)");
+			    ap_escape_html(r->pool, ws_record.vhost));
 		    }
 		    else {		/* !no_table_report */
 			if (ws_record.status == SERVER_DEAD)
@@ -713,8 +707,7 @@ static int status_handler(request_rec *r)
 			    ap_rprintf(r,
 			     "</td><td>%s</td><td nowrap>%s</td><td nowrap>%s</td></tr>\n\n",
 			     ap_escape_html(r->pool, ws_record.client),
-			     vhost ? ap_escape_html(r->pool, 
-				vhost->server_hostname) : "(unavailable)",
+			     ap_escape_html(r->pool, ws_record.vhost),
 			     ap_escape_html(r->pool, ws_record.request));
 		    }		/* no_table_report */
 		}			/* !short_report */
diff --git a/modules/ssl/ssl_engine_rand.c b/modules/ssl/ssl_engine_rand.c
index 0655ce1..2cf98ff 100644
--- a/modules/ssl/ssl_engine_rand.c
+++ b/modules/ssl/ssl_engine_rand.c
@@ -161,7 +161,7 @@ int ssl_rand_seed(server_rec *s, apr_pool_t *p, ssl_rsctx_t nCtx, char *prefix)
                  * seed in an 1KB extract of the current scoreboard
                  */
                 if (ap_scoreboard_image != NULL) {
-                    n = ssl_rand_choosenum(0, sizeof(scoreboard)-1024-1);
+                    n = ssl_rand_choosenum(0,ap_calc_scoreboard_size()-1024-1);
                     RAND_seed(((unsigned char *)ap_scoreboard_image)+n, 1024);
                     nDone += 1024;
                 }
diff --git a/modules/ssl/ssl_expr_parse.c b/modules/ssl/ssl_expr_parse.c
index 2f9a013..d8fdc0a 100644
--- a/modules/ssl/ssl_expr_parse.c
+++ b/modules/ssl/ssl_expr_parse.c
@@ -1,518 +1,820 @@
-#ifndef lint
-static char const 
-ssl_expr_yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
-#endif
-#include <stdlib.h>
-#define YYBYACC 1
-#define YYMAJOR 1
-#define YYMINOR 9
-#define YYLEX ssl_expr_yylex()
-#define YYEMPTY -1
-#define ssl_expr_yyclearin (ssl_expr_yychar=(YYEMPTY))
-#define ssl_expr_yyerrok (ssl_expr_yyerrflag=0)
-#define YYRECOVERING() (ssl_expr_yyerrflag!=0)
-static int ssl_expr_yygrowstack();
-#define YYPREFIX "ssl_expr_yy"
-#line 69 "ssl_expr_parse.y"
+
+/*  A Bison parser, made from ssl_expr_parse.y
+    by GNU Bison version 1.28  */
+
+#define YYBISON 1  /* Identify Bison output.  */
+
+#define	T_TRUE	257
+#define	T_FALSE	258
+#define	T_DIGIT	259
+#define	T_ID	260
+#define	T_STRING	261
+#define	T_REGEX	262
+#define	T_REGEX_I	263
+#define	T_FUNC_FILE	264
+#define	T_OP_EQ	265
+#define	T_OP_NE	266
+#define	T_OP_LT	267
+#define	T_OP_LE	268
+#define	T_OP_GT	269
+#define	T_OP_GE	270
+#define	T_OP_REG	271
+#define	T_OP_NRE	272
+#define	T_OP_IN	273
+#define	T_OP_OR	274
+#define	T_OP_AND	275
+#define	T_OP_NOT	276
+
+#line 68 "ssl_expr_parse.y"
+
 #include "mod_ssl.h"
+
 #line 72 "ssl_expr_parse.y"
 typedef union {
     char     *cpVal;
     ssl_expr *exVal;
 } YYSTYPE;
-#line 24 "y.tab.c"
-#define YYERRCODE 256
-#define T_TRUE 257
-#define T_FALSE 258
-#define T_DIGIT 259
-#define T_ID 260
-#define T_STRING 261
-#define T_REGEX 262
-#define T_REGEX_I 263
-#define T_FUNC_FILE 264
-#define T_OP_EQ 265
-#define T_OP_NE 266
-#define T_OP_LT 267
-#define T_OP_LE 268
-#define T_OP_GT 269
-#define T_OP_GE 270
-#define T_OP_REG 271
-#define T_OP_NRE 272
-#define T_OP_IN 273
-#define T_OP_OR 274
-#define T_OP_AND 275
-#define T_OP_NOT 276
-const short ssl_expr_yylhs[] = {                                        -1,
-    0,    1,    1,    1,    1,    1,    1,    1,    2,    2,
-    2,    2,    2,    2,    2,    2,    2,    5,    5,    6,
-    6,    6,    6,    4,    4,    3,
+#include <stdio.h>
+
+#ifndef __cplusplus
+#ifndef __STDC__
+#define const
+#endif
+#endif
+
+
+
+#define	YYFINAL		53
+#define	YYFLAG		-32768
+#define	YYNTBASE	29
+
+#define YYTRANSLATE(x) ((unsigned)(x) <= 276 ? ssl_expr_yytranslate[x] : 36)
+
+static const char ssl_expr_yytranslate[] = {     0,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,    28,     2,     2,    23,
+    24,     2,     2,    27,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,    25,     2,    26,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
+     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+    17,    18,    19,    20,    21,    22
 };
-const short ssl_expr_yylen[] = {                                         2,
-    1,    1,    1,    2,    3,    3,    1,    3,    3,    3,
-    3,    3,    3,    3,    5,    3,    3,    1,    3,    1,
-    1,    4,    1,    1,    1,    4,
+
+#if YYDEBUG != 0
+static const short ssl_expr_yyprhs[] = {     0,
+     0,     2,     4,     6,     9,    13,    17,    19,    23,    27,
+    31,    35,    39,    43,    47,    53,    57,    61,    63,    67,
+    69,    71,    76,    78,    80,    82
 };
-const short ssl_expr_yydefred[] = {                                      0,
-    2,    3,   20,   21,    0,    0,    0,    0,    0,    0,
-    7,   23,    0,    0,    4,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    8,
-    0,    0,    6,    9,   10,   11,   12,   13,   14,   24,
-   25,   16,   17,    0,   26,   22,    0,   18,   15,    0,
-   19,
+
+static const short ssl_expr_yyrhs[] = {    30,
+     0,     3,     0,     4,     0,    22,    30,     0,    30,    20,
+    30,     0,    30,    21,    30,     0,    31,     0,    23,    30,
+    24,     0,    33,    11,    33,     0,    33,    12,    33,     0,
+    33,    13,    33,     0,    33,    14,    33,     0,    33,    15,
+    33,     0,    33,    16,    33,     0,    33,    19,    25,    32,
+    26,     0,    33,    17,    34,     0,    33,    18,    34,     0,
+    33,     0,    32,    27,    33,     0,     5,     0,     7,     0,
+    28,    25,     6,    26,     0,    35,     0,     8,     0,     9,
+     0,    10,    23,     7,    24,     0
 };
-const short ssl_expr_yydgoto[] = {                                       9,
-   10,   11,   12,   42,   47,   13,
+
+#endif
+
+#if YYDEBUG != 0
+static const short ssl_expr_yyrline[] = { 0,
+   115,   118,   119,   120,   121,   122,   123,   124,   127,   128,
+   129,   130,   131,   132,   133,   134,   135,   138,   139,   142,
+   143,   144,   145,   148,   158,   170
 };
-const short ssl_expr_yysindex[] = {                                    -37,
-    0,    0,    0,    0,  -35,  -37,  -37,  -99,    0, -247,
-    0,    0, -250, -229,    0,  -39, -227,  -37,  -37,  -33,
-  -33,  -33,  -33,  -33,  -33, -233, -233,  -89,   -6,    0,
-  -87, -239,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,  -33,    0,    0,  -38,    0,    0,  -33,
-    0,
+#endif
+
+
+#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+
+static const char * const ssl_expr_yytname[] = {   "$","error","$undefined.","T_TRUE",
+"T_FALSE","T_DIGIT","T_ID","T_STRING","T_REGEX","T_REGEX_I","T_FUNC_FILE","T_OP_EQ",
+"T_OP_NE","T_OP_LT","T_OP_LE","T_OP_GT","T_OP_GE","T_OP_REG","T_OP_NRE","T_OP_IN",
+"T_OP_OR","T_OP_AND","T_OP_NOT","'('","')'","'{'","'}'","','","'%'","root","expr",
+"comparison","words","word","regex","funccall", NULL
+};
+#endif
+
+static const short ssl_expr_yyr1[] = {     0,
+    29,    30,    30,    30,    30,    30,    30,    30,    31,    31,
+    31,    31,    31,    31,    31,    31,    31,    32,    32,    33,
+    33,    33,    33,    34,    34,    35
 };
-const short ssl_expr_yyrindex[] = {                                      0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,   39,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    1,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,
+
+static const short ssl_expr_yyr2[] = {     0,
+     1,     1,     1,     2,     3,     3,     1,     3,     3,     3,
+     3,     3,     3,     3,     5,     3,     3,     1,     3,     1,
+     1,     4,     1,     1,     1,     4
+};
+
+static const short ssl_expr_yydefact[] = {     0,
+     2,     3,    20,    21,     0,     0,     0,     0,     1,     7,
+     0,    23,     0,     4,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,     0,     8,     0,
+     5,     6,     9,    10,    11,    12,    13,    14,    24,    25,
+    16,    17,     0,    26,    22,     0,    18,    15,     0,    19,
+     0,     0,     0
 };
-const short ssl_expr_yygindex[] = {                                      0,
-    7,    0,    0,   13,    0,  -13,
+
+static const short ssl_expr_yydefgoto[] = {    51,
+     9,    10,    46,    11,    41,    12
 };
-#define YYTABLESIZE 275
-const short ssl_expr_yytable[] = {                                       8,
-    5,   30,    7,    8,   14,   50,   34,   35,   36,   37,
-   38,   39,   15,   16,   20,   21,   22,   23,   24,   25,
-   26,   27,   28,   17,   32,   33,   18,   19,   40,   41,
-   48,   29,   31,   44,   45,   19,   51,   46,    1,   43,
-    0,    5,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,   49,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
-    2,    3,    0,    4,    0,    3,    5,    4,    0,    0,
-    5,    0,    0,    0,   18,   19,    0,    0,    6,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    5,
+
+static const short ssl_expr_yypact[] = {     3,
+-32768,-32768,-32768,-32768,   -11,     3,     3,   -10,     0,-32768,
+    22,-32768,    16,-32768,    -2,    23,     3,     3,     4,     4,
+     4,     4,     4,     4,    34,    34,    21,    24,-32768,    25,
+    26,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
+-32768,-32768,     4,-32768,-32768,    18,-32768,-32768,     4,-32768,
+    49,    50,-32768
 };
-const short ssl_expr_yycheck[] = {                                      37,
-    0,   41,   40,   37,   40,   44,   20,   21,   22,   23,
-   24,   25,    6,    7,  265,  266,  267,  268,  269,  270,
-  271,  272,  273,  123,   18,   19,  274,  275,  262,  263,
-   44,  261,  260,  123,   41,  275,   50,  125,    0,   27,
-   -1,   41,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,  125,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
-  258,  259,   -1,  261,   -1,  259,  264,  261,   -1,   -1,
-  264,   -1,   -1,   -1,  274,  275,   -1,   -1,  276,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,   -1,   -1,   -1,  274,
+
+static const short ssl_expr_yypgoto[] = {-32768,
+    10,-32768,-32768,   -19,    27,-32768
 };
-#define YYFINAL 9
-#ifndef YYDEBUG
-#define YYDEBUG 0
-#endif
-#define YYMAXTOKEN 276
-#if YYDEBUG
-const char * const ssl_expr_yyname[] = {
-"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,"'%'",0,0,"'('","')'",0,0,"','",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"T_TRUE",
-"T_FALSE","T_DIGIT","T_ID","T_STRING","T_REGEX","T_REGEX_I","T_FUNC_FILE",
-"T_OP_EQ","T_OP_NE","T_OP_LT","T_OP_LE","T_OP_GT","T_OP_GE","T_OP_REG",
-"T_OP_NRE","T_OP_IN","T_OP_OR","T_OP_AND","T_OP_NOT",
+
+
+#define	YYLAST		53
+
+
+static const short ssl_expr_yytable[] = {    33,
+    34,    35,    36,    37,    38,     1,     2,     3,     3,     4,
+     4,    13,     5,     5,    16,    14,    15,    17,    18,    17,
+    18,    29,    28,    47,     6,     7,    31,    32,    30,    50,
+     8,     8,    19,    20,    21,    22,    23,    24,    25,    26,
+    27,    39,    40,    48,    49,    43,    18,    44,    52,    53,
+    45,     0,    42
 };
-const char * const ssl_expr_yyrule[] = {
-"$accept : root",
-"root : expr",
-"expr : T_TRUE",
-"expr : T_FALSE",
-"expr : T_OP_NOT expr",
-"expr : expr T_OP_OR expr",
-"expr : expr T_OP_AND expr",
-"expr : comparison",
-"expr : '(' expr ')'",
-"comparison : word T_OP_EQ word",
-"comparison : word T_OP_NE word",
-"comparison : word T_OP_LT word",
-"comparison : word T_OP_LE word",
-"comparison : word T_OP_GT word",
-"comparison : word T_OP_GE word",
-"comparison : word T_OP_IN '{' words '}'",
-"comparison : word T_OP_REG regex",
-"comparison : word T_OP_NRE regex",
-"words : word",
-"words : words ',' word",
-"word : T_DIGIT",
-"word : T_STRING",
-"word : '%' '{' T_ID '}'",
-"word : funccall",
-"regex : T_REGEX",
-"regex : T_REGEX_I",
-"funccall : T_FUNC_FILE '(' T_STRING ')'",
+
+static const short ssl_expr_yycheck[] = {    19,
+    20,    21,    22,    23,    24,     3,     4,     5,     5,     7,
+     7,    23,    10,    10,    25,     6,     7,    20,    21,    20,
+    21,    24,     7,    43,    22,    23,    17,    18,     6,    49,
+    28,    28,    11,    12,    13,    14,    15,    16,    17,    18,
+    19,     8,     9,    26,    27,    25,    21,    24,     0,     0,
+    26,    -1,    26
 };
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/usr/local/share/bison.simple"
+/* This file comes from bison-1.28.  */
+
+/* Skeleton output parser for bison,
+   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+#ifndef YYSTACK_USE_ALLOCA
+#ifdef alloca
+#define YYSTACK_USE_ALLOCA
+#else /* alloca not defined */
+#ifdef __GNUC__
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#else /* not GNU C.  */
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+#define YYSTACK_USE_ALLOCA
+#include <alloca.h>
+#else /* not sparc */
+/* We think this test detects Watcom and Microsoft C.  */
+/* This used to test MSDOS, but that is a bad idea
+   since that symbol is in the user namespace.  */
+#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+#if 0 /* No need for malloc.h, which pollutes the namespace;
+	 instead, just don't use alloca.  */
+#include <malloc.h>
 #endif
-#if YYDEBUG
-#include <stdio.h>
+#else /* not MSDOS, or __TURBOC__ */
+#if defined(_AIX)
+/* I don't know what this was needed for, but it pollutes the namespace.
+   So I turned it off.   rms, 2 May 1997.  */
+/* #include <malloc.h>  */
+ #pragma alloca
+#define YYSTACK_USE_ALLOCA
+#else /* not MSDOS, or __TURBOC__, or _AIX */
+#if 0
+#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+		 and on HPUX 10.  Eventually we can turn this on.  */
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#endif /* __hpux */
 #endif
-#ifdef YYSTACKSIZE
-#undef YYMAXDEPTH
-#define YYMAXDEPTH YYSTACKSIZE
+#endif /* not _AIX */
+#endif /* not MSDOS, or __TURBOC__ */
+#endif /* not sparc */
+#endif /* not GNU C */
+#endif /* alloca not defined */
+#endif /* YYSTACK_USE_ALLOCA not defined */
+
+#ifdef YYSTACK_USE_ALLOCA
+#define YYSTACK_ALLOC alloca
 #else
-#ifdef YYMAXDEPTH
-#define YYSTACKSIZE YYMAXDEPTH
+#define YYSTACK_ALLOC malloc
+#endif
+
+/* Note: there must be only one dollar sign in this file.
+   It is replaced by the list of actions, each action
+   as one case of the switch.  */
+
+#define ssl_expr_yyerrok		(ssl_expr_yyerrstatus = 0)
+#define ssl_expr_yyclearin	(ssl_expr_yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	goto ssl_expr_yyacceptlab
+#define YYABORT 	goto ssl_expr_yyabortlab
+#define YYERROR		goto ssl_expr_yyerrlab1
+/* Like YYERROR except do call ssl_expr_yyerror.
+   This remains here temporarily to ease the
+   transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto ssl_expr_yyerrlab
+#define YYRECOVERING()  (!!ssl_expr_yyerrstatus)
+#define YYBACKUP(token, value) \
+do								\
+  if (ssl_expr_yychar == YYEMPTY && ssl_expr_yylen == 1)				\
+    { ssl_expr_yychar = (token), ssl_expr_yylval = (value);			\
+      ssl_expr_yychar1 = YYTRANSLATE (ssl_expr_yychar);				\
+      YYPOPSTACK;						\
+      goto ssl_expr_yybackup;						\
+    }								\
+  else								\
+    { ssl_expr_yyerror ("syntax error: cannot back up"); YYERROR; }	\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+#ifndef YYPURE
+#define YYLEX		ssl_expr_yylex()
+#endif
+
+#ifdef YYPURE
+#ifdef YYLSP_NEEDED
+#ifdef YYLEX_PARAM
+#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, &ssl_expr_yylloc, YYLEX_PARAM)
 #else
-#define YYSTACKSIZE 10000
-#define YYMAXDEPTH 10000
+#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, &ssl_expr_yylloc)
 #endif
+#else /* not YYLSP_NEEDED */
+#ifdef YYLEX_PARAM
+#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, YYLEX_PARAM)
+#else
+#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval)
+#endif
+#endif /* not YYLSP_NEEDED */
 #endif
-#define YYINITSTACKSIZE 200
-int ssl_expr_yydebug;
-int ssl_expr_yynerrs;
-int ssl_expr_yyerrflag;
-int ssl_expr_yychar;
-short *ssl_expr_yyssp;
-YYSTYPE *ssl_expr_yyvsp;
-YYSTYPE ssl_expr_yyval;
-YYSTYPE ssl_expr_yylval;
-short *ssl_expr_yyss;
-short *ssl_expr_yysslim;
-YYSTYPE *ssl_expr_yyvs;
-int ssl_expr_yystacksize;
-#line 177 "ssl_expr_parse.y"
 
-int ssl_expr_yyerror(char *s)
+/* If nonreentrant, generate the variables here */
+
+#ifndef YYPURE
+
+int	ssl_expr_yychar;			/*  the lookahead symbol		*/
+YYSTYPE	ssl_expr_yylval;			/*  the semantic value of the		*/
+				/*  lookahead symbol			*/
+
+#ifdef YYLSP_NEEDED
+YYLTYPE ssl_expr_yylloc;			/*  location data for the lookahead	*/
+				/*  symbol				*/
+#endif
+
+int ssl_expr_yynerrs;			/*  number of parse errors so far       */
+#endif  /* not YYPURE */
+
+#if YYDEBUG != 0
+int ssl_expr_yydebug;			/*  nonzero means print parse trace	*/
+/* Since this is uninitialized, it does not stop multiple parsers
+   from coexisting.  */
+#endif
+
+/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+
+#ifndef	YYINITDEPTH
+#define YYINITDEPTH 200
+#endif
+
+/*  YYMAXDEPTH is the maximum size the stacks can grow to
+    (effective only if the built-in stack extension method is used).  */
+
+#if YYMAXDEPTH == 0
+#undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 10000
+#endif
+
+/* Define __ssl_expr_yy_memcpy.  Note that the size argument
+   should be passed with type unsigned int, because that is what the non-GCC
+   definitions require.  With GCC, __builtin_memcpy takes an arg
+   of type size_t, but it can handle unsigned int.  */
+
+#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
+#define __ssl_expr_yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
+#else				/* not GNU C or C++ */
+#ifndef __cplusplus
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__ssl_expr_yy_memcpy (to, from, count)
+     char *to;
+     char *from;
+     unsigned int count;
 {
-    ssl_expr_error = s;
-    return 2;
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
 }
 
-#line 230 "y.tab.c"
-/* allocate initial stack or double stack size, up to YYMAXDEPTH */
-static int ssl_expr_yygrowstack()
+#else /* __cplusplus */
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__ssl_expr_yy_memcpy (char *to, char *from, unsigned int count)
 {
-    int newsize, i;
-    short *newss;
-    YYSTYPE *newvs;
-
-    if ((newsize = ssl_expr_yystacksize) == 0)
-        newsize = YYINITSTACKSIZE;
-    else if (newsize >= YYMAXDEPTH)
-        return -1;
-    else if ((newsize *= 2) > YYMAXDEPTH)
-        newsize = YYMAXDEPTH;
-    i = ssl_expr_yyssp - ssl_expr_yyss;
-    newss = ssl_expr_yyss ? (short *)realloc(ssl_expr_yyss, newsize * sizeof *newss) :
-      (short *)malloc(newsize * sizeof *newss);
-    if (newss == NULL)
-        return -1;
-    ssl_expr_yyss = newss;
-    ssl_expr_yyssp = newss + i;
-    newvs = ssl_expr_yyvs ? (YYSTYPE *)realloc(ssl_expr_yyvs, newsize * sizeof *newvs) :
-      (YYSTYPE *)malloc(newsize * sizeof *newvs);
-    if (newvs == NULL)
-        return -1;
-    ssl_expr_yyvs = newvs;
-    ssl_expr_yyvsp = newvs + i;
-    ssl_expr_yystacksize = newsize;
-    ssl_expr_yysslim = ssl_expr_yyss + newsize - 1;
-    return 0;
+  register char *t = to;
+  register char *f = from;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
 }
 
-#define YYABORT goto ssl_expr_yyabort
-#define YYREJECT goto ssl_expr_yyabort
-#define YYACCEPT goto ssl_expr_yyaccept
-#define YYERROR goto ssl_expr_yyerrlab
+#endif
+#endif
+
+#line 217 "/usr/local/share/bison.simple"
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into ssl_expr_yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
 
-#ifndef YYPARSE_PARAM
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG void
+#ifdef YYPARSE_PARAM
+#ifdef __cplusplus
+#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
 #define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
+#else /* not __cplusplus */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+#endif /* not __cplusplus */
+#else /* not YYPARSE_PARAM */
 #define YYPARSE_PARAM_ARG
 #define YYPARSE_PARAM_DECL
-#endif	/* ANSI-C/C++ */
-#else	/* YYPARSE_PARAM */
-#ifndef YYPARSE_PARAM_TYPE
-#define YYPARSE_PARAM_TYPE void *
+#endif /* not YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+#ifdef YYPARSE_PARAM
+int ssl_expr_yyparse (void *);
+#else
+int ssl_expr_yyparse (void);
+#endif
 #endif
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
-#endif	/* ANSI-C/C++ */
-#endif	/* ! YYPARSE_PARAM */
 
 int
-ssl_expr_yyparse (YYPARSE_PARAM_ARG)
-    YYPARSE_PARAM_DECL
+ssl_expr_yyparse(YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
 {
-    register int ssl_expr_yym, ssl_expr_yyn, ssl_expr_yystate;
-#if YYDEBUG
-    register const char *ssl_expr_yys;
+  register int ssl_expr_yystate;
+  register int ssl_expr_yyn;
+  register short *ssl_expr_yyssp;
+  register YYSTYPE *ssl_expr_yyvsp;
+  int ssl_expr_yyerrstatus;	/*  number of tokens to shift before error messages enabled */
+  int ssl_expr_yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
+
+  short	ssl_expr_yyssa[YYINITDEPTH];	/*  the state stack			*/
+  YYSTYPE ssl_expr_yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+
+  short *ssl_expr_yyss = ssl_expr_yyssa;		/*  refer to the stacks thru separate pointers */
+  YYSTYPE *ssl_expr_yyvs = ssl_expr_yyvsa;	/*  to allow ssl_expr_yyoverflow to reallocate them elsewhere */
+
+#ifdef YYLSP_NEEDED
+  YYLTYPE ssl_expr_yylsa[YYINITDEPTH];	/*  the location stack			*/
+  YYLTYPE *ssl_expr_yyls = ssl_expr_yylsa;
+  YYLTYPE *ssl_expr_yylsp;
+
+#define YYPOPSTACK   (ssl_expr_yyvsp--, ssl_expr_yyssp--, ssl_expr_yylsp--)
+#else
+#define YYPOPSTACK   (ssl_expr_yyvsp--, ssl_expr_yyssp--)
+#endif
+
+  int ssl_expr_yystacksize = YYINITDEPTH;
+  int ssl_expr_yyfree_stacks = 0;
+
+#ifdef YYPURE
+  int ssl_expr_yychar;
+  YYSTYPE ssl_expr_yylval;
+  int ssl_expr_yynerrs;
+#ifdef YYLSP_NEEDED
+  YYLTYPE ssl_expr_yylloc;
+#endif
+#endif
+
+  YYSTYPE ssl_expr_yyval;		/*  the variable used to return		*/
+				/*  semantic values from the action	*/
+				/*  routines				*/
+
+  int ssl_expr_yylen;
 
-    if ((ssl_expr_yys = getenv("YYDEBUG")))
+#if YYDEBUG != 0
+  if (ssl_expr_yydebug)
+    fprintf(stderr, "Starting parse\n");
+#endif
+
+  ssl_expr_yystate = 0;
+  ssl_expr_yyerrstatus = 0;
+  ssl_expr_yynerrs = 0;
+  ssl_expr_yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  ssl_expr_yyssp = ssl_expr_yyss - 1;
+  ssl_expr_yyvsp = ssl_expr_yyvs;
+#ifdef YYLSP_NEEDED
+  ssl_expr_yylsp = ssl_expr_yyls;
+#endif
+
+/* Push a new state, which is found in  ssl_expr_yystate  .  */
+/* In all cases, when you get here, the value and location stacks
+   have just been pushed. so pushing a state here evens the stacks.  */
+ssl_expr_yynewstate:
+
+  *++ssl_expr_yyssp = ssl_expr_yystate;
+
+  if (ssl_expr_yyssp >= ssl_expr_yyss + ssl_expr_yystacksize - 1)
     {
-        ssl_expr_yyn = *ssl_expr_yys;
-        if (ssl_expr_yyn >= '0' && ssl_expr_yyn <= '9')
-            ssl_expr_yydebug = ssl_expr_yyn - '0';
+      /* Give user a chance to reallocate the stack */
+      /* Use copies of these so that the &'s don't force the real ones into memory. */
+      YYSTYPE *ssl_expr_yyvs1 = ssl_expr_yyvs;
+      short *ssl_expr_yyss1 = ssl_expr_yyss;
+#ifdef YYLSP_NEEDED
+      YYLTYPE *ssl_expr_yyls1 = ssl_expr_yyls;
+#endif
+
+      /* Get the current used size of the three stacks, in elements.  */
+      int size = ssl_expr_yyssp - ssl_expr_yyss + 1;
+
+#ifdef ssl_expr_yyoverflow
+      /* Each stack pointer address is followed by the size of
+	 the data in use in that stack, in bytes.  */
+#ifdef YYLSP_NEEDED
+      /* This used to be a conditional around just the two extra args,
+	 but that might be undefined if ssl_expr_yyoverflow is a macro.  */
+      ssl_expr_yyoverflow("parser stack overflow",
+		 &ssl_expr_yyss1, size * sizeof (*ssl_expr_yyssp),
+		 &ssl_expr_yyvs1, size * sizeof (*ssl_expr_yyvsp),
+		 &ssl_expr_yyls1, size * sizeof (*ssl_expr_yylsp),
+		 &ssl_expr_yystacksize);
+#else
+      ssl_expr_yyoverflow("parser stack overflow",
+		 &ssl_expr_yyss1, size * sizeof (*ssl_expr_yyssp),
+		 &ssl_expr_yyvs1, size * sizeof (*ssl_expr_yyvsp),
+		 &ssl_expr_yystacksize);
+#endif
+
+      ssl_expr_yyss = ssl_expr_yyss1; ssl_expr_yyvs = ssl_expr_yyvs1;
+#ifdef YYLSP_NEEDED
+      ssl_expr_yyls = ssl_expr_yyls1;
+#endif
+#else /* no ssl_expr_yyoverflow */
+      /* Extend the stack our own way.  */
+      if (ssl_expr_yystacksize >= YYMAXDEPTH)
+	{
+	  ssl_expr_yyerror("parser stack overflow");
+	  if (ssl_expr_yyfree_stacks)
+	    {
+	      free (ssl_expr_yyss);
+	      free (ssl_expr_yyvs);
+#ifdef YYLSP_NEEDED
+	      free (ssl_expr_yyls);
+#endif
+	    }
+	  return 2;
+	}
+      ssl_expr_yystacksize *= 2;
+      if (ssl_expr_yystacksize > YYMAXDEPTH)
+	ssl_expr_yystacksize = YYMAXDEPTH;
+#ifndef YYSTACK_USE_ALLOCA
+      ssl_expr_yyfree_stacks = 1;
+#endif
+      ssl_expr_yyss = (short *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yyssp));
+      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyss, (char *)ssl_expr_yyss1,
+		   size * (unsigned int) sizeof (*ssl_expr_yyssp));
+      ssl_expr_yyvs = (YYSTYPE *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yyvsp));
+      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyvs, (char *)ssl_expr_yyvs1,
+		   size * (unsigned int) sizeof (*ssl_expr_yyvsp));
+#ifdef YYLSP_NEEDED
+      ssl_expr_yyls = (YYLTYPE *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yylsp));
+      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyls, (char *)ssl_expr_yyls1,
+		   size * (unsigned int) sizeof (*ssl_expr_yylsp));
+#endif
+#endif /* no ssl_expr_yyoverflow */
+
+      ssl_expr_yyssp = ssl_expr_yyss + size - 1;
+      ssl_expr_yyvsp = ssl_expr_yyvs + size - 1;
+#ifdef YYLSP_NEEDED
+      ssl_expr_yylsp = ssl_expr_yyls + size - 1;
+#endif
+
+#if YYDEBUG != 0
+      if (ssl_expr_yydebug)
+	fprintf(stderr, "Stack size increased to %d\n", ssl_expr_yystacksize);
+#endif
+
+      if (ssl_expr_yyssp >= ssl_expr_yyss + ssl_expr_yystacksize - 1)
+	YYABORT;
     }
+
+#if YYDEBUG != 0
+  if (ssl_expr_yydebug)
+    fprintf(stderr, "Entering state %d\n", ssl_expr_yystate);
 #endif
 
-    ssl_expr_yynerrs = 0;
-    ssl_expr_yyerrflag = 0;
-    ssl_expr_yychar = (-1);
+  goto ssl_expr_yybackup;
+ ssl_expr_yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* ssl_expr_yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
 
-    if (ssl_expr_yyss == NULL && ssl_expr_yygrowstack()) goto ssl_expr_yyoverflow;
-    ssl_expr_yyssp = ssl_expr_yyss;
-    ssl_expr_yyvsp = ssl_expr_yyvs;
-    *ssl_expr_yyssp = ssl_expr_yystate = 0;
+  ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];
+  if (ssl_expr_yyn == YYFLAG)
+    goto ssl_expr_yydefault;
 
-ssl_expr_yyloop:
-    if ((ssl_expr_yyn = ssl_expr_yydefred[ssl_expr_yystate])) goto ssl_expr_yyreduce;
-    if (ssl_expr_yychar < 0)
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* ssl_expr_yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (ssl_expr_yychar == YYEMPTY)
     {
-        if ((ssl_expr_yychar = ssl_expr_yylex()) < 0) ssl_expr_yychar = 0;
-#if YYDEBUG
-        if (ssl_expr_yydebug)
-        {
-            ssl_expr_yys = 0;
-            if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
-            if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
-            printf("%sdebug: state %d, reading %d (%s)\n",
-                    YYPREFIX, ssl_expr_yystate, ssl_expr_yychar, ssl_expr_yys);
-        }
+#if YYDEBUG != 0
+      if (ssl_expr_yydebug)
+	fprintf(stderr, "Reading a token: ");
 #endif
+      ssl_expr_yychar = YYLEX;
     }
-    if ((ssl_expr_yyn = ssl_expr_yysindex[ssl_expr_yystate]) && (ssl_expr_yyn += ssl_expr_yychar) >= 0 &&
-            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yychar)
+
+  /* Convert token to internal form (in ssl_expr_yychar1) for indexing tables with */
+
+  if (ssl_expr_yychar <= 0)		/* This means end of input. */
     {
-#if YYDEBUG
-        if (ssl_expr_yydebug)
-            printf("%sdebug: state %d, shifting to state %d\n",
-                    YYPREFIX, ssl_expr_yystate, ssl_expr_yytable[ssl_expr_yyn]);
-#endif
-        if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
-        {
-            goto ssl_expr_yyoverflow;
-        }
-        *++ssl_expr_yyssp = ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
-        *++ssl_expr_yyvsp = ssl_expr_yylval;
-        ssl_expr_yychar = (-1);
-        if (ssl_expr_yyerrflag > 0)  --ssl_expr_yyerrflag;
-        goto ssl_expr_yyloop;
+      ssl_expr_yychar1 = 0;
+      ssl_expr_yychar = YYEOF;		/* Don't call YYLEX any more */
+
+#if YYDEBUG != 0
+      if (ssl_expr_yydebug)
+	fprintf(stderr, "Now at end of input.\n");
+#endif
     }
-    if ((ssl_expr_yyn = ssl_expr_yyrindex[ssl_expr_yystate]) && (ssl_expr_yyn += ssl_expr_yychar) >= 0 &&
-            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yychar)
+  else
     {
-        ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];
-        goto ssl_expr_yyreduce;
-    }
-    if (ssl_expr_yyerrflag) goto ssl_expr_yyinrecovery;
-#if defined(lint) || defined(__GNUC__)
-    goto ssl_expr_yynewerror;
+      ssl_expr_yychar1 = YYTRANSLATE(ssl_expr_yychar);
+
+#if YYDEBUG != 0
+      if (ssl_expr_yydebug)
+	{
+	  fprintf (stderr, "Next token is %d (%s", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
+	  /* Give the individual parser a way to print the precise meaning
+	     of a token, for further debugging info.  */
+#ifdef YYPRINT
+	  YYPRINT (stderr, ssl_expr_yychar, ssl_expr_yylval);
 #endif
-ssl_expr_yynewerror:
-    ssl_expr_yyerror("syntax error");
-#if defined(lint) || defined(__GNUC__)
-    goto ssl_expr_yyerrlab;
+	  fprintf (stderr, ")\n");
+	}
 #endif
-ssl_expr_yyerrlab:
-    ++ssl_expr_yynerrs;
-ssl_expr_yyinrecovery:
-    if (ssl_expr_yyerrflag < 3)
-    {
-        ssl_expr_yyerrflag = 3;
-        for (;;)
-        {
-            if ((ssl_expr_yyn = ssl_expr_yysindex[*ssl_expr_yyssp]) && (ssl_expr_yyn += YYERRCODE) >= 0 &&
-                    ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == YYERRCODE)
-            {
-#if YYDEBUG
-                if (ssl_expr_yydebug)
-                    printf("%sdebug: state %d, error recovery shifting\
- to state %d\n", YYPREFIX, *ssl_expr_yyssp, ssl_expr_yytable[ssl_expr_yyn]);
-#endif
-                if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
-                {
-                    goto ssl_expr_yyoverflow;
-                }
-                *++ssl_expr_yyssp = ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
-                *++ssl_expr_yyvsp = ssl_expr_yylval;
-                goto ssl_expr_yyloop;
-            }
-            else
-            {
-#if YYDEBUG
-                if (ssl_expr_yydebug)
-                    printf("%sdebug: error recovery discarding state %d\n",
-                            YYPREFIX, *ssl_expr_yyssp);
-#endif
-                if (ssl_expr_yyssp <= ssl_expr_yyss) goto ssl_expr_yyabort;
-                --ssl_expr_yyssp;
-                --ssl_expr_yyvsp;
-            }
-        }
     }
-    else
+
+  ssl_expr_yyn += ssl_expr_yychar1;
+  if (ssl_expr_yyn < 0 || ssl_expr_yyn > YYLAST || ssl_expr_yycheck[ssl_expr_yyn] != ssl_expr_yychar1)
+    goto ssl_expr_yydefault;
+
+  ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];
+
+  /* ssl_expr_yyn is what to do for this token type in this state.
+     Negative => reduce, -ssl_expr_yyn is rule number.
+     Positive => shift, ssl_expr_yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (ssl_expr_yyn < 0)
     {
-        if (ssl_expr_yychar == 0) goto ssl_expr_yyabort;
-#if YYDEBUG
-        if (ssl_expr_yydebug)
-        {
-            ssl_expr_yys = 0;
-            if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
-            if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
-            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
-                    YYPREFIX, ssl_expr_yystate, ssl_expr_yychar, ssl_expr_yys);
-        }
-#endif
-        ssl_expr_yychar = (-1);
-        goto ssl_expr_yyloop;
+      if (ssl_expr_yyn == YYFLAG)
+	goto ssl_expr_yyerrlab;
+      ssl_expr_yyn = -ssl_expr_yyn;
+      goto ssl_expr_yyreduce;
     }
+  else if (ssl_expr_yyn == 0)
+    goto ssl_expr_yyerrlab;
+
+  if (ssl_expr_yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+
+#if YYDEBUG != 0
+  if (ssl_expr_yydebug)
+    fprintf(stderr, "Shifting token %d (%s), ", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
+#endif
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (ssl_expr_yychar != YYEOF)
+    ssl_expr_yychar = YYEMPTY;
+
+  *++ssl_expr_yyvsp = ssl_expr_yylval;
+#ifdef YYLSP_NEEDED
+  *++ssl_expr_yylsp = ssl_expr_yylloc;
+#endif
+
+  /* count tokens shifted since error; after three, turn off error status.  */
+  if (ssl_expr_yyerrstatus) ssl_expr_yyerrstatus--;
+
+  ssl_expr_yystate = ssl_expr_yyn;
+  goto ssl_expr_yynewstate;
+
+/* Do the default action for the current state.  */
+ssl_expr_yydefault:
+
+  ssl_expr_yyn = ssl_expr_yydefact[ssl_expr_yystate];
+  if (ssl_expr_yyn == 0)
+    goto ssl_expr_yyerrlab;
+
+/* Do a reduction.  ssl_expr_yyn is the number of a rule to reduce with.  */
 ssl_expr_yyreduce:
-#if YYDEBUG
-    if (ssl_expr_yydebug)
-        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
-                YYPREFIX, ssl_expr_yystate, ssl_expr_yyn, ssl_expr_yyrule[ssl_expr_yyn]);
-#endif
-    ssl_expr_yym = ssl_expr_yylen[ssl_expr_yyn];
-    ssl_expr_yyval = ssl_expr_yyvsp[1-ssl_expr_yym];
-    switch (ssl_expr_yyn)
+  ssl_expr_yylen = ssl_expr_yyr2[ssl_expr_yyn];
+  if (ssl_expr_yylen > 0)
+    ssl_expr_yyval = ssl_expr_yyvsp[1-ssl_expr_yylen]; /* implement default value of the action */
+
+#if YYDEBUG != 0
+  if (ssl_expr_yydebug)
     {
+      int i;
+
+      fprintf (stderr, "Reducing via rule %d (line %d), ",
+	       ssl_expr_yyn, ssl_expr_yyrline[ssl_expr_yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (i = ssl_expr_yyprhs[ssl_expr_yyn]; ssl_expr_yyrhs[i] > 0; i++)
+	fprintf (stderr, "%s ", ssl_expr_yytname[ssl_expr_yyrhs[i]]);
+      fprintf (stderr, " -> %s\n", ssl_expr_yytname[ssl_expr_yyr1[ssl_expr_yyn]]);
+    }
+#endif
+
+
+  switch (ssl_expr_yyn) {
+
 case 1:
 #line 115 "ssl_expr_parse.y"
-{ ssl_expr_info.expr = ssl_expr_yyvsp[0].exVal; }
-break;
+{ ssl_expr_info.expr = ssl_expr_yyvsp[0].exVal; ;
+    break;}
 case 2:
 #line 118 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_True,  NULL, NULL); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_True,  NULL, NULL); ;
+    break;}
 case 3:
 #line 119 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_False, NULL, NULL); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_False, NULL, NULL); ;
+    break;}
 case 4:
 #line 120 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_Not,   ssl_expr_yyvsp[0].exVal,   NULL); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_Not,   ssl_expr_yyvsp[0].exVal,   NULL); ;
+    break;}
 case 5:
 #line 121 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_Or,    ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_Or,    ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   ;
+    break;}
 case 6:
 #line 122 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_And,   ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_And,   ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   ;
+    break;}
 case 7:
 #line 123 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_Comp,  ssl_expr_yyvsp[0].exVal,   NULL); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_Comp,  ssl_expr_yyvsp[0].exVal,   NULL); ;
+    break;}
 case 8:
 #line 124 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[-1].exVal; }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[-1].exVal; ;
+    break;}
 case 9:
 #line 127 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_EQ,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_EQ,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
+    break;}
 case 10:
 #line 128 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_NE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_NE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
+    break;}
 case 11:
 #line 129 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_LT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_LT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
+    break;}
 case 12:
 #line 130 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_LE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_LE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
+    break;}
 case 13:
 #line 131 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_GT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_GT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
+    break;}
 case 14:
 #line 132 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_GE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_GE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
+    break;}
 case 15:
 #line 133 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_IN,  ssl_expr_yyvsp[-4].exVal, ssl_expr_yyvsp[-1].exVal); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_IN,  ssl_expr_yyvsp[-4].exVal, ssl_expr_yyvsp[-1].exVal); ;
+    break;}
 case 16:
 #line 134 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_REG, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_REG, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
+    break;}
 case 17:
 #line 135 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_NRE, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_NRE, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
+    break;}
 case 18:
 #line 138 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, NULL); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, NULL); ;
+    break;}
 case 19:
 #line 139 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, ssl_expr_yyvsp[-2].exVal);   }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, ssl_expr_yyvsp[-2].exVal);   ;
+    break;}
 case 20:
 #line 142 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_Digit,  ssl_expr_yyvsp[0].cpVal, NULL); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_Digit,  ssl_expr_yyvsp[0].cpVal, NULL); ;
+    break;}
 case 21:
 #line 143 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_String, ssl_expr_yyvsp[0].cpVal, NULL); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_String, ssl_expr_yyvsp[0].cpVal, NULL); ;
+    break;}
 case 22:
 #line 144 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_make(op_Var,    ssl_expr_yyvsp[-1].cpVal, NULL); }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_make(op_Var,    ssl_expr_yyvsp[-1].cpVal, NULL); ;
+    break;}
 case 23:
 #line 145 "ssl_expr_parse.y"
-{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[0].exVal; }
-break;
+{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[0].exVal; ;
+    break;}
 case 24:
 #line 148 "ssl_expr_parse.y"
 { 
@@ -524,8 +826,8 @@ case 24:
                     regex = NULL;
                 }
                 ssl_expr_yyval.exVal = ssl_expr_make(op_Regex, regex, NULL);
-            }
-break;
+            ;
+    break;}
 case 25:
 #line 158 "ssl_expr_parse.y"
 {
@@ -537,69 +839,243 @@ case 25:
                     regex = NULL;
                 }
                 ssl_expr_yyval.exVal = ssl_expr_make(op_Regex, regex, NULL);
-            }
-break;
+            ;
+    break;}
 case 26:
 #line 170 "ssl_expr_parse.y"
 { 
                ssl_expr *args = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[-1].cpVal, NULL);
                ssl_expr_yyval.exVal = ssl_expr_make(op_Func, "file", args);
-            }
-break;
-#line 550 "y.tab.c"
+            ;
+    break;}
+}
+   /* the action file gets copied in in place of this dollarsign */
+#line 543 "/usr/local/share/bison.simple"
+
+  ssl_expr_yyvsp -= ssl_expr_yylen;
+  ssl_expr_yyssp -= ssl_expr_yylen;
+#ifdef YYLSP_NEEDED
+  ssl_expr_yylsp -= ssl_expr_yylen;
+#endif
+
+#if YYDEBUG != 0
+  if (ssl_expr_yydebug)
+    {
+      short *ssp1 = ssl_expr_yyss - 1;
+      fprintf (stderr, "state stack now");
+      while (ssp1 != ssl_expr_yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+  *++ssl_expr_yyvsp = ssl_expr_yyval;
+
+#ifdef YYLSP_NEEDED
+  ssl_expr_yylsp++;
+  if (ssl_expr_yylen == 0)
+    {
+      ssl_expr_yylsp->first_line = ssl_expr_yylloc.first_line;
+      ssl_expr_yylsp->first_column = ssl_expr_yylloc.first_column;
+      ssl_expr_yylsp->last_line = (ssl_expr_yylsp-1)->last_line;
+      ssl_expr_yylsp->last_column = (ssl_expr_yylsp-1)->last_column;
+      ssl_expr_yylsp->text = 0;
+    }
+  else
+    {
+      ssl_expr_yylsp->last_line = (ssl_expr_yylsp+ssl_expr_yylen-1)->last_line;
+      ssl_expr_yylsp->last_column = (ssl_expr_yylsp+ssl_expr_yylen-1)->last_column;
     }
-    ssl_expr_yyssp -= ssl_expr_yym;
-    ssl_expr_yystate = *ssl_expr_yyssp;
-    ssl_expr_yyvsp -= ssl_expr_yym;
-    ssl_expr_yym = ssl_expr_yylhs[ssl_expr_yyn];
-    if (ssl_expr_yystate == 0 && ssl_expr_yym == 0)
+#endif
+
+  /* Now "shift" the result of the reduction.
+     Determine what state that goes to,
+     based on the state we popped back to
+     and the rule number reduced by.  */
+
+  ssl_expr_yyn = ssl_expr_yyr1[ssl_expr_yyn];
+
+  ssl_expr_yystate = ssl_expr_yypgoto[ssl_expr_yyn - YYNTBASE] + *ssl_expr_yyssp;
+  if (ssl_expr_yystate >= 0 && ssl_expr_yystate <= YYLAST && ssl_expr_yycheck[ssl_expr_yystate] == *ssl_expr_yyssp)
+    ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yystate];
+  else
+    ssl_expr_yystate = ssl_expr_yydefgoto[ssl_expr_yyn - YYNTBASE];
+
+  goto ssl_expr_yynewstate;
+
+ssl_expr_yyerrlab:   /* here on detecting error */
+
+  if (! ssl_expr_yyerrstatus)
+    /* If not already recovering from an error, report this error.  */
+    {
+      ++ssl_expr_yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];
+
+      if (ssl_expr_yyn > YYFLAG && ssl_expr_yyn < YYLAST)
+	{
+	  int size = 0;
+	  char *msg;
+	  int x, count;
+
+	  count = 0;
+	  /* Start X at -ssl_expr_yyn if nec to avoid negative indexes in ssl_expr_yycheck.  */
+	  for (x = (ssl_expr_yyn < 0 ? -ssl_expr_yyn : 0);
+	       x < (sizeof(ssl_expr_yytname) / sizeof(char *)); x++)
+	    if (ssl_expr_yycheck[x + ssl_expr_yyn] == x)
+	      size += strlen(ssl_expr_yytname[x]) + 15, count++;
+	  msg = (char *) malloc(size + 15);
+	  if (msg != 0)
+	    {
+	      strcpy(msg, "parse error");
+
+	      if (count < 5)
+		{
+		  count = 0;
+		  for (x = (ssl_expr_yyn < 0 ? -ssl_expr_yyn : 0);
+		       x < (sizeof(ssl_expr_yytname) / sizeof(char *)); x++)
+		    if (ssl_expr_yycheck[x + ssl_expr_yyn] == x)
+		      {
+			strcat(msg, count == 0 ? ", expecting `" : " or `");
+			strcat(msg, ssl_expr_yytname[x]);
+			strcat(msg, "'");
+			count++;
+		      }
+		}
+	      ssl_expr_yyerror(msg);
+	      free(msg);
+	    }
+	  else
+	    ssl_expr_yyerror ("parse error; also virtual memory exceeded");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	ssl_expr_yyerror("parse error");
+    }
+
+  goto ssl_expr_yyerrlab1;
+ssl_expr_yyerrlab1:   /* here on error raised explicitly by an action */
+
+  if (ssl_expr_yyerrstatus == 3)
     {
-#if YYDEBUG
-        if (ssl_expr_yydebug)
-            printf("%sdebug: after reduction, shifting from state 0 to\
- state %d\n", YYPREFIX, YYFINAL);
-#endif
-        ssl_expr_yystate = YYFINAL;
-        *++ssl_expr_yyssp = YYFINAL;
-        *++ssl_expr_yyvsp = ssl_expr_yyval;
-        if (ssl_expr_yychar < 0)
-        {
-            if ((ssl_expr_yychar = ssl_expr_yylex()) < 0) ssl_expr_yychar = 0;
-#if YYDEBUG
-            if (ssl_expr_yydebug)
-            {
-                ssl_expr_yys = 0;
-                if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
-                if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
-                printf("%sdebug: state %d, reading %d (%s)\n",
-                        YYPREFIX, YYFINAL, ssl_expr_yychar, ssl_expr_yys);
-            }
-#endif
-        }
-        if (ssl_expr_yychar == 0) goto ssl_expr_yyaccept;
-        goto ssl_expr_yyloop;
+      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+
+      /* return failure if at end of input */
+      if (ssl_expr_yychar == YYEOF)
+	YYABORT;
+
+#if YYDEBUG != 0
+      if (ssl_expr_yydebug)
+	fprintf(stderr, "Discarding token %d (%s).\n", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
+#endif
+
+      ssl_expr_yychar = YYEMPTY;
     }
-    if ((ssl_expr_yyn = ssl_expr_yygindex[ssl_expr_yym]) && (ssl_expr_yyn += ssl_expr_yystate) >= 0 &&
-            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yystate)
-        ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
-    else
-        ssl_expr_yystate = ssl_expr_yydgoto[ssl_expr_yym];
-#if YYDEBUG
-    if (ssl_expr_yydebug)
-        printf("%sdebug: after reduction, shifting from state %d \
-to state %d\n", YYPREFIX, *ssl_expr_yyssp, ssl_expr_yystate);
-#endif
-    if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
+
+  /* Else will try to reuse lookahead token
+     after shifting the error token.  */
+
+  ssl_expr_yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto ssl_expr_yyerrhandle;
+
+ssl_expr_yyerrdefault:  /* current state does not do anything special for the error token. */
+
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+  ssl_expr_yyn = ssl_expr_yydefact[ssl_expr_yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
+  if (ssl_expr_yyn) goto ssl_expr_yydefault;
+#endif
+
+ssl_expr_yyerrpop:   /* pop the current state because it cannot handle the error token */
+
+  if (ssl_expr_yyssp == ssl_expr_yyss) YYABORT;
+  ssl_expr_yyvsp--;
+  ssl_expr_yystate = *--ssl_expr_yyssp;
+#ifdef YYLSP_NEEDED
+  ssl_expr_yylsp--;
+#endif
+
+#if YYDEBUG != 0
+  if (ssl_expr_yydebug)
     {
-        goto ssl_expr_yyoverflow;
+      short *ssp1 = ssl_expr_yyss - 1;
+      fprintf (stderr, "Error: state stack now");
+      while (ssp1 != ssl_expr_yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
     }
-    *++ssl_expr_yyssp = ssl_expr_yystate;
-    *++ssl_expr_yyvsp = ssl_expr_yyval;
-    goto ssl_expr_yyloop;
-ssl_expr_yyoverflow:
-    ssl_expr_yyerror("yacc stack overflow");
-ssl_expr_yyabort:
-    return (1);
-ssl_expr_yyaccept:
-    return (0);
+#endif
+
+ssl_expr_yyerrhandle:
+
+  ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];
+  if (ssl_expr_yyn == YYFLAG)
+    goto ssl_expr_yyerrdefault;
+
+  ssl_expr_yyn += YYTERROR;
+  if (ssl_expr_yyn < 0 || ssl_expr_yyn > YYLAST || ssl_expr_yycheck[ssl_expr_yyn] != YYTERROR)
+    goto ssl_expr_yyerrdefault;
+
+  ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];
+  if (ssl_expr_yyn < 0)
+    {
+      if (ssl_expr_yyn == YYFLAG)
+	goto ssl_expr_yyerrpop;
+      ssl_expr_yyn = -ssl_expr_yyn;
+      goto ssl_expr_yyreduce;
+    }
+  else if (ssl_expr_yyn == 0)
+    goto ssl_expr_yyerrpop;
+
+  if (ssl_expr_yyn == YYFINAL)
+    YYACCEPT;
+
+#if YYDEBUG != 0
+  if (ssl_expr_yydebug)
+    fprintf(stderr, "Shifting error token, ");
+#endif
+
+  *++ssl_expr_yyvsp = ssl_expr_yylval;
+#ifdef YYLSP_NEEDED
+  *++ssl_expr_yylsp = ssl_expr_yylloc;
+#endif
+
+  ssl_expr_yystate = ssl_expr_yyn;
+  goto ssl_expr_yynewstate;
+
+ ssl_expr_yyacceptlab:
+  /* YYACCEPT comes here.  */
+  if (ssl_expr_yyfree_stacks)
+    {
+      free (ssl_expr_yyss);
+      free (ssl_expr_yyvs);
+#ifdef YYLSP_NEEDED
+      free (ssl_expr_yyls);
+#endif
+    }
+  return 0;
+
+ ssl_expr_yyabortlab:
+  /* YYABORT comes here.  */
+  if (ssl_expr_yyfree_stacks)
+    {
+      free (ssl_expr_yyss);
+      free (ssl_expr_yyvs);
+#ifdef YYLSP_NEEDED
+      free (ssl_expr_yyls);
+#endif
+    }
+  return 1;
+}
+#line 176 "ssl_expr_parse.y"
+
+
+int ssl_expr_yyerror(char *s)
+{
+    ssl_expr_error = s;
+    return 2;
 }
+
diff --git a/modules/ssl/ssl_expr_parse.h b/modules/ssl/ssl_expr_parse.h
index 618cacb..5378e28 100644
--- a/modules/ssl/ssl_expr_parse.h
+++ b/modules/ssl/ssl_expr_parse.h
@@ -1,29 +1,27 @@
-#ifndef YYERRCODE
-#define YYERRCODE 256
-#endif
-
-#define T_TRUE 257
-#define T_FALSE 258
-#define T_DIGIT 259
-#define T_ID 260
-#define T_STRING 261
-#define T_REGEX 262
-#define T_REGEX_I 263
-#define T_FUNC_FILE 264
-#define T_OP_EQ 265
-#define T_OP_NE 266
-#define T_OP_LT 267
-#define T_OP_LE 268
-#define T_OP_GT 269
-#define T_OP_GE 270
-#define T_OP_REG 271
-#define T_OP_NRE 272
-#define T_OP_IN 273
-#define T_OP_OR 274
-#define T_OP_AND 275
-#define T_OP_NOT 276
 typedef union {
     char     *cpVal;
     ssl_expr *exVal;
 } YYSTYPE;
+#define	T_TRUE	257
+#define	T_FALSE	258
+#define	T_DIGIT	259
+#define	T_ID	260
+#define	T_STRING	261
+#define	T_REGEX	262
+#define	T_REGEX_I	263
+#define	T_FUNC_FILE	264
+#define	T_OP_EQ	265
+#define	T_OP_NE	266
+#define	T_OP_LT	267
+#define	T_OP_LE	268
+#define	T_OP_GT	269
+#define	T_OP_GE	270
+#define	T_OP_REG	271
+#define	T_OP_NRE	272
+#define	T_OP_IN	273
+#define	T_OP_OR	274
+#define	T_OP_AND	275
+#define	T_OP_NOT	276
+
+
 extern YYSTYPE ssl_expr_yylval;
diff --git a/modules/ssl/ssl_expr_scan.c b/modules/ssl/ssl_expr_scan.c
index ddfa2fd..b3e6e1a 100644
--- a/modules/ssl/ssl_expr_scan.c
+++ b/modules/ssl/ssl_expr_scan.c
@@ -18,6 +18,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
+ * $Header: /home/striker/cvs2svn/dumps/httpd-2.0/../../httpd-2.0/modules/ssl/ssl_expr_scan.c,v 1.7 2002/01/10 00:28:00 wrowe Exp $
  */
 
 #define FLEX_SCANNER
@@ -38,6 +39,7 @@
 #ifdef __cplusplus
 
 #include <stdlib.h>
+#include <unistd.h>
 
 /* Use prototypes in function declarations. */
 #define YY_USE_PROTOS
diff --git a/server/mpm/beos/beos.c b/server/mpm/beos/beos.c
index 55bd91a..57d34ef 100644
--- a/server/mpm/beos/beos.c
+++ b/server/mpm/beos/beos.c
@@ -332,7 +332,7 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, int my_child_num)
     conn_rec *current_conn;
     long conn_id = my_child_num;
     int csd;
-    void *sbh;
+    ap_sb_handle_t *sbh;
 
     (void)apr_os_sock_get(&csd, sock);
     
diff --git a/server/mpm/experimental/perchild/perchild.c b/server/mpm/experimental/perchild/perchild.c
index 4fb3244..548c222 100644
--- a/server/mpm/experimental/perchild/perchild.c
+++ b/server/mpm/experimental/perchild/perchild.c
@@ -546,7 +546,7 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
     int csd;
     apr_status_t rv;
     int thread_num = conn_id % thread_limit;
-    void *sbh;
+    ap_sb_handle_t *sbh;
 
     if ((rv = apr_os_sock_get(&csd, sock)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_os_sock_get");
diff --git a/server/mpm/mpmt_os2/mpmt_os2.c b/server/mpm/mpmt_os2/mpmt_os2.c
index d9dc481..e20ecd1 100644
--- a/server/mpm/mpmt_os2/mpmt_os2.c
+++ b/server/mpm/mpmt_os2/mpmt_os2.c
@@ -215,7 +215,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
 
         restart = master_main();
         ++ap_my_generation;
-        ap_scoreboard_image->global.running_generation = ap_my_generation;
+        ap_scoreboard_image->global->running_generation = ap_my_generation;
 
         if (!restart) {
             const char *pidfile = ap_server_root_relative(pconf, ap_pid_fname);
@@ -297,7 +297,8 @@ static char master_main()
 
     /* Allocate shared memory for scoreboard */
     if (ap_scoreboard_image == NULL) {
-        rc = DosAllocSharedMem((PPVOID)&ap_scoreboard_image, ap_scoreboard_fname,
+        void *sb_mem;
+        rc = DosAllocSharedMem((PPVOID)&sbmem, ap_scoreboard_fname,
                                ap_calc_scoreboard_size(),
                                PAG_COMMIT|PAG_READ|PAG_WRITE);
 
@@ -307,7 +308,7 @@ static char master_main()
             return FALSE;
         }
 
-        ap_init_scoreboard();
+        ap_init_scoreboard(sb_mem);
     }
 
     ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, ap_server_conf,
diff --git a/server/mpm/mpmt_os2/mpmt_os2_child.c b/server/mpm/mpmt_os2/mpmt_os2_child.c
index 455cbb4..8ae9702 100644
--- a/server/mpm/mpmt_os2/mpmt_os2_child.c
+++ b/server/mpm/mpmt_os2/mpmt_os2_child.c
@@ -298,7 +298,7 @@ void ap_mpm_child_main(apr_pool_t *pconf)
 
         if (ap_max_requests_per_child != 0 && requests_this_child >= ap_max_requests_per_child)
             break;
-    } while (!shutdown_pending && ap_my_generation == ap_scoreboard_image->global.running_generation);
+    } while (!shutdown_pending && ap_my_generation == ap_scoreboard_image->global->running_generation);
 
     ap_scoreboard_image->parent[child_slot].quiescing = 1;
     DosPostEventSem(shutdown_event);
@@ -404,7 +404,7 @@ static void worker_main(void *vpArg)
     BYTE priority;
     int thread_slot = (int)vpArg;
     EXCEPTIONREGISTRATIONRECORD reg_rec = { NULL, thread_exception_handler };
-    void *sbh;
+    ap_sb_handle_t *sbh;
   
     /* Trap exceptions in this thread so we don't take down the whole process */
     DosSetExceptionHandler( &reg_rec );
diff --git a/server/mpm/netware/mpm_netware.c b/server/mpm/netware/mpm_netware.c
index 222c363..372549c 100644
--- a/server/mpm/netware/mpm_netware.c
+++ b/server/mpm/netware/mpm_netware.c
@@ -333,7 +333,7 @@ static void worker_main(void *arg)
     conn_rec *current_conn;
     apr_status_t stat = APR_EINIT;
     int worker_num_arg = (int)arg;
-    void *sbh;
+    ap_sb_handle_t *sbh;
 
     int my_worker_num = worker_num_arg;
     apr_socket_t *csd = NULL;
@@ -842,7 +842,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
          * use by any of the children.
          */
         ++ap_my_generation;
-        ap_scoreboard_image->global.running_generation = ap_my_generation;
+        ap_scoreboard_image->global->running_generation = ap_my_generation;
         update_scoreboard_global();
 
     	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, ap_server_conf,
diff --git a/server/mpm/perchild/perchild.c b/server/mpm/perchild/perchild.c
index 4fb3244..548c222 100644
--- a/server/mpm/perchild/perchild.c
+++ b/server/mpm/perchild/perchild.c
@@ -546,7 +546,7 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
     int csd;
     apr_status_t rv;
     int thread_num = conn_id % thread_limit;
-    void *sbh;
+    ap_sb_handle_t *sbh;
 
     if ((rv = apr_os_sock_get(&csd, sock)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_os_sock_get");
diff --git a/server/mpm/prefork/prefork.c b/server/mpm/prefork/prefork.c
index 8a697ee..a7d161c 100644
--- a/server/mpm/prefork/prefork.c
+++ b/server/mpm/prefork/prefork.c
@@ -578,7 +578,7 @@ static void child_main(int child_num_arg)
     apr_pollfd_t *pollset;
     int offset;
     void *csd;
-    void *sbh;
+    ap_sb_handle_t *sbh;
 
     my_child_num = child_num_arg;
     ap_my_pid = getpid();
@@ -593,7 +593,7 @@ static void child_main(int child_num_arg)
     apr_pool_create(&ptrans, pchild);
 
     /* needs to be done before we switch UIDs so we have permissions */
-    reopen_scoreboard(pchild);
+    reopen_scoreboard(pchild, 0);
     SAFE_ACCEPT(accept_mutex_child_init(pchild));
 
     if (unixd_setup_child()) {
@@ -1160,7 +1160,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
      * use by any of the children.
      */
     ++ap_my_generation;
-    ap_scoreboard_image->global.running_generation = ap_my_generation;
+    ap_scoreboard_image->global->running_generation = ap_my_generation;
     update_scoreboard_global();
     
     if (is_graceful) {
diff --git a/server/mpm/spmt_os2/spmt_os2.c b/server/mpm/spmt_os2/spmt_os2.c
index a5677d0..1fdc3e8 100644
--- a/server/mpm/spmt_os2/spmt_os2.c
+++ b/server/mpm/spmt_os2/spmt_os2.c
@@ -458,7 +458,7 @@ AP_DECLARE(void) ap_child_terminate(request_rec *r)
 int ap_graceful_stop_signalled(void)
 {
     if (thread_control[THREAD_GLOBAL(thread_num)].deferred_die ||
-	ap_scoreboard_image->global.running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
+	ap_scoreboard_image->global->running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
 	return 1;
     }
     return 0;
@@ -470,7 +470,7 @@ int ap_stop_signalled(void)
 {
     if (shutdown_pending || restart_pending ||
         thread_control[THREAD_GLOBAL(thread_num)].deferred_die ||
-	ap_scoreboard_image->global.running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
+	ap_scoreboard_image->global->running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
 	return 1;
     }
     return 0;
@@ -508,7 +508,7 @@ static void thread_main(void *thread_num_arg)
     apr_pollfd_t *listen_poll;
     apr_socket_t *csd = NULL;
     int nsds, rv;
-    void *sbh;
+    ap_sb_handle_t *sbh;
 
     /* Disable the restart signal handlers and enable the just_die stuff.
      * Note that since restart() just notes that a restart has been
@@ -527,7 +527,7 @@ static void thread_main(void *thread_num_arg)
     *ppthread_globals = (struct thread_globals *)apr_palloc(pchild, sizeof(struct thread_globals));
     THREAD_GLOBAL(thread_num) = (int)thread_num_arg;
     THREAD_GLOBAL(pchild) = pchild;
-    thread_control[THREAD_GLOBAL(thread_num)].generation = ap_scoreboard_image->global.running_generation;
+    thread_control[THREAD_GLOBAL(thread_num)].generation = ap_scoreboard_image->global->running_generation;
     apr_pool_create(&ptrans, pchild);
 
     if (setup_listen_poll(pchild, &listen_poll)) {
@@ -1147,7 +1147,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     /* XXX: we really need to make sure this new generation number isn't in
      * use by any of the children.
      */
-    ++ap_scoreboard_image->global.running_generation;
+    ++ap_scoreboard_image->global->running_generation;
 
     if (is_graceful) {
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, ap_server_conf,
diff --git a/server/mpm/winnt/mpm.h b/server/mpm/winnt/mpm.h
index e6f66dd..a86b31c 100644
--- a/server/mpm/winnt/mpm.h
+++ b/server/mpm/winnt/mpm.h
@@ -71,6 +71,7 @@
 #define AP_MPM_WANT_SET_PIDFILE
 #define AP_MPM_WANT_SET_MAX_REQUESTS
 #define AP_MPM_WANT_SET_COREDUMPDIR
+#define AP_MPM_WANT_SET_SCOREBOARD
 
 extern int ap_threads_per_child;
 extern server_rec *ap_server_conf;
diff --git a/server/mpm/winnt/mpm_winnt.c b/server/mpm/winnt/mpm_winnt.c
index b006abc..a6fb5ed 100644
--- a/server/mpm/winnt/mpm_winnt.c
+++ b/server/mpm/winnt/mpm_winnt.c
@@ -887,7 +887,7 @@ static void worker_main(int thread_num)
     static int requests_this_child = 0;
     PCOMP_CONTEXT context = NULL;
     apr_os_sock_info_t sockinfo;
-    void *sbh;
+    ap_sb_handle_t *sbh;
 
     while (1) {
         conn_rec *c;
@@ -2019,22 +2019,22 @@ AP_DECLARE(int) ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
         ap_log_error(APLOG_MARK, APLOG_INFO, APR_SUCCESS, ap_server_conf,
                      "Child %d: Child process is running", my_pid);
 
-        /* Set up the scoreboard. */
-        ap_run_pre_mpm(pconf, SB_NOT_SHARED);
-        /* Humm... Should we put the parent pid here? Does it matter 
-         * since the scoreboard is not shared?
-         */
-        ap_scoreboard_image->parent[0].pid = parent_pid;
-        ap_scoreboard_image->parent[0].quiescing = 0;
         if (one_process) {
+            /* Set up the scoreboard. */
+            ap_run_pre_mpm(pconf, SB_NOT_SHARED);
             if (ap_setup_listeners(ap_server_conf) < 1) {
                 return 1;
             }
         }
         else {
+            /* Set up the scoreboard. */
+            ap_run_pre_mpm(pconf, SB_SHARED_CHILD);
             ap_my_generation = atoi(getenv("AP_MY_GENERATION"));
             get_listeners_from_parent(ap_server_conf);
         }
+        ap_scoreboard_image->parent[0].pid = parent_pid;
+        ap_scoreboard_image->parent[0].quiescing = 0;
+            
         if (!set_listeners_noninheritable(pconf)) {
             return 1;
         }
@@ -2045,6 +2045,9 @@ AP_DECLARE(int) ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
         return 1;
     }
     else { 
+        /* Set up the scoreboard. */
+        ap_run_pre_mpm(pconf, SB_SHARED);
+
         /* Parent process */
         if (ap_setup_listeners(ap_server_conf) < 1) {
             ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, s,
diff --git a/server/mpm/worker/worker.c b/server/mpm/worker/worker.c
index 2a10529..4d01e91 100644
--- a/server/mpm/worker/worker.c
+++ b/server/mpm/worker/worker.c
@@ -542,7 +542,7 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, int my_child_num,
     conn_rec *current_conn;
     long conn_id = ID_FROM_CHILD_THREAD(my_child_num, my_thread_num);
     int csd;
-    void *sbh;
+    ap_sb_handle_t *sbh;
 
     ap_create_sb_handle(&sbh, p, my_child_num, my_thread_num);
     apr_os_sock_get(&csd, sock);
@@ -903,7 +903,7 @@ static void child_main(int child_num_arg)
     apr_pool_create(&pchild, pconf);
 
     /*stuff to do before we switch id's, so we have permissions.*/
-    reopen_scoreboard(pchild);
+    reopen_scoreboard(pchild, 0);
 
     rv = SAFE_ACCEPT(apr_proc_mutex_child_init(&accept_mutex, ap_lock_fname,
                                                pchild));
@@ -1502,7 +1502,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
      * use by any of the children.
      */
     ++ap_my_generation;
-    ap_scoreboard_image->global.running_generation = ap_my_generation;
+    ap_scoreboard_image->global->running_generation = ap_my_generation;
     update_scoreboard_global();
     
     /* wake up the children...time to die.  But we'll have more soon */
diff --git a/server/mpm_common.c b/server/mpm_common.c
index 0b452da..999ccf3 100644
--- a/server/mpm_common.c
+++ b/server/mpm_common.c
@@ -535,14 +535,13 @@ const char *ap_mpm_set_pidfile(cmd_parms *cmd, void *dummy,
 #endif
 
 #ifdef AP_MPM_WANT_SET_SCOREBOARD
-AP_DECLARE(const char *) ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
-					       const char *arg)
+const char * ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
+                                   const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
     }
-
     ap_scoreboard_fname = arg;
     return NULL;
 }
@@ -550,8 +549,8 @@ AP_DECLARE(const char *) ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
 
 #ifdef AP_MPM_WANT_SET_LOCKFILE
 const char *ap_lock_fname = NULL;
-AP_DECLARE(const char *) ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
-					     const char *arg)
+const char *ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
+                                const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
diff --git a/server/scoreboard.c b/server/scoreboard.c
index ce443d5..d196e56 100644
--- a/server/scoreboard.c
+++ b/server/scoreboard.c
@@ -85,8 +85,8 @@ AP_DECLARE_DATA int ap_extended_status = 0;
 AP_DECLARE_DATA apr_time_t ap_restart_time = 0;
 
 #if APR_HAS_SHARED_MEMORY
-#include "apr_shmem.h"
-static apr_shmem_t *scoreboard_shm = NULL;
+#include "apr_shm.h"
+static apr_shm_t *scoreboard_shm = NULL;
 #endif
 
 APR_HOOK_STRUCT(
@@ -97,10 +97,10 @@ AP_IMPLEMENT_HOOK_VOID(pre_mpm,
                        (apr_pool_t *p, ap_scoreboard_e sb_type),
                        (p, sb_type))
 
-typedef struct sb_handle {
+struct ap_sb_handle_t {
     int child_num;
     int thread_num;
-} sb_handle;
+};
 
 static int server_limit, thread_limit;
 static apr_size_t scoreboard_size;
@@ -116,7 +116,7 @@ static apr_size_t scoreboard_size;
 static apr_status_t ap_cleanup_shared_mem(void *d)
 {
 #if APR_HAS_SHARED_MEMORY
-    apr_shm_free(scoreboard_shm, ap_scoreboard_image);
+    free(ap_scoreboard_image);
     ap_scoreboard_image = NULL;
     apr_shm_destroy(scoreboard_shm);
 #endif
@@ -127,119 +127,151 @@ int ap_calc_scoreboard_size(void)
 {
     ap_mpm_query(AP_MPMQ_HARD_LIMIT_THREADS, &thread_limit);
     ap_mpm_query(AP_MPMQ_HARD_LIMIT_DAEMONS, &server_limit);
-    scoreboard_size = sizeof(scoreboard);
+    scoreboard_size = sizeof(global_score);
     scoreboard_size += sizeof(process_score) * server_limit;
-    scoreboard_size += sizeof(worker_score * ) * server_limit;
     scoreboard_size += sizeof(worker_score) * server_limit * thread_limit;
     return scoreboard_size;
 }
 
-void ap_init_scoreboard(void)
+void ap_init_scoreboard(void *shared_score)
 {
     char *more_storage;
     int i;
 
-    memset(ap_scoreboard_image, 0, scoreboard_size);
-    more_storage = (char *)(ap_scoreboard_image + 1);
+    ap_scoreboard_image = 
+        calloc(1, sizeof(scoreboard) + server_limit * sizeof(worker_score *));
+    more_storage = shared_score;
+    ap_scoreboard_image->global = (global_score *)more_storage;
+    more_storage += sizeof(global_score);
     ap_scoreboard_image->parent = (process_score *)more_storage;
     more_storage += sizeof(process_score) * server_limit;
-    ap_scoreboard_image->servers = (worker_score **)more_storage;
-    more_storage += server_limit * sizeof(worker_score *);
-
+    ap_scoreboard_image->servers = 
+        (worker_score **)((char*)ap_scoreboard_image + sizeof(scoreboard));
     for (i = 0; i < server_limit; i++) {
         ap_scoreboard_image->servers[i] = (worker_score *)more_storage;
         more_storage += thread_limit * sizeof(worker_score);
     }
-    ap_assert(more_storage == (char *)ap_scoreboard_image + scoreboard_size);
+    ap_assert(more_storage == (char*)shared_score + scoreboard_size);
 }
 
 /* ToDo: This function should be made to handle setting up 
  * a scoreboard shared between processes using any IPC technique, 
  * not just a shared memory segment
  */
-static apr_status_t setup_shared(apr_pool_t *p)
+static apr_status_t open_scoreboard(apr_pool_t *p)
 {
 #if APR_HAS_SHARED_MEMORY
-    const char *fname;
     apr_status_t rv;
+    char *fname = NULL;
 
-    fname = ap_server_root_relative(p, ap_scoreboard_fname);
-    rv = apr_shm_init(&scoreboard_shm, scoreboard_size, fname, p);
+    if (ap_scoreboard_fname) {
+        fname = ap_server_root_relative(p, ap_scoreboard_fname);
+    }
+    rv = apr_shm_create(&scoreboard_shm, scoreboard_size, fname, p);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                      "Fatal error: could not open(create) scoreboard");
         return rv;
     }
-    ap_scoreboard_image = apr_shm_malloc(scoreboard_shm, scoreboard_size);
-    if (ap_scoreboard_image == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT | APLOG_NOERRNO, 0, NULL,
-                     "Fatal error: cannot allocate scoreboard");
-        apr_shm_destroy(scoreboard_shm);
-        return APR_EGENERAL;
-    }
     /* everything will be cleared shortly */
 #endif
     return APR_SUCCESS;
 }
 
-AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p)
+/* If detach is non-zero, this is a seperate child process,
+ * if zero, it is a forked child.
+ */
+apr_status_t reopen_scoreboard(apr_pool_t *p, int detached)
 {
+#if APR_HAS_SHARED_MEMORY
+    apr_status_t rv;
+    char *fname = NULL;
+
+    if (!detached) {
+        return APR_SUCCESS;
+    }
+    if (ap_scoreboard_fname) {
+        fname = ap_server_root_relative(p, ap_scoreboard_fname);
+    }
+    rv = apr_shm_attach(&scoreboard_shm, fname, p);
+    if (rv != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+                     "Fatal error: could not open(create) scoreboard");
+        return rv;
+    }
+    if (apr_shm_size_get(scoreboard_shm) < scoreboard_size) {
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+                     "Fatal error: shared scoreboard too small for child!");
+        apr_shm_detach(scoreboard_shm);
+        scoreboard_shm = NULL;
+    }
+    /* everything will be cleared shortly */
+#endif
+    return APR_SUCCESS;
 }
 
-/* ap_cleanup_scoreboard
- * 
- */
 apr_status_t ap_cleanup_scoreboard(void *d) {
     if (ap_scoreboard_image == NULL)
         return APR_SUCCESS;
-    if (ap_scoreboard_image->global.sb_type == SB_SHARED) {
+    if (ap_scoreboard_image->global->sb_type == SB_SHARED) {
         ap_cleanup_shared_mem(NULL);
     }
     else {
+        free(ap_scoreboard_image->global);
         free(ap_scoreboard_image);
         ap_scoreboard_image = NULL;
     }
     return APR_SUCCESS;
 }
 
-/* ap_create_scoreboard(apr_pool_t*, ap_scoreboard_e t)
- *
- * Create or reinit an existing scoreboard. The MPM can control whether
+/* Create or reinit an existing scoreboard. The MPM can control whether
  * the scoreboard is shared across multiple processes or not
- *
- * ###: Is there any reason to export this symbol in the first place?
  */
-AP_DECLARE_NONSTD(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
+void ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
 {
     int running_gen = 0;
     apr_status_t rv;
 
     if (ap_scoreboard_image)
-	running_gen = ap_scoreboard_image->global.running_generation;
+	running_gen = ap_scoreboard_image->global->running_generation;
     if (ap_scoreboard_image == NULL) {
         ap_calc_scoreboard_size();
         if (sb_type == SB_SHARED) {
-            rv = setup_shared(p);
-            if (rv) {
+            void *sb_shared;
+            rv = open_scoreboard(p);
+            if (rv || !(sb_shared = apr_shm_baseaddr_get(scoreboard_shm))) {
                 exit(APEXIT_INIT); /* XXX need to return an error from this function */
             }
+            memset(sb_shared, 0, scoreboard_size);
+            ap_init_scoreboard(sb_shared);
+        }
+        else if (sb_type == SB_SHARED_CHILD) {
+            void *sb_shared;
+            rv = reopen_scoreboard(p, 1);
+            if (rv || !(sb_shared = apr_shm_baseaddr_get(scoreboard_shm))) {
+                exit(APEXIT_INIT); /* XXX need to return an error from this function */
+            }
+            ap_init_scoreboard(sb_shared);
         }
         else {
             /* A simple malloc will suffice */
-            ap_scoreboard_image = (scoreboard *) malloc(scoreboard_size);
-            if (ap_scoreboard_image == NULL) {
+            void *sb_mem = calloc(1, scoreboard_size);
+            if (sb_mem == NULL) {
                 ap_log_error(APLOG_MARK, APLOG_CRIT | APLOG_NOERRNO, 0, NULL,
                              "(%d)%s: cannot allocate scoreboard",
                              errno, strerror(errno));
                 exit(APEXIT_INIT); /* XXX need to return an error from this function */
             }
+            ap_init_scoreboard(sb_mem);
         }
     }
-    ap_init_scoreboard(); /* can't just memset() */
-    ap_scoreboard_image->global.sb_type = sb_type;
-    ap_scoreboard_image->global.running_generation = running_gen;
-    ap_restart_time = apr_time_now();
-    apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
+    /* can't just memset() */
+    if (sb_type != SB_SHARED_CHILD) {
+        ap_scoreboard_image->global->sb_type = sb_type;
+        ap_scoreboard_image->global->running_generation = running_gen;
+        ap_restart_time = apr_time_now();
+        apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
+    }
 }
 
 /* Routines called to deal with the scoreboard image
@@ -263,11 +295,12 @@ AP_DECLARE(int) ap_exists_scoreboard_image(void)
 }
 
 static APR_INLINE void put_scoreboard_info(int child_num, int thread_num, 
-				       worker_score *new_score_rec)
+				           worker_score *new_score_rec)
 {
     /* XXX - needs to be fixed to account for threads */
 #ifdef SCOREBOARD_FILE
-    lseek(scoreboard_fd, (long) child_num * sizeof(worker_score), 0);
+    lseek(scoreboard_fd, sizeof(global_score) 
+                       + (long) child_num * sizeof(worker_score), 0);
     force_write(scoreboard_fd, new_score_rec, sizeof(worker_score));
 #endif
 }
@@ -275,16 +308,14 @@ static APR_INLINE void put_scoreboard_info(int child_num, int thread_num,
 void update_scoreboard_global(void)
 {
 #ifdef SCOREBOARD_FILE
-    lseek(scoreboard_fd,
-	  (char *) &ap_scoreboard_image->global -(char *) ap_scoreboard_image, 0);
+    lseek(scoreboard_fd, 0, 0);
     force_write(scoreboard_fd, &ap_scoreboard_image->global,
 		sizeof ap_scoreboard_image->global);
 #endif
 }
 
-AP_DECLARE(void) ap_increment_counts(void *sbh, request_rec *r)
+AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)
 {
-    sb_handle *sb = sbh;
     worker_score *ws;
 
     ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];
@@ -316,21 +347,18 @@ AP_DECLARE(int) find_child_by_pid(apr_proc_t *pid)
     return -1;
 }
 
-AP_DECLARE(void) ap_create_sb_handle(void **new_handle, apr_pool_t *p,
+AP_DECLARE(void) ap_create_sb_handle(ap_sb_handle_t **new_sbh, apr_pool_t *p,
                                      int child_num, int thread_num)
 {
-    sb_handle *sbh;
-
-    sbh = (sb_handle *)apr_palloc(p, sizeof *sbh);
-    *new_handle = sbh;
-    sbh->child_num = child_num;
-    sbh->thread_num = thread_num;
+    *new_sbh = (ap_sb_handle_t *)apr_palloc(p, sizeof(ap_sb_handle_t));
+    (*new_sbh)->child_num = child_num;
+    (*new_sbh)->thread_num = thread_num;
 }
 
 AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num, int thread_num,
                                                     int status, request_rec *r)
 {
-    int old_status, i;
+    int old_status;
     worker_score *ws;
     process_score *ps;
 
@@ -346,12 +374,7 @@ AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num, int thread_nu
     if (status == SERVER_READY
 	&& old_status == SERVER_STARTING) {
         ws->thread_num = child_num * server_limit + thread_num;
-        if (ps->generation != ap_my_generation) {
-            for (i = 0; i < thread_limit; i++) {
-                ap_scoreboard_image->servers[child_num][i].vhostrec = NULL;
-            }
-            ps->generation = ap_my_generation;
-        }
+        ps->generation = ap_my_generation;
     }
 
     if (ap_extended_status) {
@@ -382,7 +405,7 @@ AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num, int thread_nu
 					       r->assbackwards ? NULL : " ", r->protocol, NULL),
 				       sizeof(ws->request));
 	    }
-	    ws->vhostrec =  r->server;
+	    apr_cpystrn(ws->vhost, r->server->server_hostname, sizeof(ws->vhost));
 	}
     }
     
@@ -390,11 +413,9 @@ AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num, int thread_nu
     return old_status;
 }
 
-AP_DECLARE(int)ap_update_child_status(void *sbh, int status, request_rec *r)
+AP_DECLARE(int)ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r)
 {
-    sb_handle *sb = sbh;
-    
-    return ap_update_child_status_from_indexes(sb->child_num, sb->thread_num,
+    return ap_update_child_status_from_indexes(sbh->child_num, sbh->thread_num,
                                                status, r);
 }
 
@@ -416,7 +437,7 @@ void ap_time_process_request(int child_num, int thread_num, int status)
     put_scoreboard_info(child_num, thread_num, ws);
 }
 
-AP_DECLARE(worker_score *) ap_get_servers_scoreboard(int x, int y)
+AP_DECLARE(worker_score *) ap_get_scoreboard_worker(int x, int y)
 {
     if (((x < 0) || (server_limit < x)) ||
         ((y < 0) || (thread_limit < y))) {
@@ -425,7 +446,7 @@ AP_DECLARE(worker_score *) ap_get_servers_scoreboard(int x, int y)
     return(&ap_scoreboard_image->servers[x][y]);
 }
 
-AP_DECLARE(process_score *) ap_get_parent_scoreboard(int x)
+AP_DECLARE(process_score *) ap_get_scoreboard_process(int x)
 {
     if ((x < 0) || (server_limit < x)) {
         return(NULL); /* Out of range */
@@ -433,7 +454,7 @@ AP_DECLARE(process_score *) ap_get_parent_scoreboard(int x)
     return(&ap_scoreboard_image->parent[x]);
 }
 
-AP_DECLARE(global_score *) ap_get_global_scoreboard()
+AP_DECLARE(global_score *) ap_get_scoreboard_global()
 {
-    return(&ap_scoreboard_image->global);
+    return(ap_scoreboard_image->global);
 }
