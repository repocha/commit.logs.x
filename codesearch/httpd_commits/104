commit 10b900a16c51d99bf10e5c0d013cffbb2dc4163a
Author: Daniel Earl Poirier <poirier@apache.org>
Date:   Sat Oct 30 17:56:13 2010 +0000

    Fix a number of typos and misspellings.  Reported by Ville Skytta.
    PR48496.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1029134 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/ROADMAP b/ROADMAP
index 44de676..4c80780 100644
--- a/ROADMAP
+++ b/ROADMAP
@@ -191,7 +191,7 @@ MAKING APACHE REPOSITORY-AGNOSTIC
       than calling apr_dir_open/read/close(), a caller uses
       resource->repos->get_children() or somesuch.
 
-      Note that things like mod_dir, mod_autoindex, and mod_negotation
+      Note that things like mod_dir, mod_autoindex, and mod_negotiation
       need to be converted to use these mechanisms so that their
       functions will work on logical repositories rather than just
       filesystems.
diff --git a/docs/manual/caching.xml b/docs/manual/caching.xml
index f99af8a..a77b73d 100644
--- a/docs/manual/caching.xml
+++ b/docs/manual/caching.xml
@@ -510,7 +510,7 @@ sys     0m0.000s</pre>
 
       <p>Additionally, because the operating system knows when files are 
       deleted or modified, it can automatically remove file contents from the 
-      cache when neccessary. This is a big advantage over httpd's in-memory 
+      cache when necessary. This is a big advantage over httpd's in-memory 
       caching which has no way of knowing when a file has changed.</p>
     </section>
 
diff --git a/docs/manual/content-negotiation.xml b/docs/manual/content-negotiation.xml
index 306b9b7..c1464c0 100644
--- a/docs/manual/content-negotiation.xml
+++ b/docs/manual/content-negotiation.xml
@@ -180,7 +180,7 @@
     represents.</p>
 
     <p>The full list of headers recognized is available in the <a
-    href="mod/mod_negotiation.html#typemaps">mod_negotation
+    href="mod/mod_negotiation.html#typemaps">mod_negotiation
     typemap</a> documentation.</p>
 </section>
 
diff --git a/docs/manual/mod/mod_file_cache.xml b/docs/manual/mod/mod_file_cache.xml
index 78609e6..b279cb5 100644
--- a/docs/manual/mod/mod_file_cache.xml
+++ b/docs/manual/mod/mod_file_cache.xml
@@ -76,7 +76,7 @@
       directive of <module>mod_file_cache</module> maps a list of
       statically configured files into memory through the system call
       <code>mmap()</code>. This system call is available on most modern
-      Unix derivates, but not on all. There are sometimes system-specific
+      Unix derivatives, but not on all. There are sometimes system-specific
       limits on the size and number of files that can be
       <code>mmap()</code>ed, experimentation is probably the easiest way
       to find out.</p>
diff --git a/docs/manual/mod/mod_mime.xml b/docs/manual/mod/mod_mime.xml
index d9091a1..ca37507 100644
--- a/docs/manual/mod/mod_mime.xml
+++ b/docs/manual/mod/mod_mime.xml
@@ -599,7 +599,7 @@ a matching file with MultiViews</description>
 
     <p>The <code>NegotiatedOnly</code> option provides that every extension
     following the base name must correlate to a recognized
-    <module>mod_mime</module> extension for content negotation, <em>e.g.</em>
+    <module>mod_mime</module> extension for content negotiation, <em>e.g.</em>
     Charset, Content-Type, Language, or Encoding.  This is the strictest
     implementation with the fewest unexpected side effects, and is the
     default behavior.</p>
diff --git a/docs/manual/mod/mod_negotiation.xml b/docs/manual/mod/mod_negotiation.xml
index c11cae3..4d9ef1c 100644
--- a/docs/manual/mod/mod_negotiation.xml
+++ b/docs/manual/mod/mod_negotiation.xml
@@ -209,7 +209,7 @@ found</description>
     <p>The <directive>ForceLanguagePriority</directive> directive uses
     the given <directive
     module="mod_negotiation">LanguagePriority</directive> to satisfy
-    negotation where the server could otherwise not return a single
+    negotiation where the server could otherwise not return a single
     matching document.</p>
 
     <p><code>ForceLanguagePriority Prefer</code> uses
diff --git a/docs/manual/mod/mod_ssl.xml b/docs/manual/mod/mod_ssl.xml
index 403193e..3123589 100644
--- a/docs/manual/mod/mod_ssl.xml
+++ b/docs/manual/mod/mod_ssl.xml
@@ -31,7 +31,7 @@ Layer (SSL) and Transport Layer Security (TLS) protocols</description>
 
 <summary>
 <p>This module provides SSL v2/v3 and TLS v1 support for the Apache
-HTTP Server.  It was contributed by Ralf S. Engeschall based on his
+HTTP Server.  It was contributed by Ralf S. Engelschall based on his
 mod_ssl project and originally derived from work by Ben Laurie.</p>
 
 <p>This module relies on <a href="http://www.openssl.org/">OpenSSL</a>
@@ -326,7 +326,7 @@ The following <em>source</em> variants are available:</p>
     consumes minimum CPU cycles under runtime and hence can be always used
     without drawbacks. The source used for seeding the PRNG contains of the
     current time, the current process id and (when applicable) a randomly
-    choosen 1KB extract of the inter-process scoreboard structure of Apache.
+    chosen 1KB extract of the inter-process scoreboard structure of Apache.
     The drawback is that this is not really a strong source and at startup
     time (where the scoreboard is still not available) this source just
     produces a few bytes of entropy. So you should always, at least for the
@@ -342,7 +342,7 @@ The following <em>source</em> variants are available:</p>
     the first argument). Use this especially at startup time, for instance
     with an available <code>/dev/random</code> and/or
     <code>/dev/urandom</code> devices (which usually exist on modern Unix
-    derivates like FreeBSD and Linux).</p>
+    derivatives like FreeBSD and Linux).</p>
     <p>
     <em>But be careful</em>: Usually <code>/dev/random</code> provides only as
     much entropy data as it actually has, i.e. when you request 512 bytes of
@@ -415,7 +415,7 @@ OpenSSL already caches the SSL session information locally. But because modern
 clients request inlined images and other data via parallel requests (usually
 up to four parallel requests are common) those requests are served by
 <em>different</em> pre-forked server processes. Here an inter-process cache
-helps to avoid unneccessary session handshakes.</p>
+helps to avoid unnecessary session handshakes.</p>
 <p>
 The following four storage <em>type</em>s are currently supported:</p>
 <ul>
@@ -614,7 +614,7 @@ consisting of OpenSSL cipher specifications to configure the Cipher Suite the
 client is permitted to negotiate in the SSL handshake phase. Notice that this
 directive can be used both in per-server and per-directory context. In
 per-server context it applies to the standard SSL handshake when a connection
-is established. In per-directory context it forces a SSL renegotation with the
+is established. In per-directory context it forces a SSL renegotiation with the
 reconfigured Cipher Suite after the HTTP request was read but before the HTTP
 response is sent.</p>
 <p>
@@ -634,7 +634,7 @@ attributes plus a few extra minor ones:</p>
     MD5, SHA or SHA1.
 </li>
 </ul>
-<p>An SSL cipher can also be an export cipher and is either a SSLv2 or SSLv3/TLSv1
+<p>An SSL cipher can also be an export cipher and is either an SSLv2 or SSLv3/TLSv1
 cipher (here TLSv1 is equivalent to SSLv3). To specify which ciphers to use,
 one can either specify all the Ciphers, one at a time, or use aliases to
 specify the preference and order for the ciphers (see <a href="#table1">Table
@@ -1035,7 +1035,7 @@ This directive sets the Certificate verification level for the Client
 Authentication. Notice that this directive can be used both in per-server and
 per-directory context. In per-server context it applies to the client
 authentication process used in the standard SSL handshake when a connection is
-established. In per-directory context it forces a SSL renegotation with the
+established. In per-directory context it forces a SSL renegotiation with the
 reconfigured client verification level after the HTTP request was read but
 before the HTTP response is sent.</p>
 <p>
@@ -1081,7 +1081,7 @@ clients don't have a valid certificate. Notice that this directive can be
 used both in per-server and per-directory context. In per-server context it
 applies to the client authentication process used in the standard SSL
 handshake when a connection is established. In per-directory context it forces
-a SSL renegotation with the reconfigured client verification depth after the
+a SSL renegotiation with the reconfigured client verification depth after the
 HTTP request was read but before the HTTP response is sent.</p>
 <p>
 The depth actually is the maximum number of intermediate certificate issuers,
@@ -1461,7 +1461,7 @@ verification of the remote server.  Notice that this directive can be
 used both in per-server and per-directory context. In per-server
 context it applies to the remote server authentication process used in
 the standard SSL handshake when a connection is established by the
-proxy. In per-directory context it forces a SSL renegotation with the
+proxy. In per-directory context it forces a SSL renegotiation with the
 reconfigured remote server verification level after the HTTP request
 was read but before the HTTP response is sent.</p>
 
@@ -1508,7 +1508,7 @@ remote server does not have a valid certificate. Notice that this directive can
 used both in per-server and per-directory context. In per-server context it
 applies to the client authentication process used in the standard SSL
 handshake when a connection is established. In per-directory context it forces
-a SSL renegotation with the reconfigured remote server verification depth after the
+a SSL renegotiation with the reconfigured remote server verification depth after the
 HTTP request was read but before the HTTP response is sent.</p>
 <p>
 The depth actually is the maximum number of intermediate certificate issuers,
diff --git a/docs/manual/programs/configure.xml b/docs/manual/programs/configure.xml
index a63d12e..f05f2f9 100644
--- a/docs/manual/programs/configure.xml
+++ b/docs/manual/programs/configure.xml
@@ -212,7 +212,7 @@
         <dd>Install the system administrator executables in <var>DIR</var>.
           Those are server programs like <program>httpd</program>,
           <program>apachectl</program>, <program>suexec</program>, etc. which
-          are neccessary to run the Apache HTTP Server. By default
+          are necessary to run the Apache HTTP Server. By default
           <code>sbindir</code> is set to
           <code><var>EPREFIX</var>/sbin</code>.</dd>
 
diff --git a/modules/aaa/mod_auth_digest.c b/modules/aaa/mod_auth_digest.c
index ba7f10b..e88eba5 100644
--- a/modules/aaa/mod_auth_digest.c
+++ b/modules/aaa/mod_auth_digest.c
@@ -1340,7 +1340,7 @@ static void note_digest_auth_failure(request_rec *r,
 
     /* setup domain attribute. We want to send this attribute wherever
      * possible so that the client won't send the Authorization header
-     * unneccessarily (it's usually > 200 bytes!).
+     * unnecessarily (it's usually > 200 bytes!).
      */
 
 
diff --git a/modules/arch/netware/mod_nw_ssl.c b/modules/arch/netware/mod_nw_ssl.c
index 690de8d..20707d3 100644
--- a/modules/arch/netware/mod_nw_ssl.c
+++ b/modules/arch/netware/mod_nw_ssl.c
@@ -364,7 +364,7 @@ static int convert_secure_socket(conn_rec *c, apr_socket_t *csd)
                      sizeof(struct tlsclientopts), NULL, 0, NULL,
                      NULL, NULL);
 
-    /* make sure that it was successfull */
+    /* make sure that it was successful */
         if(SOCKET_ERROR == rcode ){
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server,
                      "Error: %d with ioctl (SO_TLS_SET_CLIENT)", WSAGetLastError());
diff --git a/modules/arch/win32/mod_isapi.h b/modules/arch/win32/mod_isapi.h
index 33524bc..44c845b 100644
--- a/modules/arch/win32/mod_isapi.h
+++ b/modules/arch/win32/mod_isapi.h
@@ -128,7 +128,7 @@ typedef struct HSE_SEND_HEADER_EX_INFO {
  * not passed, and a completion context was defined, we will invoke the
  * completion function immediately following the transfer, and then
  * return to the caller.  If HSE_IO_SYNC is passed, there is no call
- * neccessary to the completion context.
+ * necessary to the completion context.
  */
 #define HSE_IO_SYNC  1
 #define HSE_IO_ASYNC 2
diff --git a/modules/http/mod_mime.c b/modules/http/mod_mime.c
index 0ecd25f..6277daa 100644
--- a/modules/http/mod_mime.c
+++ b/modules/http/mod_mime.c
@@ -867,7 +867,7 @@ static int find_ct(request_rec *r)
                 found = 1;
             }
             /* The following extensions are not 'Found'.  That is, they don't
-             * make any contribution to metadata negotation, so they must have
+             * make any contribution to metadata negotiation, so they must have
              * been explicitly requested by name.
              */
             if (exinfo->handler && r->proxyreq == PROXYREQ_NONE) {
diff --git a/modules/proxy/mod_proxy.h b/modules/proxy/mod_proxy.h
index 86c33b2..ddef166 100644
--- a/modules/proxy/mod_proxy.h
+++ b/modules/proxy/mod_proxy.h
@@ -543,7 +543,7 @@ PROXY_DECLARE(proxy_worker *) ap_proxy_get_worker(apr_pool_t *p,
  * @param conf   current proxy server configuration
  * @param url    url containing worker name
  * @param id     slotnumber id or -1 for auto allocation
- * @return       error message or NULL if successfull
+ * @return       error message or NULL if successful
  */
 PROXY_DECLARE(const char *) ap_proxy_add_worker_wid(proxy_worker **worker,
                                                 apr_pool_t *p,
@@ -557,7 +557,7 @@ PROXY_DECLARE(const char *) ap_proxy_add_worker_wid(proxy_worker **worker,
  * @param p      memory pool to allocate worker from 
  * @param conf   current proxy server configuration
  * @param url    url containing worker name
- * @return       error message or NULL if successfull
+ * @return       error message or NULL if successful
  */
 PROXY_DECLARE(const char *) ap_proxy_add_worker(proxy_worker **worker,
                                                 apr_pool_t *p,
diff --git a/modules/proxy/proxy_util.c b/modules/proxy/proxy_util.c
index 320ec5a..8dbebb6 100644
--- a/modules/proxy/proxy_util.c
+++ b/modules/proxy/proxy_util.c
@@ -1766,7 +1766,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_ssl_connection_cleanup(proxy_conn_rec *conn
 
     /*
      * If we have an existing SSL connection it might be possible that the
-     * server sent some SSL message we have not read so far (e.g. a SSL
+     * server sent some SSL message we have not read so far (e.g. an SSL
      * shutdown message if the server closed the keepalive connection while
      * the connection was held unused in our pool).
      * So ensure that if present (=> APR_NONBLOCK_READ) it is read and
diff --git a/modules/ssl/ssl_engine_io.c b/modules/ssl/ssl_engine_io.c
index e5ac041..e64fd3b 100644
--- a/modules/ssl/ssl_engine_io.c
+++ b/modules/ssl/ssl_engine_io.c
@@ -684,7 +684,7 @@ static apr_status_t ssl_io_input_read(bio_filter_in_ctx_t *inctx,
                  * data from network filter.
                  *
                  * (This is usually the case when the client forces an SSL
-                 * renegotation which is handled implicitly by OpenSSL.)
+                 * renegotiation which is handled implicitly by OpenSSL.)
                  */
                 inctx->rc = APR_EAGAIN;
 
@@ -814,7 +814,7 @@ static apr_status_t ssl_filter_write(ap_filter_t *f,
              * data at the network filter.
              *
              * (This is usually the case when the client forces an SSL
-             * renegotation which is handled implicitly by OpenSSL.)
+             * renegotiation which is handled implicitly by OpenSSL.)
              */
             outctx->rc = APR_EAGAIN;
         }
diff --git a/modules/ssl/ssl_engine_kernel.c b/modules/ssl/ssl_engine_kernel.c
index 1fa0d4b..c374ce0 100644
--- a/modules/ssl/ssl_engine_kernel.c
+++ b/modules/ssl/ssl_engine_kernel.c
@@ -524,7 +524,7 @@ int ssl_hook_Access(request_rec *r)
      * Additionally the following optimization is possible here: When the
      * currently active verify type is "none" but a client certificate is
      * already known/present, it's enough to manually force a client
-     * verification but at least skip the I/O-intensive renegotation
+     * verification but at least skip the I/O-intensive renegotiation
      * handshake.
      */
     if ((dc->nVerifyClient != SSL_CVERIFY_UNSET) ||
@@ -664,7 +664,7 @@ int ssl_hook_Access(request_rec *r)
      */
     if (renegotiate) {
         /*
-         * Now we force the SSL renegotation by sending the Hello Request
+         * Now we force the SSL renegotiation by sending the Hello Request
          * message to the client. Here we have to do a workaround: Actually
          * OpenSSL returns immediately after sending the Hello Request (the
          * intent AFAIK is because the SSL/TLS protocol says it's not a must
@@ -2114,7 +2114,7 @@ static void log_tracing_state(MODSSL_INFO_CB_ARG_TYPE ssl, conn_rec *c,
     }
 
     /*
-     * Because SSL renegotations can happen at any time (not only after
+     * Because SSL renegotiations can happen at any time (not only after
      * SSL_accept()), the best way to log the current connection details is
      * right after a finished handshake.
      */
