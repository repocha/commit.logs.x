commit 5f9700c0c4f866689e5ee492a6d7314f6cf9b0ef
Author: William A. Rowe Jr <wrowe@apache.org>
Date:   Fri Jan 19 07:04:36 2001 +0000

      The big change.  This is part 3 of the apr-util symbols rename, please
      see the first commit of srclib/apr-util/include (cvs apr-util/include)
      for the quick glance at symbols changed.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@87731 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/Apache.dsw b/Apache.dsw
index 074451f..9505d28 100644
--- a/Apache.dsw
+++ b/Apache.dsw
@@ -182,6 +182,12 @@ Package=<5>
 
 Package=<4>
 {{{
+    Begin Project Dependency
+    Project_Dep_Name apr
+    End Project Dependency
+    Begin Project Dependency
+    Project_Dep_Name aprutil
+    End Project Dependency
 }}}
 
 ###############################################################################
diff --git a/include/ap_config.h b/include/ap_config.h
index 9601ec7..3c876e9 100644
--- a/include/ap_config.h
+++ b/include/ap_config.h
@@ -57,7 +57,7 @@
 
 #include "ap_mmn.h"		/* MODULE_MAGIC_NUMBER_ */
 #include "apr_lib.h"		/* apr_isfoo() macros */
-#include "ap_hooks.h"
+#include "apr_hooks.h"
 
 /**
  * AP_DECLARE_EXPORT is defined when building the Apache Core dynamic
@@ -133,15 +133,11 @@
 #define AP_MODULE_DECLARE_DATA __declspec(dllexport)
 #endif
 
-/* XXX: Must go away, perhaps into compat, maybe not even there.
- */
-#define MODULE_VAR_EXPORT    AP_MODULE_DECLARE_DATA
-
 #define AP_DECLARE_HOOK(ret,name,args) \
-AP_DECLARE_EXTERNAL_HOOK(AP,ret,name,args)
+APR_DECLARE_EXTERNAL_HOOK(ap,AP,ret,name,args)
 
 #define AP_IMPLEMENT_HOOK_BASE(name) \
-AP_IMPLEMENT_EXTERNAL_HOOK_BASE(AP,name)
+APR_IMPLEMENT_EXTERNAL_HOOK_BASE(ap,AP,name)
 
 /**
  * Implement an Apache core hook that has no return code, and therefore 
@@ -151,10 +147,10 @@ AP_IMPLEMENT_EXTERNAL_HOOK_BASE(AP,name)
  * @param args_used The names for the arguments for the hook
  * @deffunc void AP_IMPLEMENT_HOOK_VOID(name, args_decl, args_use)
  * @tip If IMPLEMENTing a hook that is not linked into the Apache core,
- * (e.g. within a dso) see AP_IMPLEMENT_EXTERNAL_HOOK_HOOK_VOID.
+ * (e.g. within a dso) see APR_IMPLEMENT_EXTERNAL_HOOK_HOOK_VOID.
  */
 #define AP_IMPLEMENT_HOOK_VOID(name,args_decl,args_use) \
-AP_IMPLEMENT_EXTERNAL_HOOK_VOID(AP,name,args_decl,args_use)
+APR_IMPLEMENT_EXTERNAL_HOOK_VOID(ap,AP,name,args_decl,args_use)
 
 /**
  * Implement an Apache core hook that runs until one of the functions 
@@ -164,10 +160,10 @@ AP_IMPLEMENT_EXTERNAL_HOOK_VOID(AP,name,args_decl,args_use)
  * @param args_used The names for the arguments for the hook
  * @deffunc int AP_IMPLEMENT_HOOK_RUN_ALL(name, args_decl, args_use)
  * @tip If IMPLEMENTing a hook that is not linked into the Apache core,
- * (e.g. within a dso) see AP_IMPLEMENT_EXTERNAL_HOOK_RUN_ALL.
+ * (e.g. within a dso) see APR_IMPLEMENT_EXTERNAL_HOOK_RUN_ALL.
  */
 #define AP_IMPLEMENT_HOOK_RUN_ALL(ret,name,args_decl,args_use,ok,decline) \
-AP_IMPLEMENT_EXTERNAL_HOOK_RUN_ALL(AP,ret,name,args_decl,args_use,ok,decline)
+APR_IMPLEMENT_EXTERNAL_HOOK_RUN_ALL(ap,AP,ret,name,args_decl,args_use,ok,decline)
 
 /**
  * Implement a hook that runs until the first function returns something
@@ -177,10 +173,10 @@ AP_IMPLEMENT_EXTERNAL_HOOK_RUN_ALL(AP,ret,name,args_decl,args_use,ok,decline)
  * @param args_used The names for the arguments for the hook
  * @deffunc int AP_IMPLEMENT_HOOK_RUN_FIRST(name, args_decl, args_use)
  * @tip If IMPLEMENTing a hook that is not linked into the Apache core
- * (e.g. within a dso) see AP_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST.
+ * (e.g. within a dso) see APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST.
  */
 #define AP_IMPLEMENT_HOOK_RUN_FIRST(ret,name,args_decl,args_use,decline) \
-AP_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(AP,ret,name,args_decl,args_use,decline)
+APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(ap,AP,ret,name,args_decl,args_use,decline)
 
 #ifdef WIN32
 #include "os.h"
diff --git a/include/ap_mmn.h b/include/ap_mmn.h
index 355fc95..32b8d47 100644
--- a/include/ap_mmn.h
+++ b/include/ap_mmn.h
@@ -221,11 +221,11 @@
  * 19990320.3           - add ap_regexec() and ap_regerror()
  * 19990320.4           - add ap_field_noparam()
  * 19990320.5           - add local_ip/host to conn_rec for mass-vhost
- * 19990320.6           - add ap_SHA1Final(), ap_SHA1Init(),
- *                        ap_SHA1Update_binary(), ap_SHA1Update(),
- *                        ap_base64encode(), ap_base64encode_binary(),
- *                        ap_base64encode_len(), ap_base64decode(),
- *                        ap_base64decode_binary(), ap_base64decode_len(),
+ * 19990320.6           - add apr_SHA1Final(), apr_SHA1Init(),
+ *                        apr_SHA1Update_binary(), apr_SHA1Update(),
+ *                        apr_base64encode(), apr_base64encode_binary(),
+ *                        apr_base64encode_len(), apr_base64decode(),
+ *                        apr_base64decode_binary(), apr_base64decode_len(),
  *                        ap_pbase64decode(), ap_pbase64encode()
  */
 
diff --git a/include/http_config.h b/include/http_config.h
index f16cb3c..dac23df 100644
--- a/include/http_config.h
+++ b/include/http_config.h
@@ -59,7 +59,7 @@
 #ifndef APACHE_HTTP_CONFIG_H
 #define APACHE_HTTP_CONFIG_H
 
-#include "ap_hooks.h"
+#include "apr_hooks.h"
 #include "util_cfgtree.h"
 
 #ifdef __cplusplus
diff --git a/include/http_connection.h b/include/http_connection.h
index f7a8803..8f0d226 100644
--- a/include/http_connection.h
+++ b/include/http_connection.h
@@ -55,7 +55,7 @@
 #ifndef APACHE_HTTP_CONNECTION_H
 #define APACHE_HTTP_CONNECTION_H
 
-#include "ap_hooks.h"
+#include "apr_hooks.h"
 #include "apr_network_io.h"
 
 #ifdef __cplusplus
diff --git a/include/http_core.h b/include/http_core.h
index 1846344..d1ea4af 100644
--- a/include/http_core.h
+++ b/include/http_core.h
@@ -333,7 +333,7 @@ extern AP_DECLARE_DATA module core_module;
 typedef struct {
     /* bucket brigade used by getline for look-ahead and 
      * ap_get_client_block for holding left-over request body */
-    struct ap_bucket_brigade *bb;
+    struct apr_bucket_brigade *bb;
 } core_request_config;
 
 /* Per-directory configuration */
diff --git a/include/http_protocol.h b/include/http_protocol.h
index b7a33d9..225f870 100644
--- a/include/http_protocol.h
+++ b/include/http_protocol.h
@@ -59,11 +59,11 @@
 #ifndef APACHE_HTTP_PROTOCOL_H
 #define APACHE_HTTP_PROTOCOL_H
 
-#include "ap_hooks.h"
+#include "apr_hooks.h"
 #include "apr_portable.h"
 #include "apr_mmap.h"
 #include "util_filter.h"
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -103,10 +103,10 @@ AP_DECLARE(void) ap_basic_http_header(request_rec *r, char *buf);
  */
 AP_DECLARE(void) ap_send_http_header(request_rec *l);
 
-AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(ap_filter_t *f, ap_bucket_brigade *b);
-AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f, ap_bucket_brigade *b);
+AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(ap_filter_t *f, apr_bucket_brigade *b);
+AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f, apr_bucket_brigade *b);
 AP_CORE_DECLARE_NONSTD(apr_status_t) ap_content_length_filter(ap_filter_t *, 
-                                                              ap_bucket_brigade *);
+                                                              apr_bucket_brigade *);
 
 /* Send the response to special method requests */
 
@@ -516,8 +516,8 @@ AP_DECLARE(int) ap_method_number_of(const char *method);
  */
 AP_DECLARE(const char *) ap_method_name_of(int methnum);
 
-apr_status_t ap_http_filter(ap_filter_t *f, ap_bucket_brigade *b, ap_input_mode_t mode);
-apr_status_t ap_dechunk_filter(ap_filter_t *f, ap_bucket_brigade *b, ap_input_mode_t mode);
+apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b, ap_input_mode_t mode);
+apr_status_t ap_dechunk_filter(ap_filter_t *f, apr_bucket_brigade *b, ap_input_mode_t mode);
 
 
   /* Hooks */
diff --git a/include/http_request.h b/include/http_request.h
index fb81011..0dbf428 100644
--- a/include/http_request.h
+++ b/include/http_request.h
@@ -59,7 +59,7 @@
 #ifndef APACHE_HTTP_REQUEST_H
 #define APACHE_HTTP_REQUEST_H
 
-#include "ap_hooks.h"
+#include "apr_hooks.h"
 #include "util_filter.h"
 
 #ifdef __cplusplus
@@ -137,10 +137,10 @@ AP_DECLARE(request_rec *) ap_sub_req_method_uri(const char *method,
  * has to be inserted at the end of a sub-requests filter stack.
  * @param f The current filter
  * @param bb The brigade to filter
- * @deffuc apr_status_t ap_sub_req_output_filter(ap_filter_t *f, ap_bucket_brigade *bb)
+ * @deffuc apr_status_t ap_sub_req_output_filter(ap_filter_t *f, apr_bucket_brigade *bb)
  */
 AP_CORE_DECLARE_NONSTD(apr_status_t) ap_sub_req_output_filter(ap_filter_t *f,
-                                                        ap_bucket_brigade *bb);
+                                                        apr_bucket_brigade *bb);
 
 /**
  * Run the handler for the sub request
diff --git a/include/util_filter.h b/include/util_filter.h
index cfd82ce..1777b1e 100644
--- a/include/util_filter.h
+++ b/include/util_filter.h
@@ -65,7 +65,7 @@ extern "C" {
 
 #include "httpd.h"
 #include "apr.h"
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 
 /**
  * @package Apache filter library
@@ -150,8 +150,8 @@ typedef struct ap_filter_t ap_filter_t;
  *
  * The return value of a filter should be an APR status value.
  */
-typedef apr_status_t (*ap_out_filter_func)(ap_filter_t *f, ap_bucket_brigade *b);
-typedef apr_status_t (*ap_in_filter_func)(ap_filter_t *f, ap_bucket_brigade *b, 
+typedef apr_status_t (*ap_out_filter_func)(ap_filter_t *f, apr_bucket_brigade *b);
+typedef apr_status_t (*ap_in_filter_func)(ap_filter_t *f, apr_bucket_brigade *b, 
                                           ap_input_mode_t mode);
 typedef union ap_filter_func {
     ap_out_filter_func out_func;
@@ -280,9 +280,9 @@ struct ap_filter_t {
  * @param bucket The current bucket brigade
  * @param mode   AP_MODE_BLOCKING, AP_MODE_NONBLOCKING, or AP_MODE_PEEK
  * @return apr_status_t value
- * @deffunc apr_status_t ap_get_brigade(ap_filter_t *filter, ap_bucket_brigade *bucket, ap_input_mode_t mode)
+ * @deffunc apr_status_t ap_get_brigade(ap_filter_t *filter, apr_bucket_brigade *bucket, ap_input_mode_t mode)
  */
-AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *filter, ap_bucket_brigade *bucket, 
+AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *filter, apr_bucket_brigade *bucket, 
                                         ap_input_mode_t mode);
 
 /**
@@ -292,9 +292,9 @@ AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *filter, ap_bucket_brigade *
  * @param filter The next filter in the chain
  * @param bucket The current bucket brigade
  * @return apr_status_t value
- * @deffunc apr_status_t ap_pass_brigade(ap_filter_t *filter, ap_bucket_brigade *bucket)
+ * @deffunc apr_status_t ap_pass_brigade(ap_filter_t *filter, apr_bucket_brigade *bucket)
  */
-AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter, ap_bucket_brigade *bucket);
+AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter, apr_bucket_brigade *bucket);
 
 /*
  * ap_register_input_filter():
@@ -399,10 +399,10 @@ AP_DECLARE(void) ap_remove_output_filter(ap_filter_t *f);
  *             new bucket brigade is returned in this location.
  * @param b The bucket brigade to save aside.  This brigade is always empty
  *          on return
- * @deffunc apr_status_t ap_save_brigade(ap_filter_t *f, ap_bucket_brigade **save_to, ap_bucket_brigade **b)
+ * @deffunc apr_status_t ap_save_brigade(ap_filter_t *f, apr_bucket_brigade **save_to, apr_bucket_brigade **b)
  */
-AP_DECLARE(apr_status_t) ap_save_brigade(ap_filter_t *f, ap_bucket_brigade **save_to,
-                                         ap_bucket_brigade **b);    
+AP_DECLARE(apr_status_t) ap_save_brigade(ap_filter_t *f, apr_bucket_brigade **save_to,
+                                         apr_bucket_brigade **b);    
 
 #ifdef __cplusplus
 }
diff --git a/modules/aaa/mod_access.c b/modules/aaa/mod_access.c
index 1e7f705..1e19955 100644
--- a/modules/aaa/mod_access.c
+++ b/modules/aaa/mod_access.c
@@ -408,7 +408,7 @@ static int check_dir_access(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_access_checker(check_dir_access,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_access_checker(check_dir_access,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA access_module =
diff --git a/modules/aaa/mod_auth.c b/modules/aaa/mod_auth.c
index 0fd9ba6..e3b61af 100644
--- a/modules/aaa/mod_auth.c
+++ b/modules/aaa/mod_auth.c
@@ -320,8 +320,8 @@ static int check_user_access(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_check_user_id(authenticate_basic_user,NULL,NULL,AP_HOOK_MIDDLE);
-    ap_hook_auth_checker(check_user_access,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_check_user_id(authenticate_basic_user,NULL,NULL,APR_HOOK_MIDDLE);
+    ap_hook_auth_checker(check_user_access,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA auth_module =
diff --git a/modules/aaa/mod_auth_anon.c b/modules/aaa/mod_auth_anon.c
index ec69551..04e971f 100644
--- a/modules/aaa/mod_auth_anon.c
+++ b/modules/aaa/mod_auth_anon.c
@@ -297,8 +297,8 @@ static int check_anon_access(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_check_user_id(anon_authenticate_basic_user,NULL,NULL,AP_HOOK_MIDDLE);
-    ap_hook_auth_checker(check_anon_access,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_check_user_id(anon_authenticate_basic_user,NULL,NULL,APR_HOOK_MIDDLE);
+    ap_hook_auth_checker(check_anon_access,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA anon_auth_module =
diff --git a/modules/aaa/mod_auth_db.c b/modules/aaa/mod_auth_db.c
index 610b14a..d755c8b 100644
--- a/modules/aaa/mod_auth_db.c
+++ b/modules/aaa/mod_auth_db.c
@@ -397,8 +397,8 @@ static int db_check_auth(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_check_user_id(db_authenticate_basic_user,NULL,NULL,AP_HOOK_MIDDLE);
-    ap_hook_auth_checker(db_check_auth,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_check_user_id(db_authenticate_basic_user,NULL,NULL,APR_HOOK_MIDDLE);
+    ap_hook_auth_checker(db_check_auth,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module db_auth_module =
diff --git a/modules/aaa/mod_auth_dbm.c b/modules/aaa/mod_auth_dbm.c
index 8b8048b..e8edb73 100644
--- a/modules/aaa/mod_auth_dbm.c
+++ b/modules/aaa/mod_auth_dbm.c
@@ -337,8 +337,8 @@ static int dbm_check_auth(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_check_user_id(dbm_authenticate_basic_user, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_auth_checker(dbm_check_auth, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_check_user_id(dbm_authenticate_basic_user, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_auth_checker(dbm_check_auth, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA dbm_auth_module =
diff --git a/modules/aaa/mod_auth_digest.c b/modules/aaa/mod_auth_digest.c
index edd95d9..720894e 100644
--- a/modules/aaa/mod_auth_digest.c
+++ b/modules/aaa/mod_auth_digest.c
@@ -108,8 +108,8 @@
 #include "http_protocol.h"
 #include "util_uri.h"
 #include "util_md5.h"
-#include "ap_sha1.h"
-#include "ap_base64.h"
+#include "apr_sha1.h"
+#include "apr_base64.h"
 #include "apr_lib.h"
 #include "apr_time.h"
 #include "apr_errno.h"
@@ -162,7 +162,7 @@ typedef struct digest_config_struct {
     const char  *grpfile;
     const char  *realm;
     const char **qop_list;
-    AP_SHA1_CTX  nonce_ctx;
+    apr_sha1_ctx_t  nonce_ctx;
     apr_time_t    nonce_lifetime;
     const char  *nonce_format;
     int          check_nc;
@@ -179,7 +179,7 @@ typedef struct digest_config_struct {
 
 
 #define NONCE_TIME_LEN	(((sizeof(apr_time_t)+2)/3)*4)
-#define NONCE_HASH_LEN	(2*SHA_DIGESTSIZE)
+#define NONCE_HASH_LEN	(2*APR_SHA1_DIGESTSIZE)
 #define NONCE_LEN	(NONCE_TIME_LEN + NONCE_HASH_LEN)
 
 #define	SECRET_LEN	20
@@ -475,9 +475,9 @@ static const char *set_realm(cmd_parms *cmd, void *config, const char *realm)
      * the host:port would be too, but that varies for .htaccess files
      * and directives outside a virtual host section)
      */
-    ap_SHA1Init(&conf->nonce_ctx);
-    ap_SHA1Update_binary(&conf->nonce_ctx, secret, sizeof(secret));
-    ap_SHA1Update_binary(&conf->nonce_ctx, (const unsigned char *) realm,
+    apr_SHA1Init(&conf->nonce_ctx);
+    apr_SHA1Update_binary(&conf->nonce_ctx, secret, sizeof(secret));
+    apr_SHA1Update_binary(&conf->nonce_ctx, (const unsigned char *) realm,
 			 strlen(realm));
 
     return DECLINE_CMD;
@@ -986,24 +986,24 @@ static void gen_nonce_hash(char *hash, const char *timestr, const char *opaque,
 			   const digest_config_rec *conf)
 {
     const char *hex = "0123456789abcdef";
-    unsigned char sha1[SHA_DIGESTSIZE];
-    AP_SHA1_CTX ctx;
+    unsigned char sha1[APR_SHA1_DIGESTSIZE];
+    apr_sha1_ctx_t ctx;
     int idx;
 
     memcpy(&ctx, &conf->nonce_ctx, sizeof(ctx));
     /*
-    ap_SHA1Update_binary(&ctx, (const unsigned char *) server->server_hostname,
+    apr_SHA1Update_binary(&ctx, (const unsigned char *) server->server_hostname,
 			 strlen(server->server_hostname));
-    ap_SHA1Update_binary(&ctx, (const unsigned char *) &server->port,
+    apr_SHA1Update_binary(&ctx, (const unsigned char *) &server->port,
 			 sizeof(server->port));
      */
-    ap_SHA1Update_binary(&ctx, (const unsigned char *) timestr, strlen(timestr));
+    apr_SHA1Update_binary(&ctx, (const unsigned char *) timestr, strlen(timestr));
     if (opaque)
-	ap_SHA1Update_binary(&ctx, (const unsigned char *) opaque,
+	apr_SHA1Update_binary(&ctx, (const unsigned char *) opaque,
 			     strlen(opaque));
-    ap_SHA1Final(sha1, &ctx);
+    apr_SHA1Final(sha1, &ctx);
 
-    for (idx=0; idx<SHA_DIGESTSIZE; idx++) {
+    for (idx=0; idx<APR_SHA1_DIGESTSIZE; idx++) {
 	*hash++ = hex[sha1[idx] >> 4];
 	*hash++ = hex[sha1[idx] & 0xF];
     }
@@ -1031,7 +1031,7 @@ static const char *gen_nonce(apr_pool_t *p, apr_time_t now, const char *opaque,
 	t.time = (*otn_counter)++;
     else
 	t.time = 42;
-    len = ap_base64encode_binary(nonce, t.arr, sizeof(t.arr));
+    len = apr_base64encode_binary(nonce, t.arr, sizeof(t.arr));
     gen_nonce_hash(nonce+NONCE_TIME_LEN, nonce, opaque, server, conf);
 
     return nonce;
@@ -1408,7 +1408,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
 
     tmp = resp->nonce[NONCE_TIME_LEN];
     resp->nonce[NONCE_TIME_LEN] = '\0';
-    len = ap_base64decode_binary(nonce_time.arr, resp->nonce);
+    len = apr_base64decode_binary(nonce_time.arr, resp->nonce);
     gen_nonce_hash(hash, resp->nonce, resp->opaque, r->server, conf);
     resp->nonce[NONCE_TIME_LEN] = tmp;
     resp->nonce_time = nonce_time.time;
@@ -2054,12 +2054,12 @@ static void register_hooks(apr_pool_t *p)
     static const char * const cfgPost[]={ "http_core.c", NULL };
     static const char * const parsePre[]={ "mod_proxy.c", NULL };
 
-    ap_hook_post_config(initialize_module, NULL, cfgPost, AP_HOOK_MIDDLE);
-    ap_hook_child_init(initialize_child, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_post_read_request(parse_hdr_and_update_nc, parsePre, NULL, AP_HOOK_MIDDLE);
-    ap_hook_check_user_id(authenticate_digest_user, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_auth_checker(digest_check_auth, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_fixups(add_auth_info, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_post_config(initialize_module, NULL, cfgPost, APR_HOOK_MIDDLE);
+    ap_hook_child_init(initialize_child, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_post_read_request(parse_hdr_and_update_nc, parsePre, NULL, APR_HOOK_MIDDLE);
+    ap_hook_check_user_id(authenticate_digest_user, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_auth_checker(digest_check_auth, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_fixups(add_auth_info, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA digest_auth_module =
diff --git a/modules/arch/win32/mod_isapi.c b/modules/arch/win32/mod_isapi.c
index 54a9e8d..543fff8 100644
--- a/modules/arch/win32/mod_isapi.c
+++ b/modules/arch/win32/mod_isapi.c
@@ -77,7 +77,7 @@
 
 #include "apr_strings.h"
 #include "apr_portable.h"
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 #include "ap_config.h"
 #include "httpd.h"
 #include "http_config.h"
@@ -648,17 +648,17 @@ BOOL WINAPI WriteClient (HCONN ConnID, LPVOID Buffer, LPDWORD lpwdwBytes,
                          DWORD dwReserved)
 {
     request_rec *r = ((isapi_cid *)ConnID)->r;
-    ap_bucket_brigade *bb;
-    ap_bucket *b;
+    apr_bucket_brigade *bb;
+    apr_bucket *b;
 
     if (dwReserved == HSE_IO_SYNC)
         ; /* XXX: Fake it */
 
-    bb = ap_brigade_create(r->pool);
-    b = ap_bucket_create_transient(Buffer, (apr_size_t)lpwdwBytes);
-    AP_BRIGADE_INSERT_TAIL(bb, b);
-    b = ap_bucket_create_eos();
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(r->pool);
+    b = apr_bucket_create_transient(Buffer, (apr_size_t)lpwdwBytes);
+    APR_BRIGADE_INSERT_TAIL(bb, b);
+    b = apr_bucket_create_eos();
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 
     return TRUE;
@@ -796,14 +796,14 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             return FALSE;
         }
         else if (ate < headlen) {
-            ap_bucket_brigade *bb;
-            ap_bucket *b;
-            bb = ap_brigade_create(cid->r->pool);
-	    b = ap_bucket_create_transient((char*) lpdwDataType + ate, 
+            apr_bucket_brigade *bb;
+            apr_bucket *b;
+            bb = apr_brigade_create(cid->r->pool);
+	    b = apr_bucket_create_transient((char*) lpdwDataType + ate, 
                                            headlen - ate);
-	    AP_BRIGADE_INSERT_TAIL(bb, b);
-            b = ap_bucket_create_eos();
-	    AP_BRIGADE_INSERT_TAIL(bb, b);
+	    APR_BRIGADE_INSERT_TAIL(bb, b);
+            b = apr_bucket_create_eos();
+	    APR_BRIGADE_INSERT_TAIL(bb, b);
 	    ap_pass_brigade(cid->r->output_filters, bb);
         }
         return TRUE;
@@ -885,8 +885,8 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
     {
         HSE_TF_INFO *tf = (HSE_TF_INFO*)lpvBuffer;
         apr_status_t rv;
-        ap_bucket_brigade *bb;
-        ap_bucket *b;
+        apr_bucket_brigade *bb;
+        apr_bucket *b;
         apr_file_t *fd;
 
         if (!cid->isa->fakeasync && (tf->dwFlags & HSE_IO_ASYNC)) {
@@ -903,7 +903,7 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
         }
         
         /* apr_dupfile_oshandle (&fd, tf->hFile, r->pool); */
-        bb = ap_brigade_create(r->pool);
+        bb = apr_brigade_create(r->pool);
 
         if (tf->dwFlags & HSE_IO_SEND_HEADERS) 
         {
@@ -922,35 +922,35 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
                                                  (apr_size_t)tf->HeadLength);
             if (ate < 0)
             {
-                ap_brigade_destroy(bb);
+                apr_brigade_destroy(bb);
                 SetLastError(TODO_ERROR);
                 return FALSE;
             }
             if (ate < (apr_size_t)tf->HeadLength)
             {
-                b = ap_bucket_create_transient((char*)tf->pHead + ate, 
+                b = apr_bucket_create_transient((char*)tf->pHead + ate, 
                                             (apr_size_t)tf->HeadLength - ate);
-                AP_BRIGADE_INSERT_TAIL(bb, b);
+                APR_BRIGADE_INSERT_TAIL(bb, b);
             }
         }
         else if (tf->pHead && tf->HeadLength) {
-            b = ap_bucket_create_transient((char*)tf->pHead, 
+            b = apr_bucket_create_transient((char*)tf->pHead, 
                                            (apr_size_t)tf->HeadLength);
-            AP_BRIGADE_INSERT_TAIL(bb, b);
+            APR_BRIGADE_INSERT_TAIL(bb, b);
         }
 
-        b = ap_bucket_create_file(fd, (apr_off_t)tf->Offset, 
+        b = apr_bucket_create_file(fd, (apr_off_t)tf->Offset, 
                                   (apr_size_t)tf->BytesToWrite);
-        AP_BRIGADE_INSERT_TAIL(bb, b);
+        APR_BRIGADE_INSERT_TAIL(bb, b);
         
         if (tf->pTail && (apr_size_t)tf->TailLength) {
-            b = ap_bucket_create_transient((char*)tf->pTail, 
+            b = apr_bucket_create_transient((char*)tf->pTail, 
                                            (apr_size_t)tf->TailLength);
-            AP_BRIGADE_INSERT_TAIL(bb, b);
+            APR_BRIGADE_INSERT_TAIL(bb, b);
         }
         
-        b = ap_bucket_create_eos();
-        AP_BRIGADE_INSERT_TAIL(bb, b);
+        b = apr_bucket_create_eos();
+        APR_BRIGADE_INSERT_TAIL(bb, b);
         ap_pass_brigade(r->output_filters, bb);
 
         /* we do nothing with (tf->dwFlags & HSE_DISCONNECT_AFTER_SEND)
@@ -1099,14 +1099,14 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             return FALSE;
         }
         else if (ate < (apr_off_t)shi->cchHeader) {
-            ap_bucket_brigade *bb;
-            ap_bucket *b;
-            bb = ap_brigade_create(cid->r->pool);
-	    b = ap_bucket_create_transient(shi->pszHeader + ate, 
+            apr_bucket_brigade *bb;
+            apr_bucket *b;
+            bb = apr_brigade_create(cid->r->pool);
+	    b = apr_bucket_create_transient(shi->pszHeader + ate, 
                                            (apr_size_t)shi->cchHeader - ate);
-	    AP_BRIGADE_INSERT_TAIL(bb, b);
-            b = ap_bucket_create_eos();
-	    AP_BRIGADE_INSERT_TAIL(bb, b);
+	    APR_BRIGADE_INSERT_TAIL(bb, b);
+            b = apr_bucket_create_eos();
+	    APR_BRIGADE_INSERT_TAIL(bb, b);
 	    ap_pass_brigade(cid->r->output_filters, bb);
         }
         return TRUE;
@@ -1266,8 +1266,8 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
 
 static void isapi_hooks(apr_pool_t *cont)
 {
-    ap_hook_post_config(isapi_post_config, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_handler(isapi_handler, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_post_config(isapi_post_config, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_handler(isapi_handler, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 static const command_rec isapi_cmds[] = {
diff --git a/modules/cache/mod_file_cache.c b/modules/cache/mod_file_cache.c
index c853332..ed78b65 100644
--- a/modules/cache/mod_file_cache.c
+++ b/modules/cache/mod_file_cache.c
@@ -501,13 +501,13 @@ AP_INIT_ITERATE("mmapfile", mmapfile, NULL, RSRC_CONF,
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_handler(file_cache_handler, NULL, NULL, AP_HOOK_LAST);
-    ap_hook_post_config(file_cache_post_config, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_translate_name(file_cache_xlat, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_handler(file_cache_handler, NULL, NULL, APR_HOOK_LAST);
+    ap_hook_post_config(file_cache_post_config, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_translate_name(file_cache_xlat, NULL, NULL, APR_HOOK_MIDDLE);
     /* This trick doesn't work apparently because the translate hooks
        are single shot. If the core_hook returns OK, then our hook is 
        not called.
-    ap_hook_translate_name(file_cache_xlat, aszPre, NULL, AP_HOOK_MIDDLE); 
+    ap_hook_translate_name(file_cache_xlat, aszPre, NULL, APR_HOOK_MIDDLE); 
     */
 
 }
diff --git a/modules/dav/fs/mod_dav_fs.c b/modules/dav/fs/mod_dav_fs.c
index 324019f..22c440b 100644
--- a/modules/dav/fs/mod_dav_fs.c
+++ b/modules/dav/fs/mod_dav_fs.c
@@ -121,11 +121,11 @@ static const command_rec dav_fs_cmds[] =
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_gather_propsets(dav_fs_gather_propsets, NULL, NULL,
-                            AP_HOOK_MIDDLE);
-    ap_hook_find_liveprop(dav_fs_find_liveprop, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_insert_all_liveprops(dav_fs_insert_all_liveprops, NULL, NULL,
-                                 AP_HOOK_MIDDLE);
+    dav_hook_gather_propsets(dav_fs_gather_propsets, NULL, NULL,
+                             APR_HOOK_MIDDLE);
+    dav_hook_find_liveprop(dav_fs_find_liveprop, NULL, NULL, APR_HOOK_MIDDLE);
+    dav_hook_insert_all_liveprops(dav_fs_insert_all_liveprops, NULL, NULL,
+                                  APR_HOOK_MIDDLE);
 
     dav_fs_register(p);
 }
diff --git a/modules/dav/main/mod_dav.c b/modules/dav/main/mod_dav.c
index c921806..1657c16 100644
--- a/modules/dav/main/mod_dav.c
+++ b/modules/dav/main/mod_dav.c
@@ -1303,7 +1303,7 @@ static int dav_method_options(request_rec *r)
 
     /* gather property set URIs from all the liveprop providers */
     uri_ary = apr_make_array(r->pool, 5, sizeof(const char *));
-    ap_run_gather_propsets(uri_ary);
+    dav_run_gather_propsets(uri_ary);
     uris = apr_array_pstrcat(r->pool, uri_ary, ',');
     if (*uris) {
         dav_level = apr_pstrcat(r->pool, dav_level, ",", uris, NULL);
@@ -4007,13 +4007,13 @@ static int dav_type_checker(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_handler(dav_handler, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_post_config(dav_init_handler, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_type_checker(dav_type_checker, NULL, NULL, AP_HOOK_FIRST);
+    ap_hook_handler(dav_handler, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_post_config(dav_init_handler, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_type_checker(dav_type_checker, NULL, NULL, APR_HOOK_FIRST);
 
-    ap_hook_find_liveprop(dav_core_find_liveprop, NULL, NULL, AP_HOOK_LAST);
-    ap_hook_insert_all_liveprops(dav_core_insert_all_liveprops,
-                                 NULL, NULL, AP_HOOK_MIDDLE);
+    dav_hook_find_liveprop(dav_core_find_liveprop, NULL, NULL, APR_HOOK_LAST);
+    dav_hook_insert_all_liveprops(dav_core_insert_all_liveprops,
+                                 NULL, NULL, APR_HOOK_MIDDLE);
 
     dav_core_register_uris(p);
 }
@@ -4058,20 +4058,20 @@ module DAV_DECLARE_DATA dav_module =
     register_hooks,             /* register hooks */
 };
 
-AP_HOOK_STRUCT(
-    AP_HOOK_LINK(gather_propsets)
-    AP_HOOK_LINK(find_liveprop)
-    AP_HOOK_LINK(insert_all_liveprops)
+APR_HOOK_STRUCT(
+    APR_HOOK_LINK(gather_propsets)
+    APR_HOOK_LINK(find_liveprop)
+    APR_HOOK_LINK(insert_all_liveprops)
     )
-AP_IMPLEMENT_EXTERNAL_HOOK_VOID(DAV, gather_propsets,
-                                (apr_array_header_t *uris),
-                                (uris))
-AP_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(DAV, int, find_liveprop,
-                                     (const dav_resource *resource,
-                                      const char *ns_uri, const char *name,
-                                      const dav_hooks_liveprop **hooks),
+APR_IMPLEMENT_EXTERNAL_HOOK_VOID(dav, DAV, gather_propsets,
+                                 (apr_array_header_t *uris),
+                                 (uris))
+APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(dav, DAV, int, find_liveprop,
+                                      (const dav_resource *resource,
+                                       const char *ns_uri, const char *name,
+                                       const dav_hooks_liveprop **hooks),
                                      (resource, ns_uri, name, hooks), 0);
-AP_IMPLEMENT_EXTERNAL_HOOK_VOID(DAV, insert_all_liveprops,
-                                (request_rec *r, const dav_resource *resource,
-                                 int insvalue, ap_text_header *phdr),
-                                (r, resource, insvalue, phdr));
+APR_IMPLEMENT_EXTERNAL_HOOK_VOID(dav, DAV, insert_all_liveprops,
+                                 (request_rec *r, const dav_resource *resource,
+                                  int insvalue, ap_text_header *phdr),
+                                 (r, resource, insvalue, phdr));
diff --git a/modules/dav/main/mod_dav.h b/modules/dav/main/mod_dav.h
index d456194..dce73ff 100644
--- a/modules/dav/main/mod_dav.h
+++ b/modules/dav/main/mod_dav.h
@@ -61,7 +61,7 @@
 
 #include "httpd.h"
 #include "util_xml.h"
-#include "ap_hooks.h"
+#include "apr_hooks.h"
 #include "apr_hash.h"
 #include "apr_dbm.h"
 
@@ -520,7 +520,7 @@ ap_xml_elem *dav_find_child(const ap_xml_elem *elem, const char *tagname);
 ** functionality.
 **
 ** Live properties are not part of the dav_provider structure because they
-** are handled through the AP_HOOK interface (to allow for multiple liveprop
+** are handled through the APR_HOOK interface (to allow for multiple liveprop
 ** providers). The core always provides some properties, and then a given
 ** provider will add more properties.
 */
@@ -546,7 +546,7 @@ typedef struct {
 **
 ** (of course, use your own domain to ensure a unique value)
 */
-AP_DECLARE_EXTERNAL_HOOK(DAV, void, gather_propsets, 
+APR_DECLARE_EXTERNAL_HOOK(dav, DAV, void, gather_propsets, 
                          (apr_array_header_t *uris))
 
 /*
@@ -560,7 +560,7 @@ AP_DECLARE_EXTERNAL_HOOK(DAV, void, gather_propsets,
 **
 ** Return 0 if the property is not defined by the hook implementor.
 */
-AP_DECLARE_EXTERNAL_HOOK(DAV, int, find_liveprop,
+APR_DECLARE_EXTERNAL_HOOK(dav, DAV, int, find_liveprop,
                          (const dav_resource *resource,
                           const char *ns_uri, const char *name,
                           const dav_hooks_liveprop **hooks))
@@ -576,7 +576,7 @@ AP_DECLARE_EXTERNAL_HOOK(DAV, int, find_liveprop,
 ** properties on the specified resource. If a particular liveprop is
 ** not defined for this resource, then it should not be inserted.
 */
-AP_DECLARE_EXTERNAL_HOOK(DAV, void, insert_all_liveprops, 
+APR_DECLARE_EXTERNAL_HOOK(dav, DAV, void, insert_all_liveprops, 
                          (request_rec *r, const dav_resource *resource,
                           int insvalue, ap_text_header *phdr))
 
diff --git a/modules/dav/main/props.c b/modules/dav/main/props.c
index 1b0627b..2278bed 100644
--- a/modules/dav/main/props.c
+++ b/modules/dav/main/props.c
@@ -354,7 +354,7 @@ static void dav_find_liveprop(dav_propdb *propdb, ap_xml_elem *elem)
     ns_uri = AP_XML_GET_URI_ITEM(propdb->ns_xlate, elem->ns);
 
     /* is there a liveprop provider for this property? */
-    propid = ap_run_find_liveprop(propdb->resource, ns_uri, elem->name,
+    propid = dav_run_find_liveprop(propdb->resource, ns_uri, elem->name,
                                   &hooks);
     if (propid != 0) {
         priv->propid = propid;
@@ -1068,7 +1068,7 @@ dav_get_props_result dav_get_allprops(dav_propdb *propdb, int getvals)
     dav_add_all_liveprop_xmlns(propdb->p, &hdr_ns);
     
     /* ask the liveprop providers to insert their properties */
-    ap_run_insert_all_liveprops(propdb->r, propdb->resource, getvals, &hdr);
+    dav_run_insert_all_liveprops(propdb->r, propdb->resource, getvals, &hdr);
 
     /* insert the standard properties */
     /* ### should be handling the return errors here */
diff --git a/modules/echo/mod_echo.c b/modules/echo/mod_echo.c
index e52ca1c..e15c693 100644
--- a/modules/echo/mod_echo.c
+++ b/modules/echo/mod_echo.c
@@ -122,7 +122,7 @@ static const command_rec echo_cmds[] =
 static void register_hooks(apr_pool_t *p)
 {
     ap_hook_process_connection(process_echo_connection, NULL, NULL,
-                               AP_HOOK_MIDDLE);
+                               APR_HOOK_MIDDLE);
 }
 
 AP_DECLARE_DATA module echo_module = {
diff --git a/modules/experimental/mod_cache.c b/modules/experimental/mod_cache.c
index 946503c..48767f1 100644
--- a/modules/experimental/mod_cache.c
+++ b/modules/experimental/mod_cache.c
@@ -69,17 +69,17 @@
 #include "util_script.h"
 #include "http_core.h" 
 #include "mod_cache.h"
-#include "ap_hooks.h"
+#include "apr_hooks.h"
 
 module MODULE_VAR_EXPORT cache_module;
 
-AP_HOOK_STRUCT(
-            AP_HOOK_LINK(serve_cache)
-            AP_HOOK_LINK(store_cache)
+APR_HOOK_STRUCT(
+            APR_HOOK_LINK(serve_cache)
+            APR_HOOK_LINK(store_cache)
 )
 
 AP_IMPLEMENT_HOOK_RUN_FIRST(int,serve_cache,(request_rec *r),(r),DECLINED)
-AP_IMPLEMENT_HOOK_RUN_FIRST(int,store_cache,(request_rec *r, ap_bucket_brigade *bb, void **cf),
+AP_IMPLEMENT_HOOK_RUN_FIRST(int,store_cache,(request_rec *r, apr_bucket_brigade *bb, void **cf),
                             (r, bb, cf),DECLINED)
 
 static int cache_handler(request_rec *r)
@@ -94,7 +94,7 @@ typedef struct cache_struct {
     void *cf;
 } cache_struct;
 
-static int cache_filter(ap_filter_t *f, ap_bucket_brigade *bb)
+static int cache_filter(ap_filter_t *f, apr_bucket_brigade *bb)
 {
     cache_struct *ctx = f->ctx;
     
diff --git a/modules/experimental/mod_cache.h b/modules/experimental/mod_cache.h
index 92bb2bf..5c32b27 100644
--- a/modules/experimental/mod_cache.h
+++ b/modules/experimental/mod_cache.h
@@ -56,10 +56,10 @@
  * University of Illinois, Urbana-Champaign.
  */
 
-#include "ap_buckets.h"
-#include "ap_hooks.h"
+#include "apr_buckets.h"
+#include "apr_hooks.h"
 #include "httpd.h"
 
 AP_DECLARE_HOOK(int,serve_cache,(request_rec *r));
-AP_DECLARE_HOOK(int,store_cache,(request_rec *r, ap_bucket_brigade *bb, void **cf));
+AP_DECLARE_HOOK(int,store_cache,(request_rec *r, apr_bucket_brigade *bb, void **cf));
 
diff --git a/modules/experimental/mod_case_filter.c b/modules/experimental/mod_case_filter.c
index b035594..af0b6c5 100644
--- a/modules/experimental/mod_case_filter.c
+++ b/modules/experimental/mod_case_filter.c
@@ -4,7 +4,7 @@
 #include "http_config.h"
 #include "apr_general.h"
 #include "util_filter.h"
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 #include "http_request.h"
 
 static const char s_szCaseFilterName[]="CaseFilter";
@@ -36,31 +36,31 @@ static void CaseFilterInsertFilter(request_rec *r)
     }
 
 static apr_status_t CaseFilterOutFilter(ap_filter_t *f,
-					ap_bucket_brigade *pbbIn)
+					apr_bucket_brigade *pbbIn)
     {
-    ap_bucket *pbktIn;
-    ap_bucket_brigade *pbbOut;
+    apr_bucket *pbktIn;
+    apr_bucket_brigade *pbbOut;
 
     // XXX: is this the most appropriate pool?
-    pbbOut=ap_brigade_create(f->r->pool);
-    AP_BRIGADE_FOREACH(pbktIn,pbbIn)
+    pbbOut=apr_brigade_create(f->r->pool);
+    APR_BRIGADE_FOREACH(pbktIn,pbbIn)
 	{
 	const char *data;
 	apr_size_t len;
 	char *buf;
 	apr_size_t n;
-	ap_bucket *pbktOut;
+	apr_bucket *pbktOut;
 
-	if(AP_BUCKET_IS_EOS(pbktIn))
+	if(APR_BUCKET_IS_EOS(pbktIn))
 	    {
 	    // XXX: why can't I reuse pbktIn???
-	    ap_bucket *pbktEOS=ap_bucket_create_eos();
-	    AP_BRIGADE_INSERT_TAIL(pbbOut,pbktEOS);
+	    apr_bucket *pbktEOS=apr_bucket_create_eos();
+	    APR_BRIGADE_INSERT_TAIL(pbbOut,pbktEOS);
 	    break;
 	    }
 
 	// read
-	ap_bucket_read(pbktIn,&data,&len,1);
+	apr_bucket_read(pbktIn,&data,&len,1);
 
 	// write
 	buf=apr_palloc(f->r->pool,len);
@@ -69,8 +69,8 @@ static apr_status_t CaseFilterOutFilter(ap_filter_t *f,
 
 	// XXX: should we use a heap bucket instead? Or a transient (in
 	// which case we need a separate brigade for each bucket)?
-	pbktOut=ap_bucket_create_pool(buf,len,f->r->pool);
-	AP_BRIGADE_INSERT_TAIL(pbbOut,pbktOut);
+	pbktOut=apr_bucket_create_pool(buf,len,f->r->pool);
+	APR_BRIGADE_INSERT_TAIL(pbbOut,pbktOut);
 	}
 
     // XXX: is there any advantage to passing a brigade for each bucket?
@@ -95,7 +95,7 @@ static const command_rec CaseFilterCmds[] =
 
 static void CaseFilterRegisterHooks(void)
     {
-    ap_hook_insert_filter(CaseFilterInsertFilter,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_insert_filter(CaseFilterInsertFilter,NULL,NULL,APR_HOOK_MIDDLE);
     ap_register_output_filter(s_szCaseFilterName,CaseFilterOutFilter,
 			      AP_FTYPE_CONTENT);
     }
diff --git a/modules/experimental/mod_charset_lite.c b/modules/experimental/mod_charset_lite.c
index 33bdf28..27cb98b 100644
--- a/modules/experimental/mod_charset_lite.c
+++ b/modules/experimental/mod_charset_lite.c
@@ -75,7 +75,7 @@
 #include "http_protocol.h"
 #include "http_request.h"
 #include "util_charset.h"
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 #include "util_filter.h"
 #include "apr_strings.h"
 
@@ -86,7 +86,7 @@
 #define OUTPUT_XLATE_BUF_SIZE (16*1024) /* size of translation buffer used on output */
 #define INPUT_XLATE_BUF_SIZE  (8*1024)  /* size of translation buffer used on input */
 
-/* XXX this works around an issue with the heap bucket: ap_bucket_create_heap will 
+/* XXX this works around an issue with the heap bucket: apr_bucket_create_heap will 
  *     copy only the first 4096 bytes
  */
 #undef INPUT_XLATE_BUF_SIZE         /* XXX */
@@ -140,7 +140,7 @@ typedef struct charset_filter_ctx_t {
     int ran;                /* has filter instance run before? */
     int noop;               /* should we pass brigades through unchanged? */
     char *tmp;              /* buffer for input filtering */
-    ap_bucket_brigade *bb;  /* input buckets we couldn't finish translating */
+    apr_bucket_brigade *bb;  /* input buckets we couldn't finish translating */
 } charset_filter_ctx_t;
 
 /* charset_req_t is available via r->request_config if any translation is
@@ -353,7 +353,7 @@ static int find_code_page(request_rec *r)
          * of it.
          */
         input_ctx = apr_pcalloc(r->pool, sizeof(charset_filter_ctx_t));
-        input_ctx->bb = ap_brigade_create(r->pool);
+        input_ctx->bb = apr_brigade_create(r->pool);
         input_ctx->tmp = apr_palloc(r->pool, INPUT_XLATE_BUF_SIZE);
         input_ctx->dc = dc;
         reqinfo->input_ctx = input_ctx;
@@ -455,14 +455,14 @@ static void xlate_insert_filter(request_rec *r)
  */
 static apr_status_t send_downstream(ap_filter_t *f, const char *tmp, apr_size_t len)
 {
-    ap_bucket_brigade *bb;
-    ap_bucket *b;
+    apr_bucket_brigade *bb;
+    apr_bucket *b;
     charset_filter_ctx_t *ctx = f->ctx;
     apr_status_t rv;
 
-    bb = ap_brigade_create(f->r->pool);
-    b = ap_bucket_create_transient(tmp, len);
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(f->r->pool);
+    b = apr_bucket_create_transient(tmp, len);
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     rv = ap_pass_brigade(f->next, bb);
     if (rv != APR_SUCCESS) {
         ctx->ees = EES_DOWNSTREAM;
@@ -472,14 +472,14 @@ static apr_status_t send_downstream(ap_filter_t *f, const char *tmp, apr_size_t
 
 static apr_status_t send_eos(ap_filter_t *f)
 {
-    ap_bucket_brigade *bb;
-    ap_bucket *b;
+    apr_bucket_brigade *bb;
+    apr_bucket *b;
     charset_filter_ctx_t *ctx = f->ctx;
     apr_status_t rv;
 
-    bb = ap_brigade_create(f->r->pool);
-    b = ap_bucket_create_eos();
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(f->r->pool);
+    b = apr_bucket_create_eos();
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     rv = ap_pass_brigade(f->next, bb);
     if (rv != APR_SUCCESS) {
         ctx->ees = EES_DOWNSTREAM;
@@ -723,12 +723,12 @@ static void chk_filter_chain(ap_filter_t *f)
  *   hit_eos:          did we hit an EOS bucket?
  */
 static apr_status_t xlate_brigade(charset_filter_ctx_t *ctx,
-                                  ap_bucket_brigade *bb,
+                                  apr_bucket_brigade *bb,
                                   char *buffer, 
                                   apr_size_t *buffer_avail,
                                   int *hit_eos)
 {
-    ap_bucket *b, *consumed_bucket;
+    apr_bucket *b, *consumed_bucket;
     const char *bucket;
     apr_size_t bytes_in_bucket; /* total bytes read from current bucket */
     apr_size_t bucket_avail;    /* bytes left in current bucket */
@@ -740,16 +740,16 @@ static apr_status_t xlate_brigade(charset_filter_ctx_t *ctx,
     while (1) {
         if (!bucket_avail) { /* no bytes left to process in the current bucket... */
             if (consumed_bucket) {
-                AP_BUCKET_REMOVE(consumed_bucket);
-                ap_bucket_destroy(consumed_bucket);
+                APR_BUCKET_REMOVE(consumed_bucket);
+                apr_bucket_destroy(consumed_bucket);
                 consumed_bucket = NULL;
             }
-            b = AP_BRIGADE_FIRST(bb);
-            if (b == AP_BRIGADE_SENTINEL(bb) ||
-                AP_BUCKET_IS_EOS(b)) {
+            b = APR_BRIGADE_FIRST(bb);
+            if (b == APR_BRIGADE_SENTINEL(bb) ||
+                APR_BUCKET_IS_EOS(b)) {
                 break;
             }
-            rv = ap_bucket_read(b, &bucket, &bytes_in_bucket, 0);
+            rv = apr_bucket_read(b, &bucket, &bytes_in_bucket, 0);
             if (rv != APR_SUCCESS) {
                 ctx->ees = EES_BUCKET_READ;
                 break;
@@ -797,18 +797,18 @@ static apr_status_t xlate_brigade(charset_filter_ctx_t *ctx,
             if (*buffer_avail < XLATE_MIN_BUFF_LEFT) {
                 /* if any data remains in the current bucket, split there */
                 if (bucket_avail) {
-                    ap_bucket_split(b, bytes_in_bucket - bucket_avail);
+                    apr_bucket_split(b, bytes_in_bucket - bucket_avail);
                 }
-                AP_BUCKET_REMOVE(b);
-                ap_bucket_destroy(b);
+                APR_BUCKET_REMOVE(b);
+                apr_bucket_destroy(b);
                 break;
             }
         }
     }
 
-    if (!AP_BRIGADE_EMPTY(bb)) {
-        b = AP_BRIGADE_FIRST(bb);
-        if (AP_BUCKET_IS_EOS(b)) {
+    if (!APR_BRIGADE_EMPTY(bb)) {
+        b = APR_BRIGADE_FIRST(bb);
+        if (APR_BUCKET_IS_EOS(b)) {
             /* Leave the eos bucket in the brigade for reporting to
              * subsequent filters.
              */
@@ -832,14 +832,14 @@ static apr_status_t xlate_brigade(charset_filter_ctx_t *ctx,
  * where the filter's context data is set up... the context data gives us
  * the translation handle
  */
-static apr_status_t xlate_out_filter(ap_filter_t *f, ap_bucket_brigade *bb)
+static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
 {
     charset_req_t *reqinfo = ap_get_module_config(f->r->request_config,
                                                   &charset_lite_module);
     charset_dir_t *dc = ap_get_module_config(f->r->per_dir_config,
                                              &charset_lite_module);
     charset_filter_ctx_t *ctx = f->ctx;
-    ap_bucket *dptr, *consumed_bucket;
+    apr_bucket *dptr, *consumed_bucket;
     const char *cur_str;
     apr_size_t cur_len, cur_avail;
     char tmp[OUTPUT_XLATE_BUF_SIZE];
@@ -883,7 +883,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, ap_bucket_brigade *bb)
         return ap_pass_brigade(f->next, bb);
     }
 
-    dptr = AP_BRIGADE_FIRST(bb);
+    dptr = APR_BRIGADE_FIRST(bb);
     done = 0;
     cur_len = 0;
     space_avail = sizeof(tmp);
@@ -891,15 +891,15 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, ap_bucket_brigade *bb)
     while (!done) {
         if (!cur_len) { /* no bytes left to process in the current bucket... */
             if (consumed_bucket) {
-                AP_BUCKET_REMOVE(consumed_bucket);
-                ap_bucket_destroy(consumed_bucket);
+                APR_BUCKET_REMOVE(consumed_bucket);
+                apr_bucket_destroy(consumed_bucket);
                 consumed_bucket = NULL;
             }
-            if (dptr == AP_BRIGADE_SENTINEL(bb)) {
+            if (dptr == APR_BRIGADE_SENTINEL(bb)) {
                 done = 1;
                 break;
             }
-            if (AP_BUCKET_IS_EOS(dptr)) {
+            if (APR_BUCKET_IS_EOS(dptr)) {
                 done = 1;
                 cur_len = -1; /* XXX yuck, but that tells us to send
                                  * eos down; when we minimize our bb construction
@@ -913,14 +913,14 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, ap_bucket_brigade *bb)
                 }
                 break;
             }
-            rv = ap_bucket_read(dptr, &cur_str, &cur_len, 0);
+            rv = apr_bucket_read(dptr, &cur_str, &cur_len, 0);
             if (rv != APR_SUCCESS) {
                 done = 1;
                 ctx->ees = EES_BUCKET_READ;
                 break;
             }
             consumed_bucket = dptr; /* for axing when we're done reading it */
-            dptr = AP_BUCKET_NEXT(dptr); /* get ready for when we access the 
+            dptr = APR_BUCKET_NEXT(dptr); /* get ready for when we access the 
                                           * next bucket */
         }
         /* Try to fill up our tmp buffer with translated data. */
@@ -993,18 +993,18 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, ap_bucket_brigade *bb)
     return rv;
 }
 
-static void transfer_brigade(ap_bucket_brigade *in, ap_bucket_brigade *out)
+static void transfer_brigade(apr_bucket_brigade *in, apr_bucket_brigade *out)
 {
-    ap_bucket *b;
+    apr_bucket *b;
 
-    while (!AP_BRIGADE_EMPTY(in)) {
-        b = AP_BRIGADE_FIRST(in);
-        AP_BUCKET_REMOVE(b);
-        AP_BRIGADE_INSERT_TAIL(out, b);
+    while (!APR_BRIGADE_EMPTY(in)) {
+        b = APR_BRIGADE_FIRST(in);
+        APR_BUCKET_REMOVE(b);
+        APR_BRIGADE_INSERT_TAIL(out, b);
     }
 }
 
-static int xlate_in_filter(ap_filter_t *f, ap_bucket_brigade *bb, 
+static int xlate_in_filter(ap_filter_t *f, apr_bucket_brigade *bb, 
                            ap_input_mode_t mode)
 {
     apr_status_t rv;
@@ -1052,7 +1052,7 @@ static int xlate_in_filter(ap_filter_t *f, ap_bucket_brigade *bb,
         return ap_get_brigade(f->next, bb, mode);
     }
 
-    if (AP_BRIGADE_EMPTY(ctx->bb)) {
+    if (APR_BRIGADE_EMPTY(ctx->bb)) {
         if ((rv = ap_get_brigade(f->next, bb, mode)) != APR_SUCCESS) {
             return rv;
         }
@@ -1073,16 +1073,16 @@ static int xlate_in_filter(ap_filter_t *f, ap_bucket_brigade *bb,
             transfer_brigade(bb, ctx->bb);
         }
         if (buffer_size < INPUT_XLATE_BUF_SIZE) { /* do we have output? */
-            ap_bucket *e;
+            apr_bucket *e;
 
-            e = ap_bucket_create_heap(ctx->tmp, 
+            e = apr_bucket_create_heap(ctx->tmp, 
                                       INPUT_XLATE_BUF_SIZE - buffer_size, 1, 
                                       NULL);
             /* make sure we insert at the head, because there may be
              * an eos bucket already there, and the eos bucket should 
              * come after the data
              */
-            AP_BRIGADE_INSERT_HEAD(bb, e);
+            APR_BRIGADE_INSERT_HEAD(bb, e);
         }
         else {
             /* XXX need to get some more data... what if the last brigade
@@ -1121,8 +1121,8 @@ static const command_rec cmds[] =
 
 static void charset_register_hooks(apr_pool_t *p)
 {
-    ap_hook_fixups(find_code_page, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_insert_filter(xlate_insert_filter, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_fixups(find_code_page, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_insert_filter(xlate_insert_filter, NULL, NULL, APR_HOOK_MIDDLE);
     ap_register_output_filter(XLATEOUT_FILTER_NAME, xlate_out_filter, 
                               AP_FTYPE_CONTENT);
     ap_register_input_filter(XLATEIN_FILTER_NAME, xlate_in_filter, 
diff --git a/modules/experimental/mod_disk_cache.c b/modules/experimental/mod_disk_cache.c
index a32f5b0..70a2643 100644
--- a/modules/experimental/mod_disk_cache.c
+++ b/modules/experimental/mod_disk_cache.c
@@ -67,8 +67,8 @@ module MODULE_VAR_EXPORT disk_cache_module;
 
 static int disk_serve(request_rec *r)
 {
-    ap_bucket *e;
-    ap_bucket_brigade *bb = ap_brigade_create(r->pool); 
+    apr_bucket *e;
+    apr_bucket_brigade *bb = apr_brigade_create(r->pool); 
     const char *filename;
     apr_file_t *fd = NULL;
     apr_status_t rv;
@@ -98,11 +98,11 @@ static int disk_serve(request_rec *r)
         }
     }
 
-    e = ap_bucket_create_file(fd, offset, r->finfo.size);
+    e = apr_bucket_create_file(fd, offset, r->finfo.size);
 
-    AP_BRIGADE_INSERT_HEAD(bb, e);
-    e = ap_bucket_create_eos();
-    AP_BRIGADE_INSERT_TAIL(bb, e);
+    APR_BRIGADE_INSERT_HEAD(bb, e);
+    e = apr_bucket_create_eos();
+    APR_BRIGADE_INSERT_TAIL(bb, e);
 
     ap_pass_brigade(r->output_filters, bb);
     return OK;
@@ -114,10 +114,10 @@ typedef struct cache_struct {
     int state;
 } cache_struct;
 
-static int disk_cache(request_rec *r, ap_bucket_brigade *bb, void **cf)
+static int disk_cache(request_rec *r, apr_bucket_brigade *bb, void **cf)
 {
     cache_struct *ctx = *cf;
-    ap_bucket *e;
+    apr_bucket *e;
     
     if (ctx == NULL) {
         *cf = ctx = apr_pcalloc(r->pool, sizeof(*ctx));
@@ -140,14 +140,14 @@ static int disk_cache(request_rec *r, ap_bucket_brigade *bb, void **cf)
             return DECLINED;
         }
     } 
-    AP_BRIGADE_FOREACH(e, bb) {
+    APR_BRIGADE_FOREACH(e, bb) {
         const char *str;
         apr_ssize_t length;
 
-        ap_bucket_read(e, &str, &length, 0);
+        apr_bucket_read(e, &str, &length, 0);
         apr_write(ctx->fd, str, &length);
     }
-    if (AP_BUCKET_IS_EOS(AP_BRIGADE_LAST(bb))) {
+    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
         apr_close(ctx->fd);
     }
     return OK;	
@@ -155,8 +155,8 @@ static int disk_cache(request_rec *r, ap_bucket_brigade *bb, void **cf)
 
 static void disk_cache_register_hook(apr_pool_t *p)
 {
-    ap_hook_store_cache(disk_cache, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_serve_cache(disk_serve, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_store_cache(disk_cache, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_serve_cache(disk_serve, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module MODULE_VAR_EXPORT disk_cache_module = {
diff --git a/modules/experimental/mod_example.c b/modules/experimental/mod_example.c
index ea96362..2256d0d 100644
--- a/modules/experimental/mod_example.c
+++ b/modules/experimental/mod_example.c
@@ -1076,9 +1076,9 @@ static int example_header_parser(request_rec *r)
  *                 before this module.
  * successors   -> a list of modules whose calls to this hook must come 
  *                 after this module.
- * position     -> The relative position of this module.  One of AP_HOOK_FIRST,
- *                 AP_HOOK_MIDDLE, or AP_HOOK_LAST.  Most modules will use
- *                 AP_HOOK_MIDDLE.  If multiple modules use the same relative
+ * position     -> The relative position of this module.  One of APR_HOOK_FIRST,
+ *                 APR_HOOK_MIDDLE, or APR_HOOK_LAST.  Most modules will use
+ *                 APR_HOOK_MIDDLE.  If multiple modules use the same relative
  *                 position, Apache will determine which to call first.
  *                 If your module relies on another module to run first,
  *                 or another module running after yours, use the 
@@ -1094,39 +1094,39 @@ static void example_register_hooks(apr_pool_t *p)
 {
     /* module initializer */
     ap_hook_post_config(example_init,
-			NULL, NULL, AP_HOOK_MIDDLE);
+			NULL, NULL, APR_HOOK_MIDDLE);
     /* [1] post read_request handling */
     ap_hook_post_read_request(example_post_read_request,
-			      NULL, NULL, AP_HOOK_MIDDLE);
+			      NULL, NULL, APR_HOOK_MIDDLE);
     /* [2] filename-to-URI translation */
     ap_hook_translate_name(example_translate_handler,
-			   NULL, NULL, AP_HOOK_MIDDLE);
+			   NULL, NULL, APR_HOOK_MIDDLE);
     /* [3] header parser */
     ap_hook_header_parser(example_header_parser,
-			  NULL, NULL, AP_HOOK_MIDDLE);
+			  NULL, NULL, APR_HOOK_MIDDLE);
     /* [4] check access by host address */
     ap_hook_access_checker(example_access_checker,
-			   NULL, NULL, AP_HOOK_MIDDLE);
+			   NULL, NULL, APR_HOOK_MIDDLE);
     /* [5] check/validate user_id */
     ap_hook_check_user_id(example_check_user_id,
-			  NULL, NULL, AP_HOOK_MIDDLE);
+			  NULL, NULL, APR_HOOK_MIDDLE);
     /* [6] check user_id is valid *here* */
     ap_hook_auth_checker(example_auth_checker,
-			 NULL, NULL, AP_HOOK_MIDDLE);
+			 NULL, NULL, APR_HOOK_MIDDLE);
     /* [7] MIME type checker/setter */
     ap_hook_type_checker(example_type_checker,
-			 NULL, NULL, AP_HOOK_MIDDLE);
+			 NULL, NULL, APR_HOOK_MIDDLE);
     /* [8] fixups */
     ap_hook_fixups(example_fixer_upper,
-		   NULL, NULL, AP_HOOK_MIDDLE);
+		   NULL, NULL, APR_HOOK_MIDDLE);
     /* [9] is for the handlers; see below */
 
     /* [10] logger */
     ap_hook_log_transaction(example_logger,
-			    NULL, NULL, AP_HOOK_MIDDLE);
+			    NULL, NULL, APR_HOOK_MIDDLE);
     /* process initializer */
     ap_hook_child_init(example_child_init,
-		       NULL, NULL, AP_HOOK_MIDDLE);
+		       NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 /*--------------------------------------------------------------------------*/
diff --git a/modules/experimental/mod_ext_filter.c b/modules/experimental/mod_ext_filter.c
index 02b5697..5982ddf 100644
--- a/modules/experimental/mod_ext_filter.c
+++ b/modules/experimental/mod_ext_filter.c
@@ -65,7 +65,7 @@
 #include "http_log.h"
 #define CORE_PRIVATE
 #include "http_core.h"
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 #include "util_filter.h"
 #include "apr_strings.h"
 #include "apr_hash.h"
@@ -110,7 +110,7 @@ typedef struct ef_ctx_t {
 
 module ext_filter_module;
 
-static apr_status_t ef_output_filter(ap_filter_t *, ap_bucket_brigade *);
+static apr_status_t ef_output_filter(ap_filter_t *, apr_bucket_brigade *);
 
 #define DBGLVL_SHOWOPTIONS         1
 #define DBGLVL_GORY                9
@@ -536,8 +536,8 @@ static apr_status_t drain_available_output(ap_filter_t *f)
     apr_size_t len;
     char buf[4096];
     apr_status_t rv;
-    ap_bucket_brigade *bb;
-    ap_bucket *b;
+    apr_bucket_brigade *bb;
+    apr_bucket *b;
 
     while (1) {
         len = sizeof(buf);
@@ -553,9 +553,9 @@ static apr_status_t drain_available_output(ap_filter_t *f)
         if (rv != APR_SUCCESS) {
             return rv;
         }
-        bb = ap_brigade_create(f->r->pool);
-        b = ap_bucket_create_transient(buf, len);
-        AP_BRIGADE_INSERT_TAIL(bb, b);
+        bb = apr_brigade_create(f->r->pool);
+        b = apr_bucket_create_transient(buf, len);
+        APR_BRIGADE_INSERT_TAIL(bb, b);
         if ((rv = ap_pass_brigade(f->next, bb)) != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
                           "ap_pass_brigade()");
@@ -629,16 +629,16 @@ static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data,
     return rv;
 }
 
-static apr_status_t ef_output_filter(ap_filter_t *f, ap_bucket_brigade *bb)
+static apr_status_t ef_output_filter(ap_filter_t *f, apr_bucket_brigade *bb)
 {
     ef_ctx_t *ctx = f->ctx;
-    ap_bucket *b;
+    apr_bucket *b;
     ef_dir_t *dc;
     apr_size_t len;
     const char *data;
     apr_status_t rv;
     char buf[4096];
-    ap_bucket *eos = NULL;
+    apr_bucket *eos = NULL;
 
     if (!ctx) {
         if ((rv = init_filter_instance(f)) != APR_SUCCESS) {
@@ -652,16 +652,16 @@ static apr_status_t ef_output_filter(ap_filter_t *f, ap_bucket_brigade *bb)
     }
     dc = ctx->dc;
 
-    AP_BRIGADE_FOREACH(b, bb) {
+    APR_BRIGADE_FOREACH(b, bb) {
 
-        if (AP_BUCKET_IS_EOS(b)) {
+        if (APR_BUCKET_IS_EOS(b)) {
             eos = b;
             break;
         }
 
-        rv = ap_bucket_read(b, &data, &len, 1);
+        rv = apr_bucket_read(b, &data, &len, 1);
         if (rv != APR_SUCCESS) {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, "ap_bucket_read()");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, "apr_bucket_read()");
             return rv;
         }
 
@@ -671,7 +671,7 @@ static apr_status_t ef_output_filter(ap_filter_t *f, ap_bucket_brigade *bb)
         }
     }
 
-    ap_brigade_destroy(bb);
+    apr_brigade_destroy(bb);
 
     /* XXX What we *really* need to do once we've hit eos is create a pipe bucket
      * from the child output pipe and pass down the pipe bucket + eos.
@@ -717,9 +717,9 @@ static apr_status_t ef_output_filter(ap_filter_t *f, ap_bucket_brigade *bb)
         }
         
         if (rv == APR_SUCCESS) {
-            bb = ap_brigade_create(f->r->pool);
-            b = ap_bucket_create_transient(buf, len);
-            AP_BRIGADE_INSERT_TAIL(bb, b);
+            bb = apr_brigade_create(f->r->pool);
+            b = apr_bucket_create_transient(buf, len);
+            APR_BRIGADE_INSERT_TAIL(bb, b);
             if ((rv = ap_pass_brigade(f->next, bb)) != APR_SUCCESS) {
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
                               "ap_pass_brigade(filtered buffer) failed");
@@ -734,9 +734,9 @@ static apr_status_t ef_output_filter(ap_filter_t *f, ap_bucket_brigade *bb)
 
     if (eos) {
         /* pass down eos */
-        bb = ap_brigade_create(f->r->pool);
-        b = ap_bucket_create_eos();
-        AP_BRIGADE_INSERT_TAIL(bb, b);
+        bb = apr_brigade_create(f->r->pool);
+        b = apr_bucket_create_eos();
+        APR_BRIGADE_INSERT_TAIL(bb, b);
         if ((rv = ap_pass_brigade(f->next, bb)) != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
                           "ap_pass_brigade(eos) failed");
@@ -748,11 +748,11 @@ static apr_status_t ef_output_filter(ap_filter_t *f, ap_bucket_brigade *bb)
 }
 
 #if 0
-static int ef_input_filter(ap_filter_t *f, ap_bucket_brigade *bb, 
+static int ef_input_filter(ap_filter_t *f, apr_bucket_brigade *bb, 
                            ap_input_mode_t mode)
 {
     apr_status_t rv;
-    ap_bucket *b;
+    apr_bucket *b;
     char *buf;
     apr_ssize_t len;
     char *zero;
@@ -762,13 +762,13 @@ static int ef_input_filter(ap_filter_t *f, ap_bucket_brigade *bb,
         return rv;
     }
 
-    AP_BRIGADE_FOREACH(b, bb) {
-        if (!AP_BUCKET_IS_EOS(b)) {
-            if ((rv = ap_bucket_read(b, (const char **)&buf, &len, 0)) != APR_SUCCESS) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, "ap_bucket_read() failed");
+    APR_BRIGADE_FOREACH(b, bb) {
+        if (!APR_BUCKET_IS_EOS(b)) {
+            if ((rv = apr_bucket_read(b, (const char **)&buf, &len, 0)) != APR_SUCCESS) {
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, "apr_bucket_read() failed");
                 return rv;
             }
-            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, "ap_bucket_read -> %d bytes",
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, "apr_bucket_read -> %d bytes",
                          len);
             while ((zero = memchr(buf, '0', len))) {
                 *zero = 'a';
diff --git a/modules/experimental/mod_generic_hook_export.c b/modules/experimental/mod_generic_hook_export.c
index 3029aea..72431b3 100644
--- a/modules/experimental/mod_generic_hook_export.c
+++ b/modules/experimental/mod_generic_hook_export.c
@@ -67,7 +67,7 @@ static int ExportLogTransaction(request_rec *r)
 
 static void ExportRegisterHooks(apr_pool_t *p)
 {
-    ap_hook_log_transaction(ExportLogTransaction,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_log_transaction(ExportLogTransaction,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module generic_hook_export_module =
diff --git a/modules/experimental/mod_generic_hook_export.h b/modules/experimental/mod_generic_hook_export.h
index 17b44b4..b9ee314 100644
--- a/modules/experimental/mod_generic_hook_export.h
+++ b/modules/experimental/mod_generic_hook_export.h
@@ -55,7 +55,7 @@
 #ifndef MOD_GENERIC_HOOK_EXPORT_H
 #define MOD_GENERIC_HOOK_EXPORT_H
 
-#include "ap_generic_hook.h"
+#include "apr_generic_hook.h"
 
 AP_DECLARE_HOOK(int,generic_hook_test,(const char *))
 
diff --git a/modules/experimental/mod_generic_hook_import.c b/modules/experimental/mod_generic_hook_import.c
index e73f23a..4fb65ab 100644
--- a/modules/experimental/mod_generic_hook_import.c
+++ b/modules/experimental/mod_generic_hook_import.c
@@ -67,8 +67,8 @@ static int ImportGenericHookTestHook(const char *szStr)
 
 static void ImportRegisterHooks(apr_pool_t *p)
 {
-    AP_HOOK_GENERIC(generic_hook_test,ImportGenericHookTestHook,NULL,NULL,
-		    AP_HOOK_MIDDLE);
+    APR_HOOK_GENERIC(generic_hook_test,ImportGenericHookTestHook,NULL,NULL,
+		    APR_HOOK_MIDDLE);
 }
 
 module generic_hook_import_module=
diff --git a/modules/filters/mod_include.c b/modules/filters/mod_include.c
index a86b788..0354a97 100644
--- a/modules/filters/mod_include.c
+++ b/modules/filters/mod_include.c
@@ -149,8 +149,8 @@ static void add_include_vars(request_rec *r, char *timefmt)
  * first byte of the BEGINNING_SEQUENCE (after finding a complete match) or it
  * returns NULL if no match found.
  */
-static ap_bucket *find_start_sequence(ap_bucket *dptr, include_ctx_t *ctx,
-                                      ap_bucket_brigade *bb, int *do_cleanup)
+static apr_bucket *find_start_sequence(apr_bucket *dptr, include_ctx_t *ctx,
+                                      apr_bucket_brigade *bb, int *do_cleanup)
 {
     apr_size_t len;
     const char *c;
@@ -160,10 +160,10 @@ static ap_bucket *find_start_sequence(ap_bucket *dptr, include_ctx_t *ctx,
     *do_cleanup = 0;
 
     do {
-        if (AP_BUCKET_IS_EOS(dptr)) {
+        if (APR_BUCKET_IS_EOS(dptr)) {
             break;
         }
-        ap_bucket_read(dptr, &buf, &len, 0);
+        apr_bucket_read(dptr, &buf, &len, 0);
         /* XXX handle retcodes */
         if (len == 0) { /* end of pipe? */
             break;
@@ -180,7 +180,7 @@ static ap_bucket *find_start_sequence(ap_bucket *dptr, include_ctx_t *ctx,
             }
             else {
                 if (str[ctx->parse_pos] == '\0') {
-                    ap_bucket   *tmp_bkt;
+                    apr_bucket   *tmp_bkt;
                     apr_size_t  start_index;
 
                     /* We want to split the bucket at the '<'. */
@@ -191,8 +191,8 @@ static ap_bucket *find_start_sequence(ap_bucket *dptr, include_ctx_t *ctx,
                     ctx->tag_start_index  = c - buf;
                     if (ctx->head_start_index > 0) {
                         start_index = (c - buf) - ctx->head_start_index;
-                        ap_bucket_split(ctx->head_start_bucket, ctx->head_start_index);
-                        tmp_bkt = AP_BUCKET_NEXT(ctx->head_start_bucket);
+                        apr_bucket_split(ctx->head_start_bucket, ctx->head_start_index);
+                        tmp_bkt = APR_BUCKET_NEXT(ctx->head_start_bucket);
                         if (dptr == ctx->head_start_bucket) {
                             ctx->tag_start_bucket = tmp_bkt;
                             ctx->tag_start_index  = start_index;
@@ -225,12 +225,12 @@ static ap_bucket *find_start_sequence(ap_bucket *dptr, include_ctx_t *ctx,
             }
             c++;
         }
-        dptr = AP_BUCKET_NEXT(dptr);
-    } while (dptr != AP_BRIGADE_SENTINEL(bb));
+        dptr = APR_BUCKET_NEXT(dptr);
+    } while (dptr != APR_BRIGADE_SENTINEL(bb));
     return NULL;
 }
 
-static ap_bucket *find_end_sequence(ap_bucket *dptr, include_ctx_t *ctx, ap_bucket_brigade *bb)
+static apr_bucket *find_end_sequence(apr_bucket *dptr, include_ctx_t *ctx, apr_bucket_brigade *bb)
 {
     apr_size_t len;
     const char *c;
@@ -238,10 +238,10 @@ static ap_bucket *find_end_sequence(ap_bucket *dptr, include_ctx_t *ctx, ap_buck
     const char *str = ENDING_SEQUENCE;
 
     do {
-        if (AP_BUCKET_IS_EOS(dptr)) {
+        if (APR_BUCKET_IS_EOS(dptr)) {
             break;
         }
-        ap_bucket_read(dptr, &buf, &len, 0);
+        apr_bucket_read(dptr, &buf, &len, 0);
         /* XXX handle retcodes */
         if (len == 0) { /* end of pipe? */
             break;
@@ -286,7 +286,7 @@ static ap_bucket *find_end_sequence(ap_bucket *dptr, include_ctx_t *ctx, ap_buck
                 }
                 else {
                     if (str[ctx->parse_pos] == '\0') {
-                        ap_bucket *tmp_buck = dptr;
+                        apr_bucket *tmp_buck = dptr;
 
                         /* We want to split the bucket at the '>'. The
                          * end of the END_SEQUENCE is in the current bucket.
@@ -294,8 +294,8 @@ static ap_bucket *find_end_sequence(ap_bucket *dptr, include_ctx_t *ctx, ap_buck
                          */
                         ctx->state = PARSED;
                         if ((c - buf) > 0) {
-                            ap_bucket_split(dptr, c - buf);
-                            tmp_buck = AP_BUCKET_NEXT(dptr);
+                            apr_bucket_split(dptr, c - buf);
+                            tmp_buck = APR_BUCKET_NEXT(dptr);
                         }
                         return (tmp_buck);
                     }
@@ -332,8 +332,8 @@ static ap_bucket *find_end_sequence(ap_bucket *dptr, include_ctx_t *ctx, ap_buck
             }
             c++;
         }
-        dptr = AP_BUCKET_NEXT(dptr);
-    } while (dptr != AP_BRIGADE_SENTINEL(bb));
+        dptr = APR_BUCKET_NEXT(dptr);
+    } while (dptr != APR_BRIGADE_SENTINEL(bb));
     return NULL;
 }
 
@@ -343,11 +343,11 @@ static ap_bucket *find_end_sequence(ap_bucket *dptr, include_ctx_t *ctx, ap_buck
  */
 static apr_status_t get_combined_directive (include_ctx_t *ctx,
                                             request_rec *r,
-                                            ap_bucket_brigade *bb,
+                                            apr_bucket_brigade *bb,
                                             char *tmp_buf, int tmp_buf_size)
 {
     int         done = 0;
-    ap_bucket  *dptr;
+    apr_bucket  *dptr;
     const char *tmp_from;
     apr_size_t tmp_from_len;
 
@@ -363,7 +363,7 @@ static apr_status_t get_combined_directive (include_ctx_t *ctx,
 
     /* Prime the pump. Start at the beginning of the tag... */
     dptr = ctx->tag_start_bucket;
-    ap_bucket_read (dptr, &tmp_from, &tmp_from_len, 0);  /* Read the bucket... */
+    apr_bucket_read (dptr, &tmp_from, &tmp_from_len, 0);  /* Read the bucket... */
 
     /* Adjust the pointer to start at the tag within the bucket... */
     if (dptr == ctx->tail_start_bucket) {
@@ -384,8 +384,8 @@ static apr_status_t get_combined_directive (include_ctx_t *ctx,
             done = 1;
         }
         else {
-            dptr = AP_BUCKET_NEXT (dptr);
-            ap_bucket_read (dptr, &tmp_from, &tmp_from_len, 0);
+            dptr = APR_BUCKET_NEXT (dptr);
+            apr_bucket_read (dptr, &tmp_from, &tmp_from_len, 0);
             /* Adjust the count to stop at the beginning of the tail. */
             if (dptr == ctx->tail_start_bucket) {
                 tmp_from_len -= (tmp_from_len - ctx->tail_start_index);
@@ -695,11 +695,11 @@ static void parse_string(request_rec *r, const char *in, char *out,
 /* --------------------------- Action handlers ---------------------------- */
 
 static int include_cgi(char *s, request_rec *r, ap_filter_t *next,
-                       ap_bucket *head_ptr, ap_bucket **inserted_head)
+                       apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     request_rec *rr = ap_sub_req_lookup_uri(s, r, next);
     int rr_status;
-    ap_bucket  *tmp_buck, *tmp2_buck;
+    apr_bucket  *tmp_buck, *tmp2_buck;
 
     if (rr->status != HTTP_OK) {
         return -1;
@@ -735,16 +735,16 @@ static int include_cgi(char *s, request_rec *r, ap_filter_t *next,
         location = ap_escape_html(rr->pool, location);
         len_loc = strlen(location);
 
-        tmp_buck = ap_bucket_create_immortal("<A HREF=\"", sizeof("<A HREF=\""));
-        AP_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
-        tmp2_buck = ap_bucket_create_heap(location, len_loc, 1, &h_wrt);
-        AP_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
-        tmp2_buck = ap_bucket_create_immortal("\">", sizeof("\">"));
-        AP_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
-        tmp2_buck = ap_bucket_create_heap(location, len_loc, 1, &h_wrt);
-        AP_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
-        tmp2_buck = ap_bucket_create_immortal("</A>", sizeof("</A>"));
-        AP_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
+        tmp_buck = apr_bucket_create_immortal("<A HREF=\"", sizeof("<A HREF=\""));
+        APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
+        tmp2_buck = apr_bucket_create_heap(location, len_loc, 1, &h_wrt);
+        APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
+        tmp2_buck = apr_bucket_create_immortal("\">", sizeof("\">"));
+        APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
+        tmp2_buck = apr_bucket_create_heap(location, len_loc, 1, &h_wrt);
+        APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
+        tmp2_buck = apr_bucket_create_immortal("</A>", sizeof("</A>"));
+        APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
 
         if (*inserted_head == NULL) {
             *inserted_head = tmp_buck;
@@ -797,12 +797,12 @@ static int is_only_below(const char *path)
     return 1;
 }
 
-static int handle_include(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                          ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_include(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                          ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag     = NULL;
     char *tag_val = NULL;
-    ap_bucket  *tmp_buck;
+    apr_bucket  *tmp_buck;
     char parsed_string[MAX_STRING_LEN];
 
     *inserted_head = NULL;
@@ -973,7 +973,7 @@ static apr_status_t build_argv_list(char ***argv, request_rec *r, apr_pool_t *p)
 
 
 
-static int include_cmd(include_ctx_t *ctx, ap_bucket_brigade **bb, char *s,
+static int include_cmd(include_ctx_t *ctx, apr_bucket_brigade **bb, char *s,
                        request_rec *r, ap_filter_t *f)
 {
     include_cmd_arg arg;
@@ -1054,17 +1054,17 @@ static int include_cmd(include_ctx_t *ctx, ap_bucket_brigade **bb, char *s,
                         "couldn't create child process: %d: %s", rc, s);
         }
         else {
-            ap_bucket_brigade *bcgi;
-            ap_bucket *b;
+            apr_bucket_brigade *bcgi;
+            apr_bucket *b;
 
             apr_note_subprocess(r->pool, procnew, kill_after_timeout);
             /* Fill in BUFF structure for parents pipe to child's stdout */
             file = procnew->out;
             if (!file)
                 return APR_EBADF;
-            bcgi = ap_brigade_create(r->pool);
-            b = ap_bucket_create_pipe(file);
-            AP_BRIGADE_INSERT_TAIL(bcgi, b);
+            bcgi = apr_brigade_create(r->pool);
+            b = apr_bucket_create_pipe(file);
+            APR_BRIGADE_INSERT_TAIL(bcgi, b);
             ap_pass_brigade(f->next, bcgi);
         
             /* We can't close the pipe here, because we may return before the
@@ -1077,13 +1077,13 @@ static int include_cmd(include_ctx_t *ctx, ap_bucket_brigade **bb, char *s,
     return 0;
 }
 
-static int handle_exec(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                       ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_exec(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                       ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag     = NULL;
     char *tag_val = NULL;
     char *file = r->filename;
-    ap_bucket  *tmp_buck;
+    apr_bucket  *tmp_buck;
     char parsed_string[MAX_STRING_LEN];
 
     *inserted_head = NULL;
@@ -1136,13 +1136,13 @@ static int handle_exec(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *
     return 0;
 }
 
-static int handle_echo(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                       ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_echo(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                       ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char       *tag       = NULL;
     char       *tag_val   = NULL;
     const char *echo_text = NULL;
-    ap_bucket  *tmp_buck;
+    apr_bucket  *tmp_buck;
     apr_size_t e_len, e_wrt;
     enum {E_NONE, E_URL, E_ENTITY} encode;
 
@@ -1172,12 +1172,12 @@ static int handle_echo(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *
             	}
 
                     e_len = strlen(echo_text);
-                    tmp_buck = ap_bucket_create_heap(echo_text, e_len, 1, &e_wrt);
+                    tmp_buck = apr_bucket_create_heap(echo_text, e_len, 1, &e_wrt);
                 }
                 else {
-                    tmp_buck = ap_bucket_create_immortal("(none)", sizeof("none"));
+                    tmp_buck = apr_bucket_create_immortal("(none)", sizeof("none"));
                 }
-                AP_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
+                APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                 if (*inserted_head == NULL) {
                     *inserted_head = tmp_buck;
                 }
@@ -1208,8 +1208,8 @@ static int handle_echo(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *
 /* error and tf must point to a string with room for at 
  * least MAX_STRING_LEN characters 
  */
-static int handle_config(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                         ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_config(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                         ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag     = NULL;
     char *tag_val = NULL;
@@ -1252,7 +1252,7 @@ static int handle_config(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec
                 }
             }
             else {
-                ap_bucket  *tmp_buck;
+                apr_bucket  *tmp_buck;
 
                 ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                             "unknown parameter \"%s\" to tag config in %s",
@@ -1366,14 +1366,14 @@ static void generate_size(apr_ssize_t size, char *buff, apr_size_t buff_size)
     }
 }
 
-static int handle_fsize(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                        ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_fsize(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                        ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag     = NULL;
     char *tag_val = NULL;
     apr_finfo_t  finfo;
     apr_size_t  s_len, s_wrt;
-    ap_bucket   *tmp_buck;
+    apr_bucket   *tmp_buck;
     char parsed_string[MAX_STRING_LEN];
 
     *inserted_head = NULL;
@@ -1413,8 +1413,8 @@ static int handle_fsize(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec
                         s_len = pos;
                     }
 
-                    tmp_buck = ap_bucket_create_heap(buff, s_len, 1, &s_wrt);
-                    AP_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
+                    tmp_buck = apr_bucket_create_heap(buff, s_len, 1, &s_wrt);
+                    APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                     if (*inserted_head == NULL) {
                         *inserted_head = tmp_buck;
                     }
@@ -1428,14 +1428,14 @@ static int handle_fsize(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec
     return 0;
 }
 
-static int handle_flastmod(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                           ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_flastmod(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                           ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag     = NULL;
     char *tag_val = NULL;
     apr_finfo_t  finfo;
     apr_size_t  t_len, t_wrt;
-    ap_bucket   *tmp_buck;
+    apr_bucket   *tmp_buck;
     char parsed_string[MAX_STRING_LEN];
 
     *inserted_head = NULL;
@@ -1458,8 +1458,8 @@ static int handle_flastmod(include_ctx_t *ctx, ap_bucket_brigade **bb, request_r
                     t_val = ap_ht_time(r->pool, finfo.mtime, ctx->time_str, 0);
                     t_len = strlen(t_val);
 
-                    tmp_buck = ap_bucket_create_heap(t_val, t_len, 1, &t_wrt);
-                    AP_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
+                    tmp_buck = apr_bucket_create_heap(t_val, t_len, 1, &t_wrt);
+                    APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                     if (*inserted_head == NULL) {
                         *inserted_head = tmp_buck;
                     }
@@ -2274,8 +2274,8 @@ static int parse_expr(request_rec *r, const char *expr, int *was_error,
         cond_txt[31] = '1';                                                \
     }                                                                      \
     memcpy(&cond_txt[5], tag_text, sizeof(tag_text));                      \
-    t_buck = ap_bucket_create_heap(cond_txt, sizeof(cond_txt), 1, &c_wrt); \
-    AP_BUCKET_INSERT_BEFORE(h_ptr, t_buck);                                \
+    t_buck = apr_bucket_create_heap(cond_txt, sizeof(cond_txt), 1, &c_wrt); \
+    APR_BUCKET_INSERT_BEFORE(h_ptr, t_buck);                                \
                                                                            \
     if (ins_head == NULL) {                                                \
         ins_head = t_buck;                                                 \
@@ -2285,8 +2285,8 @@ static int parse_expr(request_rec *r, const char *expr, int *was_error,
 {                                                                        \
     apr_size_t b_wrt;                                                    \
     if (d_buf[0] != '\0') {                                              \
-        t_buck = ap_bucket_create_heap(d_buf, strlen(d_buf), 1, &b_wrt); \
-        AP_BUCKET_INSERT_BEFORE(h_ptr, t_buck);                          \
+        t_buck = apr_bucket_create_heap(d_buf, strlen(d_buf), 1, &b_wrt); \
+        APR_BUCKET_INSERT_BEFORE(h_ptr, t_buck);                          \
                                                                          \
         if (ins_head == NULL) {                                          \
             ins_head = t_buck;                                           \
@@ -2303,14 +2303,14 @@ static int parse_expr(request_rec *r, const char *expr, int *was_error,
 /*-------------------------------------------------------------------------*/
 
 /* pjr - These seem to allow expr="fred" expr="joe" where joe overwrites fred. */
-static int handle_if(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                     ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_if(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                     ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag     = NULL;
     char *tag_val = NULL;
     char *expr    = NULL;
     int   expr_ret, was_error, was_unmatched;
-    ap_bucket *tmp_buck;
+    apr_bucket *tmp_buck;
     char debug_buf[MAX_DEBUG_SIZE];
 
     *inserted_head = NULL;
@@ -2354,8 +2354,8 @@ static int handle_if(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
                 if (1) {
                     apr_size_t d_len = 0, d_wrt = 0;
                     d_len = sprintf(debug_buf, "**** if expr=\"%s\"\n", expr);
-                    tmp_buck = ap_bucket_create_heap(debug_buf, d_len, 1, &d_wrt);
-                    AP_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
+                    tmp_buck = apr_bucket_create_heap(debug_buf, d_len, 1, &d_wrt);
+                    APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
 
                     if (*inserted_head == NULL) {
                         *inserted_head = tmp_buck;
@@ -2374,14 +2374,14 @@ static int handle_if(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
     return 0;
 }
 
-static int handle_elif(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                       ap_filter_t *f,  ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_elif(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                       ap_filter_t *f,  apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag     = NULL;
     char *tag_val = NULL;
     char *expr    = NULL;
     int   expr_ret, was_error, was_unmatched;
-    ap_bucket *tmp_buck;
+    apr_bucket *tmp_buck;
     char debug_buf[MAX_DEBUG_SIZE];
 
     *inserted_head = NULL;
@@ -2427,8 +2427,8 @@ static int handle_elif(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *
                 if (1) {
                     apr_size_t d_len = 0, d_wrt = 0;
                     d_len = sprintf(debug_buf, "**** elif expr=\"%s\"\n", expr);
-                    tmp_buck = ap_bucket_create_heap(debug_buf, d_len, 1, &d_wrt);
-                    AP_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
+                    tmp_buck = apr_bucket_create_heap(debug_buf, d_len, 1, &d_wrt);
+                    APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
 
                     if (*inserted_head == NULL) {
                         *inserted_head = tmp_buck;
@@ -2446,12 +2446,12 @@ static int handle_elif(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *
     return 0;
 }
 
-static int handle_else(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                       ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_else(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                       ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag = NULL;
     char *tag_val = NULL;
-    ap_bucket *tmp_buck;
+    apr_bucket *tmp_buck;
 
     *inserted_head = NULL;
     if (!ctx->if_nesting_level) {
@@ -2479,12 +2479,12 @@ static int handle_else(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *
     return 0;
 }
 
-static int handle_endif(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                        ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_endif(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                        ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag     = NULL;
     char *tag_val = NULL;
-    ap_bucket *tmp_buck;
+    apr_bucket *tmp_buck;
 
     *inserted_head = NULL;
     if (!ctx->if_nesting_level) {
@@ -2507,13 +2507,13 @@ static int handle_endif(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec
     }
 }
 
-static int handle_set(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                      ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_set(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                      ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag     = NULL;
     char *tag_val = NULL;
     char *var     = NULL;
-    ap_bucket *tmp_buck;
+    apr_bucket *tmp_buck;
     char parsed_string[MAX_STRING_LEN];
 
     *inserted_head = NULL;
@@ -2552,12 +2552,12 @@ static int handle_set(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r
     return 0;
 }
 
-static int handle_printenv(include_ctx_t *ctx, ap_bucket_brigade **bb, request_rec *r,
-                           ap_filter_t *f, ap_bucket *head_ptr, ap_bucket **inserted_head)
+static int handle_printenv(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r,
+                           ap_filter_t *f, apr_bucket *head_ptr, apr_bucket **inserted_head)
 {
     char *tag     = NULL;
     char *tag_val = NULL;
-    ap_bucket *tmp_buck;
+    apr_bucket *tmp_buck;
 
     if (ctx->flags & FLAG_PRINTING) {
         get_tag_and_value(ctx, &tag, &tag_val, 1);
@@ -2576,20 +2576,20 @@ static int handle_printenv(include_ctx_t *ctx, ap_bucket_brigade **bb, request_r
                 v_len = strlen(val_text);
 
                 /*  Key_text                                               */
-                tmp_buck = ap_bucket_create_heap(key_text, k_len, 1, &t_wrt);
-                AP_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
+                tmp_buck = apr_bucket_create_heap(key_text, k_len, 1, &t_wrt);
+                APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                 if (*inserted_head == NULL) {
                     *inserted_head = tmp_buck;
                 }
                 /*            =                                            */
-                tmp_buck = ap_bucket_create_immortal("=", 1);
-                AP_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
+                tmp_buck = apr_bucket_create_immortal("=", 1);
+                APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                 /*              Value_text                                 */
-                tmp_buck = ap_bucket_create_heap(val_text, v_len, 1, &t_wrt);
-                AP_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
+                tmp_buck = apr_bucket_create_heap(val_text, v_len, 1, &t_wrt);
+                APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                 /*                        newline...                       */
-                tmp_buck = ap_bucket_create_immortal("\n", 1);
-                AP_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
+                tmp_buck = apr_bucket_create_immortal("\n", 1);
+                APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
             }
             return 0;
         }
@@ -2606,13 +2606,13 @@ static int handle_printenv(include_ctx_t *ctx, ap_bucket_brigade **bb, request_r
 
 /* -------------------------- The main function --------------------------- */
 
-static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r, 
+static void send_parsed_content(apr_bucket_brigade **bb, request_rec *r, 
                                 ap_filter_t *f)
 {
     include_ctx_t *ctx = f->ctx;
-    ap_bucket *dptr = AP_BRIGADE_FIRST(*bb);
-    ap_bucket *tmp_dptr;
-    ap_bucket_brigade *tag_and_after;
+    apr_bucket *dptr = APR_BRIGADE_FIRST(*bb);
+    apr_bucket *tmp_dptr;
+    apr_bucket_brigade *tag_and_after;
     int ret;
 
     ap_chdir_file(r->filename);
@@ -2625,7 +2625,7 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
                   ap_escape_shell_cmd(r->pool, arg_copy));
     }
 
-    while (dptr != AP_BRIGADE_SENTINEL(*bb)) {
+    while (dptr != APR_BRIGADE_SENTINEL(*bb)) {
         /* State to check for the STARTING_SEQUENCE. */
         if ((ctx->state == PRE_HEAD) || (ctx->state == PARSE_HEAD)) {
             int do_cleanup = 0;
@@ -2637,16 +2637,16 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
              * be a tag after all. This can only happen if the starting
              * tag actually spans brigades. This should be very rare.
              */
-            if ((do_cleanup) && (!AP_BRIGADE_EMPTY(ctx->ssi_tag_brigade))) {
-                ap_bucket *tmp_bkt;
+            if ((do_cleanup) && (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade))) {
+                apr_bucket *tmp_bkt;
 
-                tmp_bkt = ap_bucket_create_immortal(STARTING_SEQUENCE, cleanup_bytes);
-                AP_BRIGADE_INSERT_HEAD(*bb, tmp_bkt);
+                tmp_bkt = apr_bucket_create_immortal(STARTING_SEQUENCE, cleanup_bytes);
+                APR_BRIGADE_INSERT_HEAD(*bb, tmp_bkt);
 
-                while (!AP_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
-                    tmp_bkt = AP_BRIGADE_FIRST(ctx->ssi_tag_brigade);
-                    AP_BUCKET_REMOVE(tmp_bkt);
-                    ap_bucket_destroy(tmp_bkt);
+                while (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
+                    tmp_bkt = APR_BRIGADE_FIRST(ctx->ssi_tag_brigade);
+                    APR_BUCKET_REMOVE(tmp_bkt);
+                    apr_bucket_destroy(tmp_bkt);
                 }
             }
 
@@ -2654,14 +2654,14 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
              *   then I need to throw away anything contained in it.
              */
             if ((!(ctx->flags & FLAG_PRINTING)) && (tmp_dptr != NULL) &&
-                (dptr != AP_BRIGADE_SENTINEL(*bb))) {
-                while ((dptr != AP_BRIGADE_SENTINEL(*bb)) &&
+                (dptr != APR_BRIGADE_SENTINEL(*bb))) {
+                while ((dptr != APR_BRIGADE_SENTINEL(*bb)) &&
                        (dptr != tmp_dptr)) {
-                    ap_bucket *free_bucket = dptr;
+                    apr_bucket *free_bucket = dptr;
 
-                    dptr = AP_BUCKET_NEXT (dptr);
-                    AP_BUCKET_REMOVE(free_bucket);
-                    ap_bucket_destroy(free_bucket);
+                    dptr = APR_BUCKET_NEXT (dptr);
+                    APR_BUCKET_REMOVE(free_bucket);
+                    apr_bucket_destroy(free_bucket);
                 }
             }
 
@@ -2671,11 +2671,11 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
                     dptr = ctx->tag_start_bucket;
                 }
                 else {
-                    dptr = AP_BRIGADE_SENTINEL(*bb);
+                    dptr = APR_BRIGADE_SENTINEL(*bb);
                 }
             }
             else if (tmp_dptr == NULL) { /* There was no possible SSI tag in the */
-                dptr = AP_BRIGADE_SENTINEL(*bb);  /* remainder of this brigade...    */
+                dptr = APR_BRIGADE_SENTINEL(*bb);  /* remainder of this brigade...    */
             }
         }
 
@@ -2683,7 +2683,7 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
         if (((ctx->state == PARSE_DIRECTIVE) ||
              (ctx->state == PARSE_TAG)       ||
              (ctx->state == PARSE_TAIL))       &&
-            (dptr != AP_BRIGADE_SENTINEL(*bb))) {
+            (dptr != APR_BRIGADE_SENTINEL(*bb))) {
             tmp_dptr = find_end_sequence(dptr, ctx, *bb);
 
             if (tmp_dptr != NULL) {
@@ -2695,24 +2695,24 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
                  * In any event after this the entire set of tag buckets will be
                  * in one place or another.
                  */
-                if (!AP_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
-                    tag_and_after = ap_brigade_split(*bb, dptr);
-                    AP_BRIGADE_CONCAT(ctx->ssi_tag_brigade, *bb);
+                if (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
+                    tag_and_after = apr_brigade_split(*bb, dptr);
+                    APR_BRIGADE_CONCAT(ctx->ssi_tag_brigade, *bb);
                     *bb = tag_and_after;
                 }
             }
             else {
-                dptr = AP_BRIGADE_SENTINEL(*bb);  /* remainder of this brigade...    */
+                dptr = APR_BRIGADE_SENTINEL(*bb);  /* remainder of this brigade...    */
             }
         }
 
         /* State to processed the directive... */
         if (ctx->state == PARSED) {
-            ap_bucket    *content_head = NULL, *tmp_bkt;
+            apr_bucket    *content_head = NULL, *tmp_bkt;
             apr_size_t    tmp_i;
             char          tmp_buf[TMP_BUF_SIZE];
-            int (*handle_func)(include_ctx_t *, ap_bucket_brigade **, request_rec *,
-                           ap_filter_t *, ap_bucket *, ap_bucket **);
+            int (*handle_func)(include_ctx_t *, apr_bucket_brigade **, request_rec *,
+                           ap_filter_t *, apr_bucket *, apr_bucket **);
 
             /* By now the full tag (all buckets) should either be set aside into
              *  ssi_tag_brigade or contained within the current bb. All tag
@@ -2732,21 +2732,21 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
 
                 /* DO CLEANUP HERE!!!!! */
                 tmp_dptr = ctx->head_start_bucket;
-                if (!AP_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
-                    while (!AP_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
-                        tmp_bkt = AP_BRIGADE_FIRST(ctx->ssi_tag_brigade);
-                        AP_BUCKET_REMOVE(tmp_bkt);
-                        ap_bucket_destroy(tmp_bkt);
+                if (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
+                    while (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
+                        tmp_bkt = APR_BRIGADE_FIRST(ctx->ssi_tag_brigade);
+                        APR_BUCKET_REMOVE(tmp_bkt);
+                        apr_bucket_destroy(tmp_bkt);
                     }
                 }
                 else {
                     do {
                         tmp_bkt  = tmp_dptr;
-                        tmp_dptr = AP_BUCKET_NEXT (tmp_dptr);
-                        AP_BUCKET_REMOVE(tmp_bkt);
-                        ap_bucket_destroy(tmp_bkt);
+                        tmp_dptr = APR_BUCKET_NEXT (tmp_dptr);
+                        APR_BUCKET_REMOVE(tmp_bkt);
+                        apr_bucket_destroy(tmp_bkt);
                     } while ((tmp_dptr != dptr) &&
-                             (tmp_dptr != AP_BRIGADE_SENTINEL(*bb)));
+                             (tmp_dptr != APR_BRIGADE_SENTINEL(*bb)));
                 }
 
                 return;
@@ -2777,8 +2777,8 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
             ctx->curr_tag_pos = &ctx->combined_tag[ctx->directive_length+1];
 
             handle_func = 
-                (int (*)(include_ctx_t *, ap_bucket_brigade **, request_rec *,
-                    ap_filter_t *, ap_bucket *, ap_bucket **))
+                (int (*)(include_ctx_t *, apr_bucket_brigade **, request_rec *,
+                    ap_filter_t *, apr_bucket *, apr_bucket **))
                 apr_hash_get(include_hash, ctx->combined_tag, ctx->directive_length+1);
             if (handle_func != NULL) {
                 ret = (*handle_func)(ctx, bb, r, f, dptr, &content_head);
@@ -2812,21 +2812,21 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
                 content_head = dptr;
             }
             tmp_dptr = ctx->head_start_bucket;
-            if (!AP_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
-                while (!AP_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
-                    tmp_bkt = AP_BRIGADE_FIRST(ctx->ssi_tag_brigade);
-                    AP_BUCKET_REMOVE(tmp_bkt);
-                    ap_bucket_destroy(tmp_bkt);
+            if (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
+                while (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
+                    tmp_bkt = APR_BRIGADE_FIRST(ctx->ssi_tag_brigade);
+                    APR_BUCKET_REMOVE(tmp_bkt);
+                    apr_bucket_destroy(tmp_bkt);
                 }
             }
             else {
                 do {
                     tmp_bkt  = tmp_dptr;
-                    tmp_dptr = AP_BUCKET_NEXT (tmp_dptr);
-                    AP_BUCKET_REMOVE(tmp_bkt);
-                    ap_bucket_destroy(tmp_bkt);
+                    tmp_dptr = APR_BUCKET_NEXT (tmp_dptr);
+                    APR_BUCKET_REMOVE(tmp_bkt);
+                    apr_bucket_destroy(tmp_bkt);
                 } while ((tmp_dptr != content_head) &&
-                         (tmp_dptr != AP_BRIGADE_SENTINEL(*bb)));
+                         (tmp_dptr != APR_BRIGADE_SENTINEL(*bb)));
             }
             if (ctx->combined_tag == tmp_buf) {
                 memset (ctx->combined_tag, '\0', ctx->tag_length);
@@ -2845,11 +2845,11 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
             ctx->tag_length        = 0;
             ctx->directive_length  = 0;
 
-            if (!AP_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
-                while (!AP_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
-                    tmp_bkt = AP_BRIGADE_FIRST(ctx->ssi_tag_brigade);
-                    AP_BUCKET_REMOVE(tmp_bkt);
-                    ap_bucket_destroy(tmp_bkt);
+            if (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
+                while (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
+                    tmp_bkt = APR_BRIGADE_FIRST(ctx->ssi_tag_brigade);
+                    APR_BUCKET_REMOVE(tmp_bkt);
+                    apr_bucket_destroy(tmp_bkt);
                 }
             }
 
@@ -2865,38 +2865,38 @@ static void send_parsed_content(ap_bucket_brigade **bb, request_rec *r,
      */
     if (ctx->state == PRE_HEAD) {
         /* Inside a false conditional (if, elif, else), so toss it all... */
-        if ((dptr != AP_BRIGADE_SENTINEL(*bb)) &&
+        if ((dptr != APR_BRIGADE_SENTINEL(*bb)) &&
             (!(ctx->flags & FLAG_PRINTING))) {
-            ap_bucket *free_bucket;
+            apr_bucket *free_bucket;
             do {
                 free_bucket = dptr;
-                dptr = AP_BUCKET_NEXT (dptr);
-                AP_BUCKET_REMOVE(free_bucket);
-                ap_bucket_destroy(free_bucket);
-            } while (dptr != AP_BRIGADE_SENTINEL(*bb));
+                dptr = APR_BUCKET_NEXT (dptr);
+                APR_BUCKET_REMOVE(free_bucket);
+                apr_bucket_destroy(free_bucket);
+            } while (dptr != APR_BRIGADE_SENTINEL(*bb));
         }
         else { /* Otherwise pass it along... */
             ap_pass_brigade(f->next, *bb);  /* No SSI tags in this brigade... */
         }
     }
     else if (ctx->state == PARSED) {     /* Invalid internal condition... */
-        ap_bucket *content_head = NULL, *tmp_bkt;
+        apr_bucket *content_head = NULL, *tmp_bkt;
         ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                       "Invalid mod_include state during file %s", r->filename);
-        CREATE_ERROR_BUCKET(ctx, tmp_bkt, AP_BRIGADE_FIRST(*bb), content_head);
+        CREATE_ERROR_BUCKET(ctx, tmp_bkt, APR_BRIGADE_FIRST(*bb), content_head);
     }
     else {                 /* Entire brigade is middle chunk of SSI tag... */
-        if (!AP_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
-            AP_BRIGADE_CONCAT(ctx->ssi_tag_brigade, *bb);
+        if (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
+            APR_BRIGADE_CONCAT(ctx->ssi_tag_brigade, *bb);
         }
         else {             /* End of brigade contains part of SSI tag... */
             if (ctx->head_start_index > 0) {
-                ap_bucket_split(ctx->head_start_bucket, ctx->head_start_index);
-                ctx->head_start_bucket = AP_BUCKET_NEXT(ctx->head_start_bucket);
+                apr_bucket_split(ctx->head_start_bucket, ctx->head_start_index);
+                ctx->head_start_bucket = APR_BUCKET_NEXT(ctx->head_start_bucket);
                 ctx->head_start_index  = 0;
             }
                            /* Set aside tag, pass pre-tag... */
-            tag_and_after = ap_brigade_split(*bb, ctx->head_start_bucket);
+            tag_and_after = apr_brigade_split(*bb, ctx->head_start_bucket);
             ap_save_brigade(f, &ctx->ssi_tag_brigade, &tag_and_after);
             ap_pass_brigade(f->next, *bb);
         }
@@ -2947,7 +2947,7 @@ static const char *set_xbithack(cmd_parms *cmd, void *xbp, const char *arg)
     return NULL;
 }
 
-static int includes_filter(ap_filter_t *f, ap_bucket_brigade *b)
+static int includes_filter(ap_filter_t *f, apr_bucket_brigade *b)
 {
     request_rec *r = f->r;
     include_ctx_t *ctx = f->ctx;
@@ -2971,7 +2971,7 @@ static int includes_filter(ap_filter_t *f, ap_bucket_brigade *b)
             if (ap_allow_options(r) & OPT_INCNOEXEC) {
                 ctx->flags |= FLAG_NO_EXEC;
             }
-            ctx->ssi_tag_brigade = ap_brigade_create(f->c->pool);
+            ctx->ssi_tag_brigade = apr_brigade_create(f->c->pool);
 
             apr_cpystrn(ctx->error_str, DEFAULT_ERROR_MSG,   sizeof(ctx->error_str));
             apr_cpystrn(ctx->time_str,  DEFAULT_TIME_FORMAT, sizeof(ctx->time_str));
@@ -3067,7 +3067,7 @@ static const command_rec includes_cmds[] =
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_post_config(include_post_config, NULL, NULL, AP_HOOK_REALLY_FIRST);
+    ap_hook_post_config(include_post_config, NULL, NULL, APR_HOOK_REALLY_FIRST);
     ap_register_output_filter("INCLUDES", includes_filter, AP_FTYPE_CONTENT);
 }
 
diff --git a/modules/filters/mod_include.h b/modules/filters/mod_include.h
index a537afb..efd1c9b 100644
--- a/modules/filters/mod_include.h
+++ b/modules/filters/mod_include.h
@@ -146,13 +146,13 @@ typedef struct include_filter_ctx {
     int          if_nesting_level;
     apr_size_t   parse_pos;
     
-    ap_bucket   *head_start_bucket;
+    apr_bucket   *head_start_bucket;
     apr_size_t   head_start_index;
 
-    ap_bucket   *tag_start_bucket;
+    apr_bucket   *tag_start_bucket;
     apr_size_t   tag_start_index;
 
-    ap_bucket   *tail_start_bucket;
+    apr_bucket   *tail_start_bucket;
     apr_size_t   tail_start_index;
 
     char        *combined_tag;
@@ -164,7 +164,7 @@ typedef struct include_filter_ctx {
     char         error_str[MAX_STRING_LEN];
     char         time_str[MAX_STRING_LEN];
 
-    ap_bucket_brigade *ssi_tag_brigade;
+    apr_bucket_brigade *ssi_tag_brigade;
 } include_ctx_t;
 
 /* These flags are used to set flag bits. */
@@ -181,9 +181,9 @@ typedef struct include_filter_ctx {
 #define CREATE_ERROR_BUCKET(cntx, t_buck, h_ptr, ins_head)        \
 {                                                                 \
     apr_size_t e_wrt;                                             \
-    t_buck = ap_bucket_create_heap(cntx->error_str,               \
+    t_buck = apr_bucket_create_heap(cntx->error_str,               \
                                    ctx->error_length, 1, &e_wrt); \
-    AP_BUCKET_INSERT_BEFORE(h_ptr, t_buck);                       \
+    APR_BUCKET_INSERT_BEFORE(h_ptr, t_buck);                       \
                                                                   \
     if (ins_head == NULL) {                                       \
         ins_head = t_buck;                                        \
@@ -191,18 +191,18 @@ typedef struct include_filter_ctx {
 }
 
 #define SPLIT_AND_PASS_PRETAG_BUCKETS(brgd, cntxt)               \
-if ((AP_BRIGADE_EMPTY(cntxt->ssi_tag_brigade)) &&                \
+if ((APR_BRIGADE_EMPTY(cntxt->ssi_tag_brigade)) &&                \
     (cntxt->head_start_bucket != NULL)) {                        \
-    ap_bucket_brigade *tag_plus;                                 \
+    apr_bucket_brigade *tag_plus;                                 \
                                                                  \
-    tag_plus = ap_brigade_split(brgd, cntxt->head_start_bucket); \
+    tag_plus = apr_brigade_split(brgd, cntxt->head_start_bucket); \
     ap_pass_brigade(f->next, brgd);                              \
     brgd = tag_plus;                                             \
 }
 
-typedef int (*handler)(include_ctx_t *ctx, ap_bucket_brigade **bb, 
-                       request_rec *r, ap_filter_t *f, ap_bucket *head_ptr, 
-                       ap_bucket **inserted_head);
+typedef int (*handler)(include_ctx_t *ctx, apr_bucket_brigade **bb, 
+                       request_rec *r, ap_filter_t *f, apr_bucket *head_ptr, 
+                       apr_bucket **inserted_head);
 
 void ap_register_include_handler(char *tag, handler func);
 
diff --git a/modules/generators/mod_asis.c b/modules/generators/mod_asis.c
index cb65f20..7e5daa6 100644
--- a/modules/generators/mod_asis.c
+++ b/modules/generators/mod_asis.c
@@ -126,7 +126,7 @@ static int asis_handler(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_handler(asis_handler,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_handler(asis_handler,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA asis_module =
diff --git a/modules/generators/mod_autoindex.c b/modules/generators/mod_autoindex.c
index 54357cd..49efda9 100644
--- a/modules/generators/mod_autoindex.c
+++ b/modules/generators/mod_autoindex.c
@@ -1700,7 +1700,7 @@ static int handle_autoindex(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_handler(handle_autoindex,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_handler(handle_autoindex,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA autoindex_module =
diff --git a/modules/generators/mod_cgi.c b/modules/generators/mod_cgi.c
index b293a4a..8ce1e88 100644
--- a/modules/generators/mod_cgi.c
+++ b/modules/generators/mod_cgi.c
@@ -75,7 +75,7 @@
 
 #define CORE_PRIVATE
 
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 #include "util_filter.h"
 #include "ap_config.h"
 #include "httpd.h"
@@ -506,8 +506,8 @@ static int cgi_handler(request_rec *r)
     const char **argv;
     char *dbuf = NULL;
     apr_file_t *script_out = NULL, *script_in = NULL, *script_err = NULL;
-    ap_bucket_brigade *bb;
-    ap_bucket *b;
+    apr_bucket_brigade *bb;
+    apr_bucket *b;
     char argsbuffer[HUGE_STRING_LEN];
     int is_included = !strcmp(r->protocol, "INCLUDED");
     apr_pool_t *p;
@@ -696,11 +696,11 @@ static int cgi_handler(request_rec *r)
 
 	ap_send_http_header(r);
 	if (!r->header_only) {
-            bb = ap_brigade_create(r->pool);
-	    b = ap_bucket_create_pipe(script_in);
-	    AP_BRIGADE_INSERT_TAIL(bb, b);
-            b = ap_bucket_create_eos();
-	    AP_BRIGADE_INSERT_TAIL(bb, b);
+            bb = apr_brigade_create(r->pool);
+	    b = apr_bucket_create_pipe(script_in);
+	    APR_BRIGADE_INSERT_TAIL(bb, b);
+            b = apr_bucket_create_eos();
+	    APR_BRIGADE_INSERT_TAIL(bb, b);
 	    ap_pass_brigade(r->output_filters, bb);
 	}
 
@@ -709,11 +709,11 @@ static int cgi_handler(request_rec *r)
     }
 
     if (script_in && nph) {
-        bb = ap_brigade_create(r->pool);
-	b = ap_bucket_create_pipe(script_in);
-	AP_BRIGADE_INSERT_TAIL(bb, b);
-	b = ap_bucket_create_eos();
-	AP_BRIGADE_INSERT_TAIL(bb, b);
+        bb = apr_brigade_create(r->pool);
+	b = apr_bucket_create_pipe(script_in);
+	APR_BRIGADE_INSERT_TAIL(bb, b);
+	b = apr_bucket_create_eos();
+	APR_BRIGADE_INSERT_TAIL(bb, b);
         ap_pass_brigade(r->output_filters, bb);
     }
 
@@ -722,7 +722,7 @@ static int cgi_handler(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_handler(cgi_handler, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_handler(cgi_handler, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA cgi_module =
diff --git a/modules/generators/mod_cgid.c b/modules/generators/mod_cgid.c
index afca7e4..5377ebc 100644
--- a/modules/generators/mod_cgid.c
+++ b/modules/generators/mod_cgid.c
@@ -78,7 +78,7 @@
 #include "apr_general.h"
 #include "apr_file_io.h"
 #include "apr_portable.h"
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 #include "util_filter.h"
 #include "httpd.h" 
 #include "http_config.h" 
@@ -734,8 +734,8 @@ static int cgid_handler(request_rec *r)
 { 
     int retval, nph, dbpos = 0; 
     char *argv0, *dbuf = NULL; 
-    ap_bucket_brigade *bb;
-    ap_bucket *b;
+    apr_bucket_brigade *bb;
+    apr_bucket *b;
     char argsbuffer[HUGE_STRING_LEN]; 
     void *sconf;
     cgid_server_conf *conf;
@@ -908,21 +908,21 @@ static int cgid_handler(request_rec *r)
 
         ap_send_http_header(r); 
         if (!r->header_only) { 
-            bb = ap_brigade_create(r->pool);
-            b = ap_bucket_create_pipe(tempsock);
-            AP_BRIGADE_INSERT_TAIL(bb, b);
-            b = ap_bucket_create_eos();
-            AP_BRIGADE_INSERT_TAIL(bb, b);
+            bb = apr_brigade_create(r->pool);
+            b = apr_bucket_create_pipe(tempsock);
+            APR_BRIGADE_INSERT_TAIL(bb, b);
+            b = apr_bucket_create_eos();
+            APR_BRIGADE_INSERT_TAIL(bb, b);
             ap_pass_brigade(r->output_filters, bb);
         } 
     } 
 
     if (nph) {
-        bb = ap_brigade_create(r->pool);
-        b = ap_bucket_create_pipe(tempsock);
-        AP_BRIGADE_INSERT_TAIL(bb, b);
-        b = ap_bucket_create_eos();
-        AP_BRIGADE_INSERT_TAIL(bb, b);
+        bb = apr_brigade_create(r->pool);
+        b = apr_bucket_create_pipe(tempsock);
+        APR_BRIGADE_INSERT_TAIL(bb, b);
+        b = apr_bucket_create_eos();
+        APR_BRIGADE_INSERT_TAIL(bb, b);
         ap_pass_brigade(r->output_filters, bb);
     } 
 
@@ -933,8 +933,8 @@ static int cgid_handler(request_rec *r)
 
 static void register_hook(apr_pool_t *p)
 {
-    ap_hook_post_config(cgid_init, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_handler(cgid_handler, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_post_config(cgid_init, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_handler(cgid_handler, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA cgid_module = { 
diff --git a/modules/generators/mod_info.c b/modules/generators/mod_info.c
index 6117d9c..91e183a 100644
--- a/modules/generators/mod_info.c
+++ b/modules/generators/mod_info.c
@@ -468,7 +468,7 @@ static const command_rec info_cmds[] =
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_handler(display_info, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_handler(display_info, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA info_module =
diff --git a/modules/generators/mod_status.c b/modules/generators/mod_status.c
index ec4038c..dee3436 100644
--- a/modules/generators/mod_status.c
+++ b/modules/generators/mod_status.c
@@ -126,7 +126,7 @@ static int status_handler(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_handler(status_handler, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_handler(status_handler, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA status_module =
diff --git a/modules/generators/mod_suexec.c b/modules/generators/mod_suexec.c
index 7ecc65e..ed83cf9 100644
--- a/modules/generators/mod_suexec.c
+++ b/modules/generators/mod_suexec.c
@@ -143,7 +143,7 @@ static const command_rec suexec_cmds[] =
 
 static void suexec_hooks(apr_pool_t *p)
 {
-    ap_hook_get_suexec_identity(get_suexec_id_doer,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_get_suexec_identity(get_suexec_id_doer,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module MODULE_VAR_EXPORT suexec_module =
diff --git a/modules/http/http_core.c b/modules/http/http_core.c
index ce4a1a3..e50d020 100644
--- a/modules/http/http_core.c
+++ b/modules/http/http_core.c
@@ -79,7 +79,7 @@
 #include "rfc1413.h"
 #include "util_md5.h"
 #include "http_connection.h"
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 #include "util_filter.h"
 #include "util_ebcdic.h"
 #include "mpm.h"
@@ -2974,8 +2974,8 @@ static int do_nothing(request_rec *r) { return OK; }
 
 static int default_handler(request_rec *r)
 {
-    ap_bucket_brigade *bb;
-    ap_bucket *e;
+    apr_bucket_brigade *bb;
+    apr_bucket *e;
     core_dir_config *d;
     int errstatus;
     apr_file_t *fd = NULL;
@@ -3053,12 +3053,12 @@ static int default_handler(request_rec *r)
                        ap_md5digest(r->pool, fd));
     }
 
-    bb = ap_brigade_create(r->pool);
-    e = ap_bucket_create_file(fd, 0, r->finfo.size);
+    bb = apr_brigade_create(r->pool);
+    e = apr_bucket_create_file(fd, 0, r->finfo.size);
 
-    AP_BRIGADE_INSERT_HEAD(bb, e);
-    e = ap_bucket_create_eos();
-    AP_BRIGADE_INSERT_TAIL(bb, e);
+    APR_BRIGADE_INSERT_HEAD(bb, e);
+    e = apr_bucket_create_eos();
+    APR_BRIGADE_INSERT_TAIL(bb, e);
 
     return ap_pass_brigade(r->output_filters, bb);
 }
@@ -3082,11 +3082,11 @@ typedef struct COALESCE_FILTER_CTX {
     apr_size_t avail;   /* Number of bytes available in the buf */
 } coalesce_filter_ctx_t;
 #define MIN_BUCKET_SIZE 200
-static apr_status_t coalesce_filter(ap_filter_t *f, ap_bucket_brigade *b)
+static apr_status_t coalesce_filter(ap_filter_t *f, apr_bucket_brigade *b)
 {
     apr_status_t rv;
     apr_pool_t *p = f->r->pool;
-    ap_bucket *e, *insert_before = NULL, *destroy_me = NULL;
+    apr_bucket *e, *insert_before = NULL, *destroy_me = NULL;
     coalesce_filter_ctx_t *ctx = f->ctx;
     int pass_the_brigade = 0, insert_first = 0;
 
@@ -3102,19 +3102,19 @@ static apr_status_t coalesce_filter(ap_filter_t *f, ap_bucket_brigade *b)
     /* Iterate across the buckets, coalescing the small buckets into a 
      * single buffer 
      */
-    AP_BRIGADE_FOREACH(e, b) {
+    APR_BRIGADE_FOREACH(e, b) {
         if (destroy_me) {
-            ap_bucket_destroy(destroy_me);
+            apr_bucket_destroy(destroy_me);
             destroy_me = NULL;
         }
-        if (AP_BUCKET_IS_EOS(e)  || AP_BUCKET_IS_FILE(e) ||
-            AP_BUCKET_IS_PIPE(e) || AP_BUCKET_IS_FLUSH(e)) {
+        if (APR_BUCKET_IS_EOS(e)  || APR_BUCKET_IS_FILE(e) ||
+            APR_BUCKET_IS_PIPE(e) || APR_BUCKET_IS_FLUSH(e)) {
             pass_the_brigade = 1;
         }
         else {
             const char *str;
             apr_size_t n;
-            rv = ap_bucket_read(e, &str, &n, AP_BLOCK_READ);
+            rv = apr_bucket_read(e, &str, &n, APR_BLOCK_READ);
             if (rv != APR_SUCCESS) {
                 /* XXX: log error */
                 return rv;
@@ -3135,7 +3135,7 @@ static apr_status_t coalesce_filter(ap_filter_t *f, ap_bucket_brigade *b)
                  * ctx->buf into the brigade when we're done.
                  */
                 if (insert_before || insert_first){
-                    AP_BUCKET_REMOVE(e);
+                    APR_BUCKET_REMOVE(e);
                     destroy_me = e;
                 }
                 else {
@@ -3160,20 +3160,20 @@ static apr_status_t coalesce_filter(ap_filter_t *f, ap_bucket_brigade *b)
     }
 
     if (destroy_me) {
-        ap_bucket_destroy(destroy_me);
+        apr_bucket_destroy(destroy_me);
         destroy_me = NULL;
     }
 
     if (pass_the_brigade) {
         /* Insert ctx->buf into the correct spot in the brigade */
-        e = ap_bucket_create_pool(ctx->buf, ctx->cnt, p);
+        e = apr_bucket_create_pool(ctx->buf, ctx->cnt, p);
         if (insert_first) {
-            AP_BRIGADE_INSERT_HEAD(b, e);
+            APR_BRIGADE_INSERT_HEAD(b, e);
         } 
         else if (insert_before) {
-            AP_BUCKET_INSERT_BEFORE(e, insert_before);
-            AP_BUCKET_REMOVE(insert_before);
-            ap_bucket_destroy(insert_before);
+            APR_BUCKET_INSERT_BEFORE(e, insert_before);
+            APR_BUCKET_REMOVE(insert_before);
+            apr_bucket_destroy(insert_before);
             insert_before = NULL;
         }
         rv = ap_pass_brigade(f->next, b);
@@ -3190,8 +3190,8 @@ static apr_status_t coalesce_filter(ap_filter_t *f, ap_bucket_brigade *b)
     }
     else {
         if (insert_before) {
-            AP_BUCKET_REMOVE(insert_before);
-            ap_bucket_destroy(insert_before);
+            APR_BUCKET_REMOVE(insert_before);
+            apr_bucket_destroy(insert_before);
         }
         /* The brigade should be empty now because all the buckets
          * were coalesced into the coalesce_filter buf
@@ -3203,21 +3203,21 @@ static apr_status_t coalesce_filter(ap_filter_t *f, ap_bucket_brigade *b)
 /*
  * HTTP/1.1 chunked transfer encoding filter.
  */
-static apr_status_t chunk_filter(ap_filter_t *f, ap_bucket_brigade *b)
+static apr_status_t chunk_filter(ap_filter_t *f, apr_bucket_brigade *b)
 {
 #define ASCII_CRLF  "\015\012"
 #define ASCII_ZERO  "\060"
-    ap_bucket_brigade *more = NULL;
-    ap_bucket *e;
+    apr_bucket_brigade *more = NULL;
+    apr_bucket *e;
     apr_status_t rv;
 
     for (more = NULL; b; b = more, more = NULL) {
 	apr_off_t bytes = 0;
-        ap_bucket *eos = NULL;
+        apr_bucket *eos = NULL;
         char chunk_hdr[20]; /* enough space for the snprintf below */
 
-	AP_BRIGADE_FOREACH(e, b) {
-	    if (AP_BUCKET_IS_EOS(e)) {
+	APR_BRIGADE_FOREACH(e, b) {
+	    if (APR_BUCKET_IS_EOS(e)) {
 		/* there shouldn't be anything after the eos */
 		eos = e;
 		break;
@@ -3227,7 +3227,7 @@ static apr_status_t chunk_filter(ap_filter_t *f, ap_bucket_brigade *b)
 		const char *data;
 		apr_size_t len;
 
-		rv = ap_bucket_read(e, &data, &len, AP_BLOCK_READ);
+		rv = apr_bucket_read(e, &data, &len, APR_BLOCK_READ);
 		if (rv != APR_SUCCESS) {
 		    return rv;
 		}
@@ -3238,7 +3238,7 @@ static apr_status_t chunk_filter(ap_filter_t *f, ap_bucket_brigade *b)
 		     * block so we pass down what we have so far.
 		     */
 		    bytes += len;
-                    more = ap_brigade_split(b, AP_BUCKET_NEXT(e));
+                    more = apr_brigade_split(b, APR_BUCKET_NEXT(e));
 		    break;
 		}
 		else {
@@ -3272,19 +3272,19 @@ static apr_status_t chunk_filter(ap_filter_t *f, ap_bucket_brigade *b)
             hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr),
                                    "%qx" CRLF, (apr_uint64_t)bytes);
             ap_xlate_proto_to_ascii(chunk_hdr, hdr_len);
-            e = ap_bucket_create_transient(chunk_hdr, hdr_len);
-            AP_BRIGADE_INSERT_HEAD(b, e);
+            e = apr_bucket_create_transient(chunk_hdr, hdr_len);
+            APR_BRIGADE_INSERT_HEAD(b, e);
 
             /*
              * Insert the end-of-chunk CRLF before the EOS bucket, or
              * appended to the brigade
              */
-            e = ap_bucket_create_immortal(ASCII_CRLF, 2);
+            e = apr_bucket_create_immortal(ASCII_CRLF, 2);
             if (eos != NULL) {
-                AP_BUCKET_INSERT_BEFORE(eos, e);
+                APR_BUCKET_INSERT_BEFORE(eos, e);
             }
             else {
-                AP_BRIGADE_INSERT_TAIL(b, e);
+                APR_BRIGADE_INSERT_TAIL(b, e);
             }
         }
 
@@ -3303,8 +3303,8 @@ static apr_status_t chunk_filter(ap_filter_t *f, ap_bucket_brigade *b)
          */
         if (eos != NULL) {
             /* XXX: (2) trailers ... does not yet exist */
-            e = ap_bucket_create_immortal(ASCII_ZERO ASCII_CRLF /* <trailers> */ ASCII_CRLF, 5);
-            AP_BUCKET_INSERT_BEFORE(eos, e);
+            e = apr_bucket_create_immortal(ASCII_ZERO ASCII_CRLF /* <trailers> */ ASCII_CRLF, 5);
+            APR_BUCKET_INSERT_BEFORE(eos, e);
         }
 
         /* pass the brigade to the next filter. */
@@ -3317,14 +3317,14 @@ static apr_status_t chunk_filter(ap_filter_t *f, ap_bucket_brigade *b)
     return APR_SUCCESS;
 }
 
-static int core_input_filter(ap_filter_t *f, ap_bucket_brigade *b, ap_input_mode_t mode)
+static int core_input_filter(ap_filter_t *f, apr_bucket_brigade *b, ap_input_mode_t mode)
 {
-    ap_bucket *e;
+    apr_bucket *e;
     
     if (!f->ctx) {    /* If we haven't passed up the socket yet... */
         f->ctx = (void *)1;
-        e = ap_bucket_create_socket(f->c->client_socket);
-        AP_BRIGADE_INSERT_TAIL(b, e);
+        e = apr_bucket_create_socket(f->c->client_socket);
+        APR_BRIGADE_INSERT_TAIL(b, e);
         return APR_SUCCESS;
     }
     else {            
@@ -3341,15 +3341,15 @@ static int core_input_filter(ap_filter_t *f, ap_bucket_brigade *b, ap_input_mode
  * the actual data.
  */
 typedef struct CORE_OUTPUT_FILTER_CTX {
-    ap_bucket_brigade *b;
+    apr_bucket_brigade *b;
 } core_output_filter_ctx_t;
 #define MAX_IOVEC_TO_WRITE 16
-static apr_status_t core_output_filter(ap_filter_t *f, ap_bucket_brigade *b)
+static apr_status_t core_output_filter(ap_filter_t *f, apr_bucket_brigade *b)
 {
     apr_status_t rv;
-    ap_bucket_brigade *more = NULL;
+    apr_bucket_brigade *more = NULL;
     apr_size_t bytes_sent = 0, nbytes;
-    ap_bucket *e;
+    apr_bucket *e;
     conn_rec *c = f->c;
     core_output_filter_ctx_t *ctx = f->ctx;
 
@@ -3367,7 +3367,7 @@ static apr_status_t core_output_filter(ap_filter_t *f, ap_bucket_brigade *b)
     }
     /* If we have a saved brigade, concatenate the new brigade to it */
     if (ctx->b) {
-        AP_BRIGADE_CONCAT(ctx->b, b);
+        APR_BRIGADE_CONCAT(ctx->b, b);
         b = ctx->b;
         ctx->b = NULL;
     }
@@ -3376,13 +3376,13 @@ static apr_status_t core_output_filter(ap_filter_t *f, ap_bucket_brigade *b)
     while (b) {
         nbytes = 0; /* in case more points to another brigade */
         more = NULL;
-        AP_BRIGADE_FOREACH(e, b) {
-            if (AP_BUCKET_IS_EOS(e) || AP_BUCKET_IS_FLUSH(e)) {
+        APR_BRIGADE_FOREACH(e, b) {
+            if (APR_BUCKET_IS_EOS(e) || APR_BUCKET_IS_FLUSH(e)) {
                 break;
             }
-            else if (AP_BUCKET_IS_FILE(e)) {
-                ap_bucket_file *a = e->data;
-                /* Assume there is at most one AP_BUCKET_FILE in the brigade */
+            else if (APR_BUCKET_IS_FILE(e)) {
+                apr_bucket_file *a = e->data;
+                /* Assume there is at most one APR_BUCKET_FILE in the brigade */
                 fd = a->fd;
                 flen = e->length;
                 foffset = a->offset;
@@ -3390,7 +3390,7 @@ static apr_status_t core_output_filter(ap_filter_t *f, ap_bucket_brigade *b)
             else {
                 const char *str;
                 apr_size_t n;
-                rv = ap_bucket_read(e, &str, &n, AP_BLOCK_READ);
+                rv = apr_bucket_read(e, &str, &n, APR_BLOCK_READ);
                 if (n) {
                     nbytes += n;
                     if (!fd) {
@@ -3409,8 +3409,8 @@ static apr_status_t core_output_filter(ap_filter_t *f, ap_bucket_brigade *b)
 
             if ((nvec == MAX_IOVEC_TO_WRITE) || (nvec_trailers == MAX_IOVEC_TO_WRITE)) {
                 /* Split the brigade and break */
-                if (AP_BUCKET_NEXT(e) != AP_BRIGADE_SENTINEL(b)) {
-                    more = ap_brigade_split(b, AP_BUCKET_NEXT(e));
+                if (APR_BUCKET_NEXT(e) != APR_BRIGADE_SENTINEL(b)) {
+                    more = apr_brigade_split(b, APR_BUCKET_NEXT(e));
                 }
                 break;
             }
@@ -3419,16 +3419,16 @@ static apr_status_t core_output_filter(ap_filter_t *f, ap_bucket_brigade *b)
         /* Completed iterating over the brigades, now determine if we want to
          * buffer the brigade or send the brigade out on the network
          */
-        if ((!fd && (!more) && (nbytes < AP_MIN_BYTES_TO_WRITE) && !AP_BUCKET_IS_FLUSH(e))
-            || (AP_BUCKET_IS_EOS(e) && c->keepalive)) {
+        if ((!fd && (!more) && (nbytes < AP_MIN_BYTES_TO_WRITE) && !APR_BUCKET_IS_FLUSH(e))
+            || (APR_BUCKET_IS_EOS(e) && c->keepalive)) {
             
             /* NEVER save an EOS in here.  If we are saving a brigade with an
              * EOS bucket, then we are doing keepalive connections, and we want
              * to process to second request fully.
              */
-            if (AP_BUCKET_IS_EOS(e)) {
-                AP_BUCKET_REMOVE(e);
-                ap_bucket_destroy(e);
+            if (APR_BUCKET_IS_EOS(e)) {
+                APR_BUCKET_REMOVE(e);
+                apr_bucket_destroy(e);
             }
             ap_save_brigade(f, &ctx->b, &b);
             return APR_SUCCESS;
@@ -3486,11 +3486,11 @@ static apr_status_t core_output_filter(ap_filter_t *f, ap_bucket_brigade *b)
                                nbytes, &bytes_sent);
         }
 
-        ap_brigade_destroy(b);
+        apr_brigade_destroy(b);
         if (rv != APR_SUCCESS) {
             /* XXX: log the error */
             if (more)
-                ap_brigade_destroy(more);
+                apr_brigade_destroy(more);
             return rv;
         }
         nvec = 0;
@@ -3504,7 +3504,7 @@ static apr_status_t core_output_filter(ap_filter_t *f, ap_bucket_brigade *b)
 
 static void core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
 {
-    ap_init_bucket_types(pconf);
+    apr_init_bucket_types(pconf);
 }
 
 static void core_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
@@ -3545,25 +3545,25 @@ static void core_insert_filter(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_pre_config(core_pre_config, NULL, NULL, AP_HOOK_REALLY_FIRST);
-    ap_hook_post_config(core_post_config,NULL,NULL,AP_HOOK_REALLY_FIRST);
-    ap_hook_translate_name(ap_core_translate,NULL,NULL,AP_HOOK_REALLY_LAST);
+    ap_hook_pre_config(core_pre_config, NULL, NULL, APR_HOOK_REALLY_FIRST);
+    ap_hook_post_config(core_post_config,NULL,NULL,APR_HOOK_REALLY_FIRST);
+    ap_hook_translate_name(ap_core_translate,NULL,NULL,APR_HOOK_REALLY_LAST);
     ap_hook_pre_connection(ap_pre_http_connection,NULL,NULL,
-			       AP_HOOK_REALLY_LAST);
+			       APR_HOOK_REALLY_LAST);
     ap_hook_process_connection(ap_process_http_connection,NULL,NULL,
-			       AP_HOOK_REALLY_LAST);
-    ap_hook_http_method(core_method,NULL,NULL,AP_HOOK_REALLY_LAST);
-    ap_hook_default_port(core_port,NULL,NULL,AP_HOOK_REALLY_LAST);
-    ap_hook_open_logs(core_open_logs,NULL,NULL,AP_HOOK_MIDDLE);
-    ap_hook_handler(default_handler,NULL,NULL,AP_HOOK_REALLY_LAST);
+			       APR_HOOK_REALLY_LAST);
+    ap_hook_http_method(core_method,NULL,NULL,APR_HOOK_REALLY_LAST);
+    ap_hook_default_port(core_port,NULL,NULL,APR_HOOK_REALLY_LAST);
+    ap_hook_open_logs(core_open_logs,NULL,NULL,APR_HOOK_MIDDLE);
+    ap_hook_handler(default_handler,NULL,NULL,APR_HOOK_REALLY_LAST);
     /* FIXME: I suspect we can eliminate the need for these - Ben */
-    ap_hook_type_checker(do_nothing,NULL,NULL,AP_HOOK_REALLY_LAST);
-    ap_hook_access_checker(do_nothing,NULL,NULL,AP_HOOK_REALLY_LAST);
+    ap_hook_type_checker(do_nothing,NULL,NULL,APR_HOOK_REALLY_LAST);
+    ap_hook_access_checker(do_nothing,NULL,NULL,APR_HOOK_REALLY_LAST);
 
     /* register the core's insert_filter hook and register core-provided
      * filters
      */
-    ap_hook_insert_filter(core_insert_filter, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_insert_filter(core_insert_filter, NULL, NULL, APR_HOOK_MIDDLE);
 
     ap_register_input_filter("HTTP_IN", ap_http_filter, AP_FTYPE_CONNECTION);
     ap_register_input_filter("DECHUNK", ap_dechunk_filter, AP_FTYPE_TRANSCODE);
diff --git a/modules/http/http_protocol.c b/modules/http/http_protocol.c
index 138b103..09c1c2f 100644
--- a/modules/http/http_protocol.c
+++ b/modules/http/http_protocol.c
@@ -74,7 +74,7 @@
 #endif
 
 #define CORE_PRIVATE
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 #include "util_filter.h"
 #include "ap_config.h"
 #include "httpd.h"
@@ -98,11 +98,11 @@
 #include <strings.h>
 #endif
 
-AP_HOOK_STRUCT(
-	    AP_HOOK_LINK(post_read_request)
-	    AP_HOOK_LINK(log_transaction)
-	    AP_HOOK_LINK(http_method)
-	    AP_HOOK_LINK(default_port)
+APR_HOOK_STRUCT(
+	    APR_HOOK_LINK(post_read_request)
+	    APR_HOOK_LINK(log_transaction)
+	    APR_HOOK_LINK(http_method)
+	    APR_HOOK_LINK(default_port)
 )
 
 /*
@@ -189,7 +189,7 @@ static int parse_byterange(char *range, apr_off_t clength,
 static int ap_set_byterange(request_rec *r);
 
 typedef struct byterange_ctx {
-    ap_bucket_brigade *bb;
+    apr_bucket_brigade *bb;
     int num_ranges;
 } byterange_ctx;
 
@@ -212,13 +212,13 @@ static int use_range_x(request_rec *r)
 
 AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
     ap_filter_t *f,
-    ap_bucket_brigade *bb)
+    apr_bucket_brigade *bb)
 {
 #define MIN_LENGTH(len1, len2) ((len1 > len2) ? len2 : len1)
     request_rec *r = f->r;
     byterange_ctx *ctx = f->ctx;
-    ap_bucket *e;
-    ap_bucket_brigade *bsend;
+    apr_bucket *e;
+    apr_bucket_brigade *bsend;
     apr_off_t range_start;
     apr_off_t range_end;
     char *current;
@@ -249,14 +249,14 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
         }
 
         /* create a brigade in case we never call ap_save_brigade() */
-        ctx->bb = ap_brigade_create(r->pool);
+        ctx->bb = apr_brigade_create(r->pool);
     }
 
     /* We can't actually deal with byte-ranges until we have the whole brigade
      * because the byte-ranges can be in any order, and according to the RFC,
      * we SHOULD return the data in the same order it was requested. 
      */
-    if (!AP_BUCKET_IS_EOS(AP_BRIGADE_LAST(bb))) {
+    if (!APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
         ap_save_brigade(f, &ctx->bb, &bb);
         return APR_SUCCESS;
     }
@@ -271,14 +271,14 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
     ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));
 
     /* concat the passed brigade with our saved brigade */
-    AP_BRIGADE_CONCAT(ctx->bb, bb);
+    APR_BRIGADE_CONCAT(ctx->bb, bb);
     bb = ctx->bb;
     ctx->bb = NULL;     /* ### strictly necessary? call brigade_destroy? */
 
     /* It is possible that we won't have a content length yet, so we have to
      * compute the length before we can actually do the byterange work.
      */
-    AP_BRIGADE_FOREACH(e, bb) {
+    APR_BRIGADE_FOREACH(e, bb) {
         const char *ignore;
         apr_size_t len;
 
@@ -286,12 +286,12 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
             clength += e->length;
             continue;
         }
-        ap_bucket_read(e, &ignore, &len, AP_NONBLOCK_READ);
+        apr_bucket_read(e, &ignore, &len, APR_NONBLOCK_READ);
         clength += e->length;
     }
 
     /* this brigade holds what we will be sending */
-    bsend = ap_brigade_create(r->pool);
+    bsend = apr_brigade_create(r->pool);
 
     while ((current = ap_getword(r->pool, &r->range, ',')) &&
            (rv = parse_byterange(current, clength, &range_start, &range_end))) {
@@ -314,7 +314,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
         /* ### this is so bogus, but not dealing with it right now */
         range = loc = apr_pcalloc(r->pool, range_length + 1);
 
-        e = AP_BRIGADE_FIRST(bb);
+        e = APR_BRIGADE_FIRST(bb);
 
         /* ### we should split() buckets rather than read() them. this
            ### will allow us to avoid reading files or custom buckets
@@ -329,19 +329,19 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
            ### occurs, using the split() as an internal "seek".
         */
 
-        ap_bucket_read(e, &str, &n, AP_NONBLOCK_READ);
+        apr_bucket_read(e, &str, &n, APR_NONBLOCK_READ);
         /* using e->length doesn't account for pipes once we change the read
          * to a split.*/
         while (range_start > (curr_offset + e->length)) {
             curr_offset += e->length;
-            e = AP_BUCKET_NEXT(e);
+            e = APR_BUCKET_NEXT(e);
 
-            if (e == AP_BRIGADE_SENTINEL(bb)) {
+            if (e == APR_BRIGADE_SENTINEL(bb)) {
                 break;
             }
 
             /* eventually we can avoid this */
-            ap_bucket_read(e, &str, &n, AP_NONBLOCK_READ);
+            apr_bucket_read(e, &str, &n, APR_NONBLOCK_READ);
         }
         if (range_start != curr_offset) {
             /* If we get here, then we know that the beginning of this 
@@ -352,14 +352,14 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
             memcpy(loc, str + (range_start - curr_offset), segment_length);
             loc += segment_length;
             curr_length -= segment_length;
-            e = AP_BUCKET_NEXT(e);
+            e = APR_BUCKET_NEXT(e);
         }
 
-        while (e != AP_BRIGADE_SENTINEL(bb)) {
+        while (e != APR_BRIGADE_SENTINEL(bb)) {
             if (curr_length == 0) {
                 break;
             }
-            ap_bucket_read(e, &str, &n, AP_NONBLOCK_READ);
+            apr_bucket_read(e, &str, &n, APR_NONBLOCK_READ);
 
             /* ### we should use 'n', not e->length */
             segment_length = MIN_LENGTH(curr_length + 1, e->length);
@@ -367,25 +367,25 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
             memcpy(loc, str, segment_length);
             loc += segment_length;
             curr_length -= segment_length;
-            e = AP_BUCKET_NEXT(e);
+            e = APR_BUCKET_NEXT(e);
         }
 
         if (ctx->num_ranges > 1) {
             char *ts;
 
-            e = ap_bucket_create_pool(bound_head,
+            e = apr_bucket_create_pool(bound_head,
                                       strlen(bound_head), r->pool);
-            AP_BRIGADE_INSERT_TAIL(bsend, e);
+            APR_BRIGADE_INSERT_TAIL(bsend, e);
 
             ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,
                               range_start, range_end, clength);
             ap_xlate_proto_to_ascii(ts, strlen(ts));
-            e = ap_bucket_create_pool(ts, strlen(ts), r->pool);
-            AP_BRIGADE_INSERT_TAIL(bsend, e);
+            e = apr_bucket_create_pool(ts, strlen(ts), r->pool);
+            APR_BRIGADE_INSERT_TAIL(bsend, e);
         }
         
-        e = ap_bucket_create_pool(range, range_length, r->pool);
-        AP_BRIGADE_INSERT_TAIL(bsend, e);
+        e = apr_bucket_create_pool(range, range_length, r->pool);
+        APR_BRIGADE_INSERT_TAIL(bsend, e);
     }
 
     if (found == 0) {
@@ -400,15 +400,15 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
         /* add the final boundary */
         end = apr_pstrcat(r->pool, CRLF "--", r->boundary, "--" CRLF, NULL);
         ap_xlate_proto_to_ascii(end, strlen(end));
-        e = ap_bucket_create_pool(end, strlen(end), r->pool);
-        AP_BRIGADE_INSERT_TAIL(bsend, e);
+        e = apr_bucket_create_pool(end, strlen(end), r->pool);
+        APR_BRIGADE_INSERT_TAIL(bsend, e);
     }
 
-    e = ap_bucket_create_eos();
-    AP_BRIGADE_INSERT_TAIL(bsend, e);
+    e = apr_bucket_create_eos();
+    APR_BRIGADE_INSERT_TAIL(bsend, e);
 
     /* we're done with the original content */
-    ap_brigade_destroy(bb);
+    apr_brigade_destroy(bb);
 
     /* send our multipart output */
     return ap_pass_brigade(f->next, bsend); 
@@ -864,12 +864,12 @@ struct dechunk_ctx {
 
 static long get_chunk_size(char *);
 
-apr_status_t ap_dechunk_filter(ap_filter_t *f, ap_bucket_brigade *bb,
+apr_status_t ap_dechunk_filter(ap_filter_t *f, apr_bucket_brigade *bb,
                                ap_input_mode_t mode)
 {
     apr_status_t rv;
     struct dechunk_ctx *ctx = f->ctx;
-    ap_bucket *b;
+    apr_bucket *b;
     const char *buf;
     apr_size_t len;
 
@@ -906,8 +906,8 @@ apr_status_t ap_dechunk_filter(ap_filter_t *f, ap_bucket_brigade *bb,
                 }
                 if (ctx->chunk_size == 0) { /* we just finished the last chunk? */
                     /* append eos bucket and get out */
-                    b = ap_bucket_create_eos();
-                    AP_BRIGADE_INSERT_TAIL(bb, b);
+                    b = apr_bucket_create_eos();
+                    APR_BRIGADE_INSERT_TAIL(bb, b);
                     return APR_SUCCESS;
                 }
                 ctx->state = WANT_HDR;
@@ -927,17 +927,17 @@ apr_status_t ap_dechunk_filter(ap_filter_t *f, ap_bucket_brigade *bb,
         /* Walk through the body, accounting for bytes, and removing an eos bucket if
          * ap_http_filter() delivered the entire chunk.
          */
-        b = AP_BRIGADE_FIRST(bb);
-        while (b != AP_BRIGADE_SENTINEL(bb) && !AP_BUCKET_IS_EOS(b)) {
-            ap_bucket_read(b, &buf, &len, mode);
+        b = APR_BRIGADE_FIRST(bb);
+        while (b != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(b)) {
+            apr_bucket_read(b, &buf, &len, mode);
             AP_DEBUG_ASSERT(len <= ctx->chunk_size - ctx->bytes_delivered);
             ctx->bytes_delivered += len;
-            b = AP_BUCKET_NEXT(b);
+            b = APR_BUCKET_NEXT(b);
         }
         if (ctx->bytes_delivered == ctx->chunk_size) {
-            AP_DEBUG_ASSERT(AP_BUCKET_IS_EOS(b));
-            AP_BUCKET_REMOVE(b);
-            ap_bucket_destroy(b);
+            AP_DEBUG_ASSERT(APR_BUCKET_IS_EOS(b));
+            APR_BUCKET_REMOVE(b);
+            apr_bucket_destroy(b);
             ctx->state = WANT_TRL;
         }
     }
@@ -946,16 +946,16 @@ apr_status_t ap_dechunk_filter(ap_filter_t *f, ap_bucket_brigade *bb,
 }
 
 typedef struct http_filter_ctx {
-    ap_bucket_brigade *b;
+    apr_bucket_brigade *b;
 } http_ctx_t;
 
-apr_status_t ap_http_filter(ap_filter_t *f, ap_bucket_brigade *b, ap_input_mode_t mode)
+apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b, ap_input_mode_t mode)
 {
 #define ASCII_BLANK  '\040'
 #define ASCII_CR     '\015'
 #define ASCII_LF     '\012'
 #define ASCII_TAB    '\011' 
-    ap_bucket *e;
+    apr_bucket *e;
     char *buff;
     apr_size_t len;
     char *pos;
@@ -964,11 +964,11 @@ apr_status_t ap_http_filter(ap_filter_t *f, ap_bucket_brigade *b, ap_input_mode_
 
     if (!ctx) {
         f->ctx = ctx = apr_pcalloc(f->c->pool, sizeof(*ctx));
-        ctx->b = ap_brigade_create(f->c->pool);
+        ctx->b = apr_brigade_create(f->c->pool);
     }
 
     if (mode == AP_MODE_PEEK) {
-        ap_bucket *e;
+        apr_bucket *e;
         const char *str;
         apr_size_t length;
 
@@ -982,13 +982,13 @@ apr_status_t ap_http_filter(ap_filter_t *f, ap_bucket_brigade *b, ap_input_mode_
          * mean that there is another request, just a blank line.
          */
         while (1) {
-            if (AP_BRIGADE_EMPTY(ctx->b)) {
+            if (APR_BRIGADE_EMPTY(ctx->b)) {
                 e = NULL;
             }
             else {
-                e = AP_BRIGADE_FIRST(ctx->b);
+                e = APR_BRIGADE_FIRST(ctx->b);
             }
-            if (!e || ap_bucket_read(e, &str, &length, AP_NONBLOCK_READ) != APR_SUCCESS) {
+            if (!e || apr_bucket_read(e, &str, &length, APR_NONBLOCK_READ) != APR_SUCCESS) {
                 return APR_EOF;
             }
             else {
@@ -1000,73 +1000,73 @@ apr_status_t ap_http_filter(ap_filter_t *f, ap_bucket_brigade *b, ap_input_mode_
                         c += 2;
                     else return APR_SUCCESS;
                 }
-                AP_BUCKET_REMOVE(e);
-                ap_bucket_destroy(e);
+                APR_BUCKET_REMOVE(e);
+                apr_bucket_destroy(e);
             }
         }
     }
 
-    if (AP_BRIGADE_EMPTY(ctx->b)) {
+    if (APR_BRIGADE_EMPTY(ctx->b)) {
         if ((rv = ap_get_brigade(f->next, ctx->b, mode)) != APR_SUCCESS) {
             return rv;
         }
     }
 
     if (f->c->remain) {
-        e = AP_BRIGADE_FIRST(ctx->b);
-        while (e != AP_BRIGADE_SENTINEL(ctx->b)) {
-            ap_bucket *old;
+        e = APR_BRIGADE_FIRST(ctx->b);
+        while (e != APR_BRIGADE_SENTINEL(ctx->b)) {
+            apr_bucket *old;
             const char *ignore;
 
-            if ((rv = ap_bucket_read(e, &ignore, &len, mode)) != APR_SUCCESS) {
+            if ((rv = apr_bucket_read(e, &ignore, &len, mode)) != APR_SUCCESS) {
                 /* probably APR_IS_EAGAIN(rv); socket state isn't correct;
                  * remove log once we get this squared away */
                 ap_log_error(APLOG_MARK, APLOG_ERR, rv, f->c->base_server, 
-                             "ap_bucket_read");
+                             "apr_bucket_read");
                 return rv;
             }
 
             if (len) {
                 if (f->c->remain < len) {
-                    ap_bucket_split(e, f->c->remain);
+                    apr_bucket_split(e, f->c->remain);
                     f->c->remain = 0;
                 }
                 else {
                     f->c->remain -= len;
                 }
-                AP_BUCKET_REMOVE(e);
-                AP_BRIGADE_INSERT_TAIL(b, e);
+                APR_BUCKET_REMOVE(e);
+                APR_BRIGADE_INSERT_TAIL(b, e);
                 break; /* once we've gotten some data, deliver it to caller */
             }
 
             old = e;
-            e = AP_BUCKET_NEXT(e);
-            AP_BUCKET_REMOVE(old);
-            ap_bucket_destroy(old);
+            e = APR_BUCKET_NEXT(e);
+            APR_BUCKET_REMOVE(old);
+            apr_bucket_destroy(old);
         }
         if (f->c->remain == 0) {
-            ap_bucket *eos = ap_bucket_create_eos();
+            apr_bucket *eos = apr_bucket_create_eos();
                 
-            AP_BRIGADE_INSERT_TAIL(b, eos);
+            APR_BRIGADE_INSERT_TAIL(b, eos);
         }
         return APR_SUCCESS;
     }
 
-    while (!AP_BRIGADE_EMPTY(ctx->b)) {
-        e = AP_BRIGADE_FIRST(ctx->b);
-        if ((rv = ap_bucket_read(e, (const char **)&buff, &len, mode)) != APR_SUCCESS) {
+    while (!APR_BRIGADE_EMPTY(ctx->b)) {
+        e = APR_BRIGADE_FIRST(ctx->b);
+        if ((rv = apr_bucket_read(e, (const char **)&buff, &len, mode)) != APR_SUCCESS) {
             return rv;
         }
 
         pos = memchr(buff, ASCII_LF, len);
         if (pos != NULL) {
-            ap_bucket_split(e, pos - buff + 1);
-            AP_BUCKET_REMOVE(e);
-            AP_BRIGADE_INSERT_TAIL(b, e);
+            apr_bucket_split(e, pos - buff + 1);
+            APR_BUCKET_REMOVE(e);
+            APR_BRIGADE_INSERT_TAIL(b, e);
             return APR_SUCCESS;
         }
-        AP_BUCKET_REMOVE(e);
-        AP_BRIGADE_INSERT_TAIL(b, e);
+        APR_BUCKET_REMOVE(e);
+        APR_BRIGADE_INSERT_TAIL(b, e);
     }
     return APR_SUCCESS;
 }
@@ -1095,29 +1095,29 @@ AP_CORE_DECLARE(int) ap_getline(char *s, int n, request_rec *r, int fold)
     apr_size_t length;
     conn_rec *c = r->connection;
     core_request_config *req_cfg;
-    ap_bucket_brigade *b;
-    ap_bucket *e;
+    apr_bucket_brigade *b;
+    apr_bucket *e;
 
     req_cfg = (core_request_config *)
                 ap_get_module_config(r->request_config, &core_module);
     b = req_cfg->bb;
     /* make sure it's empty unless we're folding */ 
-    AP_DEBUG_ASSERT(fold || AP_BRIGADE_EMPTY(b));
+    AP_DEBUG_ASSERT(fold || APR_BRIGADE_EMPTY(b));
 
     while (1) {
-        if (AP_BRIGADE_EMPTY(b)) {
+        if (APR_BRIGADE_EMPTY(b)) {
             if (ap_get_brigade(c->input_filters, b, AP_MODE_BLOCKING) != APR_SUCCESS ||
-                AP_BRIGADE_EMPTY(b)) {
+                APR_BRIGADE_EMPTY(b)) {
                 return -1;
             }
         }
-        e = AP_BRIGADE_FIRST(b); 
+        e = APR_BRIGADE_FIRST(b); 
         if (e->length == 0) {
-            AP_BUCKET_REMOVE(e);
-            ap_bucket_destroy(e);
+            APR_BUCKET_REMOVE(e);
+            apr_bucket_destroy(e);
             continue;
         }
-        retval = ap_bucket_read(e, &temp, &length, AP_BLOCK_READ);
+        retval = apr_bucket_read(e, &temp, &length, APR_BLOCK_READ);
 
         if (retval != APR_SUCCESS) {
             total = ((length < 0) && (total == 0)) ? -1 : total;
@@ -1129,18 +1129,18 @@ AP_CORE_DECLARE(int) ap_getline(char *s, int n, request_rec *r, int fold)
              * so return what we have.  lookahead brigade is 
              * stashed on req_cfg->bb
              */
-            AP_DEBUG_ASSERT(!AP_BRIGADE_EMPTY(req_cfg->bb));
+            AP_DEBUG_ASSERT(!APR_BRIGADE_EMPTY(req_cfg->bb));
             break;
         }
         last_char = pos + length - 1;
         if (last_char < beyond_buff) {
             memcpy(pos, temp, length);
-            AP_BUCKET_REMOVE(e);
-            ap_bucket_destroy(e);
+            APR_BUCKET_REMOVE(e);
+            apr_bucket_destroy(e);
         }
         else {
             /* input line was larger than the caller's buffer */
-            ap_brigade_destroy(b); 
+            apr_brigade_destroy(b); 
             
             /* don't need to worry about req_cfg->bb being bogus.
              * the request is about to die, and ErrorDocument
@@ -1178,7 +1178,7 @@ AP_CORE_DECLARE(int) ap_getline(char *s, int n, request_rec *r, int fold)
                 looking_ahead = 1;
             }
             else {
-                AP_DEBUG_ASSERT(AP_BRIGADE_EMPTY(req_cfg->bb));
+                AP_DEBUG_ASSERT(APR_BRIGADE_EMPTY(req_cfg->bb));
                 break;
             }
         }
@@ -1453,7 +1453,7 @@ request_rec *ap_read_request(conn_rec *conn)
 
     r->request_config  = ap_create_request_config(r->pool);
     req_cfg = apr_pcalloc(r->pool, sizeof(core_request_config));
-    req_cfg->bb = ap_brigade_create(r->pool);
+    req_cfg->bb = apr_brigade_create(r->pool);
     ap_set_module_config(r->request_config, &core_module, req_cfg);
                     
     r->per_dir_config  = r->server->lookup_defaults;
@@ -1619,12 +1619,12 @@ void ap_set_sub_req_protocol(request_rec *rnew, const request_rec *r)
 
 static void end_output_stream(request_rec *r)
 {
-    ap_bucket_brigade *bb;
-    ap_bucket *b;
+    apr_bucket_brigade *bb;
+    apr_bucket *b;
 
-    bb = ap_brigade_create(r->pool);
-    b = ap_bucket_create_eos();
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(r->pool);
+    b = apr_bucket_create_eos();
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 }
 
@@ -2173,8 +2173,8 @@ AP_DECLARE(int) ap_send_http_trace(request_rec *r)
 int ap_send_http_options(request_rec *r)
 {
     char *buff;
-    ap_bucket *b;
-    ap_bucket_brigade *bb;
+    apr_bucket *b;
+    apr_bucket_brigade *bb;
     apr_size_t len = 0;
     header_struct h;
 
@@ -2205,9 +2205,9 @@ int ap_send_http_options(request_rec *r)
 
     r->bytes_sent = 0;
 
-    bb = ap_brigade_create(r->pool);
-    b = ap_bucket_create_pool(buff, strlen(buff), r->pool);
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(r->pool);
+    b = apr_bucket_create_pool(buff, strlen(buff), r->pool);
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 
     return OK;
@@ -2296,7 +2296,7 @@ AP_DECLARE(void) ap_send_http_header(request_rec *r)
 }
 
 struct content_length_ctx {
-    ap_bucket_brigade *saved;
+    apr_bucket_brigade *saved;
     int compute_len;
     apr_size_t curr_len;
 };
@@ -2306,12 +2306,12 @@ struct content_length_ctx {
  * through all of the buckets in all brigades 
  */
 AP_CORE_DECLARE_NONSTD(apr_status_t) ap_content_length_filter(ap_filter_t *f,
-                                                              ap_bucket_brigade *b)
+                                                              apr_bucket_brigade *b)
 {
     request_rec *r = f->r;
     struct content_length_ctx *ctx;
     apr_status_t rv;
-    ap_bucket *e;
+    apr_bucket *e;
     int send_it = 0;
 
     ctx = f->ctx;
@@ -2319,15 +2319,15 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_content_length_filter(ap_filter_t *f,
         f->ctx = ctx = apr_pcalloc(r->pool, sizeof(struct content_length_ctx));
     }
 
-    AP_BRIGADE_FOREACH(e, b) {
+    APR_BRIGADE_FOREACH(e, b) {
         const char *ignored;
         apr_size_t length;
 
-        if (AP_BUCKET_IS_EOS(e) || AP_BUCKET_IS_FLUSH(e)) {
+        if (APR_BUCKET_IS_EOS(e) || APR_BUCKET_IS_FLUSH(e)) {
             send_it = 1;
         }
         if (e->length == -1) { /* if length unknown */
-            rv = ap_bucket_read(e, &ignored, &length, AP_BLOCK_READ);
+            rv = apr_bucket_read(e, &ignored, &length, APR_BLOCK_READ);
             if (rv != APR_SUCCESS) {
                 return rv;
             }
@@ -2358,7 +2358,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_content_length_filter(ap_filter_t *f,
                                              "Transfer-Encoding"),
                                "chunked"))
         || (f->r->connection->keepalive)
-        || (AP_BUCKET_IS_EOS(AP_BRIGADE_LAST(b)))) {
+        || (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(b)))) {
         ctx->compute_len = 1;
     }
     else {
@@ -2376,8 +2376,8 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_content_length_filter(ap_filter_t *f,
         ap_set_content_length(r, r->bytes_sent);
     }
     if (ctx->saved) {
-        AP_BRIGADE_CONCAT(ctx->saved, b);
-        ap_brigade_destroy(b);
+        APR_BRIGADE_CONCAT(ctx->saved, b);
+        apr_brigade_destroy(b);
         b = ctx->saved;
         ctx->saved = NULL;
     }
@@ -2475,14 +2475,14 @@ static int ap_set_byterange(request_rec *r)
 typedef struct header_filter_cts {
     int headers_sent;
 } header_filter_ctx;
-AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f, ap_bucket_brigade *b)
+AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f, apr_bucket_brigade *b)
 {
     int i;
     char *date = NULL;
     request_rec *r = f->r;
     char *buff, *buff_start;
-    ap_bucket *e;
-    ap_bucket_brigade *b2;
+    apr_bucket *e;
+    apr_bucket_brigade *b2;
     apr_size_t len = 0;
     header_struct h;
     header_filter_ctx *ctx = f->ctx;
@@ -2494,7 +2494,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f, ap_bu
     }
 
     if (ctx->headers_sent) {
-        ap_brigade_destroy(b);
+        apr_brigade_destroy(b);
         return AP_REQUEST_DONE;
     }
 
@@ -2637,13 +2637,13 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f, ap_bu
 
     r->sent_bodyct = 1;         /* Whatever follows is real body stuff... */
 
-    b2 = ap_brigade_create(r->pool);
-    e = ap_bucket_create_pool(buff_start, strlen(buff_start), r->pool);
-    AP_BRIGADE_INSERT_HEAD(b2, e);
+    b2 = apr_brigade_create(r->pool);
+    e = apr_bucket_create_pool(buff_start, strlen(buff_start), r->pool);
+    APR_BRIGADE_INSERT_HEAD(b2, e);
     ap_pass_brigade(f->next, b2);
 
     if (r->header_only) {
-        ap_brigade_destroy(b);
+        apr_brigade_destroy(b);
         return AP_REQUEST_DONE;
     }
 
@@ -2783,7 +2783,7 @@ AP_DECLARE(int) ap_setup_client_block(request_rec *r, int read_policy)
         core_request_config *req_cfg = 
             (core_request_config *)ap_get_module_config(r->request_config,
                                                         &core_module);
-        AP_DEBUG_ASSERT(AP_BRIGADE_EMPTY(req_cfg->bb));
+        AP_DEBUG_ASSERT(APR_BRIGADE_EMPTY(req_cfg->bb));
     }
 #endif
 
@@ -2799,17 +2799,17 @@ AP_DECLARE(int) ap_should_client_block(request_rec *r)
 
     if (r->expecting_100 && r->proto_num >= HTTP_VERSION(1,1)) {
         char *tmp;
-        ap_bucket *e;
-        ap_bucket_brigade *bb;
+        apr_bucket *e;
+        apr_bucket_brigade *bb;
 
         /* sending 100 Continue interim response */
         tmp = apr_pstrcat(r->pool, AP_SERVER_PROTOCOL, " ", status_lines[0],
                                 CRLF CRLF, NULL);
-        bb = ap_brigade_create(r->pool);
-        e = ap_bucket_create_pool(tmp, strlen(tmp), r->pool);
-        AP_BRIGADE_INSERT_HEAD(bb, e);
-        e = ap_bucket_create_flush();
-        AP_BRIGADE_INSERT_TAIL(bb, e);
+        bb = apr_brigade_create(r->pool);
+        e = apr_bucket_create_pool(tmp, strlen(tmp), r->pool);
+        APR_BRIGADE_INSERT_HEAD(bb, e);
+        e = apr_bucket_create_flush();
+        APR_BRIGADE_INSERT_TAIL(bb, e);
 
         ap_pass_brigade(r->connection->output_filters, bb);
     }
@@ -2858,40 +2858,40 @@ AP_DECLARE(long) ap_get_client_block(request_rec *r, char *buffer, int bufsiz)
 {
     apr_size_t len_read, total;
     apr_status_t rv;
-    ap_bucket *b, *old;
+    apr_bucket *b, *old;
     const char *tempbuf;
     core_request_config *req_cfg =
 	(core_request_config *)ap_get_module_config(r->request_config,
                                                     &core_module);
-    ap_bucket_brigade *bb = req_cfg->bb;
+    apr_bucket_brigade *bb = req_cfg->bb;
 
     do {
-        if (AP_BRIGADE_EMPTY(bb)) {
+        if (APR_BRIGADE_EMPTY(bb)) {
             if (ap_get_brigade(r->input_filters, bb, AP_MODE_BLOCKING) != APR_SUCCESS) {
                 /* if we actually fail here, we want to just return and
                  * stop trying to read data from the client.
                  */
                 r->connection->keepalive = -1;
-                ap_brigade_destroy(bb);
+                apr_brigade_destroy(bb);
                 return -1;
             }
         }
-        b = AP_BRIGADE_FIRST(bb);
-    } while (AP_BRIGADE_EMPTY(bb));
+        b = APR_BRIGADE_FIRST(bb);
+    } while (APR_BRIGADE_EMPTY(bb));
 
-    if (AP_BUCKET_IS_EOS(b)) {         /* reached eos on previous invocation */
-        AP_BUCKET_REMOVE(b);
-        ap_bucket_destroy(b);
+    if (APR_BUCKET_IS_EOS(b)) {         /* reached eos on previous invocation */
+        APR_BUCKET_REMOVE(b);
+        apr_bucket_destroy(b);
         return 0;
     }
 
     total = 0;
-    while (total < bufsiz &&  b != AP_BRIGADE_SENTINEL(bb) && !AP_BUCKET_IS_EOS(b)) {
-        if ((rv = ap_bucket_read(b, &tempbuf, &len_read, AP_BLOCK_READ)) != APR_SUCCESS) {
+    while (total < bufsiz &&  b != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(b)) {
+        if ((rv = apr_bucket_read(b, &tempbuf, &len_read, APR_BLOCK_READ)) != APR_SUCCESS) {
             return -1;
         }
         if (total + len_read > bufsiz) {
-            ap_bucket_split(b, bufsiz - total);
+            apr_bucket_split(b, bufsiz - total);
             len_read = bufsiz - total;
         }
         memcpy(buffer, tempbuf, len_read);
@@ -2904,9 +2904,9 @@ AP_DECLARE(long) ap_get_client_block(request_rec *r, char *buffer, int bufsiz)
         r->read_length += len_read;      /* XXX yank me? */
         r->remaining -= len_read;        /* XXX yank me? */
         old = b;
-        b = AP_BUCKET_NEXT(b);
-        AP_BUCKET_REMOVE(old);
-        ap_bucket_destroy(old);
+        b = APR_BUCKET_NEXT(b);
+        APR_BUCKET_REMOVE(old);
+        apr_bucket_destroy(old);
     }
 
     return total;
@@ -2960,13 +2960,13 @@ AP_DECLARE(int) ap_discard_request_body(request_rec *r)
 AP_DECLARE(apr_status_t) ap_send_fd(apr_file_t *fd, request_rec *r, apr_off_t offset, 
                                     apr_size_t len, apr_size_t *nbytes) 
 {
-    ap_bucket_brigade *bb = NULL;
-    ap_bucket *b;
+    apr_bucket_brigade *bb = NULL;
+    apr_bucket *b;
     apr_status_t rv;
 
-    bb = ap_brigade_create(r->pool);
-    b = ap_bucket_create_file(fd, offset, len);
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(r->pool);
+    b = apr_bucket_create_file(fd, offset, len);
+    APR_BRIGADE_INSERT_TAIL(bb, b);
 
     rv = ap_pass_brigade(r->output_filters, bb);
     if (rv != APR_SUCCESS) {
@@ -2984,12 +2984,12 @@ AP_DECLARE(apr_status_t) ap_send_fd(apr_file_t *fd, request_rec *r, apr_off_t of
 AP_DECLARE(size_t) ap_send_mmap(apr_mmap_t *mm, request_rec *r, size_t offset,
                              size_t length)
 {
-    ap_bucket_brigade *bb = NULL;
-    ap_bucket *b;
+    apr_bucket_brigade *bb = NULL;
+    apr_bucket *b;
 
-    bb = ap_brigade_create(r->pool);
-    b = ap_bucket_create_mmap(mm, offset, length);
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(r->pool);
+    b = apr_bucket_create_mmap(mm, offset, length);
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 
     return mm->size; /* XXX - change API to report apr_status_t? */
@@ -2998,17 +2998,17 @@ AP_DECLARE(size_t) ap_send_mmap(apr_mmap_t *mm, request_rec *r, size_t offset,
 
 AP_DECLARE(int) ap_rputc(int c, request_rec *r)
 {
-    ap_bucket_brigade *bb = NULL;
-    ap_bucket *b;
+    apr_bucket_brigade *bb = NULL;
+    apr_bucket *b;
     char c2 = (char)c;
 
     if (r->connection->aborted) {
 	return EOF;
     }
 
-    bb = ap_brigade_create(r->pool);
-    b = ap_bucket_create_transient(&c2, 1);
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(r->pool);
+    b = apr_bucket_create_transient(&c2, 1);
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 
     return c;
@@ -3016,8 +3016,8 @@ AP_DECLARE(int) ap_rputc(int c, request_rec *r)
 
 AP_DECLARE(int) ap_rputs(const char *str, request_rec *r)
 {
-    ap_bucket_brigade *bb = NULL;
-    ap_bucket *b;
+    apr_bucket_brigade *bb = NULL;
+    apr_bucket *b;
     apr_size_t len;
 
     if (r->connection->aborted)
@@ -3026,9 +3026,9 @@ AP_DECLARE(int) ap_rputs(const char *str, request_rec *r)
         return 0;
 
     len = strlen(str);
-    bb = ap_brigade_create(r->pool);
-    b = ap_bucket_create_transient(str, len);
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(r->pool);
+    b = apr_bucket_create_transient(str, len);
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 
     return len;
@@ -3036,31 +3036,31 @@ AP_DECLARE(int) ap_rputs(const char *str, request_rec *r)
 
 AP_DECLARE(int) ap_rwrite(const void *buf, int nbyte, request_rec *r)
 {
-    ap_bucket_brigade *bb = NULL;
-    ap_bucket *b;
+    apr_bucket_brigade *bb = NULL;
+    apr_bucket *b;
 
     if (r->connection->aborted)
         return EOF;
     if (nbyte == 0)
         return 0;
 
-    bb = ap_brigade_create(r->pool);
-    b = ap_bucket_create_transient(buf, nbyte);
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(r->pool);
+    b = apr_bucket_create_transient(buf, nbyte);
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
     return nbyte;
 }
 
 AP_DECLARE(int) ap_vrprintf(request_rec *r, const char *fmt, va_list va)
 {
-    ap_bucket_brigade *bb = NULL;
+    apr_bucket_brigade *bb = NULL;
     apr_size_t written;
 
     if (r->connection->aborted)
         return EOF;
 
-    bb = ap_brigade_create(r->pool);
-    written = ap_brigade_vprintf(bb, fmt, va);
+    bb = apr_brigade_create(r->pool);
+    written = apr_brigade_vprintf(bb, fmt, va);
     if (written != 0)
         ap_pass_brigade(r->output_filters, bb);
     return written;
@@ -3086,15 +3086,15 @@ AP_DECLARE_NONSTD(int) ap_rprintf(request_rec *r, const char *fmt, ...)
 
 AP_DECLARE_NONSTD(int) ap_rvputs(request_rec *r, ...)
 {
-    ap_bucket_brigade *bb = NULL;
+    apr_bucket_brigade *bb = NULL;
     apr_size_t written;
     va_list va;
 
     if (r->connection->aborted)
         return EOF;
-    bb = ap_brigade_create(r->pool);
+    bb = apr_brigade_create(r->pool);
     va_start(va, r);
-    written = ap_brigade_vputstrs(bb, va);
+    written = apr_brigade_vputstrs(bb, va);
     va_end(va);
     if (written != 0)
         ap_pass_brigade(r->output_filters, bb);
@@ -3104,12 +3104,12 @@ AP_DECLARE_NONSTD(int) ap_rvputs(request_rec *r, ...)
 AP_DECLARE(int) ap_rflush(request_rec *r)
 {
     /* we should be using a flush bucket to flush the stack, not buff code. */
-    ap_bucket_brigade *bb;
-    ap_bucket *b;
+    apr_bucket_brigade *bb;
+    apr_bucket *b;
 
-    bb = ap_brigade_create(r->pool);
-    b = ap_bucket_create_flush();
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(r->pool);
+    b = apr_bucket_create_flush();
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
     return 0;
 }
diff --git a/modules/http/http_request.c b/modules/http/http_request.c
index 3da29e4..25980de 100644
--- a/modules/http/http_request.c
+++ b/modules/http/http_request.c
@@ -84,14 +84,14 @@
 #include <stdarg.h>
 #endif
 
-AP_HOOK_STRUCT(
-	    AP_HOOK_LINK(translate_name)
-	    AP_HOOK_LINK(check_user_id)
-	    AP_HOOK_LINK(fixups)
-	    AP_HOOK_LINK(type_checker)
-	    AP_HOOK_LINK(access_checker)
-	    AP_HOOK_LINK(auth_checker)
-	    AP_HOOK_LINK(insert_filter)
+APR_HOOK_STRUCT(
+	    APR_HOOK_LINK(translate_name)
+	    APR_HOOK_LINK(check_user_id)
+	    APR_HOOK_LINK(fixups)
+	    APR_HOOK_LINK(type_checker)
+	    APR_HOOK_LINK(access_checker)
+	    APR_HOOK_LINK(auth_checker)
+	    APR_HOOK_LINK(insert_filter)
 )
 
 AP_IMPLEMENT_HOOK_RUN_FIRST(int,translate_name,
@@ -792,13 +792,13 @@ static request_rec *make_sub_request(const request_rec *r)
 }
 
 AP_CORE_DECLARE_NONSTD(apr_status_t) ap_sub_req_output_filter(ap_filter_t *f,
-                                                        ap_bucket_brigade *bb)
+                                                        apr_bucket_brigade *bb)
 {
-    ap_bucket *e = AP_BRIGADE_LAST(bb);
+    apr_bucket *e = APR_BRIGADE_LAST(bb);
 
-    if (AP_BUCKET_IS_EOS(e)) {
-        AP_BUCKET_REMOVE(e);
-        ap_bucket_destroy(e);
+    if (APR_BUCKET_IS_EOS(e)) {
+        APR_BUCKET_REMOVE(e);
+        apr_bucket_destroy(e);
     }
     ap_pass_brigade(f->next, bb);
     return APR_SUCCESS;
@@ -1356,16 +1356,16 @@ static void process_request_internal(request_rec *r)
 
 static void check_pipeline_flush(request_rec *r)
 {
-    ap_bucket_brigade *bb = ap_brigade_create(r->pool);
+    apr_bucket_brigade *bb = apr_brigade_create(r->pool);
     if (ap_get_brigade(r->input_filters, bb, AP_MODE_PEEK) != APR_SUCCESS) {
-        ap_bucket *e = ap_bucket_create_flush();
+        apr_bucket *e = apr_bucket_create_flush();
 
         /* We just send directly to the connection based filters, because at
          * this point, we know that we have seen all of the data, so we just
          * want to flush the buckets if something hasn't been sent to the
          * network yet.
          */
-        AP_BRIGADE_INSERT_HEAD(bb, e);
+        APR_BRIGADE_INSERT_HEAD(bb, e);
         ap_pass_brigade(r->connection->output_filters, bb);
     }
 }
@@ -1426,7 +1426,7 @@ static request_rec *internal_internal_redirect(const char *new_uri,
 
     new->request_config = ap_create_request_config(r->pool);
     req_cfg = apr_pcalloc(r->pool, sizeof(core_request_config));
-    req_cfg->bb = ap_brigade_create(r->pool);
+    req_cfg->bb = apr_brigade_create(r->pool);
     ap_set_module_config(new->request_config, &core_module, req_cfg);
 
     new->per_dir_config = r->server->lookup_defaults;
diff --git a/modules/http/mod_mime.c b/modules/http/mod_mime.c
index bca6ae6..2a3a8af 100644
--- a/modules/http/mod_mime.c
+++ b/modules/http/mod_mime.c
@@ -842,9 +842,9 @@ static void mime_insert_filter(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_type_checker(find_ct,NULL,NULL,AP_HOOK_MIDDLE);
-    ap_hook_post_config(mime_post_config,NULL,NULL,AP_HOOK_MIDDLE);
-    ap_hook_insert_filter(mime_insert_filter, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_type_checker(find_ct,NULL,NULL,APR_HOOK_MIDDLE);
+    ap_hook_post_config(mime_post_config,NULL,NULL,APR_HOOK_MIDDLE);
+    ap_hook_insert_filter(mime_insert_filter, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA mime_module = {
diff --git a/modules/loggers/mod_log_config.c b/modules/loggers/mod_log_config.c
index 2c37090..e3bdee4 100644
--- a/modules/loggers/mod_log_config.c
+++ b/modules/loggers/mod_log_config.c
@@ -1243,9 +1243,9 @@ static void init_child(apr_pool_t *p, server_rec *s)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_child_init(init_child,NULL,NULL,AP_HOOK_MIDDLE);
-    ap_hook_open_logs(init_config_log,NULL,NULL,AP_HOOK_MIDDLE);
-    ap_hook_log_transaction(multi_log_transaction,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_child_init(init_child,NULL,NULL,APR_HOOK_MIDDLE);
+    ap_hook_open_logs(init_config_log,NULL,NULL,APR_HOOK_MIDDLE);
+    ap_hook_log_transaction(multi_log_transaction,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA config_log_module =
diff --git a/modules/mappers/mod_actions.c b/modules/mappers/mod_actions.c
index 68ece9b..35e2e34 100644
--- a/modules/mappers/mod_actions.c
+++ b/modules/mappers/mod_actions.c
@@ -211,7 +211,7 @@ static int action_handler(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_handler(action_handler,NULL,NULL,AP_HOOK_LAST);
+    ap_hook_handler(action_handler,NULL,NULL,APR_HOOK_LAST);
 }
 
 module action_module =
diff --git a/modules/mappers/mod_alias.c b/modules/mappers/mod_alias.c
index 766c047..c9b11c6 100644
--- a/modules/mappers/mod_alias.c
+++ b/modules/mappers/mod_alias.c
@@ -424,8 +424,8 @@ static void register_hooks(apr_pool_t *p)
 {
     static const char * const aszPre[]={ "mod_userdir.c",NULL };
 
-    ap_hook_translate_name(translate_alias_redir,aszPre,NULL,AP_HOOK_MIDDLE);
-    ap_hook_fixups(fixup_redir,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_translate_name(translate_alias_redir,aszPre,NULL,APR_HOOK_MIDDLE);
+    ap_hook_fixups(fixup_redir,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA alias_module =
diff --git a/modules/mappers/mod_dir.c b/modules/mappers/mod_dir.c
index 58077e8..15e7771 100644
--- a/modules/mappers/mod_dir.c
+++ b/modules/mappers/mod_dir.c
@@ -225,7 +225,7 @@ static void register_hooks(apr_pool_t *p)
 {
     static const char * const aszSucc[]={ "mod_autoindex.c", NULL };
 
-    ap_hook_handler(handle_dir,NULL,aszSucc,AP_HOOK_MIDDLE);
+    ap_hook_handler(handle_dir,NULL,aszSucc,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA dir_module = {
diff --git a/modules/mappers/mod_imap.c b/modules/mappers/mod_imap.c
index 877a440..1ec4a34 100644
--- a/modules/mappers/mod_imap.c
+++ b/modules/mappers/mod_imap.c
@@ -915,7 +915,7 @@ menu_bail:
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_handler(imap_handler,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_handler(imap_handler,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA imap_module =
diff --git a/modules/mappers/mod_negotiation.c b/modules/mappers/mod_negotiation.c
index d85fb49..0c76b1a 100644
--- a/modules/mappers/mod_negotiation.c
+++ b/modules/mappers/mod_negotiation.c
@@ -2747,9 +2747,9 @@ static int fix_encoding(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_fixups(fix_encoding,NULL,NULL,AP_HOOK_MIDDLE);
-    ap_hook_type_checker(handle_multi,NULL,NULL,AP_HOOK_FIRST);
-    ap_hook_handler(handle_map_file,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_fixups(fix_encoding,NULL,NULL,APR_HOOK_MIDDLE);
+    ap_hook_type_checker(handle_multi,NULL,NULL,APR_HOOK_FIRST);
+    ap_hook_handler(handle_map_file,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA negotiation_module =
diff --git a/modules/mappers/mod_rewrite.c b/modules/mappers/mod_rewrite.c
index f7d1750..5236a99 100644
--- a/modules/mappers/mod_rewrite.c
+++ b/modules/mappers/mod_rewrite.c
@@ -4154,13 +4154,13 @@ static const command_rec command_table[] = {
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_handler(handler_redirect, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_post_config(init_module,NULL,NULL,AP_HOOK_MIDDLE);
-    ap_hook_child_init(init_child,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_handler(handler_redirect, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_post_config(init_module,NULL,NULL,APR_HOOK_MIDDLE);
+    ap_hook_child_init(init_child,NULL,NULL,APR_HOOK_MIDDLE);
 
-    ap_hook_fixups(hook_fixup,NULL,NULL,AP_HOOK_FIRST);
-    ap_hook_translate_name(hook_uri2file,NULL,NULL,AP_HOOK_FIRST);
-    ap_hook_type_checker(hook_mimetype,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_fixups(hook_fixup,NULL,NULL,APR_HOOK_FIRST);
+    ap_hook_translate_name(hook_uri2file,NULL,NULL,APR_HOOK_FIRST);
+    ap_hook_type_checker(hook_mimetype,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
     /* the main config structure */
diff --git a/modules/mappers/mod_speling.c b/modules/mappers/mod_speling.c
index b415120..8581385 100644
--- a/modules/mappers/mod_speling.c
+++ b/modules/mappers/mod_speling.c
@@ -553,7 +553,7 @@ static int check_speling(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_fixups(check_speling,NULL,NULL,AP_HOOK_LAST);
+    ap_hook_fixups(check_speling,NULL,NULL,APR_HOOK_LAST);
 }
 
 module AP_MODULE_DECLARE_DATA speling_module =
diff --git a/modules/mappers/mod_userdir.c b/modules/mappers/mod_userdir.c
index ef54d0f..06ce5e2 100644
--- a/modules/mappers/mod_userdir.c
+++ b/modules/mappers/mod_userdir.c
@@ -388,9 +388,9 @@ static void register_hooks(apr_pool_t *p)
 {
     static const char * const aszSucc[]={ "mod_alias.c",NULL };
 
-    ap_hook_translate_name(translate_userdir,NULL,aszSucc,AP_HOOK_MIDDLE);
+    ap_hook_translate_name(translate_userdir,NULL,aszSucc,APR_HOOK_MIDDLE);
 #ifdef HAVE_UNIX_SUEXEC
-    ap_hook_get_suexec_identity(get_suexec_id_doer,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_get_suexec_identity(get_suexec_id_doer,NULL,NULL,APR_HOOK_MIDDLE);
 #endif
 }
 
diff --git a/modules/mappers/mod_vhost_alias.c b/modules/mappers/mod_vhost_alias.c
index 85b2874..2b15a3b 100644
--- a/modules/mappers/mod_vhost_alias.c
+++ b/modules/mappers/mod_vhost_alias.c
@@ -76,7 +76,7 @@
  */
 
 #include "apr_strings.h"
-#include "ap_hooks.h"
+#include "apr_hooks.h"
 #include "httpd.h"
 #include "http_config.h"
 #include "http_core.h"
@@ -471,7 +471,7 @@ static int mva_translate(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_translate_name(mva_translate, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_translate_name(mva_translate, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA vhost_alias_module =
diff --git a/modules/metadata/mod_cern_meta.c b/modules/metadata/mod_cern_meta.c
index 491068c..66e8acb 100644
--- a/modules/metadata/mod_cern_meta.c
+++ b/modules/metadata/mod_cern_meta.c
@@ -388,7 +388,7 @@ static int add_cern_meta_data(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_fixups(add_cern_meta_data,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_fixups(add_cern_meta_data,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA cern_meta_module =
diff --git a/modules/metadata/mod_env.c b/modules/metadata/mod_env.c
index 6e6f4a9..53f291e 100644
--- a/modules/metadata/mod_env.c
+++ b/modules/metadata/mod_env.c
@@ -256,7 +256,7 @@ static int fixup_env_module(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_fixups(fixup_env_module,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_fixups(fixup_env_module,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA env_module =
diff --git a/modules/metadata/mod_expires.c b/modules/metadata/mod_expires.c
index e9f2a44..d122474 100644
--- a/modules/metadata/mod_expires.c
+++ b/modules/metadata/mod_expires.c
@@ -505,7 +505,7 @@ static int add_expires(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_fixups(add_expires,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_fixups(add_expires,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA expires_module =
diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index f866dfc..34439ef 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -253,7 +253,7 @@ static int fixup_headers(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_fixups(fixup_headers,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_fixups(fixup_headers,NULL,NULL,APR_HOOK_MIDDLE);
 } 
 
 module AP_MODULE_DECLARE_DATA headers_module =
diff --git a/modules/metadata/mod_mime_magic.c b/modules/metadata/mod_mime_magic.c
index 6294a00..5172509 100644
--- a/modules/metadata/mod_mime_magic.c
+++ b/modules/metadata/mod_mime_magic.c
@@ -2469,8 +2469,8 @@ static void register_hooks(apr_pool_t *p)
 
     /* mod_mime_magic should be run after mod_mime, if at all. */
 
-    ap_hook_type_checker(magic_find_ct, aszPre, NULL, AP_HOOK_MIDDLE);
-    ap_hook_post_config(magic_init, NULL, NULL, AP_HOOK_FIRST);
+    ap_hook_type_checker(magic_find_ct, aszPre, NULL, APR_HOOK_MIDDLE);
+    ap_hook_post_config(magic_init, NULL, NULL, APR_HOOK_FIRST);
 }
 
 /*
diff --git a/modules/metadata/mod_setenvif.c b/modules/metadata/mod_setenvif.c
index a5220ea..f738b93 100644
--- a/modules/metadata/mod_setenvif.c
+++ b/modules/metadata/mod_setenvif.c
@@ -454,8 +454,8 @@ static int match_headers(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_header_parser(match_headers, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_post_read_request(match_headers, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_header_parser(match_headers, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_post_read_request(match_headers, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA setenvif_module =
diff --git a/modules/metadata/mod_unique_id.c b/modules/metadata/mod_unique_id.c
index 16a02a5..c27f256 100644
--- a/modules/metadata/mod_unique_id.c
+++ b/modules/metadata/mod_unique_id.c
@@ -387,9 +387,9 @@ static int gen_unique_id(request_rec *r)
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_post_config(unique_id_global_init, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_child_init(unique_id_child_init, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_post_read_request(gen_unique_id, NULL, NULL, AP_HOOK_MIDDLE); 
+    ap_hook_post_config(unique_id_global_init, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_child_init(unique_id_child_init, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_post_read_request(gen_unique_id, NULL, NULL, APR_HOOK_MIDDLE); 
 }
 
 module AP_MODULE_DECLARE_DATA unique_id_module = {
diff --git a/modules/metadata/mod_usertrack.c b/modules/metadata/mod_usertrack.c
index 44314f1..6063212 100644
--- a/modules/metadata/mod_usertrack.c
+++ b/modules/metadata/mod_usertrack.c
@@ -311,7 +311,7 @@ static const command_rec cookie_log_cmds[] = {
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_hook_fixups(spot_cookie,NULL,NULL,AP_HOOK_MIDDLE);
+    ap_hook_fixups(spot_cookie,NULL,NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA usertrack_module = {
diff --git a/modules/proxy/mod_proxy.c b/modules/proxy/mod_proxy.c
index 1ac4237..4e4c038 100644
--- a/modules/proxy/mod_proxy.c
+++ b/modules/proxy/mod_proxy.c
@@ -747,11 +747,11 @@ static const command_rec proxy_cmds[] =
 static void register_hooks(apr_pool_t *p)
 {
     /* [2] filename-to-URI translation */
-    ap_hook_translate_name(proxy_trans, NULL, NULL, AP_HOOK_FIRST);
+    ap_hook_translate_name(proxy_trans, NULL, NULL, APR_HOOK_FIRST);
     /* [8] fixups */
-    ap_hook_fixups(proxy_fixup, NULL, NULL, AP_HOOK_FIRST);
+    ap_hook_fixups(proxy_fixup, NULL, NULL, APR_HOOK_FIRST);
     /* [1] post read_request handling */
-    ap_hook_post_read_request(proxy_detect, NULL, NULL, AP_HOOK_FIRST);
+    ap_hook_post_read_request(proxy_detect, NULL, NULL, APR_HOOK_FIRST);
 }
 
 module AP_MODULE_DECLARE_DATA proxy_module =
diff --git a/modules/proxy/proxy_http.c b/modules/proxy/proxy_http.c
index 044c64f..3e61f2e 100644
--- a/modules/proxy/proxy_http.c
+++ b/modules/proxy/proxy_http.c
@@ -194,8 +194,8 @@ int ap_proxy_http_handler(request_rec *r, char *url,
     apr_file_t *cachefp = NULL;
     char *buf;
     conn_rec *origin;
-    ap_bucket *e;
-    ap_bucket_brigade *bb = ap_brigade_create(r->pool);
+    apr_bucket *e;
+    apr_bucket_brigade *bb = apr_brigade_create(r->pool);
 
     void *sconf = r->server->module_config;
     proxy_server_conf *conf =
@@ -283,17 +283,17 @@ int ap_proxy_http_handler(request_rec *r, char *url,
 
     buf = apr_pstrcat(r->pool, r->method, " ", proxyhost ? url : urlptr,
                       " HTTP/1.0" CRLF, NULL);
-    e = ap_bucket_create_pool(buf, strlen(buf), r->pool);
-    AP_BRIGADE_INSERT_TAIL(bb, e);
+    e = apr_bucket_create_pool(buf, strlen(buf), r->pool);
+    APR_BRIGADE_INSERT_TAIL(bb, e);
     if (destportstr != NULL && destport != DEFAULT_HTTP_PORT) {
         buf = apr_pstrcat(r->pool, "Host: ", desthost, ":", destportstr, CRLF, NULL);
-        e = ap_bucket_create_pool(buf, strlen(buf), r->pool);
-        AP_BRIGADE_INSERT_TAIL(bb, e);
+        e = apr_bucket_create_pool(buf, strlen(buf), r->pool);
+        APR_BRIGADE_INSERT_TAIL(bb, e);
     }
     else {
         buf = apr_pstrcat(r->pool, "Host: ", desthost, CRLF, NULL);
-        e = ap_bucket_create_pool(buf, strlen(buf), r->pool);
-        AP_BRIGADE_INSERT_TAIL(bb, e);
+        e = apr_bucket_create_pool(buf, strlen(buf), r->pool);
+        APR_BRIGADE_INSERT_TAIL(bb, e);
     }
 
     if (conf->viaopt == via_block) {
@@ -335,42 +335,42 @@ int ap_proxy_http_handler(request_rec *r, char *url,
 	    || !strcasecmp(reqhdrs[i].key, "Proxy-Authorization"))
 	    continue;
         buf = apr_pstrcat(r->pool, reqhdrs[i].key, ": ", reqhdrs[i].val, CRLF, NULL);
-        e = ap_bucket_create_pool(buf, strlen(buf), r->pool);
-        AP_BRIGADE_INSERT_TAIL(bb, e);
+        e = apr_bucket_create_pool(buf, strlen(buf), r->pool);
+        APR_BRIGADE_INSERT_TAIL(bb, e);
 
     }
 
-    e = ap_bucket_create_pool(CRLF, strlen(CRLF), r->pool);
-    AP_BRIGADE_INSERT_TAIL(bb, e);
-    e = ap_bucket_create_flush();
-    AP_BRIGADE_INSERT_TAIL(bb, e);
+    e = apr_bucket_create_pool(CRLF, strlen(CRLF), r->pool);
+    APR_BRIGADE_INSERT_TAIL(bb, e);
+    e = apr_bucket_create_flush();
+    APR_BRIGADE_INSERT_TAIL(bb, e);
 
     ap_pass_brigade(origin->output_filters, bb);
 /* send the request data, if any. */
 
     if (ap_should_client_block(r)) {
 	while ((i = ap_get_client_block(r, buffer, sizeof buffer)) > 0) {
-            e = ap_bucket_create_pool(buffer, i, r->pool);
-            AP_BRIGADE_INSERT_TAIL(bb, e);
+            e = apr_bucket_create_pool(buffer, i, r->pool);
+            APR_BRIGADE_INSERT_TAIL(bb, e);
         }
     }
     /* Flush the data to the origin server */
-    e = ap_bucket_create_flush();
-    AP_BRIGADE_INSERT_TAIL(bb, e);
+    e = apr_bucket_create_flush();
+    APR_BRIGADE_INSERT_TAIL(bb, e);
     ap_pass_brigade(origin->output_filters, bb);
 
     ap_add_input_filter("HTTP_IN", NULL, NULL, origin);
     ap_add_input_filter("CORE_IN", NULL, NULL, origin);
 
-    ap_brigade_destroy(bb);
-    bb = ap_brigade_create(r->pool);
+    apr_brigade_destroy(bb);
+    bb = apr_brigade_create(r->pool);
     
     /* Tell http_filter to grab the data one line at a time. */
     origin->remain = 0;
 
     ap_get_brigade(origin->input_filters, bb, AP_MODE_BLOCKING);
-    e = AP_BRIGADE_FIRST(bb);
-    ap_bucket_read(e, (const char **)&buffer2, &len, AP_BLOCK_READ);
+    e = APR_BRIGADE_FIRST(bb);
+    apr_bucket_read(e, (const char **)&buffer2, &len, APR_BLOCK_READ);
     if (len == -1) {
 	apr_close_socket(sock);
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
@@ -383,8 +383,8 @@ int ap_proxy_http_handler(request_rec *r, char *url,
 	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
 			     "Document contains no data");
     }
-    AP_BUCKET_REMOVE(e);
-    ap_bucket_destroy(e);
+    APR_BUCKET_REMOVE(e);
+    apr_bucket_destroy(e);
 
 /* Is it an HTTP/1 response?  This is buggy if we ever see an HTTP/1.10 */
     if (ap_checkmask(buffer2, "HTTP/#.# ###*")) {
@@ -489,8 +489,8 @@ int ap_proxy_http_handler(request_rec *r, char *url,
 /* Is it an HTTP/0.9 response? If so, send the extra data */
     if (backasswards) {
         cntr = len;
-        e = ap_bucket_create_heap(buffer, cntr, 0, NULL);
-        AP_BRIGADE_INSERT_TAIL(bb, e);
+        e = apr_bucket_create_heap(buffer, cntr, 0, NULL);
+        APR_BRIGADE_INSERT_TAIL(bb, e);
         if (cachefp && apr_write(cachefp, buffer, &cntr) != APR_SUCCESS) {
 	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		"proxy: error writing extra data to cache");
@@ -507,13 +507,13 @@ int ap_proxy_http_handler(request_rec *r, char *url,
  
         origin->remain = content_length;
         while (ap_get_brigade(origin->input_filters, bb, AP_MODE_BLOCKING) == APR_SUCCESS) {
-            if (AP_BUCKET_IS_EOS(AP_BRIGADE_LAST(bb))) {
+            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
                 ap_pass_brigade(r->output_filters, bb);
                 break;
             }
             ap_pass_brigade(r->output_filters, bb);
-            ap_brigade_destroy(bb);
-            bb = ap_brigade_create(r->pool);
+            apr_brigade_destroy(bb);
+            bb = apr_brigade_create(r->pool);
         }
     }
 
diff --git a/modules/proxy/proxy_util.c b/modules/proxy/proxy_util.c
index ccab271..5e2d1ae 100644
--- a/modules/proxy/proxy_util.c
+++ b/modules/proxy/proxy_util.c
@@ -389,7 +389,7 @@ static request_rec *make_fake_req(conn_rec *c)
 
     r->request_config  = ap_create_request_config(r->pool);
     req_cfg = apr_pcalloc(r->pool, sizeof(core_request_config));
-    req_cfg->bb = ap_brigade_create(r->pool);
+    req_cfg->bb = apr_brigade_create(r->pool);
     ap_set_module_config(r->request_config, &core_module, req_cfg);
 
     return r;
diff --git a/os/unix/unixd.c b/os/unix/unixd.c
index 168a9a9..1db01cd 100644
--- a/os/unix/unixd.c
+++ b/os/unix/unixd.c
@@ -419,8 +419,8 @@ AP_DECLARE(void) unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
 #endif
 }
 
-AP_HOOK_STRUCT(
-               AP_HOOK_LINK(get_suexec_identity)
+APR_HOOK_STRUCT(
+               APR_HOOK_LINK(get_suexec_identity)
 )
 
 AP_IMPLEMENT_HOOK_RUN_FIRST(ap_unix_identity_t *, get_suexec_identity,
diff --git a/os/unix/unixd.h b/os/unix/unixd.h
index 205efca..1e6224e 100644
--- a/os/unix/unixd.h
+++ b/os/unix/unixd.h
@@ -67,7 +67,7 @@
 #ifdef HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
 #endif
-#include "ap_hooks.h"
+#include "apr_hooks.h"
 #include "apr_thread_proc.h"
 
 #include <pwd.h>
diff --git a/os/win32/mod_isapi.c b/os/win32/mod_isapi.c
index 54a9e8d..543fff8 100644
--- a/os/win32/mod_isapi.c
+++ b/os/win32/mod_isapi.c
@@ -77,7 +77,7 @@
 
 #include "apr_strings.h"
 #include "apr_portable.h"
-#include "ap_buckets.h"
+#include "apr_buckets.h"
 #include "ap_config.h"
 #include "httpd.h"
 #include "http_config.h"
@@ -648,17 +648,17 @@ BOOL WINAPI WriteClient (HCONN ConnID, LPVOID Buffer, LPDWORD lpwdwBytes,
                          DWORD dwReserved)
 {
     request_rec *r = ((isapi_cid *)ConnID)->r;
-    ap_bucket_brigade *bb;
-    ap_bucket *b;
+    apr_bucket_brigade *bb;
+    apr_bucket *b;
 
     if (dwReserved == HSE_IO_SYNC)
         ; /* XXX: Fake it */
 
-    bb = ap_brigade_create(r->pool);
-    b = ap_bucket_create_transient(Buffer, (apr_size_t)lpwdwBytes);
-    AP_BRIGADE_INSERT_TAIL(bb, b);
-    b = ap_bucket_create_eos();
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(r->pool);
+    b = apr_bucket_create_transient(Buffer, (apr_size_t)lpwdwBytes);
+    APR_BRIGADE_INSERT_TAIL(bb, b);
+    b = apr_bucket_create_eos();
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 
     return TRUE;
@@ -796,14 +796,14 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             return FALSE;
         }
         else if (ate < headlen) {
-            ap_bucket_brigade *bb;
-            ap_bucket *b;
-            bb = ap_brigade_create(cid->r->pool);
-	    b = ap_bucket_create_transient((char*) lpdwDataType + ate, 
+            apr_bucket_brigade *bb;
+            apr_bucket *b;
+            bb = apr_brigade_create(cid->r->pool);
+	    b = apr_bucket_create_transient((char*) lpdwDataType + ate, 
                                            headlen - ate);
-	    AP_BRIGADE_INSERT_TAIL(bb, b);
-            b = ap_bucket_create_eos();
-	    AP_BRIGADE_INSERT_TAIL(bb, b);
+	    APR_BRIGADE_INSERT_TAIL(bb, b);
+            b = apr_bucket_create_eos();
+	    APR_BRIGADE_INSERT_TAIL(bb, b);
 	    ap_pass_brigade(cid->r->output_filters, bb);
         }
         return TRUE;
@@ -885,8 +885,8 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
     {
         HSE_TF_INFO *tf = (HSE_TF_INFO*)lpvBuffer;
         apr_status_t rv;
-        ap_bucket_brigade *bb;
-        ap_bucket *b;
+        apr_bucket_brigade *bb;
+        apr_bucket *b;
         apr_file_t *fd;
 
         if (!cid->isa->fakeasync && (tf->dwFlags & HSE_IO_ASYNC)) {
@@ -903,7 +903,7 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
         }
         
         /* apr_dupfile_oshandle (&fd, tf->hFile, r->pool); */
-        bb = ap_brigade_create(r->pool);
+        bb = apr_brigade_create(r->pool);
 
         if (tf->dwFlags & HSE_IO_SEND_HEADERS) 
         {
@@ -922,35 +922,35 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
                                                  (apr_size_t)tf->HeadLength);
             if (ate < 0)
             {
-                ap_brigade_destroy(bb);
+                apr_brigade_destroy(bb);
                 SetLastError(TODO_ERROR);
                 return FALSE;
             }
             if (ate < (apr_size_t)tf->HeadLength)
             {
-                b = ap_bucket_create_transient((char*)tf->pHead + ate, 
+                b = apr_bucket_create_transient((char*)tf->pHead + ate, 
                                             (apr_size_t)tf->HeadLength - ate);
-                AP_BRIGADE_INSERT_TAIL(bb, b);
+                APR_BRIGADE_INSERT_TAIL(bb, b);
             }
         }
         else if (tf->pHead && tf->HeadLength) {
-            b = ap_bucket_create_transient((char*)tf->pHead, 
+            b = apr_bucket_create_transient((char*)tf->pHead, 
                                            (apr_size_t)tf->HeadLength);
-            AP_BRIGADE_INSERT_TAIL(bb, b);
+            APR_BRIGADE_INSERT_TAIL(bb, b);
         }
 
-        b = ap_bucket_create_file(fd, (apr_off_t)tf->Offset, 
+        b = apr_bucket_create_file(fd, (apr_off_t)tf->Offset, 
                                   (apr_size_t)tf->BytesToWrite);
-        AP_BRIGADE_INSERT_TAIL(bb, b);
+        APR_BRIGADE_INSERT_TAIL(bb, b);
         
         if (tf->pTail && (apr_size_t)tf->TailLength) {
-            b = ap_bucket_create_transient((char*)tf->pTail, 
+            b = apr_bucket_create_transient((char*)tf->pTail, 
                                            (apr_size_t)tf->TailLength);
-            AP_BRIGADE_INSERT_TAIL(bb, b);
+            APR_BRIGADE_INSERT_TAIL(bb, b);
         }
         
-        b = ap_bucket_create_eos();
-        AP_BRIGADE_INSERT_TAIL(bb, b);
+        b = apr_bucket_create_eos();
+        APR_BRIGADE_INSERT_TAIL(bb, b);
         ap_pass_brigade(r->output_filters, bb);
 
         /* we do nothing with (tf->dwFlags & HSE_DISCONNECT_AFTER_SEND)
@@ -1099,14 +1099,14 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             return FALSE;
         }
         else if (ate < (apr_off_t)shi->cchHeader) {
-            ap_bucket_brigade *bb;
-            ap_bucket *b;
-            bb = ap_brigade_create(cid->r->pool);
-	    b = ap_bucket_create_transient(shi->pszHeader + ate, 
+            apr_bucket_brigade *bb;
+            apr_bucket *b;
+            bb = apr_brigade_create(cid->r->pool);
+	    b = apr_bucket_create_transient(shi->pszHeader + ate, 
                                            (apr_size_t)shi->cchHeader - ate);
-	    AP_BRIGADE_INSERT_TAIL(bb, b);
-            b = ap_bucket_create_eos();
-	    AP_BRIGADE_INSERT_TAIL(bb, b);
+	    APR_BRIGADE_INSERT_TAIL(bb, b);
+            b = apr_bucket_create_eos();
+	    APR_BRIGADE_INSERT_TAIL(bb, b);
 	    ap_pass_brigade(cid->r->output_filters, bb);
         }
         return TRUE;
@@ -1266,8 +1266,8 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
 
 static void isapi_hooks(apr_pool_t *cont)
 {
-    ap_hook_post_config(isapi_post_config, NULL, NULL, AP_HOOK_MIDDLE);
-    ap_hook_handler(isapi_handler, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_post_config(isapi_post_config, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_handler(isapi_handler, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 static const command_rec isapi_cmds[] = {
diff --git a/server/config.c b/server/config.c
index 16ab1da..ab01769 100644
--- a/server/config.c
+++ b/server/config.c
@@ -109,13 +109,13 @@ AP_DECLARE_DATA apr_array_header_t *ap_server_config_defines;
 
 AP_DECLARE_DATA ap_directive_t *ap_conftree;
 
-AP_HOOK_STRUCT(
-	       AP_HOOK_LINK(header_parser)
-	       AP_HOOK_LINK(pre_config)
-	       AP_HOOK_LINK(post_config)
-	       AP_HOOK_LINK(open_logs)
-	       AP_HOOK_LINK(child_init)
-	       AP_HOOK_LINK(handler)
+APR_HOOK_STRUCT(
+	       APR_HOOK_LINK(header_parser)
+	       APR_HOOK_LINK(pre_config)
+	       APR_HOOK_LINK(post_config)
+	       APR_HOOK_LINK(open_logs)
+	       APR_HOOK_LINK(child_init)
+	       APR_HOOK_LINK(handler)
 )
 
 AP_IMPLEMENT_HOOK_RUN_ALL(int,header_parser,
@@ -345,9 +345,9 @@ AP_DECLARE(void) ap_register_hooks(module *m, apr_pool_t *p)
 	if(getenv("SHOW_HOOKS"))
 	{
 	    printf("Registering hooks for %s\n",m->name);
-	    ap_debug_module_hooks=1;
+	    apr_debug_module_hooks=1;
 	}
-	ap_current_hooking_module=m->name;
+	apr_debug_module_name=m->name;
 	m->register_hooks(p);
     }
 }
@@ -513,7 +513,7 @@ AP_DECLARE(void) ap_setup_prelinked_modules(process_rec *process)
     module **m;
     module **m2;
 
-    ap_global_hook_pool=process->pconf;
+    apr_global_hook_pool=process->pconf;
 
     /*
      *  Initialise total_modules variable and module indices
@@ -541,7 +541,7 @@ AP_DECLARE(void) ap_setup_prelinked_modules(process_rec *process)
     for (m = ap_prelinked_modules; *m != NULL; m++)
         ap_add_module(*m, process->pconf);
 
-    ap_sort_hooks();
+    apr_sort_hooks();
 }
 
 AP_DECLARE(const char *) ap_find_module_name(module *m)
diff --git a/server/connection.c b/server/connection.c
index 940496d..e7e49ce 100644
--- a/server/connection.c
+++ b/server/connection.c
@@ -76,9 +76,9 @@
 #include <arpa/inet.h>
 #endif
 
-AP_HOOK_STRUCT(
-	    AP_HOOK_LINK(pre_connection)
-	    AP_HOOK_LINK(process_connection)
+APR_HOOK_STRUCT(
+	    APR_HOOK_LINK(pre_connection)
+	    APR_HOOK_LINK(process_connection)
 )
 
 AP_IMPLEMENT_HOOK_RUN_ALL(int,pre_connection,(conn_rec *c),(c),OK,DECLINED)
@@ -132,12 +132,12 @@ static void sock_enable_linger(int s)
 
 AP_CORE_DECLARE(void) ap_flush_conn(conn_rec *c)
 {
-    ap_bucket_brigade *bb;
-    ap_bucket *b;
+    apr_bucket_brigade *bb;
+    apr_bucket *b;
 
-    bb = ap_brigade_create(c->pool);
-    b = ap_bucket_create_flush();
-    AP_BRIGADE_INSERT_TAIL(bb, b);
+    bb = apr_brigade_create(c->pool);
+    b = apr_bucket_create_flush();
+    APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(c->output_filters, bb);
 }
 
diff --git a/server/main.c b/server/main.c
index b7967c9..ee3b77b 100644
--- a/server/main.c
+++ b/server/main.c
@@ -390,7 +390,7 @@ int main(int argc, const char * const argv[])
     ap_process_config_tree(server_conf, ap_conftree, process->pconf, ptemp); 
     ap_fixup_virtual_hosts(pconf, server_conf);
     ap_fini_vhost_config(pconf, server_conf);
-    ap_sort_hooks();
+    apr_sort_hooks();
     if (configtestonly) {
 	ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, "Syntax OK\n");
 	destroy_and_exit_process(process, 0);
@@ -401,7 +401,7 @@ int main(int argc, const char * const argv[])
     apr_destroy_pool(ptemp);
 
     for (;;) {
-	ap_hook_deregister_all();
+	apr_hook_deregister_all();
 	apr_clear_pool(pconf);
 	for (mod = ap_prelinked_modules; *mod != NULL; mod++) {
 		ap_register_hooks(*mod, pconf);
@@ -418,7 +418,7 @@ int main(int argc, const char * const argv[])
         ap_process_config_tree(server_conf, ap_conftree, process->pconf, ptemp);
         ap_fixup_virtual_hosts(pconf, server_conf);
         ap_fini_vhost_config(pconf, server_conf);
-        ap_sort_hooks();
+        apr_sort_hooks();
 	apr_clear_pool(plog);
 	ap_run_open_logs(pconf, plog, ptemp, server_conf);
 	ap_post_config_hook(pconf, plog, ptemp, server_conf);
diff --git a/server/mpm/beos/beos.c b/server/mpm/beos/beos.c
index 938d0c8..cbd607c 100644
--- a/server/mpm/beos/beos.c
+++ b/server/mpm/beos/beos.c
@@ -843,7 +843,7 @@ static void beos_hooks(apr_pool_t *p)
     INIT_SIGLIST()
     one_process = 0;
     
-    ap_hook_pre_config(beos_pre_config, NULL, NULL, AP_HOOK_MIDDLE); 
+    ap_hook_pre_config(beos_pre_config, NULL, NULL, APR_HOOK_MIDDLE); 
 }
 
 
diff --git a/server/mpm/dexter/dexter.c b/server/mpm/dexter/dexter.c
index 4b88ea9..c4b035e 100644
--- a/server/mpm/dexter/dexter.c
+++ b/server/mpm/dexter/dexter.c
@@ -1162,7 +1162,7 @@ static void dexter_hooks(apr_pool_t *p)
     INIT_SIGLIST()
     one_process = 0;
 
-    ap_hook_pre_config(dexter_pre_config, NULL, NULL, AP_HOOK_MIDDLE); 
+    ap_hook_pre_config(dexter_pre_config, NULL, NULL, APR_HOOK_MIDDLE); 
 }
 
 static const char *set_pidfile(cmd_parms *cmd, void *dummy, const char *arg) 
diff --git a/server/mpm/experimental/perchild/perchild.c b/server/mpm/experimental/perchild/perchild.c
index 9cc2e25..c9dd28a 100644
--- a/server/mpm/experimental/perchild/perchild.c
+++ b/server/mpm/experimental/perchild/perchild.c
@@ -1346,7 +1346,7 @@ static int pass_request(request_rec *r)
     struct cmsghdr *cmsg;
     int sfd;
     struct iovec iov;
-    ap_bucket_brigade *bb = ap_brigade_create(r->pool);
+    apr_bucket_brigade *bb = apr_brigade_create(r->pool);
     perchild_server_conf *sconf = (perchild_server_conf *)
                             ap_get_module_config(r->server->module_config, 
                                                  &mpm_perchild_module);
@@ -1388,11 +1388,11 @@ static int pass_request(request_rec *r)
     write(sconf->sd2, foo, len);
    
     while (ap_get_brigade(r->input_filters, bb, AP_MODE_NONBLOCKING) == APR_SUCCESS) {
-        ap_bucket *e;
-        AP_BRIGADE_FOREACH(e, bb) {
+        apr_bucket *e;
+        APR_BRIGADE_FOREACH(e, bb) {
             const char *str;
 
-            ap_bucket_read(e, &str, &len, AP_NONBLOCK_READ);
+            apr_bucket_read(e, &str, &len, APR_NONBLOCK_READ);
             write(sconf->sd2, str, len);
         }
     }
@@ -1481,9 +1481,9 @@ static int perchild_post_read(request_rec *r)
     return OK;
 }
 
-static apr_status_t perchild_buffer(ap_filter_t *f, ap_bucket_brigade *b, ap_input_mode_t mode)
+static apr_status_t perchild_buffer(ap_filter_t *f, apr_bucket_brigade *b, ap_input_mode_t mode)
 {
-    ap_bucket *e;
+    apr_bucket *e;
     apr_status_t rv;
     char *buffer = NULL;
     const char *str;
@@ -1495,9 +1495,9 @@ static apr_status_t perchild_buffer(ap_filter_t *f, ap_bucket_brigade *b, ap_inp
 
     apr_get_userdata((void **)&buffer, "PERCHILD_BUFFER", f->c->pool);
 
-    AP_BRIGADE_FOREACH(e, b) {
+    APR_BRIGADE_FOREACH(e, b) {
         if (e->length != 0) {
-            ap_bucket_read(e, &str, &len, AP_NONBLOCK_READ);
+            apr_bucket_read(e, &str, &len, APR_NONBLOCK_READ);
        
             if (buffer == NULL) {
                 buffer = apr_pstrndup(f->c->pool, str, len);
@@ -1524,16 +1524,16 @@ static void perchild_hooks(apr_pool_t *p)
     INIT_SIGLIST()
     one_process = 0;
 
-    ap_hook_pre_config(perchild_pre_config, NULL, NULL, AP_HOOK_MIDDLE); 
-    ap_hook_post_config(perchild_post_config, NULL, NULL, AP_HOOK_MIDDLE); 
-    ap_hook_pre_connection(perchild_pre_connection,NULL,NULL, AP_HOOK_MIDDLE);
+    ap_hook_pre_config(perchild_pre_config, NULL, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_post_config(perchild_post_config, NULL, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_pre_connection(perchild_pre_connection,NULL,NULL, APR_HOOK_MIDDLE);
 
     /* This must be run absolutely first.  If this request isn't for this
      * server then we need to forward it to the proper child.  No sense
      * tying up this server running more post_read request hooks if it is
      * just going to be forwarded along.
      */
-    ap_hook_post_read_request(perchild_post_read, NULL, NULL, AP_HOOK_REALLY_FIRST);
+    ap_hook_post_read_request(perchild_post_read, NULL, NULL, APR_HOOK_REALLY_FIRST);
     ap_register_input_filter("PERCHILD_BUFFER", perchild_buffer, AP_FTYPE_CONTENT);
 }
 
diff --git a/server/mpm/mpmt_beos/mpmt_beos.c b/server/mpm/mpmt_beos/mpmt_beos.c
index 54cc320..c2cb11d 100644
--- a/server/mpm/mpmt_beos/mpmt_beos.c
+++ b/server/mpm/mpmt_beos/mpmt_beos.c
@@ -853,7 +853,7 @@ static void mpmt_beos_hooks(apr_pool_t *p)
     INIT_SIGLIST()
     one_process = 0;
     
-    ap_hook_pre_config(mpmt_beos_pre_config, NULL, NULL, AP_HOOK_MIDDLE); 
+    ap_hook_pre_config(mpmt_beos_pre_config, NULL, NULL, APR_HOOK_MIDDLE); 
 }
 
 
diff --git a/server/mpm/mpmt_pthread/mpmt_pthread.c b/server/mpm/mpmt_pthread/mpmt_pthread.c
index c43d685..4b8a92d 100644
--- a/server/mpm/mpmt_pthread/mpmt_pthread.c
+++ b/server/mpm/mpmt_pthread/mpmt_pthread.c
@@ -1196,7 +1196,7 @@ static void mpmt_pthread_hooks(apr_pool_t *p)
     INIT_SIGLIST()
     one_process = 0;
 
-    ap_hook_pre_config(mpmt_pthread_pre_config, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_pre_config(mpmt_pthread_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 
diff --git a/server/mpm/perchild/perchild.c b/server/mpm/perchild/perchild.c
index 9cc2e25..c9dd28a 100644
--- a/server/mpm/perchild/perchild.c
+++ b/server/mpm/perchild/perchild.c
@@ -1346,7 +1346,7 @@ static int pass_request(request_rec *r)
     struct cmsghdr *cmsg;
     int sfd;
     struct iovec iov;
-    ap_bucket_brigade *bb = ap_brigade_create(r->pool);
+    apr_bucket_brigade *bb = apr_brigade_create(r->pool);
     perchild_server_conf *sconf = (perchild_server_conf *)
                             ap_get_module_config(r->server->module_config, 
                                                  &mpm_perchild_module);
@@ -1388,11 +1388,11 @@ static int pass_request(request_rec *r)
     write(sconf->sd2, foo, len);
    
     while (ap_get_brigade(r->input_filters, bb, AP_MODE_NONBLOCKING) == APR_SUCCESS) {
-        ap_bucket *e;
-        AP_BRIGADE_FOREACH(e, bb) {
+        apr_bucket *e;
+        APR_BRIGADE_FOREACH(e, bb) {
             const char *str;
 
-            ap_bucket_read(e, &str, &len, AP_NONBLOCK_READ);
+            apr_bucket_read(e, &str, &len, APR_NONBLOCK_READ);
             write(sconf->sd2, str, len);
         }
     }
@@ -1481,9 +1481,9 @@ static int perchild_post_read(request_rec *r)
     return OK;
 }
 
-static apr_status_t perchild_buffer(ap_filter_t *f, ap_bucket_brigade *b, ap_input_mode_t mode)
+static apr_status_t perchild_buffer(ap_filter_t *f, apr_bucket_brigade *b, ap_input_mode_t mode)
 {
-    ap_bucket *e;
+    apr_bucket *e;
     apr_status_t rv;
     char *buffer = NULL;
     const char *str;
@@ -1495,9 +1495,9 @@ static apr_status_t perchild_buffer(ap_filter_t *f, ap_bucket_brigade *b, ap_inp
 
     apr_get_userdata((void **)&buffer, "PERCHILD_BUFFER", f->c->pool);
 
-    AP_BRIGADE_FOREACH(e, b) {
+    APR_BRIGADE_FOREACH(e, b) {
         if (e->length != 0) {
-            ap_bucket_read(e, &str, &len, AP_NONBLOCK_READ);
+            apr_bucket_read(e, &str, &len, APR_NONBLOCK_READ);
        
             if (buffer == NULL) {
                 buffer = apr_pstrndup(f->c->pool, str, len);
@@ -1524,16 +1524,16 @@ static void perchild_hooks(apr_pool_t *p)
     INIT_SIGLIST()
     one_process = 0;
 
-    ap_hook_pre_config(perchild_pre_config, NULL, NULL, AP_HOOK_MIDDLE); 
-    ap_hook_post_config(perchild_post_config, NULL, NULL, AP_HOOK_MIDDLE); 
-    ap_hook_pre_connection(perchild_pre_connection,NULL,NULL, AP_HOOK_MIDDLE);
+    ap_hook_pre_config(perchild_pre_config, NULL, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_post_config(perchild_post_config, NULL, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_pre_connection(perchild_pre_connection,NULL,NULL, APR_HOOK_MIDDLE);
 
     /* This must be run absolutely first.  If this request isn't for this
      * server then we need to forward it to the proper child.  No sense
      * tying up this server running more post_read request hooks if it is
      * just going to be forwarded along.
      */
-    ap_hook_post_read_request(perchild_post_read, NULL, NULL, AP_HOOK_REALLY_FIRST);
+    ap_hook_post_read_request(perchild_post_read, NULL, NULL, APR_HOOK_REALLY_FIRST);
     ap_register_input_filter("PERCHILD_BUFFER", perchild_buffer, AP_FTYPE_CONTENT);
 }
 
diff --git a/server/mpm/prefork/prefork.c b/server/mpm/prefork/prefork.c
index 288fe75..caf41e1 100644
--- a/server/mpm/prefork/prefork.c
+++ b/server/mpm/prefork/prefork.c
@@ -1583,7 +1583,7 @@ static void prefork_hooks(apr_pool_t *p)
     (void) set42sig();
 #endif
 
-    ap_hook_pre_config(prefork_pre_config, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_pre_config(prefork_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 static const char *set_pidfile(cmd_parms *cmd, void *dummy, const char *arg) 
diff --git a/server/mpm/spmt_os2/spmt_os2.c b/server/mpm/spmt_os2/spmt_os2.c
index a449b89..84f8a77 100644
--- a/server/mpm/spmt_os2/spmt_os2.c
+++ b/server/mpm/spmt_os2/spmt_os2.c
@@ -1386,7 +1386,7 @@ static void spmt_os2_hooks(apr_pool_t *p)
     INIT_SIGLIST();
     /* TODO: set one_process properly */ one_process = 0;
 
-    ap_hook_pre_config(spmt_os2_pre_config, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_pre_config(spmt_os2_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 static const char *set_pidfile(cmd_parms *cmd, void *dummy, char *arg) 
diff --git a/server/mpm/winnt/mpm_winnt.c b/server/mpm/winnt/mpm_winnt.c
index 2d98a29..43502a4 100644
--- a/server/mpm/winnt/mpm_winnt.c
+++ b/server/mpm/winnt/mpm_winnt.c
@@ -2228,7 +2228,7 @@ AP_DECLARE(int) ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
 
 static void winnt_hooks(apr_pool_t *p)
 {
-    ap_hook_pre_config(winnt_pre_config, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_hook_pre_config(winnt_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
     ap_hook_post_config(winnt_post_config, NULL, NULL, 0);
 }
 
diff --git a/server/util.c b/server/util.c
index b3c61d0..f6d389d 100644
--- a/server/util.c
+++ b/server/util.c
@@ -85,7 +85,7 @@
 #endif
 
 #include "ap_config.h"
-#include "ap_base64.h"
+#include "apr_base64.h"
 #include "httpd.h"
 #include "http_main.h"
 #include "http_log.h"
@@ -1908,15 +1908,15 @@ char *ap_get_local_host(apr_pool_t *a)
     return server_hostname;
 }
 
-/* simple 'pool' alloc()ing glue to ap_base64.c
+/* simple 'pool' alloc()ing glue to apr_base64.c
  */
 AP_DECLARE(char *) ap_pbase64decode(apr_pool_t *p, const char *bufcoded)
 {
     char *decoded;
     int l;
 
-    decoded = (char *) apr_palloc(p, 1 + ap_base64decode_len(bufcoded));
-    l = ap_base64decode(decoded, bufcoded);
+    decoded = (char *) apr_palloc(p, 1 + apr_base64decode_len(bufcoded));
+    l = apr_base64decode(decoded, bufcoded);
     decoded[l] = '\0'; /* make binary sequence into string */
 
     return decoded;
@@ -1927,8 +1927,8 @@ AP_DECLARE(char *) ap_pbase64encode(apr_pool_t *p, char *string)
     char *encoded;
     int l = strlen(string);
 
-    encoded = (char *) apr_palloc(p, 1 + ap_base64encode_len(l));
-    l = ap_base64encode(encoded, string, l);
+    encoded = (char *) apr_palloc(p, 1 + apr_base64encode_len(l));
+    l = apr_base64encode(encoded, string, l);
     encoded[l] = '\0'; /* make binary sequence into string */
 
     return encoded;
diff --git a/server/util_ebcdic.c b/server/util_ebcdic.c
index c83719e..2e8b654 100644
--- a/server/util_ebcdic.c
+++ b/server/util_ebcdic.c
@@ -106,17 +106,17 @@ apr_status_t ap_init_ebcdic(apr_pool_t *pool)
         return rv;
     }
     
-    rv = ap_base64init_ebcdic(ap_hdrs_to_ascii, ap_hdrs_from_ascii);
+    rv = apr_base64init_ebcdic(ap_hdrs_to_ascii, ap_hdrs_from_ascii);
     if (rv) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
-                     "ap_base64init_ebcdic() failed");
+                     "apr_base64init_ebcdic() failed");
         return rv;
     }
     
-    rv = ap_SHA1InitEBCDIC(ap_hdrs_to_ascii);
+    rv = apr_SHA1InitEBCDIC(ap_hdrs_to_ascii);
     if (rv) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
-                     "ap_SHA1InitEBCDIC() failed");
+                     "apr_SHA1InitEBCDIC() failed");
         return rv;
     }
     
diff --git a/server/util_filter.c b/server/util_filter.c
index e676e88..70efc5f 100644
--- a/server/util_filter.c
+++ b/server/util_filter.c
@@ -69,8 +69,8 @@ static ap_filter_rec_t *registered_input_filters = NULL;
 /* NOTE: Apache's current design doesn't allow a pool to be passed thu,
    so we depend on a global to hold the correct pool
 */
-#define FILTER_POOL     ap_global_hook_pool
-#include "ap_hooks.h"   /* for ap_global_hook_pool */
+#define FILTER_POOL     apr_global_hook_pool
+#include "apr_hooks.h"   /* for apr_global_hook_pool */
 
 /*
 ** This macro returns true/false if a given filter should be inserted BEFORE
@@ -208,7 +208,7 @@ AP_DECLARE(void) ap_remove_output_filter(ap_filter_t *f)
  * save data off to the side should probably create their own temporary
  * brigade especially for that use.
  */
-AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *next, ap_bucket_brigade *bb, 
+AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *next, apr_bucket_brigade *bb, 
                                         ap_input_mode_t mode)
 {
     if (next) {
@@ -222,11 +222,11 @@ AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *next, ap_bucket_brigade *bb
  * the current filter.  At that point, we can just call the first filter in
  * the stack, or r->output_filters.
  */
-AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *next, ap_bucket_brigade *bb)
+AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *next, apr_bucket_brigade *bb)
 {
     if (next) {
-        ap_bucket *e;
-        if ((e = AP_BRIGADE_LAST(bb)) && AP_BUCKET_IS_EOS(e) && next->r) {
+        apr_bucket *e;
+        if ((e = APR_BRIGADE_LAST(bb)) && APR_BUCKET_IS_EOS(e) && next->r) {
             /* This is only safe because HTTP_HEADER filter is always in
              * the filter stack.   This ensures that there is ALWAYS a
              * request-based filter that we can attach this to.  If the
@@ -242,10 +242,10 @@ AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *next, ap_bucket_brigade *b
     return AP_NOBODY_WROTE;
 }
 
-AP_DECLARE(apr_status_t) ap_save_brigade(ap_filter_t *f, ap_bucket_brigade **saveto,
-                                         ap_bucket_brigade **b)
+AP_DECLARE(apr_status_t) ap_save_brigade(ap_filter_t *f, apr_bucket_brigade **saveto,
+                                         apr_bucket_brigade **b)
 {
-    ap_bucket *e;
+    apr_bucket *e;
     apr_pool_t *p = f->r ? f->r->pool : f->c->pool;
     apr_status_t rv;
 
@@ -253,15 +253,15 @@ AP_DECLARE(apr_status_t) ap_save_brigade(ap_filter_t *f, ap_bucket_brigade **sav
      * create an empty bucket brigade so that we can concat.
      */
     if (!(*saveto)) {
-        *saveto = ap_brigade_create(p);
+        *saveto = apr_brigade_create(p);
     }
     
-    AP_RING_FOREACH(e, &(*b)->list, ap_bucket, link) {
-        rv = ap_bucket_setaside(e);
+    APR_RING_FOREACH(e, &(*b)->list, apr_bucket, link) {
+        rv = apr_bucket_setaside(e);
         if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {
             return rv;
         }
     }
-    AP_BRIGADE_CONCAT(*saveto, *b);
+    APR_BRIGADE_CONCAT(*saveto, *b);
     return APR_SUCCESS;
 }
diff --git a/support/ab.c b/support/ab.c
index 420e5cf..d192470 100644
--- a/support/ab.c
+++ b/support/ab.c
@@ -129,7 +129,7 @@
 #include <stdlib.h>
 #endif
 
-#include "ap_base64.h"
+#include "apr_base64.h"
 #ifdef NOT_ASCII
 #include "apr_xlate.h"
 #endif
@@ -903,14 +903,14 @@ static void test(void)
 static void copyright(void)
 {
     if (!use_html) {
-        printf("This is ApacheBench, Version %s\n", AB_VERSION " <$Revision: 1.51 $> apache-2.0");
+        printf("This is ApacheBench, Version %s\n", AB_VERSION " <$Revision: 1.52 $> apache-2.0");
         printf("Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\n");
         printf("Copyright (c) 1998-2000 The Apache Software Foundation, http://www.apache.org/\n");
         printf("\n");
     }
     else {
         printf("<p>\n");
-        printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-2.0<br>\n", AB_VERSION, "$Revision: 1.51 $");
+        printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-2.0<br>\n", AB_VERSION, "$Revision: 1.52 $");
         printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
         printf(" Copyright (c) 1998-2000 The Apache Software Foundation, http://www.apache.org/<br>\n");
         printf("</p>\n<p>\n");
@@ -1065,9 +1065,9 @@ int main(int argc, const char * const argv[])
         fprintf(stderr, "apr_xlate_open(from ASCII)->%d\n", status);
         exit(1);
     }
-    status = ap_base64init_ebcdic(to_ascii, from_ascii);
+    status = apr_base64init_ebcdic(to_ascii, from_ascii);
     if (status) {
-        fprintf(stderr, "ap_base64init_ebcdic()->%d\n", status);
+        fprintf(stderr, "apr_base64init_ebcdic()->%d\n", status);
         exit(1);
     }
 #endif
@@ -1124,7 +1124,7 @@ int main(int argc, const char * const argv[])
              */
             while(apr_isspace(*optarg))
                 optarg++;
-            l=ap_base64encode(tmp, optarg, strlen(optarg));
+            l=apr_base64encode(tmp, optarg, strlen(optarg));
             tmp[l]='\0';
  
             strncat(auth, "Authorization: basic ", sizeof(auth));
@@ -1137,7 +1137,7 @@ int main(int argc, const char * const argv[])
              */
             while(apr_isspace(*optarg))
                 optarg++;
-            l=ap_base64encode(tmp, optarg, strlen(optarg));
+            l=apr_base64encode(tmp, optarg, strlen(optarg));
             tmp[l]='\0';
  
             strncat(auth, "Proxy-Authorization: basic ", sizeof(auth));
diff --git a/support/htpasswd.c b/support/htpasswd.c
index d8e6653..e9eeefa 100644
--- a/support/htpasswd.c
+++ b/support/htpasswd.c
@@ -91,7 +91,7 @@
 #endif
 
 #include "apr_md5.h"
-#include "ap_sha1.h"
+#include "apr_sha1.h"
 #if APR_HAVE_SIGNAL_H
 #include <signal.h>
 #endif
@@ -234,7 +234,7 @@ static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
 
     case ALG_APSHA:
 	/* XXX cpw >= 28 + strlen(sha1) chars - fixed len SHA */
- 	ap_sha1_base64(pw,strlen(pw),cpw);
+ 	apr_sha1_base64(pw,strlen(pw),cpw);
 	break;
 
     case ALG_APMD5: 
@@ -409,9 +409,9 @@ int main(int argc, char *argv[])
         fprintf(stderr, "apr_xlate_open(to ASCII)->%d\n", rv);
         exit(1);
     }
-    rv = ap_SHA1InitEBCDIC(to_ascii);
+    rv = apr_SHA1InitEBCDIC(to_ascii);
     if (rv) {
-        fprintf(stderr, "ap_SHA1InitEBCDIC()->%d\n", rv);
+        fprintf(stderr, "apr_SHA1InitEBCDIC()->%d\n", rv);
         exit(1);
     }
     rv = apr_MD5InitEBCDIC(to_ascii);
