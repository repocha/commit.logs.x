commit bbc1387cb927f127d28296415c09e543eb8bcabd
Author: Doug MacEachern <dougm@apache.org>
Date:   Thu Feb 8 07:45:33 2001 +0000

    renaming various functions for consistency sake
    see: http://apr.apache.org/~dougm/apr_rename.pl
    PR:
    Obtained from:
    Submitted by:
    Reviewed by:
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@88019 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/include/ap_mmn.h b/include/ap_mmn.h
index 32b8d47..bb48a87 100644
--- a/include/ap_mmn.h
+++ b/include/ap_mmn.h
@@ -168,7 +168,7 @@
  *			  added limit_req_body to core_dir_config and
  *			  ap_get_limit_req_body() to get its value.
  * 19980812 (1.3.2-dev)	- split off MODULE_MAGIC_NUMBER
- * 19980812.2           - add apr_overlap_tables()
+ * 19980812.2           - add apr_table_overlap()
  * 19980816 (1.3.2-dev)	- change proxy to use tables for headers, change
  *                        struct cache_req to typedef cache_req.
  *                        Delete ap_proxy_get_header(), ap_proxy_add_header(),
@@ -205,8 +205,8 @@
  *                      - reordered entries in request_rec that were waiting
  *                        for a non-binary-compatible release.
  *          (1.3.5-dev)
- * 19990108.1           - add apr_MD5Encode() for MD5 password handling.
- * 19990108.2           - add apr_validate_password() and change apr_MD5Encode()
+ * 19990108.1           - add apr_md5_encode() for MD5 password handling.
+ * 19990108.2           - add apr_password_validate() and change apr_md5_encode()
  *                        to use a stronger algorithm.
  * 19990108.4           - add ap_size_list_item(), ap_get_list_item(), and
  *                        ap_find_list_item()
@@ -221,11 +221,11 @@
  * 19990320.3           - add ap_regexec() and ap_regerror()
  * 19990320.4           - add ap_field_noparam()
  * 19990320.5           - add local_ip/host to conn_rec for mass-vhost
- * 19990320.6           - add apr_SHA1Final(), apr_SHA1Init(),
- *                        apr_SHA1Update_binary(), apr_SHA1Update(),
- *                        apr_base64encode(), apr_base64encode_binary(),
- *                        apr_base64encode_len(), apr_base64decode(),
- *                        apr_base64decode_binary(), apr_base64decode_len(),
+ * 19990320.6           - add apr_sha1_final(), apr_sha1_init(),
+ *                        apr_sha1_update_binary(), apr_sha1_update(),
+ *                        apr_base64_encode(), apr_base64_encode_binary(),
+ *                        apr_base64_encode_len(), apr_base64_decode(),
+ *                        apr_base64_decode_binary(), apr_base64_decode_len(),
  *                        ap_pbase64decode(), ap_pbase64encode()
  */
 
@@ -242,13 +242,13 @@
  * specified value.
  * <PRE>
  * Useful for testing for features.
- * For example, suppose you wish to use the apr_overlap_tables
+ * For example, suppose you wish to use the apr_table_overlap
  *    function.  You can do this:
  * 
  * #if MODULE_MAGIC_AT_LEAST(19980812,2)
- *     ... use apr_overlap_tables()
+ *     ... use apr_table_overlap()
  * #else
- *     ... alternative code which doesn't use apr_overlap_tables()
+ *     ... alternative code which doesn't use apr_table_overlap()
  * #endif
  * </PRE>
  * @param major The major module magic number
diff --git a/modules/aaa/mod_access.c b/modules/aaa/mod_access.c
index 1e19955..10ddd77 100644
--- a/modules/aaa/mod_access.c
+++ b/modules/aaa/mod_access.c
@@ -127,8 +127,8 @@ static void *create_access_dir_config(apr_pool_t *p, char *dummy)
 
     for (i = 0; i < METHODS; ++i)
 	conf->order[i] = DENY_THEN_ALLOW;
-    conf->allows = apr_make_array(p, 1, sizeof(allowdeny));
-    conf->denys = apr_make_array(p, 1, sizeof(allowdeny));
+    conf->allows = apr_array_make(p, 1, sizeof(allowdeny));
+    conf->denys = apr_array_make(p, 1, sizeof(allowdeny));
 
     return (void *) conf;
 }
@@ -172,7 +172,7 @@ static const char *allow_cmd(cmd_parms *cmd, void *dv, const char *from,
     if (strcasecmp(from, "from"))
 	return "allow and deny must be followed by 'from'";
 
-    a = (allowdeny *) apr_push_array(cmd->info ? d->allows : d->denys);
+    a = (allowdeny *) apr_array_push(cmd->info ? d->allows : d->denys);
     a->x.from = where;
     a->limited = cmd->limited;
 
diff --git a/modules/aaa/mod_auth.c b/modules/aaa/mod_auth.c
index e3b61af..9cd7c52 100644
--- a/modules/aaa/mod_auth.c
+++ b/modules/aaa/mod_auth.c
@@ -153,7 +153,7 @@ static char *get_pw(request_rec *r, char *user, char *auth_pwfile)
 static apr_table_t *groups_for_user(apr_pool_t *p, char *user, char *grpfile)
 {
     configfile_t *f;
-    apr_table_t *grps = apr_make_table(p, 15);
+    apr_table_t *grps = apr_table_make(p, 15);
     apr_pool_t *sp;
     char l[MAX_STRING_LEN];
     const char *group_name, *ll, *w;
@@ -165,7 +165,7 @@ static apr_table_t *groups_for_user(apr_pool_t *p, char *user, char *grpfile)
 	return NULL;
     }
 
-    apr_create_pool(&sp, p);
+    apr_pool_create(&sp, p);
 
     while (!(ap_cfg_getline(l, MAX_STRING_LEN, f))) {
 	if ((l[0] == '#') || (!l[0]))
@@ -184,7 +184,7 @@ static apr_table_t *groups_for_user(apr_pool_t *p, char *user, char *grpfile)
 	}
     }
     ap_cfg_closefile(f);
-    apr_destroy_pool(sp);
+    apr_pool_destroy(sp);
     return grps;
 }
 
@@ -225,7 +225,7 @@ static int authenticate_basic_user(request_rec *r)
 	ap_note_basic_auth_failure(r);
 	return HTTP_UNAUTHORIZED;
     }
-    invalid_pw = apr_validate_password(sent_pw, real_pw);
+    invalid_pw = apr_password_validate(sent_pw, real_pw);
     if (invalid_pw != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		      "user %s: authentication failure for \"%s\": "
diff --git a/modules/aaa/mod_auth_db.c b/modules/aaa/mod_auth_db.c
index d755c8b..efde731 100644
--- a/modules/aaa/mod_auth_db.c
+++ b/modules/aaa/mod_auth_db.c
@@ -319,7 +319,7 @@ static int db_authenticate_basic_user(request_rec *r)
 	*colon_pw = '\0';
     }
 
-    invalid_pw = apr_validate_password(sent_pw, real_pw);
+    invalid_pw = apr_password_validate(sent_pw, real_pw);
 
     if (invalid_pw != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
diff --git a/modules/aaa/mod_auth_dbm.c b/modules/aaa/mod_auth_dbm.c
index e8edb73..a6bd82a 100644
--- a/modules/aaa/mod_auth_dbm.c
+++ b/modules/aaa/mod_auth_dbm.c
@@ -259,7 +259,7 @@ static int dbm_authenticate_basic_user(request_rec *r)
     if (colon_pw) {
 	*colon_pw = '\0';
     }
-    invalid_pw = apr_validate_password(sent_pw, real_pw);
+    invalid_pw = apr_password_validate(sent_pw, real_pw);
     if (invalid_pw != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		      "DBM user %s: authentication failure for \"%s\": "
diff --git a/modules/aaa/mod_auth_digest.c b/modules/aaa/mod_auth_digest.c
index 720894e..1295278 100644
--- a/modules/aaa/mod_auth_digest.c
+++ b/modules/aaa/mod_auth_digest.c
@@ -139,13 +139,13 @@ void *apr_shm_calloc(apr_shmem_t *shared, apr_size_t size) {
 apr_status_t apr_shm_free(apr_shmem_t *shared, void *free) {
     return APR_ENOTIMPL;
 }
-apr_status_t apr_get_shm_name(apr_shmem_t *c, apr_shm_name_t **name) {
+apr_status_t apr_shm_name_get(apr_shmem_t *c, apr_shm_name_t **name) {
     return APR_ENOTIMPL;
 }
-apr_status_t apr_set_shm_name(apr_shmem_t *c, apr_shm_name_t *name) {
+apr_status_t apr_shm_name_set(apr_shmem_t *c, apr_shm_name_t *name) {
     return APR_ENOTIMPL;
 }
-apr_status_t apr_open_shmem(apr_shmem_t *c) {
+apr_status_t apr_shm_open(apr_shmem_t *c) {
     return APR_ENOTIMPL;
 }
 apr_status_t apr_shm_avail(apr_shmem_t *c, apr_size_t *avail) {
@@ -280,12 +280,12 @@ static apr_status_t cleanup_tables(void *not_used)
     }
 
     if (client_lock) {
-	apr_destroy_lock(client_lock);
+	apr_lock_destroy(client_lock);
 	client_lock = NULL;
     }
 
     if (opaque_lock) {
-	apr_destroy_lock(opaque_lock);
+	apr_lock_destroy(opaque_lock);
 	opaque_lock = NULL;
     }
 
@@ -348,7 +348,7 @@ static void initialize_tables(server_rec *s, apr_pool_t *ctx)
     client_list->num_entries = 0;
 
     tmpnam(client_lock_name);
-    sts = apr_create_lock(&client_lock, APR_READWRITE, APR_LOCKALL,
+    sts = apr_lock_create(&client_lock, APR_READWRITE, APR_LOCKALL,
 			 client_lock_name, ctx);
     if (sts != APR_SUCCESS) {
 	log_error_and_cleanup("failed to create lock", sts, s);
@@ -366,7 +366,7 @@ static void initialize_tables(server_rec *s, apr_pool_t *ctx)
     *opaque_cntr = 1UL;
 
     tmpnam(opaque_lock_name);
-    sts = apr_create_lock(&opaque_lock, APR_MUTEX, APR_LOCKALL,
+    sts = apr_lock_create(&opaque_lock, APR_MUTEX, APR_LOCKALL,
 			 opaque_lock_name, ctx);
     if (sts != APR_SUCCESS) {
 	log_error_and_cleanup("failed to create lock", sts, s);
@@ -418,7 +418,7 @@ static void initialize_module(apr_pool_t *p, apr_pool_t *plog,
      * creating a creeping memory leak.
      */
     initialize_tables(s, p);
-    apr_register_cleanup(p, NULL, cleanup_tables, apr_null_cleanup);
+    apr_pool_cleanup_register(p, NULL, cleanup_tables, apr_pool_cleanup_null);
 #endif	/* APR_HAS_SHARED_MEMORY */
 }
 
@@ -429,9 +429,9 @@ static void initialize_child(apr_pool_t *p, server_rec *s)
     if (!client_shm)
 	return;
 
-    if ((sts = apr_child_init_lock(&client_lock, client_lock_name, p))
+    if ((sts = apr_lock_child_init(&client_lock, client_lock_name, p))
 	    != APR_SUCCESS
-	||  (sts = apr_child_init_lock(&opaque_lock, opaque_lock_name, p))
+	||  (sts = apr_lock_child_init(&opaque_lock, opaque_lock_name, p))
 	    != APR_SUCCESS) {
 	log_error_and_cleanup("failed to create lock", sts, s);
 	return;
@@ -475,9 +475,9 @@ static const char *set_realm(cmd_parms *cmd, void *config, const char *realm)
      * the host:port would be too, but that varies for .htaccess files
      * and directives outside a virtual host section)
      */
-    apr_SHA1Init(&conf->nonce_ctx);
-    apr_SHA1Update_binary(&conf->nonce_ctx, secret, sizeof(secret));
-    apr_SHA1Update_binary(&conf->nonce_ctx, (const unsigned char *) realm,
+    apr_sha1_init(&conf->nonce_ctx);
+    apr_sha1_update_binary(&conf->nonce_ctx, secret, sizeof(secret));
+    apr_sha1_update_binary(&conf->nonce_ctx, (const unsigned char *) realm,
 			 strlen(realm));
 
     return DECLINE_CMD;
@@ -721,7 +721,7 @@ static client_entry *get_client(unsigned long key, const request_rec *r)
     bucket = key % client_list->tbl_len;
     entry  = client_list->table[bucket];
 
-    apr_lock(client_lock /*, MM_LOCK_RD */);
+    apr_lock_aquire(client_lock /*, MM_LOCK_RD */);
 
     while(entry && key != entry->key) {
 	prev  = entry;
@@ -734,7 +734,7 @@ static client_entry *get_client(unsigned long key, const request_rec *r)
 	client_list->table[bucket] = entry;
     }
 
-    apr_unlock(client_lock);
+    apr_lock_release(client_lock);
 
     if (entry)
 	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, 0, r,
@@ -798,7 +798,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
     bucket = key % client_list->tbl_len;
     entry  = client_list->table[bucket];
 
-    apr_lock(client_lock /*, MM_LOCK_RW */);
+    apr_lock_aquire(client_lock /*, MM_LOCK_RW */);
 
     /* try to allocate a new entry */
 
@@ -824,7 +824,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
     client_list->num_created++;
     client_list->num_entries++;
 
-    apr_unlock(client_lock);
+    apr_lock_release(client_lock);
 
     ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, 0, s,
 		 "allocated new client %lu", key);
@@ -992,16 +992,16 @@ static void gen_nonce_hash(char *hash, const char *timestr, const char *opaque,
 
     memcpy(&ctx, &conf->nonce_ctx, sizeof(ctx));
     /*
-    apr_SHA1Update_binary(&ctx, (const unsigned char *) server->server_hostname,
+    apr_sha1_update_binary(&ctx, (const unsigned char *) server->server_hostname,
 			 strlen(server->server_hostname));
-    apr_SHA1Update_binary(&ctx, (const unsigned char *) &server->port,
+    apr_sha1_update_binary(&ctx, (const unsigned char *) &server->port,
 			 sizeof(server->port));
      */
-    apr_SHA1Update_binary(&ctx, (const unsigned char *) timestr, strlen(timestr));
+    apr_sha1_update_binary(&ctx, (const unsigned char *) timestr, strlen(timestr));
     if (opaque)
-	apr_SHA1Update_binary(&ctx, (const unsigned char *) opaque,
+	apr_sha1_update_binary(&ctx, (const unsigned char *) opaque,
 			     strlen(opaque));
-    apr_SHA1Final(sha1, &ctx);
+    apr_sha1_final(sha1, &ctx);
 
     for (idx=0; idx<APR_SHA1_DIGESTSIZE; idx++) {
 	*hash++ = hex[sha1[idx] >> 4];
@@ -1031,7 +1031,7 @@ static const char *gen_nonce(apr_pool_t *p, apr_time_t now, const char *opaque,
 	t.time = (*otn_counter)++;
     else
 	t.time = 42;
-    len = apr_base64encode_binary(nonce, t.arr, sizeof(t.arr));
+    len = apr_base64_encode_binary(nonce, t.arr, sizeof(t.arr));
     gen_nonce_hash(nonce+NONCE_TIME_LEN, nonce, opaque, server, conf);
 
     return nonce;
@@ -1053,9 +1053,9 @@ static client_entry *gen_client(const request_rec *r)
 
     if (!opaque_cntr)  return NULL;
 
-    apr_lock(opaque_lock /*, MM_LOCK_RW */);
+    apr_lock_aquire(opaque_lock /*, MM_LOCK_RW */);
     op = (*opaque_cntr)++;
-    apr_unlock(opaque_lock);
+    apr_lock_release(opaque_lock);
 
     if (!(entry = add_client(op, &new_entry, r->server))) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
@@ -1408,7 +1408,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
 
     tmp = resp->nonce[NONCE_TIME_LEN];
     resp->nonce[NONCE_TIME_LEN] = '\0';
-    len = apr_base64decode_binary(nonce_time.arr, resp->nonce);
+    len = apr_base64_decode_binary(nonce_time.arr, resp->nonce);
     gen_nonce_hash(hash, resp->nonce, resp->opaque, r->server, conf);
     resp->nonce[NONCE_TIME_LEN] = tmp;
     resp->nonce_time = nonce_time.time;
@@ -1768,7 +1768,7 @@ static apr_table_t *groups_for_user(request_rec *r, const char *user,
 			      const char *grpfile)
 {
     configfile_t *f;
-    apr_table_t *grps = apr_make_table(r->pool, 15);
+    apr_table_t *grps = apr_table_make(r->pool, 15);
     apr_pool_t *sp;
     char l[MAX_STRING_LEN];
     const char *group_name, *ll, *w;
@@ -1780,7 +1780,7 @@ static apr_table_t *groups_for_user(request_rec *r, const char *user,
 	return NULL;
     }
 
-    if (apr_create_pool(&sp, r->pool) != APR_SUCCESS)
+    if (apr_pool_create(&sp, r->pool) != APR_SUCCESS)
 		return NULL;
 
     while (!(ap_cfg_getline(l, MAX_STRING_LEN, f))) {
@@ -1801,7 +1801,7 @@ static apr_table_t *groups_for_user(request_rec *r, const char *user,
     }
 
     ap_cfg_closefile(f);
-    apr_destroy_pool(sp);
+    apr_pool_destroy(sp);
     return grps;
 }
 
diff --git a/modules/arch/win32/mod_isapi.c b/modules/arch/win32/mod_isapi.c
index 803b9da..cae86d6 100644
--- a/modules/arch/win32/mod_isapi.c
+++ b/modules/arch/win32/mod_isapi.c
@@ -191,7 +191,7 @@ static apr_status_t cleanup_isapi_server_config(void *sconfv)
 static void *create_isapi_server_config(apr_pool_t *p, server_rec *s)
 {
     isapi_server_conf *sconf = apr_palloc(p, sizeof(isapi_server_conf));
-    sconf->loaded = apr_make_array(p, 20, sizeof(isapi_loaded*));
+    sconf->loaded = apr_array_make(p, 20, sizeof(isapi_loaded*));
     sconf->lock = CreateMutex(NULL, FALSE, NULL);
 
     sconf->ReadAheadBuffer = 49152;
@@ -199,8 +199,8 @@ static void *create_isapi_server_config(apr_pool_t *p, server_rec *s)
     sconf->AppendLogToErrors   = 0;
     sconf->AppendLogToQuery    = 0;
 
-    apr_register_cleanup(p, sconf, cleanup_isapi_server_config, 
-                                   apr_null_cleanup);
+    apr_pool_cleanup_register(p, sconf, cleanup_isapi_server_config, 
+                                   apr_pool_cleanup_null);
 
     return sconf;
 }
@@ -655,9 +655,9 @@ BOOL WINAPI WriteClient (HCONN ConnID, LPVOID Buffer, LPDWORD lpwdwBytes,
         ; /* XXX: Fake it */
 
     bb = apr_brigade_create(r->pool);
-    b = apr_bucket_create_transient(Buffer, (apr_size_t)lpwdwBytes);
+    b = apr_bucket_transient_create(Buffer, (apr_size_t)lpwdwBytes);
     APR_BRIGADE_INSERT_TAIL(bb, b);
-    b = apr_bucket_create_eos();
+    b = apr_bucket_eos_create();
     APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 
@@ -799,10 +799,10 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             apr_bucket_brigade *bb;
             apr_bucket *b;
             bb = apr_brigade_create(cid->r->pool);
-	    b = apr_bucket_create_transient((char*) lpdwDataType + ate, 
+	    b = apr_bucket_transient_create((char*) lpdwDataType + ate, 
                                            headlen - ate);
 	    APR_BRIGADE_INSERT_TAIL(bb, b);
-            b = apr_bucket_create_eos();
+            b = apr_bucket_eos_create();
 	    APR_BRIGADE_INSERT_TAIL(bb, b);
 	    ap_pass_brigade(cid->r->output_filters, bb);
         }
@@ -898,7 +898,7 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             return FALSE;
         }
         
-        if ((rv = apr_put_os_file(&fd, tf->hFile, r->pool)) != APR_SUCCESS) {
+        if ((rv = apr_os_file_put(&fd, tf->hFile, r->pool)) != APR_SUCCESS) {
             return FALSE;
         }
         
@@ -928,28 +928,28 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             }
             if (ate < (apr_size_t)tf->HeadLength)
             {
-                b = apr_bucket_create_transient((char*)tf->pHead + ate, 
+                b = apr_bucket_transient_create((char*)tf->pHead + ate, 
                                             (apr_size_t)tf->HeadLength - ate);
                 APR_BRIGADE_INSERT_TAIL(bb, b);
             }
         }
         else if (tf->pHead && tf->HeadLength) {
-            b = apr_bucket_create_transient((char*)tf->pHead, 
+            b = apr_bucket_transient_create((char*)tf->pHead, 
                                            (apr_size_t)tf->HeadLength);
             APR_BRIGADE_INSERT_TAIL(bb, b);
         }
 
-        b = apr_bucket_create_file(fd, (apr_off_t)tf->Offset, 
+        b = apr_bucket_file_create(fd, (apr_off_t)tf->Offset, 
                                   (apr_size_t)tf->BytesToWrite);
         APR_BRIGADE_INSERT_TAIL(bb, b);
         
         if (tf->pTail && (apr_size_t)tf->TailLength) {
-            b = apr_bucket_create_transient((char*)tf->pTail, 
+            b = apr_bucket_transient_create((char*)tf->pTail, 
                                            (apr_size_t)tf->TailLength);
             APR_BRIGADE_INSERT_TAIL(bb, b);
         }
         
-        b = apr_bucket_create_eos();
+        b = apr_bucket_eos_create();
         APR_BRIGADE_INSERT_TAIL(bb, b);
         ap_pass_brigade(r->output_filters, bb);
 
@@ -1102,10 +1102,10 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             apr_bucket_brigade *bb;
             apr_bucket *b;
             bb = apr_brigade_create(cid->r->pool);
-	    b = apr_bucket_create_transient(shi->pszHeader + ate, 
+	    b = apr_bucket_transient_create(shi->pszHeader + ate, 
                                            (apr_size_t)shi->cchHeader - ate);
 	    APR_BRIGADE_INSERT_TAIL(bb, b);
-            b = apr_bucket_create_eos();
+            b = apr_bucket_eos_create();
 	    APR_BRIGADE_INSERT_TAIL(bb, b);
 	    ap_pass_brigade(cid->r->output_filters, bb);
         }
@@ -1259,7 +1259,7 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
     }
 
     /* Add to cached list of loaded modules */
-    newisa = apr_push_array(sconf->loaded);
+    newisa = apr_array_push(sconf->loaded);
     *newisa = isa;
     
     return NULL;
diff --git a/modules/cache/mod_file_cache.c b/modules/cache/mod_file_cache.c
index cf2d8cc..7e56969 100644
--- a/modules/cache/mod_file_cache.c
+++ b/modules/cache/mod_file_cache.c
@@ -153,7 +153,7 @@ static void *create_server_config(apr_pool_t *p, server_rec *s)
 {
     a_server_config *sconf = apr_palloc(p, sizeof(*sconf));
 
-    sconf->files = apr_make_array(p, 20, sizeof(a_file));
+    sconf->files = apr_array_make(p, 20, sizeof(a_file));
     return sconf;
 }
 
@@ -173,7 +173,7 @@ static apr_status_t cleanup_file_cache(void *sconfv)
         else 
 #endif 
 #if APR_HAS_SENDFILE
-            apr_close(file->file); 
+            apr_file_close(file->file); 
 #endif
 	    ++file;
 	    --n;
@@ -212,7 +212,7 @@ static const char *cachefile(cmd_parms *cmd, void *dummy, const char *filename)
 	return NULL;
     }
 
-    rc = apr_open(&fd, filename, APR_READ | APR_XTHREAD, APR_OS_DEFAULT, cmd->pool);
+    rc = apr_file_open(&fd, filename, APR_READ | APR_XTHREAD, APR_OS_DEFAULT, cmd->pool);
     if (rc != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
                      "mod_file_cache: unable to open(%s, O_RDONLY), skipping", filename);
@@ -221,11 +221,11 @@ static const char *cachefile(cmd_parms *cmd, void *dummy, const char *filename)
     tmp.file = fd;
     tmp.filename = apr_pstrdup(cmd->pool, filename);
     sconf = ap_get_module_config(cmd->server->module_config, &file_cache_module);
-    new_file = apr_push_array(sconf->files);
+    new_file = apr_array_push(sconf->files);
     *new_file = tmp;
     if (sconf->files->nelts == 1) {
 	/* first one, register the cleanup */
-	apr_register_cleanup(cmd->pool, sconf, cleanup_file_cache, apr_null_cleanup);
+	apr_pool_cleanup_register(cmd->pool, sconf, cleanup_file_cache, apr_pool_cleanup_null);
     }
 
     new_file->is_mmapped = FALSE;
@@ -261,7 +261,7 @@ static const char *mmapfile(cmd_parms *cmd, void *dummy, const char *filename)
 	    "mod_file_cache: %s isn't a regular file, skipping", filename);
 	return NULL;
     }
-    if ((rc = apr_open(&fd, fspec, APR_READ, APR_OS_DEFAULT, 
+    if ((rc = apr_file_open(&fd, fspec, APR_READ, APR_OS_DEFAULT, 
                        cmd->temp_pool)) != APR_SUCCESS) { 
 	ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
                      "mod_file_cache: unable to open %s, skipping", 
@@ -269,19 +269,19 @@ static const char *mmapfile(cmd_parms *cmd, void *dummy, const char *filename)
 	return NULL;
     }
     if ((rc = apr_mmap_create(&tmp.mm, fd, 0, tmp.finfo.size, APR_MMAP_READ, cmd->pool)) != APR_SUCCESS) { 
-	apr_close(fd);
+	apr_file_close(fd);
 	ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
 	    "mod_file_cache: unable to mmap %s, skipping", filename);
 	return NULL;
     }
-    apr_close(fd);
+    apr_file_close(fd);
     tmp.filename = fspec;
     sconf = ap_get_module_config(cmd->server->module_config, &file_cache_module);
-    new_file = apr_push_array(sconf->files);
+    new_file = apr_array_push(sconf->files);
     *new_file = tmp;
     if (sconf->files->nelts == 1) {
 	/* first one, register the cleanup */
-       apr_register_cleanup(cmd->pool, sconf, cleanup_file_cache, apr_null_cleanup); 
+       apr_pool_cleanup_register(cmd->pool, sconf, cleanup_file_cache, apr_pool_cleanup_null); 
     }
 
     new_file->is_mmapped = TRUE;
diff --git a/modules/dav/fs/dbm.c b/modules/dav/fs/dbm.c
index dff582c..7bf7070 100644
--- a/modules/dav/fs/dbm.c
+++ b/modules/dav/fs/dbm.c
@@ -128,7 +128,7 @@ void dav_fs_ensure_state_dir(apr_pool_t * p, const char *dirname)
     /* ### do we need to deal with the umask? */
 
     /* just try to make it, ignoring any resulting errors */
-    (void) apr_make_dir(pathname, APR_OS_DEFAULT, p);
+    (void) apr_dir_make(pathname, APR_OS_DEFAULT, p);
 }
 
 /* dav_dbm_open_direct:  Opens a *dbm database specified by path.
diff --git a/modules/dav/fs/lock.c b/modules/dav/fs/lock.c
index 66b73cf..4ef2f1a 100644
--- a/modules/dav/fs/lock.c
+++ b/modules/dav/fs/lock.c
@@ -258,7 +258,7 @@ static dav_lock *dav_fs_alloc_lock(dav_lockdb *lockdb, dav_datum key,
 
     if (locktoken == NULL) {
 	comb->pub.locktoken = &comb->token;
-        apr_get_uuid(&comb->token.uuid);
+        apr_uuid_get(&comb->token.uuid);
     }
     else {
 	comb->pub.locktoken = locktoken;
@@ -288,7 +288,7 @@ static dav_error * dav_fs_parse_locktoken(
     char_token += 16;
 
     locktoken = apr_pcalloc(p, sizeof(*locktoken));
-    if (apr_parse_uuid(&locktoken->uuid, char_token)) {
+    if (apr_uuid_parse(&locktoken->uuid, char_token)) {
 	return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN,
 			     "The opaquelocktoken has an incorrect format "
 			     "and could not be parsed.");
@@ -309,7 +309,7 @@ static const char *dav_fs_format_locktoken(
 {
     char buf[APR_UUID_FORMATTED_LENGTH + 1];
 
-    apr_format_uuid(buf, &locktoken->uuid);
+    apr_uuid_format(buf, &locktoken->uuid);
     return apr_pstrcat(p, "opaquelocktoken:", buf, NULL);
 }
 
@@ -828,12 +828,12 @@ static dav_error * dav_fs_load_locknull_list(apr_pool_t *p, const char *dirpath,
     /* reset this in case we leave w/o reading into the buffer */
     pbuf->cur_len = 0;
 
-    if (apr_open(&file, pbuf->buf, APR_READ | APR_BINARY, APR_OS_DEFAULT,
+    if (apr_file_open(&file, pbuf->buf, APR_READ | APR_BINARY, APR_OS_DEFAULT,
                 p) != APR_SUCCESS) {
 	return NULL;
     }
 
-    if (apr_getfileinfo(&finfo, APR_FINFO_NORM, file) != APR_SUCCESS) {
+    if (apr_file_info_get(&finfo, APR_FINFO_NORM, file) != APR_SUCCESS) {
 	err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
 			    apr_psprintf(p,
 					"Opened but could not stat file %s",
@@ -843,7 +843,7 @@ static dav_error * dav_fs_load_locknull_list(apr_pool_t *p, const char *dirpath,
 
     dav_set_bufsize(p, pbuf, finfo.size);
     amt = finfo.size;
-    if (apr_read(file, pbuf->buf, &amt) != APR_SUCCESS
+    if (apr_file_read(file, pbuf->buf, &amt) != APR_SUCCESS
         || amt != finfo.size) {
 	err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
 			    apr_psprintf(p,
@@ -856,7 +856,7 @@ static dav_error * dav_fs_load_locknull_list(apr_pool_t *p, const char *dirpath,
     }
 
   loaderror:
-    apr_close(file);
+    apr_file_close(file);
     return err;
 }
 
@@ -884,7 +884,7 @@ static dav_error * dav_fs_save_locknull_list(apr_pool_t *p, const char *dirpath,
 
     if (pbuf->cur_len == 0) {
 	/* delete the file if cur_len == 0 */
-	if (apr_remove_file(pathname, p) != 0) {
+	if (apr_file_remove(pathname, p) != 0) {
 	    return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
 				 apr_psprintf(p,
 					     "Error removing %s", pathname));
@@ -892,7 +892,7 @@ static dav_error * dav_fs_save_locknull_list(apr_pool_t *p, const char *dirpath,
 	return NULL;
     }
 
-    if (apr_open(&file, pathname,
+    if (apr_file_open(&file, pathname,
                 APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
                 APR_OS_DEFAULT, p) != APR_SUCCESS) {
 	return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -902,7 +902,7 @@ static dav_error * dav_fs_save_locknull_list(apr_pool_t *p, const char *dirpath,
     }
 
     amt = pbuf->cur_len;
-    if (apr_write(file, pbuf->buf, &amt) != APR_SUCCESS
+    if (apr_file_write(file, pbuf->buf, &amt) != APR_SUCCESS
         || amt != pbuf->cur_len) {
 	err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
 			    apr_psprintf(p,
@@ -910,7 +910,7 @@ static dav_error * dav_fs_save_locknull_list(apr_pool_t *p, const char *dirpath,
 					pbuf->cur_len, pathname));
     }
 
-    apr_close(file);
+    apr_file_close(file);
     return err;
 }
 
diff --git a/modules/dav/fs/repos.c b/modules/dav/fs/repos.c
index 5ee6e40..5266e23 100644
--- a/modules/dav/fs/repos.c
+++ b/modules/dav/fs/repos.c
@@ -306,7 +306,7 @@ static dav_error * dav_fs_copymove_file(
 
     dav_set_bufsize(p, pbuf, DAV_FS_COPY_BLOCKSIZE);
 
-    if ((apr_open(&inf, src, APR_READ | APR_BINARY, APR_OS_DEFAULT, p)) 
+    if ((apr_file_open(&inf, src, APR_READ | APR_BINARY, APR_OS_DEFAULT, p)) 
 	!= APR_SUCCESS) {
 	/* ### use something besides 500? */
 	return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -314,9 +314,9 @@ static dav_error * dav_fs_copymove_file(
     }
 
     /* ### do we need to deal with the umask? */
-    if ((apr_open(&outf, dst, APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
+    if ((apr_file_open(&outf, dst, APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
 		 APR_OS_DEFAULT, p)) != APR_SUCCESS) {
-	apr_close(inf);
+	apr_file_close(inf);
 
 	/* ### use something besides 500? */
 	return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -327,12 +327,12 @@ static dav_error * dav_fs_copymove_file(
 	apr_ssize_t len = DAV_FS_COPY_BLOCKSIZE;
 	apr_status_t status;
 
-	status = apr_read(inf, pbuf->buf, &len);
+	status = apr_file_read(inf, pbuf->buf, &len);
 	if (status != APR_SUCCESS && status != APR_EOF) {
-	    apr_close(inf);
-	    apr_close(outf);
+	    apr_file_close(inf);
+	    apr_file_close(outf);
 	    
-	    if (apr_remove_file(dst, p) != APR_SUCCESS) {
+	    if (apr_file_remove(dst, p) != APR_SUCCESS) {
 		/* ### ACK! Inconsistent state... */
 
 		/* ### use something besides 500? */
@@ -348,13 +348,13 @@ static dav_error * dav_fs_copymove_file(
 	}
 
         /* write any bytes that were read (applies to APR_EOF, too) */
-        if (apr_full_write(outf, pbuf->buf, len, NULL) != APR_SUCCESS) {
+        if (apr_file_write_full(outf, pbuf->buf, len, NULL) != APR_SUCCESS) {
             int save_errno = errno;
 
-	    apr_close(inf);
-	    apr_close(outf);
+	    apr_file_close(inf);
+	    apr_file_close(outf);
 
-	    if (apr_remove_file(dst, p) != 0) {
+	    if (apr_file_remove(dst, p) != 0) {
 		/* ### ACK! Inconsistent state... */
 
 		/* ### use something besides 500? */
@@ -379,8 +379,8 @@ static dav_error * dav_fs_copymove_file(
             break;
     }
 
-    apr_close(inf);
-    apr_close(outf);
+    apr_file_close(inf);
+    apr_file_close(outf);
 
     if (is_move && remove(src) != 0) {
 	dav_error *err;
@@ -437,7 +437,7 @@ static dav_error * dav_fs_copymove_state(
     /* ### do we need to deal with the umask? */
 
     /* ensure that it exists */
-    rv = apr_make_dir(dst, APR_OS_DEFAULT, p);
+    rv = apr_dir_make(dst, APR_OS_DEFAULT, p);
     if (rv != APR_SUCCESS) {
 	if (!APR_STATUS_IS_EEXIST(rv)) {
 	    /* ### use something besides 500? */
@@ -468,7 +468,7 @@ static dav_error * dav_fs_copymove_state(
     /* copy/move the file now */
     if (is_move && src_finfo.device == dst_state_finfo.device) {
 	/* simple rename is possible since it is on the same device */
-	if (apr_rename_file(src, dst, p) != APR_SUCCESS) {
+	if (apr_file_rename(src, dst, p) != APR_SUCCESS) {
 	    /* ### use something besides 500? */
 	    return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
 				 "Could not move state file.");
@@ -817,7 +817,7 @@ static dav_error * dav_fs_open_stream(const dav_resource *resource,
 
     ds->p = p;
     ds->pathname = resource->info->pathname;
-    if (apr_open(&ds->f, ds->pathname, flags, APR_OS_DEFAULT, 
+    if (apr_file_open(&ds->f, ds->pathname, flags, APR_OS_DEFAULT, 
 		ds->p) != APR_SUCCESS) {
 	/* ### use something besides 500? */
 	return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -832,10 +832,10 @@ static dav_error * dav_fs_open_stream(const dav_resource *resource,
 
 static dav_error * dav_fs_close_stream(dav_stream *stream, int commit)
 {
-    apr_close(stream->f);
+    apr_file_close(stream->f);
 
     if (!commit) {
-	if (apr_remove_file(stream->pathname, stream->p) != 0) {
+	if (apr_file_remove(stream->pathname, stream->p) != 0) {
 	    /* ### use a better description? */
             return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
 				 "There was a problem removing (rolling "
@@ -850,7 +850,7 @@ static dav_error * dav_fs_close_stream(dav_stream *stream, int commit)
 static dav_error * dav_fs_read_stream(dav_stream *stream,
 				      void *buf, apr_size_t *bufsize)
 {
-    if (apr_read(stream->f, buf, (apr_ssize_t *)bufsize) != APR_SUCCESS) {
+    if (apr_file_read(stream->f, buf, (apr_ssize_t *)bufsize) != APR_SUCCESS) {
 	/* ### use something besides 500? */
 	return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
 			     "An error occurred while reading from a "
@@ -864,7 +864,7 @@ static dav_error * dav_fs_write_stream(dav_stream *stream,
 {
     apr_status_t status;
 
-    status = apr_full_write(stream->f, buf, bufsize, NULL);
+    status = apr_file_write_full(stream->f, buf, bufsize, NULL);
     if (status == APR_ENOSPC) {
         return dav_new_error(stream->p, HTTP_INSUFFICIENT_STORAGE, 0,
                              "There is not enough storage to write to "
@@ -881,8 +881,8 @@ static dav_error * dav_fs_write_stream(dav_stream *stream,
 
 static dav_error * dav_fs_seek_stream(dav_stream *stream, apr_off_t abs_pos)
 {
-    if (apr_seek(stream->f, APR_SET, &abs_pos) != APR_SUCCESS) {
-	/* ### should check whether apr_seek set abs_pos was set to the
+    if (apr_file_seek(stream->f, APR_SET, &abs_pos) != APR_SUCCESS) {
+	/* ### should check whether apr_file_seek set abs_pos was set to the
 	 * correct position? */
 	/* ### use something besides 500? */
 	return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -940,7 +940,7 @@ static dav_error * dav_fs_create_collection(dav_resource *resource)
     dav_resource_private *ctx = resource->info;
     apr_status_t status;
 
-    status = apr_make_dir(ctx->pathname, APR_OS_DEFAULT, ctx->pool);
+    status = apr_dir_make(ctx->pathname, APR_OS_DEFAULT, ctx->pool);
     if (status == ENOSPC) {
         return dav_new_error(ctx->pool, HTTP_INSUFFICIENT_STORAGE, 0,
 			     "There is not enough storage to create "
@@ -977,7 +977,7 @@ static dav_error * dav_fs_copymove_walker(dav_walk_resource *wres,
 	}
         else {
 	    /* copy/move of a collection. Create the new, target collection */
-            if (apr_make_dir(dstinfo->pathname, APR_OS_DEFAULT,
+            if (apr_dir_make(dstinfo->pathname, APR_OS_DEFAULT,
                              ctx->pool) != APR_SUCCESS) {
 		/* ### assume it was a permissions problem */
 		/* ### need a description here */
@@ -1174,7 +1174,7 @@ static dav_error * dav_fs_move_resource(
     *response = NULL;
 
     /* ### APR has no rename? */
-    if (apr_rename_file(srcinfo->pathname, dstinfo->pathname,
+    if (apr_file_rename(srcinfo->pathname, dstinfo->pathname,
                        srcinfo->pool) != APR_SUCCESS) {
 	/* ### should have a better error than this. */
 	return dav_new_error(srcinfo->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -1194,7 +1194,7 @@ static dav_error * dav_fs_move_resource(
     }
 
     /* error occurred during properties move; try to put resource back */
-    if (apr_rename_file(dstinfo->pathname, srcinfo->pathname,
+    if (apr_file_rename(dstinfo->pathname, srcinfo->pathname,
                        srcinfo->pool) != APR_SUCCESS) {
 	/* couldn't put it back! */
 	return dav_push_error(srcinfo->pool,
@@ -1937,7 +1937,7 @@ static dav_error *dav_fs_patch_exec(const dav_resource *resource,
     if (value)
 	perms |= APR_UEXECUTE;
 
-    if (apr_setfileperms(resource->info->pathname, perms) != APR_SUCCESS) {
+    if (apr_file_perms_set(resource->info->pathname, perms) != APR_SUCCESS) {
 	return dav_new_error(resource->info->pool,
 			     HTTP_INTERNAL_SERVER_ERROR, 0,
 			     "Could not set the executable flag of the "
@@ -1973,7 +1973,7 @@ static dav_error *dav_fs_patch_rollback(const dav_resource *resource,
     if (value)
 	perms |= APR_UEXECUTE;
 
-    if (apr_setfileperms(resource->info->pathname, perms) != APR_SUCCESS) {
+    if (apr_file_perms_set(resource->info->pathname, perms) != APR_SUCCESS) {
 	return dav_new_error(resource->info->pool,
 			     HTTP_INTERNAL_SERVER_ERROR, 0,
 			     "After a failure occurred, the resource's "
@@ -2010,7 +2010,7 @@ static const dav_provider dav_fs_provider =
 void dav_fs_gather_propsets(apr_array_header_t *uris)
 {
 #ifndef WIN32
-    *(const char **)apr_push_array(uris) =
+    *(const char **)apr_array_push(uris) =
         "<http://apache.org/dav/propset/fs/1>";
 #endif
 }
diff --git a/modules/dav/main/liveprop.c b/modules/dav/main/liveprop.c
index 120626b..5d30e88 100644
--- a/modules/dav/main/liveprop.c
+++ b/modules/dav/main/liveprop.c
@@ -76,8 +76,8 @@ static void dav_register_liveprop_namespace(apr_pool_t *p, const char *uri)
     int value;
 
     if (dav_liveprop_uris == NULL) {
-        dav_liveprop_uris = apr_make_hash(p);
-        apr_register_cleanup(p, NULL, dav_cleanup_liveprops, apr_null_cleanup);
+        dav_liveprop_uris = apr_hash_make(p);
+        apr_pool_cleanup_register(p, NULL, dav_cleanup_liveprops, apr_pool_cleanup_null);
     }
 
     value = (int)apr_hash_get(dav_liveprop_uris, uri, APR_HASH_KEY_STRING);
diff --git a/modules/dav/main/mod_dav.c b/modules/dav/main/mod_dav.c
index df4b893..0c3168f 100644
--- a/modules/dav/main/mod_dav.c
+++ b/modules/dav/main/mod_dav.c
@@ -180,7 +180,7 @@ static void *dav_create_dir_config(apr_pool_t *p, char *dir)
         conf->dir = d;
     }
 
-    conf->d_params = apr_make_table(p, 1);
+    conf->d_params = apr_table_make(p, 1);
 
     return conf;
 }
@@ -215,8 +215,8 @@ static void *dav_merge_dir_config(apr_pool_t *p, void *base, void *overrides)
     newconf->allow_depthinfinity = DAV_INHERIT_VALUE(parent, child,
                                                      allow_depthinfinity);
 
-    newconf->d_params = apr_copy_table(p, parent->d_params);
-    apr_overlap_tables(newconf->d_params, child->d_params,
+    newconf->d_params = apr_table_copy(p, parent->d_params);
+    apr_table_overlap(newconf->d_params, child->d_params,
 		      APR_OVERLAP_TABLES_SET);
 
     return newconf;
@@ -1517,7 +1517,7 @@ static int dav_method_options(request_rec *r)
     char *s;
     apr_array_header_t *arr;
     apr_table_entry_t *elts;
-    apr_table_t *methods = apr_make_table(r->pool, 12);
+    apr_table_t *methods = apr_table_make(r->pool, 12);
     ap_text_header vsn_options = { 0 };
     ap_text_header body = { 0 };
     ap_text *t;
@@ -1581,7 +1581,7 @@ static int dav_method_options(request_rec *r)
     ** and generate a separate DAV header for each URI, to avoid
     ** problems with long header lengths.
     */
-    uri_ary = apr_make_array(r->pool, 5, sizeof(const char *));
+    uri_ary = apr_array_make(r->pool, 5, sizeof(const char *));
     dav_run_gather_propsets(uri_ary);
     for (i = 0; i < uri_ary->nelts; ++i) {
         if (((char **)uri_ary->elts)[i] != NULL)
@@ -2193,7 +2193,7 @@ static int dav_method_proppatch(request_rec *r)
     /* ### validate "live" properties */
 
     /* set up an array to hold property operation contexts */
-    ctx_list = apr_make_array(r->pool, 10, sizeof(dav_prop_ctx));
+    ctx_list = apr_array_make(r->pool, 10, sizeof(dav_prop_ctx));
 
     /* do a first pass to ensure that all "remove" properties exist */
     for (child = doc->root->first_child; child; child = child->next) {
@@ -2222,7 +2222,7 @@ static int dav_method_proppatch(request_rec *r)
 	for (one_prop = prop_group->first_child; one_prop;
 	     one_prop = one_prop->next) {
 
-	    ctx = (dav_prop_ctx *)apr_push_array(ctx_list);
+	    ctx = (dav_prop_ctx *)apr_array_push(ctx_list);
 	    ctx->propdb = propdb;
 	    ctx->operation = is_remove ? DAV_PROP_OP_DELETE : DAV_PROP_OP_SET;
 	    ctx->prop = one_prop;
@@ -3335,7 +3335,7 @@ static int dav_method_checkout(request_rec *r)
 
                         href = dav_xml_get_cdata(child, r->pool,
                                                  1 /* strip_white */);
-                        *(const char **)apr_push_array(activities) = href;
+                        *(const char **)apr_array_push(activities) = href;
                     }
                 }
 
diff --git a/modules/dav/main/providers.c b/modules/dav/main/providers.c
index e5071c9..3ac6401 100644
--- a/modules/dav/main/providers.c
+++ b/modules/dav/main/providers.c
@@ -70,8 +70,8 @@ DAV_DECLARE(void) dav_register_provider(apr_pool_t *p, const char *name,
                                         const dav_provider *provider)
 {
     if (dav_repos_providers == NULL) {
-        dav_repos_providers = apr_make_hash(p);
-        apr_register_cleanup(p, NULL, dav_cleanup_providers, apr_null_cleanup);
+        dav_repos_providers = apr_hash_make(p);
+        apr_pool_cleanup_register(p, NULL, dav_cleanup_providers, apr_pool_cleanup_null);
     }
 
     /* just set it. no biggy if it was there before. */
diff --git a/modules/dav/main/util.c b/modules/dav/main/util.c
index 041355c..8e9572e 100644
--- a/modules/dav/main/util.c
+++ b/modules/dav/main/util.c
@@ -215,7 +215,7 @@ dav_lookup_result dav_lookup_uri(const char *uri, request_rec * r)
        the port, must match our port.
        the URI must not have a query (args) or a fragment
      */
-    apr_get_port(&port, r->connection->local_addr);
+    apr_sockaddr_port_get(&port, r->connection->local_addr);
     if (strcasecmp(comp.scheme, scheme) != 0 ||
 	comp.port != port) {
 	result.err.status = HTTP_BAD_GATEWAY;
diff --git a/modules/experimental/mod_case_filter.c b/modules/experimental/mod_case_filter.c
index af0b6c5..7afcefd 100644
--- a/modules/experimental/mod_case_filter.c
+++ b/modules/experimental/mod_case_filter.c
@@ -54,7 +54,7 @@ static apr_status_t CaseFilterOutFilter(ap_filter_t *f,
 	if(APR_BUCKET_IS_EOS(pbktIn))
 	    {
 	    // XXX: why can't I reuse pbktIn???
-	    apr_bucket *pbktEOS=apr_bucket_create_eos();
+	    apr_bucket *pbktEOS=apr_bucket_eos_create();
 	    APR_BRIGADE_INSERT_TAIL(pbbOut,pbktEOS);
 	    break;
 	    }
@@ -69,7 +69,7 @@ static apr_status_t CaseFilterOutFilter(ap_filter_t *f,
 
 	// XXX: should we use a heap bucket instead? Or a transient (in
 	// which case we need a separate brigade for each bucket)?
-	pbktOut=apr_bucket_create_pool(buf,len,f->r->pool);
+	pbktOut=apr_bucket_pool_create(buf,len,f->r->pool);
 	APR_BRIGADE_INSERT_TAIL(pbbOut,pbktOut);
 	}
 
diff --git a/modules/experimental/mod_charset_lite.c b/modules/experimental/mod_charset_lite.c
index 27cb98b..cc4d023 100644
--- a/modules/experimental/mod_charset_lite.c
+++ b/modules/experimental/mod_charset_lite.c
@@ -86,7 +86,7 @@
 #define OUTPUT_XLATE_BUF_SIZE (16*1024) /* size of translation buffer used on output */
 #define INPUT_XLATE_BUF_SIZE  (8*1024)  /* size of translation buffer used on input */
 
-/* XXX this works around an issue with the heap bucket: apr_bucket_create_heap will 
+/* XXX this works around an issue with the heap bucket: apr_bucket_heap_create will 
  *     copy only the first 4096 bytes
  */
 #undef INPUT_XLATE_BUF_SIZE         /* XXX */
@@ -461,7 +461,7 @@ static apr_status_t send_downstream(ap_filter_t *f, const char *tmp, apr_size_t
     apr_status_t rv;
 
     bb = apr_brigade_create(f->r->pool);
-    b = apr_bucket_create_transient(tmp, len);
+    b = apr_bucket_transient_create(tmp, len);
     APR_BRIGADE_INSERT_TAIL(bb, b);
     rv = ap_pass_brigade(f->next, bb);
     if (rv != APR_SUCCESS) {
@@ -478,7 +478,7 @@ static apr_status_t send_eos(ap_filter_t *f)
     apr_status_t rv;
 
     bb = apr_brigade_create(f->r->pool);
-    b = apr_bucket_create_eos();
+    b = apr_bucket_eos_create();
     APR_BRIGADE_INSERT_TAIL(bb, b);
     rv = ap_pass_brigade(f->next, bb);
     if (rv != APR_SUCCESS) {
@@ -1075,7 +1075,7 @@ static int xlate_in_filter(ap_filter_t *f, apr_bucket_brigade *bb,
         if (buffer_size < INPUT_XLATE_BUF_SIZE) { /* do we have output? */
             apr_bucket *e;
 
-            e = apr_bucket_create_heap(ctx->tmp, 
+            e = apr_bucket_heap_create(ctx->tmp, 
                                       INPUT_XLATE_BUF_SIZE - buffer_size, 1, 
                                       NULL);
             /* make sure we insert at the head, because there may be
diff --git a/modules/experimental/mod_disk_cache.c b/modules/experimental/mod_disk_cache.c
index 70a2643..bea4b4a 100644
--- a/modules/experimental/mod_disk_cache.c
+++ b/modules/experimental/mod_disk_cache.c
@@ -78,14 +78,14 @@ static int disk_serve(request_rec *r)
 
     filename = ap_server_root_relative(r->pool, 
                         apr_pstrcat(r->pool, "proxy", r->uri, NULL));
-    if ((rv = apr_open(&fd, filename, APR_READ, 
+    if ((rv = apr_file_open(&fd, filename, APR_READ, 
                  APR_UREAD, r->connection->pool)) != APR_SUCCESS) {
         return DECLINED;
     }
 
     /* skip the cached headers. */
     do {
-        apr_fgets(str, 256, fd);
+        apr_file_gets(str, 256, fd);
         offset += strlen(str);
     } while (strcmp(str, CRLF));
 
@@ -98,10 +98,10 @@ static int disk_serve(request_rec *r)
         }
     }
 
-    e = apr_bucket_create_file(fd, offset, r->finfo.size);
+    e = apr_bucket_file_create(fd, offset, r->finfo.size);
 
     APR_BRIGADE_INSERT_HEAD(bb, e);
-    e = apr_bucket_create_eos();
+    e = apr_bucket_eos_create();
     APR_BRIGADE_INSERT_TAIL(bb, e);
 
     ap_pass_brigade(r->output_filters, bb);
@@ -124,14 +124,14 @@ static int disk_cache(request_rec *r, apr_bucket_brigade *bb, void **cf)
     }
     if (ctx->filename == NULL) {
         apr_status_t rv;
-        apr_make_dir(ap_server_root_relative(r->pool, "proxy"), APR_UREAD | APR_UWRITE | APR_UEXECUTE | APR_GREAD | APR_GWRITE, r->pool);
+        apr_dir_make(ap_server_root_relative(r->pool, "proxy"), APR_UREAD | APR_UWRITE | APR_UEXECUTE | APR_GREAD | APR_GWRITE, r->pool);
 
         /* currently, we are using the uri as the cache key.  This is
          * probably wrong, but it is much better than a hard-coded filename.
          */
         ctx->filename = ap_server_root_relative(r->pool, 
                             apr_pstrcat(r->pool, "proxy", r->uri, NULL));
-        if ((rv = apr_open(&ctx->fd, ctx->filename, 
+        if ((rv = apr_file_open(&ctx->fd, ctx->filename, 
                      APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BUFFERED,
                      APR_UREAD | APR_UWRITE, r->pool)) != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
@@ -145,10 +145,10 @@ static int disk_cache(request_rec *r, apr_bucket_brigade *bb, void **cf)
         apr_ssize_t length;
 
         apr_bucket_read(e, &str, &length, 0);
-        apr_write(ctx->fd, str, &length);
+        apr_file_write(ctx->fd, str, &length);
     }
     if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
-        apr_close(ctx->fd);
+        apr_file_close(ctx->fd);
     }
     return OK;	
 }
diff --git a/modules/experimental/mod_example.c b/modules/experimental/mod_example.c
index 2256d0d..7842026 100644
--- a/modules/experimental/mod_example.c
+++ b/modules/experimental/mod_example.c
@@ -298,14 +298,14 @@ static void setup_module_cells(void)
      * If we haven't already allocated our module-private pool, do so now.
      */
     if (example_pool == NULL) {
-        apr_create_pool(&example_pool, NULL);
+        apr_pool_create(&example_pool, NULL);
     };
     /*
      * Likewise for the apr_table_t of routine/environment pairs we visit outside of
      * request context.
      */
     if (static_calls_made == NULL) {
-        static_calls_made = apr_make_table(example_pool, 16);
+        static_calls_made = apr_table_make(example_pool, 16);
     };
 }
 
@@ -363,7 +363,7 @@ static void trace_add(server_rec *s, request_rec *r, excfg *mconfig,
          * Make a new sub-pool and copy any existing trace to it.  Point the
          * trace cell at the copied value.
          */
-        apr_create_pool(&p, example_pool);
+        apr_pool_create(&p, example_pool);
         if (trace != NULL) {
             trace = apr_pstrdup(p, trace);
         }
@@ -372,7 +372,7 @@ static void trace_add(server_rec *s, request_rec *r, excfg *mconfig,
          * the one we just allocated.
          */
         if (example_subpool != NULL) {
-            apr_destroy_pool(example_subpool);
+            apr_pool_destroy(example_subpool);
         }
         example_subpool = p;
         trace_copy = trace;
@@ -708,7 +708,7 @@ static void example_child_init(apr_pool_t *p, server_rec *s)
     note = apr_pstrcat(p, "example_child_init(", sname, ")", NULL);
     trace_add(s, NULL, NULL, note);
 
-    apr_register_cleanup(p, s, example_child_exit, example_child_exit);
+    apr_pool_cleanup_register(p, s, example_child_exit, example_child_exit);
 }
 
 /*
diff --git a/modules/experimental/mod_ext_filter.c b/modules/experimental/mod_ext_filter.c
index 5982ddf..a8e1b1d 100644
--- a/modules/experimental/mod_ext_filter.c
+++ b/modules/experimental/mod_ext_filter.c
@@ -131,7 +131,7 @@ static void *create_ef_server_conf(apr_pool_t *p, server_rec *s)
 
     conf = (ef_server_t *)apr_pcalloc(p, sizeof(ef_server_t));
     conf->p = p;
-    conf->h = apr_make_hash(conf->p);
+    conf->h = apr_hash_make(conf->p);
     return conf;
 }
 
@@ -351,15 +351,15 @@ static apr_status_t set_resource_limits(request_rec *r,
     apr_status_t rv;
 
 #ifdef RLIMIT_CPU
-    rv = apr_setprocattr_limit(procattr, APR_LIMIT_CPU, conf->limit_cpu);
+    rv = apr_procattr_limit_set(procattr, APR_LIMIT_CPU, conf->limit_cpu);
     ap_assert(rv == APR_SUCCESS); /* otherwise, we're out of sync with APR */
 #endif
 #if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
-    rv = apr_setprocattr_limit(procattr, APR_LIMIT_MEM, conf->limit_mem);
+    rv = apr_procattr_limit_set(procattr, APR_LIMIT_MEM, conf->limit_mem);
     ap_assert(rv == APR_SUCCESS); /* otherwise, we're out of sync with APR */
 #endif
 #ifdef RLIMIT_NPROC
-    rv = apr_setprocattr_limit(procattr, APR_LIMIT_NPROC, conf->limit_nproc);
+    rv = apr_procattr_limit_set(procattr, APR_LIMIT_NPROC, conf->limit_nproc);
     ap_assert(rv == APR_SUCCESS); /* otherwise, we're out of sync with APR */
 #endif
 
@@ -370,7 +370,7 @@ static apr_status_t set_resource_limits(request_rec *r,
 
 static apr_status_t ef_close_file(void *vfile)
 {
-    return apr_close(vfile);
+    return apr_file_close(vfile);
 }
 
 /* init_ext_filter_process: get the external filter process going
@@ -384,10 +384,10 @@ static apr_status_t init_ext_filter_process(ap_filter_t *f)
 
     ctx->proc = apr_pcalloc(ctx->p, sizeof(*ctx->proc));
 
-    rc = apr_createprocattr_init(&ctx->procattr, ctx->p);
+    rc = apr_procattr_create(&ctx->procattr, ctx->p);
     ap_assert(rc == APR_SUCCESS);
 
-    rc = apr_setprocattr_io(ctx->procattr,
+    rc = apr_procattr_io_set(ctx->procattr,
                             APR_CHILD_BLOCK,
                             APR_CHILD_BLOCK,
                             APR_CHILD_BLOCK);
@@ -397,13 +397,13 @@ static apr_status_t init_ext_filter_process(ap_filter_t *f)
     ap_assert(rc == APR_SUCCESS);
 
     if (dc->log_stderr > 0) {
-        rc = apr_setprocattr_childerr(ctx->procattr,
+        rc = apr_procattr_child_err_set(ctx->procattr,
                                       f->r->server->error_log, /* stderr in child */
                                       NULL);
         ap_assert(rc == APR_SUCCESS);
     }
                                   
-    rc = apr_create_process(ctx->proc, 
+    rc = apr_proc_create(ctx->proc, 
                             ctx->filter->command, 
                             (const char * const *)ctx->filter->args, 
                             NULL, /* environment */
@@ -416,7 +416,7 @@ static apr_status_t init_ext_filter_process(ap_filter_t *f)
         return rc;
     }
 
-    apr_note_subprocess(ctx->p, ctx->proc, kill_after_timeout);
+    apr_pool_note_subprocess(ctx->p, ctx->proc, kill_after_timeout);
 
     /* We don't want the handle to the child's stdin inherited by any
      * other processes created by httpd.  Otherwise, when we close our
@@ -424,23 +424,23 @@ static apr_status_t init_ext_filter_process(ap_filter_t *f)
      * be open.
      */
 
-    apr_register_cleanup(ctx->p, ctx->proc->in, 
-                         apr_null_cleanup, /* other mechanism */
+    apr_pool_cleanup_register(ctx->p, ctx->proc->in, 
+                         apr_pool_cleanup_null, /* other mechanism */
                          ef_close_file);
 
 #if APR_FILES_AS_SOCKETS
     {
         apr_socket_t *newsock;
 
-        rc = apr_setup_poll(&ctx->pollset, 2, ctx->p);
+        rc = apr_poll_setup(&ctx->pollset, 2, ctx->p);
         ap_assert(rc == APR_SUCCESS);
         rc = apr_socket_from_file(&newsock, ctx->proc->in);
         ap_assert(rc == APR_SUCCESS);
-        rc = apr_add_poll_socket(ctx->pollset, newsock, APR_POLLOUT);
+        rc = apr_poll_socket_add(ctx->pollset, newsock, APR_POLLOUT);
         ap_assert(rc == APR_SUCCESS);
         rc = apr_socket_from_file(&newsock, ctx->proc->out);
         ap_assert(rc == APR_SUCCESS);
-        rc = apr_add_poll_socket(ctx->pollset, newsock, APR_POLLIN);
+        rc = apr_poll_socket_add(ctx->pollset, newsock, APR_POLLIN);
         ap_assert(rc == APR_SUCCESS);
     }
 #endif
@@ -541,20 +541,20 @@ static apr_status_t drain_available_output(ap_filter_t *f)
 
     while (1) {
         len = sizeof(buf);
-        rv = apr_read(ctx->proc->out,
+        rv = apr_file_read(ctx->proc->out,
                       buf,
                       &len);
         if ((rv && !APR_STATUS_IS_EAGAIN(rv)) ||
             dc->debug >= DBGLVL_GORY) {
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, f->r,
-                          "apr_read(child output), len %" APR_SIZE_T_FMT,
+                          "apr_file_read(child output), len %" APR_SIZE_T_FMT,
                           !rv ? len : -1);
         }
         if (rv != APR_SUCCESS) {
             return rv;
         }
         bb = apr_brigade_create(f->r->pool);
-        b = apr_bucket_create_transient(buf, len);
+        b = apr_bucket_transient_create(buf, len);
         APR_BRIGADE_INSERT_TAIL(bb, b);
         if ((rv = ap_pass_brigade(f->next, bb)) != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
@@ -579,13 +579,13 @@ static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data,
     
     do {
         tmplen = len - bytes_written;
-        rv = apr_write(ctx->proc->in,
+        rv = apr_file_write(ctx->proc->in,
                        (const char *)data + bytes_written,
                        &tmplen);
         bytes_written += tmplen;
         if (rv != APR_SUCCESS && !APR_STATUS_IS_EAGAIN(rv)) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
-                          "apr_write(child input), len %" APR_SIZE_T_FMT,
+                          "apr_file_write(child input), len %" APR_SIZE_T_FMT,
                           tmplen);
             return rv;
         }
@@ -680,32 +680,32 @@ static apr_status_t ef_output_filter(ap_filter_t *f, apr_bucket_brigade *bb)
         /* close the child's stdin to signal that no more data is coming;
          * that will cause the child to finish generating output
          */
-        if ((rv = apr_close(ctx->proc->in)) != APR_SUCCESS) {
+        if ((rv = apr_file_close(ctx->proc->in)) != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
-                          "apr_close(child input)");
+                          "apr_file_close(child input)");
             return rv;
         }
         /* since we've seen eos and closed the child's stdin, set the proper pipe 
-         * timeout; we don't care if we don't return from apr_read() for a while... 
+         * timeout; we don't care if we don't return from apr_file_read() for a while... 
          */
-        rv = apr_set_pipe_timeout(ctx->proc->out, 
+        rv = apr_file_pipe_timeout_set(ctx->proc->out, 
                                   f->r->server->timeout * APR_USEC_PER_SEC);
         if (rv) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
-                          "apr_set_pipe_timeout(child output)");
+                          "apr_file_pipe_timeout_set(child output)");
             return rv;
         }
     }
 
     do {
         len = sizeof(buf);
-        rv = apr_read(ctx->proc->out,
+        rv = apr_file_read(ctx->proc->out,
                       buf,
                       &len);
         if ((rv && !APR_STATUS_IS_EOF(rv) && !APR_STATUS_IS_EAGAIN(rv)) ||
             dc->debug >= DBGLVL_GORY) {
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rv, f->r,
-                          "apr_read(child output), len %" APR_SIZE_T_FMT,
+                          "apr_file_read(child output), len %" APR_SIZE_T_FMT,
                           !rv ? len : -1);
         }
         if (APR_STATUS_IS_EAGAIN(rv)) {
@@ -718,7 +718,7 @@ static apr_status_t ef_output_filter(ap_filter_t *f, apr_bucket_brigade *bb)
         
         if (rv == APR_SUCCESS) {
             bb = apr_brigade_create(f->r->pool);
-            b = apr_bucket_create_transient(buf, len);
+            b = apr_bucket_transient_create(buf, len);
             APR_BRIGADE_INSERT_TAIL(bb, b);
             if ((rv = ap_pass_brigade(f->next, bb)) != APR_SUCCESS) {
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
@@ -735,7 +735,7 @@ static apr_status_t ef_output_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     if (eos) {
         /* pass down eos */
         bb = apr_brigade_create(f->r->pool);
-        b = apr_bucket_create_eos();
+        b = apr_bucket_eos_create();
         APR_BRIGADE_INSERT_TAIL(bb, b);
         if ((rv = ap_pass_brigade(f->next, bb)) != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
diff --git a/modules/filters/mod_include.c b/modules/filters/mod_include.c
index f74bb29..09acb6d 100644
--- a/modules/filters/mod_include.c
+++ b/modules/filters/mod_include.c
@@ -884,10 +884,10 @@ static int handle_echo(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec
             	}
 
                     e_len = strlen(echo_text);
-                    tmp_buck = apr_bucket_create_heap(echo_text, e_len, 1, &e_wrt);
+                    tmp_buck = apr_bucket_heap_create(echo_text, e_len, 1, &e_wrt);
                 }
                 else {
-                    tmp_buck = apr_bucket_create_immortal("(none)", sizeof("none"));
+                    tmp_buck = apr_bucket_immortal_create("(none)", sizeof("none"));
                 }
                 APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                 if (*inserted_head == NULL) {
@@ -1126,7 +1126,7 @@ static int handle_fsize(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec
                         s_len = pos;
                     }
 
-                    tmp_buck = apr_bucket_create_heap(buff, s_len, 1, &s_wrt);
+                    tmp_buck = apr_bucket_heap_create(buff, s_len, 1, &s_wrt);
                     APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                     if (*inserted_head == NULL) {
                         *inserted_head = tmp_buck;
@@ -1171,7 +1171,7 @@ static int handle_flastmod(include_ctx_t *ctx, apr_bucket_brigade **bb, request_
                     t_val = ap_ht_time(r->pool, finfo.mtime, ctx->time_str, 0);
                     t_len = strlen(t_val);
 
-                    tmp_buck = apr_bucket_create_heap(t_val, t_len, 1, &t_wrt);
+                    tmp_buck = apr_bucket_heap_create(t_val, t_len, 1, &t_wrt);
                     APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                     if (*inserted_head == NULL) {
                         *inserted_head = tmp_buck;
@@ -1403,7 +1403,7 @@ static int parse_expr(request_rec *r, const char *expr, int *was_error,
         return (0);
     }
     root = current = (struct parse_node *) NULL;
-    if (apr_create_pool(&expr_pool, r->pool) != APR_SUCCESS)
+    if (apr_pool_create(&expr_pool, r->pool) != APR_SUCCESS)
 		return 0;
 
     /* Create Parse Tree */
@@ -1968,7 +1968,7 @@ static int parse_expr(request_rec *r, const char *expr, int *was_error,
 
     retval = (root == (struct parse_node *) NULL) ? 0 : root->value;
   RETURN:
-    apr_destroy_pool(expr_pool);
+    apr_pool_destroy(expr_pool);
     return (retval);
 }
 
@@ -1987,7 +1987,7 @@ static int parse_expr(request_rec *r, const char *expr, int *was_error,
         cond_txt[31] = '1';                                                \
     }                                                                      \
     memcpy(&cond_txt[5], tag_text, sizeof(tag_text));                      \
-    t_buck = apr_bucket_create_heap(cond_txt, sizeof(cond_txt), 1, &c_wrt); \
+    t_buck = apr_bucket_heap_create(cond_txt, sizeof(cond_txt), 1, &c_wrt); \
     APR_BUCKET_INSERT_BEFORE(h_ptr, t_buck);                                \
                                                                            \
     if (ins_head == NULL) {                                                \
@@ -1998,7 +1998,7 @@ static int parse_expr(request_rec *r, const char *expr, int *was_error,
 {                                                                        \
     apr_size_t b_wrt;                                                    \
     if (d_buf[0] != '\0') {                                              \
-        t_buck = apr_bucket_create_heap(d_buf, strlen(d_buf), 1, &b_wrt); \
+        t_buck = apr_bucket_heap_create(d_buf, strlen(d_buf), 1, &b_wrt); \
         APR_BUCKET_INSERT_BEFORE(h_ptr, t_buck);                          \
                                                                          \
         if (ins_head == NULL) {                                          \
@@ -2067,7 +2067,7 @@ static int handle_if(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec *r
                 if (1) {
                     apr_size_t d_len = 0, d_wrt = 0;
                     d_len = sprintf(debug_buf, "**** if expr=\"%s\"\n", expr);
-                    tmp_buck = apr_bucket_create_heap(debug_buf, d_len, 1, &d_wrt);
+                    tmp_buck = apr_bucket_heap_create(debug_buf, d_len, 1, &d_wrt);
                     APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
 
                     if (*inserted_head == NULL) {
@@ -2140,7 +2140,7 @@ static int handle_elif(include_ctx_t *ctx, apr_bucket_brigade **bb, request_rec
                 if (1) {
                     apr_size_t d_len = 0, d_wrt = 0;
                     d_len = sprintf(debug_buf, "**** elif expr=\"%s\"\n", expr);
-                    tmp_buck = apr_bucket_create_heap(debug_buf, d_len, 1, &d_wrt);
+                    tmp_buck = apr_bucket_heap_create(debug_buf, d_len, 1, &d_wrt);
                     APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
 
                     if (*inserted_head == NULL) {
@@ -2289,19 +2289,19 @@ static int handle_printenv(include_ctx_t *ctx, apr_bucket_brigade **bb, request_
                 v_len = strlen(val_text);
 
                 /*  Key_text                                               */
-                tmp_buck = apr_bucket_create_heap(key_text, k_len, 1, &t_wrt);
+                tmp_buck = apr_bucket_heap_create(key_text, k_len, 1, &t_wrt);
                 APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                 if (*inserted_head == NULL) {
                     *inserted_head = tmp_buck;
                 }
                 /*            =                                            */
-                tmp_buck = apr_bucket_create_immortal("=", 1);
+                tmp_buck = apr_bucket_immortal_create("=", 1);
                 APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                 /*              Value_text                                 */
-                tmp_buck = apr_bucket_create_heap(val_text, v_len, 1, &t_wrt);
+                tmp_buck = apr_bucket_heap_create(val_text, v_len, 1, &t_wrt);
                 APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
                 /*                        newline...                       */
-                tmp_buck = apr_bucket_create_immortal("\n", 1);
+                tmp_buck = apr_bucket_immortal_create("\n", 1);
                 APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
             }
             return 0;
@@ -2352,7 +2352,7 @@ static void send_parsed_content(apr_bucket_brigade **bb, request_rec *r,
             if ((do_cleanup) && (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade))) {
                 apr_bucket *tmp_bkt;
 
-                tmp_bkt = apr_bucket_create_immortal(STARTING_SEQUENCE, cleanup_bytes);
+                tmp_bkt = apr_bucket_immortal_create(STARTING_SEQUENCE, cleanup_bytes);
                 APR_BRIGADE_INSERT_HEAD(*bb, tmp_bkt);
 
                 while (!APR_BRIGADE_EMPTY(ctx->ssi_tag_brigade)) {
@@ -2749,7 +2749,7 @@ static void ap_register_include_handler(char *tag, include_handler func)
 static void include_post_config(apr_pool_t *p, apr_pool_t *plog,
                                 apr_pool_t *ptemp, server_rec *s)
 {
-    include_hash = apr_make_hash(p);
+    include_hash = apr_hash_make(p);
 
     ssi_pfn_register = APR_RETRIEVE_OPTIONAL_FN(ap_register_include_handler);
 
diff --git a/modules/filters/mod_include.h b/modules/filters/mod_include.h
index 89d2c51..6712516 100644
--- a/modules/filters/mod_include.h
+++ b/modules/filters/mod_include.h
@@ -173,7 +173,7 @@ typedef struct include_filter_ctx {
 #define CREATE_ERROR_BUCKET(cntx, t_buck, h_ptr, ins_head)        \
 {                                                                 \
     apr_size_t e_wrt;                                             \
-    t_buck = apr_bucket_create_heap(cntx->error_str,              \
+    t_buck = apr_bucket_heap_create(cntx->error_str,              \
                                    ctx->error_length, 1, &e_wrt); \
     APR_BUCKET_INSERT_BEFORE(h_ptr, t_buck);                      \
                                                                   \
diff --git a/modules/generators/mod_asis.c b/modules/generators/mod_asis.c
index 858bd20..0347b14 100644
--- a/modules/generators/mod_asis.c
+++ b/modules/generators/mod_asis.c
@@ -87,7 +87,7 @@ static int asis_handler(request_rec *r)
 	return HTTP_NOT_FOUND;
     }
 
-    if ((status = apr_open(&f, r->filename, APR_READ, 
+    if ((status = apr_file_open(&f, r->filename, APR_READ, 
                 APR_OS_DEFAULT, r->pool)) != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
 		    "file permissions deny server access: %s", r->filename);
@@ -100,7 +100,7 @@ static int asis_handler(request_rec *r)
     if (location && location[0] == '/' &&
 	((r->status == HTTP_OK) || ap_is_HTTP_REDIRECT(r->status))) {
 
-	apr_close(f);
+	apr_file_close(f);
 
 	/* Internal redirect -- fake-up a pseudo-request */
 	r->status = HTTP_OK;
@@ -120,7 +120,7 @@ static int asis_handler(request_rec *r)
 	ap_send_fd(f, r, 0, r->finfo.size, &nbytes);
     }
 
-    apr_close(f);
+    apr_file_close(f);
     return OK;
 }
 
diff --git a/modules/generators/mod_autoindex.c b/modules/generators/mod_autoindex.c
index ce5c6c2..dd8ef9e 100644
--- a/modules/generators/mod_autoindex.c
+++ b/modules/generators/mod_autoindex.c
@@ -212,7 +212,7 @@ static void emit_preamble(request_rec *r, char *title)
 static void push_item(apr_array_header_t *arr, char *type, const char *to,
 		      const char *path, const char *data)
 {
-    struct item *p = (struct item *) apr_push_array(arr);
+    struct item *p = (struct item *) apr_array_push(arr);
 
     if (!to) {
 	to = "";
@@ -316,7 +316,7 @@ static const char *add_desc(cmd_parms *cmd, void *d, const char *desc,
     ai_desc_t *desc_entry;
     char *prefix = "";
 
-    desc_entry = (ai_desc_t *) apr_push_array(dcfg->desc_list);
+    desc_entry = (ai_desc_t *) apr_array_push(dcfg->desc_list);
     desc_entry->full_path = (ap_strchr_c(to, '/') == NULL) ? 0 : 1;
     desc_entry->wildcards = (WILDCARDS_REQUIRED
 			     || desc_entry->full_path
@@ -596,12 +596,12 @@ static void *create_autoindex_config(apr_pool_t *p, char *dummy)
     new->icon_height = 0;
     new->name_width = DEFAULT_NAME_WIDTH;
     new->name_adjust = K_UNSET;
-    new->icon_list = apr_make_array(p, 4, sizeof(struct item));
-    new->alt_list = apr_make_array(p, 4, sizeof(struct item));
-    new->desc_list = apr_make_array(p, 4, sizeof(ai_desc_t));
-    new->ign_list = apr_make_array(p, 4, sizeof(struct item));
-    new->hdr_list = apr_make_array(p, 4, sizeof(struct item));
-    new->rdme_list = apr_make_array(p, 4, sizeof(struct item));
+    new->icon_list = apr_array_make(p, 4, sizeof(struct item));
+    new->alt_list = apr_array_make(p, 4, sizeof(struct item));
+    new->desc_list = apr_array_make(p, 4, sizeof(ai_desc_t));
+    new->ign_list = apr_array_make(p, 4, sizeof(struct item));
+    new->hdr_list = apr_array_make(p, 4, sizeof(struct item));
+    new->rdme_list = apr_array_make(p, 4, sizeof(struct item));
     new->opts = 0;
     new->incremented_opts = 0;
     new->decremented_opts = 0;
@@ -622,12 +622,12 @@ static void *merge_autoindex_configs(apr_pool_t *p, void *basev, void *addv)
     new->icon_height = add->icon_height ? add->icon_height : base->icon_height;
     new->icon_width = add->icon_width ? add->icon_width : base->icon_width;
 
-    new->alt_list = apr_append_arrays(p, add->alt_list, base->alt_list);
-    new->ign_list = apr_append_arrays(p, add->ign_list, base->ign_list);
-    new->hdr_list = apr_append_arrays(p, add->hdr_list, base->hdr_list);
-    new->desc_list = apr_append_arrays(p, add->desc_list, base->desc_list);
-    new->icon_list = apr_append_arrays(p, add->icon_list, base->icon_list);
-    new->rdme_list = apr_append_arrays(p, add->rdme_list, base->rdme_list);
+    new->alt_list = apr_array_append(p, add->alt_list, base->alt_list);
+    new->ign_list = apr_array_append(p, add->ign_list, base->ign_list);
+    new->hdr_list = apr_array_append(p, add->hdr_list, base->hdr_list);
+    new->desc_list = apr_array_append(p, add->desc_list, base->desc_list);
+    new->icon_list = apr_array_append(p, add->icon_list, base->icon_list);
+    new->rdme_list = apr_array_append(p, add->rdme_list, base->rdme_list);
     if (add->opts & NO_OPTIONS) {
 	/*
 	 * If the current directory says 'no options' then we also
@@ -916,10 +916,10 @@ static void do_emit_plain(request_rec *r, apr_file_t *f)
     apr_status_t stat;
 
     ap_rputs("<PRE>\n", r);
-    while (!apr_eof(f)) {
+    while (!apr_file_eof(f)) {
 	do {
             n = sizeof(char) * IOBUFSIZE;
-	    stat = apr_read(f, buf, &n);
+	    stat = apr_file_read(f, buf, &n);
 	}
 	while (stat != APR_SUCCESS && APR_STATUS_IS_EINTR(stat));
 	if (n == -1 || n == 0) {
@@ -1011,12 +1011,12 @@ static void emit_head(request_rec *r, char *header_fname, int suppress_amble,
 		 * the file's contents, any HTML header it had won't end up
 		 * where it belongs.
 		 */
-		if (apr_open(&f, rr->filename, APR_READ,
+		if (apr_file_open(&f, rr->filename, APR_READ,
                             APR_OS_DEFAULT, r->pool) == APR_SUCCESS) {
 		    emit_preamble(r, title);
 		    emit_amble = 0;
 		    do_emit_plain(r, f);
-		    apr_close(f);
+		    apr_file_close(f);
 		    emit_H1 = 0;
 		}
 	    }
@@ -1079,10 +1079,10 @@ static void emit_tail(request_rec *r, char *readme_fname, int suppress_amble)
 		/*
 		 * If we can open the file, suppress the signature.
 		 */
-		if (apr_open(&f, rr->filename, APR_READ,
+		if (apr_file_open(&f, rr->filename, APR_READ,
                             APR_OS_DEFAULT, r->pool) == APR_SUCCESS) {
 		    do_emit_plain(r, f);
-		    apr_close(f);
+		    apr_file_close(f);
 		    suppress_sig = 1;
 		}
 	    }
@@ -1116,14 +1116,14 @@ static char *find_title(request_rec *r)
 			"text/html")
 	    || !strcmp(r->content_type, INCLUDES_MAGIC_TYPE))
 	&& !r->content_encoding) {
-        if (apr_open(&thefile, r->filename, APR_READ,
+        if (apr_file_open(&thefile, r->filename, APR_READ,
                     APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
 	    return NULL;
 	}
         n = sizeof(char) * (MAX_STRING_LEN - 1);
-	apr_read(thefile, titlebuf, &n);
+	apr_file_read(thefile, titlebuf, &n);
 	if (n <= 0) {
-	    apr_close(thefile);
+	    apr_file_close(thefile);
 	    return NULL;
 	}
 	titlebuf[n] = '\0';
@@ -1144,7 +1144,7 @@ static char *find_title(request_rec *r)
 			    }
 			}
 		    }
-		    apr_close(thefile);
+		    apr_file_close(thefile);
 		    return apr_pstrdup(r->pool, &titlebuf[x]);
 		}
 	    }
@@ -1152,7 +1152,7 @@ static char *find_title(request_rec *r)
 		p = 0;
 	    }
 	}
-	apr_close(thefile);
+	apr_file_close(thefile);
     }
     return NULL;
 }
@@ -1308,7 +1308,7 @@ static void output_directories(struct ent **ar, int n,
     char *name_scratch;
     char *pad_scratch;
 
-    apr_create_pool(&scratch, r->pool);
+    apr_pool_create(&scratch, r->pool);
     if (name[0] == '\0') {
 	name = "/";
     }
diff --git a/modules/generators/mod_cgi.c b/modules/generators/mod_cgi.c
index 7cea508..f817855 100644
--- a/modules/generators/mod_cgi.c
+++ b/modules/generators/mod_cgi.c
@@ -216,22 +216,22 @@ static int log_scripterror(request_rec *r, cgi_server_conf * conf, int ret,
         ((apr_stat(&finfo, ap_server_root_relative(r->pool, conf->logname),
                    APR_FINFO_SIZE, r->pool) == APR_SUCCESS)
          &&  (finfo.size > conf->logbytes)) ||
-          (apr_open(&f, ap_server_root_relative(r->pool, conf->logname),
+          (apr_file_open(&f, ap_server_root_relative(r->pool, conf->logname),
                    APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool)
               != APR_SUCCESS)) {
 	return ret;
     }
 
     /* "%% [Wed Jun 19 10:53:21 1996] GET /cgi-bin/printenv HTTP/1.0" */
-    apr_ctime(time_str, apr_now());
-    apr_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri,
+    apr_ctime(time_str, apr_time_now());
+    apr_file_printf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri,
 	    r->args ? "?" : "", r->args ? r->args : "", r->protocol);
     /* "%% 500 /usr/local/apache/cgi-bin */
-    apr_fprintf(f, "%%%% %d %s\n", ret, r->filename);
+    apr_file_printf(f, "%%%% %d %s\n", ret, r->filename);
 
-    apr_fprintf(f, "%%error\n%s\n", error);
+    apr_file_printf(f, "%%error\n%s\n", error);
 
-    apr_close(f);
+    apr_file_close(f);
     return ret;
 }
 
@@ -242,7 +242,7 @@ static void log_script_err(request_rec *r, apr_file_t *script_err)
     char argsbuffer[HUGE_STRING_LEN];
     char *newline;
 
-    while (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_err) == 0) {
+    while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_err) == 0) {
         newline = strchr(argsbuffer, '\n');
         if (newline) {
             *newline = '\0';
@@ -268,10 +268,10 @@ static int log_script(request_rec *r, cgi_server_conf * conf, int ret,
         ((apr_stat(&finfo, ap_server_root_relative(r->pool, conf->logname),
                    APR_FINFO_SIZE, r->pool) == APR_SUCCESS)
          &&  (finfo.size > conf->logbytes)) ||
-         (apr_open(&f, ap_server_root_relative(r->pool, conf->logname),
+         (apr_file_open(&f, ap_server_root_relative(r->pool, conf->logname),
                   APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) {
 	/* Soak up script output */
-	while (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_in) == 0)
+	while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_in) == 0)
 	    continue;
 
         log_script_err(r, script_err);
@@ -279,56 +279,56 @@ static int log_script(request_rec *r, cgi_server_conf * conf, int ret,
     }
 
     /* "%% [Wed Jun 19 10:53:21 1996] GET /cgi-bin/printenv HTTP/1.0" */
-    apr_ctime(time_str, apr_now());
-    apr_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri,
+    apr_ctime(time_str, apr_time_now());
+    apr_file_printf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri,
 	    r->args ? "?" : "", r->args ? r->args : "", r->protocol);
     /* "%% 500 /usr/local/apache/cgi-bin" */
-    apr_fprintf(f, "%%%% %d %s\n", ret, r->filename);
+    apr_file_printf(f, "%%%% %d %s\n", ret, r->filename);
 
-    apr_puts("%request\n", f);
+    apr_file_puts("%request\n", f);
     for (i = 0; i < hdrs_arr->nelts; ++i) {
 	if (!hdrs[i].key)
 	    continue;
-	apr_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
+	apr_file_printf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
     }
     if ((r->method_number == M_POST || r->method_number == M_PUT)
 	&& *dbuf) {
-	apr_fprintf(f, "\n%s\n", dbuf);
+	apr_file_printf(f, "\n%s\n", dbuf);
     }
 
-    apr_puts("%response\n", f);
+    apr_file_puts("%response\n", f);
     hdrs_arr = apr_table_elts(r->err_headers_out);
     hdrs = (apr_table_entry_t *) hdrs_arr->elts;
 
     for (i = 0; i < hdrs_arr->nelts; ++i) {
 	if (!hdrs[i].key)
 	    continue;
-	apr_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
+	apr_file_printf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
     }
 
     if (sbuf && *sbuf)
-	apr_fprintf(f, "%s\n", sbuf);
+	apr_file_printf(f, "%s\n", sbuf);
 
-    if (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_in) == 0) {
-	apr_puts("%stdout\n", f);
-	apr_puts(argsbuffer, f);
-	while (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_in) == 0)
-	    apr_puts(argsbuffer, f);
-	apr_puts("\n", f);
+    if (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_in) == 0) {
+	apr_file_puts("%stdout\n", f);
+	apr_file_puts(argsbuffer, f);
+	while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_in) == 0)
+	    apr_file_puts(argsbuffer, f);
+	apr_file_puts("\n", f);
     }
 
-    if (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_err) == 0) {
-	apr_puts("%stderr\n", f);
-	apr_puts(argsbuffer, f);
-	while (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_err) == 0)
-	    apr_puts(argsbuffer, f);
-	apr_puts("\n", f);
+    if (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_err) == 0) {
+	apr_file_puts("%stderr\n", f);
+	apr_file_puts(argsbuffer, f);
+	while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_err) == 0)
+	    apr_file_puts(argsbuffer, f);
+	apr_file_puts("\n", f);
     }
 
-    apr_close(script_in);
-    apr_close(script_err);
+    apr_file_close(script_in);
+    apr_file_close(script_err);
 
-    apr_close(f);
+    apr_file_close(f);
     return ret;
 }
 
@@ -415,23 +415,23 @@ static apr_status_t run_cgi_child(apr_file_t **script_out,
     /* Transmute ourselves into the script.
      * NB only ISINDEX scripts get decoded arguments.
      */
-    if (((rc = apr_createprocattr_init(&procattr, p)) != APR_SUCCESS) ||
-        ((rc = apr_setprocattr_io(procattr,
+    if (((rc = apr_procattr_create(&procattr, p)) != APR_SUCCESS) ||
+        ((rc = apr_procattr_io_set(procattr,
                                   e_info->in_pipe,
                                   e_info->out_pipe,
                                   e_info->err_pipe)) != APR_SUCCESS) ||
-        ((rc = apr_setprocattr_dir(procattr, 
+        ((rc = apr_procattr_dir_set(procattr, 
                                   ap_make_dirstr_parent(r->pool, r->filename))) != APR_SUCCESS) ||
 #ifdef RLIMIT_CPU
-        ((rc = apr_setprocattr_limit(procattr, APR_LIMIT_CPU, conf->limit_cpu)) != APR_SUCCESS) ||
+        ((rc = apr_procattr_limit_set(procattr, APR_LIMIT_CPU, conf->limit_cpu)) != APR_SUCCESS) ||
 #endif
 #if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
-        ((rc = apr_setprocattr_limit(procattr, APR_LIMIT_MEM, conf->limit_mem)) != APR_SUCCESS) ||
+        ((rc = apr_procattr_limit_set(procattr, APR_LIMIT_MEM, conf->limit_mem)) != APR_SUCCESS) ||
 #endif
 #ifdef RLIMIT_NPROC
-        ((rc = apr_setprocattr_limit(procattr, APR_LIMIT_NPROC, conf->limit_nproc)) != APR_SUCCESS) ||
+        ((rc = apr_procattr_limit_set(procattr, APR_LIMIT_NPROC, conf->limit_nproc)) != APR_SUCCESS) ||
 #endif
-        ((rc = apr_setprocattr_cmdtype(procattr, e_info->cmd_type)) != APR_SUCCESS)) {
+        ((rc = apr_procattr_cmdtype_set(procattr, e_info->cmd_type)) != APR_SUCCESS)) {
         /* Something bad happened, tell the world. */
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
 		      "couldn't set child process attributes: %s", r->filename);
@@ -450,23 +450,23 @@ static apr_status_t run_cgi_child(apr_file_t **script_out,
                         "couldn't create child process: %d: %s", rc, r->filename);
         }
         else {
-            apr_note_subprocess(p, procnew, kill_after_timeout);
+            apr_pool_note_subprocess(p, procnew, kill_after_timeout);
 
             *script_in = procnew->out;
             if (!script_in)
                 return APR_EBADF;
-            apr_set_pipe_timeout(*script_in, (int)(r->server->timeout * APR_USEC_PER_SEC));
+            apr_file_pipe_timeout_set(*script_in, (int)(r->server->timeout * APR_USEC_PER_SEC));
 
             if (e_info->prog_type == RUN_AS_CGI) {
                 *script_out = procnew->in;
                 if (!*script_out)
                     return APR_EBADF;
-                apr_set_pipe_timeout(*script_out, (int)(r->server->timeout * APR_USEC_PER_SEC));
+                apr_file_pipe_timeout_set(*script_out, (int)(r->server->timeout * APR_USEC_PER_SEC));
 
                 *script_err = procnew->err;
                 if (!*script_err)
                     return APR_EBADF;
-                apr_set_pipe_timeout(*script_err, (int)(r->server->timeout * APR_USEC_PER_SEC));
+                apr_file_pipe_timeout_set(*script_err, (int)(r->server->timeout * APR_USEC_PER_SEC));
             }
         }
     }
@@ -709,7 +709,7 @@ static int cgi_handler(request_rec *r)
             bytes_written = 0;
             do {
                 bytes_to_write = len_read - bytes_written;
-                rv = apr_write(script_out, argsbuffer + bytes_written, 
+                rv = apr_file_write(script_out, argsbuffer + bytes_written, 
                                &bytes_to_write);
                 bytes_written += bytes_to_write;
             } while (rv == APR_SUCCESS && bytes_written < len_read);
@@ -721,10 +721,10 @@ static int cgi_handler(request_rec *r)
 		break;
 	    }
 	}
-	apr_flush(script_out);
+	apr_file_flush(script_out);
     }
 
-    apr_close(script_out);
+    apr_file_close(script_out);
 
     /* Handle script return... */
     if (script_in && !nph) {
@@ -741,7 +741,7 @@ static int cgi_handler(request_rec *r)
 	if (location && location[0] == '/' && r->status == 200) {
 
 	    /* Soak up all the script output */
-	    while (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_in) == 0) {
+	    while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_in) == 0) {
 		continue;
 	    }
             log_script_err(r, script_err);
@@ -770,22 +770,22 @@ static int cgi_handler(request_rec *r)
 	ap_send_http_header(r);
 	if (!r->header_only) {
             bb = apr_brigade_create(r->pool);
-	    b = apr_bucket_create_pipe(script_in);
+	    b = apr_bucket_pipe_creat(script_in);
 	    APR_BRIGADE_INSERT_TAIL(bb, b);
-            b = apr_bucket_create_eos();
+            b = apr_bucket_eos_create();
 	    APR_BRIGADE_INSERT_TAIL(bb, b);
 	    ap_pass_brigade(r->output_filters, bb);
 	}
 
         log_script_err(r, script_err);
-	apr_close(script_err);
+	apr_file_close(script_err);
     }
 
     if (script_in && nph) {
         bb = apr_brigade_create(r->pool);
-	b = apr_bucket_create_pipe(script_in);
+	b = apr_bucket_pipe_creat(script_in);
 	APR_BRIGADE_INSERT_TAIL(bb, b);
-	b = apr_bucket_create_eos();
+	b = apr_bucket_eos_create();
 	APR_BRIGADE_INSERT_TAIL(bb, b);
         ap_pass_brigade(r->output_filters, bb);
     }
@@ -840,15 +840,15 @@ static int include_cgi(char *s, request_rec *r, ap_filter_t *next,
         location = ap_escape_html(rr->pool, location);
         len_loc = strlen(location);
 
-        tmp_buck = apr_bucket_create_immortal("<A HREF=\"", sizeof("<A HREF=\""));
+        tmp_buck = apr_bucket_immortal_create("<A HREF=\"", sizeof("<A HREF=\""));
         APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
-        tmp2_buck = apr_bucket_create_heap(location, len_loc, 1, &h_wrt);
+        tmp2_buck = apr_bucket_heap_create(location, len_loc, 1, &h_wrt);
         APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
-        tmp2_buck = apr_bucket_create_immortal("\">", sizeof("\">"));
+        tmp2_buck = apr_bucket_immortal_create("\">", sizeof("\">"));
         APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
-        tmp2_buck = apr_bucket_create_heap(location, len_loc, 1, &h_wrt);
+        tmp2_buck = apr_bucket_heap_create(location, len_loc, 1, &h_wrt);
         APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
-        tmp2_buck = apr_bucket_create_immortal("</A>", sizeof("</A>"));
+        tmp2_buck = apr_bucket_immortal_create("</A>", sizeof("</A>"));
         APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
 
         if (*inserted_head == NULL) {
@@ -896,7 +896,7 @@ static int include_cmd(include_ctx_t *ctx, apr_bucket_brigade **bb, char *comman
     }
 
     bcgi = apr_brigade_create(r->pool);
-    b = apr_bucket_create_pipe(script_in);
+    b = apr_bucket_pipe_creat(script_in);
     APR_BRIGADE_INSERT_TAIL(bcgi, b);
     ap_pass_brigade(f->next, bcgi);
 
diff --git a/modules/generators/mod_cgid.c b/modules/generators/mod_cgid.c
index 194b97e..3007323 100644
--- a/modules/generators/mod_cgid.c
+++ b/modules/generators/mod_cgid.c
@@ -227,12 +227,12 @@ static void cgid_maint(int reason, void *data, apr_wait_t status)
         case APR_OC_REASON_LOST:
             /* stop gap to make sure everything else works.  In the end,
              * we'll just restart the cgid server. */
-            apr_destroy_pool(pcgi);
+            apr_pool_destroy(pcgi);
             kill(getppid(), SIGWINCH);
             break;
         case APR_OC_REASON_RESTART:
         case APR_OC_REASON_UNREGISTER:
-            apr_destroy_pool(pcgi);
+            apr_pool_destroy(pcgi);
             kill(*sd, SIGHUP);
             break;
     }
@@ -328,7 +328,7 @@ static void get_req(int fd, request_rec *r, char **filename, char **argv0, char
      * to actually fill this out, but for now we just don't want suexec to
      * seg fault.
      */
-    r->notes = apr_make_table(r->pool, 1);
+    r->notes = apr_table_make(r->pool, 1);
 } 
 
 
@@ -510,14 +510,14 @@ static int cgid_server(void *data)
             continue;
         }
        
-        apr_create_pool(&p, pcgi); 
+        apr_pool_create(&p, pcgi); 
 
         r = apr_pcalloc(p, sizeof(request_rec)); 
         procnew = apr_pcalloc(p, sizeof(*procnew));
         r->pool = p; 
         get_req(sd2, r, &filename, &argv0, &env, &req_type); 
-        apr_put_os_file(&r->server->error_log, &errfileno, r->pool);
-        apr_put_os_file(&inout, &sd2, r->pool);
+        apr_os_file_put(&r->server->error_log, &errfileno, r->pool);
+        apr_os_file_put(&inout, &sd2, r->pool);
 
         if (req_type == SSI_REQ) {
             in_pipe  = APR_NO_PIPE;
@@ -526,18 +526,18 @@ static int cgid_server(void *data)
             cmd_type = APR_SHELLCMD;
         }
 
-        if (((rc = apr_createprocattr_init(&procattr, p)) != APR_SUCCESS) ||
+        if (((rc = apr_procattr_create(&procattr, p)) != APR_SUCCESS) ||
             ((req_type == CGI_REQ) && 
-             (((rc = apr_setprocattr_io(procattr,
+             (((rc = apr_procattr_io_set(procattr,
                                         in_pipe,
                                         out_pipe,
                                         err_pipe)) != APR_SUCCESS) ||
-              ((rc = apr_setprocattr_childerr(procattr, r->server->error_log, NULL)) != APR_SUCCESS) ||
-              ((rc = apr_setprocattr_childin(procattr, inout, NULL)) != APR_SUCCESS))) ||
-            ((rc = apr_setprocattr_childout(procattr, inout, NULL)) != APR_SUCCESS) ||
-            ((rc = apr_setprocattr_dir(procattr,
+              ((rc = apr_procattr_child_err_set(procattr, r->server->error_log, NULL)) != APR_SUCCESS) ||
+              ((rc = apr_procattr_child_in_set(procattr, inout, NULL)) != APR_SUCCESS))) ||
+            ((rc = apr_procattr_child_out_set(procattr, inout, NULL)) != APR_SUCCESS) ||
+            ((rc = apr_procattr_dir_set(procattr,
                                   ap_make_dirstr_parent(r->pool, r->filename))) != APR_SUCCESS) ||
-            ((rc = apr_setprocattr_cmdtype(procattr, cmd_type)) != APR_SUCCESS)) {
+            ((rc = apr_procattr_cmdtype_set(procattr, cmd_type)) != APR_SUCCESS)) {
             /* Something bad happened, tell the world. */
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
                       "couldn't set child process attributes: %s", r->filename);
@@ -569,15 +569,15 @@ static void cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
     const char *userdata_key = "cgid_init";
     module **m;
 
-    apr_get_userdata(&data, userdata_key, main_server->process->pool);
+    apr_pool_userdata_get(&data, userdata_key, main_server->process->pool);
     if (!data) {
         first_time = 1;
-        apr_set_userdata((const void *)1, userdata_key,
-                         apr_null_cleanup, main_server->process->pool);
+        apr_pool_userdata_set((const void *)1, userdata_key,
+                         apr_pool_cleanup_null, main_server->process->pool);
     }
 
     if (!first_time) {
-        apr_create_pool(&pcgi, p); 
+        apr_pool_create(&pcgi, p); 
 
         total_modules = 0;
         for (m = ap_preloaded_modules; *m != NULL; m++)
@@ -595,9 +595,9 @@ static void cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
         procnew = apr_pcalloc(p, sizeof(*procnew));
         procnew->pid = pid;
         procnew->err = procnew->in = procnew->out = NULL;
-        apr_note_subprocess(p, procnew, kill_after_timeout);
+        apr_pool_note_subprocess(p, procnew, kill_after_timeout);
 #if APR_HAS_OTHER_CHILD
-        apr_register_other_child(procnew, cgid_maint, &procnew->pid, NULL, p);
+        apr_proc_other_child_register(procnew, cgid_maint, &procnew->pid, NULL, p);
 #endif
 
         cgid_pfn_reg_with_ssi = APR_RETRIEVE_OPTIONAL_FN(ap_register_include_handler);
@@ -700,21 +700,21 @@ static int log_scripterror(request_rec *r, cgid_server_conf * conf, int ret,
     if (!conf->logname || 
         ((stat(ap_server_root_relative(r->pool, conf->logname), &finfo) == 0) 
          && (finfo.st_size > conf->logbytes)) || 
-         (apr_open(&f, ap_server_root_relative(r->pool, conf->logname),
+         (apr_file_open(&f, ap_server_root_relative(r->pool, conf->logname),
                   APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) { 
         return ret; 
     } 
 
     /* "%% [Wed Jun 19 10:53:21 1996] GET /cgid-bin/printenv HTTP/1.0" */ 
-    apr_ctime(time_str, apr_now());
-    apr_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, 
+    apr_ctime(time_str, apr_time_now());
+    apr_file_printf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, 
             r->args ? "?" : "", r->args ? r->args : "", r->protocol); 
     /* "%% 500 /usr/local/apache/cgid-bin */ 
-    apr_fprintf(f, "%%%% %d %s\n", ret, r->filename); 
+    apr_file_printf(f, "%%%% %d %s\n", ret, r->filename); 
 
-    apr_fprintf(f, "%%error\n%s\n", error); 
+    apr_file_printf(f, "%%error\n%s\n", error); 
 
-    apr_close(f); 
+    apr_file_close(f); 
     return ret; 
 } 
 
@@ -732,73 +732,73 @@ static int log_script(request_rec *r, cgid_server_conf * conf, int ret,
     if (!conf->logname || 
         ((stat(ap_server_root_relative(r->pool, conf->logname), &finfo) == 0) 
          && (finfo.st_size > conf->logbytes)) || 
-         (apr_open(&f, ap_server_root_relative(r->pool, conf->logname), 
+         (apr_file_open(&f, ap_server_root_relative(r->pool, conf->logname), 
                   APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) { 
         /* Soak up script output */ 
-        while (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_in) == 0) 
+        while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_in) == 0) 
             continue; 
         if (script_err) {
-            while (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_err) == 0) 
+            while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_err) == 0) 
                 continue; 
         }
         return ret; 
     } 
 
     /* "%% [Wed Jun 19 10:53:21 1996] GET /cgid-bin/printenv HTTP/1.0" */ 
-    apr_ctime(time_str, apr_now());
-    apr_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, 
+    apr_ctime(time_str, apr_time_now());
+    apr_file_printf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, 
             r->args ? "?" : "", r->args ? r->args : "", r->protocol); 
     /* "%% 500 /usr/local/apache/cgid-bin" */ 
-    apr_fprintf(f, "%%%% %d %s\n", ret, r->filename); 
+    apr_file_printf(f, "%%%% %d %s\n", ret, r->filename); 
 
-    apr_puts("%request\n", f); 
+    apr_file_puts("%request\n", f); 
     for (i = 0; i < hdrs_arr->nelts; ++i) { 
         if (!hdrs[i].key) 
             continue; 
-        apr_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val); 
+        apr_file_printf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val); 
     } 
     if ((r->method_number == M_POST || r->method_number == M_PUT) 
         && *dbuf) { 
-        apr_fprintf(f, "\n%s\n", dbuf); 
+        apr_file_printf(f, "\n%s\n", dbuf); 
     } 
 
-    apr_puts("%response\n", f); 
+    apr_file_puts("%response\n", f); 
     hdrs_arr = apr_table_elts(r->err_headers_out); 
     hdrs = (apr_table_entry_t *) hdrs_arr->elts; 
 
     for (i = 0; i < hdrs_arr->nelts; ++i) { 
         if (!hdrs[i].key) 
             continue; 
-        apr_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val); 
+        apr_file_printf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val); 
     } 
 
     if (sbuf && *sbuf) 
-        apr_fprintf(f, "%s\n", sbuf); 
-
-    if (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_in) == 0) { 
-        apr_puts("%stdout\n", f); 
-        apr_puts(argsbuffer, f); 
-        while (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_in) == 0) 
-            apr_puts(argsbuffer, f); 
-        apr_puts("\n", f); 
+        apr_file_printf(f, "%s\n", sbuf); 
+
+    if (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_in) == 0) { 
+        apr_file_puts("%stdout\n", f); 
+        apr_file_puts(argsbuffer, f); 
+        while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_in) == 0) 
+            apr_file_puts(argsbuffer, f); 
+        apr_file_puts("\n", f); 
     } 
 
     if (script_err) {
-        if (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_err) == 0) { 
-            apr_puts("%stderr\n", f); 
-            apr_puts(argsbuffer, f); 
-            while (apr_fgets(argsbuffer, HUGE_STRING_LEN, script_err) == 0) 
-                apr_puts(argsbuffer, f); 
-            apr_puts("\n", f); 
+        if (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_err) == 0) { 
+            apr_file_puts("%stderr\n", f); 
+            apr_file_puts(argsbuffer, f); 
+            while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, script_err) == 0) 
+                apr_file_puts(argsbuffer, f); 
+            apr_file_puts("\n", f); 
         } 
     }
 
-    apr_close(script_in); 
+    apr_file_close(script_in); 
     if (script_err) {
-        apr_close(script_err); 
+        apr_file_close(script_err); 
     }
 
-    apr_close(f); 
+    apr_file_close(f); 
     return ret; 
 } 
 
@@ -897,7 +897,7 @@ static int cgid_handler(request_rec *r)
     /* We are putting the tempsock variable into a file so that we can use
      * a pipe bucket to send the data to the client.
      */
-    apr_put_os_file(&tempsock, &sd, r->pool);
+    apr_os_file_put(&tempsock, &sd, r->pool);
 
     if ((retval = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR))) 
         return retval; 
@@ -932,7 +932,7 @@ static int cgid_handler(request_rec *r)
                 dbpos += dbsize; 
             } 
             nbytes = len_read;
-            apr_write(tempsock, argsbuffer, &nbytes);
+            apr_file_write(tempsock, argsbuffer, &nbytes);
             if (nbytes < len_read) { 
                 /* silly script stopped reading, soak up remaining message */ 
                 while (ap_get_client_block(r, argsbuffer, HUGE_STRING_LEN) > 0) { 
@@ -959,7 +959,7 @@ static int cgid_handler(request_rec *r)
         if (location && location[0] == '/' && r->status == 200) { 
 
             /* Soak up all the script output */ 
-            while (apr_fgets(argsbuffer, HUGE_STRING_LEN, tempsock) > 0) { 
+            while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, tempsock) > 0) { 
                 continue; 
             } 
             /* This redirect needs to be a GET no matter what the original 
@@ -987,9 +987,9 @@ static int cgid_handler(request_rec *r)
         ap_send_http_header(r); 
         if (!r->header_only) { 
             bb = apr_brigade_create(r->pool);
-            b = apr_bucket_create_pipe(tempsock);
+            b = apr_bucket_pipe_creat(tempsock);
             APR_BRIGADE_INSERT_TAIL(bb, b);
-            b = apr_bucket_create_eos();
+            b = apr_bucket_eos_create();
             APR_BRIGADE_INSERT_TAIL(bb, b);
             ap_pass_brigade(r->output_filters, bb);
         } 
@@ -997,14 +997,14 @@ static int cgid_handler(request_rec *r)
 
     if (nph) {
         bb = apr_brigade_create(r->pool);
-        b = apr_bucket_create_pipe(tempsock);
+        b = apr_bucket_pipe_creat(tempsock);
         APR_BRIGADE_INSERT_TAIL(bb, b);
-        b = apr_bucket_create_eos();
+        b = apr_bucket_eos_create();
         APR_BRIGADE_INSERT_TAIL(bb, b);
         ap_pass_brigade(r->output_filters, bb);
     } 
 
-    apr_close(tempsock);
+    apr_file_close(tempsock);
 
     return OK; /* NOT r->status, even if it has changed. */ 
 } 
@@ -1059,15 +1059,15 @@ static int include_cgi(char *s, request_rec *r, ap_filter_t *next,
         location = ap_escape_html(rr->pool, location);
         len_loc = strlen(location);
 
-        tmp_buck = apr_bucket_create_immortal("<A HREF=\"", sizeof("<A HREF=\""));
+        tmp_buck = apr_bucket_immortal_create("<A HREF=\"", sizeof("<A HREF=\""));
         APR_BUCKET_INSERT_BEFORE(head_ptr, tmp_buck);
-        tmp2_buck = apr_bucket_create_heap(location, len_loc, 1, &h_wrt);
+        tmp2_buck = apr_bucket_heap_create(location, len_loc, 1, &h_wrt);
         APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
-        tmp2_buck = apr_bucket_create_immortal("\">", sizeof("\">"));
+        tmp2_buck = apr_bucket_immortal_create("\">", sizeof("\">"));
         APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
-        tmp2_buck = apr_bucket_create_heap(location, len_loc, 1, &h_wrt);
+        tmp2_buck = apr_bucket_heap_create(location, len_loc, 1, &h_wrt);
         APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
-        tmp2_buck = apr_bucket_create_immortal("</A>", sizeof("</A>"));
+        tmp2_buck = apr_bucket_immortal_create("</A>", sizeof("</A>"));
         APR_BUCKET_INSERT_BEFORE(head_ptr, tmp2_buck);
 
         if (*inserted_head == NULL) {
@@ -1147,7 +1147,7 @@ static int include_cmd(include_ctx_t *ctx, apr_bucket_brigade **bb, char *comman
     /* We are putting the tempsock variable into a file so that we can use
      * a pipe bucket to send the data to the client.
      */
-    apr_put_os_file(&tempsock, &sd, r->pool);
+    apr_os_file_put(&tempsock, &sd, r->pool);
 
     if ((retval = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR))) 
         return retval; 
@@ -1158,7 +1158,7 @@ static int include_cmd(include_ctx_t *ctx, apr_bucket_brigade **bb, char *comman
         char argsbuffer[HUGE_STRING_LEN]; 
 
         /* Soak up all the script output */ 
-        while (apr_fgets(argsbuffer, HUGE_STRING_LEN, tempsock) > 0) { 
+        while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, tempsock) > 0) { 
             continue; 
         } 
         /* This redirect needs to be a GET no matter what the original 
@@ -1186,7 +1186,7 @@ static int include_cmd(include_ctx_t *ctx, apr_bucket_brigade **bb, char *comman
     ap_send_http_header(r); 
     if (!r->header_only) { 
         bcgi = apr_brigade_create(r->pool);
-        b    = apr_bucket_create_pipe(tempsock);
+        b    = apr_bucket_pipe_creat(tempsock);
         APR_BRIGADE_INSERT_TAIL(bcgi, b);
         ap_pass_brigade(f->next, bcgi);
     } 
diff --git a/modules/generators/mod_info.c b/modules/generators/mod_info.c
index 91e183a..df1b485 100644
--- a/modules/generators/mod_info.c
+++ b/modules/generators/mod_info.c
@@ -114,7 +114,7 @@ static void *create_info_config(apr_pool_t *p, server_rec *s)
 {
     info_svr_conf *conf = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
 
-    conf->more_info = apr_make_array(p, 20, sizeof(info_entry));
+    conf->more_info = apr_array_make(p, 20, sizeof(info_entry));
     return conf;
 }
 
@@ -124,7 +124,7 @@ static void *merge_info_config(apr_pool_t *p, void *basev, void *overridesv)
     info_svr_conf *base = (info_svr_conf *) basev;
     info_svr_conf *overrides = (info_svr_conf *) overridesv;
 
-    new->more_info = apr_append_arrays(p, overrides->more_info, base->more_info);
+    new->more_info = apr_array_append(p, overrides->more_info, base->more_info);
     return new;
 }
 
@@ -452,7 +452,7 @@ static const char *add_module_info(cmd_parms *cmd, void *dummy,
     server_rec *s = cmd->server;
     info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                               &info_module);
-    info_entry *new = apr_push_array(conf->more_info);
+    info_entry *new = apr_array_push(conf->more_info);
 
     new->name = name;
     new->info = info;
diff --git a/modules/generators/mod_status.c b/modules/generators/mod_status.c
index bb68550..d171fc4 100644
--- a/modules/generators/mod_status.c
+++ b/modules/generators/mod_status.c
@@ -228,7 +228,7 @@ static char status_flags[SERVER_NUM_STATUS];
 static int status_handler(request_rec *r)
 {
     const char *loc;
-    apr_time_t nowtime = apr_now();
+    apr_time_t nowtime = apr_time_now();
     time_t up_time;
     int j, i, res;
     int ready = 0;
diff --git a/modules/http/error_bucket.c b/modules/http/error_bucket.c
index 8d3c674..38b39f8 100644
--- a/modules/http/error_bucket.c
+++ b/modules/http/error_bucket.c
@@ -98,7 +98,7 @@ AP_DECLARE_DATA const apr_bucket_type_t ap_bucket_type_error = {
     "ERROR", 5,
     free,
     error_read,
-    apr_bucket_setaside_notimpl,
-    apr_bucket_split_notimpl,
-    apr_bucket_copy_notimpl
+    apr_bucket_notimpl_setaside,
+    apr_bucket_notimpl_split,
+    apr_bucket_notimpl_copy
 };
diff --git a/modules/http/http_core.c b/modules/http/http_core.c
index 8d38a6a..15d2f04 100644
--- a/modules/http/http_core.c
+++ b/modules/http/http_core.c
@@ -155,7 +155,7 @@ static void *create_core_dir_config(apr_pool_t *a, char *dir)
 
     conf->limit_req_body = 0;
     conf->limit_xml_body = AP_LIMIT_UNSET;
-    conf->sec = apr_make_array(a, 2, sizeof(void *));
+    conf->sec = apr_array_make(a, 2, sizeof(void *));
 #ifdef WIN32
     conf->script_interpreter_source = INTERPRETER_SOURCE_UNSET;
 #endif
@@ -165,8 +165,8 @@ static void *create_core_dir_config(apr_pool_t *a, char *dir)
     conf->add_default_charset = ADD_DEFAULT_CHARSET_UNSET;
     conf->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;
 
-    conf->output_filters = apr_make_array(a, 2, sizeof(void *));
-    conf->input_filters = apr_make_array(a, 2, sizeof(void *));
+    conf->output_filters = apr_array_make(a, 2, sizeof(void *));
+    conf->input_filters = apr_array_make(a, 2, sizeof(void *));
     return (void *)conf;
 }
 
@@ -284,7 +284,7 @@ static void *merge_core_dir_configs(apr_pool_t *a, void *basev, void *newv)
     else
         conf->limit_xml_body = base->limit_xml_body;
 
-    conf->sec = apr_append_arrays(a, base->sec, new->sec);
+    conf->sec = apr_array_append(a, base->sec, new->sec);
 
     if (new->satisfy != SATISFY_NOSPEC) {
         conf->satisfy = new->satisfy;
@@ -306,9 +306,9 @@ static void *merge_core_dir_configs(apr_pool_t *a, void *basev, void *newv)
 	    conf->add_default_charset_name = new->add_default_charset_name;
 	}
     }
-    conf->output_filters = apr_append_arrays(a, base->output_filters, 
+    conf->output_filters = apr_array_append(a, base->output_filters, 
                                              new->output_filters);
-    conf->input_filters = apr_append_arrays(a, base->input_filters,
+    conf->input_filters = apr_array_append(a, base->input_filters,
                                             new->input_filters);
 
     return (void*)conf;
@@ -325,8 +325,8 @@ static void *create_core_server_config(apr_pool_t *a, server_rec *s)
 #endif
     conf->access_name = is_virtual ? NULL : DEFAULT_ACCESS_FNAME;
     conf->ap_document_root = is_virtual ? NULL : DOCUMENT_LOCATION;
-    conf->sec = apr_make_array(a, 40, sizeof(void *));
-    conf->sec_url = apr_make_array(a, 40, sizeof(void *));
+    conf->sec = apr_array_make(a, 40, sizeof(void *));
+    conf->sec_url = apr_array_make(a, 40, sizeof(void *));
     
     return (void *)conf;
 }
@@ -345,8 +345,8 @@ static void *merge_core_server_configs(apr_pool_t *p, void *basev, void *virtv)
     if (!conf->ap_document_root) {
         conf->ap_document_root = base->ap_document_root;
     }
-    conf->sec = apr_append_arrays(p, base->sec, virt->sec);
-    conf->sec_url = apr_append_arrays(p, base->sec_url, virt->sec_url);
+    conf->sec = apr_array_append(p, base->sec, virt->sec);
+    conf->sec_url = apr_array_append(p, base->sec_url, virt->sec_url);
 
     return conf;
 }
@@ -359,7 +359,7 @@ AP_CORE_DECLARE(void) ap_add_per_dir_conf(server_rec *s, void *dir_config)
 {
     core_server_config *sconf = ap_get_module_config(s->module_config,
 						     &core_module);
-    void **new_space = (void **)apr_push_array(sconf->sec);
+    void **new_space = (void **)apr_array_push(sconf->sec);
     
     *new_space = dir_config;
 }
@@ -368,14 +368,14 @@ AP_CORE_DECLARE(void) ap_add_per_url_conf(server_rec *s, void *url_config)
 {
     core_server_config *sconf = ap_get_module_config(s->module_config,
 						     &core_module);
-    void **new_space = (void **)apr_push_array(sconf->sec_url);
+    void **new_space = (void **)apr_array_push(sconf->sec_url);
     
     *new_space = url_config;
 }
 
 AP_CORE_DECLARE(void) ap_add_file_conf(core_dir_config *conf, void *url_config)
 {
-    void **new_space = (void **)apr_push_array(conf->sec);
+    void **new_space = (void **)apr_array_push(conf->sec);
     
     *new_space = url_config;
 }
@@ -465,7 +465,7 @@ void ap_core_reorder_directories(apr_pool_t *p, server_rec *s)
     elts = (void **)sec->elts;
 
     /* we have to allocate tmp space to do a stable sort */
-    apr_create_pool(&tmp, p);
+    apr_pool_create(&tmp, p);
     sortbin = apr_palloc(tmp, sec->nelts * sizeof(*sortbin));
     for (i = 0; i < nelts; ++i) {
 	sortbin[i].orig_index = i;
@@ -479,7 +479,7 @@ void ap_core_reorder_directories(apr_pool_t *p, server_rec *s)
       elts[i] = sortbin[i].elt;
     }
 
-    apr_destroy_pool(tmp);
+    apr_pool_destroy(tmp);
 }
 
 /*****************************************************************
@@ -598,7 +598,7 @@ static apr_inline void do_double_reverse (conn_rec *conn)
 	conn->double_reverse = -1;
 	return;
     }
-    rv = apr_getaddrinfo(&sa, conn->remote_host, APR_UNSPEC, 0, 0, conn->pool);
+    rv = apr_sockaddr_info_get(&sa, conn->remote_host, APR_UNSPEC, 0, 0, conn->pool);
     if (rv == APR_SUCCESS) {
         while (sa) {
             if (sa->ipaddr_len == conn->remote_addr->ipaddr_len &&
@@ -638,7 +638,7 @@ AP_DECLARE(const char *) ap_get_remote_host(conn_rec *conn, void *dir_config,
 	    || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {
         apr_sockaddr_t *remote_addr;
 
-        apr_get_sockaddr(&remote_addr, APR_REMOTE, conn->client_socket);
+        apr_socket_addr_get(&remote_addr, APR_REMOTE, conn->client_socket);
 	if (apr_getnameinfo(&conn->remote_host, remote_addr, 0) == APR_SUCCESS) {
 	    ap_str_tolower(conn->remote_host);
 	   
@@ -727,7 +727,7 @@ AP_DECLARE(const char *) ap_get_server_name(request_rec *r)
         if (conn->local_host == NULL) {
             apr_sockaddr_t *local_addr;
 
-            apr_get_sockaddr(&local_addr, APR_LOCAL, conn->client_socket);
+            apr_socket_addr_get(&local_addr, APR_LOCAL, conn->client_socket);
             if (apr_getnameinfo(&conn->local_host, local_addr, 0) != APR_SUCCESS)
                 conn->local_host = apr_pstrdup(conn->pool, r->server->server_hostname);
             else {
@@ -753,8 +753,8 @@ AP_DECLARE(apr_port_t) ap_get_server_port(const request_rec *r)
         if (r->hostname) {
             apr_sockaddr_t *localsa;
 
-            apr_get_sockaddr(&localsa, APR_LOCAL, r->connection->client_socket);
-            apr_get_port(&port, localsa);
+            apr_socket_addr_get(&localsa, APR_LOCAL, r->connection->client_socket);
+            apr_sockaddr_port_get(&port, localsa);
         }
     }
     /* default */
@@ -1430,9 +1430,9 @@ static const char *require(cmd_parms *cmd, void *c_, const char *arg)
     core_dir_config *c=c_;
 
     if (!c->ap_requires) {
-        c->ap_requires = apr_make_array(cmd->pool, 2, sizeof(require_line));
+        c->ap_requires = apr_array_make(cmd->pool, 2, sizeof(require_line));
     }
-    r = (require_line *)apr_push_array(c->ap_requires);
+    r = (require_line *)apr_array_push(c->ap_requires);
     r->requirement = apr_pstrdup(cmd->pool, arg);
     r->method_mask = cmd->limited;
     return NULL;
@@ -1466,10 +1466,10 @@ AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd, void *dumm
 	     */
 	    if (!tog) {
 		if (cmd->limited_xmethods == NULL) {
-		    cmd->limited_xmethods = apr_make_array(cmd->pool, 2,
+		    cmd->limited_xmethods = apr_array_make(cmd->pool, 2,
 							   sizeof(char *));
 		}
-		xmethod = (char **) apr_push_array(cmd->limited_xmethods);
+		xmethod = (char **) apr_array_push(cmd->limited_xmethods);
 		*xmethod = apr_pstrdup(cmd->pool, method);
 	    }
 	    /*
@@ -1868,10 +1868,10 @@ static const char *set_server_alias(cmd_parms *cmd, void *dummy,
     while (*arg) {
 	char **item, *name = ap_getword_conf(cmd->pool, &arg);
 	if (ap_is_matchexp(name)) {
-	    item = (char **)apr_push_array(cmd->server->wild_names);
+	    item = (char **)apr_array_push(cmd->server->wild_names);
 	}
 	else {
-	    item = (char **)apr_push_array(cmd->server->names);
+	    item = (char **)apr_array_push(cmd->server->names);
 	}
 	*item = name;
     }
@@ -1883,7 +1883,7 @@ static const char *add_filter(cmd_parms *cmd, void *dummy, const char *arg)
     core_dir_config *conf = dummy;
     char **newfilter;
     
-    newfilter = (char **)apr_push_array(conf->output_filters);
+    newfilter = (char **)apr_array_push(conf->output_filters);
     *newfilter = apr_pstrdup(cmd->pool, arg);
     return NULL;
 }
@@ -1893,7 +1893,7 @@ static const char *add_input_filter(cmd_parms *cmd, void *dummy, const char *arg
     core_dir_config *conf = dummy;
     char **newfilter;
     
-    newfilter = (char **)apr_push_array(conf->input_filters);
+    newfilter = (char **)apr_array_push(conf->input_filters);
     *newfilter = apr_pstrdup(cmd->pool, arg);
     return NULL;
 }
@@ -2270,8 +2270,8 @@ AP_DECLARE(void) ap_add_version_component(apr_pool_t *pconf, const char *compone
          * we are adding the original SERVER_BASEVERSION string.
          */
         if (server_version == NULL) {
-            apr_register_cleanup(pconf, NULL, reset_version,
-                                apr_null_cleanup);
+            apr_pool_cleanup_register(pconf, NULL, reset_version,
+                                apr_pool_cleanup_null);
             server_version = apr_pstrdup(pconf, component);
         }
         else {
@@ -2677,7 +2677,7 @@ static apr_status_t send_the_file(conn_rec *c, apr_file_t *fd,
 
     /* Seek the file to 'offset' */
     if (offset != 0 && rv == APR_SUCCESS) {
-        rv = apr_seek(fd, APR_SET, &offset);
+        rv = apr_file_seek(fd, APR_SET, &offset);
     }
 
     /* Send the file, making sure to handle partial writes */
@@ -2685,7 +2685,7 @@ static apr_status_t send_the_file(conn_rec *c, apr_file_t *fd,
     while (rv == APR_SUCCESS && togo) {
         sendlen = togo > sizeof(buffer) ? sizeof(buffer) : togo;
         o = 0;
-        rv = apr_read(fd, buffer, &sendlen);
+        rv = apr_file_read(fd, buffer, &sendlen);
         while (rv == APR_SUCCESS && sendlen) {
             bytes_sent = sendlen;
             rv = apr_send(c->client_socket, &buffer[o], &bytes_sent);
@@ -3006,7 +3006,7 @@ static int default_handler(request_rec *r)
         return HTTP_METHOD_NOT_ALLOWED;
     }
 	
-    if ((status = apr_open(&fd, r->filename, APR_READ | APR_BINARY, 0, r->connection->pool)) != APR_SUCCESS) {
+    if ((status = apr_file_open(&fd, r->filename, APR_READ | APR_BINARY, 0, r->connection->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
 		     "file permissions deny server access: %s", r->filename);
         return HTTP_FORBIDDEN;
@@ -3017,7 +3017,7 @@ static int default_handler(request_rec *r)
     apr_table_setn(r->headers_out, "Accept-Ranges", "bytes");
     ap_set_content_length(r, r->finfo.size); 
     if ((errstatus = ap_meets_conditions(r)) != OK) {
-        apr_close(fd);
+        apr_file_close(fd);
         return errstatus;
     }
 
@@ -3027,10 +3027,10 @@ static int default_handler(request_rec *r)
     }
 
     bb = apr_brigade_create(r->pool);
-    e = apr_bucket_create_file(fd, 0, r->finfo.size);
+    e = apr_bucket_file_create(fd, 0, r->finfo.size);
 
     APR_BRIGADE_INSERT_HEAD(bb, e);
-    e = apr_bucket_create_eos();
+    e = apr_bucket_eos_create();
     APR_BRIGADE_INSERT_TAIL(bb, e);
 
     return ap_pass_brigade(r->output_filters, bb);
@@ -3139,7 +3139,7 @@ static apr_status_t coalesce_filter(ap_filter_t *f, apr_bucket_brigade *b)
 
     if (pass_the_brigade) {
         /* Insert ctx->buf into the correct spot in the brigade */
-        e = apr_bucket_create_pool(ctx->buf, ctx->cnt, p);
+        e = apr_bucket_pool_create(ctx->buf, ctx->cnt, p);
         if (insert_first) {
             APR_BRIGADE_INSERT_HEAD(b, e);
         } 
@@ -3245,14 +3245,14 @@ static apr_status_t chunk_filter(ap_filter_t *f, apr_bucket_brigade *b)
             hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr),
                                    "%qx" CRLF, (apr_uint64_t)bytes);
             ap_xlate_proto_to_ascii(chunk_hdr, hdr_len);
-            e = apr_bucket_create_transient(chunk_hdr, hdr_len);
+            e = apr_bucket_transient_create(chunk_hdr, hdr_len);
             APR_BRIGADE_INSERT_HEAD(b, e);
 
             /*
              * Insert the end-of-chunk CRLF before the EOS bucket, or
              * appended to the brigade
              */
-            e = apr_bucket_create_immortal(ASCII_CRLF, 2);
+            e = apr_bucket_immortal_create(ASCII_CRLF, 2);
             if (eos != NULL) {
                 APR_BUCKET_INSERT_BEFORE(eos, e);
             }
@@ -3276,7 +3276,7 @@ static apr_status_t chunk_filter(ap_filter_t *f, apr_bucket_brigade *b)
          */
         if (eos != NULL) {
             /* XXX: (2) trailers ... does not yet exist */
-            e = apr_bucket_create_immortal(ASCII_ZERO ASCII_CRLF /* <trailers> */ ASCII_CRLF, 5);
+            e = apr_bucket_immortal_create(ASCII_ZERO ASCII_CRLF /* <trailers> */ ASCII_CRLF, 5);
             APR_BUCKET_INSERT_BEFORE(eos, e);
         }
 
@@ -3296,7 +3296,7 @@ static int core_input_filter(ap_filter_t *f, apr_bucket_brigade *b, ap_input_mod
     
     if (!f->ctx) {    /* If we haven't passed up the socket yet... */
         f->ctx = (void *)1;
-        e = apr_bucket_create_socket(f->c->client_socket);
+        e = apr_bucket_socket_create(f->c->client_socket);
         APR_BRIGADE_INSERT_TAIL(b, e);
         return APR_SUCCESS;
     }
@@ -3474,7 +3474,7 @@ static apr_status_t core_output_filter(ap_filter_t *f, apr_bucket_brigade *b)
                                  flags);   /* apr_sendfile flags        */
     
             /* If apr_sendfile() returns APR_ENOTIMPL, call send_the_file()
-             * to loop on apr_read/apr_send to send the file. Our Windows 
+             * to loop on apr_file_read/apr_send to send the file. Our Windows 
              * binary distributions (which work on Windows 9x/NT) are 
              * compiled on Windows NT. TransmitFile is not available on 
              * Windows 95/98 and we discover this at runtime when 
@@ -3517,8 +3517,8 @@ static apr_status_t core_output_filter(ap_filter_t *f, apr_bucket_brigade *b)
 
 static void core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
 {
-    apr_init_bucket_types(pconf);
-    apr_insert_bucket_type(&ap_bucket_type_error);
+    apr_bucket_init_types(pconf);
+    apr_bucket_insert_type(&ap_bucket_type_error);
 }
 
 static void core_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
diff --git a/modules/http/http_protocol.c b/modules/http/http_protocol.c
index 668be6b..951de01 100644
--- a/modules/http/http_protocol.c
+++ b/modules/http/http_protocol.c
@@ -237,7 +237,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
             bsend = apr_brigade_create(r->pool);
             e = ap_bucket_create_error(HTTP_RANGE_NOT_SATISFIABLE, NULL, r->pool);
             APR_BRIGADE_INSERT_TAIL(bsend, e);
-            e = apr_bucket_create_eos();
+            e = apr_bucket_eos_create();
             APR_BRIGADE_INSERT_TAIL(bsend, e);
             return ap_pass_brigade(f->next, bsend);
         }
@@ -316,14 +316,14 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
         if (ctx->num_ranges > 1) {
             char *ts;
 
-            e = apr_bucket_create_pool(bound_head,
+            e = apr_bucket_pool_create(bound_head,
                                       strlen(bound_head), r->pool);
             APR_BRIGADE_INSERT_TAIL(bsend, e);
 
             ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,
                               range_start, range_end, clength);
             ap_xlate_proto_to_ascii(ts, strlen(ts));
-            e = apr_bucket_create_pool(ts, strlen(ts), r->pool);
+            e = apr_bucket_pool_create(ts, strlen(ts), r->pool);
             APR_BRIGADE_INSERT_TAIL(bsend, e);
         }
         
@@ -338,7 +338,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
 
             if (apr_bucket_copy(ec, &foo) != APR_SUCCESS) {
                 apr_bucket_read(ec, &str, &len, APR_BLOCK_READ);
-                foo = apr_bucket_create_heap(str, len, 0, NULL);
+                foo = apr_bucket_heap_create(str, len, 0, NULL);
             }
             APR_BRIGADE_INSERT_TAIL(bsend, foo);
             ec = APR_BUCKET_NEXT(ec);
@@ -357,11 +357,11 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(
         /* add the final boundary */
         end = apr_pstrcat(r->pool, CRLF "--", r->boundary, "--" CRLF, NULL);
         ap_xlate_proto_to_ascii(end, strlen(end));
-        e = apr_bucket_create_pool(end, strlen(end), r->pool);
+        e = apr_bucket_pool_create(end, strlen(end), r->pool);
         APR_BRIGADE_INSERT_TAIL(bsend, e);
     }
 
-    e = apr_bucket_create_eos();
+    e = apr_bucket_eos_create();
     APR_BRIGADE_INSERT_TAIL(bsend, e);
 
     /* we're done with the original content */
@@ -489,7 +489,7 @@ AP_DECLARE(apr_time_t) ap_rationalize_mtime(request_rec *r, apr_time_t mtime)
      * were given a time in the future, we return the current time - the
      * Last-Modified can't be in the future.
      */
-    now = (mtime < r->request_time) ? r->request_time : apr_now();
+    now = (mtime < r->request_time) ? r->request_time : apr_time_now();
     return (mtime > now) ? now : mtime;
 }
 
@@ -515,7 +515,7 @@ AP_DECLARE(int) ap_meets_conditions(request_rec *r)
     }
 
     /* XXX: we should define a "time unset" constant */
-    mtime = (r->mtime != 0) ? r->mtime : apr_now();
+    mtime = (r->mtime != 0) ? r->mtime : apr_time_now();
 
     /* If an If-Match request-header field was given
      * AND the field value is not "*" (meaning match anything)
@@ -863,7 +863,7 @@ apr_status_t ap_dechunk_filter(ap_filter_t *f, apr_bucket_brigade *bb,
                 }
                 if (ctx->chunk_size == 0) { /* we just finished the last chunk? */
                     /* append eos bucket and get out */
-                    b = apr_bucket_create_eos();
+                    b = apr_bucket_eos_create();
                     APR_BRIGADE_INSERT_TAIL(bb, b);
                     return APR_SUCCESS;
                 }
@@ -1002,7 +1002,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b, ap_input_mode
             apr_bucket_destroy(old);
         }
         if (f->c->remain == 0) {
-            apr_bucket *eos = apr_bucket_create_eos();
+            apr_bucket *eos = apr_bucket_eos_create();
                 
             APR_BRIGADE_INSERT_TAIL(b, eos);
         }
@@ -1250,7 +1250,7 @@ static int read_request_line(request_rec *r)
 	    /* this is a hack to make sure that request time is set,
 	     * it's not perfect, but it's better than nothing 
 	     */
-	    r->request_time = apr_now();
+	    r->request_time = apr_time_now();
             return 0;
         }
     }
@@ -1275,7 +1275,7 @@ static int read_request_line(request_rec *r)
     ap_bsetflag(conn->client, B_SAFEREAD, 0);
 #endif
 
-    r->request_time = apr_now();
+    r->request_time = apr_time_now();
     r->the_request = apr_pstrdup(r->pool, l);
     r->method = ap_getword_white(r->pool, &ll);
 #if 0
@@ -1332,8 +1332,8 @@ static void get_mime_headers(request_rec *r)
     int fields_read = 0;
     apr_table_t *tmp_headers;
 
-    /* We'll use apr_overlap_tables later to merge these into r->headers_in. */
-    tmp_headers = apr_make_table(r->pool, 50);
+    /* We'll use apr_table_overlap later to merge these into r->headers_in. */
+    tmp_headers = apr_table_make(r->pool, 50);
 
     /*
      * Read header lines until we get the empty separator line, a read error,
@@ -1388,7 +1388,7 @@ static void get_mime_headers(request_rec *r)
 	apr_table_addn(tmp_headers, copy, value);
     }
 
-    apr_overlap_tables(r->headers_in, tmp_headers, APR_OVERLAP_TABLES_MERGE);
+    apr_table_overlap(r->headers_in, tmp_headers, APR_OVERLAP_TABLES_MERGE);
 }
 
 request_rec *ap_read_request(conn_rec *conn)
@@ -1399,7 +1399,7 @@ request_rec *ap_read_request(conn_rec *conn)
     int access_status;
     core_request_config *req_cfg;
 
-    apr_create_pool(&p, conn->pool);
+    apr_pool_create(&p, conn->pool);
     r = apr_pcalloc(p, sizeof(request_rec));
     r->pool            = p;
     r->connection      = conn;
@@ -1413,11 +1413,11 @@ request_rec *ap_read_request(conn_rec *conn)
 
     r->allowed_methods = ap_make_method_list(p, 2);
 
-    r->headers_in      = apr_make_table(r->pool, 50);
-    r->subprocess_env  = apr_make_table(r->pool, 50);
-    r->headers_out     = apr_make_table(r->pool, 12);
-    r->err_headers_out = apr_make_table(r->pool, 5);
-    r->notes           = apr_make_table(r->pool, 5);
+    r->headers_in      = apr_table_make(r->pool, 50);
+    r->subprocess_env  = apr_table_make(r->pool, 50);
+    r->headers_out     = apr_table_make(r->pool, 12);
+    r->err_headers_out = apr_table_make(r->pool, 5);
+    r->notes           = apr_table_make(r->pool, 5);
 
     r->request_config  = ap_create_request_config(r->pool);
     req_cfg = apr_pcalloc(r->pool, sizeof(core_request_config));
@@ -1573,10 +1573,10 @@ void ap_set_sub_req_protocol(request_rec *rnew, const request_rec *r)
     rnew->status          = HTTP_OK;
 
     rnew->headers_in      = r->headers_in;
-    rnew->subprocess_env  = apr_copy_table(rnew->pool, r->subprocess_env);
-    rnew->headers_out     = apr_make_table(rnew->pool, 5);
-    rnew->err_headers_out = apr_make_table(rnew->pool, 5);
-    rnew->notes           = apr_make_table(rnew->pool, 5);
+    rnew->subprocess_env  = apr_table_copy(rnew->pool, r->subprocess_env);
+    rnew->headers_out     = apr_table_make(rnew->pool, 5);
+    rnew->err_headers_out = apr_table_make(rnew->pool, 5);
+    rnew->notes           = apr_table_make(rnew->pool, 5);
 
     rnew->expecting_100   = r->expecting_100;
     rnew->read_length     = r->read_length;
@@ -1591,7 +1591,7 @@ static void end_output_stream(request_rec *r)
     apr_bucket *b;
 
     bb = apr_brigade_create(r->pool);
-    b = apr_bucket_create_eos();
+    b = apr_bucket_eos_create();
     APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 }
@@ -1921,7 +1921,7 @@ AP_DECLARE(ap_method_list_t *) ap_make_method_list(apr_pool_t *p, int nelts)
 
     ml = (ap_method_list_t *) apr_palloc(p, sizeof(ap_method_list_t));
     ml->method_mask = 0;
-    ml->method_list = apr_make_array(p, sizeof(char *), nelts);
+    ml->method_list = apr_array_make(p, sizeof(char *), nelts);
     return ml;
 }
 
@@ -1939,7 +1939,7 @@ AP_DECLARE(void) ap_copy_method_list(ap_method_list_t *dest,
     dest->method_mask = src->method_mask;
     imethods = (char **) src->method_list->elts;
     for (i = 0; i < src->method_list->nelts; ++i) {
-	omethods = (char **) apr_push_array(dest->method_list);
+	omethods = (char **) apr_array_push(dest->method_list);
 	*omethods = apr_pstrdup(dest->method_list->cont, imethods[i]);
     }
 }
@@ -2030,7 +2030,7 @@ AP_DECLARE(void) ap_method_list_add(ap_method_list_t *l, const char *method)
 	    }
 	}
     }
-    xmethod = (const char **) apr_push_array(l->method_list);
+    xmethod = (const char **) apr_array_push(l->method_list);
     *xmethod = method;
 }
     
@@ -2188,7 +2188,7 @@ int ap_send_http_options(request_rec *r)
     r->bytes_sent = 0;
 
     bb = apr_brigade_create(r->pool);
-    b = apr_bucket_create_pool(buff, strlen(buff), r->pool);
+    b = apr_bucket_pool_create(buff, strlen(buff), r->pool);
     APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 
@@ -2240,7 +2240,7 @@ static int uniq_field_values(void *d, const char *key, const char *val)
             }
         }
         if (i == values->nelts) {  /* if not found */
-	    *(char **)apr_push_array(values) = start;
+	    *(char **)apr_array_push(values) = start;
         }
     } while (*e != '\0');
 
@@ -2256,7 +2256,7 @@ static void fixup_vary(request_rec *r)
 {
     apr_array_header_t *varies;
 
-    varies = apr_make_array(r->pool, 5, sizeof(char *));
+    varies = apr_array_make(r->pool, 5, sizeof(char *));
 
     /* Extract all Vary fields from the headers_out, separate each into
      * its comma-separated fieldname values, and then add them to varies
@@ -2504,7 +2504,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f, apr_b
      * later attempts to set or unset a given fieldname might be bypassed.
      */
     if (!apr_is_empty_table(r->err_headers_out))
-        r->headers_out = apr_overlay_tables(r->pool, r->err_headers_out,
+        r->headers_out = apr_table_overlay(r->pool, r->err_headers_out,
                                         r->headers_out);
 
     /*
@@ -2633,7 +2633,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f, apr_b
     r->sent_bodyct = 1;         /* Whatever follows is real body stuff... */
 
     b2 = apr_brigade_create(r->pool);
-    e = apr_bucket_create_pool(buff_start, strlen(buff_start), r->pool);
+    e = apr_bucket_pool_create(buff_start, strlen(buff_start), r->pool);
     APR_BRIGADE_INSERT_HEAD(b2, e);
     ap_pass_brigade(f->next, b2);
 
@@ -2796,9 +2796,9 @@ AP_DECLARE(int) ap_should_client_block(request_rec *r)
         tmp = apr_pstrcat(r->pool, AP_SERVER_PROTOCOL, " ", status_lines[0],
                                 CRLF CRLF, NULL);
         bb = apr_brigade_create(r->pool);
-        e = apr_bucket_create_pool(tmp, strlen(tmp), r->pool);
+        e = apr_bucket_pool_create(tmp, strlen(tmp), r->pool);
         APR_BRIGADE_INSERT_HEAD(bb, e);
-        e = apr_bucket_create_flush();
+        e = apr_bucket_flush_create();
         APR_BRIGADE_INSERT_TAIL(bb, e);
 
         ap_pass_brigade(r->connection->output_filters, bb);
@@ -2955,7 +2955,7 @@ AP_DECLARE(apr_status_t) ap_send_fd(apr_file_t *fd, request_rec *r, apr_off_t of
     apr_status_t rv;
 
     bb = apr_brigade_create(r->pool);
-    b = apr_bucket_create_file(fd, offset, len);
+    b = apr_bucket_file_create(fd, offset, len);
     APR_BRIGADE_INSERT_TAIL(bb, b);
 
     rv = ap_pass_brigade(r->output_filters, bb);
@@ -2978,7 +2978,7 @@ AP_DECLARE(size_t) ap_send_mmap(apr_mmap_t *mm, request_rec *r, size_t offset,
     apr_bucket *b;
 
     bb = apr_brigade_create(r->pool);
-    b = apr_bucket_create_mmap(mm, offset, length);
+    b = apr_bucket_mmap_create(mm, offset, length);
     APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 
@@ -3006,7 +3006,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_old_write_filter(
             /* whatever is coming down the pipe (we don't care), we
                can simply insert our buffered data at the front and
                pass the whole bundle down the chain. */
-            apr_bucket *b = apr_bucket_create_heap(ctx->buf, nbyte, 0, NULL);
+            apr_bucket *b = apr_bucket_heap_create(ctx->buf, nbyte, 0, NULL);
             APR_BRIGADE_INSERT_HEAD(bb, b);
             ctx->buf = NULL;
         }
@@ -3020,14 +3020,14 @@ static apr_status_t flush_buffer(request_rec *r, old_write_filter_ctx *ctx,
 {
     apr_bucket_brigade *bb = apr_brigade_create(r->pool);
     apr_size_t nbyte = ctx->cur - ctx->buf;
-    apr_bucket *b = apr_bucket_create_heap(ctx->buf, nbyte, 0, NULL);
+    apr_bucket *b = apr_bucket_heap_create(ctx->buf, nbyte, 0, NULL);
 
     APR_BRIGADE_INSERT_TAIL(bb, b);
     ctx->buf = NULL;
 
     /* if there is extra data, then send that, too */
     if (extra != NULL) {
-        b = apr_bucket_create_transient(extra, extra_len);
+        b = apr_bucket_transient_create(extra, extra_len);
         APR_BRIGADE_INSERT_TAIL(bb, b);
     }
 
@@ -3062,7 +3062,7 @@ static apr_status_t buffer_output(request_rec *r,
        deliver the content through the normal filter chain */
     if (strcmp("OLD_WRITE", r->output_filters->frec->name) != 0) {
         apr_bucket_brigade *bb = apr_brigade_create(r->pool);
-        apr_bucket *b = apr_bucket_create_transient(str, len);
+        apr_bucket *b = apr_bucket_transient_create(str, len);
         APR_BRIGADE_INSERT_TAIL(bb, b);
 
         return ap_pass_brigade(r->output_filters, bb);
@@ -3217,7 +3217,7 @@ AP_DECLARE(int) ap_rflush(request_rec *r)
     apr_bucket *b;
 
     bb = apr_brigade_create(r->pool);
-    b = apr_bucket_create_flush();
+    b = apr_bucket_flush_create();
     APR_BRIGADE_INSERT_TAIL(bb, b);
     if (ap_pass_brigade(r->output_filters, bb) != APR_SUCCESS)
         return -1;
@@ -3531,7 +3531,7 @@ AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)
          */
         r->headers_out = r->err_headers_out;
         r->err_headers_out = tmp;
-        apr_clear_table(r->err_headers_out);
+        apr_table_clear(r->err_headers_out);
 
         if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {
             if ((location != NULL) && *location) {
diff --git a/modules/http/http_request.c b/modules/http/http_request.c
index 178afb0..1a71bc5 100644
--- a/modules/http/http_request.c
+++ b/modules/http/http_request.c
@@ -794,7 +794,7 @@ static request_rec *make_sub_request(const request_rec *r)
     apr_pool_t *rrp;
     request_rec *rr;
     
-    apr_create_pool(&rrp, r->pool);
+    apr_pool_create(&rrp, r->pool);
     rr = apr_pcalloc(rrp, sizeof(request_rec));
     rr->pool = rrp;
     return rr;
@@ -1077,7 +1077,7 @@ AP_DECLARE(int) ap_run_sub_req(request_rec *r)
 AP_DECLARE(void) ap_destroy_sub_req(request_rec *r)
 {
     /* Reclaim the space */
-    apr_destroy_pool(r->pool);
+    apr_pool_destroy(r->pool);
 }
 
 /*****************************************************************
@@ -1385,7 +1385,7 @@ static void check_pipeline_flush(request_rec *r)
     /* ### shouldn't this read from the connection input filters? */
     if (!r->connection->keepalive || 
         ap_get_brigade(r->input_filters, bb, AP_MODE_PEEK) != APR_SUCCESS) {
-        apr_bucket *e = apr_bucket_create_flush();
+        apr_bucket *e = apr_bucket_flush_create();
 
         /* We just send directly to the connection based filters.  At
          * this point, we know that we have seen all of the data
@@ -1417,7 +1417,7 @@ static apr_table_t *rename_original_env(apr_pool_t *p, apr_table_t *t)
 {
     apr_array_header_t *env_arr = apr_table_elts(t);
     apr_table_entry_t *elts = (apr_table_entry_t *) env_arr->elts;
-    apr_table_t *new = apr_make_table(p, env_arr->nalloc);
+    apr_table_t *new = apr_table_make(p, env_arr->nalloc);
     int i;
 
     for (i = 0; i < env_arr->nelts; ++i) {
@@ -1478,10 +1478,10 @@ static request_rec *internal_internal_redirect(const char *new_uri,
     new->main            = r->main;
 
     new->headers_in      = r->headers_in;
-    new->headers_out     = apr_make_table(r->pool, 12);
+    new->headers_out     = apr_table_make(r->pool, 12);
     new->err_headers_out = r->err_headers_out;
     new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);
-    new->notes           = apr_make_table(r->pool, 5);
+    new->notes           = apr_table_make(r->pool, 5);
     new->allowed_methods = ap_make_method_list(new->pool, 2);
 
     new->htaccess        = r->htaccess;
diff --git a/modules/http/mod_mime.c b/modules/http/mod_mime.c
index 2a3a8af..2b6cde3 100644
--- a/modules/http/mod_mime.c
+++ b/modules/http/mod_mime.c
@@ -138,15 +138,15 @@ static void *create_mime_dir_config(apr_pool_t *p, char *dummy)
     mime_dir_config *new =
     (mime_dir_config *) apr_palloc(p, sizeof(mime_dir_config));
 
-    new->forced_types = apr_make_table(p, 4);
-    new->encoding_types = apr_make_table(p, 4);
-    new->charset_types = apr_make_table(p, 4);
-    new->language_types = apr_make_table(p, 4);
-    new->filter_names = apr_make_table(p, 4);
-    new->handlers = apr_make_table(p, 4);
-    new->handlers_remove = apr_make_array(p, 4, sizeof(attrib_info));
-    new->types_remove = apr_make_array(p, 4, sizeof(attrib_info));
-    new->encodings_remove = apr_make_array(p, 4, sizeof(attrib_info));
+    new->forced_types = apr_table_make(p, 4);
+    new->encoding_types = apr_table_make(p, 4);
+    new->charset_types = apr_table_make(p, 4);
+    new->language_types = apr_table_make(p, 4);
+    new->filter_names = apr_table_make(p, 4);
+    new->handlers = apr_table_make(p, 4);
+    new->handlers_remove = apr_array_make(p, 4, sizeof(attrib_info));
+    new->types_remove = apr_array_make(p, 4, sizeof(attrib_info));
+    new->encodings_remove = apr_array_make(p, 4, sizeof(attrib_info));
 
     new->type = NULL;
     new->handler = NULL;
@@ -164,17 +164,17 @@ static void *merge_mime_dir_configs(apr_pool_t *p, void *basev, void *addv)
     int i;
     attrib_info *suffix;
 
-    new->forced_types = apr_overlay_tables(p, add->forced_types,
+    new->forced_types = apr_table_overlay(p, add->forced_types,
 					 base->forced_types);
-    new->encoding_types = apr_overlay_tables(p, add->encoding_types,
+    new->encoding_types = apr_table_overlay(p, add->encoding_types,
                                          base->encoding_types);
-    new->charset_types = apr_overlay_tables(p, add->charset_types,
+    new->charset_types = apr_table_overlay(p, add->charset_types,
 					   base->charset_types);
-    new->language_types = apr_overlay_tables(p, add->language_types,
+    new->language_types = apr_table_overlay(p, add->language_types,
                                          base->language_types);
-    new->filter_names = apr_overlay_tables(p, add->filter_names,
+    new->filter_names = apr_table_overlay(p, add->filter_names,
                                    base->filter_names);
-    new->handlers = apr_overlay_tables(p, add->handlers,
+    new->handlers = apr_table_overlay(p, add->handlers,
                                    base->handlers);
 
     suffix = (attrib_info *) add->handlers_remove->elts;
@@ -293,7 +293,7 @@ static const char *remove_handler(cmd_parms *cmd, void *m, const char *ext)
     if (*ext == '.') {
         ++ext;
     }
-    suffix = (attrib_info *) apr_push_array(mcfg->handlers_remove);
+    suffix = (attrib_info *) apr_array_push(mcfg->handlers_remove);
     suffix->name = apr_pstrdup(cmd->pool, ext);
     return NULL;
 }
@@ -310,7 +310,7 @@ static const char *remove_encoding(cmd_parms *cmd, void *m, const char *ext)
     if (*ext == '.') {
         ++ext;
     }
-    suffix = (attrib_info *) apr_push_array(mcfg->encodings_remove);
+    suffix = (attrib_info *) apr_array_push(mcfg->encodings_remove);
     suffix->name = apr_pstrdup(cmd->pool, ext);
     return NULL;
 }
@@ -327,7 +327,7 @@ static const char *remove_type(cmd_parms *cmd, void *m, const char *ext)
     if (*ext == '.') {
         ++ext;
     }
-    suffix = (attrib_info *) apr_push_array(mcfg->types_remove);
+    suffix = (attrib_info *) apr_array_push(mcfg->types_remove);
     suffix->name = apr_pstrdup(cmd->pool, ext);
     return NULL;
 }
@@ -407,7 +407,7 @@ static void mime_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
     }
 
     for (x = 0; x < MIME_HASHSIZE; x++)
-        hash_buckets[x] = apr_make_table(p, 10);
+        hash_buckets[x] = apr_table_make(p, 10);
 
     while (!(ap_cfg_getline(l, MAX_STRING_LEN, f))) {
         const char *ll = l, *ct;
@@ -717,8 +717,8 @@ static int find_ct(request_rec *r)
 
             r->content_language = type;         /* back compat. only */
             if (!r->content_languages)
-                r->content_languages = apr_make_array(r->pool, 2, sizeof(char *));
-            new = (const char **) apr_push_array(r->content_languages);
+                r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));
+            new = (const char **) apr_array_push(r->content_languages);
             *new = type;
             found = 1;
         }
@@ -806,8 +806,8 @@ static int find_ct(request_rec *r)
 
         r->content_language = conf->default_language; /* back compat. only */
         if (!r->content_languages)
-            r->content_languages = apr_make_array(r->pool, 2, sizeof(char *));
-        new = (const char **) apr_push_array(r->content_languages);
+            r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));
+        new = (const char **) apr_array_push(r->content_languages);
         *new = conf->default_language;
     }
 
diff --git a/modules/loggers/mod_log_config.c b/modules/loggers/mod_log_config.c
index e3bdee4..16c9f52 100644
--- a/modules/loggers/mod_log_config.c
+++ b/modules/loggers/mod_log_config.c
@@ -455,7 +455,7 @@ static const char *log_request_time(request_rec *r, char *a)
 	a problem with this, you can set the define.  -djg
     */
 #ifdef I_INSIST_ON_EXTRA_CYCLES_FOR_CLF_COMPLIANCE
-    apr_explode_localtime(&xt, apr_now());
+    apr_explode_localtime(&xt, apr_time_now());
 #else
     apr_explode_localtime(&xt, r->request_time);
 #endif
@@ -486,7 +486,7 @@ static const char *log_request_time(request_rec *r, char *a)
 
 static const char *log_request_duration(request_rec *r, char *a)
 {
-    return apr_psprintf(r->pool, "%ld", (apr_now() - r->request_time) 
+    return apr_psprintf(r->pool, "%ld", (apr_time_now() - r->request_time) 
                                              / APR_USEC_PER_SEC);
 }
 
@@ -754,9 +754,9 @@ static char *parse_log_item(apr_pool_t *p, log_format_item *it, const char **sa)
                 i = i * 10 + (*s) - '0';
             }
             if (!it->conditions) {
-                it->conditions = apr_make_array(p, 4, sizeof(int));
+                it->conditions = apr_array_make(p, 4, sizeof(int));
             }
-            *(int *) apr_push_array(it->conditions) = i;
+            *(int *) apr_array_push(it->conditions) = i;
             break;
 
         default:
@@ -783,18 +783,18 @@ static char *parse_log_item(apr_pool_t *p, log_format_item *it, const char **sa)
 
 static apr_array_header_t *parse_log_string(apr_pool_t *p, const char *s, const char **err)
 {
-    apr_array_header_t *a = apr_make_array(p, 30, sizeof(log_format_item));
+    apr_array_header_t *a = apr_array_make(p, 30, sizeof(log_format_item));
     char *res;
 
     while (*s) {
-        if ((res = parse_log_item(p, (log_format_item *) apr_push_array(a), &s))) {
+        if ((res = parse_log_item(p, (log_format_item *) apr_array_push(a), &s))) {
             *err = res;
             return NULL;
         }
     }
 
     s = APR_EOL_STR;
-    parse_log_item(p, (log_format_item *) apr_push_array(a), &s);
+    parse_log_item(p, (log_format_item *) apr_array_push(a), &s);
     return a;
 }
 
@@ -838,7 +838,7 @@ static const char *process_item(request_rec *r, request_rec *orig,
 static void flush_log(config_log_state *cls)
 {
     if (cls->outcnt && cls->log_fd != NULL) {
-        apr_write(cls->log_fd, cls->outbuf, &cls->outcnt);
+        apr_file_write(cls->log_fd, cls->outbuf, &cls->outcnt);
         cls->outcnt = 0;
     }
 }
@@ -914,7 +914,7 @@ static int config_log_transaction(request_rec *r, config_log_state *cls,
             s += strl[i];
         }
         w = len;
-        apr_write(cls->log_fd, str, &w);
+        apr_file_write(cls->log_fd, str, &w);
     }
     else {
         for (i = 0, s = &cls->outbuf[cls->outcnt]; i < format->nelts; ++i) {
@@ -931,7 +931,7 @@ static int config_log_transaction(request_rec *r, config_log_state *cls,
         s += strl[i];
     }
 
-    apr_write(cls->log_fd, str, &len);
+    apr_file_write(cls->log_fd, str, &len);
 #endif
 
     return OK;
@@ -977,11 +977,11 @@ static void *make_config_log_state(apr_pool_t *p, server_rec *s)
     multi_log_state *mls;
 
     mls = (multi_log_state *) apr_palloc(p, sizeof(multi_log_state));
-    mls->config_logs = apr_make_array(p, 1, sizeof(config_log_state));
+    mls->config_logs = apr_array_make(p, 1, sizeof(config_log_state));
     mls->default_format_string = NULL;
     mls->default_format = NULL;
     mls->server_config_logs = NULL;
-    mls->formats = apr_make_table(p, 4);
+    mls->formats = apr_table_make(p, 4);
     apr_table_setn(mls->formats, "CLF", DEFAULT_LOG_FORMAT);
 
     return mls;
@@ -1003,7 +1003,7 @@ static void *merge_config_log_state(apr_pool_t *p, void *basev, void *addv)
         add->default_format_string = base->default_format_string;
         add->default_format = base->default_format;
     }
-    add->formats = apr_overlay_tables(p, base->formats, add->formats);
+    add->formats = apr_table_overlay(p, base->formats, add->formats);
 
     return add;
 }
@@ -1045,7 +1045,7 @@ static const char *add_custom_log(cmd_parms *cmd, void *dummy, const char *fn,
 						&config_log_module);
     config_log_state *cls;
 
-    cls = (config_log_state *) apr_push_array(mls->config_logs);
+    cls = (config_log_state *) apr_array_push(mls->config_logs);
     cls->condition_var = NULL;
     if (envclause != NULL) {
 	if (strncasecmp(envclause, "env=", 4) != 0) {
@@ -1121,7 +1121,7 @@ static config_log_state *open_config_log(server_rec *s, apr_pool_t *p,
     }
     else {
         const char *fname = ap_server_root_relative(p, cls->fname);
-        if ((status = apr_open(&cls->log_fd, fname, xfer_flags, xfer_perms, p)) 
+        if ((status = apr_file_open(&cls->log_fd, fname, xfer_flags, xfer_perms, p)) 
             != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR, status, s,
                          "could not open transfer log file %s.", fname);
@@ -1237,7 +1237,7 @@ static void init_child(apr_pool_t *p, server_rec *s)
 {
 #ifdef BUFFERED_LOGS
 	/* Now register the last buffer flush with the cleanup engine */
-	apr_register_cleanup(p, s, flush_all_logs, flush_all_logs);
+	apr_pool_cleanup_register(p, s, flush_all_logs, flush_all_logs);
 #endif
 }
 
diff --git a/modules/mappers/mod_actions.c b/modules/mappers/mod_actions.c
index 8c28246..1bd74fe 100644
--- a/modules/mappers/mod_actions.c
+++ b/modules/mappers/mod_actions.c
@@ -101,7 +101,7 @@ static void *create_action_dir_config(apr_pool_t *p, char *dummy)
     action_dir_config *new =
     (action_dir_config *) apr_pcalloc(p, sizeof(action_dir_config));
 
-    new->action_types = apr_make_table(p, 4);
+    new->action_types = apr_table_make(p, 4);
 
     return new;
 }
@@ -114,7 +114,7 @@ static void *merge_action_dir_configs(apr_pool_t *p, void *basev, void *addv)
                                   sizeof(action_dir_config));
     int i;
 
-    new->action_types = apr_overlay_tables(p, add->action_types,
+    new->action_types = apr_table_overlay(p, add->action_types,
 				       base->action_types);
 
     for (i = 0; i < METHODS; ++i) {
diff --git a/modules/mappers/mod_alias.c b/modules/mappers/mod_alias.c
index e9e9049..a7915d6 100644
--- a/modules/mappers/mod_alias.c
+++ b/modules/mappers/mod_alias.c
@@ -97,8 +97,8 @@ static void *create_alias_config(apr_pool_t *p, server_rec *s)
     alias_server_conf *a =
     (alias_server_conf *) apr_pcalloc(p, sizeof(alias_server_conf));
 
-    a->aliases = apr_make_array(p, 20, sizeof(alias_entry));
-    a->redirects = apr_make_array(p, 20, sizeof(alias_entry));
+    a->aliases = apr_array_make(p, 20, sizeof(alias_entry));
+    a->redirects = apr_array_make(p, 20, sizeof(alias_entry));
     return a;
 }
 
@@ -106,7 +106,7 @@ static void *create_alias_dir_config(apr_pool_t *p, char *d)
 {
     alias_dir_conf *a =
     (alias_dir_conf *) apr_pcalloc(p, sizeof(alias_dir_conf));
-    a->redirects = apr_make_array(p, 2, sizeof(alias_entry));
+    a->redirects = apr_array_make(p, 2, sizeof(alias_entry));
     return a;
 }
 
@@ -116,8 +116,8 @@ static void *merge_alias_config(apr_pool_t *p, void *basev, void *overridesv)
     (alias_server_conf *) apr_pcalloc(p, sizeof(alias_server_conf));
     alias_server_conf *base = (alias_server_conf *) basev, *overrides = (alias_server_conf *) overridesv;
 
-    a->aliases = apr_append_arrays(p, overrides->aliases, base->aliases);
-    a->redirects = apr_append_arrays(p, overrides->redirects, base->redirects);
+    a->aliases = apr_array_append(p, overrides->aliases, base->aliases);
+    a->redirects = apr_array_append(p, overrides->redirects, base->redirects);
     return a;
 }
 
@@ -126,7 +126,7 @@ static void *merge_alias_dir_config(apr_pool_t *p, void *basev, void *overridesv
     alias_dir_conf *a =
     (alias_dir_conf *) apr_pcalloc(p, sizeof(alias_dir_conf));
     alias_dir_conf *base = (alias_dir_conf *) basev, *overrides = (alias_dir_conf *) overridesv;
-    a->redirects = apr_append_arrays(p, overrides->redirects, base->redirects);
+    a->redirects = apr_array_append(p, overrides->redirects, base->redirects);
     return a;
 }
 
@@ -137,7 +137,7 @@ static const char *add_alias_internal(cmd_parms *cmd, void *dummy,
     server_rec *s = cmd->server;
     alias_server_conf *conf =
     (alias_server_conf *) ap_get_module_config(s->module_config, &alias_module);
-    alias_entry *new = apr_push_array(conf->aliases);
+    alias_entry *new = apr_array_push(conf->aliases);
 
     /* XX r can NOT be relative to DocumentRoot here... compat bug. */
 
@@ -219,9 +219,9 @@ static const char *add_redirect_internal(cmd_parms *cmd,
     }
 
     if (cmd->path)
-	new = apr_push_array(dirconf->redirects);
+	new = apr_array_push(dirconf->redirects);
     else
-	new = apr_push_array(serverconf->redirects);
+	new = apr_array_push(serverconf->redirects);
 
     new->fake = f;
     new->real = url;
diff --git a/modules/mappers/mod_dir.c b/modules/mappers/mod_dir.c
index 15e7771..7dd48d5 100644
--- a/modules/mappers/mod_dir.c
+++ b/modules/mappers/mod_dir.c
@@ -84,9 +84,9 @@ static const char *add_index(cmd_parms *cmd, void *dummy, const char *arg)
     dir_config_rec *d = dummy;
 
     if (!d->index_names) {
-	d->index_names = apr_make_array(cmd->pool, 2, sizeof(char *));
+	d->index_names = apr_array_make(cmd->pool, 2, sizeof(char *));
     }
-    *(const char **)apr_push_array(d->index_names) = arg;
+    *(const char **)apr_array_push(d->index_names) = arg;
     return NULL;
 }
 
@@ -187,10 +187,10 @@ static int handle_dir(request_rec *r)
 
             apr_pool_join(r->pool, rr->pool);
             error_notfound = rr->status;
-            r->notes = apr_overlay_tables(r->pool, r->notes, rr->notes);
-            r->headers_out = apr_overlay_tables(r->pool, r->headers_out,
+            r->notes = apr_table_overlay(r->pool, r->notes, rr->notes);
+            r->headers_out = apr_table_overlay(r->pool, r->headers_out,
                                             rr->headers_out);
-            r->err_headers_out = apr_overlay_tables(r->pool, r->err_headers_out,
+            r->err_headers_out = apr_table_overlay(r->pool, r->err_headers_out,
                                                 rr->err_headers_out);
             return error_notfound;
         }
diff --git a/modules/mappers/mod_negotiation.c b/modules/mappers/mod_negotiation.c
index f6e6f4f..3b4d691 100644
--- a/modules/mappers/mod_negotiation.c
+++ b/modules/mappers/mod_negotiation.c
@@ -102,7 +102,7 @@ static void *create_neg_dir_config(apr_pool_t *p, char *dummy)
 {
     neg_dir_config *new = (neg_dir_config *) apr_palloc(p, sizeof(neg_dir_config));
 
-    new->language_priority = apr_make_array(p, 4, sizeof(char *));
+    new->language_priority = apr_array_make(p, 4, sizeof(char *));
     return new;
 }
 
@@ -113,7 +113,7 @@ static void *merge_neg_dir_configs(apr_pool_t *p, void *basev, void *addv)
     neg_dir_config *new = (neg_dir_config *) apr_palloc(p, sizeof(neg_dir_config));
 
     /* give priority to the config in the subdirectory */
-    new->language_priority = apr_append_arrays(p, add->language_priority,
+    new->language_priority = apr_array_append(p, add->language_priority,
                                            base->language_priority);
     return new;
 }
@@ -122,7 +122,7 @@ static const char *set_language_priority(cmd_parms *cmd, void *n,
 					 const char *lang)
 {
     apr_array_header_t *arr = ((neg_dir_config *) n)->language_priority;
-    const char **langp = (const char **) apr_push_array(arr);
+    const char **langp = (const char **) apr_array_push(arr);
 
     *langp = lang;
     return NULL;
@@ -444,10 +444,10 @@ static apr_array_header_t *do_header_line(apr_pool_t *p, const char *accept_line
         return NULL;
     }
 
-    accept_recs = apr_make_array(p, 40, sizeof(accept_rec));
+    accept_recs = apr_array_make(p, 40, sizeof(accept_rec));
 
     while (*accept_line) {
-        accept_rec *new = (accept_rec *) apr_push_array(accept_recs);
+        accept_rec *new = (accept_rec *) apr_array_push(accept_recs);
         accept_line = get_entry(p, new, accept_line);
     }
 
@@ -460,14 +460,14 @@ static apr_array_header_t *do_header_line(apr_pool_t *p, const char *accept_line
 
 static apr_array_header_t *do_languages_line(apr_pool_t *p, const char **lang_line)
 {
-    apr_array_header_t *lang_recs = apr_make_array(p, 2, sizeof(char *));
+    apr_array_header_t *lang_recs = apr_array_make(p, 2, sizeof(char *));
 
     if (!lang_line) {
         return lang_recs;
     }
 
     while (**lang_line) {
-        char **new = (char **) apr_push_array(lang_recs);
+        char **new = (char **) apr_array_push(lang_recs);
         *new = ap_get_token(p, lang_line, 0);
         ap_str_tolower(*new);
         if (**lang_line == ',' || **lang_line == ';') {
@@ -515,7 +515,7 @@ static negotiation_state *parse_accept_headers(request_rec *r)
     new->accept_charsets =
         do_header_line(r->pool, apr_table_get(hdrs, "Accept-Charset"));
 
-    new->avail_vars = apr_make_array(r->pool, 40, sizeof(var_rec));
+    new->avail_vars = apr_array_make(r->pool, 40, sizeof(var_rec));
 
     return new;
 }
@@ -620,16 +620,16 @@ static void maybe_add_default_accepts(negotiation_state *neg,
     accept_rec *new_accept;
 
     if (!neg->accepts) {
-        neg->accepts = apr_make_array(neg->pool, 4, sizeof(accept_rec));
+        neg->accepts = apr_array_make(neg->pool, 4, sizeof(accept_rec));
 
-        new_accept = (accept_rec *) apr_push_array(neg->accepts);
+        new_accept = (accept_rec *) apr_array_push(neg->accepts);
         
         new_accept->name = "*/*";
         new_accept->quality = 1.0f;
         new_accept->level = 0.0f;
     }    
 
-    new_accept = (accept_rec *) apr_push_array(neg->accepts);
+    new_accept = (accept_rec *) apr_array_push(neg->accepts);
 
     new_accept->name = CGI_MAGIC_TYPE;
     if (neg->use_rvsa) {
@@ -664,7 +664,7 @@ static enum header_state get_header_line(char *buffer, int len, apr_file_t *map)
     /* Get a noncommented line */
 
     do {
-        if (apr_fgets(buffer, MAX_STRING_LEN, map) != APR_SUCCESS) {
+        if (apr_file_gets(buffer, MAX_STRING_LEN, map) != APR_SUCCESS) {
             return header_eof;
         }
     } while (buffer[0] == '#');
@@ -685,10 +685,10 @@ static enum header_state get_header_line(char *buffer, int len, apr_file_t *map)
 
     cp += strlen(cp);
 
-    while (apr_getc(&c, map) != APR_EOF) {
+    while (apr_file_getc(&c, map) != APR_EOF) {
         if (c == '#') {
             /* Comment line */
-            while (apr_getc(&c, map) != EOF && c != '\n') {
+            while (apr_file_getc(&c, map) != EOF && c != '\n') {
                 continue;
             }
         }
@@ -699,11 +699,11 @@ static enum header_state get_header_line(char *buffer, int len, apr_file_t *map)
              */
 
             while (c != '\n' && apr_isspace(c)) {
-                if(apr_getc(&c, map) != APR_SUCCESS)
+                if(apr_file_getc(&c, map) != APR_SUCCESS)
 		    break;
             }
 
-            apr_ungetc(c, map);
+            apr_file_ungetc(c, map);
 
             if (c == '\n') {
                 return header_seen;     /* Blank line */
@@ -711,7 +711,7 @@ static enum header_state get_header_line(char *buffer, int len, apr_file_t *map)
 
             /* Continuation */
 
-            while (cp < buf_end - 2 && (apr_getc(&c, map)) != EOF && c != '\n') {
+            while (cp < buf_end - 2 && (apr_file_getc(&c, map)) != EOF && c != '\n') {
                 *cp++ = c;
             }
 
@@ -722,7 +722,7 @@ static enum header_state get_header_line(char *buffer, int len, apr_file_t *map)
 
             /* Line beginning with something other than whitespace */
 
-            apr_ungetc(c, map);
+            apr_file_ungetc(c, map);
             return header_seen;
         }
     }
@@ -803,7 +803,7 @@ static int read_type_map(negotiation_state *neg, request_rec *rr)
     /* We are not using multiviews */
     neg->count_multiviews_variants = 0;
 
-    if ((status = apr_open(&map, rr->filename, APR_READ,
+    if ((status = apr_file_open(&map, rr->filename, APR_READ,
                 APR_OS_DEFAULT, neg->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
                       "cannot access type map file: %s", rr->filename);
@@ -863,7 +863,7 @@ static int read_type_map(negotiation_state *neg, request_rec *rr)
         }
         else {
             if (*mime_info.file_name && has_content) {
-                void *new_var = apr_push_array(neg->avail_vars);
+                void *new_var = apr_array_push(neg->avail_vars);
 
                 memcpy(new_var, (void *) &mime_info, sizeof(var_rec));
             }
@@ -873,7 +873,7 @@ static int read_type_map(negotiation_state *neg, request_rec *rr)
         }
     } while (hstate != header_eof);
 
-    apr_close(map);
+    apr_file_close(map);
 
     set_vlist_validator(r, rr);
 
@@ -999,7 +999,7 @@ static int read_types_multi(negotiation_state *neg)
         get_entry(neg->pool, &accept_info, sub_req->content_type);
         set_mime_fields(&mime_info, &accept_info);
 
-        new_var = apr_push_array(neg->avail_vars);
+        new_var = apr_array_push(neg->avail_vars);
         memcpy(new_var, (void *) &mime_info, sizeof(var_rec));
 
         neg->count_multiviews_variants++;
@@ -2080,7 +2080,7 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
      * need to change the calculation of max_vlist_array above.
      */
     if (neg->send_alternates && neg->avail_vars->nelts)
-        arr = apr_make_array(r->pool, max_vlist_array, sizeof(char *));
+        arr = apr_array_make(r->pool, max_vlist_array, sizeof(char *));
     else
         arr = NULL;
 
@@ -2138,9 +2138,9 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
 
         /* Generate the string components for this Alternates entry */
 
-        *((const char **) apr_push_array(arr)) = "{\"";
-        *((const char **) apr_push_array(arr)) = variant->file_name;
-        *((const char **) apr_push_array(arr)) = "\" ";
+        *((const char **) apr_array_push(arr)) = "{\"";
+        *((const char **) apr_array_push(arr)) = variant->file_name;
+        *((const char **) apr_array_push(arr)) = "\" ";
 
         qstr = (char *) apr_palloc(r->pool, 6);
         apr_snprintf(qstr, 6, "%1.3f", variant->source_quality);
@@ -2155,29 +2155,29 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
                 }
             }
         }
-        *((const char **) apr_push_array(arr)) = qstr;
+        *((const char **) apr_array_push(arr)) = qstr;
 
         if (variant->mime_type && *variant->mime_type) {
-            *((const char **) apr_push_array(arr)) = " {type ";
-            *((const char **) apr_push_array(arr)) = variant->mime_type;
-            *((const char **) apr_push_array(arr)) = "}";
+            *((const char **) apr_array_push(arr)) = " {type ";
+            *((const char **) apr_array_push(arr)) = variant->mime_type;
+            *((const char **) apr_array_push(arr)) = "}";
         }
         if (variant->content_charset && *variant->content_charset) {
-            *((const char **) apr_push_array(arr)) = " {charset ";
-            *((const char **) apr_push_array(arr)) = variant->content_charset;
-            *((const char **) apr_push_array(arr)) = "}";
+            *((const char **) apr_array_push(arr)) = " {charset ";
+            *((const char **) apr_array_push(arr)) = variant->content_charset;
+            *((const char **) apr_array_push(arr)) = "}";
         }
         if (lang) {
-            *((const char **) apr_push_array(arr)) = " {language ";
-            *((const char **) apr_push_array(arr)) = lang;
-            *((const char **) apr_push_array(arr)) = "}";
+            *((const char **) apr_array_push(arr)) = " {language ";
+            *((const char **) apr_array_push(arr)) = lang;
+            *((const char **) apr_array_push(arr)) = "}";
         }
         if (variant->content_encoding && *variant->content_encoding) {
             /* Strictly speaking, this is non-standard, but so is TCN */
 
-            *((const char **) apr_push_array(arr)) = " {encoding ";
-            *((const char **) apr_push_array(arr)) = variant->content_encoding;
-            *((const char **) apr_push_array(arr)) = "}";
+            *((const char **) apr_array_push(arr)) = " {encoding ";
+            *((const char **) apr_array_push(arr)) = variant->content_encoding;
+            *((const char **) apr_array_push(arr)) = "}";
         }
 
         /* Note that the Alternates specification (in rfc2295) does
@@ -2200,13 +2200,13 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
 
             lenstr = (char *) apr_palloc(r->pool, 22);
             apr_snprintf(lenstr, 22, "%ld", len);
-            *((const char **) apr_push_array(arr)) = " {length ";
-            *((const char **) apr_push_array(arr)) = lenstr;
-            *((const char **) apr_push_array(arr)) = "}";
+            *((const char **) apr_array_push(arr)) = " {length ";
+            *((const char **) apr_array_push(arr)) = lenstr;
+            *((const char **) apr_array_push(arr)) = "}";
         }
       
-        *((const char **) apr_push_array(arr)) = "}";
-        *((const char **) apr_push_array(arr)) = ", "; /* trimmed below */
+        *((const char **) apr_array_push(arr)) = "}";
+        *((const char **) apr_array_push(arr)) = ", "; /* trimmed below */
     }
 
     if (neg->send_alternates && neg->avail_vars->nelts) {
@@ -2248,9 +2248,9 @@ static char *make_variant_list(request_rec *r, negotiation_state *neg)
      * we preallocate a apr_table_t with the maximum substrings possible,
      * fill it with the variant list, and then concatenate the entire array.
      */
-    arr = apr_make_array(r->pool, max_vlist_array, sizeof(char *));
+    arr = apr_array_make(r->pool, max_vlist_array, sizeof(char *));
 
-    *((const char **) apr_push_array(arr)) = "Available variants:\n<ul>\n";
+    *((const char **) apr_array_push(arr)) = "Available variants:\n<ul>\n";
 
     for (i = 0; i < neg->avail_vars->nelts; ++i) {
         var_rec *variant = &((var_rec *) neg->avail_vars->elts)[i];
@@ -2263,33 +2263,33 @@ static char *make_variant_list(request_rec *r, negotiation_state *neg)
          * Note that if you change the number of substrings pushed, you also
          * need to change the calculation of max_vlist_array above.
          */
-        *((const char **) apr_push_array(arr)) = "<li><a href=\"";
-        *((const char **) apr_push_array(arr)) = filename;
-        *((const char **) apr_push_array(arr)) = "\">";
-        *((const char **) apr_push_array(arr)) = filename;
-        *((const char **) apr_push_array(arr)) = "</a> ";
-        *((const char **) apr_push_array(arr)) = description;
+        *((const char **) apr_array_push(arr)) = "<li><a href=\"";
+        *((const char **) apr_array_push(arr)) = filename;
+        *((const char **) apr_array_push(arr)) = "\">";
+        *((const char **) apr_array_push(arr)) = filename;
+        *((const char **) apr_array_push(arr)) = "</a> ";
+        *((const char **) apr_array_push(arr)) = description;
 
         if (variant->mime_type && *variant->mime_type) {
-            *((const char **) apr_push_array(arr)) = ", type ";
-            *((const char **) apr_push_array(arr)) = variant->mime_type;
+            *((const char **) apr_array_push(arr)) = ", type ";
+            *((const char **) apr_array_push(arr)) = variant->mime_type;
         }
         if (languages && languages->nelts) {
-            *((const char **) apr_push_array(arr)) = ", language ";
-            *((const char **) apr_push_array(arr)) = apr_array_pstrcat(r->pool,
+            *((const char **) apr_array_push(arr)) = ", language ";
+            *((const char **) apr_array_push(arr)) = apr_array_pstrcat(r->pool,
                                                        languages, ',');
         }
         if (variant->content_charset && *variant->content_charset) {
-            *((const char **) apr_push_array(arr)) = ", charset ";
-            *((const char **) apr_push_array(arr)) = variant->content_charset;
+            *((const char **) apr_array_push(arr)) = ", charset ";
+            *((const char **) apr_array_push(arr)) = variant->content_charset;
         }
         if (variant->content_encoding) {
-            *((const char **) apr_push_array(arr)) = ", encoding ";
-            *((const char **) apr_push_array(arr)) = variant->content_encoding;
+            *((const char **) apr_array_push(arr)) = ", encoding ";
+            *((const char **) apr_array_push(arr)) = variant->content_encoding;
         }
-        *((const char **) apr_push_array(arr)) = "\n";
+        *((const char **) apr_array_push(arr)) = "\n";
     }
-    *((const char **) apr_push_array(arr)) = "</ul>\n";
+    *((const char **) apr_array_push(arr)) = "</ul>\n";
 
     return apr_array_pstrcat(r->pool, arr, '\0');
 }
@@ -2668,12 +2668,12 @@ static int handle_multi(request_rec *r)
     r->finfo = sub_req->finfo;
     r->per_dir_config = sub_req->per_dir_config;
     /* copy output headers from subrequest, but leave negotiation headers */
-    r->notes = apr_overlay_tables(r->pool, sub_req->notes, r->notes);
-    r->headers_out = apr_overlay_tables(r->pool, sub_req->headers_out,
+    r->notes = apr_table_overlay(r->pool, sub_req->notes, r->notes);
+    r->headers_out = apr_table_overlay(r->pool, sub_req->headers_out,
                                     r->headers_out);
-    r->err_headers_out = apr_overlay_tables(r->pool, sub_req->err_headers_out,
+    r->err_headers_out = apr_table_overlay(r->pool, sub_req->err_headers_out,
                                         r->err_headers_out);
-    r->subprocess_env = apr_overlay_tables(r->pool, sub_req->subprocess_env,
+    r->subprocess_env = apr_table_overlay(r->pool, sub_req->subprocess_env,
                                        r->subprocess_env);
     avail_recs = (var_rec *) neg->avail_vars->elts;
     for (j = 0; j < neg->avail_vars->nelts; ++j) {
diff --git a/modules/mappers/mod_rewrite.c b/modules/mappers/mod_rewrite.c
index d9b7fd7..2253f90 100644
--- a/modules/mappers/mod_rewrite.c
+++ b/modules/mappers/mod_rewrite.c
@@ -188,7 +188,7 @@ static cache *cachep;
 static int proxy_available;
 
 static const char *lockname;
-static apr_lock_t *rewrite_mapr_lock = NULL;
+static apr_lock_t *rewrite_mapr_lock_aquire = NULL;
 static apr_lock_t *rewrite_log_lock = NULL;
 
 /*
@@ -216,9 +216,9 @@ static void *config_server_create(apr_pool_t *p, server_rec *s)
     a->rewritelogfile  = NULL;
     a->rewritelogfp    = NULL;
     a->rewriteloglevel = 0;
-    a->rewritemaps     = apr_make_array(p, 2, sizeof(rewritemap_entry));
-    a->rewriteconds    = apr_make_array(p, 2, sizeof(rewritecond_entry));
-    a->rewriterules    = apr_make_array(p, 2, sizeof(rewriterule_entry));
+    a->rewritemaps     = apr_array_make(p, 2, sizeof(rewritemap_entry));
+    a->rewriteconds    = apr_array_make(p, 2, sizeof(rewritecond_entry));
+    a->rewriterules    = apr_array_make(p, 2, sizeof(rewriterule_entry));
     a->server          = s;
 
     return (void *)a;
@@ -250,11 +250,11 @@ static void *config_server_merge(apr_pool_t *p, void *basev, void *overridesv)
         a->rewritelogfp    = overrides->rewritelogfp != NULL 
                              ? overrides->rewritelogfp 
                              : base->rewritelogfp;
-        a->rewritemaps     = apr_append_arrays(p, overrides->rewritemaps,
+        a->rewritemaps     = apr_array_append(p, overrides->rewritemaps,
                                               base->rewritemaps);
-        a->rewriteconds    = apr_append_arrays(p, overrides->rewriteconds,
+        a->rewriteconds    = apr_array_append(p, overrides->rewriteconds,
                                               base->rewriteconds);
-        a->rewriterules    = apr_append_arrays(p, overrides->rewriterules,
+        a->rewriterules    = apr_array_append(p, overrides->rewriterules,
                                               base->rewriterules);
     }
     else {
@@ -289,8 +289,8 @@ static void *config_perdir_create(apr_pool_t *p, char *path)
     a->state           = ENGINE_DISABLED;
     a->options         = OPTION_NONE;
     a->baseurl         = NULL;
-    a->rewriteconds    = apr_make_array(p, 2, sizeof(rewritecond_entry));
-    a->rewriterules    = apr_make_array(p, 2, sizeof(rewriterule_entry));
+    a->rewriteconds    = apr_array_make(p, 2, sizeof(rewritecond_entry));
+    a->rewriterules    = apr_array_make(p, 2, sizeof(rewriterule_entry));
 
     if (path == NULL) {
         a->directory = NULL;
@@ -323,9 +323,9 @@ static void *config_perdir_merge(apr_pool_t *p, void *basev, void *overridesv)
     a->baseurl   = overrides->baseurl;
 
     if (a->options & OPTION_INHERIT) {
-        a->rewriteconds = apr_append_arrays(p, overrides->rewriteconds,
+        a->rewriteconds = apr_array_append(p, overrides->rewriteconds,
                                            base->rewriteconds);
-        a->rewriterules = apr_append_arrays(p, overrides->rewriterules,
+        a->rewriterules = apr_array_append(p, overrides->rewriterules,
                                            base->rewriterules);
     }
     else {
@@ -432,7 +432,7 @@ static const char *cmd_rewritemap(cmd_parms *cmd, void *dconf, const char *a1,
     sconf = (rewrite_server_conf *)
             ap_get_module_config(cmd->server->module_config, &rewrite_module);
 
-    newmap = apr_push_array(sconf->rewritemaps);
+    newmap = apr_array_push(sconf->rewritemaps);
 
     newmap->name = a1;
     newmap->func = NULL;
@@ -553,10 +553,10 @@ static const char *cmd_rewritecond(cmd_parms *cmd, void *in_dconf,
 
     /*  make a new entry in the internal temporary rewrite rule list */
     if (cmd->path == NULL) {   /* is server command */
-        newcond = apr_push_array(sconf->rewriteconds);
+        newcond = apr_array_push(sconf->rewriteconds);
     }
     else {                     /* is per-directory command */
-        newcond = apr_push_array(dconf->rewriteconds);
+        newcond = apr_array_push(dconf->rewriteconds);
     }
 
     /*  parse the argument line ourself */
@@ -698,10 +698,10 @@ static const char *cmd_rewriterule(cmd_parms *cmd, void *in_dconf,
 
     /*  make a new entry in the internal rewrite rule list */
     if (cmd->path == NULL) {   /* is server command */
-        newrule = apr_push_array(sconf->rewriterules);
+        newrule = apr_array_push(sconf->rewriterules);
     }
     else {                     /* is per-directory command */
-        newrule = apr_push_array(dconf->rewriterules);
+        newrule = apr_array_push(dconf->rewriterules);
     }
 
     /*  parse the argument line ourself */
@@ -757,12 +757,12 @@ static const char *cmd_rewriterule(cmd_parms *cmd, void *in_dconf,
      */
     if (cmd->path == NULL) {  /* is server command */
         newrule->rewriteconds   = sconf->rewriteconds;
-        sconf->rewriteconds = apr_make_array(cmd->pool, 2,
+        sconf->rewriteconds = apr_array_make(cmd->pool, 2,
                                             sizeof(rewritecond_entry));
     }
     else {                    /* is per-directory command */
         newrule->rewriteconds   = dconf->rewriteconds;
-        dconf->rewriteconds = apr_make_array(cmd->pool, 2,
+        dconf->rewriteconds = apr_array_make(cmd->pool, 2,
                                             sizeof(rewritecond_entry));
     }
 
@@ -936,18 +936,18 @@ static void init_module(apr_pool_t *p,
     int first_time = 0;
     const char *userdata_key = "rewrite_init_module";
 
-    apr_get_userdata(&data, userdata_key, s->process->pool);
+    apr_pool_userdata_get(&data, userdata_key, s->process->pool);
     if (!data) {
         first_time = 1;
-        apr_set_userdata((const void *)1, userdata_key,
-                         apr_null_cleanup, s->process->pool);
+        apr_pool_userdata_set((const void *)1, userdata_key,
+                         apr_pool_cleanup_null, s->process->pool);
     }
 
     /* check if proxy module is available */
     proxy_available = (ap_find_linked_module("mod_proxy.c") != NULL);
 
     /* create the rewriting lockfiles in the parent */
-    if ((rv = apr_create_lock (&rewrite_log_lock, APR_MUTEX, APR_LOCKALL,
+    if ((rv = apr_lock_create (&rewrite_log_lock, APR_MUTEX, APR_LOCKALL,
                                NULL, p)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
                      "mod_rewrite: could not create rewrite_log_lock");
@@ -955,7 +955,7 @@ static void init_module(apr_pool_t *p,
     }
 
     rewritelock_create(s, p);
-    apr_register_cleanup(p, (void *)s, rewritelock_remove, apr_null_cleanup);
+    apr_pool_cleanup_register(p, (void *)s, rewritelock_remove, apr_pool_cleanup_null);
 
     /* step through the servers and
      * - open each rewriting logfile
@@ -982,10 +982,10 @@ static void init_child(apr_pool_t *p, server_rec *s)
 
     if (lockname != NULL && *(lockname) != '\0')
     {
-        rv = apr_child_init_lock (&rewrite_mapr_lock, lockname, p);
+        rv = apr_lock_child_init (&rewrite_mapr_lock_aquire, lockname, p);
         if (rv != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
-                         "mod_rewrite: could not init rewrite_mapr_lock "
+                         "mod_rewrite: could not init rewrite_mapr_lock_aquire "
                          "in child");
         }
     }
@@ -2816,12 +2816,12 @@ static char *lookup_map_txtfile(request_rec *r, const char *file, char *key)
     char *curkey;
     char *curval;
 
-    rc = apr_open(&fp, file, APR_READ, APR_OS_DEFAULT, r->pool);
+    rc = apr_file_open(&fp, file, APR_READ, APR_OS_DEFAULT, r->pool);
     if (rc != APR_SUCCESS) {
        return NULL;
     }
 
-    while (apr_fgets(line, sizeof(line), fp) == APR_SUCCESS) {
+    while (apr_file_gets(line, sizeof(line), fp) == APR_SUCCESS) {
         if (line[0] == '#')
             continue; /* ignore comments */
         cpT = line;
@@ -2847,7 +2847,7 @@ static char *lookup_map_txtfile(request_rec *r, const char *file, char *key)
         value = apr_pstrdup(r->pool, curval);
         break;
     }
-    apr_close(fp);
+    apr_file_close(fp);
     return value;
 }
 
@@ -2901,16 +2901,16 @@ static char *lookup_map_program(request_rec *r, apr_file_t *fpin,
 
     /* take the lock */
 
-    if (rewrite_mapr_lock) {
-        apr_lock(rewrite_mapr_lock);
+    if (rewrite_mapr_lock_aquire) {
+        apr_lock_aquire(rewrite_mapr_lock_aquire);
     }
 
     /* write out the request key */
 #ifdef NO_WRITEV
     nbytes = strlen(key);
-    apr_write(fpin, key, &nbytes);
+    apr_file_write(fpin, key, &nbytes);
     nbytes = 1;
-    apr_write(fpin, "\n", &nbytes);
+    apr_file_write(fpin, "\n", &nbytes);
 #else
     iova[0].iov_base = key;
     iova[0].iov_len = strlen(key);
@@ -2918,26 +2918,26 @@ static char *lookup_map_program(request_rec *r, apr_file_t *fpin,
     iova[1].iov_len = 1;
 
     niov = 2;
-    apr_writev(fpin, iova, niov, &nbytes);
+    apr_file_writev(fpin, iova, niov, &nbytes);
 #endif
 
     /* read in the response value */
     i = 0;
     nbytes = 1;
-    apr_read(fpout, &c, &nbytes);
+    apr_file_read(fpout, &c, &nbytes);
     while (nbytes == 1 && (i < LONG_STRING_LEN-1)) {
         if (c == '\n') {
             break;
         }
         buf[i++] = c;
 
-        apr_read(fpout, &c, &nbytes);
+        apr_file_read(fpout, &c, &nbytes);
     }
     buf[i] = '\0';
 
     /* give the lock back */
-    if (rewrite_mapr_lock) {
-        apr_unlock(rewrite_mapr_lock);
+    if (rewrite_mapr_lock_aquire) {
+        apr_lock_release(rewrite_mapr_lock_aquire);
     }
 
     if (strcasecmp(buf, "NULL") == 0) {
@@ -3098,7 +3098,7 @@ static void open_rewritelog(server_rec *s, apr_pool_t *p)
         conf->rewritelogfp = ap_piped_log_write_fd(pl);
     }
     else if (*conf->rewritelogfile != '\0') {
-        rc = apr_open(&conf->rewritelogfp, fname, rewritelog_flags, rewritelog_mode, p);
+        rc = apr_file_open(&conf->rewritelogfp, fname, rewritelog_flags, rewritelog_mode, p);
         if (rc != APR_SUCCESS)  {
             ap_log_error(APLOG_MARK, APLOG_ERR, rc, s, 
                          "mod_rewrite: could not open RewriteLog "
@@ -3188,10 +3188,10 @@ static void rewritelog(request_rec *r, int level, const char *text, ...)
                 (unsigned long)(r->server), (unsigned long)r,
                 type, redir, level, str2);
 
-    apr_lock(rewrite_log_lock);
+    apr_lock_aquire(rewrite_log_lock);
     nbytes = strlen(str3);
-    apr_write(conf->rewritelogfp, str3, &nbytes);
-    apr_unlock(rewrite_log_lock);
+    apr_file_write(conf->rewritelogfp, str3, &nbytes);
+    apr_lock_release(rewrite_log_lock);
 
     va_end(ap);
     return;
@@ -3203,7 +3203,7 @@ static char *current_logtime(request_rec *r)
     char tstr[80];
     apr_size_t len;
 
-    apr_explode_localtime(&t, apr_now());
+    apr_explode_localtime(&t, apr_time_now());
 
     apr_strftime(tstr, &len, 80, "[%d/%b/%Y:%H:%M:%S ", &t);
     apr_snprintf(tstr + strlen(tstr), 80-strlen(tstr), "%c%.2d%.2d]",
@@ -3238,7 +3238,7 @@ static void rewritelock_create(server_rec *s, apr_pool_t *p)
     lockname = ap_server_root_relative(p, lockname);
 
     /* create the lockfile */
-    rc = apr_create_lock (&rewrite_mapr_lock, APR_MUTEX, APR_LOCKALL, lockname, p);
+    rc = apr_lock_create (&rewrite_mapr_lock_aquire, APR_MUTEX, APR_LOCKALL, lockname, p);
     if (rc != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rc, s,
                      "mod_rewrite: Parent could not create RewriteLock "
@@ -3257,8 +3257,8 @@ static apr_status_t rewritelock_remove(void *data)
     }
 
     /* destroy the rewritelock */
-    apr_destroy_lock (rewrite_mapr_lock);
-    rewrite_mapr_lock = NULL;
+    apr_lock_destroy (rewrite_mapr_lock_aquire);
+    rewrite_mapr_lock_aquire = NULL;
     lockname = NULL;
     return(0);
 }
@@ -3337,22 +3337,22 @@ static apr_status_t rewritemap_program_child(apr_pool_t *p, const char *progname
 #endif
 
     
-    if (((rc = apr_createprocattr_init(&procattr, p)) != APR_SUCCESS) ||
-        ((rc = apr_setprocattr_io(procattr, APR_FULL_BLOCK,
+    if (((rc = apr_procattr_create(&procattr, p)) != APR_SUCCESS) ||
+        ((rc = apr_procattr_io_set(procattr, APR_FULL_BLOCK,
                                   APR_FULL_NONBLOCK,
                                   APR_FULL_NONBLOCK)) != APR_SUCCESS) ||
-        ((rc = apr_setprocattr_dir(procattr, 
+        ((rc = apr_procattr_dir_set(procattr, 
                                    ap_make_dirstr_parent(p, progname)))
          != APR_SUCCESS) ||
-        ((rc = apr_setprocattr_cmdtype(procattr, APR_PROGRAM)) != APR_SUCCESS)) {
+        ((rc = apr_procattr_cmdtype_set(procattr, APR_PROGRAM)) != APR_SUCCESS)) {
         /* Something bad happened, give up and go away. */
     }
     else {
         procnew = apr_pcalloc(p, sizeof(*procnew));
-        rc = apr_create_process(procnew, progname, NULL, NULL, procattr, p);
+        rc = apr_proc_create(procnew, progname, NULL, NULL, procattr, p);
     
         if (rc == APR_SUCCESS) {
-            apr_note_subprocess(p, procnew, kill_after_timeout);
+            apr_pool_note_subprocess(p, procnew, kill_after_timeout);
 
             if (fpin) {
                 (*fpin) = procnew->in;
@@ -3493,12 +3493,12 @@ static char *lookup_variable(request_rec *r, char *var)
 /* XXX: wow this has gotta be slow if you actually use it for a lot, recalculates exploded time for each variable */
     /* underlaying Unix system stuff */
     else if (strcasecmp(var, "TIME_YEAR") == 0) {
-        apr_explode_localtime(&tm, apr_now());
+        apr_explode_localtime(&tm, apr_time_now());
         apr_snprintf(resultbuf, sizeof(resultbuf), "%04d", tm.tm_year + 1900);
         result = resultbuf;
     }
 #define MKTIMESTR(format, tmfield) \
-    apr_explode_localtime(&tm, apr_now()); \
+    apr_explode_localtime(&tm, apr_time_now()); \
     apr_snprintf(resultbuf, sizeof(resultbuf), format, tm.tmfield); \
     result = resultbuf;
     else if (strcasecmp(var, "TIME_MON") == 0) {
@@ -3520,7 +3520,7 @@ static char *lookup_variable(request_rec *r, char *var)
         MKTIMESTR("%d", tm_wday)
     }
     else if (strcasecmp(var, "TIME") == 0) {
-        apr_explode_localtime(&tm, apr_now());
+        apr_explode_localtime(&tm, apr_time_now());
         apr_snprintf(resultbuf, sizeof(resultbuf),
 		    "%04d%02d%02d%02d%02d%02d", tm.tm_year + 1900,
 		    tm.tm_mon+1, tm.tm_mday,
@@ -3636,9 +3636,9 @@ static cache *init_cache(apr_pool_t *p)
     cache *c;
 
     c = (cache *)apr_palloc(p, sizeof(cache));
-    if (apr_create_pool(&c->pool, p) != APR_SUCCESS)
+    if (apr_pool_create(&c->pool, p) != APR_SUCCESS)
 		return NULL;
-    c->lists = apr_make_array(c->pool, 2, sizeof(cachelist));
+    c->lists = apr_array_make(c->pool, 2, sizeof(cachelist));
     return c;
 }
 
@@ -3759,10 +3759,10 @@ static void store_cache_string(cache *c, const char *res, cacheentry *ce)
 
     /* create a needed new list */
     if (!found_list) {
-        l = apr_push_array(c->lists);
+        l = apr_array_push(c->lists);
         l->resource = apr_pstrdup(c->pool, res);
-        l->entries  = apr_make_array(c->pool, 2, sizeof(cacheentry));
-        l->tlb      = apr_make_array(c->pool, CACHE_TLB_ROWS,
+        l->entries  = apr_array_make(c->pool, 2, sizeof(cacheentry));
+        l->tlb      = apr_array_make(c->pool, CACHE_TLB_ROWS,
                                     sizeof(cachetlbentry));
         for (i=0; i<CACHE_TLB_ROWS; ++i) {
             t = &((cachetlbentry *)l->tlb->elts)[i];
@@ -3775,7 +3775,7 @@ static void store_cache_string(cache *c, const char *res, cacheentry *ce)
     for (i = 0; i < c->lists->nelts; i++) {
         l = &(((cachelist *)c->lists->elts)[i]);
         if (strcmp(l->resource, res) == 0) {
-            e = apr_push_array(l->entries);
+            e = apr_array_push(l->entries);
             e->time  = ce->time;
             e->key   = apr_pstrdup(c->pool, ce->key);
             e->value = apr_pstrdup(c->pool, ce->value);
diff --git a/modules/mappers/mod_so.c b/modules/mappers/mod_so.c
index 761a812..df486d2 100644
--- a/modules/mappers/mod_so.c
+++ b/modules/mappers/mod_so.c
@@ -159,7 +159,7 @@ static void *so_sconf_create(apr_pool_t *p, server_rec *s)
     so_server_conf *soc;
 
     soc = (so_server_conf *)apr_pcalloc(p, sizeof(so_server_conf));
-    soc->loaded_modules = apr_make_array(p, DYNAMIC_MODULE_LIMIT, 
+    soc->loaded_modules = apr_array_make(p, DYNAMIC_MODULE_LIMIT, 
                                      sizeof(moduleinfo));
 
     return (void *)soc;
@@ -225,7 +225,7 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
         if (modi->name != NULL && strcmp(modi->name, modname) == 0)
             return NULL;
     }
-    modi = apr_push_array(sconf->loaded_modules);
+    modi = apr_array_push(sconf->loaded_modules);
     modi->name = modname;
 
     /*
@@ -279,7 +279,7 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
      * we do a restart (or shutdown) this cleanup will cause the
      * shared object to be unloaded.
      */
-    apr_register_cleanup(cmd->pool, modi, unload_module, apr_null_cleanup);
+    apr_pool_cleanup_register(cmd->pool, modi, unload_module, apr_pool_cleanup_null);
 
     /* 
      * Finally we need to run the configuration process for the module
diff --git a/modules/mappers/mod_speling.c b/modules/mappers/mod_speling.c
index 845b3b2..3d8b390 100644
--- a/modules/mappers/mod_speling.c
+++ b/modules/mappers/mod_speling.c
@@ -303,7 +303,7 @@ static int check_speling(request_rec *r)
         return DECLINED;
     }
 
-    candidates = apr_make_array(r->pool, 2, sizeof(misspelled_file));
+    candidates = apr_array_make(r->pool, 2, sizeof(misspelled_file));
 
     dotloc = ap_ind(bad, '.');
     if (dotloc == -1) {
@@ -330,7 +330,7 @@ static int check_speling(request_rec *r)
         else if (strcasecmp(bad, dirent.name) == 0) {
             misspelled_file *sp_new;
 
-	    sp_new = (misspelled_file *) apr_push_array(candidates);
+	    sp_new = (misspelled_file *) apr_array_push(candidates);
             sp_new->name = apr_pstrdup(r->pool, dirent.name);
             sp_new->quality = SP_MISCAPITALIZED;
         }
@@ -342,7 +342,7 @@ static int check_speling(request_rec *r)
         else if ((q = spdist(bad, dirent.name)) != SP_VERYDIFFERENT) {
             misspelled_file *sp_new;
 
-	    sp_new = (misspelled_file *) apr_push_array(candidates);
+	    sp_new = (misspelled_file *) apr_array_push(candidates);
             sp_new->name = apr_pstrdup(r->pool, dirent.name);
             sp_new->quality = q;
         }
@@ -388,7 +388,7 @@ static int check_speling(request_rec *r)
                 && !strncasecmp(bad, dirent.name, dotloc)) {
                 misspelled_file *sp_new;
 
-		sp_new = (misspelled_file *) apr_push_array(candidates);
+		sp_new = (misspelled_file *) apr_array_push(candidates);
                 sp_new->name = apr_pstrdup(r->pool, dirent.name);
                 sp_new->quality = SP_VERYDIFFERENT;
             }
@@ -458,20 +458,20 @@ static int check_speling(request_rec *r)
                 notes = r->main->notes;
             }
 
-	    if (apr_create_pool(&sub_pool, p) != APR_SUCCESS)
+	    if (apr_pool_create(&sub_pool, p) != APR_SUCCESS)
 		return DECLINED;
 
-	    t = apr_make_array(sub_pool, candidates->nelts * 8 + 8,
+	    t = apr_array_make(sub_pool, candidates->nelts * 8 + 8,
 			      sizeof(char *));
-	    v = apr_make_array(sub_pool, candidates->nelts * 5,
+	    v = apr_array_make(sub_pool, candidates->nelts * 5,
 			      sizeof(char *));
 
             /* Generate the response text. */
 
-	    *(const char **)apr_push_array(t) =
+	    *(const char **)apr_array_push(t) =
 			  "The document name you requested (<code>";
-	    *(const char **)apr_push_array(t) = ap_escape_html(sub_pool, r->uri);
-	    *(const char **)apr_push_array(t) =
+	    *(const char **)apr_array_push(t) = ap_escape_html(sub_pool, r->uri);
+	    *(const char **)apr_array_push(t) =
 			   "</code>) could not be found on this server.\n"
 			   "However, we found documents with names similar "
 			   "to the one you requested.<p>"
@@ -488,19 +488,19 @@ static int check_speling(request_rec *r)
 				  (r->parsed_uri.query != NULL)
 				      ? r->parsed_uri.query : "",
 				  NULL);
-		*(const char **)apr_push_array(v) = "\"";
-		*(const char **)apr_push_array(v) = ap_escape_uri(sub_pool, vuri);
-		*(const char **)apr_push_array(v) = "\";\"";
-		*(const char **)apr_push_array(v) = reason;
-		*(const char **)apr_push_array(v) = "\"";
-
-		*(const char **)apr_push_array(t) = "<li><a href=\"";
-		*(const char **)apr_push_array(t) = ap_escape_uri(sub_pool, vuri);
-		*(const char **)apr_push_array(t) = "\">";
-		*(const char **)apr_push_array(t) = ap_escape_html(sub_pool, vuri);
-		*(const char **)apr_push_array(t) = "</a> (";
-		*(const char **)apr_push_array(t) = reason;
-		*(const char **)apr_push_array(t) = ")\n";
+		*(const char **)apr_array_push(v) = "\"";
+		*(const char **)apr_array_push(v) = ap_escape_uri(sub_pool, vuri);
+		*(const char **)apr_array_push(v) = "\";\"";
+		*(const char **)apr_array_push(v) = reason;
+		*(const char **)apr_array_push(v) = "\"";
+
+		*(const char **)apr_array_push(t) = "<li><a href=\"";
+		*(const char **)apr_array_push(t) = ap_escape_uri(sub_pool, vuri);
+		*(const char **)apr_array_push(t) = "\">";
+		*(const char **)apr_array_push(t) = ap_escape_html(sub_pool, vuri);
+		*(const char **)apr_array_push(t) = "</a> (";
+		*(const char **)apr_array_push(t) = reason;
+		*(const char **)apr_array_push(t) = ")\n";
 
                 /*
                  * when we have printed the "close matches" and there are
@@ -512,20 +512,20 @@ static int check_speling(request_rec *r)
                 if (i > 0 && i < candidates->nelts - 1
                     && variant[i].quality != SP_VERYDIFFERENT
                     && variant[i + 1].quality == SP_VERYDIFFERENT) {
-		    *(const char **)apr_push_array(t) = 
+		    *(const char **)apr_array_push(t) = 
 				   "</ul>\nFurthermore, the following related "
 				   "documents were found:\n<ul>\n";
                 }
             }
-	    *(const char **)apr_push_array(t) = "</ul>\n";
+	    *(const char **)apr_array_push(t) = "</ul>\n";
 
             /* If we know there was a referring page, add a note: */
             if (ref != NULL) {
-                *(const char **)apr_push_array(t) =
+                *(const char **)apr_array_push(t) =
 			       "Please consider informing the owner of the "
 			       "<a href=\"";
-		*(const char **)apr_push_array(t) = ap_escape_uri(sub_pool, ref);
-                *(const char **)apr_push_array(t) = "\">referring page</a> "
+		*(const char **)apr_array_push(t) = ap_escape_uri(sub_pool, ref);
+                *(const char **)apr_array_push(t) = "\">referring page</a> "
 			       "about the broken link.\n";
 	    }
 
@@ -536,7 +536,7 @@ static int check_speling(request_rec *r)
 	    apr_table_mergen(r->subprocess_env, "VARIANTS",
 			    apr_array_pstrcat(p, v, ','));
 	  
-	    apr_destroy_pool(sub_pool);
+	    apr_pool_destroy(sub_pool);
 
             ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_INFO, 0, r,
 			 ref ? "Spelling fix: %s: %d candidates from %s"
diff --git a/modules/mappers/mod_userdir.c b/modules/mappers/mod_userdir.c
index 37a2c0b..3cc49f5 100644
--- a/modules/mappers/mod_userdir.c
+++ b/modules/mappers/mod_userdir.c
@@ -138,8 +138,8 @@ static void *create_userdir_config(apr_pool_t *p, server_rec *s)
 
     newcfg->globally_disabled = 0;
     newcfg->userdir = DEFAULT_USER_DIR;
-    newcfg->enabled_users = apr_make_table(p, 4);
-    newcfg->disabled_users = apr_make_table(p, 4);
+    newcfg->enabled_users = apr_table_make(p, 4);
+    newcfg->disabled_users = apr_table_make(p, 4);
     return (void *) newcfg;
 }
 
diff --git a/modules/metadata/mod_cern_meta.c b/modules/metadata/mod_cern_meta.c
index 79aab42..21f7ca4 100644
--- a/modules/metadata/mod_cern_meta.c
+++ b/modules/metadata/mod_cern_meta.c
@@ -250,8 +250,8 @@ static int scan_meta_file(request_rec *r, apr_file_t *f)
     int p;
     apr_table_t *tmp_headers;
 
-    tmp_headers = apr_make_table(r->pool, 5);
-    while (apr_fgets(w, MAX_STRING_LEN - 1, f) == APR_SUCCESS) {
+    tmp_headers = apr_table_make(r->pool, 5);
+    while (apr_file_gets(w, MAX_STRING_LEN - 1, f) == APR_SUCCESS) {
 
 	/* Delete terminal (CR?)LF */
 
@@ -299,7 +299,7 @@ static int scan_meta_file(request_rec *r, apr_file_t *f)
 	    apr_table_set(tmp_headers, w, l);
 	}
     }
-    apr_overlap_tables(r->headers_out, tmp_headers, APR_OVERLAP_TABLES_SET);
+    apr_table_overlap(r->headers_out, tmp_headers, APR_OVERLAP_TABLES_SET);
     return OK;
 }
 
@@ -369,7 +369,7 @@ static int add_cern_meta_data(request_rec *r)
     }
     ap_destroy_sub_req(rr);
 
-    retcode = apr_open(&f, metafilename, APR_READ | APR_CREATE, APR_OS_DEFAULT, r->pool);
+    retcode = apr_file_open(&f, metafilename, APR_READ | APR_CREATE, APR_OS_DEFAULT, r->pool);
     if (retcode != APR_SUCCESS) {
 	if (APR_STATUS_IS_ENOENT(retcode)) {
 	    return DECLINED;
@@ -381,7 +381,7 @@ static int add_cern_meta_data(request_rec *r)
 
     /* read the headers in */
     rv = scan_meta_file(r, f);
-    apr_close(f);
+    apr_file_close(f);
 
     return rv;
 }
diff --git a/modules/metadata/mod_env.c b/modules/metadata/mod_env.c
index 53f291e..21b8301 100644
--- a/modules/metadata/mod_env.c
+++ b/modules/metadata/mod_env.c
@@ -120,7 +120,7 @@ static void *create_env_dir_config(apr_pool_t *p, char *dummy)
 {
     env_dir_config_rec *new =
     (env_dir_config_rec *) apr_palloc(p, sizeof(env_dir_config_rec));
-    new->vars = apr_make_table(p, 50);
+    new->vars = apr_table_make(p, 50);
     new->unsetenv = "";
     new->vars_present = 0;
     return (void *) new;
@@ -150,7 +150,7 @@ static void *merge_env_dir_configs(apr_pool_t *p, void *basev, void *addv)
      * }
      */
 
-    new_table = apr_copy_table(p, base->vars);
+    new_table = apr_table_copy(p, base->vars);
 
     arr = apr_table_elts(add->vars);
     elts = (apr_table_entry_t *)arr->elts;
@@ -249,7 +249,7 @@ static int fixup_env_module(request_rec *r)
     if (!sconf->vars_present)
         return DECLINED;
 
-    r->subprocess_env = apr_overlay_tables(r->pool, e, vars);
+    r->subprocess_env = apr_table_overlay(r->pool, e, vars);
 
     return OK;
 }
diff --git a/modules/metadata/mod_expires.c b/modules/metadata/mod_expires.c
index e3a9667..b0e72aa 100644
--- a/modules/metadata/mod_expires.c
+++ b/modules/metadata/mod_expires.c
@@ -228,7 +228,7 @@ static void *create_dir_expires_config(apr_pool_t *p, char *dummy)
     (expires_dir_config *) apr_pcalloc(p, sizeof(expires_dir_config));
     new->active = ACTIVE_DONTCARE;
     new->expiresdefault = "";
-    new->expiresbytype = apr_make_table(p, 4);
+    new->expiresbytype = apr_table_make(p, 4);
     return (void *) new;
 }
 
@@ -408,7 +408,7 @@ static void *merge_expires_dir_configs(apr_pool_t *p, void *basev, void *addv)
         new->expiresdefault = add->expiresdefault;
     };
 
-    new->expiresbytype = apr_overlay_tables(p, add->expiresbytype,
+    new->expiresbytype = apr_table_overlay(p, add->expiresbytype,
                                         base->expiresbytype);
     return new;
 }
diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index 34439ef..9c3c9ea 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -139,7 +139,7 @@ static void *create_headers_config(apr_pool_t *p, server_rec *s)
     headers_conf *a =
     (headers_conf *) apr_pcalloc(p, sizeof(headers_conf));
 
-    a->headers = apr_make_array(p, 2, sizeof(header_entry));
+    a->headers = apr_array_make(p, 2, sizeof(header_entry));
     return a;
 }
 
@@ -154,7 +154,7 @@ static void *merge_headers_config(apr_pool_t *p, void *basev, void *overridesv)
     (headers_conf *) apr_pcalloc(p, sizeof(headers_conf));
     headers_conf *base = (headers_conf *) basev, *overrides = (headers_conf *) overridesv;
 
-    a->headers = apr_append_arrays(p, base->headers, overrides->headers);
+    a->headers = apr_array_append(p, base->headers, overrides->headers);
 
     return a;
 }
@@ -172,10 +172,10 @@ static const char *header_cmd(cmd_parms *cmd, void *indirconf,
     char *colon;
 
     if (cmd->path) {
-        new = (header_entry *) apr_push_array(dirconf->headers);
+        new = (header_entry *) apr_array_push(dirconf->headers);
     }
     else {
-        new = (header_entry *) apr_push_array(serverconf->headers);
+        new = (header_entry *) apr_array_push(serverconf->headers);
     }
 
     if (!strcasecmp(action, "set"))
diff --git a/modules/metadata/mod_mime_magic.c b/modules/metadata/mod_mime_magic.c
index d54d313..1ee86d2 100644
--- a/modules/metadata/mod_mime_magic.c
+++ b/modules/metadata/mod_mime_magic.c
@@ -873,7 +873,7 @@ static int magic_process(request_rec *r)
 	return result;
     }
 
-    if (apr_open(&fd, r->filename, APR_READ, APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
+    if (apr_file_open(&fd, r->filename, APR_READ, APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
 	/* We can't open it, but we were able to stat it. */
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		    MODNAME ": can't read `%s'", r->filename);
@@ -885,7 +885,7 @@ static int magic_process(request_rec *r)
      * try looking at the first HOWMANY bytes
      */
     nbytes = sizeof(buf) - 1;
-    if ((result = apr_read(fd, (char *) buf, &nbytes)) != APR_SUCCESS) {
+    if ((result = apr_file_read(fd, (char *) buf, &nbytes)) != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, result, r,
 		    MODNAME ": read failed: %s", r->filename);
 	return HTTP_INTERNAL_SERVER_ERROR;
@@ -898,7 +898,7 @@ static int magic_process(request_rec *r)
 	tryit(r, buf, nbytes, 1); 
     }
 
-    (void) apr_close(fd);
+    (void) apr_file_close(fd);
     (void) magic_rsl_putchar(r, '\n');
 
     return OK;
@@ -954,7 +954,7 @@ static int apprentice(server_rec *s, apr_pool_t *p)
 		    ap_get_module_config(s->module_config, &mime_magic_module);
 
     const char *fname = ap_server_root_relative(p, conf->magicfile);
-    result = apr_open(&f, fname, APR_READ | APR_BUFFERED, APR_OS_DEFAULT, p);
+    result = apr_file_open(&f, fname, APR_READ | APR_BUFFERED, APR_OS_DEFAULT, p);
     if (result != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_ERR, result, s,
 		    MODNAME ": can't read magic file %s", fname);
@@ -965,7 +965,7 @@ static int apprentice(server_rec *s, apr_pool_t *p)
     conf->magic = conf->last = NULL;
 
     /* parse it */
-    for (lineno = 1; apr_fgets(line, BUFSIZ, f) == APR_SUCCESS; lineno++) {
+    for (lineno = 1; apr_file_gets(line, BUFSIZ, f) == APR_SUCCESS; lineno++) {
 	int ws_offset;
 
 	/* delete newline */
@@ -998,7 +998,7 @@ static int apprentice(server_rec *s, apr_pool_t *p)
 	    ++errs;
     }
 
-    (void) apr_close(f);
+    (void) apr_file_close(f);
 
 #if MIME_MAGIC_DEBUG
     ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, s,
@@ -2152,11 +2152,11 @@ static int uncompress_child(struct uncompress_parms *parm, apr_pool_t *cntxt,
 
     env = (const char *const *)ap_create_environment(child_context, r->subprocess_env);
 
-    if ((apr_createprocattr_init(&procattr, child_context) != APR_SUCCESS) ||
-        (apr_setprocattr_io(procattr, APR_FULL_BLOCK, 
+    if ((apr_procattr_create(&procattr, child_context) != APR_SUCCESS) ||
+        (apr_procattr_io_set(procattr, APR_FULL_BLOCK, 
                            APR_FULL_BLOCK, APR_NO_PIPE)   != APR_SUCCESS) ||
-        (apr_setprocattr_dir(procattr, r->filename)        != APR_SUCCESS) ||
-        (apr_setprocattr_cmdtype(procattr, APR_PROGRAM)    != APR_SUCCESS)) {
+        (apr_procattr_dir_set(procattr, r->filename)        != APR_SUCCESS) ||
+        (apr_procattr_cmdtype_set(procattr, APR_PROGRAM)    != APR_SUCCESS)) {
         /* Something bad happened, tell the world. */
         ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_ENOPROC, r,
                "couldn't setup child process: %s", r->filename);
@@ -2172,7 +2172,7 @@ static int uncompress_child(struct uncompress_parms *parm, apr_pool_t *cntxt,
         }
 
         procnew = apr_pcalloc(child_context, sizeof(*procnew));
-        rc = apr_create_process(procnew, compr[parm->method].argv[0],
+        rc = apr_proc_create(procnew, compr[parm->method].argv[0],
                                new_argv, env, procattr, child_context);
 
         if (rc != APR_SUCCESS) {
@@ -2182,7 +2182,7 @@ static int uncompress_child(struct uncompress_parms *parm, apr_pool_t *cntxt,
                           compr[parm->method].argv[0]);
         }
         else {
-            apr_note_subprocess(child_context, procnew, kill_after_timeout);
+            apr_pool_note_subprocess(child_context, procnew, kill_after_timeout);
             *pipe_in = procnew->out;
         }
     }
@@ -2205,7 +2205,7 @@ static int uncompress(request_rec *r, int method,
      * there are cases (i.e. generating directory indicies with mod_autoindex)
      * where we would end up with LOTS of zombies.
      */
-    if (apr_create_pool(&sub_context, r->pool) != APR_SUCCESS)
+    if (apr_pool_create(&sub_context, r->pool) != APR_SUCCESS)
         return -1;
 
     if ((rv = uncompress_child(&parm, sub_context, &pipe_out)) != APR_SUCCESS) {
@@ -2215,14 +2215,14 @@ static int uncompress(request_rec *r, int method,
     }
 
     *newch = (unsigned char *) apr_palloc(r->pool, n);
-    rv = apr_read(pipe_out, *newch, &n);
+    rv = apr_file_read(pipe_out, *newch, &n);
     if (n == 0) {
-	apr_destroy_pool(sub_context);
+	apr_pool_destroy(sub_context);
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
 	    MODNAME ": read failed %s", r->filename);
 	return -1;
     }
-    apr_destroy_pool(sub_context);
+    apr_pool_destroy(sub_context);
     return n;
 }
 
diff --git a/modules/metadata/mod_setenvif.c b/modules/metadata/mod_setenvif.c
index f738b93..5914db5 100644
--- a/modules/metadata/mod_setenvif.c
+++ b/modules/metadata/mod_setenvif.c
@@ -165,7 +165,7 @@ static void *create_setenvif_config(apr_pool_t *p)
 {
     sei_cfg_rec *new = (sei_cfg_rec *) apr_palloc(p, sizeof(sei_cfg_rec));
 
-    new->conditionals = apr_make_array(p, 20, sizeof(sei_entry));
+    new->conditionals = apr_array_make(p, 20, sizeof(sei_entry));
     return (void *) new;
 }
 
@@ -184,7 +184,7 @@ static void *merge_setenvif_config(apr_pool_t *p, void *basev, void *overridesv)
     sei_cfg_rec *a = apr_pcalloc(p, sizeof(sei_cfg_rec));
     sei_cfg_rec *base = basev, *overrides = overridesv;
 
-    a->conditionals = apr_append_arrays(p, base->conditionals,
+    a->conditionals = apr_array_append(p, base->conditionals,
 				       overrides->conditionals);
     return a;
 }
@@ -252,7 +252,7 @@ static const char *add_setenvif_core(cmd_parms *cmd, void *mconfig,
 
 	/* no match, create a new entry */
 
-	new = apr_push_array(sconf->conditionals);
+	new = apr_array_push(sconf->conditionals);
 	new->name = fname;
 	new->regex = regex;
 	new->icase = icase;
@@ -263,7 +263,7 @@ static const char *add_setenvif_core(cmd_parms *cmd, void *mconfig,
 	    return apr_pstrcat(cmd->pool, cmd->cmd->name,
 			      " regex could not be compiled.", NULL);
 	}
-	new->features = apr_make_table(cmd->pool, 2);
+	new->features = apr_table_make(cmd->pool, 2);
 
 	if (!strcasecmp(fname, "remote_addr")) {
 	    new->special_type = SPECIAL_REMOTE_ADDR;
diff --git a/modules/metadata/mod_unique_id.c b/modules/metadata/mod_unique_id.c
index 1ae9b3a..31eff29 100644
--- a/modules/metadata/mod_unique_id.c
+++ b/modules/metadata/mod_unique_id.c
@@ -246,7 +246,7 @@ static void unique_id_global_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *p
      * But protecting against it is relatively cheap.  We just sleep into the
      * next second.
      */
-    pause = (apr_interval_time_t)(1000000 - (apr_now() % APR_USEC_PER_SEC));
+    pause = (apr_interval_time_t)(1000000 - (apr_time_now() % APR_USEC_PER_SEC));
     apr_sleep(pause);
 }
 
@@ -285,7 +285,7 @@ static void unique_id_child_init(apr_pool_t *p, server_rec *s)
      * against restart problems, and a little less protection against a clock
      * going backwards in time.
      */
-    tv = apr_now();
+    tv = apr_time_now();
     /* Some systems have very low variance on the low end of their system
      * counter, defend against that.
      */
diff --git a/modules/metadata/mod_usertrack.c b/modules/metadata/mod_usertrack.c
index 6063212..5f3bcf1 100644
--- a/modules/metadata/mod_usertrack.c
+++ b/modules/metadata/mod_usertrack.c
@@ -141,7 +141,7 @@ static void make_cookie(request_rec *r)
     dcfg = ap_get_module_config(r->per_dir_config, &usertrack_module);
 
     /* XXX: hmm, this should really tie in with mod_unique_id */
-    apr_snprintf(cookiebuf, sizeof(cookiebuf), "%s.%qd", rname, apr_now());
+    apr_snprintf(cookiebuf, sizeof(cookiebuf), "%s.%qd", rname, apr_time_now());
 
     if (cls->expires) {
 	apr_exploded_time_t tms;
diff --git a/modules/proxy/mod_proxy.c b/modules/proxy/mod_proxy.c
index edc16a7..dbb47b9 100644
--- a/modules/proxy/mod_proxy.c
+++ b/modules/proxy/mod_proxy.c
@@ -464,7 +464,7 @@ static const char *
 	port = defports[i].port;
     }
 
-    new = apr_push_array(conf->proxies);
+    new = apr_array_push(conf->proxies);
     new->scheme = f;
     new->protocol = r;
     new->hostname = p + 3;
@@ -490,7 +490,7 @@ static const char *
     }
 
     if (!found) {
-        new = apr_push_array(psf->nocaches);
+        new = apr_array_push(psf->nocaches);
         new->name = arg;
         /* Don't do name lookups on things that aren't dotted */
         if (ap_strchr_c(arg, '.') != NULL &&
@@ -510,7 +510,7 @@ static const char *
     (proxy_server_conf *) ap_get_module_config(s->module_config, &proxy_module);
     struct proxy_alias *new;
 
-    new = apr_push_array(conf->aliases);
+    new = apr_array_push(conf->aliases);
     new->fake = f;
     new->real = r;
     return NULL;
@@ -525,7 +525,7 @@ static const char *
 
     conf = (proxy_server_conf *)ap_get_module_config(s->module_config, 
                                                   &proxy_module);
-    new = apr_push_array(conf->raliases);
+    new = apr_array_push(conf->raliases);
     new->fake = f;
     new->real = r;
     return NULL;
@@ -550,7 +550,7 @@ static const char *
     }
 
     if (!found) {
-	new = apr_push_array(conf->noproxies);
+	new = apr_array_push(conf->noproxies);
 	new->name = arg;
 	/* Don't do name lookups on things that aren't dotted */
         if (ap_strchr_c(arg, '.') != NULL &&
@@ -577,7 +577,7 @@ static const char *
     if (!apr_isdigit(arg[0]))
 	return "AllowCONNECT: port number must be numeric";
 
-    New = apr_push_array(conf->allowed_connect_ports);
+    New = apr_array_push(conf->allowed_connect_ports);
     *New = atoi(arg);
     return NULL;
 }
@@ -603,7 +603,7 @@ static const char *
     }
 
     if (!found) {
-	New = apr_push_array(conf->dirconn);
+	New = apr_array_push(conf->dirconn);
         New->name = apr_pstrdup(parms->pool, arg);
 	New->hostentry = NULL;
 
diff --git a/modules/proxy/proxy_cache.c b/modules/proxy/proxy_cache.c
index 8b0f899..3f4ac25 100644
--- a/modules/proxy/proxy_cache.c
+++ b/modules/proxy/proxy_cache.c
@@ -191,12 +191,12 @@ apr_status_t ap_cache_el_data_append(ap_cache_el *el, apr_file_t *data)
     
     if((ret = ap_cache_el_data(el, &place)) != APR_SUCCESS) return ret;
     nbytes = HUGE_STRING_LEN;
-    while(apr_read(data, buffer, &nbytes) == APR_SUCCESS && nbytes) {
+    while(apr_file_read(data, buffer, &nbytes) == APR_SUCCESS && nbytes) {
         o = 0;
         while(nbytes)
         {
             i = nbytes;
-            apr_write(place, buffer + o, &i);
+            apr_file_write(place, buffer + o, &i);
             o += i;
             nbytes -= i;
         }
diff --git a/modules/proxy/proxy_connect.c b/modules/proxy/proxy_connect.c
index 9b8c277..05e7d38 100644
--- a/modules/proxy/proxy_connect.c
+++ b/modules/proxy/proxy_connect.c
@@ -172,7 +172,7 @@ int ap_proxy_connect_handler(request_rec *r, char *url,
             "CONNECT to %s on port %d", host, port);
     }
 
-    if ((apr_create_socket(&sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
+    if ((apr_socket_create(&sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
             "proxy: error creating socket");
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -180,7 +180,7 @@ int ap_proxy_connect_handler(request_rec *r, char *url,
 
     if (ap_proxy_doconnect(sock, (char *)(proxyhost ? proxyhost : host),
       proxyport ? proxyport : port, r) != APR_SUCCESS) {
-        apr_close_socket(sock);
+        apr_socket_close(sock);
         return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
             apr_pstrcat(r->pool, "Could not connect to remote machine:<br>",
             proxyhost, NULL));
@@ -211,10 +211,10 @@ int ap_proxy_connect_handler(request_rec *r, char *url,
         ap_rflush(r);
     }
 
-    if(apr_setup_poll(&pollfd, 2, r->pool) != APR_SUCCESS)
+    if(apr_poll_setup(&pollfd, 2, r->pool) != APR_SUCCESS)
     {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-            "proxy: error apr_setup_poll()");
+            "proxy: error apr_poll_setup()");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
@@ -225,7 +225,7 @@ int ap_proxy_connect_handler(request_rec *r, char *url,
    just see if a recv gives us anything and do the same to sock (server) side, I'll leave this as TBD so
    one can decide the best path to take
 */
-    if(apr_put_os_sock(&client_sock,
+    if(apr_os_sock_put(&client_sock,
         (apr_os_sock_t *)get_socket(r->connection->client),
                       r->pool) != APR_SUCCESS)
     {
@@ -233,11 +233,11 @@ int ap_proxy_connect_handler(request_rec *r, char *url,
             "proxy: error creating client apr_socket_t");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
-    apr_add_poll_socket(pollfd, client_sock, APR_POLLIN);
+    apr_poll_socket_add(pollfd, client_sock, APR_POLLIN);
 #endif
 
     /* Add the server side to the poll */
-    apr_add_poll_socket(pollfd, sock, APR_POLLIN);
+    apr_poll_socket_add(pollfd, sock, APR_POLLIN);
 
     while (1) { /* Infinite loop until error (one side closes the connection) */
         ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL, "Going to sleep (poll)");
@@ -250,7 +250,7 @@ int ap_proxy_connect_handler(request_rec *r, char *url,
                      "Woke from select(), i=%d", pollcnt);
 
         if (pollcnt) {
-            apr_get_revents(&pollevent, sock, pollfd);
+            apr_poll_revents_get(&pollevent, sock, pollfd);
             if (pollevent & APR_POLLIN) {
                 ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                              "sock was set");
@@ -270,7 +270,7 @@ int ap_proxy_connect_handler(request_rec *r, char *url,
                     break;
             }
 
-            apr_get_revents(&pollevent, client_sock, pollfd);
+            apr_poll_revents_get(&pollevent, client_sock, pollfd);
             if (pollevent & APR_POLLIN) {
                 ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                              "client was set");
@@ -295,7 +295,7 @@ int ap_proxy_connect_handler(request_rec *r, char *url,
             break;
     }
 
-    apr_close_socket(sock);
+    apr_socket_close(sock);
 
     return OK;
 }
diff --git a/modules/proxy/proxy_ftp.c b/modules/proxy/proxy_ftp.c
index c02eea7..1d07fb0 100644
--- a/modules/proxy/proxy_ftp.c
+++ b/modules/proxy/proxy_ftp.c
@@ -400,7 +400,7 @@ static long int send_dir(BUFF *f, request_rec *r, ap_cache_el  *c, char *cwd)
 	total_bytes_sent += n;
 
         cntr = n;
-	if (cachefp && apr_write(cachefp, buf, &cntr) != APR_SUCCESS) {
+	if (cachefp && apr_file_write(cachefp, buf, &cntr) != APR_SUCCESS) {
 	   ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 	  "proxy: error writing to cache");
 	   ap_proxy_cache_error(&c);
@@ -567,7 +567,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
     if (parms != NULL)
 	*(parms++) = '\0';
 
-    if ((apr_create_socket(&sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
+    if ((apr_socket_create(&sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "proxy: error creating socket");
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -586,13 +586,13 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
 #ifndef _OSD_POSIX /* BS2000 has this option "always on" */
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		     "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
-	apr_close_socket(sock);
+	apr_socket_close(sock);
 	return HTTP_INTERNAL_SERVER_ERROR;
 #endif /*_OSD_POSIX*/
     }
 
     if (ap_proxy_doconnect(sock, host, port, r) != APR_SUCCESS) {
-	apr_close_socket(sock);
+	apr_socket_close(sock);
 	return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_pstrcat(r->pool,
 				"Could not connect to remote machine: ",
 				host, NULL));
@@ -788,7 +788,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
     }
 
 /* try to set up PASV data connection first */
-    if ((apr_create_socket(&dsock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
+    if ((apr_socket_create(&dsock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		     "proxy: error creating PASV socket");
 	ap_bclose(f);
@@ -818,7 +818,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
     if (i == -1) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, r,
 		     "PASV: control connection is toast");
-	apr_close_socket(dsock);
+	apr_socket_close(dsock);
 	ap_bclose(f);
 	return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -862,31 +862,31 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
 	    }
 	}
 	else
-	    apr_close_socket(dsock);	/* and try the regular way */
+	    apr_socket_close(dsock);	/* and try the regular way */
     }
 
     if (!pasvmode) {		/* set up data connection */
-	if ((apr_create_socket(&dsock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
+	if ((apr_socket_create(&dsock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
 	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 			 "proxy: error creating socket");
 	    ap_bclose(f);
 	    return HTTP_INTERNAL_SERVER_ERROR;
 	}
-        apr_get_sockaddr(&localsa, APR_LOCAL, sock);
-        apr_get_port(&npport, localsa);
-        apr_get_ipaddr(&npaddr, localsa);
+        apr_socket_addr_get(&localsa, APR_LOCAL, sock);
+        apr_sockaddr_port_get(&npport, localsa);
+        apr_sockaddr_ip_get(&npaddr, localsa);
 
 	if (apr_setsocketopt(dsock, APR_SO_REUSEADDR, one) != APR_SUCCESS) {
 #ifndef _OSD_POSIX /* BS2000 has this option "always on" */
 	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 			 "proxy: error setting reuseaddr option");
-	    apr_close_socket(dsock);
+	    apr_socket_close(dsock);
 	    ap_bclose(f);
 	    return HTTP_INTERNAL_SERVER_ERROR;
 #endif /*_OSD_POSIX*/
 	}
 
-        if (apr_getaddrinfo(&localsa, npaddr, APR_INET, npport, 0, r->pool) 
+        if (apr_sockaddr_info_get(&localsa, npaddr, APR_INET, npport, 0, r->pool) 
             != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "proxy: error creating local socket address");
@@ -901,7 +901,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
 	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 			 "proxy: error binding to ftp data socket %s", buff);
 	    ap_bclose(f);
-	    apr_close_socket(dsock);
+	    apr_socket_close(dsock);
 	    return HTTP_INTERNAL_SERVER_ERROR;
 	}
 	apr_listen(dsock, 2);	/* only need a short queue */
@@ -1170,7 +1170,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
             default:
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "proxy: failed to accept data connection");
-                apr_close_socket(dsock);
+                apr_socket_close(dsock);
                 ap_bclose(f);
                 if (c != NULL) ap_proxy_cache_error(&c);
                 return HTTP_BAD_GATEWAY;
@@ -1188,7 +1188,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
 /* write status line */
     if (!r->assbackwards)
 	ap_rvputs(r, "HTTP/1.0 ", r->status_line, CRLF, NULL);
-        if (cachefp && apr_puts(apr_pstrcat(r->pool, "HTTP/1.0 ",
+        if (cachefp && apr_file_puts(apr_pstrcat(r->pool, "HTTP/1.0 ",
           r->status_line, CRLF, NULL), cachefp) != APR_SUCCESS) {
 	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		"proxy: error writing CRLF to cache");
@@ -1200,7 +1200,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
     ap_cache_el_header_walk(c, ap_proxy_send_hdr_line, r, NULL);
     if (!r->assbackwards)
 	ap_rputs(CRLF, r);
-    if (cachefp && apr_puts(CRLF, cachefp) == -1) {
+    if (cachefp && apr_file_puts(CRLF, cachefp) == -1) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 	    "proxy: error writing CRLF to cache");
 	ap_proxy_cache_error(&c);
diff --git a/modules/proxy/proxy_http.c b/modules/proxy/proxy_http.c
index f5467d9..37a6c6a 100644
--- a/modules/proxy/proxy_http.c
+++ b/modules/proxy/proxy_http.c
@@ -249,7 +249,7 @@ int ap_proxy_http_handler(request_rec *r, char *url,
 				 "Connect to remote machine blocked");
     }
 
-    if ((apr_create_socket(&sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
+    if ((apr_socket_create(&sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "proxy: error creating socket");
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -292,16 +292,16 @@ int ap_proxy_http_handler(request_rec *r, char *url,
 
     buf = apr_pstrcat(r->pool, r->method, " ", proxyhost ? url : urlptr,
                       " HTTP/1.0" CRLF, NULL);
-    e = apr_bucket_create_pool(buf, strlen(buf), r->pool);
+    e = apr_bucket_pool_create(buf, strlen(buf), r->pool);
     APR_BRIGADE_INSERT_TAIL(bb, e);
     if (destportstr != NULL && destport != DEFAULT_HTTP_PORT) {
         buf = apr_pstrcat(r->pool, "Host: ", desthost, ":", destportstr, CRLF, NULL);
-        e = apr_bucket_create_pool(buf, strlen(buf), r->pool);
+        e = apr_bucket_pool_create(buf, strlen(buf), r->pool);
         APR_BRIGADE_INSERT_TAIL(bb, e);
     }
     else {
         buf = apr_pstrcat(r->pool, "Host: ", desthost, CRLF, NULL);
-        e = apr_bucket_create_pool(buf, strlen(buf), r->pool);
+        e = apr_bucket_pool_create(buf, strlen(buf), r->pool);
         APR_BRIGADE_INSERT_TAIL(bb, e);
     }
 
@@ -344,14 +344,14 @@ int ap_proxy_http_handler(request_rec *r, char *url,
 	    || !strcasecmp(reqhdrs[i].key, "Proxy-Authorization"))
 	    continue;
         buf = apr_pstrcat(r->pool, reqhdrs[i].key, ": ", reqhdrs[i].val, CRLF, NULL);
-        e = apr_bucket_create_pool(buf, strlen(buf), r->pool);
+        e = apr_bucket_pool_create(buf, strlen(buf), r->pool);
         APR_BRIGADE_INSERT_TAIL(bb, e);
 
     }
 
-    e = apr_bucket_create_pool(CRLF, strlen(CRLF), r->pool);
+    e = apr_bucket_pool_create(CRLF, strlen(CRLF), r->pool);
     APR_BRIGADE_INSERT_TAIL(bb, e);
-    e = apr_bucket_create_flush();
+    e = apr_bucket_flush_create();
     APR_BRIGADE_INSERT_TAIL(bb, e);
 
     ap_pass_brigade(origin->output_filters, bb);
@@ -359,12 +359,12 @@ int ap_proxy_http_handler(request_rec *r, char *url,
 
     if (ap_should_client_block(r)) {
 	while ((i = ap_get_client_block(r, buffer, sizeof buffer)) > 0) {
-            e = apr_bucket_create_pool(buffer, i, r->pool);
+            e = apr_bucket_pool_create(buffer, i, r->pool);
             APR_BRIGADE_INSERT_TAIL(bb, e);
         }
     }
     /* Flush the data to the origin server */
-    e = apr_bucket_create_flush();
+    e = apr_bucket_flush_create();
     APR_BRIGADE_INSERT_TAIL(bb, e);
     ap_pass_brigade(origin->output_filters, bb);
 
@@ -381,14 +381,14 @@ int ap_proxy_http_handler(request_rec *r, char *url,
     e = APR_BRIGADE_FIRST(bb);
     apr_bucket_read(e, (const char **)&buffer2, &len, APR_BLOCK_READ);
     if (len == -1) {
-	apr_close_socket(sock);
+	apr_socket_close(sock);
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 	     "ap_get_brigade() - proxy receive - Error reading from remote server %s (length %d)",
 	     proxyhost ? proxyhost : desthost, len);
 	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
 			     "Error reading from remote server");
     } else if (len == 0) {
-	apr_close_socket(sock);
+	apr_socket_close(sock);
 	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
 			     "Document contains no data");
     }
@@ -405,7 +405,7 @@ int ap_proxy_http_handler(request_rec *r, char *url,
 
 /* If not an HTTP/1 message or if the status line was > 8192 bytes */
 	if (buffer2[5] != '1' || buffer2[len - 1] != '\n') {
-	    apr_close_socket(sock);
+	    apr_socket_close(sock);
 	    return HTTP_BAD_GATEWAY;
 	}
 	backasswards = 0;
@@ -477,7 +477,7 @@ int ap_proxy_http_handler(request_rec *r, char *url,
     if (!r->assbackwards)
 	ap_rvputs(r, "HTTP/1.0 ", r->status_line, CRLF, NULL);
 
-    if (cachefp && apr_puts(apr_pstrcat(r->pool, "HTTP/1.0 ",
+    if (cachefp && apr_file_puts(apr_pstrcat(r->pool, "HTTP/1.0 ",
         r->status_line, CRLF, NULL), cachefp) != APR_SUCCESS) {
 	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		"proxy: error writing status line to cache");
@@ -498,9 +498,9 @@ int ap_proxy_http_handler(request_rec *r, char *url,
 /* Is it an HTTP/0.9 response? If so, send the extra data */
     if (backasswards) {
         cntr = len;
-        e = apr_bucket_create_heap(buffer, cntr, 0, NULL);
+        e = apr_bucket_heap_create(buffer, cntr, 0, NULL);
         APR_BRIGADE_INSERT_TAIL(bb, e);
-        if (cachefp && apr_write(cachefp, buffer, &cntr) != APR_SUCCESS) {
+        if (cachefp && apr_file_write(cachefp, buffer, &cntr) != APR_SUCCESS) {
 	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		"proxy: error writing extra data to cache");
 	}
@@ -526,6 +526,6 @@ int ap_proxy_http_handler(request_rec *r, char *url,
         }
     }
 
-    apr_close_socket(sock);
+    apr_socket_close(sock);
     return OK;
 }
diff --git a/modules/proxy/proxy_util.c b/modules/proxy/proxy_util.c
index d726202..ec2e86c 100644
--- a/modules/proxy/proxy_util.c
+++ b/modules/proxy/proxy_util.c
@@ -376,11 +376,11 @@ static request_rec *make_fake_req(conn_rec *c)
     r->pool            = c->pool;
     r->status          = HTTP_OK;
 
-    r->headers_in      = apr_make_table(r->pool, 50);
-    r->subprocess_env  = apr_make_table(r->pool, 50);
-    r->headers_out     = apr_make_table(r->pool, 12);
-    r->err_headers_out = apr_make_table(r->pool, 5);
-    r->notes           = apr_make_table(r->pool, 5);
+    r->headers_in      = apr_table_make(r->pool, 50);
+    r->subprocess_env  = apr_table_make(r->pool, 50);
+    r->headers_out     = apr_table_make(r->pool, 12);
+    r->err_headers_out = apr_table_make(r->pool, 5);
+    r->notes           = apr_table_make(r->pool, 5);
 
     r->read_body       = REQUEST_NO_BODY;
     r->connection      = c;
@@ -531,7 +531,7 @@ long int ap_proxy_send_fb(proxy_completion *completion, BUFF *f, request_rec *r,
 	/* Write to cache first. */
 	/*@@@ XXX FIXME: Assuming that writing the cache file won't time out?!!? */
         wrote_to_cache = cntr;
-        if (cachefp && apr_write(cachefp, &buf[0], &wrote_to_cache) != APR_SUCCESS) {
+        if (cachefp && apr_file_write(cachefp, &buf[0], &wrote_to_cache) != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		"proxy: error writing to cache");
             ap_proxy_cache_error(&c);
@@ -1162,7 +1162,7 @@ apr_status_t ap_proxy_doconnect(apr_socket_t *sock, char *host, apr_uint32_t por
     apr_status_t rv;
     apr_sockaddr_t *destsa;
 
-    rv = apr_getaddrinfo(&destsa, host, AF_INET, port, 0, r->pool);
+    rv = apr_sockaddr_info_get(&destsa, host, AF_INET, port, 0, r->pool);
     if (rv == APR_SUCCESS) {
         rv = apr_connect(sock, destsa);
     }
@@ -1195,7 +1195,7 @@ unsigned ap_proxy_bputs2(const char *data, apr_socket_t *client, ap_cache_el *ca
     apr_send(client, data, &len);
 
     if (ap_cache_el_data(cache, &cachefp) == APR_SUCCESS)
-	apr_puts(data, cachefp);
+	apr_file_puts(data, cachefp);
     return len;
 }
 
@@ -1261,7 +1261,7 @@ int ap_proxy_cache_send(request_rec *r, ap_cache_el *c)
     if(ap_cache_el_data(c, &cachefp) != APR_SUCCESS)
         return HTTP_INTERNAL_SERVER_ERROR;
     /* send the response */
-    if(apr_fgets(buffer, sizeof(buffer), cachefp)) {
+    if(apr_file_gets(buffer, sizeof(buffer), cachefp)) {
         len = strlen(buffer);
         apr_send(fp, buffer, &len);
         offset +=len;
@@ -1271,7 +1271,7 @@ int ap_proxy_cache_send(request_rec *r, ap_cache_el *c)
     len = 2;
     apr_send(fp, CRLF, &len);
     /* send data */
-    apr_getfileinfo(&finfo, APR_FINFO_MIN, cachefp);
+    apr_file_info_get(&finfo, APR_FINFO_MIN, cachefp);
     if(!r->header_only && ap_send_fd(cachefp, r, offset, finfo.size, &len))
         return HTTP_INTERNAL_SERVER_ERROR;
     return OK;
diff --git a/modules/test/mod_autoindex.c b/modules/test/mod_autoindex.c
index ce5c6c2..dd8ef9e 100644
--- a/modules/test/mod_autoindex.c
+++ b/modules/test/mod_autoindex.c
@@ -212,7 +212,7 @@ static void emit_preamble(request_rec *r, char *title)
 static void push_item(apr_array_header_t *arr, char *type, const char *to,
 		      const char *path, const char *data)
 {
-    struct item *p = (struct item *) apr_push_array(arr);
+    struct item *p = (struct item *) apr_array_push(arr);
 
     if (!to) {
 	to = "";
@@ -316,7 +316,7 @@ static const char *add_desc(cmd_parms *cmd, void *d, const char *desc,
     ai_desc_t *desc_entry;
     char *prefix = "";
 
-    desc_entry = (ai_desc_t *) apr_push_array(dcfg->desc_list);
+    desc_entry = (ai_desc_t *) apr_array_push(dcfg->desc_list);
     desc_entry->full_path = (ap_strchr_c(to, '/') == NULL) ? 0 : 1;
     desc_entry->wildcards = (WILDCARDS_REQUIRED
 			     || desc_entry->full_path
@@ -596,12 +596,12 @@ static void *create_autoindex_config(apr_pool_t *p, char *dummy)
     new->icon_height = 0;
     new->name_width = DEFAULT_NAME_WIDTH;
     new->name_adjust = K_UNSET;
-    new->icon_list = apr_make_array(p, 4, sizeof(struct item));
-    new->alt_list = apr_make_array(p, 4, sizeof(struct item));
-    new->desc_list = apr_make_array(p, 4, sizeof(ai_desc_t));
-    new->ign_list = apr_make_array(p, 4, sizeof(struct item));
-    new->hdr_list = apr_make_array(p, 4, sizeof(struct item));
-    new->rdme_list = apr_make_array(p, 4, sizeof(struct item));
+    new->icon_list = apr_array_make(p, 4, sizeof(struct item));
+    new->alt_list = apr_array_make(p, 4, sizeof(struct item));
+    new->desc_list = apr_array_make(p, 4, sizeof(ai_desc_t));
+    new->ign_list = apr_array_make(p, 4, sizeof(struct item));
+    new->hdr_list = apr_array_make(p, 4, sizeof(struct item));
+    new->rdme_list = apr_array_make(p, 4, sizeof(struct item));
     new->opts = 0;
     new->incremented_opts = 0;
     new->decremented_opts = 0;
@@ -622,12 +622,12 @@ static void *merge_autoindex_configs(apr_pool_t *p, void *basev, void *addv)
     new->icon_height = add->icon_height ? add->icon_height : base->icon_height;
     new->icon_width = add->icon_width ? add->icon_width : base->icon_width;
 
-    new->alt_list = apr_append_arrays(p, add->alt_list, base->alt_list);
-    new->ign_list = apr_append_arrays(p, add->ign_list, base->ign_list);
-    new->hdr_list = apr_append_arrays(p, add->hdr_list, base->hdr_list);
-    new->desc_list = apr_append_arrays(p, add->desc_list, base->desc_list);
-    new->icon_list = apr_append_arrays(p, add->icon_list, base->icon_list);
-    new->rdme_list = apr_append_arrays(p, add->rdme_list, base->rdme_list);
+    new->alt_list = apr_array_append(p, add->alt_list, base->alt_list);
+    new->ign_list = apr_array_append(p, add->ign_list, base->ign_list);
+    new->hdr_list = apr_array_append(p, add->hdr_list, base->hdr_list);
+    new->desc_list = apr_array_append(p, add->desc_list, base->desc_list);
+    new->icon_list = apr_array_append(p, add->icon_list, base->icon_list);
+    new->rdme_list = apr_array_append(p, add->rdme_list, base->rdme_list);
     if (add->opts & NO_OPTIONS) {
 	/*
 	 * If the current directory says 'no options' then we also
@@ -916,10 +916,10 @@ static void do_emit_plain(request_rec *r, apr_file_t *f)
     apr_status_t stat;
 
     ap_rputs("<PRE>\n", r);
-    while (!apr_eof(f)) {
+    while (!apr_file_eof(f)) {
 	do {
             n = sizeof(char) * IOBUFSIZE;
-	    stat = apr_read(f, buf, &n);
+	    stat = apr_file_read(f, buf, &n);
 	}
 	while (stat != APR_SUCCESS && APR_STATUS_IS_EINTR(stat));
 	if (n == -1 || n == 0) {
@@ -1011,12 +1011,12 @@ static void emit_head(request_rec *r, char *header_fname, int suppress_amble,
 		 * the file's contents, any HTML header it had won't end up
 		 * where it belongs.
 		 */
-		if (apr_open(&f, rr->filename, APR_READ,
+		if (apr_file_open(&f, rr->filename, APR_READ,
                             APR_OS_DEFAULT, r->pool) == APR_SUCCESS) {
 		    emit_preamble(r, title);
 		    emit_amble = 0;
 		    do_emit_plain(r, f);
-		    apr_close(f);
+		    apr_file_close(f);
 		    emit_H1 = 0;
 		}
 	    }
@@ -1079,10 +1079,10 @@ static void emit_tail(request_rec *r, char *readme_fname, int suppress_amble)
 		/*
 		 * If we can open the file, suppress the signature.
 		 */
-		if (apr_open(&f, rr->filename, APR_READ,
+		if (apr_file_open(&f, rr->filename, APR_READ,
                             APR_OS_DEFAULT, r->pool) == APR_SUCCESS) {
 		    do_emit_plain(r, f);
-		    apr_close(f);
+		    apr_file_close(f);
 		    suppress_sig = 1;
 		}
 	    }
@@ -1116,14 +1116,14 @@ static char *find_title(request_rec *r)
 			"text/html")
 	    || !strcmp(r->content_type, INCLUDES_MAGIC_TYPE))
 	&& !r->content_encoding) {
-        if (apr_open(&thefile, r->filename, APR_READ,
+        if (apr_file_open(&thefile, r->filename, APR_READ,
                     APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
 	    return NULL;
 	}
         n = sizeof(char) * (MAX_STRING_LEN - 1);
-	apr_read(thefile, titlebuf, &n);
+	apr_file_read(thefile, titlebuf, &n);
 	if (n <= 0) {
-	    apr_close(thefile);
+	    apr_file_close(thefile);
 	    return NULL;
 	}
 	titlebuf[n] = '\0';
@@ -1144,7 +1144,7 @@ static char *find_title(request_rec *r)
 			    }
 			}
 		    }
-		    apr_close(thefile);
+		    apr_file_close(thefile);
 		    return apr_pstrdup(r->pool, &titlebuf[x]);
 		}
 	    }
@@ -1152,7 +1152,7 @@ static char *find_title(request_rec *r)
 		p = 0;
 	    }
 	}
-	apr_close(thefile);
+	apr_file_close(thefile);
     }
     return NULL;
 }
@@ -1308,7 +1308,7 @@ static void output_directories(struct ent **ar, int n,
     char *name_scratch;
     char *pad_scratch;
 
-    apr_create_pool(&scratch, r->pool);
+    apr_pool_create(&scratch, r->pool);
     if (name[0] == '\0') {
 	name = "/";
     }
diff --git a/modules/test/mod_test_util_uri.c b/modules/test/mod_test_util_uri.c
index 0b48ebb..3804018 100644
--- a/modules/test/mod_test_util_uri.c
+++ b/modules/test/mod_test_util_uri.c
@@ -207,7 +207,7 @@ static unsigned iterate_pieces(request_rec *r, const test_uri_t *pieces, int row
 	}
 	*strp = 0;
 
-	sub = apr_make_sub_pool(r->pool);
+	sub = apr_pool_sub_make(r->pool);
 	status = ap_parse_uri_components(sub, input_uri, &result);
 	if (status == HTTP_OK) {
 #define CHECK(f)							\
@@ -255,7 +255,7 @@ static unsigned iterate_pieces(request_rec *r, const test_uri_t *pieces, int row
 	    ap_rputs("</tr>\n", r);
 	    ++failures;
 	}
-	apr_destroy_pool(sub);
+	apr_pool_destroy(sub);
     }
     return failures;
 }
diff --git a/os/beos/os.c b/os/beos/os.c
index dc1a63c..ddadcf2 100644
--- a/os/beos/os.c
+++ b/os/beos/os.c
@@ -80,5 +80,5 @@ AP_DECLARE(apr_status_t) ap_os_create_privileged_process(
     const char * const *env,
     apr_procattr_t *attr, apr_pool_t *p)
 {
-    return apr_create_process(newproc, progname, args, env, attr, p);
+    return apr_proc_create(newproc, progname, args, env, attr, p);
 }
diff --git a/os/bs2000/os.c b/os/bs2000/os.c
index 088230b..6110049 100644
--- a/os/bs2000/os.c
+++ b/os/bs2000/os.c
@@ -110,6 +110,6 @@ AP_DECLARE(apr_status_t) ap_os_create_privileged_process(
     const char * const *env,
     apr_procattr_t *attr, apr_pool_t *p)
 {
-    return apr_create_process(newproc, progname, args, env, attr, p);
+    return apr_proc_create(newproc, progname, args, env, attr, p);
 }
 
diff --git a/os/os2/util_os2.c b/os/os2/util_os2.c
index 5a0dc5a..0edec7d 100644
--- a/os/os2/util_os2.c
+++ b/os/os2/util_os2.c
@@ -179,5 +179,5 @@ AP_DECLARE(apr_status_t) ap_os_create_privileged_process(
     const char * const *env,
     apr_procattr_t *attr, apr_pool_t *p)
 {
-    return apr_create_process(newproc, progname, args, env, attr, p);
+    return apr_proc_create(newproc, progname, args, env, attr, p);
 }
diff --git a/os/tpf/os.c b/os/tpf/os.c
index f357228..ae16caf 100644
--- a/os/tpf/os.c
+++ b/os/tpf/os.c
@@ -323,7 +323,7 @@ int ap_tpf_spawn_child(apr_pool_t *p, int (*func) (void *, child_info *),
 
    if (pid) {
 
-       apr_note_subprocess(p, pid, kill_how);
+       apr_pool_note_subprocess(p, pid, kill_how);
 
        if (pipe_out) {
           *pipe_out = out_fds[0];
@@ -419,5 +419,5 @@ AP_DECLARE(apr_status_t) ap_os_create_privileged_process(
     const char * const *env,
     apr_procattr_t *attr, apr_pool_t *p)
 {
-    return apr_create_process(newproc, progname, args, env, attr, p);
+    return apr_proc_create(newproc, progname, args, env, attr, p);
 }
diff --git a/os/unix/unixd.c b/os/unix/unixd.c
index 3c13dd4..5870eca 100644
--- a/os/unix/unixd.c
+++ b/os/unix/unixd.c
@@ -441,7 +441,7 @@ static apr_status_t ap_unix_create_privileged_process(
     char *execuser, *execgroup;
 
     if (!unixd_config.suexec_enabled) {
-        return apr_create_process(newproc, progname, args, env, attr, p);
+        return apr_proc_create(newproc, progname, args, env, attr, p);
     }
 
     execuser = apr_psprintf(p, "%ld", (long) ugid->uid);
@@ -469,7 +469,7 @@ static apr_status_t ap_unix_create_privileged_process(
         newargs[i + 4] = args[i];
     } while (args[i++]);
 
-    return apr_create_process(newproc, newprogname, newargs, env, attr, p);
+    return apr_proc_create(newproc, newprogname, newargs, env, attr, p);
 }
 
 AP_DECLARE(apr_status_t) ap_os_create_privileged_process(
@@ -482,7 +482,7 @@ AP_DECLARE(apr_status_t) ap_os_create_privileged_process(
     ap_unix_identity_t *ugid = ap_run_get_suexec_identity(r);
 
     if (ugid == NULL) {
-        return apr_create_process(newproc, progname, args, env, attr, p);
+        return apr_proc_create(newproc, progname, args, env, attr, p);
     }
 
     return ap_unix_create_privileged_process(newproc, progname, args, env,
diff --git a/os/win32/mod_isapi.c b/os/win32/mod_isapi.c
index 803b9da..cae86d6 100644
--- a/os/win32/mod_isapi.c
+++ b/os/win32/mod_isapi.c
@@ -191,7 +191,7 @@ static apr_status_t cleanup_isapi_server_config(void *sconfv)
 static void *create_isapi_server_config(apr_pool_t *p, server_rec *s)
 {
     isapi_server_conf *sconf = apr_palloc(p, sizeof(isapi_server_conf));
-    sconf->loaded = apr_make_array(p, 20, sizeof(isapi_loaded*));
+    sconf->loaded = apr_array_make(p, 20, sizeof(isapi_loaded*));
     sconf->lock = CreateMutex(NULL, FALSE, NULL);
 
     sconf->ReadAheadBuffer = 49152;
@@ -199,8 +199,8 @@ static void *create_isapi_server_config(apr_pool_t *p, server_rec *s)
     sconf->AppendLogToErrors   = 0;
     sconf->AppendLogToQuery    = 0;
 
-    apr_register_cleanup(p, sconf, cleanup_isapi_server_config, 
-                                   apr_null_cleanup);
+    apr_pool_cleanup_register(p, sconf, cleanup_isapi_server_config, 
+                                   apr_pool_cleanup_null);
 
     return sconf;
 }
@@ -655,9 +655,9 @@ BOOL WINAPI WriteClient (HCONN ConnID, LPVOID Buffer, LPDWORD lpwdwBytes,
         ; /* XXX: Fake it */
 
     bb = apr_brigade_create(r->pool);
-    b = apr_bucket_create_transient(Buffer, (apr_size_t)lpwdwBytes);
+    b = apr_bucket_transient_create(Buffer, (apr_size_t)lpwdwBytes);
     APR_BRIGADE_INSERT_TAIL(bb, b);
-    b = apr_bucket_create_eos();
+    b = apr_bucket_eos_create();
     APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(r->output_filters, bb);
 
@@ -799,10 +799,10 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             apr_bucket_brigade *bb;
             apr_bucket *b;
             bb = apr_brigade_create(cid->r->pool);
-	    b = apr_bucket_create_transient((char*) lpdwDataType + ate, 
+	    b = apr_bucket_transient_create((char*) lpdwDataType + ate, 
                                            headlen - ate);
 	    APR_BRIGADE_INSERT_TAIL(bb, b);
-            b = apr_bucket_create_eos();
+            b = apr_bucket_eos_create();
 	    APR_BRIGADE_INSERT_TAIL(bb, b);
 	    ap_pass_brigade(cid->r->output_filters, bb);
         }
@@ -898,7 +898,7 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             return FALSE;
         }
         
-        if ((rv = apr_put_os_file(&fd, tf->hFile, r->pool)) != APR_SUCCESS) {
+        if ((rv = apr_os_file_put(&fd, tf->hFile, r->pool)) != APR_SUCCESS) {
             return FALSE;
         }
         
@@ -928,28 +928,28 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             }
             if (ate < (apr_size_t)tf->HeadLength)
             {
-                b = apr_bucket_create_transient((char*)tf->pHead + ate, 
+                b = apr_bucket_transient_create((char*)tf->pHead + ate, 
                                             (apr_size_t)tf->HeadLength - ate);
                 APR_BRIGADE_INSERT_TAIL(bb, b);
             }
         }
         else if (tf->pHead && tf->HeadLength) {
-            b = apr_bucket_create_transient((char*)tf->pHead, 
+            b = apr_bucket_transient_create((char*)tf->pHead, 
                                            (apr_size_t)tf->HeadLength);
             APR_BRIGADE_INSERT_TAIL(bb, b);
         }
 
-        b = apr_bucket_create_file(fd, (apr_off_t)tf->Offset, 
+        b = apr_bucket_file_create(fd, (apr_off_t)tf->Offset, 
                                   (apr_size_t)tf->BytesToWrite);
         APR_BRIGADE_INSERT_TAIL(bb, b);
         
         if (tf->pTail && (apr_size_t)tf->TailLength) {
-            b = apr_bucket_create_transient((char*)tf->pTail, 
+            b = apr_bucket_transient_create((char*)tf->pTail, 
                                            (apr_size_t)tf->TailLength);
             APR_BRIGADE_INSERT_TAIL(bb, b);
         }
         
-        b = apr_bucket_create_eos();
+        b = apr_bucket_eos_create();
         APR_BRIGADE_INSERT_TAIL(bb, b);
         ap_pass_brigade(r->output_filters, bb);
 
@@ -1102,10 +1102,10 @@ BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
             apr_bucket_brigade *bb;
             apr_bucket *b;
             bb = apr_brigade_create(cid->r->pool);
-	    b = apr_bucket_create_transient(shi->pszHeader + ate, 
+	    b = apr_bucket_transient_create(shi->pszHeader + ate, 
                                            (apr_size_t)shi->cchHeader - ate);
 	    APR_BRIGADE_INSERT_TAIL(bb, b);
-            b = apr_bucket_create_eos();
+            b = apr_bucket_eos_create();
 	    APR_BRIGADE_INSERT_TAIL(bb, b);
 	    ap_pass_brigade(cid->r->output_filters, bb);
         }
@@ -1259,7 +1259,7 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
     }
 
     /* Add to cached list of loaded modules */
-    newisa = apr_push_array(sconf->loaded);
+    newisa = apr_array_push(sconf->loaded);
     *newisa = isa;
     
     return NULL;
diff --git a/os/win32/util_win32.c b/os/win32/util_win32.c
index ca56879..79a3ecc 100644
--- a/os/win32/util_win32.c
+++ b/os/win32/util_win32.c
@@ -509,6 +509,6 @@ AP_DECLARE(apr_status_t) ap_os_create_privileged_process(
     const char * const *env,
     apr_procattr_t *attr, apr_pool_t *p)
 {
-    return apr_create_process(newproc, progname, args, env, attr, p);
+    return apr_proc_create(newproc, progname, args, env, attr, p);
 }
 
diff --git a/server/config.c b/server/config.c
index ecfcc6b..2fe88af 100644
--- a/server/config.c
+++ b/server/config.c
@@ -1303,12 +1303,12 @@ void ap_process_resource_config(server_rec *s, const char *fname,
                     apr_strerror(rv, errmsg, sizeof errmsg));
 	    exit(1);
 	}
-	candidates = apr_make_array(p, 1, sizeof(fnames));
+	candidates = apr_array_make(p, 1, sizeof(fnames));
         while (apr_dir_read(&dirent, APR_FINFO_DIRENT, dirp) == APR_SUCCESS) {
             /* strip out '.' and '..' */
 	    if (strcmp(dirent.name, ".") &&
 		strcmp(dirent.name, "..")) {
-		fnew = (fnames *) apr_push_array(candidates);
+		fnew = (fnames *) apr_array_push(candidates);
 		fnew->fname = ap_make_full_path(p, fname, dirent.name);
 	    }
 	}
@@ -1485,8 +1485,8 @@ AP_CORE_DECLARE(const char *) ap_init_virtual_host(apr_pool_t *p, const char *ho
     s->next = NULL;
 
     s->is_virtual = 1;
-    s->names = apr_make_array(p, 4, sizeof(char **));
-    s->wild_names = apr_make_array(p, 4, sizeof(char **));
+    s->names = apr_array_make(p, 4, sizeof(char **));
+    s->wild_names = apr_array_make(p, 4, sizeof(char **));
 
     s->module_config = create_empty_config(p);
     s->lookup_defaults = ap_create_per_dir_config(p);
@@ -1551,7 +1551,7 @@ static server_rec *init_server_config(process_rec *process, apr_pool_t *p)
     apr_status_t rv;
     server_rec *s = (server_rec *) apr_pcalloc(p, sizeof(server_rec));
 
-    apr_open_stderr(&s->error_log, p);
+    apr_file_open_stderr(&s->error_log, p);
     s->process = process;
     s->port = 0;
     s->server_admin = DEFAULT_ADMIN;
@@ -1568,7 +1568,7 @@ static server_rec *init_server_config(process_rec *process, apr_pool_t *p)
     s->next = NULL;
     s->addrs = apr_pcalloc(p, sizeof(server_addr_rec));
     /* NOT virtual host; don't match any real network interface */
-    rv = apr_getaddrinfo(&s->addrs->host_addr,
+    rv = apr_sockaddr_info_get(&s->addrs->host_addr,
                          NULL, APR_INET, 0, 0, p);
     ap_assert(rv == APR_SUCCESS); /* otherwise: bug or no storage */
     s->addrs->host_port = 0;	/* matches any port */
diff --git a/server/connection.c b/server/connection.c
index bd1ae53..0a0b380 100644
--- a/server/connection.c
+++ b/server/connection.c
@@ -138,7 +138,7 @@ AP_CORE_DECLARE(void) ap_flush_conn(conn_rec *c)
     apr_bucket *b;
 
     bb = apr_brigade_create(c->pool);
-    b = apr_bucket_create_flush();
+    b = apr_bucket_flush_create();
     APR_BRIGADE_INSERT_TAIL(bb, b);
     ap_pass_brigade(c->output_filters, bb);
 }
@@ -164,7 +164,7 @@ void ap_lingering_close(conn_rec *c)
 
 #ifdef NO_LINGCLOSE
     ap_flush_conn(c);	/* just close it */
-    apr_close_socket(c->client_socket);
+    apr_socket_close(c->client_socket);
     return;
 #endif
 
@@ -177,7 +177,7 @@ void ap_lingering_close(conn_rec *c)
     ap_flush_conn(c);
 
     if (c->aborted) {
-        apr_close_socket(c->client_socket);
+        apr_socket_close(c->client_socket);
         return;
     }
 
@@ -187,7 +187,7 @@ void ap_lingering_close(conn_rec *c)
     
     if (apr_shutdown(c->client_socket, APR_SHUTDOWN_WRITE) != APR_SUCCESS || 
         c->aborted) {
-        apr_close_socket(c->client_socket);
+        apr_socket_close(c->client_socket);
         return;
     }
 
@@ -195,7 +195,7 @@ void ap_lingering_close(conn_rec *c)
      * from peer) or we've exceeded our overall timeout.
      */
     
-    start = apr_now();
+    start = apr_time_now();
     timeout = MAX_SECS_TO_LINGER * APR_USEC_PER_SEC;
     for (;;) {
         apr_setsocketopt(c->client_socket, APR_SO_TIMEOUT, timeout);
@@ -204,14 +204,14 @@ void ap_lingering_close(conn_rec *c)
         if (rc != APR_SUCCESS || nbytes == 0) break;
 
         /* how much time has elapsed? */
-        timeout = (int)((apr_now() - start) / APR_USEC_PER_SEC);
+        timeout = (int)((apr_time_now() - start) / APR_USEC_PER_SEC);
         if (timeout >= MAX_SECS_TO_LINGER) break;
 
         /* figure out the new timeout */
         timeout = (int)((MAX_SECS_TO_LINGER - timeout) * APR_USEC_PER_SEC);
     }
 
-    apr_close_socket(c->client_socket);
+    apr_socket_close(c->client_socket);
 }
 
 AP_CORE_DECLARE(void) ap_process_connection(conn_rec *c)
@@ -254,7 +254,7 @@ AP_CORE_DECLARE_NONSTD(int) ap_process_http_connection(conn_rec *c)
 	    break;
 
         ap_update_child_status(AP_CHILD_THREAD_FROM_ID(c->id), SERVER_BUSY_KEEPALIVE, NULL);
-	apr_destroy_pool(r->pool);
+	apr_pool_destroy(r->pool);
 
 	if (ap_graceful_stop_signalled())
             break;
@@ -279,25 +279,25 @@ conn_rec *ap_new_connection(apr_pool_t *p, server_rec *server,
      */
 
     conn->conn_config=ap_create_conn_config(p);
-    conn->notes = apr_make_table(p, 5);
+    conn->notes = apr_table_make(p, 5);
 
     conn->pool = p;
-    if ((rv = apr_get_sockaddr(&conn->local_addr, APR_LOCAL, inout)) 
+    if ((rv = apr_socket_addr_get(&conn->local_addr, APR_LOCAL, inout)) 
         != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_INFO, rv, server,
-                     "apr_get_sockaddr(APR_LOCAL)");
-        apr_close_socket(inout);
+                     "apr_socket_addr_get(APR_LOCAL)");
+        apr_socket_close(inout);
         return NULL;
     }
-    apr_get_ipaddr(&conn->local_ip, conn->local_addr);
-    if ((rv = apr_get_sockaddr(&conn->remote_addr, APR_REMOTE, inout))
+    apr_sockaddr_ip_get(&conn->local_ip, conn->local_addr);
+    if ((rv = apr_socket_addr_get(&conn->remote_addr, APR_REMOTE, inout))
         != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_INFO, rv, server,
-                     "apr_get_sockaddr(APR_REMOTE)");
-        apr_close_socket(inout);
+                     "apr_socket_addr_get(APR_REMOTE)");
+        apr_socket_close(inout);
         return NULL;
     }
-    apr_get_ipaddr(&conn->remote_ip, conn->remote_addr);
+    apr_sockaddr_ip_get(&conn->remote_ip, conn->remote_addr);
     conn->base_server = server;
     conn->client_socket = inout;
 
diff --git a/server/listen.c b/server/listen.c
index dc80509..3617e08 100644
--- a/server/listen.c
+++ b/server/listen.c
@@ -93,7 +93,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
 	ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,
 		    "make_sock: for address %pI, setsockopt: (SO_REUSEADDR)", 
                      server->bind_addr);
-	apr_close_socket(s);
+	apr_socket_close(s);
 	return stat;
     }
     
@@ -102,7 +102,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
 	ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,
 		    "make_sock: for address %pI, setsockopt: (SO_KEEPALIVE)", 
                      server->bind_addr);
-	apr_close_socket(s);
+	apr_socket_close(s);
 	return stat;
     }
 
@@ -144,7 +144,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
 	ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,
                      "make_sock: could not bind to address %pI", 
                      server->bind_addr);
-	apr_close_socket(s);
+	apr_socket_close(s);
 	return stat;
     }
 
@@ -152,7 +152,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
 	ap_log_perror(APLOG_MARK, APLOG_ERR, stat, p,
 	    "make_sock: unable to listen for connections on address %pI", 
                      server->bind_addr);
-	apr_close_socket(s);
+	apr_socket_close(s);
 	return stat;
     }
 
@@ -167,7 +167,7 @@ static apr_status_t close_listeners_on_exec(void *v)
     ap_listen_rec *lr;
 
     for (lr = ap_listeners; lr; lr = lr->next) {
-	apr_close_socket(lr->sd);
+	apr_socket_close(lr->sd);
 	lr->active = 0;
     }
     return APR_SUCCESS;
@@ -184,9 +184,9 @@ static void find_default_family(apr_pool_t *p)
     if (default_family == APR_UNSPEC) {
         apr_socket_t *tmp_sock;
 
-        if (apr_create_socket(&tmp_sock, APR_INET6, SOCK_STREAM, 
+        if (apr_socket_create(&tmp_sock, APR_INET6, SOCK_STREAM, 
                               p) == APR_SUCCESS) {
-            apr_close_socket(tmp_sock);
+            apr_socket_close(tmp_sock);
             default_family = APR_INET6;
         }
         else {
@@ -224,9 +224,9 @@ static void alloc_listener(process_rec *process, char *addr, apr_port_t port)
 
     /* see if we've got an old listener for this address:port */
     for (walk = &old_listeners; *walk; walk = &(*walk)->next) {
-        apr_get_sockaddr(&sa, APR_LOCAL, (*walk)->sd);
-        apr_get_port(&oldport, sa);
-	apr_get_ipaddr(&oldaddr, sa);
+        apr_socket_addr_get(&sa, APR_LOCAL, (*walk)->sd);
+        apr_sockaddr_port_get(&oldport, sa);
+	apr_sockaddr_ip_get(&oldaddr, sa);
 	if (!strcmp(oldaddr, addr) && port == oldport) {
 	    /* re-use existing record */
 	    new = *walk;
@@ -240,21 +240,21 @@ static void alloc_listener(process_rec *process, char *addr, apr_port_t port)
     /* this has to survive restarts */
     new = apr_palloc(process->pool, sizeof(ap_listen_rec));
     new->active = 0;
-    if ((status = apr_getaddrinfo(&new->bind_addr, addr, APR_UNSPEC, port, 0, 
+    if ((status = apr_sockaddr_info_get(&new->bind_addr, addr, APR_UNSPEC, port, 0, 
                                   process->pool)) != APR_SUCCESS) {
         ap_log_perror(APLOG_MARK, APLOG_CRIT, status, process->pool,
                      "alloc_listener: failed to set up sockaddr for %s", addr);
         return;
     }
-    if ((status = apr_create_socket(&new->sd, new->bind_addr->sa.sin.sin_family, 
+    if ((status = apr_socket_create(&new->sd, new->bind_addr->sa.sin.sin_family, 
                                     SOCK_STREAM, process->pool)) != APR_SUCCESS) {
         ap_log_perror(APLOG_MARK, APLOG_CRIT, status, process->pool,
                      "alloc_listener: failed to get a socket for %s", addr);
         return;
     }
-    apr_get_sockaddr(&sa, APR_LOCAL, new->sd);
-    apr_set_port(sa, port);
-    apr_set_ipaddr(sa, addr);
+    apr_socket_addr_get(&sa, APR_LOCAL, new->sd);
+    apr_sockaddr_port_set(sa, port);
+    apr_sockaddr_ip_set(sa, addr);
     new->next = ap_listeners;
     ap_listeners = new;
 }
@@ -289,14 +289,14 @@ int ap_listen_open(process_rec *process, apr_port_t port)
 
     /* close the old listeners */
     for (lr = old_listeners; lr; lr = next) {
-	apr_close_socket(lr->sd);
+	apr_socket_close(lr->sd);
 	lr->active = 0;
 	next = lr->next;
 /*	free(lr);*/
     }
     old_listeners = NULL;
 
-    apr_register_cleanup(pconf, NULL, apr_null_cleanup, close_listeners_on_exec);
+    apr_pool_cleanup_register(pconf, NULL, apr_pool_cleanup_null, close_listeners_on_exec);
 
     return num_open ? 0 : -1;
 }
diff --git a/server/log.c b/server/log.c
index c83ce54..9b7fec3 100644
--- a/server/log.c
+++ b/server/log.c
@@ -178,7 +178,7 @@ static apr_file_t *stderr_log;
 
 AP_DECLARE(void) ap_open_stderr_log(apr_pool_t *p)
 {
-    apr_open_stderr(&stderr_log, p);
+    apr_file_open_stderr(&stderr_log, p);
 }
 
 static int log_child(apr_pool_t *p, const char *progname,
@@ -197,8 +197,8 @@ static int log_child(apr_pool_t *p, const char *progname,
     apr_signal(SIGHUP, SIG_IGN);
 #endif /* ndef SIGHUP */
 
-    if (((rc = apr_createprocattr_init(&procattr, p)) == APR_SUCCESS) &&
-        ((rc = apr_setprocattr_io(procattr,
+    if (((rc = apr_procattr_create(&procattr, p)) == APR_SUCCESS) &&
+        ((rc = apr_procattr_io_set(procattr,
                                   APR_FULL_BLOCK,
                                   APR_NO_PIPE,
                                   APR_NO_PIPE)) == APR_SUCCESS)) {
@@ -208,11 +208,11 @@ static int log_child(apr_pool_t *p, const char *progname,
         apr_tokenize_to_argv(progname, &args, p);
         pname = apr_pstrdup(p, args[0]);
         procnew = (apr_proc_t *) apr_pcalloc(p, sizeof(*procnew));
-        rc = apr_create_process(procnew, pname, (const char * const *)args,
+        rc = apr_proc_create(procnew, pname, (const char * const *)args,
                                 NULL, procattr, p);
     
         if (rc == APR_SUCCESS) {
-            apr_note_subprocess(p, procnew, kill_after_timeout);
+            apr_pool_note_subprocess(p, procnew, kill_after_timeout);
             (*fpin) = procnew->in;
         }
     }
@@ -262,7 +262,7 @@ static void open_error_log(server_rec *s, apr_pool_t *p)
 #endif
     else {
 	fname = ap_server_root_relative(p, s->error_fname);
-        rc = apr_open(&s->error_log, fname, 
+        rc = apr_file_open(&s->error_log, fname, 
                       APR_APPEND | APR_READ | APR_WRITE | APR_CREATE,
                       APR_OS_DEFAULT, p);
         if (rc != APR_SUCCESS) {
@@ -286,9 +286,9 @@ void ap_open_logs(server_rec *s_main, apr_pool_t *p)
     replace_stderr = 1;
     if (s_main->error_log) {
         /* replace stderr with this new log */
-        apr_flush(s_main->error_log);
-        apr_open_stderr(&errfile, p);        
-        if ((rc = apr_dupfile(&errfile, s_main->error_log, p)) != APR_SUCCESS) {
+        apr_file_flush(s_main->error_log);
+        apr_file_open_stderr(&errfile, p);        
+        if ((rc = apr_file_dup(&errfile, s_main->error_log, p)) != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_CRIT, rc, s_main,
                          "unable to replace stderr with error_log");
         } else {
@@ -323,9 +323,9 @@ void ap_open_logs(server_rec *s_main, apr_pool_t *p)
 AP_DECLARE(void) ap_error_log2stderr(server_rec *s) {
     apr_file_t *errfile = NULL;
 
-    apr_open_stderr(&errfile, s->process->pool);        
+    apr_file_open_stderr(&errfile, s->process->pool);        
     if (s->error_log != NULL) {
-        apr_dupfile(&(s->error_log), errfile, s->process->pool);
+        apr_file_dup(&(s->error_log), errfile, s->process->pool);
     }
 }
 
@@ -384,7 +384,7 @@ static void log_error_core(const char *file, int line, int level,
 
     if (logf && ((level & APLOG_STARTUP) != APLOG_STARTUP)) {
 	errstr[0] = '[';
-	apr_ctime(errstr + 1, apr_now());
+	apr_ctime(errstr + 1, apr_time_now());
 	errstr[1 + APR_CTIME_LEN - 1] = ']';
 	errstr[1 + APR_CTIME_LEN    ] = ' ';
 	len = 1 + APR_CTIME_LEN + 1;
@@ -448,8 +448,8 @@ static void log_error_core(const char *file, int line, int level,
         if (len > MAX_STRING_LEN - sizeof(APR_EOL_STR))
             len = MAX_STRING_LEN - sizeof(APR_EOL_STR);
         strcpy(errstr + len, APR_EOL_STR);
-        apr_puts(errstr, logf);
-	apr_flush(logf);
+        apr_file_puts(errstr, logf);
+	apr_file_flush(logf);
     }
 #ifdef HAVE_SYSLOG
     else {
@@ -536,7 +536,7 @@ void ap_log_pid(apr_pool_t *p, const char *fname)
 			       );
     }
 
-    if ((rv = apr_open(&pid_file, fname, APR_WRITE | APR_CREATE | APR_TRUNCATE,
+    if ((rv = apr_file_open(&pid_file, fname, APR_WRITE | APR_CREATE | APR_TRUNCATE,
                       APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD, p)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, 
                      "could not create %s", fname);
@@ -545,8 +545,8 @@ void ap_log_pid(apr_pool_t *p, const char *fname)
 		     ap_server_argv0, fname);
         exit(1);
     }
-    apr_fprintf(pid_file, "%ld" APR_EOL_STR, (long)mypid);
-    apr_close(pid_file);
+    apr_file_printf(pid_file, "%ld" APR_EOL_STR, (long)mypid);
+    apr_file_close(pid_file);
     saved_pid = mypid;
 }
 
@@ -554,7 +554,7 @@ AP_DECLARE(void) ap_log_assert(const char *szExp, const char *szFile, int nLine)
 {
     char time_str[APR_CTIME_LEN];
 
-    apr_ctime(time_str, apr_now());
+    apr_ctime(time_str, apr_time_now());
     ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL,
                  "[%s] file %s, line %d, assertion \"%s\" failed",
 	         time_str, szFile, nLine, szExp);
@@ -582,8 +582,8 @@ static int piped_log_spawn(piped_log *pl)
 #ifdef SIGHUP
     apr_signal(SIGHUP, SIG_IGN);
 #endif
-    if (((status = apr_createprocattr_init(&procattr, pl->p)) != APR_SUCCESS) ||
-        ((status = apr_setprocattr_childin(procattr, ap_piped_log_read_fd(pl), 
+    if (((status = apr_procattr_create(&procattr, pl->p)) != APR_SUCCESS) ||
+        ((status = apr_procattr_child_in_set(procattr, ap_piped_log_read_fd(pl), 
                                 ap_piped_log_write_fd(pl)))  != APR_SUCCESS)) {
         char buf[120];
         /* Something bad happened, give up and go away. */
@@ -599,17 +599,17 @@ static int piped_log_spawn(piped_log *pl)
         apr_tokenize_to_argv(pl->program, &args, pl->p);
         pname = apr_pstrdup(pl->p, args[0]);
         procnew = apr_pcalloc(pl->p, sizeof(apr_proc_t));
-        rc = apr_create_process(procnew, pname, (const char * const *) args,
+        rc = apr_proc_create(procnew, pname, (const char * const *) args,
                                 NULL, procattr, pl->p);
     
         if (rc == APR_SUCCESS) {            
             /* pjr - This no longer happens inside the child, */
-            /*   I am assuming that if apr_create_process was  */
+            /*   I am assuming that if apr_proc_create was  */
             /*   successful that the child is running.        */
             RAISE_SIGSTOP(PIPED_LOG_SPAWN); 
             pl->pid = procnew;
             ap_piped_log_write_fd(pl) = procnew->in;
-            apr_register_other_child(procnew, piped_log_maintenance, pl, 
+            apr_proc_other_child_register(procnew, piped_log_maintenance, pl, 
                                     ap_piped_log_write_fd(pl), pl->p);
         }
     }
@@ -626,7 +626,7 @@ static void piped_log_maintenance(int reason, void *data, apr_wait_t status)
     switch (reason) {
     case APR_OC_REASON_DEATH:
 	pl->pid = NULL;
-	apr_unregister_other_child(pl);
+	apr_proc_other_child_unregister(pl);
 	if (pl->program == NULL) {
 	    /* during a restart */
 	    break;
@@ -634,7 +634,7 @@ static void piped_log_maintenance(int reason, void *data, apr_wait_t status)
         break;
     case APR_OC_REASON_LOST:
 	pl->pid = NULL;
-	apr_unregister_other_child(pl);
+	apr_proc_other_child_unregister(pl);
 	if (pl->program == NULL) {
 	    /* during a restart */
 	    break;
@@ -657,7 +657,7 @@ static void piped_log_maintenance(int reason, void *data, apr_wait_t status)
     case APR_OC_REASON_RESTART:
 	pl->program = NULL;
 	if (pl->pid != NULL) {
-	    apr_kill(pl->pid, SIGTERM);
+	    apr_proc_kill(pl->pid, SIGTERM);
 	}
 	break;
 
@@ -672,11 +672,11 @@ static apr_status_t piped_log_cleanup(void *data)
     piped_log *pl = data;
 
     if (pl->pid != NULL) {
-	apr_kill(pl->pid, SIGTERM);
+	apr_proc_kill(pl->pid, SIGTERM);
     }
-    apr_unregister_other_child(pl);
-    apr_close(ap_piped_log_read_fd(pl));
-    apr_close(ap_piped_log_write_fd(pl));
+    apr_proc_other_child_unregister(pl);
+    apr_file_close(ap_piped_log_read_fd(pl));
+    apr_file_close(ap_piped_log_write_fd(pl));
     return APR_SUCCESS;
 }
 
@@ -685,8 +685,8 @@ static apr_status_t piped_log_cleanup_for_exec(void *data)
 {
     piped_log *pl = data;
 
-    apr_close(ap_piped_log_read_fd(pl));
-    apr_close(ap_piped_log_write_fd(pl));
+    apr_file_close(ap_piped_log_read_fd(pl));
+    apr_file_close(ap_piped_log_write_fd(pl));
     return APR_SUCCESS;
 }
 
@@ -698,15 +698,15 @@ AP_DECLARE(piped_log *) ap_open_piped_log(apr_pool_t *p, const char *program)
     pl->p = p;
     pl->program = apr_pstrdup(p, program);
     pl->pid = NULL;
-    if (apr_create_pipe(&ap_piped_log_read_fd(pl), &ap_piped_log_write_fd(pl), p) != APR_SUCCESS) {
+    if (apr_file_pipe_create(&ap_piped_log_read_fd(pl), &ap_piped_log_write_fd(pl), p) != APR_SUCCESS) {
 	return NULL;
     }
-    apr_register_cleanup(p, pl, piped_log_cleanup, piped_log_cleanup_for_exec);
+    apr_pool_cleanup_register(p, pl, piped_log_cleanup, piped_log_cleanup_for_exec);
     if (piped_log_spawn(pl) == -1) {
 	int save_errno = errno;
-	apr_kill_cleanup(p, pl, piped_log_cleanup);
-	apr_close(ap_piped_log_read_fd(pl));
-	apr_close(ap_piped_log_write_fd(pl));
+	apr_pool_cleanup_kill(p, pl, piped_log_cleanup);
+	apr_file_close(ap_piped_log_read_fd(pl));
+	apr_file_close(ap_piped_log_write_fd(pl));
 	errno = save_errno;
 	return NULL;
     }
@@ -719,7 +719,7 @@ static apr_status_t piped_log_cleanup(void *data)
 {
     piped_log *pl = data;
 
-    apr_close(ap_piped_log_write_fd(pl));
+    apr_file_close(ap_piped_log_write_fd(pl));
     return APR_SUCCESS;
 }
 
@@ -740,7 +740,7 @@ AP_DECLARE(piped_log *) ap_open_piped_log(apr_pool_t *p, const char *program)
     pl->p = p;
     ap_piped_log_read_fd(pl) = NULL;
     ap_piped_log_write_fd(pl) = dummy;
-    apr_register_cleanup(p, pl, piped_log_cleanup, piped_log_cleanup);
+    apr_pool_cleanup_register(p, pl, piped_log_cleanup, piped_log_cleanup);
 
     return pl;
 }
@@ -749,6 +749,6 @@ AP_DECLARE(piped_log *) ap_open_piped_log(apr_pool_t *p, const char *program)
 
 AP_DECLARE(void) ap_close_piped_log(piped_log *pl)
 {
-    apr_run_cleanup(pl->p, pl, piped_log_cleanup);
+    apr_pool_cleanup_run(pl->p, pl, piped_log_cleanup);
 }
 
diff --git a/server/main.c b/server/main.c
index 22fd9dc..c695622 100644
--- a/server/main.c
+++ b/server/main.c
@@ -201,7 +201,7 @@ static void show_compile_settings(void)
 
 static void destroy_and_exit_process(process_rec *process, int process_exit_value)
 {
-    apr_destroy_pool(process->pool); /* and destroy all descendent pools */
+    apr_pool_destroy(process->pool); /* and destroy all descendent pools */
     apr_terminate();
     exit(process_exit_value);
 }
@@ -212,13 +212,13 @@ static process_rec *create_process(int argc, const char * const *argv)
     apr_pool_t *cntx;
     apr_status_t stat;
 
-    stat = apr_create_pool(&cntx, NULL);
+    stat = apr_pool_create(&cntx, NULL);
     if (stat != APR_SUCCESS) {
         /* XXX From the time that we took away the NULL pool->malloc mapping
          *     we have been unable to log here without segfaulting.
          */
         ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, NULL,
-                     "apr_create_pool() failed to create "
+                     "apr_pool_create() failed to create "
                      "initial context");
         apr_terminate();
         exit(1);
@@ -229,7 +229,7 @@ static process_rec *create_process(int argc, const char * const *argv)
     process = apr_palloc(cntx, sizeof(process_rec));
     process->pool = cntx;
 
-    apr_create_pool(&process->pconf, process->pool);
+    apr_pool_create(&process->pconf, process->pool);
     process->argc = argc;
     process->argv = argv;
     process->short_name = apr_filename_of_pathname(argv[0]);
@@ -320,35 +320,35 @@ int main(int argc, const char * const argv[])
 
     ap_setup_prelinked_modules(process);
 
-    apr_create_pool(&pcommands, pglobal);
-    ap_server_pre_read_config  = apr_make_array(pcommands, 1, sizeof(char *));
-    ap_server_post_read_config = apr_make_array(pcommands, 1, sizeof(char *));
-    ap_server_config_defines   = apr_make_array(pcommands, 1, sizeof(char *));
+    apr_pool_create(&pcommands, pglobal);
+    ap_server_pre_read_config  = apr_array_make(pcommands, 1, sizeof(char *));
+    ap_server_post_read_config = apr_array_make(pcommands, 1, sizeof(char *));
+    ap_server_config_defines   = apr_array_make(pcommands, 1, sizeof(char *));
 
     ap_run_rewrite_args(process);
 
     /* Maintain AP_SERVER_BASEARGS list in http_main.h to allow the MPM 
      * to safely pass on our args from its rewrite_args() handler.
      */
-    apr_initopt(&opt, pcommands, process->argc, process->argv);
+    apr_getopt_init(&opt, pcommands, process->argc, process->argv);
 
     while (apr_getopt(opt, AP_SERVER_BASEARGS, &c, &optarg) 
             == APR_SUCCESS) {
         char **new;
         switch (c) {
  	case 'c':
-	    new = (char **)apr_push_array(ap_server_post_read_config);
+	    new = (char **)apr_array_push(ap_server_post_read_config);
 	    *new = apr_pstrdup(pcommands, optarg);
 	    break;
 	case 'C':
-	    new = (char **)apr_push_array(ap_server_pre_read_config);
+	    new = (char **)apr_array_push(ap_server_pre_read_config);
 	    *new = apr_pstrdup(pcommands, optarg);
 	    break;
 	case 'd':
 	    def_server_root = optarg;
 	    break;
 	case 'D':
-	    new = (char **)apr_push_array(ap_server_config_defines);
+	    new = (char **)apr_array_push(ap_server_config_defines);
 	    *new = apr_pstrdup(pcommands, optarg);
 	    break;
 	case 'f':
@@ -376,8 +376,8 @@ int main(int argc, const char * const argv[])
 	}
     }
 
-    apr_create_pool(&plog, pglobal);
-    apr_create_pool(&ptemp, pconf);
+    apr_pool_create(&plog, pglobal);
+    apr_pool_create(&ptemp, pconf);
 
     /* Note that we preflight the config file once
        before reading it _again_ in the main loop.
@@ -398,7 +398,7 @@ int main(int argc, const char * const argv[])
     apr_clear_pool(plog);
     ap_run_open_logs(pconf, plog, ptemp, server_conf);
     ap_post_config_hook(pconf, plog, ptemp, server_conf);
-    apr_destroy_pool(ptemp);
+    apr_pool_destroy(ptemp);
 
     for (;;) {
 	apr_hook_deregister_all();
@@ -413,7 +413,7 @@ int main(int argc, const char * const argv[])
          * memory.  rbb
          */
         ap_conftree = NULL;
-	apr_create_pool(&ptemp, pconf);
+	apr_pool_create(&ptemp, pconf);
 	ap_server_root = def_server_root;
         server_conf = ap_read_config(process, ptemp, confname, &ap_conftree);
 	ap_run_pre_config(pconf, plog, ptemp);
@@ -424,7 +424,7 @@ int main(int argc, const char * const argv[])
 	apr_clear_pool(plog);
 	ap_run_open_logs(pconf, plog, ptemp, server_conf);
 	ap_post_config_hook(pconf, plog, ptemp, server_conf);
-	apr_destroy_pool(ptemp);
+	apr_pool_destroy(ptemp);
 
 	ap_run_optional_fn_retrieve();
 
@@ -446,13 +446,13 @@ const XML_LChar *suck_in_expat(void)
 
 #ifndef SHARED_CORE_BOOTSTRAP
 /*
- * Force apr_validate_password() into the image so that modules like
+ * Force apr_password_validate() into the image so that modules like
  * mod_auth can use it even if they're dynamically loaded.
  */
-void suck_in_apr_validate_password(void);
-void suck_in_apr_validate_password(void)
+void suck_in_apr_password_validate(void);
+void suck_in_apr_password_validate(void)
 {
-    apr_validate_password("a", "b");
+    apr_password_validate("a", "b");
 }
 #endif
 
diff --git a/server/mpm/beos/beos.c b/server/mpm/beos/beos.c
index 1620b18..61543ab 100644
--- a/server/mpm/beos/beos.c
+++ b/server/mpm/beos/beos.c
@@ -150,7 +150,7 @@ AP_DECLARE(int) ap_get_max_daemons(void)
 static void clean_child_exit(int code)
 {
     if (pchild)
-        apr_destroy_pool(pchild);
+        apr_pool_destroy(pchild);
     exit(code);
 }
 
@@ -304,14 +304,14 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, int my_child_num)
     long conn_id = my_child_num;
     int csd;
 
-    (void)apr_get_os_sock(&csd, sock);
+    (void)apr_os_sock_get(&csd, sock);
     
     if (csd >= FD_SETSIZE) {
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
             "filedescriptor (%u) larger than FD_SETSIZE (%u) "
             "found, you probably need to rebuild Apache with a "
             "larger FD_SETSIZE", csd, FD_SETSIZE);
-        apr_close_socket(sock);
+        apr_socket_close(sock);
 	    return;
     }
     
@@ -344,22 +344,22 @@ static int32 worker_thread(void * dummy)
     sigfillset(&sig_mask);
     sigprocmask(SIG_BLOCK, &sig_mask, NULL);
 
-    apr_create_pool(&ptrans, tpool);
+    apr_pool_create(&ptrans, tpool);
 
-    apr_lock(worker_thread_count_mutex);
+    apr_lock_aquire(worker_thread_count_mutex);
     worker_thread_count++;
-    apr_unlock(worker_thread_count_mutex);
+    apr_lock_release(worker_thread_count_mutex);
 
-    apr_setup_poll(&pollset, num_listening_sockets, tpool);
+    apr_poll_setup(&pollset, num_listening_sockets, tpool);
     for(n=0 ; n < num_listening_sockets ; ++n)
-	    apr_add_poll_socket(pollset, listening_sockets[n], APR_POLLIN);
+	    apr_poll_socket_add(pollset, listening_sockets[n], APR_POLLIN);
 
     while (!this_worker_should_exit) {
         this_worker_should_exit |= (ap_max_requests_per_child != 0) && (requests_this_child <= 0);
         
         if (this_worker_should_exit) break;
 
-        apr_lock(accept_mutex);
+        apr_lock_aquire(accept_mutex);
         while (!this_worker_should_exit) {
             apr_int16_t event;
             apr_status_t ret = apr_poll(pollset, &srv, -1);
@@ -394,7 +394,7 @@ static int32 worker_thread(void * dummy)
                         curr_pollfd = 1;
                     }
                     /* Get the revent... */
-                    apr_get_revents(&event, listening_sockets[curr_pollfd], pollset);
+                    apr_poll_revents_get(&event, listening_sockets[curr_pollfd], pollset);
                     
                     if (event & APR_POLLIN) {
                         last_pollfd = curr_pollfd;
@@ -407,7 +407,7 @@ static int32 worker_thread(void * dummy)
     got_fd:
         if (!this_worker_should_exit) {
             rv = apr_accept(&csd, sd, ptrans);
-            apr_unlock(accept_mutex);
+            apr_lock_release(accept_mutex);
             if (rv != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
                   "apr_accept");
@@ -417,21 +417,21 @@ static int32 worker_thread(void * dummy)
             }
         }
         else {
-            apr_unlock(accept_mutex);
+            apr_lock_release(accept_mutex);
             break;
         }
         apr_clear_pool(ptrans);
     }
 
-    apr_destroy_pool(tpool);
-    apr_lock(worker_thread_count_mutex);
+    apr_pool_destroy(tpool);
+    apr_lock_aquire(worker_thread_count_mutex);
     worker_thread_count--;
     if (worker_thread_count == 0) {
         /* All the threads have exited, now finish the shutdown process
          * by signalling the sigwait thread */
         kill(server_pid, SIGTERM);
     }
-    apr_unlock(worker_thread_count_mutex);
+    apr_lock_release(worker_thread_count_mutex);
 
     return (0);
 }
@@ -448,7 +448,7 @@ static int make_worker(server_rec *s, int slot)
     }
     
     my_info->slot = slot;
-    apr_create_pool(&my_info->tpool, pchild);
+    apr_pool_create(&my_info->tpool, pchild);
     
     if (slot + 1 > ap_max_child_assigned)
 	    ap_max_child_assigned = slot + 1;
@@ -590,7 +590,7 @@ static void server_main_loop(int remaining_threads_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (apr_reap_other_child(&pid, status) == 0) {
+	    else if (apr_proc_other_child_read(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -654,7 +654,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
      * used to lock around select so we only have one thread
      * in select at a time
      */
-    if ((rv = apr_create_lock(&accept_mutex, APR_MUTEX, APR_CROSS_PROCESS,
+    if ((rv = apr_lock_create(&accept_mutex, APR_MUTEX, APR_CROSS_PROCESS,
         NULL, pconf)) != APR_SUCCESS) {
         /* tsch tsch, can't have more than one thread in the accept loop
            at a time so we need to fall on our sword... */
@@ -665,7 +665,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     /* worker_thread_count_mutex
      * locks the worker_thread_count so we have ana ccurate count...
      */
-    if ((rv = apr_create_lock(&worker_thread_count_mutex, APR_MUTEX, APR_CROSS_PROCESS,
+    if ((rv = apr_lock_create(&worker_thread_count_mutex, APR_MUTEX, APR_CROSS_PROCESS,
         NULL, pconf)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
                      "Couldn't create worker thread count lock");
@@ -701,7 +701,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     /* setup the child pool to use for the workers.  Each worker creates
      * a seperate pool of it's own to use.
      */
-    apr_create_pool(&pchild, pconf);
+    apr_pool_create(&pchild, pconf);
     ap_child_init_hook(pchild, ap_server_conf);
 
     /* Now that we have the child pool (pchild) we can allocate
@@ -797,8 +797,8 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     
     /* just before we go, tidy up the locks we've created to prevent a 
      * potential leak of semaphores... */
-    apr_destroy_lock(worker_thread_count_mutex);
-    apr_destroy_lock(accept_mutex);
+    apr_lock_destroy(worker_thread_count_mutex);
+    apr_lock_destroy(accept_mutex);
     
     return 0;
 }
@@ -815,7 +815,7 @@ static void beos_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pte
     if (restart_num++ == 1) {
         is_graceful = 0;
         if (!one_process && !no_detach)
-	        apr_detach();
+	        apr_proc_detach();
         server_pid = getpid();
     }
 
diff --git a/server/mpm/dexter/dexter.c b/server/mpm/dexter/dexter.c
index 4b784c9..36ef64b 100644
--- a/server/mpm/dexter/dexter.c
+++ b/server/mpm/dexter/dexter.c
@@ -181,7 +181,7 @@ AP_DECLARE(int) ap_get_max_daemons(void)
 static void clean_child_exit(int code)
 {
     if (pchild) {
-	apr_destroy_pool(pchild);
+	apr_pool_destroy(pchild);
     }
     exit(code);
 }
@@ -258,7 +258,7 @@ static void ap_start_restart(int graceful)
     restart_pending = 1;
     is_graceful = graceful;
     if (is_graceful) {
-        apr_kill_cleanup(pconf, NULL, ap_cleanup_scoreboard);
+        apr_pool_cleanup_kill(pconf, NULL, ap_cleanup_scoreboard);
     }
 }
 
@@ -399,8 +399,8 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
     int csd;
     apr_status_t rv;
 
-    if ((rv = apr_get_os_sock(&csd, sock)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_get_os_sock");
+    if ((rv = apr_os_sock_get(&csd, sock)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_os_sock_get");
     }
 
     if (csd >= FD_SETSIZE) {
@@ -409,7 +409,7 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
                      "to rebuild Apache with a larger FD_SETSIZE "
                      "(currently %d)", 
                      csd, FD_SETSIZE);
-        apr_close_socket(sock);
+        apr_socket_close(sock);
         return;
     }
 
@@ -511,17 +511,17 @@ static void *worker_thread(void *arg)
     apr_status_t rv;
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    apr_create_pool(&tpool, thread_pool_parent);
+    apr_pool_create(&tpool, thread_pool_parent);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
-    apr_create_pool(&ptrans, tpool);
+    apr_pool_create(&ptrans, tpool);
 
     (void) ap_update_child_status(child_num, thread_num, SERVER_STARTING,
                                   (request_rec *) NULL);
 
 
-    apr_setup_poll(&pollset, num_listenfds+1, tpool);
+    apr_poll_setup(&pollset, num_listenfds+1, tpool);
     for(n=0 ; n <= num_listenfds ; ++n)
-        apr_add_poll_socket(pollset, listenfds[n], APR_POLLIN);
+        apr_poll_socket_add(pollset, listenfds[n], APR_POLLIN);
 
     while (1) {
         workers_may_exit |= (max_requests_per_child != 0) && (requests_this_child <= 0);
@@ -544,10 +544,10 @@ static void *worker_thread(void *arg)
         (void) ap_update_child_status(child_num, thread_num, SERVER_READY,
                                       (request_rec *) NULL);
 
-        if ((rv = SAFE_ACCEPT(apr_lock(accept_mutex)))
+        if ((rv = SAFE_ACCEPT(apr_lock_aquire(accept_mutex)))
             != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                         "apr_lock failed. Attempting to shutdown "
+                         "apr_lock_aquire failed. Attempting to shutdown "
                          "process gracefully.");
             workers_may_exit = 1;
         }
@@ -569,7 +569,7 @@ static void *worker_thread(void *arg)
             }
             if (workers_may_exit) break;
 
-            apr_get_revents(&event, listenfds[0], pollset);
+            apr_poll_revents_get(&event, listenfds[0], pollset);
             if (event & APR_POLLIN) {
                 /* A process got a signal on the shutdown pipe. Check if we're
                  * the lucky process to die. */
@@ -590,7 +590,7 @@ static void *worker_thread(void *arg)
                         curr_pollfd = 1;
                     }
                     /* XXX: Should we check for POLLERR? */
-                    apr_get_revents(&event, listenfds[curr_pollfd], pollset);
+                    apr_poll_revents_get(&event, listenfds[curr_pollfd], pollset);
                     if (event & APR_POLLIN) {
                         last_pollfd = curr_pollfd;
                         sd = listenfds[curr_pollfd];
@@ -605,10 +605,10 @@ static void *worker_thread(void *arg)
                 csd = NULL;
                 ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, "apr_accept");
             }
-            if ((rv = SAFE_ACCEPT(apr_unlock(accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_lock_release(accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "apr_unlock failed. Attempting to shutdown "
+                             "apr_lock_release failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -627,10 +627,10 @@ static void *worker_thread(void *arg)
                 requests_this_child--;
             }
 	} else {
-            if ((rv = SAFE_ACCEPT(apr_unlock(accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_lock_release(accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "apr_unlock failed. Attempting to shutdown "
+                             "apr_lock_release failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -669,11 +669,11 @@ static void child_main(int child_num_arg)
 
     my_pid = getpid();
     child_num = child_num_arg;
-    apr_create_pool(&pchild, pconf);
+    apr_pool_create(&pchild, pconf);
 
     /*stuff to do before we switch id's, so we have permissions.*/
 
-    rv = SAFE_ACCEPT(apr_child_init_lock(&accept_mutex, lock_fname,
+    rv = SAFE_ACCEPT(apr_lock_child_init(&accept_mutex, lock_fname,
                                         pchild));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
@@ -726,7 +726,7 @@ static void child_main(int child_num_arg)
     for (i = 0; i < max_threads; i++) {
         worker_thread_free_ids[i] = i;
     }
-    apr_create_pool(&thread_pool_parent, pchild);
+    apr_pool_create(&thread_pool_parent, pchild);
     pthread_mutex_init(&thread_pool_parent_mutex, NULL);
     pthread_mutex_init(&idle_thread_count_mutex, NULL);
     pthread_mutex_init(&worker_thread_count_mutex, NULL);
@@ -936,7 +936,7 @@ static void server_main_loop(int remaining_children_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (apr_reap_other_child(&pid, status) == 0) {
+	    else if (apr_proc_other_child_read(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -984,17 +984,17 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
     pconf = _pconf;
     ap_server_conf = s;
-    if ((rv = apr_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
+    if ((rv = apr_file_pipe_create(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
         != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "apr_create_pipe (pipe_of_death)");
+                     "apr_file_pipe_create (pipe_of_death)");
         exit(1);
     }
-    if ((rv = apr_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
+    if ((rv = apr_file_pipe_timeout_set(pipe_of_death_in, 0)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "apr_set_pipe_timeout (pipe_of_death)");
+                     "apr_file_pipe_timeout_set (pipe_of_death)");
         exit(1);
     }
     ap_server_conf = s;
@@ -1010,7 +1010,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     lock_fname = apr_psprintf(_pconf, "%s.%u",
                              ap_server_root_relative(_pconf, lock_fname),
                              my_pid);
-    rv = SAFE_ACCEPT(apr_create_lock(&accept_mutex, APR_MUTEX,
+    rv = SAFE_ACCEPT(apr_lock_create(&accept_mutex, APR_MUTEX,
                                     APR_LOCKALL, lock_fname, _pconf));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1110,7 +1110,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 	}
 	/* give the children the signal to die */
         for (i = 0; i < num_daemons;) {
-            if ((rv = apr_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
+            if ((rv = apr_file_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
                 if (APR_STATUS_IS_EINTR(rv)) continue;
                 ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
                              "write pipe_of_death");
@@ -1147,7 +1147,7 @@ static void dexter_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp
 	is_graceful = 0;
 
 	if (!one_process && !no_detach) {
-	    apr_detach();
+	    apr_proc_detach();
 	}
 
 	my_pid = getpid();
diff --git a/server/mpm/experimental/perchild/perchild.c b/server/mpm/experimental/perchild/perchild.c
index 276651e..c3dd723 100644
--- a/server/mpm/experimental/perchild/perchild.c
+++ b/server/mpm/experimental/perchild/perchild.c
@@ -220,7 +220,7 @@ AP_DECLARE(int) ap_get_max_daemons(void)
 static void clean_child_exit(int code)
 {
     if (pchild) {
-	apr_destroy_pool(pchild);
+	apr_pool_destroy(pchild);
     }
     exit(code);
 }
@@ -296,7 +296,7 @@ static void ap_start_restart(int graceful)
     restart_pending = 1;
     is_graceful = graceful;
     if (is_graceful) {
-        apr_kill_cleanup(pconf, NULL, ap_cleanup_scoreboard);
+        apr_pool_cleanup_kill(pconf, NULL, ap_cleanup_scoreboard);
     }
 }
 
@@ -438,8 +438,8 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
     apr_status_t rv;
     int thread_num = conn_id % HARD_THREAD_LIMIT;
 
-    if ((rv = apr_get_os_sock(&csd, sock)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_get_os_sock");
+    if ((rv = apr_os_sock_get(&csd, sock)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_os_sock_get");
     }
 
     if (csd >= FD_SETSIZE) {
@@ -448,7 +448,7 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
                      "to rebuild Apache with a larger FD_SETSIZE "
                      "(currently %d)", 
                      csd, FD_SETSIZE);
-        apr_close_socket(sock);
+        apr_socket_close(sock);
         return;
     }
 
@@ -549,13 +549,13 @@ static void *worker_thread(void *arg)
     apr_status_t rv;
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    apr_create_pool(&tpool, thread_pool_parent);
+    apr_pool_create(&tpool, thread_pool_parent);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
-    apr_create_pool(&ptrans, tpool);
+    apr_pool_create(&ptrans, tpool);
 
-    apr_setup_poll(&pollset, num_listenfds+1, tpool);
+    apr_poll_setup(&pollset, num_listenfds+1, tpool);
     for(n=0 ; n <= num_listenfds ; ++n) {
-        apr_add_poll_socket(pollset, listenfds[n], APR_POLLIN);
+        apr_poll_socket_add(pollset, listenfds[n], APR_POLLIN);
     }
 
     while (!workers_may_exit) {
@@ -580,10 +580,10 @@ static void *worker_thread(void *arg)
             pthread_mutex_unlock(&thread_accept_mutex);
             break;
         }
-        if ((rv = SAFE_ACCEPT(apr_lock(process_accept_mutex)))
+        if ((rv = SAFE_ACCEPT(apr_lock_aquire(process_accept_mutex)))
             != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                         "apr_lock failed. Attempting to shutdown "
+                         "apr_lock_aquire failed. Attempting to shutdown "
                          "process gracefully.");
             workers_may_exit = 1;
         }
@@ -605,7 +605,7 @@ static void *worker_thread(void *arg)
             }
             if (workers_may_exit) break;
 
-            apr_get_revents(&event, listenfds[0], pollset);
+            apr_poll_revents_get(&event, listenfds[0], pollset);
             if (event & APR_POLLIN) {
                 /* A process got a signal on the shutdown pipe. Check if we're
                  * the lucky process to die. */
@@ -613,7 +613,7 @@ static void *worker_thread(void *arg)
                 continue;
             }
             
-            apr_get_revents(&event, listenfds[1], pollset);
+            apr_poll_revents_get(&event, listenfds[1], pollset);
             if (event & APR_POLLIN || event & APR_POLLOUT) {
                 /* This request is from another child in our current process.
                  * We should set a flag here, and then below we will read
@@ -636,7 +636,7 @@ static void *worker_thread(void *arg)
                         curr_pollfd = 1;
                     }
                     /* XXX: Should we check for POLLERR? */
-                    apr_get_revents(&event, listenfds[curr_pollfd], pollset);
+                    apr_poll_revents_get(&event, listenfds[curr_pollfd], pollset);
                     if (event & APR_POLLIN) {
                         last_pollfd = curr_pollfd;
                         sd = listenfds[curr_pollfd];
@@ -650,10 +650,10 @@ static void *worker_thread(void *arg)
             if ((rv = apr_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, "apr_accept");
             }
-            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_lock_release(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "apr_unlock failed. Attempting to shutdown "
+                             "apr_lock_release failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -695,7 +695,7 @@ static void *worker_thread(void *arg)
                 memcpy(&dp, CMSG_DATA(cmsg), sizeof(dp));
 
                 thread_socket_table[thread_num] = dp;
-                apr_put_os_sock(&csd, &child_info_table[child_num].sd, ptrans);
+                apr_os_sock_put(&csd, &child_info_table[child_num].sd, ptrans);
             }
             if (setjmp(jmpbuffer) != 1) {
                 process_socket(ptrans, csd, conn_id);
@@ -705,10 +705,10 @@ static void *worker_thread(void *arg)
             }  
             requests_this_child--;
 	} else {
-            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_lock_release(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "apr_unlock failed. Attempting to shutdown "
+                             "apr_lock_release failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -722,7 +722,7 @@ static void *worker_thread(void *arg)
     }
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    apr_destroy_pool(tpool);
+    apr_pool_destroy(tpool);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
     pthread_mutex_lock(&worker_thread_count_mutex);
     worker_thread_count--;
@@ -821,11 +821,11 @@ static void child_main(int child_num_arg)
 
     my_pid = getpid();
     child_num = child_num_arg;
-    apr_create_pool(&pchild, pconf);
+    apr_pool_create(&pchild, pconf);
 
     /*stuff to do before we switch id's, so we have permissions.*/
 
-    rv = SAFE_ACCEPT(apr_child_init_lock(&process_accept_mutex, lock_fname,
+    rv = SAFE_ACCEPT(apr_lock_child_init(&process_accept_mutex, lock_fname,
                                         pchild));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
@@ -869,7 +869,7 @@ static void child_main(int child_num_arg)
 #endif
 
     /* The child socket */
-    apr_put_os_sock(&listenfds[1], &child_info_table[child_num].sd, pchild);
+    apr_os_sock_put(&listenfds[1], &child_info_table[child_num].sd, pchild);
 
     num_listenfds++;
     for (lr = ap_listeners, i = 2; i <= num_listenfds; lr = lr->next, ++i)
@@ -885,7 +885,7 @@ static void child_main(int child_num_arg)
     for (i = 0; i < max_threads; i++) {
         worker_thread_free_ids[i] = i;
     }
-    apr_create_pool(&thread_pool_parent, pchild);
+    apr_pool_create(&thread_pool_parent, pchild);
     pthread_mutex_init(&thread_pool_parent_mutex, NULL);
     pthread_mutex_init(&idle_thread_count_mutex, NULL);
     pthread_mutex_init(&worker_thread_count_mutex, NULL);
@@ -1096,7 +1096,7 @@ static void server_main_loop(int remaining_children_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (apr_reap_other_child(&pid, status) == 0) {
+	    else if (apr_proc_other_child_read(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -1144,17 +1144,17 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
     pconf = _pconf;
     ap_server_conf = s;
-    if ((rv = apr_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
+    if ((rv = apr_file_pipe_create(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
         != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "apr_create_pipe (pipe_of_death)");
+                     "apr_file_pipe_create (pipe_of_death)");
         exit(1);
     }
-    if ((rv = apr_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
+    if ((rv = apr_file_pipe_timeout_set(pipe_of_death_in, 0)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "apr_set_pipe_timeout (pipe_of_death)");
+                     "apr_file_pipe_timeout_set (pipe_of_death)");
         exit(1);
     }
     ap_server_conf = s;
@@ -1170,7 +1170,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     lock_fname = apr_psprintf(_pconf, "%s.%u",
                              ap_server_root_relative(_pconf, lock_fname),
                              my_pid);
-    rv = SAFE_ACCEPT(apr_create_lock(&process_accept_mutex, APR_MUTEX,
+    rv = SAFE_ACCEPT(apr_lock_create(&process_accept_mutex, APR_MUTEX,
                                     APR_CROSS_PROCESS, lock_fname, _pconf));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1270,7 +1270,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 	}
 	/* give the children the signal to die */
         for (i = 0; i < num_daemons;) {
-            if ((rv = apr_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
+            if ((rv = apr_file_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
                 if (APR_STATUS_IS_EINTR(rv)) continue;
                 ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
                              "write pipe_of_death");
@@ -1308,7 +1308,7 @@ static void perchild_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *pte
 	is_graceful = 0;
 
 	if (!one_process && !no_detach) {
-	    apr_detach();
+	    apr_proc_detach();
 	}
 
 	my_pid = getpid();
@@ -1354,13 +1354,13 @@ static int pass_request(request_rec *r)
     char *foo;
     int len;
 
-    apr_get_userdata((void **)&foo, "PERCHILD_BUFFER", r->connection->pool);
+    apr_pool_userdata_get((void **)&foo, "PERCHILD_BUFFER", r->connection->pool);
     len = strlen(foo);
 
-    apr_set_userdata(NULL, "PERCHILD_BUFFER", apr_null_cleanup, 
+    apr_pool_userdata_set(NULL, "PERCHILD_BUFFER", apr_pool_cleanup_null, 
                      r->connection->pool);
 
-    apr_get_os_sock(&sfd, thesock);
+    apr_os_sock_get(&sfd, thesock);
 
     iov.iov_base = NULL;
     iov.iov_len = 0;
@@ -1382,7 +1382,7 @@ static int pass_request(request_rec *r)
     msg.msg_flags=0;
 
     if (sendmsg(sconf->sd2, &msg, 0) == -1) {
-        apr_destroy_pool(r->pool);
+        apr_pool_destroy(r->pool);
         return -1;
     }
 
@@ -1398,7 +1398,7 @@ static int pass_request(request_rec *r)
         }
     }
 
-    apr_destroy_pool(r->pool);
+    apr_pool_destroy(r->pool);
     return 1;
 }
 
@@ -1462,7 +1462,7 @@ static int perchild_post_read(request_rec *r)
     if (thread_socket_table[thread_num] != -1) {
         apr_socket_t *csd = NULL;
 
-        apr_put_os_sock(&csd, &thread_socket_table[thread_num], 
+        apr_os_sock_put(&csd, &thread_socket_table[thread_num], 
                              r->connection->pool);
         ap_sock_disable_nagle(csd);
         r->connection->client_socket = csd;
@@ -1494,7 +1494,7 @@ static apr_status_t perchild_buffer(ap_filter_t *f, apr_bucket_brigade *b, ap_in
         return rv;
     }
 
-    apr_get_userdata((void **)&buffer, "PERCHILD_BUFFER", f->c->pool);
+    apr_pool_userdata_get((void **)&buffer, "PERCHILD_BUFFER", f->c->pool);
 
     APR_BRIGADE_FOREACH(e, b) {
         if (e->length != 0) {
@@ -1509,7 +1509,7 @@ static apr_status_t perchild_buffer(ap_filter_t *f, apr_bucket_brigade *b, ap_in
             } 
         }
     }
-    apr_set_userdata(buffer, "PERCHILD_BUFFER", apr_null_cleanup, f->c->pool);
+    apr_pool_userdata_set(buffer, "PERCHILD_BUFFER", apr_pool_cleanup_null, f->c->pool);
     
     return APR_SUCCESS;
 }
diff --git a/server/mpm/mpmt_beos/mpmt_beos.c b/server/mpm/mpmt_beos/mpmt_beos.c
index 02c02ba..4315616 100644
--- a/server/mpm/mpmt_beos/mpmt_beos.c
+++ b/server/mpm/mpmt_beos/mpmt_beos.c
@@ -149,7 +149,7 @@ AP_DECLARE(int) ap_get_max_daemons(void)
 void clean_child_exit(int code)
 {
     if (pchild) {
-	apr_destroy_pool(pchild);
+	apr_pool_destroy(pchild);
     }
     exit(code);
 }
@@ -324,11 +324,11 @@ static int32 worker_thread(void * dummy)
     sigfillset(&sig_mask);
     sigprocmask(SIG_BLOCK, &sig_mask, NULL);
 
-    apr_create_pool(&ptrans, tpool);
+    apr_pool_create(&ptrans, tpool);
 
-    apr_lock(worker_thread_count_mutex);
+    apr_lock_aquire(worker_thread_count_mutex);
     worker_thread_count++;
-    apr_unlock(worker_thread_count_mutex);
+    apr_lock_release(worker_thread_count_mutex);
 
     /* TODO: Switch to a system where threads reuse the results from earlier
        poll calls - manoj */
@@ -336,7 +336,7 @@ static int32 worker_thread(void * dummy)
         workers_may_exit |= (ap_max_requests_per_child != 0) && (requests_this_child <= 0);
         if (workers_may_exit) break;
 
-        apr_lock(accept_mutex);
+        apr_lock_aquire(accept_mutex);
         while (!workers_may_exit) {
             srv = poll(listenfds, num_listenfds + 1, -1);
             if (srv < 0) {
@@ -368,7 +368,7 @@ static int32 worker_thread(void * dummy)
                     /* XXX: Should we check for POLLERR? */
                     if (listenfds[curr_pollfd].revents & POLLIN) {
                         last_pollfd = curr_pollfd;
-                        apr_put_os_sock(&sd, &listenfds[curr_pollfd].fd, tpool); 
+                        apr_os_sock_put(&sd, &listenfds[curr_pollfd].fd, tpool); 
                         goto got_fd;
                     }
                 } while (curr_pollfd != last_pollfd);
@@ -377,27 +377,27 @@ static int32 worker_thread(void * dummy)
     got_fd:
         if (!workers_may_exit) {
             apr_accept(&csd, sd, ptrans);
-            apr_unlock(accept_mutex);
+            apr_lock_release(accept_mutex);
             process_socket(ptrans, csd, process_slot,
                        thread_slot);
             requests_this_child--;
         }
         else {
-            apr_unlock(accept_mutex);
+            apr_lock_release(accept_mutex);
             break;
         }
         apr_clear_pool(ptrans);
     }
 
-    apr_destroy_pool(tpool);
-    apr_lock(worker_thread_count_mutex);
+    apr_pool_destroy(tpool);
+    apr_lock_aquire(worker_thread_count_mutex);
     worker_thread_count--;
     if (worker_thread_count == 0) {
         /* All the threads have exited, now finish the shutdown process
          * by signalling the sigwait thread */
         kill(my_pid, SIGTERM);
     }
-    apr_unlock(worker_thread_count_mutex);
+    apr_lock_release(worker_thread_count_mutex);
 
     return (0);
 }
@@ -417,7 +417,7 @@ static int32 child_main(void * data)
     apr_status_t rv;
         
     my_pid = getpid();
-    apr_create_pool(&pchild, pconf);
+    apr_pool_create(&pchild, pconf);
 
     if (beosd_setup_child()) {
 	clean_child_exit(APEXIT_CHILDFATAL);
@@ -436,7 +436,7 @@ static int32 child_main(void * data)
     /* Set up the pollfd array */
     listenfds = apr_palloc(pchild, sizeof(struct pollfd) * (num_listenfds));
     for (lr = ap_listeners, i = 0; i < num_listenfds; lr = lr->next, ++i) {
-        apr_get_os_sock(&listenfds[i].fd , lr->sd);
+        apr_os_sock_get(&listenfds[i].fd , lr->sd);
         listenfds[i].events = POLLIN; /* should we add POLLPRI ?*/
         listenfds[i].revents = 0;
     }
@@ -444,7 +444,7 @@ static int32 child_main(void * data)
     /* Setup worker threads */
 
     worker_thread_count = 0;
-    if ((rv = apr_create_lock(&worker_thread_count_mutex, APR_MUTEX, 
+    if ((rv = apr_lock_create(&worker_thread_count_mutex, APR_MUTEX, 
         APR_CROSS_PROCESS, NULL, pchild)) != APR_SUCCESS) {
         /* Oh dear, didn't manage to create a worker thread mutex, 
            so there's no point on going on with this child... */
@@ -461,7 +461,7 @@ static int32 child_main(void * data)
         my_info->pid = my_child_num;
         my_info->tid = i;
         my_info->sd = 0;
-        apr_create_pool(&my_info->tpool, pchild);
+        apr_pool_create(&my_info->tpool, pchild);
 
         /* We are creating threads right now */
         if ((thread = spawn_thread(worker_thread, "httpd_worker_thread",
@@ -635,7 +635,7 @@ static void server_main_loop(int remaining_children_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (apr_reap_other_child(&pid, status) == 0) {
+	    else if (apr_proc_other_child_read(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -690,7 +690,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     ap_log_pid(pconf, ap_pid_fname);
 
     /* create the accept_mutex */
-    if ((rv = apr_create_lock(&accept_mutex, APR_MUTEX, APR_CROSS_PROCESS,
+    if ((rv = apr_lock_create(&accept_mutex, APR_MUTEX, APR_CROSS_PROCESS,
         NULL, pconf)) != APR_SUCCESS) {
         /* tsch tsch, can't have more than one thread in the accept loop
            at a time so we need to fall on our sword... */
diff --git a/server/mpm/mpmt_pthread/mpmt_pthread.c b/server/mpm/mpmt_pthread/mpmt_pthread.c
index dc5951a..fba44e7 100644
--- a/server/mpm/mpmt_pthread/mpmt_pthread.c
+++ b/server/mpm/mpmt_pthread/mpmt_pthread.c
@@ -174,7 +174,7 @@ static void clean_child_exit(int code) __attribute__ ((noreturn));
 void clean_child_exit(int code)
 {
     if (pchild) {
-	apr_destroy_pool(pchild);
+	apr_pool_destroy(pchild);
     }
     exit(code);
 }
@@ -251,7 +251,7 @@ static void ap_start_restart(int graceful)
     restart_pending = 1;
     is_graceful = graceful;
     if (is_graceful) {
-        apr_kill_cleanup(pconf, NULL, ap_cleanup_scoreboard);
+        apr_pool_cleanup_kill(pconf, NULL, ap_cleanup_scoreboard);
     }
 }
 
@@ -392,7 +392,7 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, int my_child_num,
     long conn_id = AP_ID_FROM_CHILD_THREAD(my_child_num, my_thread_num);
     int csd;
 
-    (void) apr_get_os_sock(&csd, sock);
+    (void) apr_os_sock_get(&csd, sock);
 
     if (csd >= FD_SETSIZE) {
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
@@ -400,7 +400,7 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, int my_child_num,
                      "to rebuild Apache with a larger FD_SETSIZE "
                      "(currently %d)", 
                      csd, FD_SETSIZE);
-        apr_close_socket(sock);
+        apr_socket_close(sock);
         return;
     }
 
@@ -454,15 +454,15 @@ static void * worker_thread(void * dummy)
 
     free(ti);
 
-    apr_create_pool(&ptrans, tpool);
+    apr_pool_create(&ptrans, tpool);
 
     pthread_mutex_lock(&worker_thread_count_mutex);
     worker_thread_count++;
     pthread_mutex_unlock(&worker_thread_count_mutex);
 
-    apr_setup_poll(&pollset, num_listensocks+1, tpool);
+    apr_poll_setup(&pollset, num_listensocks+1, tpool);
     for(n=0 ; n <= num_listensocks ; ++n)
-	apr_add_poll_socket(pollset, listensocks[n], APR_POLLIN);
+	apr_poll_socket_add(pollset, listensocks[n], APR_POLLIN);
 
     /* TODO: Switch to a system where threads reuse the results from earlier
        poll calls - manoj */
@@ -472,10 +472,10 @@ static void * worker_thread(void * dummy)
 
         (void) ap_update_child_status(process_slot, thread_slot, SERVER_READY, 
                                       (request_rec *) NULL);
-        if ((rv = SAFE_ACCEPT(apr_lock(accept_mutex)))
+        if ((rv = SAFE_ACCEPT(apr_lock_aquire(accept_mutex)))
             != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                         "apr_lock failed. Attempting to shutdown "
+                         "apr_lock_aquire failed. Attempting to shutdown "
                          "process gracefully.");
             workers_may_exit = 1;
         }
@@ -499,7 +499,7 @@ static void * worker_thread(void * dummy)
 
             if (workers_may_exit) break;
 
-	    apr_get_revents(&event, listensocks[0], pollset);
+	    apr_poll_revents_get(&event, listensocks[0], pollset);
             if (event & APR_POLLIN) {
                 /* A process got a signal on the shutdown pipe. Check if we're
                  * the lucky process to die. */
@@ -520,7 +520,7 @@ static void * worker_thread(void * dummy)
                         curr_pollfd = 1;
                     }
                     /* XXX: Should we check for POLLERR? */
-		    apr_get_revents(&event, listensocks[curr_pollfd], pollset);
+		    apr_poll_revents_get(&event, listensocks[curr_pollfd], pollset);
                     if (event & APR_POLLIN) {
                         last_pollfd = curr_pollfd;
 			sd=listensocks[curr_pollfd];
@@ -536,10 +536,10 @@ static void * worker_thread(void * dummy)
                 ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, 
                              "apr_accept");
             }
-            if ((rv = SAFE_ACCEPT(apr_unlock(accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_lock_release(accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "apr_unlock failed. Attempting to shutdown "
+                             "apr_lock_release failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -549,10 +549,10 @@ static void * worker_thread(void * dummy)
             }
         }
         else {
-            if ((rv = SAFE_ACCEPT(apr_unlock(accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_lock_release(accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "apr_unlock failed. Attempting to shutdown "
+                             "apr_lock_release failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -561,7 +561,7 @@ static void * worker_thread(void * dummy)
         apr_clear_pool(ptrans);
     }
 
-    apr_destroy_pool(tpool);
+    apr_pool_destroy(tpool);
     ap_update_child_status(process_slot, thread_slot, SERVER_DEAD,
         (request_rec *) NULL);
     pthread_mutex_lock(&worker_thread_count_mutex);
@@ -591,12 +591,12 @@ static void child_main(int child_num_arg)
 
 
     ap_my_pid = getpid();
-    apr_create_pool(&pchild, pconf);
+    apr_pool_create(&pchild, pconf);
 
     /*stuff to do before we switch id's, so we have permissions.*/
     reopen_scoreboard(pchild);
 
-    rv = SAFE_ACCEPT(apr_child_init_lock(&accept_mutex, lock_fname,
+    rv = SAFE_ACCEPT(apr_lock_child_init(&accept_mutex, lock_fname,
                      pchild));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
@@ -665,7 +665,7 @@ static void child_main(int child_num_arg)
 	my_info->pid = my_child_num;
         my_info->tid = i;
 	my_info->sd = 0;
-	apr_create_pool(&my_info->tpool, pchild);
+	apr_pool_create(&my_info->tpool, pchild);
 	
 	/* We are creating threads right now */
 	(void) ap_update_child_status(my_child_num, i, SERVER_STARTING, 
@@ -866,7 +866,7 @@ static void perform_idle_server_maintenance(void)
     if (idle_thread_count > max_spare_threads) {
         /* Kill off one child */
         char char_of_death = '!';
-        if ((rv = apr_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
+        if ((rv = apr_file_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, "write pipe_of_death");
         }
         idle_spawn_rate = 1;
@@ -943,7 +943,7 @@ static void server_main_loop(int remaining_children_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (apr_reap_other_child(&pid, status) == 0) {
+	    else if (apr_proc_other_child_read(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -989,18 +989,18 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
     pconf = _pconf;
     ap_server_conf = s;
-    rv = apr_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf);
+    rv = apr_file_pipe_create(&pipe_of_death_in, &pipe_of_death_out, pconf);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "apr_create_pipe (pipe_of_death)");
+                     "apr_file_pipe_create (pipe_of_death)");
         exit(1);
     }
 
-    if ((rv = apr_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
+    if ((rv = apr_file_pipe_timeout_set(pipe_of_death_in, 0)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "apr_set_pipe_timeout (pipe_of_death)");
+                     "apr_file_pipe_timeout_set (pipe_of_death)");
         exit(1);
     }
     ap_server_conf = s;
@@ -1016,7 +1016,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     lock_fname = apr_psprintf(_pconf, "%s.%u",
                              ap_server_root_relative(_pconf, lock_fname),
                              ap_my_pid);
-    rv = apr_create_lock(&accept_mutex, APR_MUTEX, APR_LOCKALL,
+    rv = apr_lock_create(&accept_mutex, APR_MUTEX, APR_LOCKALL,
                    lock_fname, _pconf);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1116,7 +1116,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
 	/* give the children the signal to die */
         for (i = 0; i < ap_daemons_limit;) {
-            if ((rv = apr_write(pipe_of_death_in, &char_of_death, &one)) != APR_SUCCESS) {
+            if ((rv = apr_file_write(pipe_of_death_in, &char_of_death, &one)) != APR_SUCCESS) {
                 if (APR_STATUS_IS_EINTR(rv)) continue;
                 ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, "write pipe_of_death");
             }
@@ -1163,7 +1163,7 @@ static void mpmt_pthread_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_poo
 	is_graceful = 0;
 
 	if (!one_process && !no_detach) {
-	    apr_detach();
+	    apr_proc_detach();
 	}
 	ap_my_pid = getpid();
     }
diff --git a/server/mpm/perchild/perchild.c b/server/mpm/perchild/perchild.c
index 276651e..c3dd723 100644
--- a/server/mpm/perchild/perchild.c
+++ b/server/mpm/perchild/perchild.c
@@ -220,7 +220,7 @@ AP_DECLARE(int) ap_get_max_daemons(void)
 static void clean_child_exit(int code)
 {
     if (pchild) {
-	apr_destroy_pool(pchild);
+	apr_pool_destroy(pchild);
     }
     exit(code);
 }
@@ -296,7 +296,7 @@ static void ap_start_restart(int graceful)
     restart_pending = 1;
     is_graceful = graceful;
     if (is_graceful) {
-        apr_kill_cleanup(pconf, NULL, ap_cleanup_scoreboard);
+        apr_pool_cleanup_kill(pconf, NULL, ap_cleanup_scoreboard);
     }
 }
 
@@ -438,8 +438,8 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
     apr_status_t rv;
     int thread_num = conn_id % HARD_THREAD_LIMIT;
 
-    if ((rv = apr_get_os_sock(&csd, sock)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_get_os_sock");
+    if ((rv = apr_os_sock_get(&csd, sock)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_os_sock_get");
     }
 
     if (csd >= FD_SETSIZE) {
@@ -448,7 +448,7 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
                      "to rebuild Apache with a larger FD_SETSIZE "
                      "(currently %d)", 
                      csd, FD_SETSIZE);
-        apr_close_socket(sock);
+        apr_socket_close(sock);
         return;
     }
 
@@ -549,13 +549,13 @@ static void *worker_thread(void *arg)
     apr_status_t rv;
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    apr_create_pool(&tpool, thread_pool_parent);
+    apr_pool_create(&tpool, thread_pool_parent);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
-    apr_create_pool(&ptrans, tpool);
+    apr_pool_create(&ptrans, tpool);
 
-    apr_setup_poll(&pollset, num_listenfds+1, tpool);
+    apr_poll_setup(&pollset, num_listenfds+1, tpool);
     for(n=0 ; n <= num_listenfds ; ++n) {
-        apr_add_poll_socket(pollset, listenfds[n], APR_POLLIN);
+        apr_poll_socket_add(pollset, listenfds[n], APR_POLLIN);
     }
 
     while (!workers_may_exit) {
@@ -580,10 +580,10 @@ static void *worker_thread(void *arg)
             pthread_mutex_unlock(&thread_accept_mutex);
             break;
         }
-        if ((rv = SAFE_ACCEPT(apr_lock(process_accept_mutex)))
+        if ((rv = SAFE_ACCEPT(apr_lock_aquire(process_accept_mutex)))
             != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                         "apr_lock failed. Attempting to shutdown "
+                         "apr_lock_aquire failed. Attempting to shutdown "
                          "process gracefully.");
             workers_may_exit = 1;
         }
@@ -605,7 +605,7 @@ static void *worker_thread(void *arg)
             }
             if (workers_may_exit) break;
 
-            apr_get_revents(&event, listenfds[0], pollset);
+            apr_poll_revents_get(&event, listenfds[0], pollset);
             if (event & APR_POLLIN) {
                 /* A process got a signal on the shutdown pipe. Check if we're
                  * the lucky process to die. */
@@ -613,7 +613,7 @@ static void *worker_thread(void *arg)
                 continue;
             }
             
-            apr_get_revents(&event, listenfds[1], pollset);
+            apr_poll_revents_get(&event, listenfds[1], pollset);
             if (event & APR_POLLIN || event & APR_POLLOUT) {
                 /* This request is from another child in our current process.
                  * We should set a flag here, and then below we will read
@@ -636,7 +636,7 @@ static void *worker_thread(void *arg)
                         curr_pollfd = 1;
                     }
                     /* XXX: Should we check for POLLERR? */
-                    apr_get_revents(&event, listenfds[curr_pollfd], pollset);
+                    apr_poll_revents_get(&event, listenfds[curr_pollfd], pollset);
                     if (event & APR_POLLIN) {
                         last_pollfd = curr_pollfd;
                         sd = listenfds[curr_pollfd];
@@ -650,10 +650,10 @@ static void *worker_thread(void *arg)
             if ((rv = apr_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, "apr_accept");
             }
-            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_lock_release(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "apr_unlock failed. Attempting to shutdown "
+                             "apr_lock_release failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -695,7 +695,7 @@ static void *worker_thread(void *arg)
                 memcpy(&dp, CMSG_DATA(cmsg), sizeof(dp));
 
                 thread_socket_table[thread_num] = dp;
-                apr_put_os_sock(&csd, &child_info_table[child_num].sd, ptrans);
+                apr_os_sock_put(&csd, &child_info_table[child_num].sd, ptrans);
             }
             if (setjmp(jmpbuffer) != 1) {
                 process_socket(ptrans, csd, conn_id);
@@ -705,10 +705,10 @@ static void *worker_thread(void *arg)
             }  
             requests_this_child--;
 	} else {
-            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_lock_release(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "apr_unlock failed. Attempting to shutdown "
+                             "apr_lock_release failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -722,7 +722,7 @@ static void *worker_thread(void *arg)
     }
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    apr_destroy_pool(tpool);
+    apr_pool_destroy(tpool);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
     pthread_mutex_lock(&worker_thread_count_mutex);
     worker_thread_count--;
@@ -821,11 +821,11 @@ static void child_main(int child_num_arg)
 
     my_pid = getpid();
     child_num = child_num_arg;
-    apr_create_pool(&pchild, pconf);
+    apr_pool_create(&pchild, pconf);
 
     /*stuff to do before we switch id's, so we have permissions.*/
 
-    rv = SAFE_ACCEPT(apr_child_init_lock(&process_accept_mutex, lock_fname,
+    rv = SAFE_ACCEPT(apr_lock_child_init(&process_accept_mutex, lock_fname,
                                         pchild));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
@@ -869,7 +869,7 @@ static void child_main(int child_num_arg)
 #endif
 
     /* The child socket */
-    apr_put_os_sock(&listenfds[1], &child_info_table[child_num].sd, pchild);
+    apr_os_sock_put(&listenfds[1], &child_info_table[child_num].sd, pchild);
 
     num_listenfds++;
     for (lr = ap_listeners, i = 2; i <= num_listenfds; lr = lr->next, ++i)
@@ -885,7 +885,7 @@ static void child_main(int child_num_arg)
     for (i = 0; i < max_threads; i++) {
         worker_thread_free_ids[i] = i;
     }
-    apr_create_pool(&thread_pool_parent, pchild);
+    apr_pool_create(&thread_pool_parent, pchild);
     pthread_mutex_init(&thread_pool_parent_mutex, NULL);
     pthread_mutex_init(&idle_thread_count_mutex, NULL);
     pthread_mutex_init(&worker_thread_count_mutex, NULL);
@@ -1096,7 +1096,7 @@ static void server_main_loop(int remaining_children_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (apr_reap_other_child(&pid, status) == 0) {
+	    else if (apr_proc_other_child_read(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -1144,17 +1144,17 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
     pconf = _pconf;
     ap_server_conf = s;
-    if ((rv = apr_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
+    if ((rv = apr_file_pipe_create(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
         != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "apr_create_pipe (pipe_of_death)");
+                     "apr_file_pipe_create (pipe_of_death)");
         exit(1);
     }
-    if ((rv = apr_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
+    if ((rv = apr_file_pipe_timeout_set(pipe_of_death_in, 0)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "apr_set_pipe_timeout (pipe_of_death)");
+                     "apr_file_pipe_timeout_set (pipe_of_death)");
         exit(1);
     }
     ap_server_conf = s;
@@ -1170,7 +1170,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     lock_fname = apr_psprintf(_pconf, "%s.%u",
                              ap_server_root_relative(_pconf, lock_fname),
                              my_pid);
-    rv = SAFE_ACCEPT(apr_create_lock(&process_accept_mutex, APR_MUTEX,
+    rv = SAFE_ACCEPT(apr_lock_create(&process_accept_mutex, APR_MUTEX,
                                     APR_CROSS_PROCESS, lock_fname, _pconf));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1270,7 +1270,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 	}
 	/* give the children the signal to die */
         for (i = 0; i < num_daemons;) {
-            if ((rv = apr_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
+            if ((rv = apr_file_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
                 if (APR_STATUS_IS_EINTR(rv)) continue;
                 ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
                              "write pipe_of_death");
@@ -1308,7 +1308,7 @@ static void perchild_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *pte
 	is_graceful = 0;
 
 	if (!one_process && !no_detach) {
-	    apr_detach();
+	    apr_proc_detach();
 	}
 
 	my_pid = getpid();
@@ -1354,13 +1354,13 @@ static int pass_request(request_rec *r)
     char *foo;
     int len;
 
-    apr_get_userdata((void **)&foo, "PERCHILD_BUFFER", r->connection->pool);
+    apr_pool_userdata_get((void **)&foo, "PERCHILD_BUFFER", r->connection->pool);
     len = strlen(foo);
 
-    apr_set_userdata(NULL, "PERCHILD_BUFFER", apr_null_cleanup, 
+    apr_pool_userdata_set(NULL, "PERCHILD_BUFFER", apr_pool_cleanup_null, 
                      r->connection->pool);
 
-    apr_get_os_sock(&sfd, thesock);
+    apr_os_sock_get(&sfd, thesock);
 
     iov.iov_base = NULL;
     iov.iov_len = 0;
@@ -1382,7 +1382,7 @@ static int pass_request(request_rec *r)
     msg.msg_flags=0;
 
     if (sendmsg(sconf->sd2, &msg, 0) == -1) {
-        apr_destroy_pool(r->pool);
+        apr_pool_destroy(r->pool);
         return -1;
     }
 
@@ -1398,7 +1398,7 @@ static int pass_request(request_rec *r)
         }
     }
 
-    apr_destroy_pool(r->pool);
+    apr_pool_destroy(r->pool);
     return 1;
 }
 
@@ -1462,7 +1462,7 @@ static int perchild_post_read(request_rec *r)
     if (thread_socket_table[thread_num] != -1) {
         apr_socket_t *csd = NULL;
 
-        apr_put_os_sock(&csd, &thread_socket_table[thread_num], 
+        apr_os_sock_put(&csd, &thread_socket_table[thread_num], 
                              r->connection->pool);
         ap_sock_disable_nagle(csd);
         r->connection->client_socket = csd;
@@ -1494,7 +1494,7 @@ static apr_status_t perchild_buffer(ap_filter_t *f, apr_bucket_brigade *b, ap_in
         return rv;
     }
 
-    apr_get_userdata((void **)&buffer, "PERCHILD_BUFFER", f->c->pool);
+    apr_pool_userdata_get((void **)&buffer, "PERCHILD_BUFFER", f->c->pool);
 
     APR_BRIGADE_FOREACH(e, b) {
         if (e->length != 0) {
@@ -1509,7 +1509,7 @@ static apr_status_t perchild_buffer(ap_filter_t *f, apr_bucket_brigade *b, ap_in
             } 
         }
     }
-    apr_set_userdata(buffer, "PERCHILD_BUFFER", apr_null_cleanup, f->c->pool);
+    apr_pool_userdata_set(buffer, "PERCHILD_BUFFER", apr_pool_cleanup_null, f->c->pool);
     
     return APR_SUCCESS;
 }
diff --git a/server/mpm/prefork/prefork.c b/server/mpm/prefork/prefork.c
index b465d79..ccb18c3 100644
--- a/server/mpm/prefork/prefork.c
+++ b/server/mpm/prefork/prefork.c
@@ -237,7 +237,7 @@ static void clean_child_exit(int code) __attribute__ ((noreturn));
 static void clean_child_exit(int code)
 {
     if (pchild) {
-	apr_destroy_pool(pchild);
+	apr_pool_destroy(pchild);
     }
     chdir_for_gprof();
     exit(code);
@@ -257,7 +257,7 @@ static void accept_mutex_child_init(apr_pool_t *p)
 {
     apr_status_t rv;
 
-    rv = apr_child_init_lock(&accept_lock, ap_lock_fname, p);
+    rv = apr_lock_child_init(&accept_lock, ap_lock_fname, p);
     if (rv) {
 	ap_log_error(APLOG_MARK, APLOG_EMERG, rv, NULL, 
                      "couldn't do child init for accept mutex");
@@ -273,7 +273,7 @@ static void accept_mutex_init(apr_pool_t *p)
     apr_status_t rv;
 
     expand_lock_fname(p);
-    rv = apr_create_lock(&accept_lock, APR_MUTEX, APR_CROSS_PROCESS, ap_lock_fname, p);
+    rv = apr_lock_create(&accept_lock, APR_MUTEX, APR_CROSS_PROCESS, ap_lock_fname, p);
     if (rv) {
 	ap_log_error(APLOG_MARK, APLOG_EMERG, rv, NULL, "couldn't create accept mutex");
         exit(APEXIT_INIT);
@@ -282,7 +282,7 @@ static void accept_mutex_init(apr_pool_t *p)
 
 static void accept_mutex_on(void)
 {
-    apr_status_t rv = apr_lock(accept_lock);
+    apr_status_t rv = apr_lock_aquire(accept_lock);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, NULL, "couldn't grab the accept mutex");
         exit(APEXIT_CHILDFATAL);
@@ -291,7 +291,7 @@ static void accept_mutex_on(void)
 
 static void accept_mutex_off(void)
 {
-    apr_status_t rv = apr_unlock(accept_lock);
+    apr_status_t rv = apr_lock_release(accept_lock);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, NULL, "couldn't release the accept mutex");
         exit(APEXIT_CHILDFATAL);
@@ -398,7 +398,7 @@ static void restart(int sig)
     }
     restart_pending = 1;
     if ((is_graceful = (sig == SIGWINCH))) {
-        apr_kill_cleanup(pconf, NULL, ap_cleanup_scoreboard);
+        apr_pool_cleanup_kill(pconf, NULL, ap_cleanup_scoreboard);
     }
 }
 
@@ -545,9 +545,9 @@ static void child_main(int child_num_arg)
     /* Get a sub context for global allocations in this child, so that
      * we can have cleanups occur when the child exits.
      */
-    apr_create_pool(&pchild, pconf);
+    apr_pool_create(&pchild, pconf);
 
-    apr_create_pool(&ptrans, pchild);
+    apr_pool_create(&ptrans, pchild);
 
     /* needs to be done before we switch UIDs so we have permissions */
     reopen_scoreboard(pchild);
@@ -634,7 +634,7 @@ static void child_main(int child_num_arg)
 		}
 		first_lr=lr;
 		do {
-                    apr_get_os_sock(&sockdes, lr->sd);
+                    apr_os_sock_get(&sockdes, lr->sd);
 		    if (FD_ISSET(sockdes, &main_fds))
 			goto got_listener;
 		    lr = lr->next;
@@ -786,7 +786,7 @@ static void child_main(int child_num_arg)
 	 * socket options, file descriptors, and read/write buffers.
 	 */
 
-        apr_get_os_sock(&sockdes, csd);
+        apr_os_sock_get(&sockdes, csd);
 
         if (sockdes >= FD_SETSIZE) {
             ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
@@ -794,7 +794,7 @@ static void child_main(int child_num_arg)
                          "to rebuild Apache with a larger FD_SETSIZE "
                          "(currently %d)", 
                          sockdes, FD_SETSIZE);
-	    apr_close_socket(csd);
+	    apr_socket_close(csd);
 	    continue;
         }
 
@@ -1058,7 +1058,7 @@ static int setup_listeners(server_rec *s)
     listenmaxfd = -1;
     FD_ZERO(&listenfds);
     for (lr = ap_listeners; lr; lr = lr->next) {
-        apr_get_os_sock(&sockdes, lr->sd);
+        apr_os_sock_get(&sockdes, lr->sd);
 	FD_SET(sockdes, &listenfds);
 	if (sockdes > listenmaxfd) {
 	    listenmaxfd = sockdes;
@@ -1161,7 +1161,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (apr_reap_other_child(&pid, status) == 0) {
+	    else if (apr_proc_other_child_read(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -1295,7 +1295,7 @@ static void prefork_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptem
 	is_graceful = 0;
 
 	if (!one_process && !no_detach) {
-	    apr_detach();
+	    apr_proc_detach();
 	}
 
 	ap_my_pid = getpid();
diff --git a/server/mpm/spmt_os2/spmt_os2.c b/server/mpm/spmt_os2/spmt_os2.c
index 5f0d5e6..5e610e2 100644
--- a/server/mpm/spmt_os2/spmt_os2.c
+++ b/server/mpm/spmt_os2/spmt_os2.c
@@ -142,7 +142,7 @@ struct thread_control_t {
 static void clean_child_exit(int code)
 {
     if (THREAD_GLOBAL(pchild)) {
-        apr_destroy_pool(THREAD_GLOBAL(pchild));
+        apr_pool_destroy(THREAD_GLOBAL(pchild));
     }
 
     thread_control[THREAD_GLOBAL(thread_num)].deferred_die = 0;
@@ -156,7 +156,7 @@ static apr_lock_t *accept_mutex = NULL;
 
 static apr_status_t accept_mutex_child_cleanup(void *foo)
 {
-    return apr_unlock(accept_mutex);
+    return apr_lock_release(accept_mutex);
 }
 
 /*
@@ -165,7 +165,7 @@ static apr_status_t accept_mutex_child_cleanup(void *foo)
  */
 static void accept_mutex_child_init(apr_pool_t *p)
 {
-    apr_register_cleanup(p, NULL, accept_mutex_child_cleanup, apr_null_cleanup);
+    apr_pool_cleanup_register(p, NULL, accept_mutex_child_cleanup, apr_pool_cleanup_null);
 }
 
 /*
@@ -174,7 +174,7 @@ static void accept_mutex_child_init(apr_pool_t *p)
  */
 static void accept_mutex_init(apr_pool_t *p)
 {
-    apr_status_t rc = apr_create_lock(&accept_mutex, APR_MUTEX, APR_INTRAPROCESS, NULL, p);
+    apr_status_t rc = apr_lock_create(&accept_mutex, APR_MUTEX, APR_INTRAPROCESS, NULL, p);
 
     if (rc != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_EMERG, rc, ap_server_conf,
@@ -185,7 +185,7 @@ static void accept_mutex_init(apr_pool_t *p)
 
 static void accept_mutex_on(void)
 {
-    apr_status_t rc = apr_lock(accept_mutex);
+    apr_status_t rc = apr_lock_aquire(accept_mutex);
 
     if (rc != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_EMERG, rc, ap_server_conf,
@@ -196,7 +196,7 @@ static void accept_mutex_on(void)
 
 static void accept_mutex_off(void)
 {
-    apr_status_t rc = apr_unlock(accept_mutex);
+    apr_status_t rc = apr_lock_release(accept_mutex);
 
     if (rc != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_EMERG, rc, ap_server_conf,
@@ -253,7 +253,7 @@ static int wait_or_timeout(apr_wait_t *status)
     if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {
 	wait_or_timeout_counter = 0;
 #if APR_HAS_OTHER_CHILD
-	apr_probe_writable_fds();
+	apr_proc_probe_writable_fds();
 #endif
     }
 
@@ -611,10 +611,10 @@ static int setup_listen_poll(apr_pool_t *pchild, apr_pollfd_t **listen_poll)
         numfds++;
     }
 
-    apr_setup_poll(listen_poll, numfds, pchild);
+    apr_poll_setup(listen_poll, numfds, pchild);
 
     for (lr = ap_listeners; lr; lr = lr->next) {
-	apr_add_poll_socket(*listen_poll, lr->sd, APR_POLLIN);
+	apr_poll_socket_add(*listen_poll, lr->sd, APR_POLLIN);
     }
     return 0;
 }
@@ -646,11 +646,11 @@ static void thread_main(void *thread_num_arg)
     /* Get a sub pool for global allocations in this child, so that
      * we can have cleanups occur when the child exits.
      */
-    apr_create_pool(&pchild, pconf);
+    apr_pool_create(&pchild, pconf);
     *ppthread_globals = (struct thread_globals *)apr_palloc(pchild, sizeof(struct thread_globals));
     THREAD_GLOBAL(thread_num) = (int)thread_num_arg;
     THREAD_GLOBAL(pchild) = pchild;
-    apr_create_pool(&ptrans, pchild);
+    apr_pool_create(&ptrans, pchild);
 
     if (setup_listen_poll(pchild, &listen_poll)) {
 	clean_child_exit(1);
@@ -734,7 +734,7 @@ static void thread_main(void *thread_num_arg)
 			lr = ap_listeners;
 		    }
 
-                    apr_get_revents(&event, lr->sd, listen_poll);
+                    apr_poll_revents_get(&event, lr->sd, listen_poll);
 
 		    if (event == APR_POLLIN) {
                         first_lr = lr->next;
@@ -1166,7 +1166,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         ap_listen_rec *lr;
 
         for (lr = ap_listeners; lr; lr = lr->next) {
-            apr_close_socket(lr->sd);
+            apr_socket_close(lr->sd);
             DosSleep(0);
         }
 
diff --git a/server/mpm/winnt/mpm_winnt.c b/server/mpm/winnt/mpm_winnt.c
index 96169d0..133c2e4 100644
--- a/server/mpm/winnt/mpm_winnt.c
+++ b/server/mpm/winnt/mpm_winnt.c
@@ -159,7 +159,7 @@ static apr_status_t socket_cleanup(void *sock)
 {
     apr_socket_t *thesocket = sock;
     SOCKET sd;
-    if (apr_get_os_sock(&sd, thesocket) == APR_SUCCESS) {
+    if (apr_os_sock_get(&sd, thesocket) == APR_SUCCESS) {
         closesocket(sd);
     }
     return APR_SUCCESS;
@@ -406,7 +406,7 @@ static apr_inline ap_listen_rec *find_ready_listener(fd_set * main_fds)
     SOCKET nsd;
 
     for (lr = head_listener; lr ; lr = lr->next) {
-        apr_get_os_sock(&nsd, lr->sd);
+        apr_os_sock_get(&nsd, lr->sd);
 	if (FD_ISSET(nsd, main_fds)) {
 	    head_listener = lr->next;
             if (head_listener == NULL)
@@ -433,7 +433,7 @@ static int setup_listeners(server_rec *s)
     for (lr = ap_listeners; lr; lr = lr->next) {
         num_listeners++;
         if (lr->sd != NULL) {
-            apr_get_os_sock(&nsd, lr->sd);
+            apr_os_sock_get(&nsd, lr->sd);
             FD_SET(nsd, &listenfds);
             if (listenmaxfd == INVALID_SOCKET || nsd > listenmaxfd) {
                 listenmaxfd = nsd;
@@ -499,7 +499,7 @@ static int setup_inherited_listeners(server_rec *s)
                 listenmaxfd = nsd;
             }
         }
-        apr_put_os_sock(&lr->sd, &nsd, pconf);
+        apr_os_sock_put(&lr->sd, &nsd, pconf);
         lr->count = 0;
     }
     /* Now, read the AcceptExCompPort from the parent */
@@ -524,7 +524,7 @@ static void bind_listeners_to_completion_port()
     if (osver.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS) {
         for (lr = ap_listeners; lr; lr = lr->next) {
             int nsd;
-            apr_get_os_sock(&nsd,lr->sd);
+            apr_os_sock_get(&nsd,lr->sd);
             CreateIoCompletionPort((HANDLE) nsd, AcceptExCompPort, 0, 0);
         }
     }
@@ -651,7 +651,7 @@ static void add_job(int sock)
     new_job->next = NULL;
     new_job->sock = sock;
 
-    apr_lock(allowed_globals.jobmutex);
+    apr_lock_aquire(allowed_globals.jobmutex);
 
     if (allowed_globals.jobtail != NULL)
 	allowed_globals.jobtail->next = new_job;
@@ -661,7 +661,7 @@ static void add_job(int sock)
     allowed_globals.jobcount++;
     release_semaphore(allowed_globals.jobsemaphore);
 
-    apr_unlock(allowed_globals.jobmutex);
+    apr_lock_release(allowed_globals.jobmutex);
 }
 
 static int remove_job(void)
@@ -670,10 +670,10 @@ static int remove_job(void)
     int sock;
 
     acquire_semaphore(allowed_globals.jobsemaphore);
-    apr_lock(allowed_globals.jobmutex);
+    apr_lock_aquire(allowed_globals.jobmutex);
 
     if (shutdown_in_progress && !allowed_globals.jobhead) {
-        apr_unlock(allowed_globals.jobmutex);
+        apr_lock_release(allowed_globals.jobmutex);
 	return (-1);
     }
     job = allowed_globals.jobhead;
@@ -681,7 +681,7 @@ static int remove_job(void)
     allowed_globals.jobhead = job->next;
     if (allowed_globals.jobhead == NULL)
 	allowed_globals.jobtail = NULL;
-    apr_unlock(allowed_globals.jobmutex);
+    apr_lock_release(allowed_globals.jobmutex);
     sock = job->sock;
     free(job);
 
@@ -736,7 +736,7 @@ static void accept_and_queue_connections(void * dummy)
 	    lr = find_ready_listener(&main_fds);
 	    if (lr != NULL) {
                 /* fetch the native socket descriptor */
-                apr_get_os_sock(&nsd, lr->sd);
+                apr_os_sock_get(&nsd, lr->sd);
 	    }
 	}
 
@@ -773,7 +773,7 @@ static PCOMP_CONTEXT win9x_get_connection(PCOMP_CONTEXT context)
                          "win9x_get_connection: apr_pcalloc() failed. Process will exit.");
             return NULL;
         }
-        apr_create_pool(&context->ptrans, pconf);
+        apr_pool_create(&context->ptrans, pconf);
     }
     
 
@@ -873,7 +873,7 @@ static int create_acceptex_context(apr_pool_t *_pconf, ap_listen_rec *lr)
     }
 
     /* create and initialize the accept socket */
-    apr_get_os_sock(&nsd, context->lr->sd);
+    apr_os_sock_get(&nsd, context->lr->sd);
     context->accept_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
     if (context->accept_socket == INVALID_SOCKET) {
         ap_log_error(APLOG_MARK,APLOG_ERR, apr_get_netos_error(), server_conf,
@@ -890,7 +890,7 @@ static int create_acceptex_context(apr_pool_t *_pconf, ap_listen_rec *lr)
         /* Not a failure condition. Keep running. */
     }
 
-    apr_create_pool(&context->ptrans, _pconf);
+    apr_pool_create(&context->ptrans, _pconf);
 
     /* recv_buf must be large enough to hold the remote and local
      * addresses. Note that recv_buf_size is the amount of recv_buf
@@ -931,7 +931,7 @@ static apr_inline apr_status_t reset_acceptex_context(PCOMP_CONTEXT context)
     context->sock = NULL;
 
     /* recreate and initialize the accept socket if it is not being reused */
-    apr_get_os_sock(&nsd, context->lr->sd);
+    apr_os_sock_get(&nsd, context->lr->sd);
 
     /* AcceptEx on the completion context. The completion context will be signaled
      * when a connection is accepted. Hack Alert: TransmitFile, under certain 
@@ -1089,12 +1089,12 @@ static PCOMP_CONTEXT winnt_get_connection(PCOMP_CONTEXT context)
      * but only if we are not in the process of shutting down
      */
     if (!shutdown_in_progress) {
-        apr_lock(allowed_globals.jobmutex);
+        apr_lock_aquire(allowed_globals.jobmutex);
         context->lr->count--;
         if (context->lr->count < 2) {
             SetEvent(maintenance_event);
         }
-        apr_unlock(allowed_globals.jobmutex);
+        apr_lock_release(allowed_globals.jobmutex);
     }
 
     /* Received a connection */
@@ -1160,7 +1160,7 @@ static void worker_main(int thread_num)
         sockinfo.remote  = context->sa_client;
         sockinfo.family  = APR_INET;
         sockinfo.type    = SOCK_STREAM;
-        apr_make_os_sock(&context->sock, &sockinfo, context->ptrans);
+        apr_os_sock_make(&context->sock, &sockinfo, context->ptrans);
 
         ap_update_child_status(0, thread_num,  
                                SERVER_BUSY_READ, (request_rec *) NULL);
@@ -1250,7 +1250,7 @@ static void child_main()
 
     if (one_process) {
         /* Single process mode */
-        apr_create_lock(&start_mutex,APR_MUTEX, APR_CROSS_PROCESS,signal_name_prefix,pconf);
+        apr_lock_create(&start_mutex,APR_MUTEX, APR_CROSS_PROCESS,signal_name_prefix,pconf);
         exit_event = CreateEvent(NULL, TRUE, FALSE, exit_event_name);
 
         setup_listeners(server_conf);
@@ -1258,7 +1258,7 @@ static void child_main()
     }
     else {
         /* Child process mode */
-        apr_child_init_lock(&start_mutex, signal_name_prefix, pconf);
+        apr_lock_child_init(&start_mutex, signal_name_prefix, pconf);
         exit_event = OpenEvent(EVENT_ALL_ACCESS, FALSE, exit_event_name);
         ap_log_error(APLOG_MARK, APLOG_INFO, APR_SUCCESS, server_conf,
                      "Child %d: exit_event_name = %s", my_pid, exit_event_name);
@@ -1275,16 +1275,16 @@ static void child_main()
     ap_assert(exit_event);
     ap_assert(maintenance_event);
 
-    apr_create_pool(&pchild, pconf);
+    apr_pool_create(&pchild, pconf);
     allowed_globals.jobsemaphore = create_semaphore(0);
-    apr_create_lock(&allowed_globals.jobmutex, APR_MUTEX, APR_INTRAPROCESS, NULL, pchild);
+    apr_lock_create(&allowed_globals.jobmutex, APR_MUTEX, APR_INTRAPROCESS, NULL, pchild);
 
     /*
      * Wait until we have permission to start accepting connections.
      * start_mutex is used to ensure that only one child ever
      * goes into the listen/accept loop at once.
      */
-    status = apr_lock(start_mutex);
+    status = apr_lock_aquire(start_mutex);
     if (status != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK,APLOG_ERR, status, server_conf,
                      "Child %d: Failed to acquire the start_mutex. Process will exit.", my_pid);
@@ -1389,7 +1389,7 @@ static void child_main()
         workers_may_exit = 1;
 
         /* Unblock threads blocked on the completion port */
-        apr_lock(allowed_globals.jobmutex);
+        apr_lock_aquire(allowed_globals.jobmutex);
         while (g_blocked_threads > 0) {
             ap_log_error(APLOG_MARK,APLOG_INFO, APR_SUCCESS, server_conf, 
                          "Child %d: %d threads blocked on the completion port", my_pid, g_blocked_threads);
@@ -1398,11 +1398,11 @@ static void child_main()
             }
             Sleep(1000);
         }
-        apr_unlock(allowed_globals.jobmutex);
+        apr_lock_release(allowed_globals.jobmutex);
 
         /* Cancel any remaining pending AcceptEx completion contexts */
         for (lr = ap_listeners; lr != NULL; lr = lr->next) {
-            apr_get_os_sock(&nsd,lr->sd);
+            apr_os_sock_get(&nsd,lr->sd);
             CancelIo((HANDLE) nsd);
         }
 
@@ -1415,7 +1415,7 @@ static void child_main()
      */
     ap_log_error(APLOG_MARK,APLOG_INFO, APR_SUCCESS, server_conf, 
                  "Child %d: Releasing the start mutex", my_pid);
-    apr_unlock(start_mutex);
+    apr_lock_release(start_mutex);
 
     /* Give busy worker threads a chance to service their connections.
      * Kill them off if they take too long
@@ -1442,9 +1442,9 @@ static void child_main()
 
     CloseHandle(AcceptExCompPort);
     destroy_semaphore(allowed_globals.jobsemaphore);
-    apr_destroy_lock(allowed_globals.jobmutex);
+    apr_lock_destroy(allowed_globals.jobmutex);
 
-    apr_destroy_pool(pchild);
+    apr_pool_destroy(pchild);
     CloseHandle(exit_event);
 }
 
@@ -1632,7 +1632,7 @@ static int create_process(apr_pool_t *p, HANDLE *handles, HANDLE *events, int *p
     for (lr = ap_listeners; lr; lr = lr->next) {
         int nsd;
         lpWSAProtocolInfo = apr_pcalloc(p, sizeof(WSAPROTOCOL_INFO));
-        apr_get_os_sock(&nsd,lr->sd);
+        apr_os_sock_get(&nsd,lr->sd);
         ap_log_error(APLOG_MARK, APLOG_INFO, APR_SUCCESS, server_conf,
                      "Parent: Duplicating socket %d and sending it to child process %d", nsd, pi.dwProcessId);
         if (WSADuplicateSocket(nsd, pi.dwProcessId,
@@ -1918,17 +1918,17 @@ void winnt_rewrite_args(process_rec *process)
      * because pconf will be destroyed after the 
      * initial pre-flight of the config parser.
      */
-    mpm_new_argv = apr_make_array(process->pool, process->argc + 2,
+    mpm_new_argv = apr_array_make(process->pool, process->argc + 2,
                                   sizeof(const char *));
-    *(const char **)apr_push_array(mpm_new_argv) = process->argv[0];
-    *(const char **)apr_push_array(mpm_new_argv) = "-d";
-    *(const char **)apr_push_array(mpm_new_argv) = def_server_root;
+    *(const char **)apr_array_push(mpm_new_argv) = process->argv[0];
+    *(const char **)apr_array_push(mpm_new_argv) = "-d";
+    *(const char **)apr_array_push(mpm_new_argv) = def_server_root;
 
     fixed_args = mpm_new_argv->nelts;
 
     optbuf[0] = '-';
     optbuf[2] = '\0';
-    apr_initopt(&opt, process->pool, process->argc, (char**) process->argv);
+    apr_getopt_init(&opt, process->pool, process->argc, (char**) process->argv);
     while (apr_getopt(opt, "n:k:iu" AP_SERVER_BASEARGS, 
                       optbuf + 1, &optarg) == APR_SUCCESS) {
         switch (optbuf[1]) {
@@ -1949,11 +1949,11 @@ void winnt_rewrite_args(process_rec *process)
             signal_arg = "uninstall";
             break;
         default:
-            *(const char **)apr_push_array(mpm_new_argv) =
+            *(const char **)apr_array_push(mpm_new_argv) =
                 apr_pstrdup(process->pool, optbuf);
 
             if (optarg) {
-                *(const char **)apr_push_array(mpm_new_argv) = optarg;
+                *(const char **)apr_array_push(mpm_new_argv) = optarg;
             }
             break;
         }
@@ -2201,7 +2201,7 @@ static void winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *p
              * Ths start mutex is used during a restart to prevent more than one 
              * child process from entering the accept loop at once.
              */
-            apr_create_lock(&start_mutex,APR_MUTEX, APR_CROSS_PROCESS, signal_name_prefix,
+            apr_lock_create(&start_mutex,APR_MUTEX, APR_CROSS_PROCESS, signal_name_prefix,
                                server_conf->process->pool);
         }
     }
@@ -2240,7 +2240,7 @@ AP_DECLARE(int) ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
                              server_conf, "removed PID file %s (pid=%ld)",
                              pidfile, GetCurrentProcessId());
             }
-            apr_destroy_lock(start_mutex);
+            apr_lock_destroy(start_mutex);
 
             CloseHandle(restart_event);
             CloseHandle(shutdown_event);
diff --git a/server/mpm/winnt/registry.c b/server/mpm/winnt/registry.c
index e312285..d993a01 100644
--- a/server/mpm/winnt/registry.c
+++ b/server/mpm/winnt/registry.c
@@ -275,14 +275,14 @@ apr_status_t ap_registry_get_array(apr_pool_t *p, const char *key, const char *n
             ++tmp;
         }
     
-        *parray = apr_make_array(p, nSize, sizeof(char *));
+        *parray = apr_array_make(p, nSize, sizeof(char *));
         tmp = pValue;
-        newelem = (char **) apr_push_array(*parray);
+        newelem = (char **) apr_array_push(*parray);
         *newelem = tmp;
         while (tmp[0] || tmp[1])
         {
             if (!tmp[0]) {
-                newelem = (char **) apr_push_array(*parray);
+                newelem = (char **) apr_array_push(*parray);
                 *newelem = tmp + 1;
             }
             ++tmp;
diff --git a/server/mpm_common.c b/server/mpm_common.c
index 15c4c00..dc00815 100644
--- a/server/mpm_common.c
+++ b/server/mpm_common.c
@@ -115,7 +115,7 @@ void ap_reclaim_child_processes(int terminate)
                 continue;
 
             proc.pid = pid;
-            waitret = apr_wait_proc(&proc, APR_NOWAIT);
+            waitret = apr_proc_wait(&proc, APR_NOWAIT);
             if (waitret != APR_CHILD_NOTDONE) {
                 MPM_NOTE_CHILD_KILLED(i);
                 continue;
@@ -168,7 +168,7 @@ void ap_reclaim_child_processes(int terminate)
                 break;
             }
         }
-        apr_check_other_child();
+        apr_proc_other_child_check();
         if (!not_dead_yet) {
             /* nothing left to wait for */
             break;
@@ -191,10 +191,10 @@ void ap_wait_or_timeout(apr_wait_t *status, apr_proc_t *ret, apr_pool_t *p)
     if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {
         wait_or_timeout_counter = 0;
 #if APR_HAS_OTHER_CHILD
-        apr_probe_writable_fds();
+        apr_proc_probe_writable_fds();
 #endif
     }
-    rv = apr_wait_all_procs(ret, status, APR_NOWAIT, p);
+    rv = apr_proc_wait_all_procs(ret, status, APR_NOWAIT, p);
     if (APR_STATUS_IS_EINTR(rv)) {
         ret->pid = -1;
         return;
diff --git a/server/rfc1413.c b/server/rfc1413.c
index f289bda..1279465 100644
--- a/server/rfc1413.c
+++ b/server/rfc1413.c
@@ -120,29 +120,29 @@ static apr_status_t rfc1413_connect(apr_socket_t **newsock, conn_rec *conn,
     apr_status_t rv;
     apr_sockaddr_t *localsa, *destsa;
 
-    if ((rv = apr_getaddrinfo(&localsa, conn->local_ip, APR_UNSPEC, 
+    if ((rv = apr_sockaddr_info_get(&localsa, conn->local_ip, APR_UNSPEC, 
                               0, /* ephemeral port */
                               0, conn->pool)) != APR_SUCCESS) {
         /* This should not fail since we have a numeric address string
          * as the host. */
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv,
-                     "rfc1413: apr_getaddrinfo(%s) failed",
+                     "rfc1413: apr_sockaddr_info_get(%s) failed",
                      conn->local_ip);
         return rv;
     }
     
-    if ((rv = apr_getaddrinfo(&destsa, conn->remote_ip, 
+    if ((rv = apr_sockaddr_info_get(&destsa, conn->remote_ip, 
                               localsa->sa.sin.sin_family, /* has to match */
                               RFC1413_PORT, 0, conn->pool)) != APR_SUCCESS) {
         /* This should not fail since we have a numeric address string
          * as the host. */
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv,
-                     "rfc1413: apr_getaddrinfo(%s) failed",
+                     "rfc1413: apr_sockaddr_info_get(%s) failed",
                      conn->remote_ip);
         return rv;
     }
 
-    if ((rv = apr_create_socket(newsock, 
+    if ((rv = apr_socket_create(newsock, 
                                 localsa->sa.sin.sin_family, /* has to match */
                                 SOCK_STREAM, conn->pool)) != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv,
@@ -155,7 +155,7 @@ static apr_status_t rfc1413_connect(apr_socket_t **newsock, conn_rec *conn,
         != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv,
                      "rfc1413: error setting query socket timeout");
-        apr_close_socket(*newsock);
+        apr_socket_close(*newsock);
         return rv;
     }
 
@@ -171,7 +171,7 @@ static apr_status_t rfc1413_connect(apr_socket_t **newsock, conn_rec *conn,
     if ((rv = apr_bind(*newsock, localsa)) != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_CRIT, rv, srv,
                      "rfc1413: Error binding query socket to local port");
-        apr_close_socket(*newsock);
+        apr_socket_close(*newsock);
 	return rv;
     }
 
@@ -180,7 +180,7 @@ static apr_status_t rfc1413_connect(apr_socket_t **newsock, conn_rec *conn,
  * the service; don't log such an error
  */
     if ((rv = apr_connect(*newsock, destsa)) != APR_SUCCESS) {
-        apr_close_socket(*newsock);
+        apr_socket_close(*newsock);
         return rv;
     }
 
@@ -199,8 +199,8 @@ static apr_status_t rfc1413_query(apr_socket_t *sock, conn_rec *conn,
     int buflen;
     apr_sockaddr_t *localsa;
 
-    apr_get_sockaddr(&localsa, APR_LOCAL, sock);
-    apr_get_port(&sav_our_port, localsa);
+    apr_socket_addr_get(&localsa, APR_LOCAL, sock);
+    apr_sockaddr_port_get(&sav_our_port, localsa);
     sav_rmt_port = RFC1413_PORT;
 
     /* send the data */
@@ -282,7 +282,7 @@ char *ap_rfc1413(conn_rec *conn, server_rec *srv)
     rv = rfc1413_connect(&sock, conn, srv);
     if (rv == APR_SUCCESS) {
         rv = rfc1413_query(sock, conn, srv);
-        apr_close_socket(sock);
+        apr_socket_close(sock);
     }
     if (rv != APR_SUCCESS) {
         conn->remote_logname = FROM_UNKNOWN;
diff --git a/server/scoreboard.c b/server/scoreboard.c
index abba2cf..bf1a32a 100644
--- a/server/scoreboard.c
+++ b/server/scoreboard.c
@@ -184,8 +184,8 @@ AP_DECLARE(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
     memset(ap_scoreboard_image, 0, SCOREBOARD_SIZE);
     ap_scoreboard_image->global.sb_type = sb_type;
     ap_scoreboard_image->global.running_generation = running_gen;
-    ap_restart_time = apr_now();
-    apr_register_cleanup(p, NULL, ap_cleanup_scoreboard, apr_null_cleanup);
+    ap_restart_time = apr_time_now();
+    apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
 }
 
 /* ToDo:
@@ -334,10 +334,10 @@ void ap_time_process_request(int child_num, int thread_num, int status)
     ss = &ap_scoreboard_image->servers[child_num][thread_num];
 
     if (status == START_PREQUEST) {
-        ss->start_time = apr_now(); 
+        ss->start_time = apr_time_now(); 
     }
     else if (status == STOP_PREQUEST) {
-        ss->stop_time = apr_now(); 
+        ss->stop_time = apr_time_now(); 
     }
     put_scoreboard_info(child_num, thread_num, ss);
 }
diff --git a/server/util.c b/server/util.c
index 9ca1eb0..2e9dfd9 100644
--- a/server/util.c
+++ b/server/util.c
@@ -293,7 +293,7 @@ AP_DECLARE(regex_t *) ap_pregcomp(apr_pool_t *p, const char *pattern,
 	return NULL;
     }
 
-    apr_register_cleanup(p, (void *) preg, regex_cleanup, regex_cleanup);
+    apr_pool_cleanup_register(p, (void *) preg, regex_cleanup, regex_cleanup);
 
     return preg;
 }
@@ -301,7 +301,7 @@ AP_DECLARE(regex_t *) ap_pregcomp(apr_pool_t *p, const char *pattern,
 AP_DECLARE(void) ap_pregfree(apr_pool_t *p, regex_t * reg)
 {
     regfree(reg);
-    apr_kill_cleanup(p, (void *) reg, regex_cleanup);
+    apr_pool_cleanup_kill(p, (void *) reg, regex_cleanup);
 }
 
 /*
@@ -839,14 +839,14 @@ AP_DECLARE(int) ap_cfg_closefile(configfile_t *cfp)
 static apr_status_t cfg_close(void *param)
 {
     apr_file_t *cfp = (apr_file_t *) param;
-    return (apr_close(cfp));
+    return (apr_file_close(cfp));
 }
 
 static int cfg_getch(void *param)
 {
     char ch;
     apr_file_t *cfp = (apr_file_t *) param;
-    if (apr_getc(&ch, cfp) == APR_SUCCESS)
+    if (apr_file_getc(&ch, cfp) == APR_SUCCESS)
         return ch;
     return (int)EOF;
 }
@@ -855,7 +855,7 @@ static void *cfg_getstr(void *buf, size_t bufsiz, void *param)
 {
     apr_file_t *cfp = (apr_file_t *) param;
     apr_status_t rv;
-    rv = apr_fgets(buf, bufsiz, cfp);
+    rv = apr_file_gets(buf, bufsiz, cfp);
     if (rv == APR_SUCCESS || (rv == APR_EOF && strcmp(buf, "")))
         return buf;
     return NULL;
@@ -885,7 +885,7 @@ AP_DECLARE(apr_status_t) ap_pcfg_openfile(configfile_t **ret_cfg, apr_pool_t *p,
      * it was the admin's choice to assign the .htaccess file's name.
      */
 
-    status = apr_open(&file, name, APR_READ | APR_BUFFERED, APR_OS_DEFAULT, p);
+    status = apr_file_open(&file, name, APR_READ | APR_BUFFERED, APR_OS_DEFAULT, p);
 #ifdef DEBUG
     ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, NULL,
                 "Opening config file %s (%s)",
@@ -895,7 +895,7 @@ AP_DECLARE(apr_status_t) ap_pcfg_openfile(configfile_t **ret_cfg, apr_pool_t *p,
     if (status != APR_SUCCESS)
         return status;
 
-    status = apr_getfileinfo(&finfo, APR_FINFO_TYPE, file);
+    status = apr_file_info_get(&finfo, APR_FINFO_TYPE, file);
     if (status != APR_SUCCESS)
         return status;
 
@@ -910,7 +910,7 @@ AP_DECLARE(apr_status_t) ap_pcfg_openfile(configfile_t **ret_cfg, apr_pool_t *p,
         ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, NULL,
                     "Access to file %s denied by server: not a regular file",
                     name);
-        apr_close(file);
+        apr_file_close(file);
         return APR_EBADF;
     }
 
@@ -1828,8 +1828,8 @@ AP_DECLARE(char *) ap_pbase64decode(apr_pool_t *p, const char *bufcoded)
     char *decoded;
     int l;
 
-    decoded = (char *) apr_palloc(p, 1 + apr_base64decode_len(bufcoded));
-    l = apr_base64decode(decoded, bufcoded);
+    decoded = (char *) apr_palloc(p, 1 + apr_base64_decode_len(bufcoded));
+    l = apr_base64_decode(decoded, bufcoded);
     decoded[l] = '\0'; /* make binary sequence into string */
 
     return decoded;
@@ -1840,8 +1840,8 @@ AP_DECLARE(char *) ap_pbase64encode(apr_pool_t *p, char *string)
     char *encoded;
     int l = strlen(string);
 
-    encoded = (char *) apr_palloc(p, 1 + apr_base64encode_len(l));
-    l = apr_base64encode(encoded, string, l);
+    encoded = (char *) apr_palloc(p, 1 + apr_base64_encode_len(l));
+    l = apr_base64_encode(encoded, string, l);
     encoded[l] = '\0'; /* make binary sequence into string */
 
     return encoded;
diff --git a/server/util_filter.c b/server/util_filter.c
index 70efc5f..a5bb118 100644
--- a/server/util_filter.c
+++ b/server/util_filter.c
@@ -104,7 +104,7 @@ static void register_filter(const char *name,
     frec->next = *reg_filter_list;
     *reg_filter_list = frec;
 
-    apr_register_cleanup(FILTER_POOL, NULL, filter_cleanup, apr_null_cleanup);
+    apr_pool_cleanup_register(FILTER_POOL, NULL, filter_cleanup, apr_pool_cleanup_null);
 }
 
 AP_DECLARE(void) ap_register_input_filter(const char *name,
diff --git a/server/util_md5.c b/server/util_md5.c
index c6b130c..631f7b5 100644
--- a/server/util_md5.c
+++ b/server/util_md5.c
@@ -104,12 +104,12 @@ AP_DECLARE(char *) ap_md5_binary(apr_pool_t *p, const unsigned char *buf, int le
      * Take the MD5 hash of the string argument.
      */
 
-    apr_MD5Init(&my_md5);
+    apr_md5_init(&my_md5);
 #if APR_CHARSET_EBCDIC
-    apr_MD5SetXlate(&my_md5, ap_hdrs_to_ascii);
+    apr_md5_set_xlate(&my_md5, ap_hdrs_to_ascii);
 #endif
-    apr_MD5Update(&my_md5, buf, (unsigned int)length);
-    apr_MD5Final(hash, &my_md5);
+    apr_md5_update(&my_md5, buf, (unsigned int)length);
+    apr_md5_final(hash, &my_md5);
 
     for (i = 0, r = result; i < MD5_DIGESTSIZE; i++) {
 	*r++ = hex[hash[i] >> 4];
@@ -179,7 +179,7 @@ AP_DECLARE(char *) ap_md5contextTo64(apr_pool_t *a, apr_md5_ctx_t *context)
 
     encodedDigest = (char *) apr_pcalloc(a, 25 * sizeof(char));
 
-    apr_MD5Final(digest, context);
+    apr_md5_final(digest, context);
     digest[sizeof(digest) - 1] = digest[sizeof(digest) - 2] = 0;
 
     p = encodedDigest;
@@ -203,13 +203,13 @@ AP_DECLARE(char *) ap_md5digest(apr_pool_t *p, apr_file_t *infile)
     apr_size_t nbytes;
     apr_off_t offset = 0L;
 
-    apr_MD5Init(&context);
+    apr_md5_init(&context);
     nbytes = sizeof(buf);
-    while (apr_read(infile, buf, &nbytes) == APR_SUCCESS) {
+    while (apr_file_read(infile, buf, &nbytes) == APR_SUCCESS) {
 	length += nbytes;
-	apr_MD5Update(&context, buf, nbytes);
+	apr_md5_update(&context, buf, nbytes);
     }
-    apr_seek(infile, APR_SET, &offset);
+    apr_file_seek(infile, APR_SET, &offset);
     return ap_md5contextTo64(p, &context);
 }
 
diff --git a/server/util_script.c b/server/util_script.c
index 69ad9cb..7ca5869 100644
--- a/server/util_script.c
+++ b/server/util_script.c
@@ -172,7 +172,7 @@ AP_DECLARE(void) ap_add_common_vars(request_rec *r)
     /* use a temporary apr_table_t which we'll overlap onto
      * r->subprocess_env later
      */
-    e = apr_make_table(r->pool, 25 + hdrs_arr->nelts);
+    e = apr_table_make(r->pool, 25 + hdrs_arr->nelts);
 
     /* First, add environment vars from headers... this is as per
      * CGI specs, though other sorts of scripting interfaces see
@@ -258,8 +258,8 @@ AP_DECLARE(void) ap_add_common_vars(request_rec *r)
     apr_table_addn(e, "SERVER_ADMIN", s->server_admin);	/* Apache */
     apr_table_addn(e, "SCRIPT_FILENAME", r->filename);	/* Apache */
 
-    apr_get_sockaddr(&remotesa, APR_REMOTE, c->client_socket);
-    apr_get_port(&rport, remotesa);
+    apr_socket_addr_get(&remotesa, APR_REMOTE, c->client_socket);
+    apr_sockaddr_port_get(&rport, remotesa);
     apr_table_addn(e, "REMOTE_PORT", apr_psprintf(r->pool, "%d", rport));
 
     if (r->user) {
@@ -284,7 +284,7 @@ AP_DECLARE(void) ap_add_common_vars(request_rec *r)
 	}
     }
 
-    apr_overlap_tables(r->subprocess_env, e, APR_OVERLAP_TABLES_SET);
+    apr_table_overlap(r->subprocess_env, e, APR_OVERLAP_TABLES_SET);
 }
 
 /* This "cute" little function comes about because the path info on
@@ -396,7 +396,7 @@ AP_DECLARE(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
     w = buffer ? buffer : x;
 
     /* temporary place to hold headers to merge in later */
-    merge = apr_make_table(r->pool, 10);
+    merge = apr_table_make(r->pool, 10);
 
     /* The HTTP specification says that it is legal to merge duplicate
      * headers into one.  Some browsers that support Cookies don't like
@@ -404,7 +404,7 @@ AP_DECLARE(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
      * separately.  Lets humour those browsers by not merging.
      * Oh what a pain it is.
      */
-    cookie_table = apr_make_table(r->pool, 2);
+    cookie_table = apr_table_make(r->pool, 2);
     apr_table_do(set_cookie_doo_doo, cookie_table, r->err_headers_out, "Set-Cookie", NULL);
 
     while (1) {
@@ -449,12 +449,12 @@ AP_DECLARE(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
 	    if ((cgi_status == HTTP_OK) && (r->method_number == M_GET)) {
 		cond_status = ap_meets_conditions(r);
 	    }
-	    apr_overlap_tables(r->err_headers_out, merge,
+	    apr_table_overlap(r->err_headers_out, merge,
 		APR_OVERLAP_TABLES_MERGE);
 	    if (!apr_is_empty_table(cookie_table)) {
 		/* the cookies have already been copied to the cookie_table */
 		apr_table_unset(r->err_headers_out, "Set-Cookie");
-		r->err_headers_out = apr_overlay_tables(r->pool,
+		r->err_headers_out = apr_table_overlay(r->pool,
 		    r->err_headers_out, cookie_table);
 	    }
 	    return cond_status;
@@ -562,7 +562,7 @@ AP_DECLARE(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
 
 static int getsfunc_FILE(char *buf, int len, void *f)
 {
-    return apr_fgets(buf, len, (apr_file_t *) f) == APR_SUCCESS;
+    return apr_file_gets(buf, len, (apr_file_t *) f) == APR_SUCCESS;
 }
 
 AP_DECLARE(int) ap_scan_script_header_err(request_rec *r, apr_file_t *f,
diff --git a/server/util_xml.c b/server/util_xml.c
index bcc5cda..c70e34e 100644
--- a/server/util_xml.c
+++ b/server/util_xml.c
@@ -381,7 +381,7 @@ AP_DECLARE(int) ap_xml_parse_input(request_rec * r, ap_xml_doc **pdoc)
     ctx.p = r->pool;
     ctx.doc = apr_pcalloc(ctx.p, sizeof(*ctx.doc));
 
-    ctx.doc->namespaces = apr_make_array(ctx.p, 5, sizeof(const char *));
+    ctx.doc->namespaces = apr_array_make(ctx.p, 5, sizeof(const char *));
     ap_xml_insert_uri(ctx.doc->namespaces, "DAV:");
 
     /* ### we should get the encoding from Content-Encoding */
@@ -863,7 +863,7 @@ AP_DECLARE(int) ap_xml_insert_uri(apr_array_header_t *uri_array,
 	    return i;
     }
 
-    pelt = apr_push_array(uri_array);
+    pelt = apr_array_push(uri_array);
     *pelt = uri;		/* assume uri is const or in a pool */
     return uri_array->nelts - 1;
 }
diff --git a/server/vhost.c b/server/vhost.c
index 2eba9b7..2cae13a 100644
--- a/server/vhost.c
+++ b/server/vhost.c
@@ -220,15 +220,15 @@ static const char *get_addresses(apr_pool_t *p, const char *w_,
     }
 
     if (strcmp(host, "*") == 0) {
-        rv = apr_getaddrinfo(&my_addr, NULL, APR_INET, port, 0, p);
+        rv = apr_sockaddr_info_get(&my_addr, NULL, APR_INET, port, 0, p);
         my_addr->sa.sin.sin_addr.s_addr = htonl(INADDR_ANY);
     } else if (strcasecmp(host, "_default_") == 0
         || strcmp(host, "255.255.255.255") == 0) {
-        rv = apr_getaddrinfo(&my_addr, NULL, APR_INET, port, 0, p);
+        rv = apr_sockaddr_info_get(&my_addr, NULL, APR_INET, port, 0, p);
         ap_assert(rv == APR_SUCCESS); /* must be bug or out of storage */
         my_addr->sa.sin.sin_addr.s_addr = DEFAULT_VHOST_ADDR;
     } else {
-        rv = apr_getaddrinfo(&my_addr, host, APR_UNSPEC, port, 0, p);
+        rv = apr_sockaddr_info_get(&my_addr, host, APR_UNSPEC, port, 0, p);
         if (rv != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
                 "Cannot resolve host name %s --- ignoring!", host);
@@ -237,7 +237,7 @@ static const char *get_addresses(apr_pool_t *p, const char *w_,
     }
 
     /* XXX Gotta go through *all* addresses for the host name! 
-     * Fix apr_getaddrinfo() to save them! */
+     * Fix apr_sockaddr_info_get() to save them! */
 
     sar = apr_pcalloc(p, sizeof(server_addr_rec));
     **paddr = sar;
@@ -457,22 +457,22 @@ static void dump_a_vhost(apr_file_t *f, ipaddr_chain *ic)
 	buf[len-1] = '*';
     }
     if (ic->names == NULL) {
-	apr_fprintf(f, "%-22s %s (%s:%u)\n", buf, ic->server->server_hostname,
+	apr_file_printf(f, "%-22s %s (%s:%u)\n", buf, ic->server->server_hostname,
 		ic->server->defn_name, ic->server->defn_line_number);
 	return;
     }
-    apr_fprintf(f, "%-22s is a NameVirtualHost\n"
+    apr_file_printf(f, "%-22s is a NameVirtualHost\n"
 	    "%8s default server %s (%s:%u)\n",
 	    buf, "", ic->server->server_hostname,
 	    ic->server->defn_name, ic->server->defn_line_number);
     for (nc = ic->names; nc; nc = nc->next) {
 	if (nc->sar->host_port) {
-	    apr_fprintf(f, "%8s port %u ", "", nc->sar->host_port);
+	    apr_file_printf(f, "%8s port %u ", "", nc->sar->host_port);
 	}
 	else {
-	    apr_fprintf(f, "%8s port * ", "");
+	    apr_file_printf(f, "%8s port * ", "");
 	}
-	apr_fprintf(f, "namevhost %s (%s:%u)\n", nc->server->server_hostname,
+	apr_file_printf(f, "namevhost %s (%s:%u)\n", nc->server->server_hostname,
 		nc->server->defn_name, nc->server->defn_line_number);
     }
 }
@@ -482,14 +482,14 @@ static void dump_vhost_config(apr_file_t *f)
     ipaddr_chain *ic;
     int i;
 
-    apr_fprintf(f, "VirtualHost configuration:\n");
+    apr_file_printf(f, "VirtualHost configuration:\n");
     for (i = 0; i < IPHASH_TABLE_SIZE; ++i) {
 	for (ic = iphash_table[i]; ic; ic = ic->next) {
 	    dump_a_vhost(f, ic);
 	}
     }
     if (default_list) {
-	apr_fprintf(f, "wildcard NameVirtualHosts and _default_ servers:\n");
+	apr_file_printf(f, "wildcard NameVirtualHosts and _default_ servers:\n");
 	for (ic = default_list; ic; ic = ic->next) {
 	    dump_a_vhost(f, ic);
 	}
@@ -679,7 +679,7 @@ AP_DECLARE(void) ap_fini_vhost_config(apr_pool_t *p, server_rec *main_s)
 		       ServerName, and their DNS isn't working. -djg */
                     char *ipaddr_str;
 
-                    apr_get_ipaddr(&ipaddr_str, s->addrs->host_addr);
+                    apr_sockaddr_ip_get(&ipaddr_str, s->addrs->host_addr);
 		    ap_log_error(APLOG_MARK, APLOG_ERR, rv, main_s,
                                  "Failed to resolve server name "
                                  "for %s (check DNS) -- or specify an explicit "
@@ -705,7 +705,7 @@ AP_DECLARE(void) ap_fini_vhost_config(apr_pool_t *p, server_rec *main_s)
 #endif
     if (ap_exists_config_define("DUMP_VHOSTS")) {
         apr_file_t *thefile = NULL;
-        apr_open_stderr(&thefile, p);
+        apr_file_open_stderr(&thefile, p);
 	dump_vhost_config(thefile);
     }
 }
@@ -875,8 +875,8 @@ static void check_hostalias(request_rec *r)
     apr_sockaddr_t *localsa;
 
     last_s = NULL;
-    apr_get_sockaddr(&localsa, APR_LOCAL, r->connection->client_socket);
-    apr_get_port(&port, localsa);
+    apr_socket_addr_get(&localsa, APR_LOCAL, r->connection->client_socket);
+    apr_sockaddr_port_get(&port, localsa);
 
     /* Recall that the name_chain is a list of server_addr_recs, some of
      * whose ports may not match.  Also each server may appear more than
@@ -933,8 +933,8 @@ static void check_serverpath(request_rec *r)
     apr_port_t port;
     apr_sockaddr_t *localsa;
 
-    apr_get_sockaddr(&localsa, APR_LOCAL, r->connection->client_socket);
-    apr_get_port(&port, localsa);
+    apr_socket_addr_get(&localsa, APR_LOCAL, r->connection->client_socket);
+    apr_sockaddr_port_get(&port, localsa);
    
     /*
      * This is in conjunction with the ServerPath code in http_core, so we
@@ -1008,7 +1008,7 @@ void ap_update_vhost_given_ip(conn_rec *conn)
     /* maybe there's a default server or wildcard name-based vhost
      * matching this port
      */
-    apr_get_port(&port, conn->local_addr);
+    apr_sockaddr_port_get(&port, conn->local_addr);
     trav = find_default_server(port);
     if (trav) {
 	conn->vhost_lookup_data = trav->names;
diff --git a/support/ab.c b/support/ab.c
index 8c93960..f0d804b 100644
--- a/support/ab.c
+++ b/support/ab.c
@@ -272,7 +272,7 @@ static void apr_err(char *s, apr_status_t rv)
 static void write_request(struct connection *c)
 {
     apr_size_t len = reqlen;
-    c->connect = apr_now();
+    c->connect = apr_time_now();
     apr_setsocketopt(c->aprsock, APR_SO_TIMEOUT, aprtimeout);
     if (apr_send(c->aprsock, request, &reqlen) != APR_SUCCESS ||
         reqlen != len) {
@@ -284,7 +284,7 @@ static void write_request(struct connection *c)
     }
 
     c->state = STATE_READ;
-    apr_add_poll_socket(readbits, c->aprsock, APR_POLLIN);
+    apr_poll_socket_add(readbits, c->aprsock, APR_POLLIN);
 }
 
 /* --------------------------------------------------------- */
@@ -295,7 +295,7 @@ static void output_results(void)
 {
     int timetaken;
 
-    endtime = apr_now();
+    endtime = apr_time_now();
     timetaken = (endtime - start) / 1000;
 
     printf("\r                                                                           \r");
@@ -372,7 +372,7 @@ static void output_html_results(void)
 {
     int timetaken;
 
-    endtime = apr_now();
+    endtime = apr_time_now();
     timetaken = (endtime - start) / 1000;
 
     printf("\n\n<table %s>\n", tablestring);
@@ -505,28 +505,28 @@ static void start_connect(struct connection *c)
     c->cbx = 0;
     c->gotheader = 0;
 
-    if ((rv = apr_getaddrinfo(&destsa, hostname, APR_UNSPEC, port, 0, cntxt))
+    if ((rv = apr_sockaddr_info_get(&destsa, hostname, APR_UNSPEC, port, 0, cntxt))
          != APR_SUCCESS) {
         char buf[120];
 
         apr_snprintf(buf, sizeof(buf), 
-                     "apr_getaddrinfo() for %s", hostname);
+                     "apr_sockaddr_info_get() for %s", hostname);
         apr_err(buf, rv);
     }
-    if ((rv = apr_create_socket(&c->aprsock, destsa->sa.sin.sin_family, 
+    if ((rv = apr_socket_create(&c->aprsock, destsa->sa.sin.sin_family, 
                                 SOCK_STREAM, cntxt)) != APR_SUCCESS) {
         apr_err("socket", rv);
     }
-    c->start = apr_now();
+    c->start = apr_time_now();
     if ((rv = apr_connect(c->aprsock, destsa)) != APR_SUCCESS) {
         if (APR_STATUS_IS_EINPROGRESS(rv)) {
             c->state = STATE_CONNECTING;
-            apr_add_poll_socket(readbits, c->aprsock, APR_POLLOUT);
+            apr_poll_socket_add(readbits, c->aprsock, APR_POLLOUT);
             return;
         }
         else {
-            apr_remove_poll_socket(readbits, c->aprsock);
-            apr_close_socket(c->aprsock);
+            apr_poll_socket_remove(readbits, c->aprsock);
+            apr_socket_close(c->aprsock);
             err_conn++;
             if (bad++ > 10) {
                 fprintf(stderr,
@@ -566,7 +566,7 @@ static void close_connection(struct connection *c)
         /* save out time */
         if (done < requests) {
             struct data s;
-            c->done = apr_now();
+            c->done = apr_time_now();
             s.read  = c->read;
             s.ctime = (c->connect - c->start) / 1000;
             s.time  = (c->done - c->start) / 1000;
@@ -574,8 +574,8 @@ static void close_connection(struct connection *c)
         }
     }
 
-    apr_remove_poll_socket(readbits, c->aprsock);
-    apr_close_socket(c->aprsock);
+    apr_poll_socket_remove(readbits, c->aprsock);
+    apr_socket_close(c->aprsock);
     c->state = STATE_UNCONNECTED;
     
     /* connect again */
@@ -649,8 +649,8 @@ static void read_connection(struct connection *c)
             }
             else {
                 /* header is in invalid or too big - close connection */
-                apr_remove_poll_socket(readbits, c->aprsock);
-                apr_close_socket(c->aprsock);
+                apr_poll_socket_remove(readbits, c->aprsock);
+                apr_socket_close(c->aprsock);
                 err_response++;
                 if (bad++ > 10) {
                     err("\nTest aborted after 10 failures\n\n");
@@ -731,7 +731,7 @@ static void read_connection(struct connection *c)
         }
         if (done < requests) {
             struct data s;
-           c->done = apr_now();
+           c->done = apr_time_now();
             s.read = c->read;
            s.ctime = (c->connect - c->start) / 1000;
            s.time = (c->done - c->start) / 1000;
@@ -766,13 +766,13 @@ static void test(void)
         fflush(stdout);
     }
 
-    now = apr_now();
+    now = apr_time_now();
 
     con = malloc(concurrency * sizeof(struct connection));
     memset(con, 0, concurrency * sizeof(struct connection));
 
     stats = malloc(requests * sizeof(struct data));
-    apr_setup_poll(&readbits, concurrency, cntxt);
+    apr_poll_setup(&readbits, concurrency, cntxt);
 
     /* setup request */
     if (!posting) {
@@ -823,7 +823,7 @@ static void test(void)
 #endif /*NOT_ASCII*/
 
     /* ok - lets start */
-    start = apr_now();
+    start = apr_time_now();
 
     /* initialise lots of requests */
     for (i = 0; i < concurrency; i++) {
@@ -836,7 +836,7 @@ static void test(void)
         apr_int32_t timed;
 
         /* check for time limit expiry */
-        now = apr_now();
+        now = apr_time_now();
         timed = (now - start) / APR_USEC_PER_SEC;
         if (tlimit && timed > (tlimit * 1000)) {
             requests = done;   /* so stats are correct */
@@ -857,7 +857,7 @@ static void test(void)
             if (con[i].state == STATE_UNCONNECTED)
                 continue;
                                
-            apr_get_revents(&rv, con[i].aprsock, readbits);
+            apr_poll_revents_get(&rv, con[i].aprsock, readbits);
             /* Notes: APR_POLLHUP is set after FIN is received on some
              *        systems, so treat that like APR_POLLIN so that we try
              *        to read again.
@@ -887,7 +887,7 @@ static void test(void)
              * in as APR_POLLIN.
              */
             if (con[i].state == STATE_READ || con[i].state == STATE_CONNECTING)
-                apr_add_poll_socket(readbits, con[i].aprsock, APR_POLLIN);
+                apr_poll_socket_add(readbits, con[i].aprsock, APR_POLLIN);
             
         }
     }
@@ -903,14 +903,14 @@ static void test(void)
 static void copyright(void)
 {
     if (!use_html) {
-        printf("This is ApacheBench, Version %s\n", AB_VERSION " <$Revision: 1.54 $> apache-2.0");
+        printf("This is ApacheBench, Version %s\n", AB_VERSION " <$Revision: 1.55 $> apache-2.0");
         printf("Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\n");
         printf("Copyright (c) 1998-2000 The Apache Software Foundation, http://www.apache.org/\n");
         printf("\n");
     }
     else {
         printf("<p>\n");
-        printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-2.0<br>\n", AB_VERSION, "$Revision: 1.54 $");
+        printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-2.0<br>\n", AB_VERSION, "$Revision: 1.55 $");
         printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
         printf(" Copyright (c) 1998-2000 The Apache Software Foundation, http://www.apache.org/<br>\n");
         printf("</p>\n<p>\n");
@@ -995,14 +995,14 @@ static int open_postfile(const char *pfile)
     apr_status_t rv;
     char errmsg[120];
 
-    rv = apr_open(&postfd, pfile, APR_READ, mode, cntxt);
+    rv = apr_file_open(&postfd, pfile, APR_READ, mode, cntxt);
     if (rv != APR_SUCCESS) {
         printf("Invalid postfile name (%s): %s\n", pfile,
                apr_strerror(rv, errmsg, sizeof errmsg));
         return rv;
     }
 
-    apr_getfileinfo(&finfo, APR_FINFO_NORM, postfd);
+    apr_file_info_get(&finfo, APR_FINFO_NORM, postfd);
     postlen = finfo.size;
     postdata = (char *)malloc(postlen);
     if (!postdata) {
@@ -1010,7 +1010,7 @@ static int open_postfile(const char *pfile)
         return APR_ENOMEM;
     }
     length = postlen;
-    rv = apr_read(postfd, postdata, &length);
+    rv = apr_file_read(postfd, postdata, &length);
     if (rv != APR_SUCCESS) {
         printf("error reading postfile: %s\n",
                apr_strerror(rv, errmsg, sizeof errmsg));
@@ -1022,7 +1022,7 @@ static int open_postfile(const char *pfile)
                length);
         return APR_EINVAL;
     }
-    apr_close(postfd);
+    apr_file_close(postfd);
     return 0;
 }
 
@@ -1053,7 +1053,7 @@ int main(int argc, const char * const argv[])
 
     apr_initialize();
     atexit(terminate);
-    apr_create_pool(&cntxt, NULL);
+    apr_pool_create(&cntxt, NULL);
 
 #ifdef NOT_ASCII
     status = apr_xlate_open(&to_ascii, "ISO8859-1", APR_DEFAULT_CHARSET, cntxt);
@@ -1073,7 +1073,7 @@ int main(int argc, const char * const argv[])
     }
 #endif
 
-    apr_initopt(&opt, cntxt, argc, argv);
+    apr_getopt_init(&opt, cntxt, argc, argv);
     while ((status = apr_getopt(opt, "n:c:t:T:p:v:kVhwix:y:z:C:H:P:A:", &c, &optarg)) == APR_SUCCESS) {
         switch (c) {
         case 'n':
@@ -1125,7 +1125,7 @@ int main(int argc, const char * const argv[])
              */
             while(apr_isspace(*optarg))
                 optarg++;
-            l=apr_base64encode(tmp, optarg, strlen(optarg));
+            l=apr_base64_encode(tmp, optarg, strlen(optarg));
             tmp[l]='\0';
  
             strncat(auth, "Authorization: basic ", sizeof(auth));
@@ -1138,7 +1138,7 @@ int main(int argc, const char * const argv[])
              */
             while(apr_isspace(*optarg))
                 optarg++;
-            l=apr_base64encode(tmp, optarg, strlen(optarg));
+            l=apr_base64_encode(tmp, optarg, strlen(optarg));
             tmp[l]='\0';
  
             strncat(auth, "Proxy-Authorization: basic ", sizeof(auth));
diff --git a/support/htdigest.c b/support/htdigest.c
index be9b954..bebf9fb 100644
--- a/support/htdigest.c
+++ b/support/htdigest.c
@@ -129,16 +129,16 @@ static int getline(char *s, int n, apr_file_t *f)
     char ch;
 
     while (1) {
-	apr_getc(&ch, f);
+	apr_file_getc(&ch, f);
             s[i] = ch;
 
 	if (s[i] == CR)
-	    apr_getc(&ch, f);
+	    apr_file_getc(&ch, f);
             s[i] = ch;
 
 	if ((s[i] == 0x4) || (s[i] == LF) || (i == (n - 1))) {
 	    s[i] = '\0';
-            if (apr_eof(f) == APR_EOF) {
+            if (apr_file_eof(f) == APR_EOF) {
                 return 1;
             }
             return 0;
@@ -152,8 +152,8 @@ static void putline(apr_file_t *f, char *l)
     int x;
 
     for (x = 0; l[x]; x++)
-	apr_putc(l[x], f);
-    apr_putc('\n', f);
+	apr_file_putc(l[x], f);
+    apr_file_putc('\n', f);
 }
 
 
@@ -168,36 +168,36 @@ static void add_password(char *user, char *realm, apr_file_t *f)
     unsigned int i;
     size_t len = sizeof(pwin);
 
-    if (apr_getpass("New password: ", pwin, &len) != APR_SUCCESS) {
+    if (apr_password_get("New password: ", pwin, &len) != APR_SUCCESS) {
 	fprintf(stderr, "password too long");
 	exit(5);
     }
     len = sizeof(pwin);
-    apr_getpass("Re-type new password: ", pwv, &len);
+    apr_password_get("Re-type new password: ", pwv, &len);
     if (strcmp(pwin, pwv) != 0) {
 	fprintf(stderr, "They don't match, sorry.\n");
 	if (tn) {
-	    apr_remove_file(tn, cntxt);
+	    apr_file_remove(tn, cntxt);
 	}
 	exit(1);
     }
     pw = pwin;
-    apr_fprintf(f, "%s:%s:", user, realm);
+    apr_file_printf(f, "%s:%s:", user, realm);
 
     /* Do MD5 stuff */
     sprintf(string, "%s:%s:%s", user, realm, pw);
 
-    apr_MD5Init(&context);
+    apr_md5_init(&context);
 #if APR_CHARSET_EBCDIC
-    apr_MD5SetXlate(&context, to_ascii);
+    apr_md5_set_xlate(&context, to_ascii);
 #endif
-    apr_MD5Update(&context, (unsigned char *) string, strlen(string));
-    apr_MD5Final(digest, &context);
+    apr_md5_update(&context, (unsigned char *) string, strlen(string));
+    apr_md5_final(digest, &context);
 
     for (i = 0; i < 16; i++)
-	apr_fprintf(f, "%02x", digest[i]);
+	apr_file_printf(f, "%02x", digest[i]);
 
-    apr_fprintf(f, "\n");
+    apr_file_printf(f, "\n");
 }
 
 static void usage(void)
@@ -211,7 +211,7 @@ static void interrupted(void)
 {
     fprintf(stderr, "Interrupted.\n");
     if (tn)
-	apr_remove_file(tn, cntxt);
+	apr_file_remove(tn, cntxt);
     exit(1);
 }
 
@@ -240,7 +240,7 @@ int main(int argc, char *argv[])
         exit(1);
     }
     atexit(terminate); 
-    apr_create_pool(&cntxt, NULL);
+    apr_pool_create(&cntxt, NULL);
 
 #if APR_CHARSET_EBCDIC
     rv = apr_xlate_open(&to_ascii, "ISO8859-1", APR_DEFAULT_CHARSET, cntxt);
@@ -256,7 +256,7 @@ int main(int argc, char *argv[])
     if (argc == 5) {
 	if (strcmp(argv[1], "-c"))
 	    usage();
-	rv = apr_open(&tfp, argv[2], APR_WRITE | APR_CREATE, -1, cntxt);
+	rv = apr_file_open(&tfp, argv[2], APR_WRITE | APR_CREATE, -1, cntxt);
         if (rv != APR_SUCCESS) {
             char errmsg[120];
 
@@ -267,19 +267,19 @@ int main(int argc, char *argv[])
 	}
 	printf("Adding password for %s in realm %s.\n", argv[4], argv[3]);
 	add_password(argv[4], argv[3], tfp);
-	apr_close(tfp);
+	apr_file_close(tfp);
 	exit(0);
     }
     else if (argc != 4)
 	usage();
 
     tn = tmpnam(NULL);
-    if (apr_open(&tfp, tn, APR_WRITE | APR_CREATE, -1, cntxt)!= APR_SUCCESS) {
+    if (apr_file_open(&tfp, tn, APR_WRITE | APR_CREATE, -1, cntxt)!= APR_SUCCESS) {
 	fprintf(stderr, "Could not open temp file.\n");
 	exit(1);
     }
 
-    if (apr_open(&f, argv[1], APR_READ, -1, cntxt) != APR_SUCCESS) {
+    if (apr_file_open(&f, argv[1], APR_READ, -1, cntxt) != APR_SUCCESS) {
 	fprintf(stderr,
 		"Could not open passwd file %s for reading.\n", argv[1]);
 	fprintf(stderr, "Use -c option to create new one.\n");
@@ -311,14 +311,14 @@ int main(int argc, char *argv[])
 	printf("Adding user %s in realm %s\n", user, realm);
 	add_password(user, realm, tfp);
     }
-    apr_close(f);
-    apr_close(tfp);
+    apr_file_close(f);
+    apr_file_close(tfp);
 #if defined(OS2) || defined(WIN32)
     sprintf(command, "copy \"%s\" \"%s\"", tn, argv[1]);
 #else
     sprintf(command, "cp %s %s", tn, argv[1]);
 #endif
     system(command);
-    apr_remove_file(tn, cntxt);
+    apr_file_remove(tn, cntxt);
     return 0;
 }
diff --git a/support/htpasswd.c b/support/htpasswd.c
index ea79e83..ffed84f 100644
--- a/support/htpasswd.c
+++ b/support/htpasswd.c
@@ -216,13 +216,13 @@ static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
     }
     else {
         bufsize = sizeof(pwin);
-	if (apr_getpass("New password: ", pwin, &bufsize) != 0) {
+	if (apr_password_get("New password: ", pwin, &bufsize) != 0) {
 	    apr_snprintf(record, (rlen - 1), "password too long (>%d)",
 			sizeof(pwin) - 1);
 	    return ERR_OVERFLOW;
 	}
         bufsize = sizeof(pwv);
-	apr_getpass("Re-type new password: ", pwv, &bufsize);
+	apr_password_get("Re-type new password: ", pwv, &bufsize);
 	if (strcmp(pwin, pwv) != 0) {
 	    apr_cpystrn(record, "password verification error", (rlen - 1));
 	    return ERR_PWMISMATCH;
@@ -242,7 +242,7 @@ static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
         to64(&salt[0], rand(), 8);
         salt[8] = '\0';
 
-	apr_MD5Encode((const char *)pw, (const char *)salt,
+	apr_md5_encode((const char *)pw, (const char *)salt,
 		     cpw, sizeof(cpw));
 	break;
 
@@ -402,7 +402,7 @@ int main(int argc, char *argv[])
 
     apr_initialize();
     atexit(apr_terminate);
-    apr_create_pool(&pool, NULL);
+    apr_pool_create(&pool, NULL);
 
     rv = apr_xlate_open(&to_ascii, "ISO8859-1", APR_DEFAULT_CHARSET, pool);
     if (rv) {
diff --git a/support/logresolve.c b/support/logresolve.c
index c88c355..237e091 100644
--- a/support/logresolve.c
+++ b/support/logresolve.c
@@ -297,7 +297,7 @@ int main (int argc, char *argv[])
     int i, check;
 
 #ifdef WIN32
-    /*  If we apr'ify this code, apr_create_pool/apr_destroy_pool
+    /*  If we apr'ify this code, apr_pool_create/apr_pool_destroy
      *  should perform the WSAStartup/WSACleanup for us. 
      */
     WSADATA wsaData;
diff --git a/test/test_find.c b/test/test_find.c
index 2a3d102..e71a531 100644
--- a/test/test_find.c
+++ b/test/test_find.c
@@ -45,7 +45,7 @@ int main (void)
     char line[512];
     char tok[512];
 
-    p = apr_init_alloc();
+    p = apr_pool_alloc_init();
 
     printf("Enter field value to find items within:\n");
     if (!gets(line))
diff --git a/test/test_parser.c b/test/test_parser.c
index 618e3fb..eef1be4 100644
--- a/test/test_parser.c
+++ b/test/test_parser.c
@@ -46,7 +46,7 @@ int main (void)
     char *newstr;
     char instr[512];
 
-    p = apr_init_alloc();
+    p = apr_pool_alloc_init();
 
     while (gets(instr)) {
         printf("  [%s] ==\n", instr);
