commit b6e4ebcaa41618c7c808dc7c5f36f3e3f66197ae
Author: Jim Jagielski <jim@apache.org>
Date:   Thu Nov 10 15:05:51 2005 +0000

    No functional change: simple detabbing of indented code.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@332305 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/modules/aaa/mod_authn_default.c b/modules/aaa/mod_authn_default.c
index babeebd..f13904a 100644
--- a/modules/aaa/mod_authn_default.c
+++ b/modules/aaa/mod_authn_default.c
@@ -46,7 +46,7 @@ static const command_rec authn_default_cmds[] =
                  OR_AUTHCFG,
                  "Set to 'Off' to allow access control to be passed along to "
                  "lower modules if the UserID is not known to this module. "
-		         "(default is On)."),
+                         "(default is On)."),
     {NULL}
 };
 
@@ -60,7 +60,7 @@ static int authenticate_no_user(request_rec *r)
     const char *type;
 
     if (!(type = ap_auth_type(r))) {
-	return DECLINED;
+        return DECLINED;
     }
 
     /* fill in the r->user field */
@@ -74,7 +74,7 @@ static int authenticate_no_user(request_rec *r)
     }
 
     if (conf->authoritative == 0) {
-	return DECLINED;
+        return DECLINED;
     }
 
     ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
diff --git a/modules/aaa/mod_authnz_ldap.c b/modules/aaa/mod_authnz_ldap.c
index bb6901e..e1ef01b 100644
--- a/modules/aaa/mod_authnz_ldap.c
+++ b/modules/aaa/mod_authnz_ldap.c
@@ -246,7 +246,7 @@ static void authn_ldap_build_filter(char *filtbuf,
                 *q++ = '5';
                 *q++ = 'c';
                 break;
-		        }
+                        }
         }
         else
             *q++ = *p++;
diff --git a/modules/arch/netware/libprews.c b/modules/arch/netware/libprews.c
index 264ae05..a76b02f 100644
--- a/modules/arch/netware/libprews.c
+++ b/modules/arch/netware/libprews.c
@@ -76,5 +76,5 @@ void _NonAppStop( void )
 
 int  _NonAppCheckUnload( void )
 {
-	return 0;
+        return 0;
 }
diff --git a/modules/arch/netware/mod_nw_ssl.c b/modules/arch/netware/mod_nw_ssl.c
index 93cda08..54e81f2 100644
--- a/modules/arch/netware/mod_nw_ssl.c
+++ b/modules/arch/netware/mod_nw_ssl.c
@@ -113,7 +113,7 @@ struct seclistenup_rec {
 struct NWSSLSrvConfigRec {
     apr_table_t *sltable;
     apr_table_t *slutable;
-	apr_pool_t *pPool;
+        apr_pool_t *pPool;
 };
 
 struct secsocket_data {
@@ -266,7 +266,7 @@ static int make_secure_socket(apr_pool_t *pconf, const struct sockaddr_in *serve
         
     if (!mutual) {
         optParam = SO_SSL_ENABLE | SO_SSL_SERVER;
-		    
+                    
         if (WSAIoctl(s, SO_SSL_SET_FLAGS, (char *)&optParam,
             sizeof(optParam), NULL, 0, NULL, NULL, NULL)) {
             ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf,
@@ -311,9 +311,9 @@ static int make_secure_socket(apr_pool_t *pconf, const struct sockaddr_in *serve
 
 int convert_secure_socket(conn_rec *c, apr_socket_t *csd)
 {
-	int rcode;
-	struct tlsclientopts sWS2Opts;
-	struct nwtlsopts sNWTLSOpts;
+        int rcode;
+        struct tlsclientopts sWS2Opts;
+        struct nwtlsopts sNWTLSOpts;
    	struct sslserveropts opts;
     unsigned long ulFlags;
     SOCKET sock;
@@ -322,22 +322,22 @@ int convert_secure_socket(conn_rec *c, apr_socket_t *csd)
     apr_os_sock_get(&sock, csd);
 
     /* zero out buffers */
-	memset((char *)&sWS2Opts, 0, sizeof(struct tlsclientopts));
-	memset((char *)&sNWTLSOpts, 0, sizeof(struct nwtlsopts));
+        memset((char *)&sWS2Opts, 0, sizeof(struct tlsclientopts));
+        memset((char *)&sNWTLSOpts, 0, sizeof(struct nwtlsopts));
 
     /* turn on ssl for the socket */
-	ulFlags = (numcerts ? SO_TLS_ENABLE : SO_TLS_ENABLE | SO_TLS_BLIND_ACCEPT);
-	rcode = WSAIoctl(sock, SO_TLS_SET_FLAGS, &ulFlags, sizeof(unsigned long),
+        ulFlags = (numcerts ? SO_TLS_ENABLE : SO_TLS_ENABLE | SO_TLS_BLIND_ACCEPT);
+        rcode = WSAIoctl(sock, SO_TLS_SET_FLAGS, &ulFlags, sizeof(unsigned long),
                      NULL, 0, NULL, NULL, NULL);
-	if (SOCKET_ERROR == rcode)
-	{
+        if (SOCKET_ERROR == rcode)
+        {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server,
                      "Error: %d with ioctlsocket(flag SO_TLS_ENABLE)", WSAGetLastError());
-		return rcode;
-	}
+                return rcode;
+        }
 
     ulFlags = SO_TLS_UNCLEAN_SHUTDOWN;
-	WSAIoctl(sock, SO_TLS_SET_FLAGS, &ulFlags, sizeof(unsigned long),
+        WSAIoctl(sock, SO_TLS_SET_FLAGS, &ulFlags, sizeof(unsigned long),
                      NULL, 0, NULL, NULL, NULL);
 
     /* setup the socket for SSL */
@@ -365,11 +365,11 @@ int convert_secure_socket(conn_rec *c, apr_socket_t *csd)
                      NULL, NULL);
 
     /* make sure that it was successfull */
-	if(SOCKET_ERROR == rcode ){
+        if(SOCKET_ERROR == rcode ){
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server,
                      "Error: %d with ioctl (SO_TLS_SET_CLIENT)", WSAGetLastError());
-	}		
-	return rcode;
+        }		
+        return rcode;
 }
 
 int SSLize_Socket(SOCKET socketHnd, char *key, request_rec *r)
@@ -879,19 +879,19 @@ static int isSecureConnUpgradeable (const server_rec *s, const conn_rec *c)
 
 static int isSecure (const request_rec *r)
 {
-	return isSecureConn (r->server, r->connection);
+        return isSecureConn (r->server, r->connection);
 }
 
 static int isSecureUpgradeable (const request_rec *r)
 {
-	return isSecureConnUpgradeable (r->server, r->connection);
+        return isSecureConnUpgradeable (r->server, r->connection);
 }
 
 static int isSecureUpgraded (const request_rec *r)
 {
     secsocket_data *csd_data = (secsocket_data*)ap_get_module_config(r->connection->conn_config, &nwssl_module);
 
-	return csd_data->is_secure;
+        return csd_data->is_secure;
 }
 
 static int nwssl_hook_Fixup(request_rec *r)
@@ -1053,14 +1053,14 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
      */
     if (result == NULL && c != NULL) {
 
-		/* XXX-Can't get specific SSL info from NetWare */
+                /* XXX-Can't get specific SSL info from NetWare */
         /* SSLConnRec *sslconn = myConnConfig(c);
         if (strlen(var) > 4 && strcEQn(var, "SSL_", 4) 
             && sslconn && sslconn->ssl)
             result = ssl_var_lookup_ssl(p, c, var+4);*/
 
-		if (strlen(var) > 4 && strcEQn(var, "SSL_", 4))
-			result = NULL;
+                if (strlen(var) > 4 && strcEQn(var, "SSL_", 4))
+                        result = NULL;
         else if (strcEQ(var, "REMOTE_ADDR"))
             result = c->remote_ip;
     }
@@ -1070,7 +1070,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
      */
     if (result == NULL) {
         if (strlen(var) > 12 && strcEQn(var, "SSL_VERSION_", 12))
-			result = NULL;
+                        result = NULL;
             /* XXX-Can't get specific SSL info from NetWare */
             /*result = ssl_var_lookup_ssl_version(p, var+12);*/
         else if (strcEQ(var, "SERVER_SOFTWARE"))
diff --git a/modules/arch/win32/mod_isapi.c b/modules/arch/win32/mod_isapi.c
index dd6c40c..b7e061a 100644
--- a/modules/arch/win32/mod_isapi.c
+++ b/modules/arch/win32/mod_isapi.c
@@ -136,20 +136,20 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
      */
     fspec = ap_server_root_relative(cmd->pool, filename);
     if (!fspec) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING, APR_EBADPATH, cmd->server,
-	             "ISAPI: invalid module path, skipping %s", filename);
-	return NULL;
+        ap_log_error(APLOG_MARK, APLOG_WARNING, APR_EBADPATH, cmd->server,
+                     "ISAPI: invalid module path, skipping %s", filename);
+        return NULL;
     }
     if ((rv = apr_stat(&tmp, fspec, APR_FINFO_TYPE, 
                       cmd->temp_pool)) != APR_SUCCESS) { 
-	ap_log_error(APLOG_MARK, APLOG_WARNING, rv, cmd->server,
-	    "ISAPI: unable to stat, skipping %s", fspec);
-	return NULL;
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, cmd->server,
+            "ISAPI: unable to stat, skipping %s", fspec);
+        return NULL;
     }
     if (tmp.filetype != APR_REG) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
-	    "ISAPI: not a regular file, skipping %s", fspec);
-	return NULL;
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+            "ISAPI: not a regular file, skipping %s", fspec);
+        return NULL;
     }
 
     /* Load the extention as cached (with null request_rec) */
@@ -157,7 +157,7 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_WARNING, rv, cmd->server,
                      "ISAPI: unable to cache, skipping %s", fspec);
-	return NULL;
+        return NULL;
     }
 
     return NULL;
@@ -874,12 +874,12 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
             apr_bucket_brigade *bb;
             apr_bucket *b;
             bb = apr_brigade_create(cid->r->pool, c->bucket_alloc);
-	    b = apr_bucket_transient_create((char*) data_type + ate, 
+            b = apr_bucket_transient_create((char*) data_type + ate, 
                                            headlen - ate, c->bucket_alloc);
-	    APR_BRIGADE_INSERT_TAIL(bb, b);
+            APR_BRIGADE_INSERT_TAIL(bb, b);
             b = apr_bucket_flush_create(c->bucket_alloc);
-	    APR_BRIGADE_INSERT_TAIL(bb, b);
-	    ap_pass_brigade(cid->r->output_filters, bb);
+            APR_BRIGADE_INSERT_TAIL(bb, b);
+            ap_pass_brigade(cid->r->output_filters, bb);
             cid->response_sent = 1;
         }
         return 1;
@@ -1274,13 +1274,13 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
             apr_bucket_brigade *bb;
             apr_bucket *b;
             bb = apr_brigade_create(cid->r->pool, c->bucket_alloc);
-	    b = apr_bucket_transient_create(shi->pszHeader + ate, 
+            b = apr_bucket_transient_create(shi->pszHeader + ate, 
                                             shi->cchHeader - ate,
                                             c->bucket_alloc);
-	    APR_BRIGADE_INSERT_TAIL(bb, b);
+            APR_BRIGADE_INSERT_TAIL(bb, b);
             b = apr_bucket_flush_create(c->bucket_alloc);
-	    APR_BRIGADE_INSERT_TAIL(bb, b);
-	    ap_pass_brigade(cid->r->output_filters, bb);
+            APR_BRIGADE_INSERT_TAIL(bb, b);
+            ap_pass_brigade(cid->r->output_filters, bb);
             cid->response_sent = 1;
         }
         return 1;
@@ -1608,8 +1608,8 @@ static int isapi_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pte
 
     apr_pool_create_ex(&loaded.pool, pconf, NULL, NULL);
     if (!loaded.pool) {
-	ap_log_error(APLOG_MARK, APLOG_ERR, APR_EGENERAL, NULL,
-	             "ISAPI: could not create the isapi cache pool");
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EGENERAL, NULL,
+                     "ISAPI: could not create the isapi cache pool");
         return APR_EGENERAL;
     }
     
diff --git a/modules/cache/cache_hash.c b/modules/cache/cache_hash.c
index 8c5e0c1..b5c1adb 100644
--- a/modules/cache/cache_hash.c
+++ b/modules/cache/cache_hash.c
@@ -114,9 +114,9 @@ CACHE_DECLARE(cache_hash_index_t *) cache_hash_next(cache_hash_index_t *hi)
 {
     hi->this = hi->next;
     while (!hi->this) {
-	if (hi->index > hi->ht->max)
-	    return NULL;
-	hi->this = hi->ht->array[hi->index++];
+        if (hi->index > hi->ht->max)
+            return NULL;
+        hi->this = hi->ht->array[hi->index++];
     }
     hi->next = hi->this->next;
     return hi;
@@ -216,15 +216,15 @@ static cache_hash_entry_t **find_entry(cache_hash_t *ht,
     
     /* scan linked list */
     for (hep = &ht->array[hash % ht->max], he = *hep;
-	 he;
-	 hep = &he->next, he = *hep) {
-	if (he->hash == hash &&
-	    he->klen == klen &&
-	    memcmp(he->key, key, klen) == 0)
-	    break;
+         he;
+         hep = &he->next, he = *hep) {
+        if (he->hash == hash &&
+            he->klen == klen &&
+            memcmp(he->key, key, klen) == 0)
+            break;
     }
     if (he || !val)
-	return hep;
+        return hep;
     /* add a new entry for non-NULL values */
     he = malloc(sizeof(*he));
     if (!he) {
@@ -247,9 +247,9 @@ CACHE_DECLARE(void *) cache_hash_get(cache_hash_t *ht,
     cache_hash_entry_t *he;
     he = *find_entry(ht, key, klen, NULL);
     if (he)
-	return (void *)he->val;
+        return (void *)he->val;
     else
-	return NULL;
+        return NULL;
 }
 
 CACHE_DECLARE(void *) cache_hash_set(cache_hash_t *ht,
diff --git a/modules/cache/cache_util.c b/modules/cache/cache_util.c
index a3650e2..eed63f7 100644
--- a/modules/cache/cache_util.c
+++ b/modules/cache/cache_util.c
@@ -209,9 +209,9 @@ CACHE_DECLARE(int) ap_cache_check_freshness(cache_handle_t *h,
         || ap_cache_liststr(NULL, cc_req, "no-cache", NULL)) {
 
         if (!conf->ignorecachecontrol) {
-	    /* Treat as stale, causing revalidation */
-	    return 0;
-	}
+            /* Treat as stale, causing revalidation */
+            return 0;
+        }
 
         ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                      "Incoming request is asking for a uncached version of "
diff --git a/modules/cache/mod_file_cache.c b/modules/cache/mod_file_cache.c
index a23eb6e..54d0ff5 100644
--- a/modules/cache/mod_file_cache.c
+++ b/modules/cache/mod_file_cache.c
@@ -43,9 +43,9 @@
     cachefile directives into your configuration to direct files to
     be cached.
 
-	cachefile /path/to/file1
-	cachefile /path/to/file2
-	...
+        cachefile /path/to/file1
+        cachefile /path/to/file2
+        ...
 
     These files are only cached when the server is restarted, so if you 
     change the list, or if the files are changed, then you'll need to 
@@ -138,23 +138,23 @@ static void cache_the_file(cmd_parms *cmd, const char *filename, int mmap)
         ap_log_error(APLOG_MARK, APLOG_WARNING, APR_EBADPATH, cmd->server,
                      "mod_file_cache: invalid file path "
                      "%s, skipping", filename);
-	return;
+        return;
     }
     if ((rc = apr_stat(&tmp.finfo, fspec, APR_FINFO_MIN, 
                                  cmd->temp_pool)) != APR_SUCCESS) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
-	    "mod_file_cache: unable to stat(%s), skipping", fspec);
-	return;
+        ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
+            "mod_file_cache: unable to stat(%s), skipping", fspec);
+        return;
     }
     if (tmp.finfo.filetype != APR_REG) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
-	    "mod_file_cache: %s isn't a regular file, skipping", fspec);
-	return;
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+            "mod_file_cache: %s isn't a regular file, skipping", fspec);
+        return;
     }
     if (tmp.finfo.size > AP_MAX_SENDFILE) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
-	    "mod_file_cache: %s is too large to cache, skipping", fspec);
-	return;
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,
+            "mod_file_cache: %s is too large to cache, skipping", fspec);
+        return;
     }
 
     rc = apr_file_open(&fd, fspec, APR_READ | APR_BINARY | APR_XTHREAD,
@@ -162,7 +162,7 @@ static void cache_the_file(cmd_parms *cmd, const char *filename, int mmap)
     if (rc != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
                      "mod_file_cache: unable to open(%s, O_RDONLY), skipping", fspec);
-	return;
+        return;
     }
     apr_file_inherit_set(fd);
 
@@ -248,12 +248,12 @@ static int file_cache_xlat(request_rec *r)
 
     /* we only operate when at least one cachefile directive was used */
     if (!apr_hash_count(sconf->fileht)) {
-	return DECLINED;
+        return DECLINED;
     }
 
     res = ap_core_translate(r);
     if (res != OK || !r->filename) {
-	return res;
+        return res;
     }
 
     /* search the cache */
@@ -329,7 +329,7 @@ static int file_cache_handler(request_rec *r)
     match = ap_get_module_config(r->request_config, &file_cache_module);
 
     if (match == NULL) {
-	return DECLINED;
+        return DECLINED;
     }
 
     /* note that we would handle GET on this resource */
diff --git a/modules/dav/fs/lock.c b/modules/dav/fs/lock.c
index c3f071c..d57ac39 100644
--- a/modules/dav/fs/lock.c
+++ b/modules/dav/fs/lock.c
@@ -88,8 +88,8 @@
 
 /* ack. forward declare. */
 static dav_error * dav_fs_remove_locknull_member(apr_pool_t *p,
-						 const char *filename,
-						 dav_buffer *pbuf);
+                                                 const char *filename,
+                                                 dav_buffer *pbuf);
 
 /*
 ** Use the opaquelock scheme for locktokens
@@ -98,7 +98,7 @@ struct dav_locktoken {
     apr_uuid_t uuid;
 };
 #define dav_compare_locktoken(plt1, plt2) \
-		memcmp(&(plt1)->uuid, &(plt2)->uuid, sizeof((plt1)->uuid))
+                memcmp(&(plt1)->uuid, &(plt2)->uuid, sizeof((plt1)->uuid))
 
 
 /* #################################################################
@@ -150,15 +150,15 @@ typedef struct dav_lock_indirect
 ** prefix + Fixed length + lock token + 2 strings + 2 nulls (one for each string)
 */
 #define dav_size_direct(a)	(1 + sizeof(dav_lock_discovery_fixed) \
-				 + sizeof(apr_uuid_t) \
-				 + ((a)->owner ? strlen((a)->owner) : 0) \
-				 + ((a)->auth_user ? strlen((a)->auth_user) : 0) \
-				 + 2)
+                                 + sizeof(apr_uuid_t) \
+                                 + ((a)->owner ? strlen((a)->owner) : 0) \
+                                 + ((a)->auth_user ? strlen((a)->auth_user) : 0) \
+                                 + 2)
 
 /* Stored indirect lock info - lock token and apr_datum_t */
 #define dav_size_indirect(a)	(1 + sizeof(apr_uuid_t) \
-				 + sizeof(time_t) \
-				 + sizeof((a)->key.dsize) + (a)->key.dsize)
+                                 + sizeof(time_t) \
+                                 + sizeof((a)->key.dsize) + (a)->key.dsize)
 
 /*
 ** The lockdb structure.
@@ -212,7 +212,7 @@ extern const dav_hooks_locks dav_hooks_locks_fs;
 
 /* internal function for creating locks */
 static dav_lock *dav_fs_alloc_lock(dav_lockdb *lockdb, apr_datum_t key,
-				   const dav_locktoken *locktoken)
+                                   const dav_locktoken *locktoken)
 {
     dav_lock_combined *comb;
 
@@ -222,11 +222,11 @@ static dav_lock *dav_fs_alloc_lock(dav_lockdb *lockdb, apr_datum_t key,
     comb->priv.key = key;
 
     if (locktoken == NULL) {
-	comb->pub.locktoken = &comb->token;
+        comb->pub.locktoken = &comb->token;
         apr_uuid_get(&comb->token.uuid);
     }
     else {
-	comb->pub.locktoken = locktoken;
+        comb->pub.locktoken = locktoken;
     }
 
     return &comb->pub;
@@ -245,18 +245,18 @@ static dav_error * dav_fs_parse_locktoken(
     dav_locktoken *locktoken;
 
     if (ap_strstr_c(char_token, "opaquelocktoken:") != char_token) {
-	return dav_new_error(p,
-			     HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN,
-			     "The lock token uses an unknown State-token "
-			     "format and could not be parsed.");
+        return dav_new_error(p,
+                             HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN,
+                             "The lock token uses an unknown State-token "
+                             "format and could not be parsed.");
     }
     char_token += 16;
 
     locktoken = apr_pcalloc(p, sizeof(*locktoken));
     if (apr_uuid_parse(&locktoken->uuid, char_token)) {
-	return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN,
-			     "The opaquelocktoken has an incorrect format "
-			     "and could not be parsed.");
+        return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN,
+                             "The opaquelocktoken has an incorrect format "
+                             "and could not be parsed.");
     }
     
     *locktoken_p = locktoken;
@@ -300,18 +300,18 @@ static dav_error * dav_fs_really_open_lockdb(dav_lockdb *lockdb)
     dav_error *err;
 
     if (lockdb->info->opened)
-	return NULL;
+        return NULL;
 
     err = dav_dbm_open_direct(lockdb->info->pool,
-			      lockdb->info->lockdb_path,
-			      lockdb->ro,
-			      &lockdb->info->db);
+                              lockdb->info->lockdb_path,
+                              lockdb->ro,
+                              &lockdb->info->db);
     if (err != NULL) {
-	return dav_push_error(lockdb->info->pool,
-			      HTTP_INTERNAL_SERVER_ERROR,
-			      DAV_ERR_LOCK_OPENDB,
-			      "Could not open the lock database.",
-			      err);
+        return dav_push_error(lockdb->info->pool,
+                              HTTP_INTERNAL_SERVER_ERROR,
+                              DAV_ERR_LOCK_OPENDB,
+                              "Could not open the lock database.",
+                              err);
     }
 
     /* all right. it is opened now. */
@@ -329,7 +329,7 @@ static dav_error * dav_fs_really_open_lockdb(dav_lockdb *lockdb)
 ** Note that only one can be open read/write.
 */
 static dav_error * dav_fs_open_lockdb(request_rec *r, int ro, int force,
-				      dav_lockdb **lockdb)
+                                      dav_lockdb **lockdb)
 {
     dav_lockdb_combined *comb;
 
@@ -342,19 +342,19 @@ static dav_error * dav_fs_open_lockdb(request_rec *r, int ro, int force,
 
     comb->priv.lockdb_path = dav_get_lockdb_path(r);
     if (comb->priv.lockdb_path == NULL) {
-	return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR,
-			     DAV_ERR_LOCK_NO_DB,
-			     "A lock database was not specified with the "
-			     "DAVLockDB directive. One must be specified "
-			     "to use the locking functionality.");
+        return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR,
+                             DAV_ERR_LOCK_NO_DB,
+                             "A lock database was not specified with the "
+                             "DAVLockDB directive. One must be specified "
+                             "to use the locking functionality.");
     }
 
     /* done initializing. return it. */
     *lockdb = &comb->pub;
 
     if (force) {
-	/* ### add a higher-level comment? */
-	return dav_fs_really_open_lockdb(*lockdb);
+        /* ### add a higher-level comment? */
+        return dav_fs_really_open_lockdb(*lockdb);
     }
 
     return NULL;
@@ -368,7 +368,7 @@ static dav_error * dav_fs_open_lockdb(request_rec *r, int ro, int force,
 static void dav_fs_close_lockdb(dav_lockdb *lockdb)
 {
     if (lockdb->info->db != NULL)
-	dav_dbm_close(lockdb->info->db);
+        dav_dbm_close(lockdb->info->db);
 }
 
 /*
@@ -389,7 +389,7 @@ static apr_datum_t dav_fs_build_fname_key(apr_pool_t *p, const char *pathname)
     *key.dptr = DAV_TYPE_FNAME;
     memcpy(key.dptr + 1, pathname, key.dsize - 1);
     if (key.dptr[key.dsize - 2] == '/')
-	key.dptr[--key.dsize - 1] = '\0';
+        key.dptr[--key.dsize - 1] = '\0';
     return key;
 }
 
@@ -419,15 +419,15 @@ static apr_datum_t dav_fs_build_key(apr_pool_t *p,
     if ((rv == APR_SUCCESS || rv == APR_INCOMPLETE)
         && ((finfo.valid & APR_FINFO_IDENT) == APR_FINFO_IDENT))
     {
-	/* ### can we use a buffer for this? */
-	key.dsize = 1 + sizeof(finfo.inode) + sizeof(finfo.device);
-	key.dptr = apr_palloc(p, key.dsize);
-	*key.dptr = DAV_TYPE_INODE;
-	memcpy(key.dptr + 1, &finfo.inode, sizeof(finfo.inode));
-	memcpy(key.dptr + 1 + sizeof(finfo.inode), &finfo.device,
-	       sizeof(finfo.device));
-
-	return key;
+        /* ### can we use a buffer for this? */
+        key.dsize = 1 + sizeof(finfo.inode) + sizeof(finfo.device);
+        key.dptr = apr_palloc(p, key.dsize);
+        *key.dptr = DAV_TYPE_INODE;
+        memcpy(key.dptr + 1, &finfo.inode, sizeof(finfo.inode));
+        memcpy(key.dptr + 1 + sizeof(finfo.inode), &finfo.device,
+               sizeof(finfo.device));
+
+        return key;
     }
 
     return dav_fs_build_fname_key(p, file);
@@ -449,8 +449,8 @@ static int dav_fs_lock_expired(time_t expires)
 **    If direct and indirect == NULL, the key is removed.
 */
 static dav_error * dav_fs_save_lock_record(dav_lockdb *lockdb, apr_datum_t key,
-					   dav_lock_discovery *direct,
-					   dav_lock_indirect *indirect)
+                                           dav_lock_discovery *direct,
+                                           dav_lock_indirect *indirect)
 {
     dav_error *err;
     apr_datum_t val = { 0 };
@@ -460,34 +460,34 @@ static dav_error * dav_fs_save_lock_record(dav_lockdb *lockdb, apr_datum_t key,
 
 #if DAV_DEBUG
     if (lockdb->ro) {
-	return dav_new_error(lockdb->info->pool,
-			     HTTP_INTERNAL_SERVER_ERROR, 0,
-			     "INTERNAL DESIGN ERROR: the lockdb was opened "
-			     "readonly, but an attempt to save locks was "
-			     "performed.");
+        return dav_new_error(lockdb->info->pool,
+                             HTTP_INTERNAL_SERVER_ERROR, 0,
+                             "INTERNAL DESIGN ERROR: the lockdb was opened "
+                             "readonly, but an attempt to save locks was "
+                             "performed.");
     }
 #endif
 
     if ((err = dav_fs_really_open_lockdb(lockdb)) != NULL) {
-	/* ### add a higher-level error? */
-	return err;
+        /* ### add a higher-level error? */
+        return err;
     }
 
     /* If nothing to save, delete key */
     if (dp == NULL && ip == NULL) {
         /* don't fail if the key is not present */
         /* ### but what about other errors? */
-	(void) dav_dbm_delete(lockdb->info->db, key);
+        (void) dav_dbm_delete(lockdb->info->db, key);
         return NULL;
     }
-		
+                
     while(dp) {
-	val.dsize += dav_size_direct(dp);
-	dp = dp->next;
+        val.dsize += dav_size_direct(dp);
+        dp = dp->next;
     }
     while(ip) {
-	val.dsize += dav_size_indirect(ip);
-	ip = ip->next;
+        val.dsize += dav_size_indirect(ip);
+        ip = ip->next;
     }
 
     /* ### can this be apr_palloc() ? */
@@ -497,49 +497,49 @@ static dav_error * dav_fs_save_lock_record(dav_lockdb *lockdb, apr_datum_t key,
     ip  = indirect;
 
     while(dp) {
-	*ptr++ = DAV_LOCK_DIRECT;	/* Direct lock - lock_discovery struct follows */
-	memcpy(ptr, dp, sizeof(dp->f));	/* Fixed portion of struct */
-	ptr += sizeof(dp->f);
+        *ptr++ = DAV_LOCK_DIRECT;	/* Direct lock - lock_discovery struct follows */
+        memcpy(ptr, dp, sizeof(dp->f));	/* Fixed portion of struct */
+        ptr += sizeof(dp->f);
         memcpy(ptr, dp->locktoken, sizeof(*dp->locktoken));
         ptr += sizeof(*dp->locktoken);
-	if (dp->owner == NULL) {
-	    *ptr++ = '\0';
-	}
-	else {
-	    memcpy(ptr, dp->owner, strlen(dp->owner) + 1);	
-	    ptr += strlen(dp->owner) + 1;
-	}
-	if (dp->auth_user == NULL) {
+        if (dp->owner == NULL) {
+            *ptr++ = '\0';
+        }
+        else {
+            memcpy(ptr, dp->owner, strlen(dp->owner) + 1);	
+            ptr += strlen(dp->owner) + 1;
+        }
+        if (dp->auth_user == NULL) {
             *ptr++ = '\0';
-	}
-	else {
-	    memcpy(ptr, dp->auth_user, strlen(dp->auth_user) + 1);
-	    ptr += strlen(dp->auth_user) + 1;
-	}
+        }
+        else {
+            memcpy(ptr, dp->auth_user, strlen(dp->auth_user) + 1);
+            ptr += strlen(dp->auth_user) + 1;
+        }
 
-	dp = dp->next;
+        dp = dp->next;
     }
 
     while(ip) {
-	*ptr++ = DAV_LOCK_INDIRECT;	/* Indirect lock prefix */
-	memcpy(ptr, ip->locktoken, sizeof(*ip->locktoken));	/* Locktoken */
-	ptr += sizeof(*ip->locktoken);
-	memcpy(ptr, &ip->timeout, sizeof(ip->timeout));		/* Expire time */
-	ptr += sizeof(ip->timeout);
-	memcpy(ptr, &ip->key.dsize, sizeof(ip->key.dsize));	/* Size of key */
-	ptr += sizeof(ip->key.dsize);
-	memcpy(ptr, ip->key.dptr, ip->key.dsize);	/* Key data */
-	ptr += ip->key.dsize;
-	ip = ip->next;
+        *ptr++ = DAV_LOCK_INDIRECT;	/* Indirect lock prefix */
+        memcpy(ptr, ip->locktoken, sizeof(*ip->locktoken));	/* Locktoken */
+        ptr += sizeof(*ip->locktoken);
+        memcpy(ptr, &ip->timeout, sizeof(ip->timeout));		/* Expire time */
+        ptr += sizeof(ip->timeout);
+        memcpy(ptr, &ip->key.dsize, sizeof(ip->key.dsize));	/* Size of key */
+        ptr += sizeof(ip->key.dsize);
+        memcpy(ptr, ip->key.dptr, ip->key.dsize);	/* Key data */
+        ptr += ip->key.dsize;
+        ip = ip->next;
     }
 
     if ((err = dav_dbm_store(lockdb->info->db, key, val)) != NULL) {
-	/* ### more details? add an error_id? */
-	return dav_push_error(lockdb->info->pool,
-			      HTTP_INTERNAL_SERVER_ERROR,
-			      DAV_ERR_LOCK_SAVE_LOCK,
-			      "Could not save lock information.",
-			      err);
+        /* ### more details? add an error_id? */
+        return dav_push_error(lockdb->info->pool,
+                              HTTP_INTERNAL_SERVER_ERROR,
+                              DAV_ERR_LOCK_SAVE_LOCK,
+                              "Could not save lock information.",
+                              err);
     }
 
     return NULL;
@@ -556,9 +556,9 @@ static dav_error * dav_fs_save_lock_record(dav_lockdb *lockdb, apr_datum_t key,
 **    ### How much "logging" does RFC 2518 require?
 */
 static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, apr_datum_t key,
-					   int add_method,
-					   dav_lock_discovery **direct,
-					   dav_lock_indirect **indirect)
+                                           int add_method,
+                                           dav_lock_discovery **direct,
+                                           dav_lock_indirect **indirect)
 {
     apr_pool_t *p = lockdb->info->pool;
     dav_error *err;
@@ -570,13 +570,13 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, apr_datum_t key,
     dav_buffer buf = { 0 };
 
     if (add_method != DAV_APPEND_LIST) {
-	*direct = NULL;
-	*indirect = NULL;
+        *direct = NULL;
+        *indirect = NULL;
     }
 
     if ((err = dav_fs_really_open_lockdb(lockdb)) != NULL) {
-	/* ### add a higher-level error? */
-	return err;
+        /* ### add a higher-level error? */
+        return err;
     }
 
     /*
@@ -584,32 +584,32 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, apr_datum_t key,
     ** locks for this resource. Just exit.
     */
     if (lockdb->info->db == NULL)
-	return NULL;
+        return NULL;
 
     if ((err = dav_dbm_fetch(lockdb->info->db, key, &val)) != NULL)
         return err;
-	
+        
     if (!val.dsize)
-	return NULL;
+        return NULL;
 
     while (offset < val.dsize) {
-	switch (*(val.dptr + offset++)) {
-	case DAV_LOCK_DIRECT:
-	    /* Create and fill a dav_lock_discovery structure */
+        switch (*(val.dptr + offset++)) {
+        case DAV_LOCK_DIRECT:
+            /* Create and fill a dav_lock_discovery structure */
 
-	    dp = apr_pcalloc(p, sizeof(*dp));
-	    memcpy(dp, val.dptr + offset, sizeof(dp->f));
-	    offset += sizeof(dp->f);
+            dp = apr_pcalloc(p, sizeof(*dp));
+            memcpy(dp, val.dptr + offset, sizeof(dp->f));
+            offset += sizeof(dp->f);
             dp->locktoken = apr_palloc(p, sizeof(*dp->locktoken));
             memcpy(dp->locktoken, val.dptr + offset, sizeof(*dp->locktoken));
             offset += sizeof(*dp->locktoken);
-	    if (*(val.dptr + offset) == '\0') {
-		++offset;
-	    }
-	    else {
-		dp->owner = apr_pstrdup(p, val.dptr + offset);
-		offset += strlen(dp->owner) + 1;
-	    }
+            if (*(val.dptr + offset) == '\0') {
+                ++offset;
+            }
+            else {
+                dp->owner = apr_pstrdup(p, val.dptr + offset);
+                offset += strlen(dp->owner) + 1;
+            }
 
             if (*(val.dptr + offset) == '\0') {
                 ++offset;
@@ -619,71 +619,71 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, apr_datum_t key,
                 offset += strlen(dp->auth_user) + 1;
             }
 
-	    if (!dav_fs_lock_expired(dp->f.timeout)) {
-		dp->next = *direct;
-		*direct = dp;
-	    }
-	    else {
-		need_save = DAV_TRUE;
-
-		/* Remove timed-out locknull fm .locknull list */
-		if (*key.dptr == DAV_TYPE_FNAME) {
-		    const char *fname = key.dptr + 1;
-		    apr_finfo_t finfo;
+            if (!dav_fs_lock_expired(dp->f.timeout)) {
+                dp->next = *direct;
+                *direct = dp;
+            }
+            else {
+                need_save = DAV_TRUE;
+
+                /* Remove timed-out locknull fm .locknull list */
+                if (*key.dptr == DAV_TYPE_FNAME) {
+                    const char *fname = key.dptr + 1;
+                    apr_finfo_t finfo;
                     apr_status_t rv;
 
-		    /* if we don't see the file, then it's a locknull */
+                    /* if we don't see the file, then it's a locknull */
                     rv = apr_stat(&finfo, fname, APR_FINFO_MIN | APR_FINFO_LINK, p);
-		    if (rv != APR_SUCCESS && rv != APR_INCOMPLETE) {
-			if ((err = dav_fs_remove_locknull_member(p, fname, &buf)) != NULL) {
+                    if (rv != APR_SUCCESS && rv != APR_INCOMPLETE) {
+                        if ((err = dav_fs_remove_locknull_member(p, fname, &buf)) != NULL) {
                             /* ### push a higher-level description? */
                             return err;
                         }
-		    }
-		}
-	    }
-	    break;
+                    }
+                }
+            }
+            break;
 
-	case DAV_LOCK_INDIRECT:
-	    /* Create and fill a dav_lock_indirect structure */
+        case DAV_LOCK_INDIRECT:
+            /* Create and fill a dav_lock_indirect structure */
 
-	    ip = apr_pcalloc(p, sizeof(*ip));
+            ip = apr_pcalloc(p, sizeof(*ip));
             ip->locktoken = apr_palloc(p, sizeof(*ip->locktoken));
-	    memcpy(ip->locktoken, val.dptr + offset, sizeof(*ip->locktoken));
-	    offset += sizeof(*ip->locktoken);
-	    memcpy(&ip->timeout, val.dptr + offset, sizeof(ip->timeout));
-	    offset += sizeof(ip->timeout);
+            memcpy(ip->locktoken, val.dptr + offset, sizeof(*ip->locktoken));
+            offset += sizeof(*ip->locktoken);
+            memcpy(&ip->timeout, val.dptr + offset, sizeof(ip->timeout));
+            offset += sizeof(ip->timeout);
             memcpy(&ip->key.dsize, val.dptr + offset, sizeof(ip->key.dsize)); /* length of datum */
-	    offset += sizeof(ip->key.dsize);
-	    ip->key.dptr = apr_palloc(p, ip->key.dsize); 
-	    memcpy(ip->key.dptr, val.dptr + offset, ip->key.dsize);
-	    offset += ip->key.dsize;
-
-	    if (!dav_fs_lock_expired(ip->timeout)) {
-		ip->next = *indirect;
-		*indirect = ip;
-	    }
-	    else {
-		need_save = DAV_TRUE;
-		/* A locknull resource will never be locked indirectly */
-	    }
-
-	    break;
-
-	default:
-	    dav_dbm_freedatum(lockdb->info->db, val);
-
-	    /* ### should use a computed_desc and insert corrupt token data */
-	    --offset;
-	    return dav_new_error(p,
-				 HTTP_INTERNAL_SERVER_ERROR,
-				 DAV_ERR_LOCK_CORRUPT_DB,
-				 apr_psprintf(p,
-					     "The lock database was found to "
-					     "be corrupt. offset %"
+            offset += sizeof(ip->key.dsize);
+            ip->key.dptr = apr_palloc(p, ip->key.dsize); 
+            memcpy(ip->key.dptr, val.dptr + offset, ip->key.dsize);
+            offset += ip->key.dsize;
+
+            if (!dav_fs_lock_expired(ip->timeout)) {
+                ip->next = *indirect;
+                *indirect = ip;
+            }
+            else {
+                need_save = DAV_TRUE;
+                /* A locknull resource will never be locked indirectly */
+            }
+
+            break;
+
+        default:
+            dav_dbm_freedatum(lockdb->info->db, val);
+
+            /* ### should use a computed_desc and insert corrupt token data */
+            --offset;
+            return dav_new_error(p,
+                                 HTTP_INTERNAL_SERVER_ERROR,
+                                 DAV_ERR_LOCK_CORRUPT_DB,
+                                 apr_psprintf(p,
+                                             "The lock database was found to "
+                                             "be corrupt. offset %"
                                              APR_SIZE_T_FMT ", c=%02x",
-					     offset, val.dptr[offset]));
-	}
+                                             offset, val.dptr[offset]));
+        }
     }
 
     dav_dbm_freedatum(lockdb->info->db, val);
@@ -694,7 +694,7 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, apr_datum_t key,
     ** ### timed-out locks from the response, but don't save that info back
     */
     if (need_save == DAV_TRUE) {
-	return dav_fs_save_lock_record(lockdb, key, *direct, *indirect);
+        return dav_fs_save_lock_record(lockdb, key, *direct, *indirect);
     }
 
     return NULL;
@@ -702,42 +702,42 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, apr_datum_t key,
 
 /* resolve <indirect>, returning <*direct> */
 static dav_error * dav_fs_resolve(dav_lockdb *lockdb,
-				  dav_lock_indirect *indirect,
-				  dav_lock_discovery **direct,
-				  dav_lock_discovery **ref_dp,
-				  dav_lock_indirect **ref_ip)
+                                  dav_lock_indirect *indirect,
+                                  dav_lock_discovery **direct,
+                                  dav_lock_discovery **ref_dp,
+                                  dav_lock_indirect **ref_ip)
 {
     dav_error *err;
     dav_lock_discovery *dir;
     dav_lock_indirect *ind;
-	
+        
     if ((err = dav_fs_load_lock_record(lockdb, indirect->key,
-				       DAV_CREATE_LIST,
-				       &dir, &ind)) != NULL) {
-	/* ### insert a higher-level description? */
-	return err;
+                                       DAV_CREATE_LIST,
+                                       &dir, &ind)) != NULL) {
+        /* ### insert a higher-level description? */
+        return err;
     }
     if (ref_dp != NULL) {
-	*ref_dp = dir;
-	*ref_ip = ind;
+        *ref_dp = dir;
+        *ref_ip = ind;
     }
-		
+                
     for (; dir != NULL; dir = dir->next) {
-	if (!dav_compare_locktoken(indirect->locktoken, dir->locktoken)) {
-	    *direct = dir;
-	    return NULL;
-	}
+        if (!dav_compare_locktoken(indirect->locktoken, dir->locktoken)) {
+            *direct = dir;
+            return NULL;
+        }
     }
 
     /* No match found (but we should have found one!) */
 
     /* ### use a different description and/or error ID? */
     return dav_new_error(lockdb->info->pool,
-			 HTTP_INTERNAL_SERVER_ERROR,
-			 DAV_ERR_LOCK_CORRUPT_DB,
-			 "The lock database was found to be corrupt. "
-			 "An indirect lock's direct lock could not "
-			 "be found.");
+                         HTTP_INTERNAL_SERVER_ERROR,
+                         DAV_ERR_LOCK_CORRUPT_DB,
+                         "The lock database was found to be corrupt. "
+                         "An indirect lock's direct lock could not "
+                         "be found.");
 }
 
 /* ---------------------------------------------------------------
@@ -754,14 +754,14 @@ static dav_error * dav_fs_resolve(dav_lockdb *lockdb,
 static const char *dav_fs_get_supportedlock(const dav_resource *resource)
 {
     static const char supported[] = DEBUG_CR
-	"<D:lockentry>" DEBUG_CR
-	"<D:lockscope><D:exclusive/></D:lockscope>" DEBUG_CR
-	"<D:locktype><D:write/></D:locktype>" DEBUG_CR
-	"</D:lockentry>" DEBUG_CR
-	"<D:lockentry>" DEBUG_CR
-	"<D:lockscope><D:shared/></D:lockscope>" DEBUG_CR
-	"<D:locktype><D:write/></D:locktype>" DEBUG_CR
-	"</D:lockentry>" DEBUG_CR;
+        "<D:lockentry>" DEBUG_CR
+        "<D:lockscope><D:exclusive/></D:lockscope>" DEBUG_CR
+        "<D:locktype><D:write/></D:locktype>" DEBUG_CR
+        "</D:lockentry>" DEBUG_CR
+        "<D:lockentry>" DEBUG_CR
+        "<D:lockscope><D:shared/></D:lockscope>" DEBUG_CR
+        "<D:locktype><D:write/></D:locktype>" DEBUG_CR
+        "</D:lockentry>" DEBUG_CR;
 
     return supported;
 }
@@ -783,7 +783,7 @@ static const char *dav_fs_get_supportedlock(const dav_resource *resource)
 **    for the given directory.
 */
 static dav_error * dav_fs_load_locknull_list(apr_pool_t *p, const char *dirpath,
-					     dav_buffer *pbuf) 
+                                             dav_buffer *pbuf) 
 {
     apr_finfo_t finfo;
     apr_file_t *file = NULL;
@@ -794,7 +794,7 @@ static dav_error * dav_fs_load_locknull_list(apr_pool_t *p, const char *dirpath,
     dav_buffer_init(p, pbuf, dirpath);
 
     if (pbuf->buf[pbuf->cur_len - 1] == '/')
-	pbuf->buf[--pbuf->cur_len] = '\0';
+        pbuf->buf[--pbuf->cur_len] = '\0';
 
     dav_buffer_place(p, pbuf, "/" DAV_FS_STATE_DIR "/" DAV_FS_LOCK_NULL_FILE);
 
@@ -803,38 +803,38 @@ static dav_error * dav_fs_load_locknull_list(apr_pool_t *p, const char *dirpath,
 
     if (apr_file_open(&file, pbuf->buf, APR_READ | APR_BINARY, APR_OS_DEFAULT,
                 p) != APR_SUCCESS) {
-	return NULL;
+        return NULL;
     }
 
     rv = apr_file_info_get(&finfo, APR_FINFO_SIZE, file);
     if (rv != APR_SUCCESS) {
-	err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			    apr_psprintf(p,
-					"Opened but could not stat file %s",
-					pbuf->buf));
-	goto loaderror;
+        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
+                            apr_psprintf(p,
+                                        "Opened but could not stat file %s",
+                                        pbuf->buf));
+        goto loaderror;
     }
 
     if (finfo.size != (apr_size_t)finfo.size) {
-	err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			    apr_psprintf(p,
-					"Opened but rejected huge file %s",
-					pbuf->buf));
-	goto loaderror;
+        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
+                            apr_psprintf(p,
+                                        "Opened but rejected huge file %s",
+                                        pbuf->buf));
+        goto loaderror;
     }
 
     amt = (apr_size_t)finfo.size;
     dav_set_bufsize(p, pbuf, amt);
     if (apr_file_read(file, pbuf->buf, &amt) != APR_SUCCESS
         || amt != finfo.size) {
-	err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			    apr_psprintf(p,
-					"Failure reading locknull file "
-					"for %s", dirpath));
-
-	/* just in case the caller disregards the returned error */
-	pbuf->cur_len = 0;
-	goto loaderror;
+        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
+                            apr_psprintf(p,
+                                        "Failure reading locknull file "
+                                        "for %s", dirpath));
+
+        /* just in case the caller disregards the returned error */
+        pbuf->cur_len = 0;
+        goto loaderror;
     }
 
   loaderror:
@@ -847,7 +847,7 @@ static dav_error * dav_fs_load_locknull_list(apr_pool_t *p, const char *dirpath,
 **    locknull file for dirpath.
 */
 static dav_error * dav_fs_save_locknull_list(apr_pool_t *p, const char *dirpath,
-					     dav_buffer *pbuf)
+                                             dav_buffer *pbuf)
 {
     const char *pathname;
     apr_file_t *file = NULL;
@@ -855,42 +855,42 @@ static dav_error * dav_fs_save_locknull_list(apr_pool_t *p, const char *dirpath,
     apr_size_t amt;
 
     if (pbuf->buf == NULL)
-	return NULL;
+        return NULL;
 
     dav_fs_ensure_state_dir(p, dirpath);
     pathname = apr_pstrcat(p,
-			  dirpath,
-			  dirpath[strlen(dirpath) - 1] == '/' ? "" : "/",
-			  DAV_FS_STATE_DIR "/" DAV_FS_LOCK_NULL_FILE,
-			  NULL);
+                          dirpath,
+                          dirpath[strlen(dirpath) - 1] == '/' ? "" : "/",
+                          DAV_FS_STATE_DIR "/" DAV_FS_LOCK_NULL_FILE,
+                          NULL);
 
     if (pbuf->cur_len == 0) {
-	/* delete the file if cur_len == 0 */
-	if (apr_file_remove(pathname, p) != 0) {
-	    return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-				 apr_psprintf(p,
-					     "Error removing %s", pathname));
-	}
-	return NULL;
+        /* delete the file if cur_len == 0 */
+        if (apr_file_remove(pathname, p) != 0) {
+            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
+                                 apr_psprintf(p,
+                                             "Error removing %s", pathname));
+        }
+        return NULL;
     }
 
     if (apr_file_open(&file, pathname,
                 APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
                 APR_OS_DEFAULT, p) != APR_SUCCESS) {
-	return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			     apr_psprintf(p,
-					 "Error opening %s for writing",
-					 pathname));
+        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
+                             apr_psprintf(p,
+                                         "Error opening %s for writing",
+                                         pathname));
     }
 
     amt = pbuf->cur_len;
     if (apr_file_write(file, pbuf->buf, &amt) != APR_SUCCESS
         || amt != pbuf->cur_len) {
-	err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			    apr_psprintf(p,
-					"Error writing %" APR_SIZE_T_FMT 
+        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
+                            apr_psprintf(p,
+                                        "Error writing %" APR_SIZE_T_FMT 
                                         " bytes to %s",
-					pbuf->cur_len, pathname));
+                                        pbuf->cur_len, pathname));
     }
 
     apr_file_close(file);
@@ -903,7 +903,7 @@ static dav_error * dav_fs_save_locknull_list(apr_pool_t *p, const char *dirpath,
 */
 static dav_error * dav_fs_remove_locknull_member(apr_pool_t *p,
                                                  const char *filename,
-						 dav_buffer *pbuf)
+                                                 dav_buffer *pbuf)
 {
     dav_error *err;
     apr_size_t len;
@@ -915,33 +915,33 @@ static dav_error * dav_fs_remove_locknull_member(apr_pool_t *p,
     int dirty = 0;
 
     if (fname != NULL)
-	*fname++ = '\0';
+        *fname++ = '\0';
     else
-	fname = dirpath;
+        fname = dirpath;
     len = strlen(fname) + 1;
 
     if ((err = dav_fs_load_locknull_list(p, dirpath, pbuf)) != NULL) {
-	/* ### add a higher level description? */
-	return err;
+        /* ### add a higher level description? */
+        return err;
     }
 
     for (scan = pbuf->buf, scanend = scan + pbuf->cur_len;
-	 scan < scanend;
-	 scan += scanlen) {
-	scanlen = strlen(scan) + 1;
-	if (len == scanlen && memcmp(fname, scan, scanlen) == 0) {
-	    pbuf->cur_len -= scanlen;
-	    memmove(scan, scan + scanlen, scanend - (scan + scanlen));
-	    dirty = 1;
-	    break;
-	}
+         scan < scanend;
+         scan += scanlen) {
+        scanlen = strlen(scan) + 1;
+        if (len == scanlen && memcmp(fname, scan, scanlen) == 0) {
+            pbuf->cur_len -= scanlen;
+            memmove(scan, scan + scanlen, scanend - (scan + scanlen));
+            dirty = 1;
+            break;
+        }
     }
 
     if (dirty) {
-	if ((err = dav_fs_save_locknull_list(p, dirpath, pbuf)) != NULL) {
-	    /* ### add a higher level description? */
-	    return err;
-	}
+        if ((err = dav_fs_save_locknull_list(p, dirpath, pbuf)) != NULL) {
+            /* ### add a higher level description? */
+            return err;
+        }
     }
 
     return NULL;
@@ -976,7 +976,7 @@ static dav_error * dav_fs_add_locknull_state(
 
     if ((err = dav_fs_load_locknull_list(p, dirpath, &buf)) != NULL) {
         return dav_push_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			      "Could not load .locknull file.", err);
+                              "Could not load .locknull file.", err);
     }
 
     dav_buffer_append(p, &buf, fname);
@@ -984,7 +984,7 @@ static dav_error * dav_fs_add_locknull_state(
 
     if ((err = dav_fs_save_locknull_list(p, dirpath, &buf)) != NULL) {
         return dav_push_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			      "Could not save .locknull file.", err);
+                              "Could not save .locknull file.", err);
     }
 
     return NULL;
@@ -1010,36 +1010,36 @@ static dav_error * dav_fs_remove_locknull_state(
     const char *pathname = dav_fs_pathname(resource);
 
     if ((err = dav_fs_remove_locknull_member(p, pathname, &buf)) != NULL) {
-	/* ### add a higher-level description? */
-	return err;
+        /* ### add a higher-level description? */
+        return err;
     }
 
     {
-	dav_lock_discovery *ld;
-	dav_lock_indirect  *id;
-	apr_datum_t key;
-
-	/*
-	** Fetch the lock(s) that made the resource lock-null. Remove
-	** them under the filename key. Obtain the new inode key, and
-	** save the same lock information under it.
-	*/
-	key = dav_fs_build_fname_key(p, pathname);
-	if ((err = dav_fs_load_lock_record(lockdb, key, DAV_CREATE_LIST,
-					   &ld, &id)) != NULL) {
-	    /* ### insert a higher-level error description */
-	    return err;
-	}
-
-	if ((err = dav_fs_save_lock_record(lockdb, key, NULL, NULL)) != NULL) {
-	    /* ### insert a higher-level error description */
-	    return err;
+        dav_lock_discovery *ld;
+        dav_lock_indirect  *id;
+        apr_datum_t key;
+
+        /*
+        ** Fetch the lock(s) that made the resource lock-null. Remove
+        ** them under the filename key. Obtain the new inode key, and
+        ** save the same lock information under it.
+        */
+        key = dav_fs_build_fname_key(p, pathname);
+        if ((err = dav_fs_load_lock_record(lockdb, key, DAV_CREATE_LIST,
+                                           &ld, &id)) != NULL) {
+            /* ### insert a higher-level error description */
+            return err;
+        }
+
+        if ((err = dav_fs_save_lock_record(lockdb, key, NULL, NULL)) != NULL) {
+            /* ### insert a higher-level error description */
+            return err;
         }
 
-	key = dav_fs_build_key(p, resource);
-	if ((err = dav_fs_save_lock_record(lockdb, key, ld, id)) != NULL) {
-	    /* ### insert a higher-level error description */
-	    return err;
+        key = dav_fs_build_key(p, resource);
+        if ((err = dav_fs_save_lock_record(lockdb, key, ld, id)) != NULL) {
+            /* ### insert a higher-level error description */
+            return err;
         }
     }
 
@@ -1047,16 +1047,16 @@ static dav_error * dav_fs_remove_locknull_state(
 }
 
 static dav_error * dav_fs_create_lock(dav_lockdb *lockdb,
-				      const dav_resource *resource,
-				      dav_lock **lock)
+                                      const dav_resource *resource,
+                                      dav_lock **lock)
 {
     apr_datum_t key;
 
     key = dav_fs_build_key(lockdb->info->pool, resource);
 
     *lock = dav_fs_alloc_lock(lockdb,
-			      key,
-			      NULL);
+                              key,
+                              NULL);
 
     (*lock)->is_locknull = !resource->exists;
 
@@ -1064,9 +1064,9 @@ static dav_error * dav_fs_create_lock(dav_lockdb *lockdb,
 }
 
 static dav_error * dav_fs_get_locks(dav_lockdb *lockdb,
-				    const dav_resource *resource,
-				    int calltype,
-				    dav_lock **locks)
+                                    const dav_resource *resource,
+                                    int calltype,
+                                    dav_lock **locks)
 {
     apr_pool_t *p = lockdb->info->pool;
     apr_datum_t key;
@@ -1078,62 +1078,62 @@ static dav_error * dav_fs_get_locks(dav_lockdb *lockdb,
 
 #if DAV_DEBUG
     if (calltype == DAV_GETLOCKS_COMPLETE) {
-	return dav_new_error(lockdb->info->pool,
-			     HTTP_INTERNAL_SERVER_ERROR, 0,
-			     "INTERNAL DESIGN ERROR: DAV_GETLOCKS_COMPLETE "
-			     "is not yet supported");
+        return dav_new_error(lockdb->info->pool,
+                             HTTP_INTERNAL_SERVER_ERROR, 0,
+                             "INTERNAL DESIGN ERROR: DAV_GETLOCKS_COMPLETE "
+                             "is not yet supported");
     }
 #endif
 
     key = dav_fs_build_key(p, resource);
     if ((err = dav_fs_load_lock_record(lockdb, key, DAV_CREATE_LIST,
-				       &dp, &ip)) != NULL) {
-	/* ### push a higher-level desc? */
-	return err;
+                                       &dp, &ip)) != NULL) {
+        /* ### push a higher-level desc? */
+        return err;
     }
 
     /* copy all direct locks to the result list */
     for (; dp != NULL; dp = dp->next) {
-	newlock = dav_fs_alloc_lock(lockdb, key, dp->locktoken);
-	newlock->is_locknull = !resource->exists;
-	newlock->scope = dp->f.scope;
-	newlock->type = dp->f.type;
-	newlock->depth = dp->f.depth;
-	newlock->timeout = dp->f.timeout;
-	newlock->owner = dp->owner;
+        newlock = dav_fs_alloc_lock(lockdb, key, dp->locktoken);
+        newlock->is_locknull = !resource->exists;
+        newlock->scope = dp->f.scope;
+        newlock->type = dp->f.type;
+        newlock->depth = dp->f.depth;
+        newlock->timeout = dp->f.timeout;
+        newlock->owner = dp->owner;
         newlock->auth_user = dp->auth_user;
 
-	/* hook into the result list */
-	newlock->next = lock;
-	lock = newlock;
+        /* hook into the result list */
+        newlock->next = lock;
+        lock = newlock;
     }
 
     /* copy all the indirect locks to the result list. resolve as needed. */
     for (; ip != NULL; ip = ip->next) {
-	newlock = dav_fs_alloc_lock(lockdb, ip->key, ip->locktoken);
-	newlock->is_locknull = !resource->exists;
-
-	if (calltype == DAV_GETLOCKS_RESOLVED) {
-	    if ((err = dav_fs_resolve(lockdb, ip, &dp, NULL, NULL)) != NULL) {
-		/* ### push a higher-level desc? */
-		return err;
-	    }
-
-	    newlock->scope = dp->f.scope;
-	    newlock->type = dp->f.type;
-	    newlock->depth = dp->f.depth;
-	    newlock->timeout = dp->f.timeout;
-	    newlock->owner = dp->owner;
+        newlock = dav_fs_alloc_lock(lockdb, ip->key, ip->locktoken);
+        newlock->is_locknull = !resource->exists;
+
+        if (calltype == DAV_GETLOCKS_RESOLVED) {
+            if ((err = dav_fs_resolve(lockdb, ip, &dp, NULL, NULL)) != NULL) {
+                /* ### push a higher-level desc? */
+                return err;
+            }
+
+            newlock->scope = dp->f.scope;
+            newlock->type = dp->f.type;
+            newlock->depth = dp->f.depth;
+            newlock->timeout = dp->f.timeout;
+            newlock->owner = dp->owner;
             newlock->auth_user = dp->auth_user;
-	}
-	else {
-	    /* DAV_GETLOCKS_PARTIAL */
-	    newlock->rectype = DAV_LOCKREC_INDIRECT_PARTIAL;
-	}
-
-	/* hook into the result list */
-	newlock->next = lock;
-	lock = newlock;
+        }
+        else {
+            /* DAV_GETLOCKS_PARTIAL */
+            newlock->rectype = DAV_LOCKREC_INDIRECT_PARTIAL;
+        }
+
+        /* hook into the result list */
+        newlock->next = lock;
+        lock = newlock;
     }
 
     *locks = lock;
@@ -1141,10 +1141,10 @@ static dav_error * dav_fs_get_locks(dav_lockdb *lockdb,
 }
 
 static dav_error * dav_fs_find_lock(dav_lockdb *lockdb,
-				    const dav_resource *resource,
-				    const dav_locktoken *locktoken,
-				    int partial_ok,
-				    dav_lock **lock)
+                                    const dav_resource *resource,
+                                    const dav_locktoken *locktoken,
+                                    int partial_ok,
+                                    dav_lock **lock)
 {
     dav_error *err;
     apr_datum_t key;
@@ -1155,58 +1155,58 @@ static dav_error * dav_fs_find_lock(dav_lockdb *lockdb,
 
     key = dav_fs_build_key(lockdb->info->pool, resource);
     if ((err = dav_fs_load_lock_record(lockdb, key, DAV_CREATE_LIST,
-				       &dp, &ip)) != NULL) {
-	/* ### push a higher-level desc? */
-	return err;
+                                       &dp, &ip)) != NULL) {
+        /* ### push a higher-level desc? */
+        return err;
     }
 
     for (; dp != NULL; dp = dp->next) {
-	if (!dav_compare_locktoken(locktoken, dp->locktoken)) {
-	    *lock = dav_fs_alloc_lock(lockdb, key, locktoken);
-	    (*lock)->is_locknull = !resource->exists;
-	    (*lock)->scope = dp->f.scope;
-	    (*lock)->type = dp->f.type;
-	    (*lock)->depth = dp->f.depth;
-	    (*lock)->timeout = dp->f.timeout;
-	    (*lock)->owner = dp->owner;
+        if (!dav_compare_locktoken(locktoken, dp->locktoken)) {
+            *lock = dav_fs_alloc_lock(lockdb, key, locktoken);
+            (*lock)->is_locknull = !resource->exists;
+            (*lock)->scope = dp->f.scope;
+            (*lock)->type = dp->f.type;
+            (*lock)->depth = dp->f.depth;
+            (*lock)->timeout = dp->f.timeout;
+            (*lock)->owner = dp->owner;
             (*lock)->auth_user = dp->auth_user;
-	    return NULL;
-	}
+            return NULL;
+        }
     }
 
     for (; ip != NULL; ip = ip->next) {
-	if (!dav_compare_locktoken(locktoken, ip->locktoken)) {
-	    *lock = dav_fs_alloc_lock(lockdb, ip->key, locktoken);
-	    (*lock)->is_locknull = !resource->exists;
-
-	    /* ### nobody uses the resolving right now! */
-	    if (partial_ok) {
-		(*lock)->rectype = DAV_LOCKREC_INDIRECT_PARTIAL;
-	    }
-	    else {
-		(*lock)->rectype = DAV_LOCKREC_INDIRECT;
-		if ((err = dav_fs_resolve(lockdb, ip, &dp,
-					  NULL, NULL)) != NULL) {
-		    /* ### push a higher-level desc? */
-		    return err;
-		}
-		(*lock)->scope = dp->f.scope;
-		(*lock)->type = dp->f.type;
-		(*lock)->depth = dp->f.depth;
-		(*lock)->timeout = dp->f.timeout;
-		(*lock)->owner = dp->owner;
+        if (!dav_compare_locktoken(locktoken, ip->locktoken)) {
+            *lock = dav_fs_alloc_lock(lockdb, ip->key, locktoken);
+            (*lock)->is_locknull = !resource->exists;
+
+            /* ### nobody uses the resolving right now! */
+            if (partial_ok) {
+                (*lock)->rectype = DAV_LOCKREC_INDIRECT_PARTIAL;
+            }
+            else {
+                (*lock)->rectype = DAV_LOCKREC_INDIRECT;
+                if ((err = dav_fs_resolve(lockdb, ip, &dp,
+                                          NULL, NULL)) != NULL) {
+                    /* ### push a higher-level desc? */
+                    return err;
+                }
+                (*lock)->scope = dp->f.scope;
+                (*lock)->type = dp->f.type;
+                (*lock)->depth = dp->f.depth;
+                (*lock)->timeout = dp->f.timeout;
+                (*lock)->owner = dp->owner;
                 (*lock)->auth_user = dp->auth_user;
-	    }
-	    return NULL;
-	}
+            }
+            return NULL;
+        }
     }
 
     return NULL;
 }
 
 static dav_error * dav_fs_has_locks(dav_lockdb *lockdb,
-				    const dav_resource *resource,
-				    int *locks_present)
+                                    const dav_resource *resource,
+                                    int *locks_present)
 {
     dav_error *err;
     apr_datum_t key;
@@ -1214,8 +1214,8 @@ static dav_error * dav_fs_has_locks(dav_lockdb *lockdb,
     *locks_present = 0;
 
     if ((err = dav_fs_really_open_lockdb(lockdb)) != NULL) {
-	/* ### insert a higher-level error description */
-	return err;
+        /* ### insert a higher-level error description */
+        return err;
     }
 
     /*
@@ -1223,7 +1223,7 @@ static dav_error * dav_fs_has_locks(dav_lockdb *lockdb,
     ** locks for this resource. Just exit.
     */
     if (lockdb->info->db == NULL)
-	return NULL;
+        return NULL;
 
     key = dav_fs_build_key(lockdb->info->pool, resource);
 
@@ -1233,9 +1233,9 @@ static dav_error * dav_fs_has_locks(dav_lockdb *lockdb,
 }
 
 static dav_error * dav_fs_append_locks(dav_lockdb *lockdb,
-				       const dav_resource *resource,
-				       int make_indirect,
-				       const dav_lock *lock)
+                                       const dav_resource *resource,
+                                       int make_indirect,
+                                       const dav_lock *lock)
 {
     apr_pool_t *p = lockdb->info->pool;
     dav_error *err;
@@ -1245,8 +1245,8 @@ static dav_error * dav_fs_append_locks(dav_lockdb *lockdb,
 
     key = dav_fs_build_key(lockdb->info->pool, resource);
     if ((err = dav_fs_load_lock_record(lockdb, key, 0, &dp, &ip)) != NULL) {
-	/* ### maybe add in a higher-level description */
-	return err;
+        /* ### maybe add in a higher-level description */
+        return err;
     }
 
     /*
@@ -1255,70 +1255,70 @@ static dav_error * dav_fs_append_locks(dav_lockdb *lockdb,
     */
 
     if (make_indirect) {
-	for (; lock != NULL; lock = lock->next) {
-
-	    /* ### this works for any <lock> rectype */
-	    dav_lock_indirect *newi = apr_pcalloc(p, sizeof(*newi));
-
-	    /* ### shut off the const warning for now */
-	    newi->locktoken = (dav_locktoken *)lock->locktoken;
-	    newi->timeout   = lock->timeout;
-	    newi->key       = lock->info->key;
-	    newi->next      = ip;
-	    ip              = newi;
-	}
+        for (; lock != NULL; lock = lock->next) {
+
+            /* ### this works for any <lock> rectype */
+            dav_lock_indirect *newi = apr_pcalloc(p, sizeof(*newi));
+
+            /* ### shut off the const warning for now */
+            newi->locktoken = (dav_locktoken *)lock->locktoken;
+            newi->timeout   = lock->timeout;
+            newi->key       = lock->info->key;
+            newi->next      = ip;
+            ip              = newi;
+        }
     }
     else {
-	for (; lock != NULL; lock = lock->next) {
-	    /* create and link in the right kind of lock */
-
-	    if (lock->rectype == DAV_LOCKREC_DIRECT) {
-		dav_lock_discovery *newd = apr_pcalloc(p, sizeof(*newd));
-
-		newd->f.scope = lock->scope;
-		newd->f.type = lock->type;
-		newd->f.depth = lock->depth;
-		newd->f.timeout = lock->timeout;
-		/* ### shut off the const warning for now */
-		newd->locktoken = (dav_locktoken *)lock->locktoken;
-		newd->owner = lock->owner;
+        for (; lock != NULL; lock = lock->next) {
+            /* create and link in the right kind of lock */
+
+            if (lock->rectype == DAV_LOCKREC_DIRECT) {
+                dav_lock_discovery *newd = apr_pcalloc(p, sizeof(*newd));
+
+                newd->f.scope = lock->scope;
+                newd->f.type = lock->type;
+                newd->f.depth = lock->depth;
+                newd->f.timeout = lock->timeout;
+                /* ### shut off the const warning for now */
+                newd->locktoken = (dav_locktoken *)lock->locktoken;
+                newd->owner = lock->owner;
                 newd->auth_user = lock->auth_user;
-		newd->next = dp;
-		dp = newd;
-	    }
-	    else {
-		/* DAV_LOCKREC_INDIRECT(_PARTIAL) */
-
-		dav_lock_indirect *newi = apr_pcalloc(p, sizeof(*newi));
-
-		/* ### shut off the const warning for now */
-		newi->locktoken = (dav_locktoken *)lock->locktoken;
-		newi->key       = lock->info->key;
-		newi->next      = ip;
-		ip              = newi;
-	    }
-	}
+                newd->next = dp;
+                dp = newd;
+            }
+            else {
+                /* DAV_LOCKREC_INDIRECT(_PARTIAL) */
+
+                dav_lock_indirect *newi = apr_pcalloc(p, sizeof(*newi));
+
+                /* ### shut off the const warning for now */
+                newi->locktoken = (dav_locktoken *)lock->locktoken;
+                newi->key       = lock->info->key;
+                newi->next      = ip;
+                ip              = newi;
+            }
+        }
     }
 
     if ((err = dav_fs_save_lock_record(lockdb, key, dp, ip)) != NULL) {
-	/* ### maybe add a higher-level description */
-	return err;
+        /* ### maybe add a higher-level description */
+        return err;
     }
 
     /* we have a special list for recording locknull resources */
     /* ### ack! this can add two copies to the locknull list */
     if (!resource->exists
-	&& (err = dav_fs_add_locknull_state(lockdb, resource)) != NULL) {
-	/* ### maybe add a higher-level description */
-	return err;
+        && (err = dav_fs_add_locknull_state(lockdb, resource)) != NULL) {
+        /* ### maybe add a higher-level description */
+        return err;
     }
 
     return NULL;
 }
 
 static dav_error * dav_fs_remove_lock(dav_lockdb *lockdb,
-				      const dav_resource *resource,
-				      const dav_locktoken *locktoken)
+                                      const dav_resource *resource,
+                                      const dav_locktoken *locktoken)
 {
     dav_error *err;
     dav_buffer buf = { 0 };
@@ -1329,36 +1329,36 @@ static dav_error * dav_fs_remove_lock(dav_lockdb *lockdb,
     key = dav_fs_build_key(lockdb->info->pool, resource);
 
     if (locktoken != NULL) {
-	dav_lock_discovery *dp;
-	dav_lock_discovery *dprev = NULL;
-	dav_lock_indirect *ip;
-	dav_lock_indirect *iprev = NULL;
-
-	if ((err = dav_fs_load_lock_record(lockdb, key, DAV_CREATE_LIST,
-					   &dh, &ih)) != NULL) {
-	    /* ### maybe add a higher-level description */
-	    return err;
-	}
-
-	for (dp = dh; dp != NULL; dp = dp->next) {
-	    if (dav_compare_locktoken(locktoken, dp->locktoken) == 0) {
-		if (dprev)
-		    dprev->next = dp->next;
-		else
-		    dh = dh->next;
-	    }
-	    dprev = dp;
-	}
-
-	for (ip = ih; ip != NULL; ip = ip->next) {
-	    if (dav_compare_locktoken(locktoken, ip->locktoken) == 0) {
-		if (iprev)
-		    iprev->next = ip->next;
-		else
-		    ih = ih->next;
-	    }
-	    iprev = ip;
-	}
+        dav_lock_discovery *dp;
+        dav_lock_discovery *dprev = NULL;
+        dav_lock_indirect *ip;
+        dav_lock_indirect *iprev = NULL;
+
+        if ((err = dav_fs_load_lock_record(lockdb, key, DAV_CREATE_LIST,
+                                           &dh, &ih)) != NULL) {
+            /* ### maybe add a higher-level description */
+            return err;
+        }
+
+        for (dp = dh; dp != NULL; dp = dp->next) {
+            if (dav_compare_locktoken(locktoken, dp->locktoken) == 0) {
+                if (dprev)
+                    dprev->next = dp->next;
+                else
+                    dh = dh->next;
+            }
+            dprev = dp;
+        }
+
+        for (ip = ih; ip != NULL; ip = ip->next) {
+            if (dav_compare_locktoken(locktoken, ip->locktoken) == 0) {
+                if (iprev)
+                    iprev->next = ip->next;
+                else
+                    ih = ih->next;
+            }
+            iprev = ip;
+        }
 
     }
 
@@ -1379,38 +1379,38 @@ static dav_error * dav_fs_remove_lock(dav_lockdb *lockdb,
     **       any because a precondition is that none exist).
     */
     if (!resource->exists && dh == NULL && ih == NULL
-	&& (err = dav_fs_remove_locknull_member(lockdb->info->pool,
-						dav_fs_pathname(resource),
-						&buf)) != NULL) {
-	/* ### maybe add a higher-level description */
-	return err;
+        && (err = dav_fs_remove_locknull_member(lockdb->info->pool,
+                                                dav_fs_pathname(resource),
+                                                &buf)) != NULL) {
+        /* ### maybe add a higher-level description */
+        return err;
     }
 
     return NULL;
 }
 
 static int dav_fs_do_refresh(dav_lock_discovery *dp,
-			     const dav_locktoken_list *ltl,
-			     time_t new_time)
+                             const dav_locktoken_list *ltl,
+                             time_t new_time)
 {
     int dirty = 0;
 
     for (; ltl != NULL; ltl = ltl->next) {
-	if (dav_compare_locktoken(dp->locktoken, ltl->locktoken) == 0)
-	{
-	    dp->f.timeout = new_time;
-	    dirty = 1;
-	}
+        if (dav_compare_locktoken(dp->locktoken, ltl->locktoken) == 0)
+        {
+            dp->f.timeout = new_time;
+            dirty = 1;
+        }
     }
 
     return dirty;
 }
 
 static dav_error * dav_fs_refresh_locks(dav_lockdb *lockdb,
-					const dav_resource *resource,
-					const dav_locktoken_list *ltl,
-					time_t new_time,
-					dav_lock **locks)
+                                        const dav_resource *resource,
+                                        const dav_locktoken_list *ltl,
+                                        time_t new_time,
+                                        dav_lock **locks)
 {
     dav_error *err;
     apr_datum_t key;
@@ -1424,71 +1424,71 @@ static dav_error * dav_fs_refresh_locks(dav_lockdb *lockdb,
 
     key = dav_fs_build_key(lockdb->info->pool, resource);
     if ((err = dav_fs_load_lock_record(lockdb, key, DAV_CREATE_LIST,
-				       &dp, &ip)) != NULL) {
-	/* ### maybe add in a higher-level description */
-	return err;
+                                       &dp, &ip)) != NULL) {
+        /* ### maybe add in a higher-level description */
+        return err;
     }
 
     /* ### we should be refreshing direct AND (resolved) indirect locks! */
 
     /* refresh all of the direct locks on this resource */
     for (dp_scan = dp; dp_scan != NULL; dp_scan = dp_scan->next) {
-	if (dav_fs_do_refresh(dp_scan, ltl, new_time)) {
-	    /* the lock was refreshed. return the lock. */
-	    newlock = dav_fs_alloc_lock(lockdb, key, dp_scan->locktoken);
-	    newlock->is_locknull = !resource->exists;
-	    newlock->scope = dp_scan->f.scope;
-	    newlock->type = dp_scan->f.type;
-	    newlock->depth = dp_scan->f.depth;
-	    newlock->timeout = dp_scan->f.timeout;
-	    newlock->owner = dp_scan->owner;
+        if (dav_fs_do_refresh(dp_scan, ltl, new_time)) {
+            /* the lock was refreshed. return the lock. */
+            newlock = dav_fs_alloc_lock(lockdb, key, dp_scan->locktoken);
+            newlock->is_locknull = !resource->exists;
+            newlock->scope = dp_scan->f.scope;
+            newlock->type = dp_scan->f.type;
+            newlock->depth = dp_scan->f.depth;
+            newlock->timeout = dp_scan->f.timeout;
+            newlock->owner = dp_scan->owner;
             newlock->auth_user = dp_scan->auth_user;
 
-	    newlock->next = *locks;
-	    *locks = newlock;
+            newlock->next = *locks;
+            *locks = newlock;
 
-	    dirty = 1;
-	}
+            dirty = 1;
+        }
     }
 
     /* if we refreshed any locks, then save them back. */
     if (dirty
-	&& (err = dav_fs_save_lock_record(lockdb, key, dp, ip)) != NULL) {
-	/* ### maybe add in a higher-level description */
-	return err;
+        && (err = dav_fs_save_lock_record(lockdb, key, dp, ip)) != NULL) {
+        /* ### maybe add in a higher-level description */
+        return err;
     }
 
     /* for each indirect lock, find its direct lock and refresh it. */
     for (; ip != NULL; ip = ip->next) {
-	dav_lock_discovery *ref_dp;
-	dav_lock_indirect *ref_ip;
-
-	if ((err = dav_fs_resolve(lockdb, ip, &dp_scan,
-				  &ref_dp, &ref_ip)) != NULL) {
-	    /* ### push a higher-level desc? */
-	    return err;
-	}
-	if (dav_fs_do_refresh(dp_scan, ltl, new_time)) {
-	    /* the lock was refreshed. return the lock. */
-	    newlock = dav_fs_alloc_lock(lockdb, ip->key, dp_scan->locktoken);
-	    newlock->is_locknull = !resource->exists;
-	    newlock->scope = dp_scan->f.scope;
-	    newlock->type = dp_scan->f.type;
-	    newlock->depth = dp_scan->f.depth;
-	    newlock->timeout = dp_scan->f.timeout;
-	    newlock->owner = dp_scan->owner;
+        dav_lock_discovery *ref_dp;
+        dav_lock_indirect *ref_ip;
+
+        if ((err = dav_fs_resolve(lockdb, ip, &dp_scan,
+                                  &ref_dp, &ref_ip)) != NULL) {
+            /* ### push a higher-level desc? */
+            return err;
+        }
+        if (dav_fs_do_refresh(dp_scan, ltl, new_time)) {
+            /* the lock was refreshed. return the lock. */
+            newlock = dav_fs_alloc_lock(lockdb, ip->key, dp_scan->locktoken);
+            newlock->is_locknull = !resource->exists;
+            newlock->scope = dp_scan->f.scope;
+            newlock->type = dp_scan->f.type;
+            newlock->depth = dp_scan->f.depth;
+            newlock->timeout = dp_scan->f.timeout;
+            newlock->owner = dp_scan->owner;
             newlock->auth_user = dp_scan->auth_user;
 
-	    newlock->next = *locks;
-	    *locks = newlock;
+            newlock->next = *locks;
+            *locks = newlock;
 
-	    /* save the (resolved) direct lock back */
-	    if ((err = dav_fs_save_lock_record(lockdb, ip->key, ref_dp,
-					       ref_ip)) != NULL) {
-		/* ### push a higher-level desc? */
-		return err;
-	    }
-	}
+            /* save the (resolved) direct lock back */
+            if ((err = dav_fs_save_lock_record(lockdb, ip->key, ref_dp,
+                                               ref_ip)) != NULL) {
+                /* ### push a higher-level desc? */
+                return err;
+            }
+        }
     }
 
     return NULL;
diff --git a/modules/dav/main/liveprop.c b/modules/dav/main/liveprop.c
index 95c22c1..15c72cb 100644
--- a/modules/dav/main/liveprop.c
+++ b/modules/dav/main/liveprop.c
@@ -93,15 +93,15 @@ DAV_DECLARE(int) dav_do_find_liveprop(const char *ns_uri, const char *name,
         if (strcmp(ns_uri, uris[ns]) == 0)
             break;
     if (uris[ns] == NULL) {
-	/* not our property (the namespace matched none of ours) */
-	return 0;
+        /* not our property (the namespace matched none of ours) */
+        return 0;
     }
 
     /* second: look for the property in the liveprop specs */
     for (scan = group->specs; scan->name != NULL; ++scan)
-	if (ns == scan->ns && strcmp(name, scan->name) == 0) {
+        if (ns == scan->ns && strcmp(name, scan->name) == 0) {
             *hooks = group->hooks;
-	    return scan->propid;
+            return scan->propid;
         }
 
     /* not our property (same namespace, but no matching prop name) */
diff --git a/modules/debug/mod_dumpio.c b/modules/debug/mod_dumpio.c
index fc505ef..997b701 100644
--- a/modules/debug/mod_dumpio.c
+++ b/modules/debug/mod_dumpio.c
@@ -49,7 +49,7 @@ static void dumpit(ap_filter_t *f, apr_bucket *b)
     conn_rec *c = f->c;
     
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, c->base_server,
-	"mod_dumpio:  %s (%s-%s): %" APR_SIZE_T_FMT " bytes",
+        "mod_dumpio:  %s (%s-%s): %" APR_SIZE_T_FMT " bytes",
                 f->frec->name,
                 (APR_BUCKET_IS_METADATA(b)) ? "metadata" : "data",
                 b->type->name,
@@ -101,9 +101,9 @@ static int dumpio_input_filter (ap_filter_t *f, apr_bucket_brigade *bb,
     conn_rec *c = f->c;
 
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, c->base_server,
-	"mod_dumpio: %s [%s-%s] %" APR_OFF_T_FMT " readbytes",
+        "mod_dumpio: %s [%s-%s] %" APR_OFF_T_FMT " readbytes",
          f->frec->name,
-	 whichmode(mode),
+         whichmode(mode),
          ((block) == APR_BLOCK_READ) ? "blocking" : "nonblocking",
          readbytes) ;
 
@@ -115,7 +115,7 @@ static int dumpio_input_filter (ap_filter_t *f, apr_bucket_brigade *bb,
         }
     } else {
         ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, c->base_server,
-	"mod_dumpio: %s - %d", f->frec->name, ret) ;
+        "mod_dumpio: %s - %d", f->frec->name, ret) ;
     }
 
     return APR_SUCCESS ;
@@ -161,10 +161,10 @@ static void dumpio_register_hooks(apr_pool_t *p)
  * We know that SSL is CONNECTION + 5
  */
   ap_register_output_filter("DUMPIO_OUT", dumpio_output_filter,
-	NULL, AP_FTYPE_CONNECTION + 3) ;
+        NULL, AP_FTYPE_CONNECTION + 3) ;
 
   ap_register_input_filter("DUMPIO_IN", dumpio_input_filter,
-	NULL, AP_FTYPE_CONNECTION + 3) ;
+        NULL, AP_FTYPE_CONNECTION + 3) ;
 
   ap_hook_pre_connection(dumpio_pre_conn, NULL, NULL, APR_HOOK_MIDDLE);
 }
@@ -205,11 +205,11 @@ static const command_rec dumpio_cmds[] = {
 };
 
 module AP_MODULE_DECLARE_DATA dumpio_module = {
-	STANDARD20_MODULE_STUFF,
-	NULL,
-	NULL,
-	dumpio_create_sconfig,
-	NULL,
-	dumpio_cmds,
-	dumpio_register_hooks
+        STANDARD20_MODULE_STUFF,
+        NULL,
+        NULL,
+        dumpio_create_sconfig,
+        NULL,
+        dumpio_cmds,
+        dumpio_register_hooks
 };
diff --git a/modules/experimental/mod_case_filter.c b/modules/experimental/mod_case_filter.c
index 8a3b084..0c3938b 100644
--- a/modules/experimental/mod_case_filter.c
+++ b/modules/experimental/mod_case_filter.c
@@ -44,16 +44,16 @@ static void *CaseFilterCreateServerConfig(apr_pool_t *p,server_rec *s)
 static void CaseFilterInsertFilter(request_rec *r)
     {
     CaseFilterConfig *pConfig=ap_get_module_config(r->server->module_config,
-						   &case_filter_module);
+                                                   &case_filter_module);
 
     if(!pConfig->bEnabled)
-	return;
+        return;
 
     ap_add_output_filter(s_szCaseFilterName,NULL,r,r->connection);
     }
 
 static apr_status_t CaseFilterOutFilter(ap_filter_t *f,
-					apr_bucket_brigade *pbbIn)
+                                        apr_bucket_brigade *pbbIn)
     {
     request_rec *r = f->r;
     conn_rec *c = r->connection;
@@ -65,31 +65,31 @@ static apr_status_t CaseFilterOutFilter(ap_filter_t *f,
          pbktIn != APR_BRIGADE_SENTINEL(pbbIn);
          pbktIn = APR_BUCKET_NEXT(pbktIn))
     {
-	const char *data;
-	apr_size_t len;
-	char *buf;
-	apr_size_t n;
-	apr_bucket *pbktOut;
-
-	if(APR_BUCKET_IS_EOS(pbktIn))
-	    {
-	    apr_bucket *pbktEOS=apr_bucket_eos_create(c->bucket_alloc);
-	    APR_BRIGADE_INSERT_TAIL(pbbOut,pbktEOS);
-	    continue;
-	    }
-
-	/* read */
-	apr_bucket_read(pbktIn,&data,&len,APR_BLOCK_READ);
-
-	/* write */
-	buf = apr_bucket_alloc(len, c->bucket_alloc);
-	for(n=0 ; n < len ; ++n)
-	    buf[n] = apr_toupper(data[n]);
-
-	pbktOut = apr_bucket_heap_create(buf, len, apr_bucket_free,
-	                                 c->bucket_alloc);
-	APR_BRIGADE_INSERT_TAIL(pbbOut,pbktOut);
-	}
+        const char *data;
+        apr_size_t len;
+        char *buf;
+        apr_size_t n;
+        apr_bucket *pbktOut;
+
+        if(APR_BUCKET_IS_EOS(pbktIn))
+            {
+            apr_bucket *pbktEOS=apr_bucket_eos_create(c->bucket_alloc);
+            APR_BRIGADE_INSERT_TAIL(pbbOut,pbktEOS);
+            continue;
+            }
+
+        /* read */
+        apr_bucket_read(pbktIn,&data,&len,APR_BLOCK_READ);
+
+        /* write */
+        buf = apr_bucket_alloc(len, c->bucket_alloc);
+        for(n=0 ; n < len ; ++n)
+            buf[n] = apr_toupper(data[n]);
+
+        pbktOut = apr_bucket_heap_create(buf, len, apr_bucket_free,
+                                         c->bucket_alloc);
+        APR_BRIGADE_INSERT_TAIL(pbbOut,pbktOut);
+        }
 
     /* XXX: is there any advantage to passing a brigade for each bucket? */
     return ap_pass_brigade(f->next,pbbOut);
@@ -98,7 +98,7 @@ static apr_status_t CaseFilterOutFilter(ap_filter_t *f,
 static const char *CaseFilterEnable(cmd_parms *cmd, void *dummy, int arg)
     {
     CaseFilterConfig *pConfig=ap_get_module_config(cmd->server->module_config,
-						   &case_filter_module);
+                                                   &case_filter_module);
     pConfig->bEnabled=arg;
 
     return NULL;
@@ -115,7 +115,7 @@ static void CaseFilterRegisterHooks(apr_pool_t *p)
     {
     ap_hook_insert_filter(CaseFilterInsertFilter,NULL,NULL,APR_HOOK_MIDDLE);
     ap_register_output_filter(s_szCaseFilterName,CaseFilterOutFilter,NULL,
-			      AP_FTYPE_RESOURCE);
+                              AP_FTYPE_RESOURCE);
     }
 
 module AP_MODULE_DECLARE_DATA case_filter_module =
diff --git a/modules/experimental/mod_example.c b/modules/experimental/mod_example.c
index 507c525..eab1ebd 100644
--- a/modules/experimental/mod_example.c
+++ b/modules/experimental/mod_example.c
@@ -546,7 +546,7 @@ static int x_handler(request_rec *r)
     ap_rputs("  </H1>\n", r);
     ap_rputs("  <P>\n", r);
     ap_rprintf(r, "  Apache HTTP Server version: \"%s\"\n",
-	    ap_get_server_version());
+            ap_get_server_version());
     ap_rputs("  <BR>\n", r);
     ap_rprintf(r, "  Server built: \"%s\"\n", ap_get_server_built());
     ap_rputs("  </P>\n", r);;
diff --git a/modules/filters/mod_charset_lite.c b/modules/filters/mod_charset_lite.c
index 66b8ef0..e2a2560 100644
--- a/modules/filters/mod_charset_lite.c
+++ b/modules/filters/mod_charset_lite.c
@@ -861,7 +861,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
                               "can't open translation %s->%s",
                               dc->charset_source, dc->charset_default);
                 ctx->noop = 1;
-	    }
+            }
         }
         else {
                 ctx->noop = 1;
diff --git a/modules/generators/mod_asis.c b/modules/generators/mod_asis.c
index 4887d43..b32338e 100644
--- a/modules/generators/mod_asis.c
+++ b/modules/generators/mod_asis.c
@@ -36,43 +36,43 @@ static int asis_handler(request_rec *r)
     const char *location;
 
     if(strcmp(r->handler,ASIS_MAGIC_TYPE) && strcmp(r->handler,"send-as-is"))
-	return DECLINED;
+        return DECLINED;
 
     r->allowed |= (AP_METHOD_BIT << M_GET);
     if (r->method_number != M_GET)
-	return DECLINED;
+        return DECLINED;
     if (r->finfo.filetype == 0) {
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-		    "File does not exist: %s", r->filename);
-	return HTTP_NOT_FOUND;
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    "File does not exist: %s", r->filename);
+        return HTTP_NOT_FOUND;
     }
 
     if ((rv = apr_file_open(&f, r->filename, APR_READ, 
                 APR_OS_DEFAULT, r->pool)) != APR_SUCCESS) {
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
-		    "file permissions deny server access: %s", r->filename);
-	return HTTP_FORBIDDEN;
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    "file permissions deny server access: %s", r->filename);
+        return HTTP_FORBIDDEN;
     }
 
     ap_scan_script_header_err(r, f, NULL);
     location = apr_table_get(r->headers_out, "Location");
 
     if (location && location[0] == '/' &&
-	((r->status == HTTP_OK) || ap_is_HTTP_REDIRECT(r->status))) {
+        ((r->status == HTTP_OK) || ap_is_HTTP_REDIRECT(r->status))) {
 
-	apr_file_close(f);
+        apr_file_close(f);
 
-	/* Internal redirect -- fake-up a pseudo-request */
-	r->status = HTTP_OK;
+        /* Internal redirect -- fake-up a pseudo-request */
+        r->status = HTTP_OK;
 
-	/* This redirect needs to be a GET no matter what the original
-	 * method was.
-	 */
-	r->method = apr_pstrdup(r->pool, "GET");
-	r->method_number = M_GET;
+        /* This redirect needs to be a GET no matter what the original
+         * method was.
+         */
+        r->method = apr_pstrdup(r->pool, "GET");
+        r->method_number = M_GET;
 
-	ap_internal_redirect_handler(location, r);
-	return OK;
+        ap_internal_redirect_handler(location, r);
+        return OK;
     }
 
     if (!r->header_only) {
diff --git a/modules/generators/mod_cgid.c b/modules/generators/mod_cgid.c
index d16fbd7..89a6129 100644
--- a/modules/generators/mod_cgid.c
+++ b/modules/generators/mod_cgid.c
@@ -635,8 +635,8 @@ static int cgid_server(void *data)
 #if defined(ENETDOWN)
             if (errno == ENETDOWN) {
                 /* The network has been shut down, no need to continue. Die gracefully */
-		++daemon_should_exit;
-	    }
+                ++daemon_should_exit;
+            }
 #endif
             if (errno != EINTR) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, errno, 
diff --git a/modules/http/http_core.c b/modules/http/http_core.c
index be18ec4..6b4c9e6 100644
--- a/modules/http/http_core.c
+++ b/modules/http/http_core.c
@@ -42,7 +42,7 @@ AP_DECLARE_DATA ap_filter_rec_t *ap_chunk_filter_handle;
 AP_DECLARE_DATA ap_filter_rec_t *ap_byterange_filter_handle;
 
 static const char *set_keep_alive_timeout(cmd_parms *cmd, void *dummy,
-					  const char *arg)
+                                          const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
     if (err != NULL) {
@@ -54,7 +54,7 @@ static const char *set_keep_alive_timeout(cmd_parms *cmd, void *dummy,
 }
 
 static const char *set_keep_alive(cmd_parms *cmd, void *dummy,
-				  const char *arg) 
+                                  const char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
     if (err != NULL) {
@@ -65,16 +65,16 @@ static const char *set_keep_alive(cmd_parms *cmd, void *dummy,
      * so we accept anything but "Off" or "0" as "On"
      */
     if (!strcasecmp(arg, "off") || !strcmp(arg, "0")) {
-	cmd->server->keep_alive = 0;
+        cmd->server->keep_alive = 0;
     }
     else {
-	cmd->server->keep_alive = 1;
+        cmd->server->keep_alive = 1;
     }
     return NULL;
 }
 
 static const char *set_keep_alive_max(cmd_parms *cmd, void *dummy,
-				      const char *arg)
+                                      const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
     if (err != NULL) {
diff --git a/modules/http/http_filters.c b/modules/http/http_filters.c
index f94d931..88e1802 100644
--- a/modules/http/http_filters.c
+++ b/modules/http/http_filters.c
@@ -782,7 +782,7 @@ AP_DECLARE_NONSTD(int) ap_send_http_trace(request_rec *r)
                                                       &core_module);
 
     if (conf->trace_enable == AP_TRACE_DISABLE) {
-	apr_table_setn(r->notes, "error-notes",
+        apr_table_setn(r->notes, "error-notes",
                       "TRACE denied by server configuration");
         return HTTP_FORBIDDEN;
     }
@@ -804,7 +804,7 @@ AP_DECLARE_NONSTD(int) ap_send_http_trace(request_rec *r)
 
         if (r->remaining > 0) {
             if (r->remaining > 65536) {
-	        apr_table_setn(r->notes, "error-notes",
+                apr_table_setn(r->notes, "error-notes",
                        "Extended TRACE request bodies cannot exceed 64k\n");
                 return HTTP_REQUEST_ENTITY_TOO_LARGE;
             }
@@ -829,7 +829,7 @@ AP_DECLARE_NONSTD(int) ap_send_http_trace(request_rec *r)
             /* discard_rest_of_request_body into our buffer */
             while (ap_get_client_block(r, bodyread, bodylen) > 0)
                 ;
-	    apr_table_setn(r->notes, "error-notes",
+            apr_table_setn(r->notes, "error-notes",
                    "Extended TRACE request bodies cannot exceed 64k\n");
             return HTTP_REQUEST_ENTITY_TOO_LARGE;
         }
diff --git a/modules/ldap/util_ldap.c b/modules/ldap/util_ldap.c
index 6ac7f6d..3bc2906 100644
--- a/modules/ldap/util_ldap.c
+++ b/modules/ldap/util_ldap.c
@@ -309,15 +309,15 @@ static int uldap_connection_open(request_rec *r,
             result->rc = ldapssl_set_verify_mode(LDAPSSL_VERIFY_NONE);
         }
 #elif defined(LDAP_OPT_X_TLS_REQUIRE_CERT)
-		/* This is not a per-connection setting so just pass NULL for the
-		   Ldap connection handle */
+                /* This is not a per-connection setting so just pass NULL for the
+                   Ldap connection handle */
         if (st->verify_svr_cert) {
-			int i = LDAP_OPT_X_TLS_DEMAND;
-			result->rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_REQUIRE_CERT, &i);
+                        int i = LDAP_OPT_X_TLS_DEMAND;
+                        result->rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_REQUIRE_CERT, &i);
         }
         else {
-			int i = LDAP_OPT_X_TLS_NEVER;
-			result->rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_REQUIRE_CERT, &i);
+                        int i = LDAP_OPT_X_TLS_NEVER;
+                        result->rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_REQUIRE_CERT, &i);
         }
 #endif
 #endif
@@ -635,20 +635,20 @@ static int uldap_cache_comparedn(request_rec *r, util_ldap_connection_t *ldc,
 
 start_over:
     if (failures++ > 10) {
-	/* too many failures */
+        /* too many failures */
         return result;
     }
 
     /* make a server connection */
     if (LDAP_SUCCESS != (result = uldap_connection_open(r, ldc))) {
-	/* connect to server failed */
+        /* connect to server failed */
         return result;
     }
 
     /* search for reqdn */
     if ((result = ldap_search_ext_s(ldc->ldap, (char *)reqdn, LDAP_SCOPE_BASE,
-				    "(objectclass=*)", NULL, 1, 
-				    NULL, NULL, NULL, -1, &res)) 
+                                    "(objectclass=*)", NULL, 1, 
+                                    NULL, NULL, NULL, -1, &res)) 
             == LDAP_SERVER_DOWN) 
     {
         ldc->reason = "DN Comparison ldap_search_ext_s() "
@@ -924,9 +924,9 @@ start_over:
 
     /* try do the search */
     if ((result = ldap_search_ext_s(ldc->ldap,
-				    (char *)basedn, scope, 
-				    (char *)filter, attrs, 0, 
-				    NULL, NULL, NULL, -1, &res)) 
+                                    (char *)basedn, scope, 
+                                    (char *)filter, attrs, 0, 
+                                    NULL, NULL, NULL, -1, &res)) 
             == LDAP_SERVER_DOWN) 
     {
         ldc->reason = "ldap_search_ext_s() for user failed with server down";
@@ -1164,9 +1164,9 @@ start_over:
 
     /* try do the search */
     if ((result = ldap_search_ext_s(ldc->ldap,
-				    (char *)basedn, scope,
+                                    (char *)basedn, scope,
                                     (char *)filter, attrs, 0, 
-				    NULL, NULL, NULL, -1, &res)) 
+                                    NULL, NULL, NULL, -1, &res)) 
             == LDAP_SERVER_DOWN) 
     {
         ldc->reason = "ldap_search_ext_s() for user failed with server down";
@@ -1295,7 +1295,7 @@ static const char *util_ldap_set_cache_bytes(cmd_parms *cmd, void *dummy,
 {
     util_ldap_state_t *st = 
         (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
-						  &ldap_module);
+                                                  &ldap_module);
 
     st->cache_bytes = atol(bytes);
 
@@ -1333,7 +1333,7 @@ static const char *util_ldap_set_cache_ttl(cmd_parms *cmd, void *dummy,
 {
     util_ldap_state_t *st = 
         (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
-						  &ldap_module);
+                                                  &ldap_module);
 
     st->search_cache_ttl = atol(ttl) * 1000000;
 
@@ -1349,7 +1349,7 @@ static const char *util_ldap_set_cache_entries(cmd_parms *cmd, void *dummy,
 {
     util_ldap_state_t *st = 
         (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
-						  &ldap_module);
+                                                  &ldap_module);
 
 
     st->search_cache_size = atol(size);
@@ -1369,7 +1369,7 @@ static const char *util_ldap_set_opcache_ttl(cmd_parms *cmd, void *dummy,
 {
     util_ldap_state_t *st = 
         (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
-						  &ldap_module);
+                                                  &ldap_module);
 
     st->compare_cache_ttl = atol(ttl) * 1000000;
 
@@ -1385,7 +1385,7 @@ static const char *util_ldap_set_opcache_entries(cmd_parms *cmd, void *dummy,
 {
     util_ldap_state_t *st = 
         (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
-						  &ldap_module);
+                                                  &ldap_module);
 
     st->compare_cache_size = atol(size);
     if (st->compare_cache_size < 0) {
@@ -1699,7 +1699,7 @@ static const char *util_ldap_set_connection_timeout(cmd_parms *cmd,
 {
     util_ldap_state_t *st = 
         (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
-						  &ldap_module);
+                                                  &ldap_module);
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
 
     if (err != NULL) {
diff --git a/modules/ldap/util_ldap_cache.c b/modules/ldap/util_ldap_cache.c
index 904d172..c717904 100644
--- a/modules/ldap/util_ldap_cache.c
+++ b/modules/ldap/util_ldap_cache.c
@@ -247,8 +247,8 @@ int util_ldap_compare_node_compare(void *a, void *b)
     util_compare_node_t *nb = b;
 
     return (strcmp(na->dn, nb->dn) == 0 &&
-	    strcmp(na->attrib, nb->attrib) == 0 &&
-	    strcmp(na->value, nb->value) == 0);
+            strcmp(na->attrib, nb->attrib) == 0 &&
+            strcmp(na->value, nb->value) == 0);
 }
 
 void *util_ldap_compare_node_copy(util_ald_cache_t *cache, void *c)
diff --git a/modules/mappers/mod_actions.c b/modules/mappers/mod_actions.c
index 473a968..6c934ee 100644
--- a/modules/mappers/mod_actions.c
+++ b/modules/mappers/mod_actions.c
@@ -78,7 +78,7 @@ static void *merge_action_dir_configs(apr_pool_t *p, void *basev, void *addv)
     int i;
 
     new->action_types = apr_table_overlay(p, add->action_types,
-				       base->action_types);
+                                       base->action_types);
 
     for (i = 0; i < METHODS; ++i) {
         new->scripted[i] = add->scripted[i] ? add->scripted[i]
@@ -173,7 +173,7 @@ static int action_handler(request_rec *r)
 
     /* Check for looping, which can happen if the CGI script isn't */
     if (script && r->prev && r->prev->prev)
-	return DECLINED;
+        return DECLINED;
 
     /* Second, check for actions (which override the method scripts) */
     action = r->handler ? r->handler :
@@ -195,7 +195,7 @@ static int action_handler(request_rec *r)
     }
 
     if (script == NULL)
-	return DECLINED;
+        return DECLINED;
 
     ap_internal_redirect_handler(apr_pstrcat(r->pool, script,
                                              ap_escape_uri(r->pool, r->uri),
diff --git a/modules/mappers/mod_imagemap.c b/modules/mappers/mod_imagemap.c
index eada55e..90ec579 100644
--- a/modules/mappers/mod_imagemap.c
+++ b/modules/mappers/mod_imagemap.c
@@ -181,8 +181,8 @@ static int pointinpoly(const double point[2], double pgon[MAXVERTS][2])
     double x = point[X], y = point[Y];
 
     for (numverts = 0; pgon[numverts][X] != -1 && numverts < MAXVERTS;
-	numverts++) {
-	/* just counting the vertexes */
+        numverts++) {
+        /* just counting the vertexes */
     }
 
     for (i = 0; i < numverts; i++) {
@@ -193,12 +193,12 @@ static int pointinpoly(const double point[2], double pgon[MAXVERTS][2])
         double d=(y - y1) * (x2 - x1) - (x - x1) * (y2 - y1);
 
         if ((y1 >= y) != (y2 >= y)) {
-	    crossings +=y2 - y1 >= 0 ? d >= 0 : d <= 0;
-	}
+            crossings +=y2 - y1 >= 0 ? d >= 0 : d <= 0;
+        }
         if (!d && fmin(x1,x2) <= x && x <= fmax(x1,x2)
-	    && fmin(y1,y2) <= y && y <= fmax(y1,y2)) {
-	    return 1;
-	}
+            && fmin(y1,y2) <= y && y <= fmax(y1,y2)) {
+            return 1;
+        }
     }
     return crossings & 0x01;
 }
@@ -270,13 +270,13 @@ static double get_y_coord(const char *args)
         while (*start_of_y && !apr_isdigit(*start_of_y)) {
             start_of_y++;       /* jump to the first digit, but not
                                    past the end */
-	}
+        }
 
         y_coord = strtod(start_of_y, &endptr);
 
         if (endptr > start_of_y) {
             return (y_coord);
-	}
+        }
     }
 
     return (-1);                /* if no conversion was made, or
@@ -304,16 +304,16 @@ static void read_quoted(char **string, char **quoted_part)
 
     if (*strp == '"') {       	/* if that character is a double quote */
         strp++;               	/* step over it */
-	*quoted_part = strp;  	/* note where the quoted part begins */
+        *quoted_part = strp;  	/* note where the quoted part begins */
 
         while (*strp && *strp != '"') {
-	    ++strp;		/* skip the quoted portion */
+            ++strp;		/* skip the quoted portion */
         }
 
         *strp = '\0';    	/* end the string with a NUL */
 
         strp++;               	/* step over the last double quote */
-	*string = strp;
+        *string = strp;
     }
 }
 
@@ -331,7 +331,7 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
     char *my_base;
 
     if (!strcasecmp(value, "map") || !strcasecmp(value, "menu")) {
-	return ap_construct_url(r->pool, r->uri, r);
+        return ap_construct_url(r->pool, r->uri, r);
     }
 
     if (!strcasecmp(value, "nocontent") || !strcasecmp(value, "error")) {
@@ -342,11 +342,11 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
     if (!strcasecmp(value, "referer")) {
         referer = apr_table_get(r->headers_in, "Referer");
         if (referer && *referer) {
-	    return apr_pstrdup(r->pool, referer);
+            return apr_pstrdup(r->pool, referer);
         }
         else {
-	    /* XXX:  This used to do *value = '\0'; ... which is totally bogus
-	     * because it hammers the passed in value, which can be a string
+            /* XXX:  This used to do *value = '\0'; ... which is totally bogus
+             * because it hammers the passed in value, which can be a string
              * constant, or part of a config, or whatever.  Total garbage.
              * This works around that without changing the rest of this
              * code much
@@ -358,21 +358,21 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
 
     string_pos_const = value;
     while (apr_isalpha(*string_pos_const)) {
-	string_pos_const++;           /* go along the URL from the map
+        string_pos_const++;           /* go along the URL from the map
                                          until a non-letter */
     }
     if (*string_pos_const == ':') {
-	/* if letters and then a colon (like http:) */
-	/* it's an absolute URL, so use it! */
-	return apr_pstrdup(r->pool, value);
+        /* if letters and then a colon (like http:) */
+        /* it's an absolute URL, so use it! */
+        return apr_pstrdup(r->pool, value);
     }
 
     if (!base || !*base) {
         if (value && *value) {
-	    return apr_pstrdup(r->pool, value); /* no base: use what is given */
+            return apr_pstrdup(r->pool, value); /* no base: use what is given */
         }
-	/* no base, no value: pick a simple default */
-	return ap_construct_url(r->pool, "/", r);
+        /* no base, no value: pick a simple default */
+        return ap_construct_url(r->pool, "/", r);
     }
 
     /* must be a relative URL to be combined with base */
@@ -427,11 +427,11 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
 
                 if ((string_pos = strrchr(directory, '/'))) {
                     *string_pos = '\0';
-		}
+                }
                 clen = strlen(directory);
                 if (clen == 0) {
                     break;
-		}
+                }
             }
 
             value += 2;         /* jump over the '..' that we found in the
@@ -448,13 +448,13 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
                                    to do.  This way, we leave the starting
                                    '/' on value after the last '..', but get
                                    rid of it otherwise */
-	}
+        }
 
     }                           /* by this point, value does not start
                                    with '..' */
 
     if (value && *value) {
-	return apr_pstrcat(r->pool, my_base, value, NULL);
+        return apr_pstrcat(r->pool, my_base, value, NULL);
     }
     return my_base;
 }
@@ -609,12 +609,12 @@ static int imap_handler_internal(request_rec *r)
     base = imap_url(r, NULL, imap_base);         /* set base according
                                                     to default */
     if (!base) {
-	return HTTP_INTERNAL_SERVER_ERROR;
+        return HTTP_INTERNAL_SERVER_ERROR;
     }
     mapdflt = imap_url(r, NULL, imap_default);   /* and default to
                                                     global default */
     if (!mapdflt) {
-	return HTTP_INTERNAL_SERVER_ERROR;
+        return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     testpoint[X] = get_x_coord(r->args);
@@ -629,7 +629,7 @@ static int imap_handler_internal(request_rec *r)
         if (strncasecmp(imap_menu, "none", 2)) {
             showmenu = 1;       /* show the menu _unless_ ImapMenu is
                                    'none' or 'no' */
-	}
+        }
     }
 
     if (showmenu) {             /* send start of imagemap menu if
@@ -653,51 +653,51 @@ static int imap_handler_internal(request_rec *r)
         }                       /* blank lines and comments are ignored
                                    if we aren't printing a menu */
 
-	/* find the first two space delimited fields, recall that
-	 * ap_cfg_getline has removed leading/trailing whitespace.
-	 *
-	 * note that we're tokenizing as we go... if we were to use the
-	 * ap_getword() class of functions we would end up allocating extra
-	 * memory for every line of the map file
-	 */
+        /* find the first two space delimited fields, recall that
+         * ap_cfg_getline has removed leading/trailing whitespace.
+         *
+         * note that we're tokenizing as we go... if we were to use the
+         * ap_getword() class of functions we would end up allocating extra
+         * memory for every line of the map file
+         */
         string_pos = input;
-	if (!*string_pos) {		/* need at least two fields */
-	    goto need_2_fields;
-	}
-
-	directive = string_pos;
-	while (*string_pos && !apr_isspace(*string_pos)) {	/* past directive */
-	    ++string_pos;
-	}
-	if (!*string_pos) {		/* need at least two fields */
-	    goto need_2_fields;
-	}
-	*string_pos++ = '\0';
-
-	if (!*string_pos) {		/* need at least two fields */
-	    goto need_2_fields;
-	}
-	while(*string_pos && apr_isspace(*string_pos)) { /* past whitespace */
-	    ++string_pos;
-	}
-
-	value = string_pos;
-	while (*string_pos && !apr_isspace(*string_pos)) {	/* past value */
-	    ++string_pos;
-	}
-	if (apr_isspace(*string_pos)) {
-	    *string_pos++ = '\0';
-	}
-	else {
-	    /* end of input, don't advance past it */
-	    *string_pos = '\0';
-	}
+        if (!*string_pos) {		/* need at least two fields */
+            goto need_2_fields;
+        }
+
+        directive = string_pos;
+        while (*string_pos && !apr_isspace(*string_pos)) {	/* past directive */
+            ++string_pos;
+        }
+        if (!*string_pos) {		/* need at least two fields */
+            goto need_2_fields;
+        }
+        *string_pos++ = '\0';
+
+        if (!*string_pos) {		/* need at least two fields */
+            goto need_2_fields;
+        }
+        while(*string_pos && apr_isspace(*string_pos)) { /* past whitespace */
+            ++string_pos;
+        }
+
+        value = string_pos;
+        while (*string_pos && !apr_isspace(*string_pos)) {	/* past value */
+            ++string_pos;
+        }
+        if (apr_isspace(*string_pos)) {
+            *string_pos++ = '\0';
+        }
+        else {
+            /* end of input, don't advance past it */
+            *string_pos = '\0';
+        }
 
         if (!strncasecmp(directive, "base", 4)) {       /* base, base_uri */
             base = imap_url(r, NULL, value);
-	    if (!base) {
-		goto menu_bail;
-	    }
+            if (!base) {
+                goto menu_bail;
+            }
             continue;           /* base is never printed to a menu */
         }
 
@@ -705,14 +705,14 @@ static int imap_handler_internal(request_rec *r)
 
         if (!strcasecmp(directive, "default")) {        /* default */
             mapdflt = imap_url(r, NULL, value);
-	    if (!mapdflt) {
-		goto menu_bail;
-	    }
+            if (!mapdflt) {
+                goto menu_bail;
+            }
             if (showmenu) {     /* print the default if there's a menu */
                 redirect = imap_url(r, base, mapdflt);
-		if (!redirect) {
-		    goto menu_bail;
-		}
+                if (!redirect) {
+                    goto menu_bail;
+                }
                 menu_default(r, imap_menu, redirect,
                              href_text ? href_text : mapdflt);
             }
@@ -726,17 +726,17 @@ static int imap_handler_internal(request_rec *r)
             /* Now skip what we just read... we can't use ANSIism %n */
             while (apr_isspace(*string_pos)) {      /* past whitespace */
                 string_pos++;
-	    }
+            }
             while (apr_isdigit(*string_pos)) {      /* and the 1st number */
                 string_pos++;
-	    }
+            }
             string_pos++;       /* skip the ',' */
             while (apr_isspace(*string_pos)) {      /* past any more whitespace */
                 string_pos++;
-	    }
+            }
             while (apr_isdigit(*string_pos)) {      /* 2nd number */
                 string_pos++;
-	    }
+            }
             vertex++;
         }                       /* so long as there are more vertices to
                                    read, and we have room, read them in.
@@ -746,14 +746,14 @@ static int imap_handler_internal(request_rec *r)
         pointarray[vertex][X] = -1;     /* signals the end of vertices */
 
         if (showmenu) {
-	    if (!href_text) {
-		read_quoted(&string_pos, &href_text);     /* href text could
+            if (!href_text) {
+                read_quoted(&string_pos, &href_text);     /* href text could
                                                              be here instead */
-	    }
+            }
             redirect = imap_url(r, base, value);
-	    if (!redirect) {
-		goto menu_bail;
-	    }
+            if (!redirect) {
+                goto menu_bail;
+            }
             menu_directive(r, imap_menu, redirect,
                            href_text ? href_text : value);
             continue;
@@ -764,16 +764,16 @@ static int imap_handler_internal(request_rec *r)
             continue;           /* don't try the following tests if testpoints
                                    are invalid, or if there are no
                                    coordinates */
-	}
+        }
 
         if (!strcasecmp(directive, "poly")) {   /* poly */
 
             if (pointinpoly(testpoint, pointarray)) {
-		ap_cfg_closefile(imap);
+                ap_cfg_closefile(imap);
                 redirect = imap_url(r, base, value);
-		if (!redirect) {
-		    return HTTP_INTERNAL_SERVER_ERROR;
-		}
+                if (!redirect) {
+                    return HTTP_INTERNAL_SERVER_ERROR;
+                }
                 return (imap_reply(r, redirect));
             }
             continue;
@@ -782,11 +782,11 @@ static int imap_handler_internal(request_rec *r)
         if (!strcasecmp(directive, "circle")) {         /* circle */
 
             if (pointincircle(testpoint, pointarray)) {
-		ap_cfg_closefile(imap);
+                ap_cfg_closefile(imap);
                 redirect = imap_url(r, base, value);
-		if (!redirect) {
-		    return HTTP_INTERNAL_SERVER_ERROR;
-		}
+                if (!redirect) {
+                    return HTTP_INTERNAL_SERVER_ERROR;
+                }
                 return (imap_reply(r, redirect));
             }
             continue;
@@ -795,11 +795,11 @@ static int imap_handler_internal(request_rec *r)
         if (!strcasecmp(directive, "rect")) {   /* rect */
 
             if (pointinrect(testpoint, pointarray)) {
-		ap_cfg_closefile(imap);
+                ap_cfg_closefile(imap);
                 redirect = imap_url(r, base, value);
-		if (!redirect) {
-		    return HTTP_INTERNAL_SERVER_ERROR;
-		}
+                if (!redirect) {
+                    return HTTP_INTERNAL_SERVER_ERROR;
+                }
                 return (imap_reply(r, redirect));
             }
             continue;
@@ -808,7 +808,7 @@ static int imap_handler_internal(request_rec *r)
         if (!strcasecmp(directive, "point")) {  /* point */
 
             if (is_closer(testpoint, pointarray, &closest_yet)) {
-		closest = apr_pstrdup(r->pool, value);
+                closest = apr_pstrdup(r->pool, value);
             }
 
             continue;
@@ -826,18 +826,18 @@ static int imap_handler_internal(request_rec *r)
 
     if (closest) {             /* if a 'point' directive has been seen */
         redirect = imap_url(r, base, closest);
-	if (!redirect) {
-	    return HTTP_INTERNAL_SERVER_ERROR;
-	}
+        if (!redirect) {
+            return HTTP_INTERNAL_SERVER_ERROR;
+        }
         return (imap_reply(r, redirect));
     }
 
     if (mapdflt) {             /* a default should be defined, even if
                                   only 'nocontent' */
         redirect = imap_url(r, base, mapdflt);
-	if (!redirect) {
-	    return HTTP_INTERNAL_SERVER_ERROR;
-	}
+        if (!redirect) {
+            return HTTP_INTERNAL_SERVER_ERROR;
+        }
         return (imap_reply(r, redirect));
     }
 
@@ -846,18 +846,18 @@ static int imap_handler_internal(request_rec *r)
 
 need_2_fields:
     ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-		"map file %s, line %d syntax error: requires at "
+                "map file %s, line %d syntax error: requires at "
                 "least two fields", r->uri, imap->line_number);
     /* fall through */
 menu_bail:
     ap_cfg_closefile(imap);
     if (showmenu) {
-	/* There's not much else we can do ... we've already sent the headers
-	 * to the client.
-	 */
-	ap_rputs("\n\n[an internal server error occured]\n", r);
-	menu_footer(r);
-	return OK;
+        /* There's not much else we can do ... we've already sent the headers
+         * to the client.
+         */
+        ap_rputs("\n\n[an internal server error occured]\n", r);
+        menu_footer(r);
+        return OK;
     }
     return HTTP_INTERNAL_SERVER_ERROR;
 }
@@ -869,8 +869,8 @@ static int imap_handler(request_rec *r)
      * imagemaps
      */
     if (r->method_number != M_GET || (strcmp(r->handler,IMAP_MAGIC_TYPE)
-				      && strcmp(r->handler, "imap-file"))) {
-	return DECLINED;
+                                      && strcmp(r->handler, "imap-file"))) {
+        return DECLINED;
     }
     else {
         return imap_handler_internal(r);
diff --git a/modules/mappers/mod_so.c b/modules/mappers/mod_so.c
index 58e1a44..e9b3163 100644
--- a/modules/mappers/mod_so.c
+++ b/modules/mappers/mod_so.c
@@ -179,7 +179,7 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
      * Check both dynamically-loaded modules and statically-linked modules.
      */
     sconf = (so_server_conf *)ap_get_module_config(cmd->server->module_config, 
-	                                        &so_module);
+                                                &so_module);
     modie = (ap_module_symbol_t *)sconf->loaded_modules->elts;
     for (i = 0; i < sconf->loaded_modules->nelts; i++) {
         modi = &modie[i];
@@ -239,12 +239,12 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
         char my_error[256];
 
         return apr_pstrcat(cmd->pool, "Cannot load ", szModuleFile,
-			  " into server: ",
-			  apr_dso_error(modhandle, my_error, sizeof(my_error)),
-			  NULL);
+                          " into server: ",
+                          apr_dso_error(modhandle, my_error, sizeof(my_error)),
+                          NULL);
     }
     ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool,
-		 "loaded module %s", modname);
+                 "loaded module %s", modname);
 
     /*
      * Retrieve the pointer to the module structure through the module name:
@@ -254,10 +254,10 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
     if (apr_dso_sym(&modsym, modhandle, modname) != APR_SUCCESS) {
         char my_error[256];
 
-	return apr_pstrcat(cmd->pool, "Can't locate API module structure `",
-			  modname, "' in file ", szModuleFile, ": ", 
-			  apr_dso_error(modhandle, my_error, sizeof(my_error)),
-			  NULL);
+        return apr_pstrcat(cmd->pool, "Can't locate API module structure `",
+                          modname, "' in file ", szModuleFile, ": ", 
+                          apr_dso_error(modhandle, my_error, sizeof(my_error)),
+                          NULL);
     }
     modp = (module*) modsym;
     modp->dynamic_load_handle = (apr_dso_handle_t *)modhandle;
@@ -316,14 +316,14 @@ static const char *load_file(cmd_parms *cmd, void *dummy, const char *filename)
     if (apr_dso_load(&handle, file, cmd->pool) != APR_SUCCESS) {
         char my_error[256];
 
-	return apr_pstrcat(cmd->pool, "Cannot load ", filename, 
-			  " into server: ", 
-			  apr_dso_error(handle, my_error, sizeof(my_error)),
-			  NULL);
+        return apr_pstrcat(cmd->pool, "Cannot load ", filename, 
+                          " into server: ", 
+                          apr_dso_error(handle, my_error, sizeof(my_error)),
+                          NULL);
     }
     
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
-		 "loaded file %s", filename);
+                 "loaded file %s", filename);
 
     return NULL;
 }
@@ -395,7 +395,7 @@ static const char *load_file(cmd_parms *cmd, void *dummy, const char *filename)
 }
 
 static const char *load_module(cmd_parms *cmd, void *dummy, 
-	                       const char *modname, const char *filename)
+                               const char *modname, const char *filename)
 {
     ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, cmd->pool, 
                  "WARNING: LoadModule not supported on this platform");
diff --git a/modules/mappers/mod_speling.c b/modules/mappers/mod_speling.c
index a89bf44..82f15ba 100644
--- a/modules/mappers/mod_speling.c
+++ b/modules/mappers/mod_speling.c
@@ -164,22 +164,22 @@ static sp_reason spdist(const char *s, const char *t)
     for (; apr_tolower(*s) == apr_tolower(*t); t++, s++) {
         if (*t == '\0') {
             return SP_MISCAPITALIZED;   /* exact match (sans case) */
-	}
+        }
     }
     if (*s) {
         if (*t) {
             if (s[1] && t[1] && apr_tolower(*s) == apr_tolower(t[1])
-		&& apr_tolower(*t) == apr_tolower(s[1])
-		&& strcasecmp(s + 2, t + 2) == 0) {
+                && apr_tolower(*t) == apr_tolower(s[1])
+                && strcasecmp(s + 2, t + 2) == 0) {
                 return SP_TRANSPOSITION;        /* transposition */
-	    }
+            }
             if (strcasecmp(s + 1, t + 1) == 0) {
                 return SP_SIMPLETYPO;   /* 1 char mismatch */
-	    }
+            }
         }
         if (strcasecmp(s + 1, t) == 0) {
             return SP_EXTRACHAR;        /* extra character */
-	}
+        }
     }
     if (*t && strcasecmp(s, t + 1) == 0) {
         return SP_MISSINGCHAR;  /* missing character */
@@ -296,7 +296,7 @@ static int check_speling(request_rec *r)
         else if (strcasecmp(bad, dirent.name) == 0) {
             misspelled_file *sp_new;
 
-	    sp_new = (misspelled_file *) apr_array_push(candidates);
+            sp_new = (misspelled_file *) apr_array_push(candidates);
             sp_new->name = apr_pstrdup(r->pool, dirent.name);
             sp_new->quality = SP_MISCAPITALIZED;
         }
@@ -308,17 +308,17 @@ static int check_speling(request_rec *r)
         else if ((q = spdist(bad, dirent.name)) != SP_VERYDIFFERENT) {
             misspelled_file *sp_new;
 
-	    sp_new = (misspelled_file *) apr_array_push(candidates);
+            sp_new = (misspelled_file *) apr_array_push(candidates);
             sp_new->name = apr_pstrdup(r->pool, dirent.name);
             sp_new->quality = q;
         }
 
         /*
-	 * The spdist() should have found the majority of the misspelled
-	 * requests.  It is of questionable use to continue looking for
-	 * files with the same base name, but potentially of totally wrong
-	 * type (index.html <-> index.db).
-	 * I would propose to not set the WANT_BASENAME_MATCH define.
+         * The spdist() should have found the majority of the misspelled
+         * requests.  It is of questionable use to continue looking for
+         * files with the same base name, but potentially of totally wrong
+         * type (index.html <-> index.db).
+         * I would propose to not set the WANT_BASENAME_MATCH define.
          *      08-Aug-1997 <Martin.Kraemer@Mch.SNI.De>
          *
          * However, Alexei replied giving some reasons to add it anyway:
@@ -326,12 +326,12 @@ static int check_speling(request_rec *r)
          * > extension-stripping-and-matching stuff is a good idea:
          * >
          * > If you're using MultiViews, and have a file named foobar.html,
-	 * > which you refer to as "foobar", and someone tried to access
-	 * > "Foobar", mod_speling won't find it, because it won't find
-	 * > anything matching that spelling. With the extension-munging,
-	 * > it would locate "foobar.html". Not perfect, but I ran into
-	 * > that problem when I first wrote the module.
-	 */
+         * > which you refer to as "foobar", and someone tried to access
+         * > "Foobar", mod_speling won't find it, because it won't find
+         * > anything matching that spelling. With the extension-munging,
+         * > it would locate "foobar.html". Not perfect, but I ran into
+         * > that problem when I first wrote the module.
+         */
         else {
 #ifdef WANT_BASENAME_MATCH
             /*
@@ -348,13 +348,13 @@ static int check_speling(request_rec *r)
             int entloc = ap_ind(dirent.name, '.');
             if (entloc == -1) {
                 entloc = strlen(dirent.name);
-	    }
+            }
 
             if ((dotloc == entloc)
                 && !strncasecmp(bad, dirent.name, dotloc)) {
                 misspelled_file *sp_new;
 
-		sp_new = (misspelled_file *) apr_array_push(candidates);
+                sp_new = (misspelled_file *) apr_array_push(candidates);
                 sp_new->name = apr_pstrdup(r->pool, dirent.name);
                 sp_new->quality = SP_VERYDIFFERENT;
             }
@@ -366,7 +366,7 @@ static int check_speling(request_rec *r)
     if (candidates->nelts != 0) {
         /* Wow... we found us a mispelling. Construct a fixed url */
         char *nuri;
-	const char *ref;
+        const char *ref;
         misspelled_file *variant = (misspelled_file *) candidates->elts;
         int i;
 
@@ -379,27 +379,27 @@ static int check_speling(request_rec *r)
          * Conditions for immediate redirection: 
          *     a) the first candidate was not found by stripping the suffix 
          * AND b) there exists only one candidate OR the best match is not
-	 *        ambiguous
+         *        ambiguous
          * then return a redirection right away.
          */
         if (variant[0].quality != SP_VERYDIFFERENT
-	    && (candidates->nelts == 1
-		|| variant[0].quality != variant[1].quality)) {
+            && (candidates->nelts == 1
+                || variant[0].quality != variant[1].quality)) {
 
             nuri = ap_escape_uri(r->pool, apr_pstrcat(r->pool, url,
-						     variant[0].name,
-						     r->path_info, NULL));
-	    if (r->parsed_uri.query)
-		nuri = apr_pstrcat(r->pool, nuri, "?", r->parsed_uri.query, NULL);
+                                                     variant[0].name,
+                                                     r->path_info, NULL));
+            if (r->parsed_uri.query)
+                nuri = apr_pstrcat(r->pool, nuri, "?", r->parsed_uri.query, NULL);
 
             apr_table_setn(r->headers_out, "Location",
-			  ap_construct_url(r->pool, nuri, r));
+                          ap_construct_url(r->pool, nuri, r));
 
             ap_log_rerror(APLOG_MARK, APLOG_INFO, APR_SUCCESS,
-			  r, 
-			  ref ? "Fixed spelling: %s to %s from %s"
-			      : "Fixed spelling: %s to %s",
-			  r->uri, nuri, ref);
+                          r, 
+                          ref ? "Fixed spelling: %s to %s from %s"
+                              : "Fixed spelling: %s to %s",
+                          r->uri, nuri, ref);
 
             return HTTP_MOVED_PERMANENTLY;
         }
@@ -410,9 +410,9 @@ static int check_speling(request_rec *r)
         else {
             apr_pool_t *p;
             apr_table_t *notes;
-	    apr_pool_t *sub_pool;
-	    apr_array_header_t *t;
-	    apr_array_header_t *v;
+            apr_pool_t *sub_pool;
+            apr_array_header_t *t;
+            apr_array_header_t *v;
 
 
             if (r->main == NULL) {
@@ -424,49 +424,49 @@ static int check_speling(request_rec *r)
                 notes = r->main->notes;
             }
 
-	    if (apr_pool_create(&sub_pool, p) != APR_SUCCESS)
-		return DECLINED;
+            if (apr_pool_create(&sub_pool, p) != APR_SUCCESS)
+                return DECLINED;
 
-	    t = apr_array_make(sub_pool, candidates->nelts * 8 + 8,
-			      sizeof(char *));
-	    v = apr_array_make(sub_pool, candidates->nelts * 5,
-			      sizeof(char *));
+            t = apr_array_make(sub_pool, candidates->nelts * 8 + 8,
+                              sizeof(char *));
+            v = apr_array_make(sub_pool, candidates->nelts * 5,
+                              sizeof(char *));
 
             /* Generate the response text. */
 
-	    *(const char **)apr_array_push(t) =
-			  "The document name you requested (<code>";
-	    *(const char **)apr_array_push(t) = ap_escape_html(sub_pool, r->uri);
-	    *(const char **)apr_array_push(t) =
-			   "</code>) could not be found on this server.\n"
-			   "However, we found documents with names similar "
-			   "to the one you requested.<p>"
-			   "Available documents:\n<ul>\n";
+            *(const char **)apr_array_push(t) =
+                          "The document name you requested (<code>";
+            *(const char **)apr_array_push(t) = ap_escape_html(sub_pool, r->uri);
+            *(const char **)apr_array_push(t) =
+                           "</code>) could not be found on this server.\n"
+                           "However, we found documents with names similar "
+                           "to the one you requested.<p>"
+                           "Available documents:\n<ul>\n";
 
             for (i = 0; i < candidates->nelts; ++i) {
-		char *vuri;
-		const char *reason;
+                char *vuri;
+                const char *reason;
 
-		reason = sp_reason_str[(int) (variant[i].quality)];
+                reason = sp_reason_str[(int) (variant[i].quality)];
                 /* The format isn't very neat... */
-		vuri = apr_pstrcat(sub_pool, url, variant[i].name, r->path_info,
-				  (r->parsed_uri.query != NULL) ? "?" : "",
-				  (r->parsed_uri.query != NULL)
-				      ? r->parsed_uri.query : "",
-				  NULL);
-		*(const char **)apr_array_push(v) = "\"";
-		*(const char **)apr_array_push(v) = ap_escape_uri(sub_pool, vuri);
-		*(const char **)apr_array_push(v) = "\";\"";
-		*(const char **)apr_array_push(v) = reason;
-		*(const char **)apr_array_push(v) = "\"";
-
-		*(const char **)apr_array_push(t) = "<li><a href=\"";
-		*(const char **)apr_array_push(t) = ap_escape_uri(sub_pool, vuri);
-		*(const char **)apr_array_push(t) = "\">";
-		*(const char **)apr_array_push(t) = ap_escape_html(sub_pool, vuri);
-		*(const char **)apr_array_push(t) = "</a> (";
-		*(const char **)apr_array_push(t) = reason;
-		*(const char **)apr_array_push(t) = ")\n";
+                vuri = apr_pstrcat(sub_pool, url, variant[i].name, r->path_info,
+                                  (r->parsed_uri.query != NULL) ? "?" : "",
+                                  (r->parsed_uri.query != NULL)
+                                      ? r->parsed_uri.query : "",
+                                  NULL);
+                *(const char **)apr_array_push(v) = "\"";
+                *(const char **)apr_array_push(v) = ap_escape_uri(sub_pool, vuri);
+                *(const char **)apr_array_push(v) = "\";\"";
+                *(const char **)apr_array_push(v) = reason;
+                *(const char **)apr_array_push(v) = "\"";
+
+                *(const char **)apr_array_push(t) = "<li><a href=\"";
+                *(const char **)apr_array_push(t) = ap_escape_uri(sub_pool, vuri);
+                *(const char **)apr_array_push(t) = "\">";
+                *(const char **)apr_array_push(t) = ap_escape_html(sub_pool, vuri);
+                *(const char **)apr_array_push(t) = "</a> (";
+                *(const char **)apr_array_push(t) = reason;
+                *(const char **)apr_array_push(t) = ")\n";
 
                 /*
                  * when we have printed the "close matches" and there are
@@ -478,36 +478,36 @@ static int check_speling(request_rec *r)
                 if (i > 0 && i < candidates->nelts - 1
                     && variant[i].quality != SP_VERYDIFFERENT
                     && variant[i + 1].quality == SP_VERYDIFFERENT) {
-		    *(const char **)apr_array_push(t) = 
-				   "</ul>\nFurthermore, the following related "
-				   "documents were found:\n<ul>\n";
+                    *(const char **)apr_array_push(t) = 
+                                   "</ul>\nFurthermore, the following related "
+                                   "documents were found:\n<ul>\n";
                 }
             }
-	    *(const char **)apr_array_push(t) = "</ul>\n";
+            *(const char **)apr_array_push(t) = "</ul>\n";
 
             /* If we know there was a referring page, add a note: */
             if (ref != NULL) {
                 *(const char **)apr_array_push(t) =
-			       "Please consider informing the owner of the "
-			       "<a href=\"";
-		*(const char **)apr_array_push(t) = ap_escape_uri(sub_pool, ref);
+                               "Please consider informing the owner of the "
+                               "<a href=\"";
+                *(const char **)apr_array_push(t) = ap_escape_uri(sub_pool, ref);
                 *(const char **)apr_array_push(t) = "\">referring page</a> "
-			       "about the broken link.\n";
-	    }
+                               "about the broken link.\n";
+            }
 
 
             /* Pass our apr_table_t to http_protocol.c (see mod_negotiation): */
             apr_table_setn(notes, "variant-list", apr_array_pstrcat(p, t, 0));
 
-	    apr_table_mergen(r->subprocess_env, "VARIANTS",
-			    apr_array_pstrcat(p, v, ','));
-	  
-	    apr_pool_destroy(sub_pool);
+            apr_table_mergen(r->subprocess_env, "VARIANTS",
+                            apr_array_pstrcat(p, v, ','));
+          
+            apr_pool_destroy(sub_pool);
 
             ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
-			 ref ? "Spelling fix: %s: %d candidates from %s"
-			     : "Spelling fix: %s: %d candidates",
-			 r->uri, candidates->nelts, ref);
+                         ref ? "Spelling fix: %s: %d candidates from %s"
+                             : "Spelling fix: %s: %d candidates",
+                         r->uri, candidates->nelts, ref);
 
             return HTTP_MULTIPLE_CHOICES;
         }
diff --git a/modules/mappers/mod_vhost_alias.c b/modules/mappers/mod_vhost_alias.c
index c05860a..5dd54f8 100644
--- a/modules/mappers/mod_vhost_alias.c
+++ b/modules/mappers/mod_vhost_alias.c
@@ -89,20 +89,20 @@ static void *mva_merge_server_config(apr_pool_t *p, void *parentv, void *childv)
 
     conf = (mva_sconf_t *) apr_pcalloc(p, sizeof(*conf));
     if (child->doc_root_mode == VHOST_ALIAS_UNSET) {
-	conf->doc_root_mode = parent->doc_root_mode;
-	conf->doc_root = parent->doc_root;
+        conf->doc_root_mode = parent->doc_root_mode;
+        conf->doc_root = parent->doc_root;
     }
     else {
-	conf->doc_root_mode = child->doc_root_mode;
-	conf->doc_root = child->doc_root;
+        conf->doc_root_mode = child->doc_root_mode;
+        conf->doc_root = child->doc_root;
     }
     if (child->cgi_root_mode == VHOST_ALIAS_UNSET) {
-	conf->cgi_root_mode = parent->cgi_root_mode;
-	conf->cgi_root = parent->cgi_root;
+        conf->cgi_root_mode = parent->cgi_root_mode;
+        conf->cgi_root = parent->cgi_root;
     }
     else {
-	conf->cgi_root_mode = child->cgi_root_mode;
-	conf->cgi_root = child->cgi_root;
+        conf->cgi_root_mode = child->cgi_root_mode;
+        conf->cgi_root = child->cgi_root;
     }
     return conf;
 }
@@ -125,87 +125,87 @@ static const char *vhost_alias_set(cmd_parms *cmd, void *dummy, const char *map)
     const char *p;
   
     conf = (mva_sconf_t *) ap_get_module_config(cmd->server->module_config,
-						&vhost_alias_module);
+                                                &vhost_alias_module);
     /* there ought to be a better way of doing this */
     if (&vhost_alias_set_doc_root_ip == cmd->info) {
-	mode = VHOST_ALIAS_IP;
-	pmap = &conf->doc_root;
-	pmode = &conf->doc_root_mode;
+        mode = VHOST_ALIAS_IP;
+        pmap = &conf->doc_root;
+        pmode = &conf->doc_root_mode;
     }
     else if (&vhost_alias_set_cgi_root_ip == cmd->info) {
-	mode = VHOST_ALIAS_IP;
-	pmap = &conf->cgi_root;
-	pmode = &conf->cgi_root_mode;
+        mode = VHOST_ALIAS_IP;
+        pmap = &conf->cgi_root;
+        pmode = &conf->cgi_root_mode;
     }
     else if (&vhost_alias_set_doc_root_name == cmd->info) {
-	mode = VHOST_ALIAS_NAME;
-	pmap = &conf->doc_root;
-	pmode = &conf->doc_root_mode;
+        mode = VHOST_ALIAS_NAME;
+        pmap = &conf->doc_root;
+        pmode = &conf->doc_root_mode;
     }
     else if (&vhost_alias_set_cgi_root_name == cmd->info) {
-	mode = VHOST_ALIAS_NAME;
-	pmap = &conf->cgi_root;
-	pmode = &conf->cgi_root_mode;
+        mode = VHOST_ALIAS_NAME;
+        pmap = &conf->cgi_root;
+        pmode = &conf->cgi_root_mode;
     }
     else {
-	return "INTERNAL ERROR: unknown command info";
+        return "INTERNAL ERROR: unknown command info";
     }
 
     if (!ap_os_is_path_absolute(cmd->pool, map)) {
-	if (strcasecmp(map, "none")) {
-	    return "format string must be an absolute path, or 'none'";
-	}
-	*pmap = NULL;
-	*pmode = VHOST_ALIAS_NONE;
-	return NULL;
+        if (strcasecmp(map, "none")) {
+            return "format string must be an absolute path, or 'none'";
+        }
+        *pmap = NULL;
+        *pmode = VHOST_ALIAS_NONE;
+        return NULL;
     }
 
     /* sanity check */
     p = map;
     while (*p != '\0') {
-	if (*p++ != '%') {
-	    continue;
-	}
-	/* we just found a '%' */
-	if (*p == 'p' || *p == '%') {
-	    ++p;
-	    continue;
-	}
-	/* optional dash */
-	if (*p == '-') {
-	    ++p;
-	}
-	/* digit N */
-	if (apr_isdigit(*p)) {
-	    ++p;
-	}
-	else {
-	    return "syntax error in format string";
-	}
-	/* optional plus */
-	if (*p == '+') {
-	    ++p;
-	}
-	/* do we end here? */
-	if (*p != '.') {
-	    continue;
-	}
-	++p;
-	/* optional dash */
-	if (*p == '-') {
-	    ++p;
-	}
-	/* digit M */
-	if (apr_isdigit(*p)) {
-	    ++p;
-	}
-	else {
-	    return "syntax error in format string";
-	}
-	/* optional plus */
-	if (*p == '+') {
-	    ++p;
-	}
+        if (*p++ != '%') {
+            continue;
+        }
+        /* we just found a '%' */
+        if (*p == 'p' || *p == '%') {
+            ++p;
+            continue;
+        }
+        /* optional dash */
+        if (*p == '-') {
+            ++p;
+        }
+        /* digit N */
+        if (apr_isdigit(*p)) {
+            ++p;
+        }
+        else {
+            return "syntax error in format string";
+        }
+        /* optional plus */
+        if (*p == '+') {
+            ++p;
+        }
+        /* do we end here? */
+        if (*p != '.') {
+            continue;
+        }
+        ++p;
+        /* optional dash */
+        if (*p == '-') {
+            ++p;
+        }
+        /* digit M */
+        if (apr_isdigit(*p)) {
+            ++p;
+        }
+        else {
+            return "syntax error in format string";
+        }
+        /* optional plus */
+        if (*p == '+') {
+            ++p;
+        }
     }
     *pmap = map;
     *pmode = mode;
@@ -235,23 +235,23 @@ static const command_rec mva_commands[] =
  * but C is too feeble to support them.
  */
 static APR_INLINE void vhost_alias_checkspace(request_rec *r, char *buf,
-					     char **pdest, int size)
+                                             char **pdest, int size)
 {
     /* XXX: what if size > HUGE_STRING_LEN? */
     if (*pdest + size > buf + HUGE_STRING_LEN) {
-	**pdest = '\0';
-	if (r->filename) {
-	    r->filename = apr_pstrcat(r->pool, r->filename, buf, NULL);
-	}
-	else {
-	    r->filename = apr_pstrdup(r->pool, buf);
-	}
-	*pdest = buf;
+        **pdest = '\0';
+        if (r->filename) {
+            r->filename = apr_pstrcat(r->pool, r->filename, buf, NULL);
+        }
+        else {
+            r->filename = apr_pstrdup(r->pool, buf);
+        }
+        *pdest = buf;
     }
 }
 
 static void vhost_alias_interpolate(request_rec *r, const char *name,
-				    const char *map, const char *uri)
+                                    const char *map, const char *uri)
 {
     /* 0..9 9..0 */
     enum { MAXDOTS = 19 };
@@ -269,9 +269,9 @@ static void vhost_alias_interpolate(request_rec *r, const char *name,
     ndots = 0;
     dots[ndots++] = name-1; /* slightly naughty */
     for (p = name; *p; ++p){
-	if (*p == '.' && ndots < MAXDOTS) {
-	    dots[ndots++] = p;
-	}
+        if (*p == '.' && ndots < MAXDOTS) {
+            dots[ndots++] = p;
+        }
     }
     dots[ndots] = p;
 
@@ -280,103 +280,103 @@ static void vhost_alias_interpolate(request_rec *r, const char *name,
     dest = buf;
     last = '\0';
     while (*map) {
-	if (*map != '%') {
-	    /* normal characters */
-	    vhost_alias_checkspace(r, buf, &dest, 1);
-	    last = *dest++ = *map++;
-	    continue;
-	}
-	/* we are in a format specifier */
-	++map;
-	/* can't be a slash */
-	last = '\0';
-	/* %% -> % */
-	if (*map == '%') {
-	    ++map;
-	    vhost_alias_checkspace(r, buf, &dest, 1);
-	    *dest++ = '%';
-	    continue;
-	}
-	/* port number */
-	if (*map == 'p') {
-	    ++map;
-	    /* no. of decimal digits in a short plus one */
-	    vhost_alias_checkspace(r, buf, &dest, 7);
-	    dest += apr_snprintf(dest, 7, "%d", ap_get_server_port(r));
-	    continue;
-	}
-	/* deal with %-N+.-M+ -- syntax is already checked */
-	N = M = 0;   /* value */
-	Np = Mp = 0; /* is there a plus? */
-	Nd = Md = 0; /* is there a dash? */
-	if (*map == '-') ++map, Nd = 1;
-	N = *map++ - '0';
-	if (*map == '+') ++map, Np = 1;
-	if (*map == '.') {
-	    ++map;
-	    if (*map == '-') {
-		++map, Md = 1;
-	    }
-	    M = *map++ - '0';
-	    if (*map == '+') {
-		++map, Mp = 1;
-	    }
-	}
-	/* note that N and M are one-based indices, not zero-based */
-	start = dots[0]+1; /* ptr to the first character */
-	end = dots[ndots]; /* ptr to the character after the last one */
-	if (N != 0) {
-	    if (N > ndots) {
-		start = "_";
-		end = start+1;
-	    }
-	    else if (!Nd) {
-		start = dots[N-1]+1;
-		if (!Np) {
-		    end = dots[N];
-		}
-	    }
-	    else {
-		if (!Np) {
-		    start = dots[ndots-N]+1;
-		}
-		end = dots[ndots-N+1];
-	    }
-	}
-	if (M != 0) {
-	    if (M > end - start) {
-		start = "_";
-		end = start+1;
-	    }
-	    else if (!Md) {
-		start = start+M-1;
-		if (!Mp) {
-		    end = start+1;
-		}
-	    }
-	    else {
-		if (!Mp) {
-		    start = end-M;
-		}
-		end = end-M+1;
-	    }
-	}
-	vhost_alias_checkspace(r, buf, &dest, end - start);
-	for (p = start; p < end; ++p) {
-	    *dest++ = apr_tolower(*p);
-	}
+        if (*map != '%') {
+            /* normal characters */
+            vhost_alias_checkspace(r, buf, &dest, 1);
+            last = *dest++ = *map++;
+            continue;
+        }
+        /* we are in a format specifier */
+        ++map;
+        /* can't be a slash */
+        last = '\0';
+        /* %% -> % */
+        if (*map == '%') {
+            ++map;
+            vhost_alias_checkspace(r, buf, &dest, 1);
+            *dest++ = '%';
+            continue;
+        }
+        /* port number */
+        if (*map == 'p') {
+            ++map;
+            /* no. of decimal digits in a short plus one */
+            vhost_alias_checkspace(r, buf, &dest, 7);
+            dest += apr_snprintf(dest, 7, "%d", ap_get_server_port(r));
+            continue;
+        }
+        /* deal with %-N+.-M+ -- syntax is already checked */
+        N = M = 0;   /* value */
+        Np = Mp = 0; /* is there a plus? */
+        Nd = Md = 0; /* is there a dash? */
+        if (*map == '-') ++map, Nd = 1;
+        N = *map++ - '0';
+        if (*map == '+') ++map, Np = 1;
+        if (*map == '.') {
+            ++map;
+            if (*map == '-') {
+                ++map, Md = 1;
+            }
+            M = *map++ - '0';
+            if (*map == '+') {
+                ++map, Mp = 1;
+            }
+        }
+        /* note that N and M are one-based indices, not zero-based */
+        start = dots[0]+1; /* ptr to the first character */
+        end = dots[ndots]; /* ptr to the character after the last one */
+        if (N != 0) {
+            if (N > ndots) {
+                start = "_";
+                end = start+1;
+            }
+            else if (!Nd) {
+                start = dots[N-1]+1;
+                if (!Np) {
+                    end = dots[N];
+                }
+            }
+            else {
+                if (!Np) {
+                    start = dots[ndots-N]+1;
+                }
+                end = dots[ndots-N+1];
+            }
+        }
+        if (M != 0) {
+            if (M > end - start) {
+                start = "_";
+                end = start+1;
+            }
+            else if (!Md) {
+                start = start+M-1;
+                if (!Mp) {
+                    end = start+1;
+                }
+            }
+            else {
+                if (!Mp) {
+                    start = end-M;
+                }
+                end = end-M+1;
+            }
+        }
+        vhost_alias_checkspace(r, buf, &dest, end - start);
+        for (p = start; p < end; ++p) {
+            *dest++ = apr_tolower(*p);
+        }
     }
     *dest = '\0';
     /* no double slashes */
     if (last == '/') {
-	++uri;
+        ++uri;
     }
 
     if (r->filename) {
-	r->filename = apr_pstrcat(r->pool, r->filename, buf, uri, NULL);
+        r->filename = apr_pstrcat(r->pool, r->filename, buf, uri, NULL);
     }
     else {
-	r->filename = apr_pstrcat(r->pool, buf, uri, NULL);
+        r->filename = apr_pstrcat(r->pool, buf, uri, NULL);
     }
 }
 
@@ -388,36 +388,36 @@ static int mva_translate(request_rec *r)
     const char *cgi;
   
     conf = (mva_sconf_t *) ap_get_module_config(r->server->module_config,
-					      &vhost_alias_module);
+                                              &vhost_alias_module);
     cgi = NULL;
     if (conf->cgi_root) {
-	cgi = strstr(r->uri, "cgi-bin/");
-	if (cgi && (cgi != r->uri + strspn(r->uri, "/"))) {
-	    cgi = NULL;
-	}
+        cgi = strstr(r->uri, "cgi-bin/");
+        if (cgi && (cgi != r->uri + strspn(r->uri, "/"))) {
+            cgi = NULL;
+        }
     }
     if (cgi) {
-	mode = conf->cgi_root_mode;
-	map = conf->cgi_root;
-	uri = cgi + strlen("cgi-bin");
+        mode = conf->cgi_root_mode;
+        map = conf->cgi_root;
+        uri = cgi + strlen("cgi-bin");
     }
     else if (r->uri[0] == '/') {
-	mode = conf->doc_root_mode;
-	map = conf->doc_root;
-	uri = r->uri;
+        mode = conf->doc_root_mode;
+        map = conf->doc_root;
+        uri = r->uri;
     }
     else {
-	return DECLINED;
+        return DECLINED;
     }
   
     if (mode == VHOST_ALIAS_NAME) {
-	name = ap_get_server_name(r);
+        name = ap_get_server_name(r);
     }
     else if (mode == VHOST_ALIAS_IP) {
-	name = r->connection->local_ip;
+        name = r->connection->local_ip;
     }
     else {
-	return DECLINED;
+        return DECLINED;
     }
 
     /* ### There is an optimization available here to determine the
@@ -429,9 +429,9 @@ static int mva_translate(request_rec *r)
     vhost_alias_interpolate(r, name, map, uri);
 
     if (cgi) {
-	/* see is_scriptaliased() in mod_cgi */
-	r->handler = "cgi-script";
-	apr_table_setn(r->notes, "alias-forced-type", r->handler);
+        /* see is_scriptaliased() in mod_cgi */
+        r->handler = "cgi-script";
+        apr_table_setn(r->notes, "alias-forced-type", r->handler);
     }
 
     return OK;
diff --git a/modules/metadata/mod_expires.c b/modules/metadata/mod_expires.c
index 510136e..1603297 100644
--- a/modules/metadata/mod_expires.c
+++ b/modules/metadata/mod_expires.c
@@ -375,7 +375,7 @@ static void *merge_expires_dir_configs(apr_pool_t *p, void *basev, void *addv)
         new->expiresdefault = add->expiresdefault;
     }
     else {
-	new->expiresdefault = base->expiresdefault;
+        new->expiresdefault = base->expiresdefault;
     }
     new->wildcards = add->wildcards;
     new->expiresbytype = apr_table_overlay(p, add->expiresbytype,
@@ -399,13 +399,13 @@ static int set_expiration_fields(request_rec *r, const char *code,
 
     switch (code[0]) {
     case 'M':
-	if (r->finfo.filetype == 0) { 
-	    /* file doesn't exist on disk, so we can't do anything based on
-	     * modification time.  Note that this does _not_ log an error.
-	     */
-	    return DECLINED;
-	}
-	base = r->finfo.mtime;
+        if (r->finfo.filetype == 0) { 
+            /* file doesn't exist on disk, so we can't do anything based on
+             * modification time.  Note that this does _not_ log an error.
+             */
+            return DECLINED;
+        }
+        base = r->finfo.mtime;
         additional_sec = atoi(&code[1]);
         additional = apr_time_from_sec(additional_sec);
         break;
diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index 82f2993..cf798d8 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -534,11 +534,11 @@ static void do_headers_fixup(request_rec *r, apr_table_t *headers,
         header_entry *hdr = &((header_entry *) (fixup->elts))[i];
         const char *envar = hdr->condition_var;
 
-	/* ignore early headers in late calls */
+        /* ignore early headers in late calls */
         if (!early && (envar == condition_early)) {
             continue;
         }
-	/* ignore late headers in early calls */
+        /* ignore late headers in early calls */
         else if (early && (envar != condition_early)) {
             continue;
         }
diff --git a/modules/metadata/mod_mime_magic.c b/modules/metadata/mod_mime_magic.c
index d0f485f..6440c4d 100644
--- a/modules/metadata/mod_mime_magic.c
+++ b/modules/metadata/mod_mime_magic.c
@@ -134,8 +134,8 @@ struct magic {
 #define    UNSIGNED 2		/* comparison is unsigned */
     short cont_level;		/* level of ">" */
     struct {
-	char type;		/* byte short long */
-	long offset;		/* offset from indirection */
+        char type;		/* byte short long */
+        long offset;		/* offset from indirection */
     } in;
     long offset;		/* offset to magic number */
     unsigned char reln;		/* relation (0=eq, '>'=gt, etc) */
@@ -153,12 +153,12 @@ struct magic {
 #define LELONG    11
 #define LEDATE    12
     union VALUETYPE {
-	unsigned char b;
-	unsigned short h;
-	unsigned long l;
-	char s[MAXstring];
-	unsigned char hs[2];	/* 2 bytes of a fixed-endian "short" */
-	unsigned char hl[4];	/* 2 bytes of a fixed-endian "long" */
+        unsigned char b;
+        unsigned short h;
+        unsigned long l;
+        char s[MAXstring];
+        unsigned char hs[2];	/* 2 bytes of a fixed-endian "short" */
+        unsigned char hl[4];	/* 2 bytes of a fixed-endian "long" */
     } value;			/* either number or string */
     unsigned long mask;		/* mask before comparison with value */
     char nospflag;		/* supress space character */
@@ -189,20 +189,20 @@ struct magic {
 union record {
     char charptr[RECORDSIZE];
     struct header {
-	char name[NAMSIZ];
-	char mode[8];
-	char uid[8];
-	char gid[8];
-	char size[12];
-	char mtime[12];
-	char chksum[8];
-	char linkflag;
-	char linkname[NAMSIZ];
-	char magic[8];
-	char uname[TUNMLEN];
-	char gname[TGNMLEN];
-	char devmajor[8];
-	char devminor[8];
+        char name[NAMSIZ];
+        char mode[8];
+        char uid[8];
+        char gid[8];
+        char size[12];
+        char mtime[12];
+        char chksum[8];
+        char linkflag;
+        char linkname[NAMSIZ];
+        char magic[8];
+        char uname[TUNMLEN];
+        char gname[TGNMLEN];
+        char devmajor[8];
+        char devminor[8];
     } header;
 };
 
@@ -225,12 +225,12 @@ static int parse(server_rec *, apr_pool_t *p, char *, int);
 
 static int match(request_rec *, unsigned char *, apr_size_t);
 static int mget(request_rec *, union VALUETYPE *, unsigned char *,
-		struct magic *, apr_size_t);
+                struct magic *, apr_size_t);
 static int mcheck(request_rec *, union VALUETYPE *, struct magic *);
 static void mprint(request_rec *, union VALUETYPE *, struct magic *);
 
 static int uncompress(request_rec *, int, 
-		      unsigned char **, apr_size_t);
+                      unsigned char **, apr_size_t);
 static long from_oct(int, char *);
 static int fsmagic(request_rec *r, const char *fn);
 
@@ -281,79 +281,79 @@ static struct names {
     /* These must be sorted by eye for optimal hit rate */
     /* Add to this list only after substantial meditation */
     {
-	"<html>", L_HTML
+        "<html>", L_HTML
     },
     {
-	"<HTML>", L_HTML
+        "<HTML>", L_HTML
     },
     {
-	"<head>", L_HTML
+        "<head>", L_HTML
     },
     {
-	"<HEAD>", L_HTML
+        "<HEAD>", L_HTML
     },
     {
-	"<title>", L_HTML
+        "<title>", L_HTML
     },
     {
-	"<TITLE>", L_HTML
+        "<TITLE>", L_HTML
     },
     {
-	"<h1>", L_HTML
+        "<h1>", L_HTML
     },
     {
-	"<H1>", L_HTML
+        "<H1>", L_HTML
     },
     {
-	"<!--", L_HTML
+        "<!--", L_HTML
     },
     {
-	"<!DOCTYPE HTML", L_HTML
+        "<!DOCTYPE HTML", L_HTML
     },
     {
-	"/*", L_C
+        "/*", L_C
     },				/* must precede "The", "the", etc. */
     {
-	"#include", L_C
+        "#include", L_C
     },
     {
-	"char", L_C
+        "char", L_C
     },
     {
-	"The", L_ENG
+        "The", L_ENG
     },
     {
-	"the", L_ENG
+        "the", L_ENG
     },
     {
-	"double", L_C
+        "double", L_C
     },
     {
-	"extern", L_C
+        "extern", L_C
     },
     {
-	"float", L_C
+        "float", L_C
     },
     {
-	"real", L_C
+        "real", L_C
     },
     {
-	"struct", L_C
+        "struct", L_C
     },
     {
-	"union", L_C
+        "union", L_C
     },
     {
-	"CFLAGS", L_MAKE
+        "CFLAGS", L_MAKE
     },
     {
-	"LDFLAGS", L_MAKE
+        "LDFLAGS", L_MAKE
     },
     {
-	"all:", L_MAKE
+        "all:", L_MAKE
     },
     {
-	".PRECIOUS", L_MAKE
+        ".PRECIOUS", L_MAKE
     },
     /*
      * Too many files of text have these words in them.  Find another way to
@@ -361,74 +361,74 @@ static struct names {
      */
 #ifdef    NOTDEF
     {
-	"subroutine", L_FORT
+        "subroutine", L_FORT
     },
     {
-	"function", L_FORT
+        "function", L_FORT
     },
     {
-	"block", L_FORT
+        "block", L_FORT
     },
     {
-	"common", L_FORT
+        "common", L_FORT
     },
     {
-	"dimension", L_FORT
+        "dimension", L_FORT
     },
     {
-	"integer", L_FORT
+        "integer", L_FORT
     },
     {
-	"data", L_FORT
+        "data", L_FORT
     },
 #endif /* NOTDEF */
     {
-	".ascii", L_MACH
+        ".ascii", L_MACH
     },
     {
-	".asciiz", L_MACH
+        ".asciiz", L_MACH
     },
     {
-	".byte", L_MACH
+        ".byte", L_MACH
     },
     {
-	".even", L_MACH
+        ".even", L_MACH
     },
     {
-	".globl", L_MACH
+        ".globl", L_MACH
     },
     {
-	"clr", L_MACH
+        "clr", L_MACH
     },
     {
-	"(input,", L_PAS
+        "(input,", L_PAS
     },
     {
-	"dcl", L_PLI
+        "dcl", L_PLI
     },
     {
-	"Received:", L_MAIL
+        "Received:", L_MAIL
     },
     {
-	">From", L_MAIL
+        ">From", L_MAIL
     },
     {
-	"Return-Path:", L_MAIL
+        "Return-Path:", L_MAIL
     },
     {
-	"Cc:", L_MAIL
+        "Cc:", L_MAIL
     },
     {
-	"Newsgroups:", L_NEWS
+        "Newsgroups:", L_NEWS
     },
     {
-	"Path:", L_NEWS
+        "Path:", L_NEWS
     },
     {
-	"Organization:", L_NEWS
+        "Organization:", L_NEWS
     },
     {
-	NULL, 0
+        NULL, 0
     }
 };
 
@@ -482,7 +482,7 @@ static void *merge_magic_server_config(apr_pool_t *p, void *basev, void *addv)
     magic_server_config_rec *base = (magic_server_config_rec *) basev;
     magic_server_config_rec *add = (magic_server_config_rec *) addv;
     magic_server_config_rec *new = (magic_server_config_rec *)
-			    apr_palloc(p, sizeof(magic_server_config_rec));
+                            apr_palloc(p, sizeof(magic_server_config_rec));
 
     new->magicfile = add->magicfile ? add->magicfile : base->magicfile;
     new->magic = NULL;
@@ -494,10 +494,10 @@ static const char *set_magicfile(cmd_parms *cmd, void *dummy, const char *arg)
 {
     magic_server_config_rec *conf = (magic_server_config_rec *)
     ap_get_module_config(cmd->server->module_config,
-		      &mime_magic_module);
+                      &mime_magic_module);
 
     if (!conf) {
-	return MODNAME ": server structure not allocated";
+        return MODNAME ": server structure not allocated";
     }
     conf->magicfile = arg;
     return NULL;
@@ -531,7 +531,7 @@ static const command_rec mime_magic_cmds[] =
 static magic_req_rec *magic_set_config(request_rec *r)
 {
     magic_req_rec *req_dat = (magic_req_rec *) apr_palloc(r->pool,
-						      sizeof(magic_req_rec));
+                                                      sizeof(magic_req_rec));
 
     req_dat->head = req_dat->tail = (magic_rsl *) NULL;
     ap_set_module_config(r->request_config, &mime_magic_module, req_dat);
@@ -543,17 +543,17 @@ static magic_req_rec *magic_set_config(request_rec *r)
 static int magic_rsl_add(request_rec *r, char *str)
 {
     magic_req_rec *req_dat = (magic_req_rec *)
-		    ap_get_module_config(r->request_config, &mime_magic_module);
+                    ap_get_module_config(r->request_config, &mime_magic_module);
     magic_rsl *rsl;
 
     /* make sure we have a list to put it in */
     if (!req_dat) {
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EINVAL, r,
-		    MODNAME ": request config should not be NULL");
-	if (!(req_dat = magic_set_config(r))) {
-	    /* failure */
-	    return -1;
-	}
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EINVAL, r,
+                    MODNAME ": request config should not be NULL");
+        if (!(req_dat = magic_set_config(r))) {
+            /* failure */
+            return -1;
+        }
     }
 
     /* allocate the list entry */
@@ -565,11 +565,11 @@ static int magic_rsl_add(request_rec *r, char *str)
 
     /* append to the list */
     if (req_dat->head && req_dat->tail) {
-	req_dat->tail->next = rsl;
-	req_dat->tail = rsl;
+        req_dat->tail->next = rsl;
+        req_dat->tail = rsl;
     }
     else {
-	req_dat->head = req_dat->tail = rsl;
+        req_dat->head = req_dat->tail = rsl;
     }
 
     /* success */
@@ -618,7 +618,7 @@ static char *rsl_strdup(request_rec *r, int start_frag, int start_pos, int len)
         res_pos;		/* position in result string */
     magic_rsl *frag;		/* list-traversal pointer */
     magic_req_rec *req_dat = (magic_req_rec *)
-		    ap_get_module_config(r->request_config, &mime_magic_module);
+                    ap_get_module_config(r->request_config, &mime_magic_module);
 
     /* allocate the result string */
     result = (char *) apr_palloc(r->pool, len + 1);
@@ -626,32 +626,32 @@ static char *rsl_strdup(request_rec *r, int start_frag, int start_pos, int len)
     /* loop through and collect the string */
     res_pos = 0;
     for (frag = req_dat->head, cur_frag = 0;
-	 frag->next;
-	 frag = frag->next, cur_frag++) {
-	/* loop to the first fragment */
-	if (cur_frag < start_frag)
-	    continue;
-
-	/* loop through and collect chars */
-	for (cur_pos = (cur_frag == start_frag) ? start_pos : 0;
-	     frag->str[cur_pos];
-	     cur_pos++) {
-	    if (cur_frag >= start_frag
-		&& cur_pos >= start_pos
-		&& res_pos <= len) {
-		result[res_pos++] = frag->str[cur_pos];
-		if (res_pos > len) {
-		    break;
-		}
-	    }
-	}
+         frag->next;
+         frag = frag->next, cur_frag++) {
+        /* loop to the first fragment */
+        if (cur_frag < start_frag)
+            continue;
+
+        /* loop through and collect chars */
+        for (cur_pos = (cur_frag == start_frag) ? start_pos : 0;
+             frag->str[cur_pos];
+             cur_pos++) {
+            if (cur_frag >= start_frag
+                && cur_pos >= start_pos
+                && res_pos <= len) {
+                result[res_pos++] = frag->str[cur_pos];
+                if (res_pos > len) {
+                    break;
+                }
+            }
+        }
     }
 
     /* clean up and return */
     result[res_pos] = 0;
 #if MIME_MAGIC_DEBUG
     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-	     MODNAME ": rsl_strdup() %d chars: %s", res_pos - 1, result);
+             MODNAME ": rsl_strdup() %d chars: %s", res_pos - 1, result);
 #endif
     return result;
 }
@@ -677,12 +677,12 @@ static int magic_rsl_to_request(request_rec *r)
     rsl_states state;
 
     magic_req_rec *req_dat = (magic_req_rec *)
-		    ap_get_module_config(r->request_config, &mime_magic_module);
+                    ap_get_module_config(r->request_config, &mime_magic_module);
 
     /* check if we have a result */
     if (!req_dat || !req_dat->head) {
-	/* empty - no match, we defer to other Apache modules */
-	return DECLINED;
+        /* empty - no match, we defer to other Apache modules */
+        return DECLINED;
     }
 
     /* start searching for the type and encoding */
@@ -690,127 +690,127 @@ static int magic_rsl_to_request(request_rec *r)
     type_frag = type_pos = type_len = 0;
     encoding_frag = encoding_pos = encoding_len = 0;
     for (frag = req_dat->head, cur_frag = 0;
-	 frag && frag->next;
-	 frag = frag->next, cur_frag++) {
-	/* loop through the characters in the fragment */
-	for (cur_pos = 0; frag->str[cur_pos]; cur_pos++) {
-	    if (apr_isspace(frag->str[cur_pos])) {
-		/* process whitespace actions for each state */
-		if (state == rsl_leading_space) {
-		    /* eat whitespace in this state */
-		    continue;
-		}
-		else if (state == rsl_type) {
-		    /* whitespace: type has no slash! */
-		    return DECLINED;
-		}
-		else if (state == rsl_subtype) {
-		    /* whitespace: end of MIME type */
-		    state++;
-		    continue;
-		}
-		else if (state == rsl_separator) {
-		    /* eat whitespace in this state */
-		    continue;
-		}
-		else if (state == rsl_encoding) {
-		    /* whitespace: end of MIME encoding */
-		    /* we're done */
-		    frag = req_dat->tail;
-		    break;
-		}
-		else {
-		    /* should not be possible */
-		    /* abandon malfunctioning module */
-		    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-				MODNAME ": bad state %d (ws)", state);
-		    return DECLINED;
-		}
-		/* NOTREACHED */
-	    }
-	    else if (state == rsl_type &&
-		     frag->str[cur_pos] == '/') {
-		/* copy the char and go to rsl_subtype state */
-		type_len++;
-		state++;
-	    }
-	    else {
-		/* process non-space actions for each state */
-		if (state == rsl_leading_space) {
-		    /* non-space: begin MIME type */
-		    state++;
-		    type_frag = cur_frag;
-		    type_pos = cur_pos;
-		    type_len = 1;
-		    continue;
-		}
-		else if (state == rsl_type ||
-			 state == rsl_subtype) {
-		    /* non-space: adds to type */
-		    type_len++;
-		    continue;
-		}
-		else if (state == rsl_separator) {
-		    /* non-space: begin MIME encoding */
-		    state++;
-		    encoding_frag = cur_frag;
-		    encoding_pos = cur_pos;
-		    encoding_len = 1;
-		    continue;
-		}
-		else if (state == rsl_encoding) {
-		    /* non-space: adds to encoding */
-		    encoding_len++;
-		    continue;
-		}
-		else {
-		    /* should not be possible */
-		    /* abandon malfunctioning module */
-		    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-				MODNAME ": bad state %d (ns)", state);
-		    return DECLINED;
-		}
-		/* NOTREACHED */
-	    }
-	    /* NOTREACHED */
-	}
+         frag && frag->next;
+         frag = frag->next, cur_frag++) {
+        /* loop through the characters in the fragment */
+        for (cur_pos = 0; frag->str[cur_pos]; cur_pos++) {
+            if (apr_isspace(frag->str[cur_pos])) {
+                /* process whitespace actions for each state */
+                if (state == rsl_leading_space) {
+                    /* eat whitespace in this state */
+                    continue;
+                }
+                else if (state == rsl_type) {
+                    /* whitespace: type has no slash! */
+                    return DECLINED;
+                }
+                else if (state == rsl_subtype) {
+                    /* whitespace: end of MIME type */
+                    state++;
+                    continue;
+                }
+                else if (state == rsl_separator) {
+                    /* eat whitespace in this state */
+                    continue;
+                }
+                else if (state == rsl_encoding) {
+                    /* whitespace: end of MIME encoding */
+                    /* we're done */
+                    frag = req_dat->tail;
+                    break;
+                }
+                else {
+                    /* should not be possible */
+                    /* abandon malfunctioning module */
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                                MODNAME ": bad state %d (ws)", state);
+                    return DECLINED;
+                }
+                /* NOTREACHED */
+            }
+            else if (state == rsl_type &&
+                     frag->str[cur_pos] == '/') {
+                /* copy the char and go to rsl_subtype state */
+                type_len++;
+                state++;
+            }
+            else {
+                /* process non-space actions for each state */
+                if (state == rsl_leading_space) {
+                    /* non-space: begin MIME type */
+                    state++;
+                    type_frag = cur_frag;
+                    type_pos = cur_pos;
+                    type_len = 1;
+                    continue;
+                }
+                else if (state == rsl_type ||
+                         state == rsl_subtype) {
+                    /* non-space: adds to type */
+                    type_len++;
+                    continue;
+                }
+                else if (state == rsl_separator) {
+                    /* non-space: begin MIME encoding */
+                    state++;
+                    encoding_frag = cur_frag;
+                    encoding_pos = cur_pos;
+                    encoding_len = 1;
+                    continue;
+                }
+                else if (state == rsl_encoding) {
+                    /* non-space: adds to encoding */
+                    encoding_len++;
+                    continue;
+                }
+                else {
+                    /* should not be possible */
+                    /* abandon malfunctioning module */
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                                MODNAME ": bad state %d (ns)", state);
+                    return DECLINED;
+                }
+                /* NOTREACHED */
+            }
+            /* NOTREACHED */
+        }
     }
 
     /* if we ended prior to state rsl_subtype, we had incomplete info */
     if (state != rsl_subtype && state != rsl_separator &&
-	state != rsl_encoding) {
-	/* defer to other modules */
-	return DECLINED;
+        state != rsl_encoding) {
+        /* defer to other modules */
+        return DECLINED;
     }
 
     /* save the info in the request record */
     if (state == rsl_subtype || state == rsl_encoding ||
-	state == rsl_encoding) {
+        state == rsl_encoding) {
         char *tmp;
-	tmp = rsl_strdup(r, type_frag, type_pos, type_len);
-	/* XXX: this could be done at config time I'm sure... but I'm
-	 * confused by all this magic_rsl stuff. -djg */
-	ap_content_type_tolower(tmp);
-	ap_set_content_type(r, tmp);
+        tmp = rsl_strdup(r, type_frag, type_pos, type_len);
+        /* XXX: this could be done at config time I'm sure... but I'm
+         * confused by all this magic_rsl stuff. -djg */
+        ap_content_type_tolower(tmp);
+        ap_set_content_type(r, tmp);
     }
     if (state == rsl_encoding) {
         char *tmp;
-	tmp = rsl_strdup(r, encoding_frag,
-					 encoding_pos, encoding_len);
-	/* XXX: this could be done at config time I'm sure... but I'm
-	 * confused by all this magic_rsl stuff. -djg */
-	ap_str_tolower(tmp);
-	r->content_encoding = tmp;
+        tmp = rsl_strdup(r, encoding_frag,
+                                         encoding_pos, encoding_len);
+        /* XXX: this could be done at config time I'm sure... but I'm
+         * confused by all this magic_rsl stuff. -djg */
+        ap_str_tolower(tmp);
+        r->content_encoding = tmp;
     }
 
     /* detect memory allocation or other errors */
     if (!r->content_type ||
-	(state == rsl_encoding && !r->content_encoding)) {
+        (state == rsl_encoding && !r->content_encoding)) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       MODNAME ": unexpected state %d; could be caused by bad "
                       "data in magic file",
                       state);
-	return HTTP_INTERNAL_SERVER_ERROR;
+        return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     /* success! */
@@ -834,21 +834,21 @@ static int magic_process(request_rec *r)
      */
     switch ((result = fsmagic(r, r->filename))) {
     case DONE:
-	magic_rsl_putchar(r, '\n');
-	return OK;
+        magic_rsl_putchar(r, '\n');
+        return OK;
     case OK:
-	break;
+        break;
     default:
-	/* fatal error, bail out */
-	return result;
+        /* fatal error, bail out */
+        return result;
     }
 
     if (apr_file_open(&fd, r->filename, APR_READ, APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
-	/* We can't open it, but we were able to stat it. */
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-		    MODNAME ": can't read `%s'", r->filename);
-	/* let some other handler decide what the problem is */
-	return DECLINED;
+        /* We can't open it, but we were able to stat it. */
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    MODNAME ": can't read `%s'", r->filename);
+        /* let some other handler decide what the problem is */
+        return DECLINED;
     }
 
     /*
@@ -856,18 +856,18 @@ static int magic_process(request_rec *r)
      */
     nbytes = sizeof(buf) - 1;
     if ((result = apr_file_read(fd, (char *) buf, &nbytes)) != APR_SUCCESS) {
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, result, r,
-		    MODNAME ": read failed: %s", r->filename);
-	return HTTP_INTERNAL_SERVER_ERROR;
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, result, r,
+                    MODNAME ": read failed: %s", r->filename);
+        return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     if (nbytes == 0) {
         return DECLINED;
     }
     else {
-	buf[nbytes++] = '\0';	/* null-terminate it */
+        buf[nbytes++] = '\0';	/* null-terminate it */
         result = tryit(r, buf, nbytes, 1);
-	if (result != OK) {
+        if (result != OK) {
             return result;
         }
     }
@@ -885,22 +885,22 @@ static int tryit(request_rec *r, unsigned char *buf, apr_size_t nb,
     /*
      * Try compression stuff
      */
-	if (checkzmagic == 1) {  
-			if (zmagic(r, buf, nb) == 1)
-			return OK;
-	}
+        if (checkzmagic == 1) {  
+                        if (zmagic(r, buf, nb) == 1)
+                        return OK;
+        }
 
     /*
      * try tests in /etc/magic (or surrogate magic file)
      */
     if (softmagic(r, buf, nb) == 1)
-	return OK;
+        return OK;
 
     /*
      * try known keywords, check for ascii-ness too.
      */
     if (ascmagic(r, buf, nb) == 1)
-	return OK;
+        return OK;
 
     /*
      * abandon hope, all ye who remain here
@@ -926,19 +926,19 @@ static int apprentice(server_rec *s, apr_pool_t *p)
     struct magic *m, *prevm;
 #endif
     magic_server_config_rec *conf = (magic_server_config_rec *)
-		    ap_get_module_config(s->module_config, &mime_magic_module);
+                    ap_get_module_config(s->module_config, &mime_magic_module);
     const char *fname = ap_server_root_relative(p, conf->magicfile);
 
     if (!fname) {
-	ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
-		     MODNAME ": Invalid magic file path %s", conf->magicfile);
-	return -1;
+        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
+                     MODNAME ": Invalid magic file path %s", conf->magicfile);
+        return -1;
     }        
     if ((result = apr_file_open(&f, fname, APR_READ | APR_BUFFERED, 
                                 APR_OS_DEFAULT, p) != APR_SUCCESS)) {
-	ap_log_error(APLOG_MARK, APLOG_ERR, result, s,
-		     MODNAME ": can't read magic file %s", fname);
-	return -1;
+        ap_log_error(APLOG_MARK, APLOG_ERR, result, s,
+                     MODNAME ": can't read magic file %s", fname);
+        return -1;
     }
 
     /* set up the magic list (empty) */
@@ -946,78 +946,78 @@ static int apprentice(server_rec *s, apr_pool_t *p)
 
     /* parse it */
     for (lineno = 1; apr_file_gets(line, BUFSIZ, f) == APR_SUCCESS; lineno++) {
-	int ws_offset;
+        int ws_offset;
         char *last = line + strlen(line) - 1; /* guaranteed that len >= 1 since an
                                                * "empty" line contains a '\n'
                                                */
 
-	/* delete newline and any other trailing whitespace */
+        /* delete newline and any other trailing whitespace */
         while (last >= line
                && apr_isspace(*last)) {
             *last = '\0';
             --last;
         }
         
-	/* skip leading whitespace */
-	ws_offset = 0;
-	while (line[ws_offset] && apr_isspace(line[ws_offset])) {
-	    ws_offset++;
-	}
+        /* skip leading whitespace */
+        ws_offset = 0;
+        while (line[ws_offset] && apr_isspace(line[ws_offset])) {
+            ws_offset++;
+        }
 
-	/* skip blank lines */
-	if (line[ws_offset] == 0) {
-	    continue;
-	}
+        /* skip blank lines */
+        if (line[ws_offset] == 0) {
+            continue;
+        }
 
-	/* comment, do not parse */
-	if (line[ws_offset] == '#')
-	    continue;
+        /* comment, do not parse */
+        if (line[ws_offset] == '#')
+            continue;
 
 #if MIME_MAGIC_DEBUG
-	/* if we get here, we're going to use it so count it */
-	rule++;
+        /* if we get here, we're going to use it so count it */
+        rule++;
 #endif
 
-	/* parse it */
-	if (parse(s, p, line + ws_offset, lineno) != 0)
-	    ++errs;
+        /* parse it */
+        if (parse(s, p, line + ws_offset, lineno) != 0)
+            ++errs;
     }
 
     (void) apr_file_close(f);
 
 #if MIME_MAGIC_DEBUG
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-		MODNAME ": apprentice conf=%x file=%s m=%s m->next=%s last=%s",
-		conf,
-		conf->magicfile ? conf->magicfile : "NULL",
-		conf->magic ? "set" : "NULL",
-		(conf->magic && conf->magic->next) ? "set" : "NULL",
-		conf->last ? "set" : "NULL");
+                MODNAME ": apprentice conf=%x file=%s m=%s m->next=%s last=%s",
+                conf,
+                conf->magicfile ? conf->magicfile : "NULL",
+                conf->magic ? "set" : "NULL",
+                (conf->magic && conf->magic->next) ? "set" : "NULL",
+                conf->last ? "set" : "NULL");
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-		MODNAME ": apprentice read %d lines, %d rules, %d errors",
-		lineno, rule, errs);
+                MODNAME ": apprentice read %d lines, %d rules, %d errors",
+                lineno, rule, errs);
 #endif
 
 #if MIME_MAGIC_DEBUG
     prevm = 0;
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-		MODNAME ": apprentice test");
+                MODNAME ": apprentice test");
     for (m = conf->magic; m; m = m->next) {
-	if (apr_isprint((((unsigned long) m) >> 24) & 255) &&
-	    apr_isprint((((unsigned long) m) >> 16) & 255) &&
-	    apr_isprint((((unsigned long) m) >> 8) & 255) &&
-	    apr_isprint(((unsigned long) m) & 255)) {
-	    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-			MODNAME ": apprentice: POINTER CLOBBERED! "
-			"m=\"%c%c%c%c\" line=%d",
-			(((unsigned long) m) >> 24) & 255,
-			(((unsigned long) m) >> 16) & 255,
-			(((unsigned long) m) >> 8) & 255,
-			((unsigned long) m) & 255,
-			prevm ? prevm->lineno : -1);
-	    break;
-	}
-	prevm = m;
+        if (apr_isprint((((unsigned long) m) >> 24) & 255) &&
+            apr_isprint((((unsigned long) m) >> 16) & 255) &&
+            apr_isprint((((unsigned long) m) >> 8) & 255) &&
+            apr_isprint(((unsigned long) m) & 255)) {
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+                        MODNAME ": apprentice: POINTER CLOBBERED! "
+                        "m=\"%c%c%c%c\" line=%d",
+                        (((unsigned long) m) >> 24) & 255,
+                        (((unsigned long) m) >> 16) & 255,
+                        (((unsigned long) m) >> 8) & 255,
+                        ((unsigned long) m) & 255,
+                        prevm ? prevm->lineno : -1);
+            break;
+        }
+        prevm = m;
     }
 #endif
 
@@ -1030,34 +1030,34 @@ static int apprentice(server_rec *s, apr_pool_t *p)
 static unsigned long signextend(server_rec *s, struct magic *m, unsigned long v)
 {
     if (!(m->flag & UNSIGNED))
-	switch (m->type) {
-	    /*
-	     * Do not remove the casts below.  They are vital. When later
-	     * compared with the data, the sign extension must have happened.
-	     */
-	case BYTE:
-	    v = (char) v;
-	    break;
-	case SHORT:
-	case BESHORT:
-	case LESHORT:
-	    v = (short) v;
-	    break;
-	case DATE:
-	case BEDATE:
-	case LEDATE:
-	case LONG:
-	case BELONG:
-	case LELONG:
-	    v = (long) v;
-	    break;
-	case STRING:
-	    break;
-	default:
-	    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
-			MODNAME ": can't happen: m->type=%d", m->type);
-	    return -1;
-	}
+        switch (m->type) {
+            /*
+             * Do not remove the casts below.  They are vital. When later
+             * compared with the data, the sign extension must have happened.
+             */
+        case BYTE:
+            v = (char) v;
+            break;
+        case SHORT:
+        case BESHORT:
+        case LESHORT:
+            v = (short) v;
+            break;
+        case DATE:
+        case BEDATE:
+        case LEDATE:
+        case LONG:
+        case BELONG:
+        case LELONG:
+            v = (long) v;
+            break;
+        case STRING:
+            break;
+        default:
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
+                        MODNAME ": can't happen: m->type=%d", m->type);
+            return -1;
+        }
     return v;
 }
 
@@ -1069,7 +1069,7 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
     struct magic *m;
     char *t, *s;
     magic_server_config_rec *conf = (magic_server_config_rec *)
-		    ap_get_module_config(serv->module_config, &mime_magic_module);
+                    ap_get_module_config(serv->module_config, &mime_magic_module);
 
     /* allocate magic structure entry */
     m = (struct magic *) apr_pcalloc(p, sizeof(struct magic));
@@ -1077,11 +1077,11 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
     /* append to linked list */
     m->next = NULL;
     if (!conf->magic || !conf->last) {
-	conf->magic = conf->last = m;
+        conf->magic = conf->last = m;
     }
     else {
-	conf->last->next = m;
-	conf->last = m;
+        conf->last->next = m;
+        conf->last = m;
     }
 
     /* set values in magic structure */
@@ -1090,67 +1090,67 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
     m->lineno = lineno;
 
     while (*l == '>') {
-	++l;			/* step over */
-	m->cont_level++;
+        ++l;			/* step over */
+        m->cont_level++;
     }
 
     if (m->cont_level != 0 && *l == '(') {
-	++l;			/* step over */
-	m->flag |= INDIR;
+        ++l;			/* step over */
+        m->flag |= INDIR;
     }
 
     /* get offset, then skip over it */
     m->offset = (int) strtol(l, &t, 0);
     if (l == t) {
-	ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
-		    MODNAME ": offset %s invalid", l);
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
+                    MODNAME ": offset %s invalid", l);
     }
     l = t;
 
     if (m->flag & INDIR) {
-	m->in.type = LONG;
-	m->in.offset = 0;
-	/*
-	 * read [.lbs][+-]nnnnn)
-	 */
-	if (*l == '.') {
-	    switch (*++l) {
-	    case 'l':
-		m->in.type = LONG;
-		break;
-	    case 's':
-		m->in.type = SHORT;
-		break;
-	    case 'b':
-		m->in.type = BYTE;
-		break;
-	    default:
-		ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
-			MODNAME ": indirect offset type %c invalid", *l);
-		break;
-	    }
-	    l++;
-	}
-	s = l;
-	if (*l == '+' || *l == '-')
-	    l++;
-	if (apr_isdigit((unsigned char) *l)) {
-	    m->in.offset = strtol(l, &t, 0);
-	    if (*s == '-')
-		m->in.offset = -m->in.offset;
-	}
-	else
-	    t = l;
-	if (*t++ != ')') {
-	    ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
-			MODNAME ": missing ')' in indirect offset");
-	}
-	l = t;
+        m->in.type = LONG;
+        m->in.offset = 0;
+        /*
+         * read [.lbs][+-]nnnnn)
+         */
+        if (*l == '.') {
+            switch (*++l) {
+            case 'l':
+                m->in.type = LONG;
+                break;
+            case 's':
+                m->in.type = SHORT;
+                break;
+            case 'b':
+                m->in.type = BYTE;
+                break;
+            default:
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
+                        MODNAME ": indirect offset type %c invalid", *l);
+                break;
+            }
+            l++;
+        }
+        s = l;
+        if (*l == '+' || *l == '-')
+            l++;
+        if (apr_isdigit((unsigned char) *l)) {
+            m->in.offset = strtol(l, &t, 0);
+            if (*s == '-')
+                m->in.offset = -m->in.offset;
+        }
+        else
+            t = l;
+        if (*t++ != ')') {
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
+                        MODNAME ": missing ')' in indirect offset");
+        }
+        l = t;
     }
 
 
     while (apr_isdigit((unsigned char) *l))
-	++l;
+        ++l;
     EATAB;
 
 #define NBYTE           4
@@ -1166,122 +1166,122 @@ static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
 #define NLEDATE         6
 
     if (*l == 'u') {
-	++l;
-	m->flag |= UNSIGNED;
+        ++l;
+        m->flag |= UNSIGNED;
     }
 
     /* get type, skip it */
     if (strncmp(l, "byte", NBYTE) == 0) {
-	m->type = BYTE;
-	l += NBYTE;
+        m->type = BYTE;
+        l += NBYTE;
     }
     else if (strncmp(l, "short", NSHORT) == 0) {
-	m->type = SHORT;
-	l += NSHORT;
+        m->type = SHORT;
+        l += NSHORT;
     }
     else if (strncmp(l, "long", NLONG) == 0) {
-	m->type = LONG;
-	l += NLONG;
+        m->type = LONG;
+        l += NLONG;
     }
     else if (strncmp(l, "string", NSTRING) == 0) {
-	m->type = STRING;
-	l += NSTRING;
+        m->type = STRING;
+        l += NSTRING;
     }
     else if (strncmp(l, "date", NDATE) == 0) {
-	m->type = DATE;
-	l += NDATE;
+        m->type = DATE;
+        l += NDATE;
     }
     else if (strncmp(l, "beshort", NBESHORT) == 0) {
-	m->type = BESHORT;
-	l += NBESHORT;
+        m->type = BESHORT;
+        l += NBESHORT;
     }
     else if (strncmp(l, "belong", NBELONG) == 0) {
-	m->type = BELONG;
-	l += NBELONG;
+        m->type = BELONG;
+        l += NBELONG;
     }
     else if (strncmp(l, "bedate", NBEDATE) == 0) {
-	m->type = BEDATE;
-	l += NBEDATE;
+        m->type = BEDATE;
+        l += NBEDATE;
     }
     else if (strncmp(l, "leshort", NLESHORT) == 0) {
-	m->type = LESHORT;
-	l += NLESHORT;
+        m->type = LESHORT;
+        l += NLESHORT;
     }
     else if (strncmp(l, "lelong", NLELONG) == 0) {
-	m->type = LELONG;
-	l += NLELONG;
+        m->type = LELONG;
+        l += NLELONG;
     }
     else if (strncmp(l, "ledate", NLEDATE) == 0) {
-	m->type = LEDATE;
-	l += NLEDATE;
+        m->type = LEDATE;
+        l += NLEDATE;
     }
     else {
-	ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
-		    MODNAME ": type %s invalid", l);
-	return -1;
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
+                    MODNAME ": type %s invalid", l);
+        return -1;
     }
     /* New-style anding: "0 byte&0x80 =0x80 dynamically linked" */
     if (*l == '&') {
-	++l;
-	m->mask = signextend(serv, m, strtol(l, &l, 0));
+        ++l;
+        m->mask = signextend(serv, m, strtol(l, &l, 0));
     }
     else
-	m->mask = ~0L;
+        m->mask = ~0L;
     EATAB;
 
     switch (*l) {
     case '>':
     case '<':
-	/* Old-style anding: "0 byte &0x80 dynamically linked" */
+        /* Old-style anding: "0 byte &0x80 dynamically linked" */
     case '&':
     case '^':
     case '=':
-	m->reln = *l;
-	++l;
-	break;
+        m->reln = *l;
+        ++l;
+        break;
     case '!':
-	if (m->type != STRING) {
-	    m->reln = *l;
-	    ++l;
-	    break;
-	}
-	/* FALL THROUGH */
+        if (m->type != STRING) {
+            m->reln = *l;
+            ++l;
+            break;
+        }
+        /* FALL THROUGH */
     default:
-	if (*l == 'x' && apr_isspace(l[1])) {
-	    m->reln = *l;
-	    ++l;
-	    goto GetDesc;	/* Bill The Cat */
-	}
-	m->reln = '=';
-	break;
+        if (*l == 'x' && apr_isspace(l[1])) {
+            m->reln = *l;
+            ++l;
+            goto GetDesc;	/* Bill The Cat */
+        }
+        m->reln = '=';
+        break;
     }
     EATAB;
 
     if (getvalue(serv, m, &l))
-	return -1;
+        return -1;
     /*
      * now get last part - the description
      */
   GetDesc:
     EATAB;
     if (l[0] == '\b') {
-	++l;
-	m->nospflag = 1;
+        ++l;
+        m->nospflag = 1;
     }
     else if ((l[0] == '\\') && (l[1] == 'b')) {
-	++l;
-	++l;
-	m->nospflag = 1;
+        ++l;
+        ++l;
+        m->nospflag = 1;
     }
     else
-	m->nospflag = 0;
+        m->nospflag = 0;
     strncpy(m->desc, l, sizeof(m->desc) - 1);
     m->desc[sizeof(m->desc) - 1] = '\0';
 
 #if MIME_MAGIC_DEBUG
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, serv,
-		MODNAME ": parse line=%d m=%x next=%x cont=%d desc=%s",
-		lineno, m, m->next, m->cont_level, m->desc);
+                MODNAME ": parse line=%d m=%x next=%x cont=%d desc=%s",
+                lineno, m, m->next, m->cont_level, m->desc);
 #endif /* MIME_MAGIC_DEBUG */
 
     return 0;
@@ -1297,11 +1297,11 @@ static int getvalue(server_rec *s, struct magic *m, char **p)
     int slen;
 
     if (m->type == STRING) {
-	*p = getstr(s, *p, m->value.s, sizeof(m->value.s), &slen);
-	m->vallen = slen;
+        *p = getstr(s, *p, m->value.s, sizeof(m->value.s), &slen);
+        m->vallen = slen;
     }
     else if (m->reln != 'x')
-	m->value.l = signextend(s, m, strtol(*p, p, 0));
+        m->value.l = signextend(s, m, strtol(*p, p, 0));
     return 0;
 }
 
@@ -1311,7 +1311,7 @@ static int getvalue(server_rec *s, struct magic *m, char **p)
  * *slen. Return updated scan pointer as function result.
  */
 static char *getstr(server_rec *serv, register char *s, register char *p,
-		    int plen, int *slen)
+                    int plen, int *slen)
 {
     char *origs = s, *origp = p;
     char *pmax = p + plen - 1;
@@ -1319,98 +1319,98 @@ static char *getstr(server_rec *serv, register char *s, register char *p,
     register int val;
 
     while ((c = *s++) != '\0') {
-	if (apr_isspace(c))
-	    break;
-	if (p >= pmax) {
-	    ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
-			MODNAME ": string too long: %s", origs);
-	    break;
-	}
-	if (c == '\\') {
-	    switch (c = *s++) {
-
-	    case '\0':
-		goto out;
-
-	    default:
-		*p++ = (char) c;
-		break;
-
-	    case 'n':
-		*p++ = '\n';
-		break;
-
-	    case 'r':
-		*p++ = '\r';
-		break;
-
-	    case 'b':
-		*p++ = '\b';
-		break;
-
-	    case 't':
-		*p++ = '\t';
-		break;
-
-	    case 'f':
-		*p++ = '\f';
-		break;
-
-	    case 'v':
-		*p++ = '\v';
-		break;
-
-		/* \ and up to 3 octal digits */
-	    case '0':
-	    case '1':
-	    case '2':
-	    case '3':
-	    case '4':
-	    case '5':
-	    case '6':
-	    case '7':
-		val = c - '0';
-		c = *s++;	/* try for 2 */
-		if (c >= '0' && c <= '7') {
-		    val = (val << 3) | (c - '0');
-		    c = *s++;	/* try for 3 */
-		    if (c >= '0' && c <= '7')
-			val = (val << 3) | (c - '0');
-		    else
-			--s;
-		}
-		else
-		    --s;
-		*p++ = (char) val;
-		break;
-
-		/* \x and up to 3 hex digits */
-	    case 'x':
-		val = 'x';	/* Default if no digits */
-		c = hextoint(*s++);	/* Get next char */
-		if (c >= 0) {
-		    val = c;
-		    c = hextoint(*s++);
-		    if (c >= 0) {
-			val = (val << 4) + c;
-			c = hextoint(*s++);
-			if (c >= 0) {
-			    val = (val << 4) + c;
-			}
-			else
-			    --s;
-		    }
-		    else
-			--s;
-		}
-		else
-		    --s;
-		*p++ = (char) val;
-		break;
-	    }
-	}
-	else
-	    *p++ = (char) c;
+        if (apr_isspace(c))
+            break;
+        if (p >= pmax) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv,
+                        MODNAME ": string too long: %s", origs);
+            break;
+        }
+        if (c == '\\') {
+            switch (c = *s++) {
+
+            case '\0':
+                goto out;
+
+            default:
+                *p++ = (char) c;
+                break;
+
+            case 'n':
+                *p++ = '\n';
+                break;
+
+            case 'r':
+                *p++ = '\r';
+                break;
+
+            case 'b':
+                *p++ = '\b';
+                break;
+
+            case 't':
+                *p++ = '\t';
+                break;
+
+            case 'f':
+                *p++ = '\f';
+                break;
+
+            case 'v':
+                *p++ = '\v';
+                break;
+
+                /* \ and up to 3 octal digits */
+            case '0':
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+                val = c - '0';
+                c = *s++;	/* try for 2 */
+                if (c >= '0' && c <= '7') {
+                    val = (val << 3) | (c - '0');
+                    c = *s++;	/* try for 3 */
+                    if (c >= '0' && c <= '7')
+                        val = (val << 3) | (c - '0');
+                    else
+                        --s;
+                }
+                else
+                    --s;
+                *p++ = (char) val;
+                break;
+
+                /* \x and up to 3 hex digits */
+            case 'x':
+                val = 'x';	/* Default if no digits */
+                c = hextoint(*s++);	/* Get next char */
+                if (c >= 0) {
+                    val = c;
+                    c = hextoint(*s++);
+                    if (c >= 0) {
+                        val = (val << 4) + c;
+                        c = hextoint(*s++);
+                        if (c >= 0) {
+                            val = (val << 4) + c;
+                        }
+                        else
+                            --s;
+                    }
+                    else
+                        --s;
+                }
+                else
+                    --s;
+                *p++ = (char) val;
+                break;
+            }
+        }
+        else
+            *p++ = (char) c;
     }
   out:
     *p = '\0';
@@ -1423,11 +1423,11 @@ static char *getstr(server_rec *serv, register char *s, register char *p,
 static int hextoint(int c)
 {
     if (apr_isdigit(c))
-	return c - '0';
+        return c - '0';
     if ((c >= 'a') && (c <= 'f'))
-	return c + 10 - 'a';
+        return c + 10 - 'a';
     if ((c >= 'A') && (c <= 'F'))
-	return c + 10 - 'A';
+        return c + 10 - 'A';
     return -1;
 }
 
@@ -1441,53 +1441,53 @@ static int fsmagic(request_rec *r, const char *fn)
 {
     switch (r->finfo.filetype) {
     case APR_DIR:
-	magic_rsl_puts(r, DIR_MAGIC_TYPE);
-	return DONE;
+        magic_rsl_puts(r, DIR_MAGIC_TYPE);
+        return DONE;
     case APR_CHR:
-	/*
-	 * (void) magic_rsl_printf(r,"character special (%d/%d)",
-	 * major(sb->st_rdev), minor(sb->st_rdev));
-	 */
-	(void) magic_rsl_puts(r, MIME_BINARY_UNKNOWN);
-	return DONE;
+        /*
+         * (void) magic_rsl_printf(r,"character special (%d/%d)",
+         * major(sb->st_rdev), minor(sb->st_rdev));
+         */
+        (void) magic_rsl_puts(r, MIME_BINARY_UNKNOWN);
+        return DONE;
     case APR_BLK:
-	/*
-	 * (void) magic_rsl_printf(r,"block special (%d/%d)",
-	 * major(sb->st_rdev), minor(sb->st_rdev));
-	 */
-	(void) magic_rsl_puts(r, MIME_BINARY_UNKNOWN);
-	return DONE;
-	/* TODO add code to handle V7 MUX and Blit MUX files */
+        /*
+         * (void) magic_rsl_printf(r,"block special (%d/%d)",
+         * major(sb->st_rdev), minor(sb->st_rdev));
+         */
+        (void) magic_rsl_puts(r, MIME_BINARY_UNKNOWN);
+        return DONE;
+        /* TODO add code to handle V7 MUX and Blit MUX files */
     case APR_PIPE:
-	/*
-	 * magic_rsl_puts(r,"fifo (named pipe)");
-	 */
-	(void) magic_rsl_puts(r, MIME_BINARY_UNKNOWN);
-	return DONE;
+        /*
+         * magic_rsl_puts(r,"fifo (named pipe)");
+         */
+        (void) magic_rsl_puts(r, MIME_BINARY_UNKNOWN);
+        return DONE;
     case APR_LNK:
-	/* We used stat(), the only possible reason for this is that the
-	 * symlink is broken.
-	 */
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-		    MODNAME ": broken symlink (%s)", fn);
-	return HTTP_INTERNAL_SERVER_ERROR;
+        /* We used stat(), the only possible reason for this is that the
+         * symlink is broken.
+         */
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    MODNAME ": broken symlink (%s)", fn);
+        return HTTP_INTERNAL_SERVER_ERROR;
     case APR_SOCK:
-	magic_rsl_puts(r, MIME_BINARY_UNKNOWN);
-	return DONE;
+        magic_rsl_puts(r, MIME_BINARY_UNKNOWN);
+        return DONE;
     case APR_REG:
-	break;
+        break;
     default:
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-		      MODNAME ": invalid file type %d.", r->finfo.filetype);
-	return HTTP_INTERNAL_SERVER_ERROR;
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                      MODNAME ": invalid file type %d.", r->finfo.filetype);
+        return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     /*
      * regular file, check next possibility
      */
     if (r->finfo.size == 0) {
-	magic_rsl_puts(r, MIME_TEXT_UNKNOWN);
-	return DONE;
+        magic_rsl_puts(r, MIME_TEXT_UNKNOWN);
+        return DONE;
     }
     return OK;
 }
@@ -1496,11 +1496,11 @@ static int fsmagic(request_rec *r, const char *fn)
  * softmagic - lookup one file in database (already read from /etc/magic by
  * apprentice.c). Passed the name and FILE * of one file to be typed.
  */
-		/* ARGSUSED1 *//* nbytes passed for regularity, maybe need later */
+                /* ARGSUSED1 *//* nbytes passed for regularity, maybe need later */
 static int softmagic(request_rec *r, unsigned char *buf, apr_size_t nbytes)
 {
     if (match(r, buf, nbytes))
-	return 1;
+        return 1;
 
     return 0;
 }
@@ -1540,155 +1540,155 @@ static int match(request_rec *r, unsigned char *s, apr_size_t nbytes)
     int need_separator = 0;
     union VALUETYPE p;
     magic_server_config_rec *conf = (magic_server_config_rec *)
-		ap_get_module_config(r->server->module_config, &mime_magic_module);
+                ap_get_module_config(r->server->module_config, &mime_magic_module);
     struct magic *m;
 
 #if MIME_MAGIC_DEBUG
     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		MODNAME ": match conf=%x file=%s m=%s m->next=%s last=%s",
-		conf,
-		conf->magicfile ? conf->magicfile : "NULL",
-		conf->magic ? "set" : "NULL",
-		(conf->magic && conf->magic->next) ? "set" : "NULL",
-		conf->last ? "set" : "NULL");
+                MODNAME ": match conf=%x file=%s m=%s m->next=%s last=%s",
+                conf,
+                conf->magicfile ? conf->magicfile : "NULL",
+                conf->magic ? "set" : "NULL",
+                (conf->magic && conf->magic->next) ? "set" : "NULL",
+                conf->last ? "set" : "NULL");
 #endif
 
 #if MIME_MAGIC_DEBUG
     for (m = conf->magic; m; m = m->next) {
-	if (apr_isprint((((unsigned long) m) >> 24) & 255) &&
-	    apr_isprint((((unsigned long) m) >> 16) & 255) &&
-	    apr_isprint((((unsigned long) m) >> 8) & 255) &&
-	    apr_isprint(((unsigned long) m) & 255)) {
-	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-			MODNAME ": match: POINTER CLOBBERED! "
-			"m=\"%c%c%c%c\"",
-			(((unsigned long) m) >> 24) & 255,
-			(((unsigned long) m) >> 16) & 255,
-			(((unsigned long) m) >> 8) & 255,
-			((unsigned long) m) & 255);
-	    break;
-	}
+        if (apr_isprint((((unsigned long) m) >> 24) & 255) &&
+            apr_isprint((((unsigned long) m) >> 16) & 255) &&
+            apr_isprint((((unsigned long) m) >> 8) & 255) &&
+            apr_isprint(((unsigned long) m) & 255)) {
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                        MODNAME ": match: POINTER CLOBBERED! "
+                        "m=\"%c%c%c%c\"",
+                        (((unsigned long) m) >> 24) & 255,
+                        (((unsigned long) m) >> 16) & 255,
+                        (((unsigned long) m) >> 8) & 255,
+                        ((unsigned long) m) & 255);
+            break;
+        }
     }
 #endif
 
     for (m = conf->magic; m; m = m->next) {
 #if MIME_MAGIC_DEBUG
-	rule_counter++;
-	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		    MODNAME ": line=%d desc=%s", m->lineno, m->desc);
+        rule_counter++;
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    MODNAME ": line=%d desc=%s", m->lineno, m->desc);
 #endif
 
-	/* check if main entry matches */
-	if (!mget(r, &p, s, m, nbytes) ||
-	    !mcheck(r, &p, m)) {
-	    struct magic *m_cont;
+        /* check if main entry matches */
+        if (!mget(r, &p, s, m, nbytes) ||
+            !mcheck(r, &p, m)) {
+            struct magic *m_cont;
 
-	    /*
-	     * main entry didn't match, flush its continuations
-	     */
-	    if (!m->next || (m->next->cont_level == 0)) {
-		continue;
-	    }
+            /*
+             * main entry didn't match, flush its continuations
+             */
+            if (!m->next || (m->next->cont_level == 0)) {
+                continue;
+            }
 
-	    m_cont = m->next;
-	    while (m_cont && (m_cont->cont_level != 0)) {
+            m_cont = m->next;
+            while (m_cont && (m_cont->cont_level != 0)) {
 #if MIME_MAGIC_DEBUG
-		rule_counter++;
-		ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-			MODNAME ": line=%d mc=%x mc->next=%x cont=%d desc=%s",
-			    m_cont->lineno, m_cont,
-			    m_cont->next, m_cont->cont_level,
-			    m_cont->desc);
+                rule_counter++;
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                        MODNAME ": line=%d mc=%x mc->next=%x cont=%d desc=%s",
+                            m_cont->lineno, m_cont,
+                            m_cont->next, m_cont->cont_level,
+                            m_cont->desc);
 #endif
-		/*
-		 * this trick allows us to keep *m in sync when the continue
-		 * advances the pointer
-		 */
-		m = m_cont;
-		m_cont = m_cont->next;
-	    }
-	    continue;
-	}
-
-	/* if we get here, the main entry rule was a match */
-	/* this will be the last run through the loop */
+                /*
+                 * this trick allows us to keep *m in sync when the continue
+                 * advances the pointer
+                 */
+                m = m_cont;
+                m_cont = m_cont->next;
+            }
+            continue;
+        }
+
+        /* if we get here, the main entry rule was a match */
+        /* this will be the last run through the loop */
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		    MODNAME ": rule matched, line=%d type=%d %s",
-		    m->lineno, m->type,
-		    (m->type == STRING) ? m->value.s : "");
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    MODNAME ": rule matched, line=%d type=%d %s",
+                    m->lineno, m->type,
+                    (m->type == STRING) ? m->value.s : "");
 #endif
 
-	/* print the match */
-	mprint(r, &p, m);
-
-	/*
-	 * If we printed something, we'll need to print a blank before we
-	 * print something else.
-	 */
-	if (m->desc[0])
-	    need_separator = 1;
-	/* and any continuations that match */
-	cont_level++;
-	/*
-	 * while (m && m->next && m->next->cont_level != 0 && ( m = m->next
-	 * ))
-	 */
-	m = m->next;
-	while (m && (m->cont_level != 0)) {
+        /* print the match */
+        mprint(r, &p, m);
+
+        /*
+         * If we printed something, we'll need to print a blank before we
+         * print something else.
+         */
+        if (m->desc[0])
+            need_separator = 1;
+        /* and any continuations that match */
+        cont_level++;
+        /*
+         * while (m && m->next && m->next->cont_level != 0 && ( m = m->next
+         * ))
+         */
+        m = m->next;
+        while (m && (m->cont_level != 0)) {
 #if MIME_MAGIC_DEBUG
-	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-			MODNAME ": match line=%d cont=%d type=%d %s",
-			m->lineno, m->cont_level, m->type,
-			(m->type == STRING) ? m->value.s : "");
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                        MODNAME ": match line=%d cont=%d type=%d %s",
+                        m->lineno, m->cont_level, m->type,
+                        (m->type == STRING) ? m->value.s : "");
 #endif
-	    if (cont_level >= m->cont_level) {
-		if (cont_level > m->cont_level) {
-		    /*
-		     * We're at the end of the level "cont_level"
-		     * continuations.
-		     */
-		    cont_level = m->cont_level;
-		}
-		if (mget(r, &p, s, m, nbytes) &&
-		    mcheck(r, &p, m)) {
-		    /*
-		     * This continuation matched. Print its message, with a
-		     * blank before it if the previous item printed and this
-		     * item isn't empty.
-		     */
-		    /* space if previous printed */
-		    if (need_separator
-			&& (m->nospflag == 0)
-			&& (m->desc[0] != '\0')
-			) {
-			(void) magic_rsl_putchar(r, ' ');
-			need_separator = 0;
-		    }
-		    mprint(r, &p, m);
-		    if (m->desc[0])
-			need_separator = 1;
-
-		    /*
-		     * If we see any continuations at a higher level, process
-		     * them.
-		     */
-		    cont_level++;
-		}
-	    }
-
-	    /* move to next continuation record */
-	    m = m->next;
-	}
+            if (cont_level >= m->cont_level) {
+                if (cont_level > m->cont_level) {
+                    /*
+                     * We're at the end of the level "cont_level"
+                     * continuations.
+                     */
+                    cont_level = m->cont_level;
+                }
+                if (mget(r, &p, s, m, nbytes) &&
+                    mcheck(r, &p, m)) {
+                    /*
+                     * This continuation matched. Print its message, with a
+                     * blank before it if the previous item printed and this
+                     * item isn't empty.
+                     */
+                    /* space if previous printed */
+                    if (need_separator
+                        && (m->nospflag == 0)
+                        && (m->desc[0] != '\0')
+                        ) {
+                        (void) magic_rsl_putchar(r, ' ');
+                        need_separator = 0;
+                    }
+                    mprint(r, &p, m);
+                    if (m->desc[0])
+                        need_separator = 1;
+
+                    /*
+                     * If we see any continuations at a higher level, process
+                     * them.
+                     */
+                    cont_level++;
+                }
+            }
+
+            /* move to next continuation record */
+            m = m->next;
+        }
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		    MODNAME ": matched after %d rules", rule_counter);
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    MODNAME ": matched after %d rules", rule_counter);
 #endif
-	return 1;		/* all through */
+        return 1;		/* all through */
     }
 #if MIME_MAGIC_DEBUG
     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		MODNAME ": failed after %d rules", rule_counter);
+                MODNAME ": failed after %d rules", rule_counter);
 #endif
     return 0;			/* no match at all */
 }
@@ -1701,42 +1701,42 @@ static void mprint(request_rec *r, union VALUETYPE *p, struct magic *m)
 
     switch (m->type) {
     case BYTE:
-	v = p->b;
-	break;
+        v = p->b;
+        break;
 
     case SHORT:
     case BESHORT:
     case LESHORT:
-	v = p->h;
-	break;
+        v = p->h;
+        break;
 
     case LONG:
     case BELONG:
     case LELONG:
-	v = p->l;
-	break;
+        v = p->l;
+        break;
 
     case STRING:
-	if (m->reln == '=') {
-	    (void) magic_rsl_printf(r, m->desc, m->value.s);
-	}
-	else {
-	    (void) magic_rsl_printf(r, m->desc, p->s);
-	}
-	return;
+        if (m->reln == '=') {
+            (void) magic_rsl_printf(r, m->desc, m->value.s);
+        }
+        else {
+            (void) magic_rsl_printf(r, m->desc, p->s);
+        }
+        return;
 
     case DATE:
     case BEDATE:
     case LEDATE:
         apr_ctime(time_str, apr_time_from_sec(*(time_t *)&p->l));
         pp = time_str;
-	(void) magic_rsl_printf(r, m->desc, pp);
-	return;
+        (void) magic_rsl_printf(r, m->desc, pp);
+        return;
     default:
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-		    MODNAME ": invalid m->type (%d) in mprint().",
-		    m->type);
-	return;
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    MODNAME ": invalid m->type (%d) in mprint().",
+                    m->type);
+        return;
     }
 
     v = signextend(r->server, m, v) & m->mask;
@@ -1755,71 +1755,71 @@ static int mconvert(request_rec *r, union VALUETYPE *p, struct magic *m)
     case SHORT:
     case LONG:
     case DATE:
-	return 1;
+        return 1;
     case STRING:
-	/* Null terminate and eat the return */
-	p->s[sizeof(p->s) - 1] = '\0';
-	if ((rt = strchr(p->s, '\n')) != NULL)
-	    *rt = '\0';
-	return 1;
+        /* Null terminate and eat the return */
+        p->s[sizeof(p->s) - 1] = '\0';
+        if ((rt = strchr(p->s, '\n')) != NULL)
+            *rt = '\0';
+        return 1;
     case BESHORT:
-	p->h = (short) ((p->hs[0] << 8) | (p->hs[1]));
-	return 1;
+        p->h = (short) ((p->hs[0] << 8) | (p->hs[1]));
+        return 1;
     case BELONG:
     case BEDATE:
-	p->l = (long)
-	    ((p->hl[0] << 24) | (p->hl[1] << 16) | (p->hl[2] << 8) | (p->hl[3]));
-	return 1;
+        p->l = (long)
+            ((p->hl[0] << 24) | (p->hl[1] << 16) | (p->hl[2] << 8) | (p->hl[3]));
+        return 1;
     case LESHORT:
-	p->h = (short) ((p->hs[1] << 8) | (p->hs[0]));
-	return 1;
+        p->h = (short) ((p->hs[1] << 8) | (p->hs[0]));
+        return 1;
     case LELONG:
     case LEDATE:
-	p->l = (long)
-	    ((p->hl[3] << 24) | (p->hl[2] << 16) | (p->hl[1] << 8) | (p->hl[0]));
-	return 1;
+        p->l = (long)
+            ((p->hl[3] << 24) | (p->hl[2] << 16) | (p->hl[1] << 8) | (p->hl[0]));
+        return 1;
     default:
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-		    MODNAME ": invalid type %d in mconvert().", m->type);
-	return 0;
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    MODNAME ": invalid type %d in mconvert().", m->type);
+        return 0;
     }
 }
 
 
 static int mget(request_rec *r, union VALUETYPE *p, unsigned char *s,
-		struct magic *m, apr_size_t nbytes)
+                struct magic *m, apr_size_t nbytes)
 {
     long offset = m->offset;
 
     if (offset + sizeof(union VALUETYPE) > nbytes)
-	          return 0;
+                  return 0;
 
     memcpy(p, s + offset, sizeof(union VALUETYPE));
 
     if (!mconvert(r, p, m))
-	return 0;
+        return 0;
 
     if (m->flag & INDIR) {
 
-	switch (m->in.type) {
-	case BYTE:
-	    offset = p->b + m->in.offset;
-	    break;
-	case SHORT:
-	    offset = p->h + m->in.offset;
-	    break;
-	case LONG:
-	    offset = p->l + m->in.offset;
-	    break;
-	}
+        switch (m->in.type) {
+        case BYTE:
+            offset = p->b + m->in.offset;
+            break;
+        case SHORT:
+            offset = p->h + m->in.offset;
+            break;
+        case LONG:
+            offset = p->l + m->in.offset;
+            break;
+        }
 
-	if (offset + sizeof(union VALUETYPE) > nbytes)
-	              return 0;
+        if (offset + sizeof(union VALUETYPE) > nbytes)
+                      return 0;
 
-	memcpy(p, s + offset, sizeof(union VALUETYPE));
+        memcpy(p, s + offset, sizeof(union VALUETYPE));
 
-	if (!mconvert(r, p, m))
-	    return 0;
+        if (!mconvert(r, p, m))
+            return 0;
     }
     return 1;
 }
@@ -1831,21 +1831,21 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     int matched;
 
     if ((m->value.s[0] == 'x') && (m->value.s[1] == '\0')) {
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-		    MODNAME ": BOINK");
-	return 1;
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    MODNAME ": BOINK");
+        return 1;
     }
 
     switch (m->type) {
     case BYTE:
-	v = p->b;
-	break;
+        v = p->b;
+        break;
 
     case SHORT:
     case BESHORT:
     case LESHORT:
-	v = p->h;
-	break;
+        v = p->h;
+        break;
 
     case LONG:
     case BELONG:
@@ -1853,32 +1853,32 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     case DATE:
     case BEDATE:
     case LEDATE:
-	v = p->l;
-	break;
+        v = p->l;
+        break;
 
     case STRING:
-	l = 0;
-	/*
-	 * What we want here is: v = strncmp(m->value.s, p->s, m->vallen);
-	 * but ignoring any nulls.  bcmp doesn't give -/+/0 and isn't
-	 * universally available anyway.
-	 */
-	v = 0;
-	{
-	    register unsigned char *a = (unsigned char *) m->value.s;
-	    register unsigned char *b = (unsigned char *) p->s;
-	    register int len = m->vallen;
-
-	    while (--len >= 0)
-		if ((v = *b++ - *a++) != 0)
-		    break;
-	}
-	break;
+        l = 0;
+        /*
+         * What we want here is: v = strncmp(m->value.s, p->s, m->vallen);
+         * but ignoring any nulls.  bcmp doesn't give -/+/0 and isn't
+         * universally available anyway.
+         */
+        v = 0;
+        {
+            register unsigned char *a = (unsigned char *) m->value.s;
+            register unsigned char *b = (unsigned char *) p->s;
+            register int len = m->vallen;
+
+            while (--len >= 0)
+                if ((v = *b++ - *a++) != 0)
+                    break;
+        }
+        break;
     default:
-	/*  bogosity, pretend that it just wasn't a match */
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-		    MODNAME ": invalid type %d in mcheck().", m->type);
-	return 0;
+        /*  bogosity, pretend that it just wasn't a match */
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    MODNAME ": invalid type %d in mcheck().", m->type);
+        return 0;
     }
 
     v = signextend(r->server, m, v) & m->mask;
@@ -1886,85 +1886,85 @@ static int mcheck(request_rec *r, union VALUETYPE *p, struct magic *m)
     switch (m->reln) {
     case 'x':
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		    "%lu == *any* = 1", v);
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    "%lu == *any* = 1", v);
 #endif
-	matched = 1;
-	break;
+        matched = 1;
+        break;
 
     case '!':
-	matched = v != l;
+        matched = v != l;
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		    "%lu != %lu = %d", v, l, matched);
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    "%lu != %lu = %d", v, l, matched);
 #endif
-	break;
+        break;
 
     case '=':
-	matched = v == l;
+        matched = v == l;
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		    "%lu == %lu = %d", v, l, matched);
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    "%lu == %lu = %d", v, l, matched);
 #endif
-	break;
+        break;
 
     case '>':
-	if (m->flag & UNSIGNED) {
-	    matched = v > l;
+        if (m->flag & UNSIGNED) {
+            matched = v > l;
 #if MIME_MAGIC_DEBUG
-	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-			"%lu > %lu = %d", v, l, matched);
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                        "%lu > %lu = %d", v, l, matched);
 #endif
-	}
-	else {
-	    matched = (long) v > (long) l;
+        }
+        else {
+            matched = (long) v > (long) l;
 #if MIME_MAGIC_DEBUG
-	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-			"%ld > %ld = %d", v, l, matched);
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                        "%ld > %ld = %d", v, l, matched);
 #endif
-	}
-	break;
+        }
+        break;
 
     case '<':
-	if (m->flag & UNSIGNED) {
-	    matched = v < l;
+        if (m->flag & UNSIGNED) {
+            matched = v < l;
 #if MIME_MAGIC_DEBUG
-	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-			"%lu < %lu = %d", v, l, matched);
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                        "%lu < %lu = %d", v, l, matched);
 #endif
-	}
-	else {
-	    matched = (long) v < (long) l;
+        }
+        else {
+            matched = (long) v < (long) l;
 #if MIME_MAGIC_DEBUG
-	    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-			"%ld < %ld = %d", v, l, matched);
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                        "%ld < %ld = %d", v, l, matched);
 #endif
-	}
-	break;
+        }
+        break;
 
     case '&':
-	matched = (v & l) == l;
+        matched = (v & l) == l;
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		    "((%lx & %lx) == %lx) = %d", v, l, l, matched);
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    "((%lx & %lx) == %lx) = %d", v, l, l, matched);
 #endif
-	break;
+        break;
 
     case '^':
-	matched = (v & l) != l;
+        matched = (v & l) != l;
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		    "((%lx & %lx) != %lx) = %d", v, l, l, matched);
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    "((%lx & %lx) != %lx) = %d", v, l, l, matched);
 #endif
-	break;
+        break;
 
     default:
-	/* bogosity, pretend it didn't match */
-	matched = 0;
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-		    MODNAME ": mcheck: can't happen: invalid relation %d.",
-		    m->reln);
-	break;
+        /* bogosity, pretend it didn't match */
+        matched = 0;
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                    MODNAME ": mcheck: can't happen: invalid relation %d.",
+                    m->reln);
+        break;
     }
 
     return matched;
@@ -1991,20 +1991,20 @@ static int ascmagic(request_rec *r, unsigned char *buf, apr_size_t nbytes)
      * input.
      */
     if (*buf == '.') {
-	unsigned char *tp = buf + 1;
-
-	while (apr_isspace(*tp))
-	    ++tp;		/* skip leading whitespace */
-	if ((apr_isalnum(*tp) || *tp == '\\') &&
-	     (apr_isalnum(*(tp + 1)) || *tp == '"')) {
-	    magic_rsl_puts(r, "application/x-troff");
-	    return 1;
-	}
+        unsigned char *tp = buf + 1;
+
+        while (apr_isspace(*tp))
+            ++tp;		/* skip leading whitespace */
+        if ((apr_isalnum(*tp) || *tp == '\\') &&
+             (apr_isalnum(*(tp + 1)) || *tp == '"')) {
+            magic_rsl_puts(r, "application/x-troff");
+            return 1;
+        }
     }
     if ((*buf == 'c' || *buf == 'C') && apr_isspace(*(buf + 1))) {
-	/* Fortran */
-	magic_rsl_puts(r, "text/plain");
-	return 1;
+        /* Fortran */
+        magic_rsl_puts(r, "text/plain");
+        return 1;
     }
 
     /* look for tokens from names.h - this is expensive!, so we'll limit
@@ -2015,26 +2015,26 @@ static int ascmagic(request_rec *r, unsigned char *buf, apr_size_t nbytes)
     s[small_nbytes] = '\0';
     has_escapes = (memchr(s, '\033', small_nbytes) != NULL);
     while ((token = apr_strtok((char *) s, " \t\n\r\f", &strtok_state)) != NULL) {
-	s = NULL;		/* make apr_strtok() keep on tokin' */
-	for (p = names; p < names + NNAMES; p++) {
-	    if (STREQ(p->name, token)) {
-		magic_rsl_puts(r, types[p->type]);
-		if (has_escapes)
-		    magic_rsl_puts(r, " (with escape sequences)");
-		return 1;
-	    }
-	}
+        s = NULL;		/* make apr_strtok() keep on tokin' */
+        for (p = names; p < names + NNAMES; p++) {
+            if (STREQ(p->name, token)) {
+                magic_rsl_puts(r, types[p->type]);
+                if (has_escapes)
+                    magic_rsl_puts(r, " (with escape sequences)");
+                return 1;
+            }
+        }
     }
 
     switch (is_tar(buf, nbytes)) {
     case 1:
-	/* V7 tar archive */
-	magic_rsl_puts(r, "application/x-tar");
-	return 1;
+        /* V7 tar archive */
+        magic_rsl_puts(r, "application/x-tar");
+        return 1;
     case 2:
-	/* POSIX tar archive */
-	magic_rsl_puts(r, "application/x-tar");
-	return 1;
+        /* POSIX tar archive */
+        magic_rsl_puts(r, "application/x-tar");
+        return 1;
     }
 
     /* all else fails, but it is ascii... */
@@ -2061,23 +2061,23 @@ static struct {
      * ending with .Z
      */
     {
-	"\037\235", 2, {
-	    "gzip", "-dcq", NULL
-	}, 0, "x-compress"
+        "\037\235", 2, {
+            "gzip", "-dcq", NULL
+        }, 0, "x-compress"
     },
     {
-	"\037\213", 2, {
-	    "gzip", "-dcq", NULL
-	}, 1, "x-gzip"
+        "\037\213", 2, {
+            "gzip", "-dcq", NULL
+        }, 1, "x-gzip"
     },
     /*
      * XXX pcat does not work, cause I don't know how to make it read stdin,
      * so we use gzip
      */
     {
-	"\037\036", 2, {
-	    "gzip", "-dcq", NULL
-	}, 0, "x-gzip"
+        "\037\036", 2, {
+            "gzip", "-dcq", NULL
+        }, 0, "x-gzip"
     },
 };
 
@@ -2090,22 +2090,22 @@ static int zmagic(request_rec *r, unsigned char *buf, apr_size_t nbytes)
     int i;
 
     for (i = 0; i < ncompr; i++) {
-	if (nbytes < compr[i].maglen)
-	    continue;
-	if (memcmp(buf, compr[i].magic, compr[i].maglen) == 0)
-	    break;
+        if (nbytes < compr[i].maglen)
+            continue;
+        if (memcmp(buf, compr[i].magic, compr[i].maglen) == 0)
+            break;
     }
 
     if (i == ncompr)
-	return 0;
+        return 0;
 
     if ((newsize = uncompress(r, i, &newbuf, nbytes)) > 0) {
-	if (tryit(r, newbuf, newsize, 0) != OK) {
+        if (tryit(r, newbuf, newsize, 0) != OK) {
             return 0;
         }
 
-	/* set encoding type in the request record */
-	r->content_encoding = compr[i].encoding;
+        /* set encoding type in the request record */
+        r->content_encoding = compr[i].encoding;
     }
     return 1;
 }
@@ -2170,7 +2170,7 @@ static int create_uncompress_child(struct uncompress_parms *parm, apr_pool_t *cn
 }
 
 static int uncompress(request_rec *r, int method, 
-		      unsigned char **newch, apr_size_t n)
+                      unsigned char **newch, apr_size_t n)
 {
     struct uncompress_parms parm;
     apr_file_t *pipe_out = NULL;
@@ -2188,18 +2188,18 @@ static int uncompress(request_rec *r, int method,
         return -1;
 
     if ((rv = create_uncompress_child(&parm, sub_context, &pipe_out)) != APR_SUCCESS) {
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
-		    MODNAME ": couldn't spawn uncompress process: %s", r->uri);
-	return -1;
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+                    MODNAME ": couldn't spawn uncompress process: %s", r->uri);
+        return -1;
     }
 
     *newch = (unsigned char *) apr_palloc(r->pool, n);
     rv = apr_file_read(pipe_out, *newch, &n);
     if (n == 0) {
-	apr_pool_destroy(sub_context);
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
-	    MODNAME ": read failed from uncompress of %s", r->filename);
-	return -1;
+        apr_pool_destroy(sub_context);
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
+            MODNAME ": read failed from uncompress of %s", r->filename);
+        return -1;
     }
     apr_pool_destroy(sub_context);
     return n;
@@ -2233,29 +2233,29 @@ static int is_tar(unsigned char *buf, apr_size_t nbytes)
     register char *p;
 
     if (nbytes < sizeof(union record))
-	       return 0;
+               return 0;
 
     recsum = from_oct(8, header->header.chksum);
 
     sum = 0;
     p = header->charptr;
     for (i = sizeof(union record); --i >= 0;) {
-	/*
-	 * We can't use unsigned char here because of old compilers, e.g. V7.
-	 */
-	sum += 0xFF & *p++;
+        /*
+         * We can't use unsigned char here because of old compilers, e.g. V7.
+         */
+        sum += 0xFF & *p++;
     }
 
     /* Adjust checksum to count the "chksum" field as blanks. */
     for (i = sizeof(header->header.chksum); --i >= 0;)
-	sum -= 0xFF & header->header.chksum[i];
+        sum -= 0xFF & header->header.chksum[i];
     sum += ' ' * sizeof header->header.chksum;
 
     if (sum != recsum)
-	return 0;		/* Not a tar archive */
+        return 0;		/* Not a tar archive */
 
     if (0 == strcmp(header->header.magic, TMAGIC))
-	return 2;		/* Unix Standard tar archive */
+        return 2;		/* Unix Standard tar archive */
 
     return 1;			/* Old fashioned tar archive */
 }
@@ -2271,18 +2271,18 @@ static long from_oct(int digs, char *where)
     register long value;
 
     while (apr_isspace(*where)) {	/* Skip spaces */
-	where++;
-	if (--digs <= 0)
-	    return -1;		/* All blank field */
+        where++;
+        if (--digs <= 0)
+            return -1;		/* All blank field */
     }
     value = 0;
     while (digs > 0 && isodigit(*where)) {	/* Scan til nonoctal */
-	value = (value << 3) | (*where++ - '0');
-	--digs;
+        value = (value << 3) | (*where++ - '0');
+        --digs;
     }
 
     if (digs > 0 && *where && !apr_isspace(*where))
-	return -1;		/* Ended on non-space/nul */
+        return -1;		/* Ended on non-space/nul */
 
     return value;
 }
@@ -2305,18 +2305,18 @@ static int revision_suffix(request_rec *r)
 
 #if MIME_MAGIC_DEBUG
     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		MODNAME ": revision_suffix checking %s", r->filename);
+                MODNAME ": revision_suffix checking %s", r->filename);
 #endif /* MIME_MAGIC_DEBUG */
 
     /* check for recognized revision suffix */
     suffix_pos = strlen(r->filename) - 1;
     if (!apr_isdigit(r->filename[suffix_pos])) {
-	return 0;
+        return 0;
     }
     while (suffix_pos >= 0 && apr_isdigit(r->filename[suffix_pos]))
-	suffix_pos--;
+        suffix_pos--;
     if (suffix_pos < 0 || r->filename[suffix_pos] != '@') {
-	return 0;
+        return 0;
     }
 
     /* perform sub-request for the file name without the suffix */
@@ -2324,31 +2324,31 @@ static int revision_suffix(request_rec *r)
     sub_filename = apr_pstrndup(r->pool, r->filename, suffix_pos);
 #if MIME_MAGIC_DEBUG
     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		MODNAME ": subrequest lookup for %s", sub_filename);
+                MODNAME ": subrequest lookup for %s", sub_filename);
 #endif /* MIME_MAGIC_DEBUG */
     sub = ap_sub_req_lookup_file(sub_filename, r, NULL);
 
     /* extract content type/encoding/language from sub-request */
     if (sub->content_type) {
-	ap_set_content_type(r, apr_pstrdup(r->pool, sub->content_type));
+        ap_set_content_type(r, apr_pstrdup(r->pool, sub->content_type));
 #if MIME_MAGIC_DEBUG
-	ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-		    MODNAME ": subrequest %s got %s",
-		    sub_filename, r->content_type);
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                    MODNAME ": subrequest %s got %s",
+                    sub_filename, r->content_type);
 #endif /* MIME_MAGIC_DEBUG */
-	if (sub->content_encoding)
-	    r->content_encoding =
-		apr_pstrdup(r->pool, sub->content_encoding);
+        if (sub->content_encoding)
+            r->content_encoding =
+                apr_pstrdup(r->pool, sub->content_encoding);
         if (sub->content_languages) {
             int n;
-	    r->content_languages = apr_array_copy(r->pool, 
+            r->content_languages = apr_array_copy(r->pool, 
                                                   sub->content_languages);
             for (n = 0; n < r->content_languages->nelts; ++n) {
                 char **lang = ((char **)r->content_languages->elts) + n;
                 *lang = apr_pstrdup(r->pool, *lang);
             }
         }
-	result = 1;
+        result = 1;
     }
 
     /* clean up */
@@ -2372,38 +2372,38 @@ static int magic_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server
 
     main_conf = ap_get_module_config(main_server->module_config, &mime_magic_module);
     for (s = main_server; s; s = s->next) {
-	conf = ap_get_module_config(s->module_config, &mime_magic_module);
-	if (conf->magicfile == NULL && s != main_server) {
-	    /* inherits from the parent */
-	    *conf = *main_conf;
-	}
-	else if (conf->magicfile) {
-	    result = apprentice(s, p);
-	    if (result == -1)
-		return OK;
+        conf = ap_get_module_config(s->module_config, &mime_magic_module);
+        if (conf->magicfile == NULL && s != main_server) {
+            /* inherits from the parent */
+            *conf = *main_conf;
+        }
+        else if (conf->magicfile) {
+            result = apprentice(s, p);
+            if (result == -1)
+                return OK;
 #if MIME_MAGIC_DEBUG
-	    prevm = 0;
-	    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-			MODNAME ": magic_init 1 test");
-	    for (m = conf->magic; m; m = m->next) {
-		if (apr_isprint((((unsigned long) m) >> 24) & 255) &&
-		    apr_isprint((((unsigned long) m) >> 16) & 255) &&
-		    apr_isprint((((unsigned long) m) >> 8) & 255) &&
-		    apr_isprint(((unsigned long) m) & 255)) {
-		    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-				MODNAME ": magic_init 1: POINTER CLOBBERED! "
-				"m=\"%c%c%c%c\" line=%d",
-				(((unsigned long) m) >> 24) & 255,
-				(((unsigned long) m) >> 16) & 255,
-				(((unsigned long) m) >> 8) & 255,
-				((unsigned long) m) & 255,
-				prevm ? prevm->lineno : -1);
-		    break;
-		}
-		prevm = m;
-	    }
+            prevm = 0;
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+                        MODNAME ": magic_init 1 test");
+            for (m = conf->magic; m; m = m->next) {
+                if (apr_isprint((((unsigned long) m) >> 24) & 255) &&
+                    apr_isprint((((unsigned long) m) >> 16) & 255) &&
+                    apr_isprint((((unsigned long) m) >> 8) & 255) &&
+                    apr_isprint(((unsigned long) m) & 255)) {
+                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+                                MODNAME ": magic_init 1: POINTER CLOBBERED! "
+                                "m=\"%c%c%c%c\" line=%d",
+                                (((unsigned long) m) >> 24) & 255,
+                                (((unsigned long) m) >> 16) & 255,
+                                (((unsigned long) m) >> 8) & 255,
+                                ((unsigned long) m) & 255,
+                                prevm ? prevm->lineno : -1);
+                    break;
+                }
+                prevm = m;
+            }
 #endif
-	}
+        }
     }
     return OK;
 }
@@ -2419,30 +2419,30 @@ static int magic_find_ct(request_rec *r)
 
     /* the file has to exist */
     if (r->finfo.filetype == 0 || !r->filename) {
-	return DECLINED;
+        return DECLINED;
     }
 
     /* was someone else already here? */
     if (r->content_type) {
-	return DECLINED;
+        return DECLINED;
     }
 
     conf = ap_get_module_config(r->server->module_config, &mime_magic_module);
     if (!conf || !conf->magic) {
-	return DECLINED;
+        return DECLINED;
     }
 
     /* initialize per-request info */
     if (!magic_set_config(r)) {
-	return HTTP_INTERNAL_SERVER_ERROR;
+        return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     /* try excluding file-revision suffixes */
     if (revision_suffix(r) != 1) {
-	/* process it based on the file contents */
-	if ((result = magic_process(r)) != OK) {
-	    return result;
-	}
+        /* process it based on the file contents */
+        if ((result = magic_process(r)) != OK) {
+            return result;
+        }
     }
 
     /* if we have any results, put them in the request structure */
diff --git a/modules/metadata/mod_setenvif.c b/modules/metadata/mod_setenvif.c
index c99466f..bd0ccfb 100644
--- a/modules/metadata/mod_setenvif.c
+++ b/modules/metadata/mod_setenvif.c
@@ -253,7 +253,7 @@ static const char *non_regex_pattern(apr_pool_t *p, const char *s)
 }
 
 static const char *add_setenvif_core(cmd_parms *cmd, void *mconfig,
-				     char *fname, const char *args)
+                                     char *fname, const char *args)
 {
     char *regex;
     const char *simple_pattern;
@@ -274,7 +274,7 @@ static const char *add_setenvif_core(cmd_parms *cmd, void *mconfig,
     sconf = (cmd->path != NULL)
       ? (sei_cfg_rec *) mconfig
       : (sei_cfg_rec *) ap_get_module_config(cmd->server->module_config,
-					       &setenvif_module);
+                                               &setenvif_module);
     entries = (sei_entry *) sconf->conditionals->elts;
     /* get regex */
     regex = ap_getword_conf(cmd->pool, &args);
@@ -427,7 +427,7 @@ static const char *add_setenvif_core(cmd_parms *cmd, void *mconfig,
 }
 
 static const char *add_setenvif(cmd_parms *cmd, void *mconfig,
-				const char *args)
+                                const char *args)
 {
     char *fname;
 
diff --git a/modules/metadata/mod_unique_id.c b/modules/metadata/mod_unique_id.c
index 7783b3c..ebb63eb 100644
--- a/modules/metadata/mod_unique_id.c
+++ b/modules/metadata/mod_unique_id.c
@@ -284,8 +284,8 @@ static int gen_unique_id(request_rec *r)
      */
     unique_id_rec new_unique_id;
     struct {
-	unique_id_rec foo;
-	unsigned char pad[2];
+        unique_id_rec foo;
+        unsigned char pad[2];
     } paddedbuf;
     unsigned char *x,*y;
     unsigned short counter;
@@ -296,8 +296,8 @@ static int gen_unique_id(request_rec *r)
      * actually called for sub requests, so we don't need to test for
      * them) */
     if (r->prev && (e = apr_table_get(r->subprocess_env, "REDIRECT_UNIQUE_ID"))) {
-	apr_table_setn(r->subprocess_env, "UNIQUE_ID", e);
-	return DECLINED;
+        apr_table_setn(r->subprocess_env, "UNIQUE_ID", e);
+        return DECLINED;
     }
     
     new_unique_id.in_addr = cur_unique_id.in_addr;
diff --git a/modules/metadata/mod_usertrack.c b/modules/metadata/mod_usertrack.c
index 0f5afdc..21840f3 100644
--- a/modules/metadata/mod_usertrack.c
+++ b/modules/metadata/mod_usertrack.c
@@ -95,12 +95,12 @@ typedef struct {
 static void make_cookie(request_rec *r)
 {
     cookie_log_state *cls = ap_get_module_config(r->server->module_config,
-						 &usertrack_module);
+                                                 &usertrack_module);
     /* 1024 == hardcoded constant */
     char cookiebuf[1024];
     char *new_cookie;
     const char *rname = ap_get_remote_host(r->connection, r->per_dir_config,
-					   REMOTE_NAME, NULL);
+                                           REMOTE_NAME, NULL);
     cookie_dir_rec *dcfg;
 
     dcfg = ap_get_module_config(r->per_dir_config, &usertrack_module);
@@ -116,7 +116,7 @@ static void make_cookie(request_rec *r)
                                   dcfg->cookie_name, cookiebuf);
 
         if ((dcfg->style == CT_UNSET) || (dcfg->style == CT_NETSCAPE)) {
-	    apr_time_exp_t tms;
+            apr_time_exp_t tms;
             apr_time_exp_gmt(&tms, r->request_time 
                                  + apr_time_from_sec(cls->expires));
             new_cookie = apr_psprintf(r->pool,
@@ -207,7 +207,7 @@ static void set_and_comp_regexp(cookie_dir_rec *dcfg,
 static int spot_cookie(request_rec *r)
 {
     cookie_dir_rec *dcfg = ap_get_module_config(r->per_dir_config,
-						&usertrack_module);
+                                                &usertrack_module);
     const char *cookie_header;
     ap_regmatch_t regm[NUM_SUBS];
 
@@ -308,7 +308,7 @@ static const char *set_cookie_exp(cmd_parms *parms, void *dummy,
     /* {<num> <type>}* */
     while (word[0]) {
         /* <num> */
-	if (apr_isdigit(word[0]))
+        if (apr_isdigit(word[0]))
             num = atoi(word);
         else
             return "bad expires code, numeric value expected.";
diff --git a/modules/ssl/mod_ssl.c b/modules/ssl/mod_ssl.c
index 01a851c..af91fa5 100644
--- a/modules/ssl/mod_ssl.c
+++ b/modules/ssl/mod_ssl.c
@@ -144,7 +144,7 @@ static const command_rec ssl_config_cmds[] = {
     SSL_CMD_SRV(HonorCipherOrder, FLAG,
                 "Use the server's cipher ordering preference")
     SSL_CMD_ALL(UserName, TAKE1,
-		"Set user name to SSL variable value")
+                "Set user name to SSL variable value")
 
     /* 
      * Proxy configuration for remote SSL connections
diff --git a/modules/ssl/ssl_engine_config.c b/modules/ssl/ssl_engine_config.c
index 0947b28..640837a 100644
--- a/modules/ssl/ssl_engine_config.c
+++ b/modules/ssl/ssl_engine_config.c
@@ -1404,7 +1404,7 @@ const char *ssl_cmd_SSLProxyMachineCertificatePath(cmd_parms *cmd,
 
 
 const char *ssl_cmd_SSLUserName(cmd_parms *cmd, void *dcfg, 
-				const char *arg)
+                                const char *arg)
 {
     SSLDirConfigRec *dc = (SSLDirConfigRec *)dcfg;
     dc->szUserName = arg;
diff --git a/modules/ssl/ssl_engine_io.c b/modules/ssl/ssl_engine_io.c
index 996c35a..5527a5e 100644
--- a/modules/ssl/ssl_engine_io.c
+++ b/modules/ssl/ssl_engine_io.c
@@ -182,7 +182,7 @@ static int bio_filter_destroy(BIO *bio)
      */
     return 1;
 }
-	
+        
 static int bio_filter_out_read(BIO *bio, char *out, int outl)
 {
     /* this is never called */
diff --git a/modules/ssl/ssl_engine_pphrase.c b/modules/ssl/ssl_engine_pphrase.c
index 7f0e4b6..8512892 100644
--- a/modules/ssl/ssl_engine_pphrase.c
+++ b/modules/ssl/ssl_engine_pphrase.c
@@ -596,16 +596,16 @@ static int pipe_get_passwd_cb(char *buf, int length, char *prompt, int verify)
     apr_file_puts(APR_EOL_STR, writetty);
     
     if (rc != APR_SUCCESS || apr_file_eof(readtty)) {
-	memset(buf, 0, length);
+        memset(buf, 0, length);
         return 1;  /* failure */
     }
     if ((p = strchr(buf, '\n')) != NULL) {
-	*p = '\0';
+        *p = '\0';
     }
 #ifdef WIN32
     /* XXX: apr_sometest */
     if ((p = strchr(buf, '\r')) != NULL) {
-	*p = '\0';
+        *p = '\0';
     }
 #endif
     return 0;
@@ -676,7 +676,7 @@ int ssl_pphrase_Handle_CB(char *buf, int bufsize, int verify, void *srv)
                 ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
                              "Init: Creating pass phrase dialog pipe child "
                              "'%s'", sc->server->pphrase_dialog_path);
-	        if (ssl_pipe_child_create(p, sc->server->pphrase_dialog_path)
+                if (ssl_pipe_child_create(p, sc->server->pphrase_dialog_path)
                         != APR_SUCCESS) {
                     ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                                  "Init: Failed to create pass phrase pipe '%s'",
diff --git a/modules/ssl/ssl_expr_scan.c b/modules/ssl/ssl_expr_scan.c
index 07a9be1..705b246 100644
--- a/modules/ssl/ssl_expr_scan.c
+++ b/modules/ssl/ssl_expr_scan.c
@@ -139,15 +139,15 @@ extern FILE *yyin, *yyout;
 /* Return all but the first 'n' matched characters back to the input stream. */
 
 #define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
+        do \
+                { \
+                /* Undo effects of setting up yytext. */ \
+                *yy_cp = yy_hold_char; \
+                YY_RESTORE_YY_MORE_OFFSET \
+                yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+                YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+                } \
+        while ( 0 )
 
 #define unput(c) yyunput( c, yytext_ptr )
 
@@ -159,61 +159,61 @@ typedef unsigned int yy_size_t;
 
 
 struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
+        {
+        FILE *yy_input_file;
+
+        char *yy_ch_buf;		/* input buffer */
+        char *yy_buf_pos;		/* current position in input buffer */
+
+        /* Size of input buffer in bytes, not including room for EOB
+         * characters.
+         */
+        yy_size_t yy_buf_size;
+
+        /* Number of characters read into yy_ch_buf, not including EOB
+         * characters.
+         */
+        int yy_n_chars;
+
+        /* Whether we "own" the buffer - i.e., we know we created it,
+         * and can realloc() it to grow it, and should free() it to
+         * delete it.
+         */
+        int yy_is_our_buffer;
+
+        /* Whether this is an "interactive" input source; if so, and
+         * if we're using stdio for input, then we want to use getc()
+         * instead of fread(), to make sure we stop fetching input after
+         * each newline.
+         */
+        int yy_is_interactive;
+
+        /* Whether we're considered to be at the beginning of a line.
+         * If so, '^' rules will be active on the next match, otherwise
+         * not.
+         */
+        int yy_at_bol;
+
+        /* Whether to try to fill the input buffer when we reach the
+         * end of it.
+         */
+        int yy_fill_buffer;
+
+        int yy_buffer_status;
 #define YY_BUFFER_NEW 0
 #define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
+        /* When an EOF's been seen but there's still some text to process
+         * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+         * shouldn't try reading from the input source any more.  We might
+         * still have a bunch of tokens to match, though, because of
+         * possible backing-up.
+         *
+         * When we actually see the EOF, we change the status to "new"
+         * (via yyrestart()), so that the user can continue scanning by
+         * just pointing yyin at a new input file.
+         */
 #define YY_BUFFER_EOF_PENDING 2
-	};
+        };
 
 static YY_BUFFER_STATE yy_current_buffer = 0;
 
@@ -263,18 +263,18 @@ static void yy_flex_free YY_PROTO(( void * ));
 #define yy_new_buffer yy_create_buffer
 
 #define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
+        { \
+        if ( ! yy_current_buffer ) \
+                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+        yy_current_buffer->yy_is_interactive = is_interactive; \
+        }
 
 #define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
+        { \
+        if ( ! yy_current_buffer ) \
+                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+        yy_current_buffer->yy_at_bol = at_bol; \
+        }
 
 #define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
 
@@ -296,11 +296,11 @@ static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
  * corresponding action - sets up yytext.
  */
 #define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
+        yytext_ptr = yy_bp; \
+        yyleng = (int) (yy_cp - yy_bp); \
+        yy_hold_char = *yy_cp; \
+        *yy_cp = '\0'; \
+        yy_c_buf_p = yy_cp;
 
 #define YY_NUM_RULES 47
 #define YY_END_OF_BUFFER 48
@@ -600,21 +600,21 @@ YY_MALLOC_DECL
  */
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
+        if ( yy_current_buffer->yy_is_interactive ) \
+                { \
+                int c = '*', n; \
+                for ( n = 0; n < max_size && \
+                             (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+                        buf[n] = (char) c; \
+                if ( c == '\n' ) \
+                        buf[n++] = (char) c; \
+                if ( c == EOF && ferror( yyin ) ) \
+                        YY_FATAL_ERROR( "input in flex scanner failed" ); \
+                result = n; \
+                } \
+        else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
+                  && ferror( yyin ) ) \
+                YY_FATAL_ERROR( "input in flex scanner failed" );
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -655,13 +655,13 @@ YY_MALLOC_DECL
 #endif
 
 #define YY_RULE_SETUP \
-	YY_USER_ACTION
+        YY_USER_ACTION
 
 YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
+        {
+        register yy_state_type yy_current_state;
+        register char *yy_cp, *yy_bp;
+        register int yy_act;
 
 #line 58 "ssl_expr_scan.l"
 
@@ -677,82 +677,82 @@ YY_DECL
   */
 #line 680 "lex.ssl_expr_yy.c"
 
-	if ( yy_init )
-		{
-		yy_init = 0;
+        if ( yy_init )
+                {
+                yy_init = 0;
 
 #ifdef YY_USER_INIT
-		YY_USER_INIT;
+                YY_USER_INIT;
 #endif
 
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
+                if ( ! yy_start )
+                        yy_start = 1;	/* first start state */
 
-		if ( ! yyin )
-			yyin = stdin;
+                if ( ! yyin )
+                        yyin = stdin;
 
-		if ( ! yyout )
-			yyout = stdout;
+                if ( ! yyout )
+                        yyout = stdout;
 
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
+                if ( ! yy_current_buffer )
+                        yy_current_buffer =
+                                yy_create_buffer( yyin, YY_BUF_SIZE );
 
-		yy_load_buffer_state();
-		}
+                yy_load_buffer_state();
+                }
 
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
+        while ( 1 )		/* loops until end-of-file is reached */
+                {
+                yy_cp = yy_c_buf_p;
 
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
+                /* Support of yytext. */
+                *yy_cp = yy_hold_char;
 
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
+                /* yy_bp points to the position in yy_ch_buf of the start of
+                 * the current run.
+                 */
+                yy_bp = yy_cp;
 
-		yy_current_state = yy_start;
+                yy_current_state = yy_start;
 yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 97 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_current_state != 96 );
-		yy_cp = yy_last_accepting_cpos;
-		yy_current_state = yy_last_accepting_state;
+                do
+                        {
+                        register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+                        if ( yy_accept[yy_current_state] )
+                                {
+                                yy_last_accepting_state = yy_current_state;
+                                yy_last_accepting_cpos = yy_cp;
+                                }
+                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+                                {
+                                yy_current_state = (int) yy_def[yy_current_state];
+                                if ( yy_current_state >= 97 )
+                                        yy_c = yy_meta[(unsigned int) yy_c];
+                                }
+                        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+                        ++yy_cp;
+                        }
+                while ( yy_current_state != 96 );
+                yy_cp = yy_last_accepting_cpos;
+                yy_current_state = yy_last_accepting_state;
 
 yy_find_action:
-		yy_act = yy_accept[yy_current_state];
+                yy_act = yy_accept[yy_current_state];
 
-		YY_DO_BEFORE_ACTION;
+                YY_DO_BEFORE_ACTION;
 
 
 do_action:	/* This label is used only to access EOF actions. */
 
 
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
+                switch ( yy_act )
+        { /* beginning of action switch */
+                        case 0: /* must back up */
+                        /* undo the effects of YY_DO_BEFORE_ACTION */
+                        *yy_cp = yy_hold_char;
+                        yy_cp = yy_last_accepting_cpos;
+                        yy_current_state = yy_last_accepting_state;
+                        goto yy_find_action;
 
 case 1:
 YY_RULE_SETUP
@@ -760,7 +760,7 @@ YY_RULE_SETUP
 { 
     /* NOP */
 }
-	YY_BREAK
+        YY_BREAK
 /*
   * C-style strings ("...")
   */
@@ -771,7 +771,7 @@ YY_RULE_SETUP
     cpStr = caStr;
     BEGIN(str);
 }
-	YY_BREAK
+        YY_BREAK
 case 3:
 YY_RULE_SETUP
 #line 80 "ssl_expr_scan.l"
@@ -781,14 +781,14 @@ YY_RULE_SETUP
     yylval.cpVal = apr_pstrdup(ssl_expr_info.pool, caStr);
     return T_STRING;
 }
-	YY_BREAK
+        YY_BREAK
 case 4:
 YY_RULE_SETUP
 #line 86 "ssl_expr_scan.l"
 {
     yyerror("Unterminated string");
 }
-	YY_BREAK
+        YY_BREAK
 case 5:
 YY_RULE_SETUP
 #line 89 "ssl_expr_scan.l"
@@ -801,46 +801,46 @@ YY_RULE_SETUP
     else
         *cpStr++ = result;
 }
-	YY_BREAK
+        YY_BREAK
 case 6:
 YY_RULE_SETUP
 #line 98 "ssl_expr_scan.l"
 {
     yyerror("Bad escape sequence");
 }
-	YY_BREAK
+        YY_BREAK
 case 7:
 YY_RULE_SETUP
 #line 101 "ssl_expr_scan.l"
 { *cpStr++ = '\n'; }
-	YY_BREAK
+        YY_BREAK
 case 8:
 YY_RULE_SETUP
 #line 102 "ssl_expr_scan.l"
 { *cpStr++ = '\r'; }
-	YY_BREAK
+        YY_BREAK
 case 9:
 YY_RULE_SETUP
 #line 103 "ssl_expr_scan.l"
 { *cpStr++ = '\t'; }
-	YY_BREAK
+        YY_BREAK
 case 10:
 YY_RULE_SETUP
 #line 104 "ssl_expr_scan.l"
 { *cpStr++ = '\b'; }
-	YY_BREAK
+        YY_BREAK
 case 11:
 YY_RULE_SETUP
 #line 105 "ssl_expr_scan.l"
 { *cpStr++ = '\f'; }
-	YY_BREAK
+        YY_BREAK
 case 12:
 YY_RULE_SETUP
 #line 106 "ssl_expr_scan.l"
 {
     *cpStr++ = yytext[1];
 }
-	YY_BREAK
+        YY_BREAK
 case 13:
 YY_RULE_SETUP
 #line 109 "ssl_expr_scan.l"
@@ -849,14 +849,14 @@ YY_RULE_SETUP
     while (*cp != NUL)
         *cpStr++ = *cp++;
 }
-	YY_BREAK
+        YY_BREAK
 case 14:
 YY_RULE_SETUP
 #line 114 "ssl_expr_scan.l"
 {
     *cpStr++ = yytext[1];
 }
-	YY_BREAK
+        YY_BREAK
 /*
   * Regular Expression
   */
@@ -868,7 +868,7 @@ YY_RULE_SETUP
     cpRegex = caRegex;
     BEGIN(regex);
 }
-	YY_BREAK
+        YY_BREAK
 case 16:
 YY_RULE_SETUP
 #line 126 "ssl_expr_scan.l"
@@ -881,7 +881,7 @@ YY_RULE_SETUP
         *cpRegex++ = yytext[0];
     }
 }
-	YY_BREAK
+        YY_BREAK
 case 17:
 YY_RULE_SETUP
 #line 135 "ssl_expr_scan.l"
@@ -890,7 +890,7 @@ YY_RULE_SETUP
     BEGIN(INITIAL);
     return T_REGEX_I;
 }
-	YY_BREAK
+        YY_BREAK
 case 18:
 YY_RULE_SETUP
 #line 140 "ssl_expr_scan.l"
@@ -900,7 +900,7 @@ YY_RULE_SETUP
     BEGIN(INITIAL);
     return T_REGEX;
 }
-	YY_BREAK
+        YY_BREAK
 case YY_STATE_EOF(regex_flags):
 #line 146 "ssl_expr_scan.l"
 {
@@ -908,7 +908,7 @@ case YY_STATE_EOF(regex_flags):
     BEGIN(INITIAL);
     return T_REGEX;
 }
-	YY_BREAK
+        YY_BREAK
 /*
   * Operators
   */
@@ -916,112 +916,112 @@ case 19:
 YY_RULE_SETUP
 #line 155 "ssl_expr_scan.l"
 { return T_OP_EQ; }
-	YY_BREAK
+        YY_BREAK
 case 20:
 YY_RULE_SETUP
 #line 156 "ssl_expr_scan.l"
 { return T_OP_EQ; }
-	YY_BREAK
+        YY_BREAK
 case 21:
 YY_RULE_SETUP
 #line 157 "ssl_expr_scan.l"
 { return T_OP_NE; }
-	YY_BREAK
+        YY_BREAK
 case 22:
 YY_RULE_SETUP
 #line 158 "ssl_expr_scan.l"
 { return T_OP_NE; }
-	YY_BREAK
+        YY_BREAK
 case 23:
 YY_RULE_SETUP
 #line 159 "ssl_expr_scan.l"
 { return T_OP_LT; }
-	YY_BREAK
+        YY_BREAK
 case 24:
 YY_RULE_SETUP
 #line 160 "ssl_expr_scan.l"
 { return T_OP_LT; }
-	YY_BREAK
+        YY_BREAK
 case 25:
 YY_RULE_SETUP
 #line 161 "ssl_expr_scan.l"
 { return T_OP_LE; }
-	YY_BREAK
+        YY_BREAK
 case 26:
 YY_RULE_SETUP
 #line 162 "ssl_expr_scan.l"
 { return T_OP_LE; }
-	YY_BREAK
+        YY_BREAK
 case 27:
 YY_RULE_SETUP
 #line 163 "ssl_expr_scan.l"
 { return T_OP_GT; }
-	YY_BREAK
+        YY_BREAK
 case 28:
 YY_RULE_SETUP
 #line 164 "ssl_expr_scan.l"
 { return T_OP_GT; }
-	YY_BREAK
+        YY_BREAK
 case 29:
 YY_RULE_SETUP
 #line 165 "ssl_expr_scan.l"
 { return T_OP_GE; }
-	YY_BREAK
+        YY_BREAK
 case 30:
 YY_RULE_SETUP
 #line 166 "ssl_expr_scan.l"
 { return T_OP_GE; }
-	YY_BREAK
+        YY_BREAK
 case 31:
 YY_RULE_SETUP
 #line 167 "ssl_expr_scan.l"
 { return T_OP_REG; }
-	YY_BREAK
+        YY_BREAK
 case 32:
 YY_RULE_SETUP
 #line 168 "ssl_expr_scan.l"
 { return T_OP_NRE; }
-	YY_BREAK
+        YY_BREAK
 case 33:
 YY_RULE_SETUP
 #line 169 "ssl_expr_scan.l"
 { return T_OP_AND; }
-	YY_BREAK
+        YY_BREAK
 case 34:
 YY_RULE_SETUP
 #line 170 "ssl_expr_scan.l"
 { return T_OP_AND; }
-	YY_BREAK
+        YY_BREAK
 case 35:
 YY_RULE_SETUP
 #line 171 "ssl_expr_scan.l"
 { return T_OP_OR; }
-	YY_BREAK
+        YY_BREAK
 case 36:
 YY_RULE_SETUP
 #line 172 "ssl_expr_scan.l"
 { return T_OP_OR; }
-	YY_BREAK
+        YY_BREAK
 case 37:
 YY_RULE_SETUP
 #line 173 "ssl_expr_scan.l"
 { return T_OP_NOT; }
-	YY_BREAK
+        YY_BREAK
 case 38:
 YY_RULE_SETUP
 #line 174 "ssl_expr_scan.l"
 { return T_OP_NOT; }
-	YY_BREAK
+        YY_BREAK
 case 39:
 YY_RULE_SETUP
 #line 175 "ssl_expr_scan.l"
 { return T_OP_IN; }
-	YY_BREAK
+        YY_BREAK
 case 40:
 YY_RULE_SETUP
 #line 176 "ssl_expr_scan.l"
 { return T_OP_PEEREXTLIST; }
-	YY_BREAK
+        YY_BREAK
 /*
   * Functions
   */
@@ -1029,7 +1029,7 @@ case 41:
 YY_RULE_SETUP
 #line 181 "ssl_expr_scan.l"
 { return T_FUNC_FILE; }
-	YY_BREAK
+        YY_BREAK
 /*
   * Specials
   */
@@ -1037,12 +1037,12 @@ case 42:
 YY_RULE_SETUP
 #line 186 "ssl_expr_scan.l"
 { return T_TRUE; }
-	YY_BREAK
+        YY_BREAK
 case 43:
 YY_RULE_SETUP
 #line 187 "ssl_expr_scan.l"
 { return T_FALSE; }
-	YY_BREAK
+        YY_BREAK
 /*
   * Digits
   */
@@ -1053,7 +1053,7 @@ YY_RULE_SETUP
     yylval.cpVal = apr_pstrdup(ssl_expr_info.pool, yytext);
     return T_DIGIT;
 }
-	YY_BREAK
+        YY_BREAK
 /*
   * Identifiers
   */
@@ -1064,7 +1064,7 @@ YY_RULE_SETUP
     yylval.cpVal = apr_pstrdup(ssl_expr_info.pool, yytext);
     return T_ID;
 }
-	YY_BREAK
+        YY_BREAK
 /*
   * Anything else is returned as is...
   */
@@ -1074,147 +1074,147 @@ YY_RULE_SETUP
 { 
     return yytext[0];
 }
-	YY_BREAK
+        YY_BREAK
 case 47:
 YY_RULE_SETUP
 #line 212 "ssl_expr_scan.l"
 YY_FATAL_ERROR( "flex scanner jammed" );
-	YY_BREAK
+        YY_BREAK
 #line 1085 "lex.ssl_expr_yy.c"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(str):
 case YY_STATE_EOF(regex):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_last_accepting_cpos;
-				yy_current_state = yy_last_accepting_state;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
+        yyterminate();
+
+        case YY_END_OF_BUFFER:
+                {
+                /* Amount of text matched not including the EOB char. */
+                int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+                /* Undo the effects of YY_DO_BEFORE_ACTION. */
+                *yy_cp = yy_hold_char;
+                YY_RESTORE_YY_MORE_OFFSET
+
+                if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+                        {
+                        /* We're scanning a new file or input source.  It's
+                         * possible that this happened because the user
+                         * just pointed yyin at a new source and called
+                         * yylex().  If so, then we have to assure
+                         * consistency between yy_current_buffer and our
+                         * globals.  Here is the right place to do so, because
+                         * this is the first action (other than possibly a
+                         * back-up) that will match for the new input source.
+                         */
+                        yy_n_chars = yy_current_buffer->yy_n_chars;
+                        yy_current_buffer->yy_input_file = yyin;
+                        yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+                        }
+
+                /* Note that here we test for yy_c_buf_p "<=" to the position
+                 * of the first EOB in the buffer, since yy_c_buf_p will
+                 * already have been incremented past the NUL character
+                 * (since all states make transitions on EOB to the
+                 * end-of-buffer state).  Contrast this with the test
+                 * in input().
+                 */
+                if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+                        { /* This was really a NUL. */
+                        yy_state_type yy_next_state;
+
+                        yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+                        yy_current_state = yy_get_previous_state();
+
+                        /* Okay, we're now positioned to make the NUL
+                         * transition.  We couldn't have
+                         * yy_get_previous_state() go ahead and do it
+                         * for us because it doesn't know how to deal
+                         * with the possibility of jamming (and we don't
+                         * want to build jamming into it because then it
+                         * will run more slowly).
+                         */
+
+                        yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+                        yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+                        if ( yy_next_state )
+                                {
+                                /* Consume the NUL. */
+                                yy_cp = ++yy_c_buf_p;
+                                yy_current_state = yy_next_state;
+                                goto yy_match;
+                                }
+
+                        else
+                                {
+                                yy_cp = yy_last_accepting_cpos;
+                                yy_current_state = yy_last_accepting_state;
+                                goto yy_find_action;
+                                }
+                        }
+
+                else switch ( yy_get_next_buffer() )
+                        {
+                        case EOB_ACT_END_OF_FILE:
+                                {
+                                yy_did_buffer_switch_on_eof = 0;
+
+                                if ( yywrap() )
+                                        {
+                                        /* Note: because we've taken care in
+                                         * yy_get_next_buffer() to have set up
+                                         * yytext, we can now set up
+                                         * yy_c_buf_p so that if some total
+                                         * hoser (like flex itself) wants to
+                                         * call the scanner after we return the
+                                         * YY_NULL, it'll still work - another
+                                         * YY_NULL will get returned.
+                                         */
+                                        yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+                                        yy_act = YY_STATE_EOF(YY_START);
+                                        goto do_action;
+                                        }
+
+                                else
+                                        {
+                                        if ( ! yy_did_buffer_switch_on_eof )
+                                                YY_NEW_FILE;
+                                        }
+                                break;
+                                }
+
+                        case EOB_ACT_CONTINUE_SCAN:
+                                yy_c_buf_p =
+                                        yytext_ptr + yy_amount_of_matched_text;
+
+                                yy_current_state = yy_get_previous_state();
+
+                                yy_cp = yy_c_buf_p;
+                                yy_bp = yytext_ptr + YY_MORE_ADJ;
+                                goto yy_match;
+
+                        case EOB_ACT_LAST_MATCH:
+                                yy_c_buf_p =
+                                &yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+                                yy_current_state = yy_get_previous_state();
+
+                                yy_cp = yy_c_buf_p;
+                                yy_bp = yytext_ptr + YY_MORE_ADJ;
+                                goto yy_find_action;
+                        }
+                break;
+                }
+
+        default:
+                YY_FATAL_ERROR(
+                        "fatal flex scanner internal error--no action found" );
+        } /* end of action switch */
+                } /* end of scanning one token */
+        } /* end of yylex */
 
 
 /* yy_get_next_buffer - try to read in a new buffer
@@ -1226,163 +1226,163 @@ case YY_STATE_EOF(regex):
  */
 
 static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
+        {
+        register char *dest = yy_current_buffer->yy_ch_buf;
+        register char *source = yytext_ptr;
+        register int number_to_move, i;
+        int ret_val;
+
+        if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+                YY_FATAL_ERROR(
+                "fatal flex scanner internal error--end of buffer missed" );
+
+        if ( yy_current_buffer->yy_fill_buffer == 0 )
+                { /* Don't try to fill the buffer, so this is an EOF. */
+                if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+                        {
+                        /* We matched a single character, the EOB, so
+                         * treat this as a final EOF.
+                         */
+                        return EOB_ACT_END_OF_FILE;
+                        }
+
+                else
+                        {
+                        /* We matched some text prior to the EOB, first
+                         * process it.
+                         */
+                        return EOB_ACT_LAST_MATCH;
+                        }
+                }
+
+        /* Try to read more data. */
+
+        /* First move last chars to start of buffer. */
+        number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+        for ( i = 0; i < number_to_move; ++i )
+                *(dest++) = *(source++);
+
+        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+                /* don't do the read, it's not guaranteed to return an EOF,
+                 * just force an EOF
+                 */
+                yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+        else
+                {
+                int num_to_read =
+                        yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+                while ( num_to_read <= 0 )
+                        { /* Not enough room in the buffer - grow it. */
 #ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
+                        YY_FATAL_ERROR(
 "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
 #else
 
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
+                        /* just a shorter name for the current buffer */
+                        YY_BUFFER_STATE b = yy_current_buffer;
 
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
+                        int yy_c_buf_p_offset =
+                                (int) (yy_c_buf_p - b->yy_ch_buf);
 
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
+                        if ( b->yy_is_our_buffer )
+                                {
+                                int new_size = b->yy_buf_size * 2;
 
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
+                                if ( new_size <= 0 )
+                                        b->yy_buf_size += b->yy_buf_size / 8;
+                                else
+                                        b->yy_buf_size *= 2;
 
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
+                                b->yy_ch_buf = (char *)
+                                        /* Include room in for 2 EOB chars. */
+                                        yy_flex_realloc( (void *) b->yy_ch_buf,
+                                                         b->yy_buf_size + 2 );
+                                }
+                        else
+                                /* Can't grow it, we don't own it. */
+                                b->yy_ch_buf = 0;
 
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
+                        if ( ! b->yy_ch_buf )
+                                YY_FATAL_ERROR(
+                                "fatal error - scanner input buffer overflow" );
 
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+                        yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
 
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
+                        num_to_read = yy_current_buffer->yy_buf_size -
+                                                number_to_move - 1;
 #endif
-			}
+                        }
 
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
+                if ( num_to_read > YY_READ_BUF_SIZE )
+                        num_to_read = YY_READ_BUF_SIZE;
 
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
+                /* Read in more data. */
+                YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+                        yy_n_chars, num_to_read );
 
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
+                yy_current_buffer->yy_n_chars = yy_n_chars;
+                }
 
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
+        if ( yy_n_chars == 0 )
+                {
+                if ( number_to_move == YY_MORE_ADJ )
+                        {
+                        ret_val = EOB_ACT_END_OF_FILE;
+                        yyrestart( yyin );
+                        }
 
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
+                else
+                        {
+                        ret_val = EOB_ACT_LAST_MATCH;
+                        yy_current_buffer->yy_buffer_status =
+                                YY_BUFFER_EOF_PENDING;
+                        }
+                }
 
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
+        else
+                ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+        yy_n_chars += number_to_move;
+        yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+        yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
 
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+        yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
 
-	return ret_val;
-	}
+        return ret_val;
+        }
 
 
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
 static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 97 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
+        {
+        register yy_state_type yy_current_state;
+        register char *yy_cp;
+
+        yy_current_state = yy_start;
+
+        for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+                {
+                register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+                if ( yy_accept[yy_current_state] )
+                        {
+                        yy_last_accepting_state = yy_current_state;
+                        yy_last_accepting_cpos = yy_cp;
+                        }
+                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+                        {
+                        yy_current_state = (int) yy_def[yy_current_state];
+                        if ( yy_current_state >= 97 )
+                                yy_c = yy_meta[(unsigned int) yy_c];
+                        }
+                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+                }
+
+        return yy_current_state;
+        }
 
 
 /* yy_try_NUL_trans - try to make a transition on the NUL character
@@ -1397,27 +1397,27 @@ static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
 static yy_state_type yy_try_NUL_trans( yy_current_state )
 yy_state_type yy_current_state;
 #endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 97 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 96);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
+        {
+        register int yy_is_jam;
+        register char *yy_cp = yy_c_buf_p;
+
+        register YY_CHAR yy_c = 1;
+        if ( yy_accept[yy_current_state] )
+                {
+                yy_last_accepting_state = yy_current_state;
+                yy_last_accepting_cpos = yy_cp;
+                }
+        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+                {
+                yy_current_state = (int) yy_def[yy_current_state];
+                if ( yy_current_state >= 97 )
+                        yy_c = yy_meta[(unsigned int) yy_c];
+                }
+        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+        yy_is_jam = (yy_current_state == 96);
+
+        return yy_is_jam ? 0 : yy_current_state;
+        }
 
 
 #ifndef YY_NO_UNPUT
@@ -1428,40 +1428,40 @@ static void yyunput( c, yy_bp )
 int c;
 register char *yy_bp;
 #endif
-	{
-	register char *yy_cp = yy_c_buf_p;
+        {
+        register char *yy_cp = yy_c_buf_p;
 
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
+        /* undo effects of setting up yytext */
+        *yy_cp = yy_hold_char;
 
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
+        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+                { /* need to shift things up to make room */
+                /* +2 for EOB chars. */
+                register int number_to_move = yy_n_chars + 2;
+                register char *dest = &yy_current_buffer->yy_ch_buf[
+                                        yy_current_buffer->yy_buf_size + 2];
+                register char *source =
+                                &yy_current_buffer->yy_ch_buf[number_to_move];
 
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
+                while ( source > yy_current_buffer->yy_ch_buf )
+                        *--dest = *--source;
 
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
+                yy_cp += (int) (dest - source);
+                yy_bp += (int) (dest - source);
+                yy_current_buffer->yy_n_chars =
+                        yy_n_chars = yy_current_buffer->yy_buf_size;
 
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
+                if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+                        YY_FATAL_ERROR( "flex scanner push-back overflow" );
+                }
 
-	*--yy_cp = (char) c;
+        *--yy_cp = (char) c;
 
 
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
+        yytext_ptr = yy_bp;
+        yy_hold_char = *yy_cp;
+        yy_c_buf_p = yy_cp;
+        }
 #endif	/* ifndef YY_NO_UNPUT */
 
 
@@ -1470,72 +1470,72 @@ static int yyinput()
 #else
 static int input()
 #endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
+        {
+        int c;
+
+        *yy_c_buf_p = yy_hold_char;
+
+        if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+                {
+                /* yy_c_buf_p now points to the character we want to return.
+                 * If this occurs *before* the EOB characters, then it's a
+                 * valid NUL; if not, then we've hit the end of the buffer.
+                 */
+                if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+                        /* This was really a NUL. */
+                        *yy_c_buf_p = '\0';
+
+                else
+                        { /* need more input */
+                        int offset = yy_c_buf_p - yytext_ptr;
+                        ++yy_c_buf_p;
+
+                        switch ( yy_get_next_buffer() )
+                                {
+                                case EOB_ACT_LAST_MATCH:
+                                        /* This happens because yy_g_n_b()
+                                         * sees that we've accumulated a
+                                         * token and flags that we need to
+                                         * try matching the token before
+                                         * proceeding.  But for input(),
+                                         * there's no matching to consider.
+                                         * So convert the EOB_ACT_LAST_MATCH
+                                         * to EOB_ACT_END_OF_FILE.
+                                         */
+
+                                        /* Reset buffer status. */
+                                        yyrestart( yyin );
+
+                                        /* fall through */
+
+                                case EOB_ACT_END_OF_FILE:
+                                        {
+                                        if ( yywrap() )
+                                                return EOF;
+
+                                        if ( ! yy_did_buffer_switch_on_eof )
+                                                YY_NEW_FILE;
 #ifdef __cplusplus
-					return yyinput();
+                                        return yyinput();
 #else
-					return input();
+                                        return input();
 #endif
-					}
+                                        }
 
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
+                                case EOB_ACT_CONTINUE_SCAN:
+                                        yy_c_buf_p = yytext_ptr + offset;
+                                        break;
+                                }
+                        }
+                }
 
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
+        c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+        *yy_c_buf_p = '\0';	/* preserve yytext */
+        yy_hold_char = *++yy_c_buf_p;
 
 
-	return c;
-	}
+        return c;
+        }
 
 
 #ifdef YY_USE_PROTOS
@@ -1544,13 +1544,13 @@ void yyrestart( FILE *input_file )
 void yyrestart( input_file )
 FILE *input_file;
 #endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+        {
+        if ( ! yy_current_buffer )
+                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
 
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
+        yy_init_buffer( yy_current_buffer, input_file );
+        yy_load_buffer_state();
+        }
 
 
 #ifdef YY_USE_PROTOS
@@ -1559,28 +1559,28 @@ void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
 void yy_switch_to_buffer( new_buffer )
 YY_BUFFER_STATE new_buffer;
 #endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
+        {
+        if ( yy_current_buffer == new_buffer )
+                return;
 
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
+        if ( yy_current_buffer )
+                {
+                /* Flush out information for old buffer. */
+                *yy_c_buf_p = yy_hold_char;
+                yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+                yy_current_buffer->yy_n_chars = yy_n_chars;
+                }
 
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
+        yy_current_buffer = new_buffer;
+        yy_load_buffer_state();
 
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
+        /* We don't actually know whether we did this switch during
+         * EOF (yywrap()) processing, but the only time this flag
+         * is looked at is after yywrap() is called, so it's safe
+         * to go ahead and always set it.
+         */
+        yy_did_buffer_switch_on_eof = 1;
+        }
 
 
 #ifdef YY_USE_PROTOS
@@ -1588,12 +1588,12 @@ void yy_load_buffer_state( void )
 #else
 void yy_load_buffer_state()
 #endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
+        {
+        yy_n_chars = yy_current_buffer->yy_n_chars;
+        yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+        yyin = yy_current_buffer->yy_input_file;
+        yy_hold_char = *yy_c_buf_p;
+        }
 
 
 #ifdef YY_USE_PROTOS
@@ -1603,28 +1603,28 @@ YY_BUFFER_STATE yy_create_buffer( file, size )
 FILE *file;
 int size;
 #endif
-	{
-	YY_BUFFER_STATE b;
+        {
+        YY_BUFFER_STATE b;
 
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+        b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+        if ( ! b )
+                YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
-	b->yy_buf_size = size;
+        b->yy_buf_size = size;
 
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+        /* yy_ch_buf has to be 2 characters longer than the size given because
+         * we need to put in 2 end-of-buffer characters.
+         */
+        b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+        if ( ! b->yy_ch_buf )
+                YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
-	b->yy_is_our_buffer = 1;
+        b->yy_is_our_buffer = 1;
 
-	yy_init_buffer( b, file );
+        yy_init_buffer( b, file );
 
-	return b;
-	}
+        return b;
+        }
 
 
 #ifdef YY_USE_PROTOS
@@ -1633,18 +1633,18 @@ void yy_delete_buffer( YY_BUFFER_STATE b )
 void yy_delete_buffer( b )
 YY_BUFFER_STATE b;
 #endif
-	{
-	if ( ! b )
-		return;
+        {
+        if ( ! b )
+                return;
 
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
+        if ( b == yy_current_buffer )
+                yy_current_buffer = (YY_BUFFER_STATE) 0;
 
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
+        if ( b->yy_is_our_buffer )
+                yy_flex_free( (void *) b->yy_ch_buf );
 
-	yy_flex_free( (void *) b );
-	}
+        yy_flex_free( (void *) b );
+        }
 
 
 #ifndef YY_ALWAYS_INTERACTIVE
@@ -1662,22 +1662,22 @@ FILE *file;
 #endif
 
 
-	{
-	yy_flush_buffer( b );
+        {
+        yy_flush_buffer( b );
 
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
+        b->yy_input_file = file;
+        b->yy_fill_buffer = 1;
 
 #if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
+        b->yy_is_interactive = 1;
 #else
 #if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
+        b->yy_is_interactive = 0;
 #else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
 #endif
 #endif
-	}
+        }
 
 
 #ifdef YY_USE_PROTOS
@@ -1687,27 +1687,27 @@ void yy_flush_buffer( b )
 YY_BUFFER_STATE b;
 #endif
 
-	{
-	if ( ! b )
-		return;
+        {
+        if ( ! b )
+                return;
 
-	b->yy_n_chars = 0;
+        b->yy_n_chars = 0;
 
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+        /* We always need two end-of-buffer characters.  The first causes
+         * a transition to the end-of-buffer state.  The second causes
+         * a jam in that state.
+         */
+        b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+        b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
 
-	b->yy_buf_pos = &b->yy_ch_buf[0];
+        b->yy_buf_pos = &b->yy_ch_buf[0];
 
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
+        b->yy_at_bol = 1;
+        b->yy_buffer_status = YY_BUFFER_NEW;
 
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
+        if ( b == yy_current_buffer )
+                yy_load_buffer_state();
+        }
 
 
 #ifndef YY_NO_SCAN_BUFFER
@@ -1718,33 +1718,33 @@ YY_BUFFER_STATE yy_scan_buffer( base, size )
 char *base;
 yy_size_t size;
 #endif
-	{
-	YY_BUFFER_STATE b;
+        {
+        YY_BUFFER_STATE b;
 
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
+        if ( size < 2 ||
+             base[size-2] != YY_END_OF_BUFFER_CHAR ||
+             base[size-1] != YY_END_OF_BUFFER_CHAR )
+                /* They forgot to leave room for the EOB's. */
+                return 0;
 
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+        b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+        if ( ! b )
+                YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
 
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
+        b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+        b->yy_buf_pos = b->yy_ch_buf = base;
+        b->yy_is_our_buffer = 0;
+        b->yy_input_file = 0;
+        b->yy_n_chars = b->yy_buf_size;
+        b->yy_is_interactive = 0;
+        b->yy_at_bol = 1;
+        b->yy_fill_buffer = 0;
+        b->yy_buffer_status = YY_BUFFER_NEW;
 
-	yy_switch_to_buffer( b );
+        yy_switch_to_buffer( b );
 
-	return b;
-	}
+        return b;
+        }
 #endif
 
 
@@ -1755,13 +1755,13 @@ YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
 YY_BUFFER_STATE yy_scan_string( yy_str )
 yyconst char *yy_str;
 #endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
+        {
+        int len;
+        for ( len = 0; yy_str[len]; ++len )
+                ;
 
-	return yy_scan_bytes( yy_str, len );
-	}
+        return yy_scan_bytes( yy_str, len );
+        }
 #endif
 
 
@@ -1773,34 +1773,34 @@ YY_BUFFER_STATE yy_scan_bytes( bytes, len )
 yyconst char *bytes;
 int len;
 #endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
+        {
+        YY_BUFFER_STATE b;
+        char *buf;
+        yy_size_t n;
+        int i;
 
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+        /* Get memory for full buffer, including space for trailing EOB's. */
+        n = len + 2;
+        buf = (char *) yy_flex_alloc( n );
+        if ( ! buf )
+                YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
 
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
+        for ( i = 0; i < len; ++i )
+                buf[i] = bytes[i];
 
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+        buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
 
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+        b = yy_scan_buffer( buf, n );
+        if ( ! b )
+                YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
 
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
+        /* It's okay to grow etc. this buffer, and we should throw it
+         * away when we're done.
+         */
+        b->yy_is_our_buffer = 1;
 
-	return b;
-	}
+        return b;
+        }
 #endif
 
 
@@ -1811,49 +1811,49 @@ static void yy_push_state( int new_state )
 static void yy_push_state( new_state )
 int new_state;
 #endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
+        {
+        if ( yy_start_stack_ptr >= yy_start_stack_depth )
+                {
+                yy_size_t new_size;
 
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
+                yy_start_stack_depth += YY_START_STACK_INCR;
+                new_size = yy_start_stack_depth * sizeof( int );
 
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
+                if ( ! yy_start_stack )
+                        yy_start_stack = (int *) yy_flex_alloc( new_size );
 
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
+                else
+                        yy_start_stack = (int *) yy_flex_realloc(
+                                        (void *) yy_start_stack, new_size );
 
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
+                if ( ! yy_start_stack )
+                        YY_FATAL_ERROR(
+                        "out of memory expanding start-condition stack" );
+                }
 
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+        yy_start_stack[yy_start_stack_ptr++] = YY_START;
 
-	BEGIN(new_state);
-	}
+        BEGIN(new_state);
+        }
 #endif
 
 
 #ifndef YY_NO_POP_STATE
 static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
+        {
+        if ( --yy_start_stack_ptr < 0 )
+                YY_FATAL_ERROR( "start-condition stack underflow" );
 
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
+        BEGIN(yy_start_stack[yy_start_stack_ptr]);
+        }
 #endif
 
 
 #ifndef YY_NO_TOP_STATE
 static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
+        {
+        return yy_start_stack[yy_start_stack_ptr - 1];
+        }
 #endif
 
 #ifndef YY_EXIT_FAILURE
@@ -1866,10 +1866,10 @@ static void yy_fatal_error( yyconst char msg[] )
 static void yy_fatal_error( msg )
 char msg[];
 #endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
+        {
+        (void) fprintf( stderr, "%s\n", msg );
+        exit( YY_EXIT_FAILURE );
+        }
 
 
 
@@ -1877,16 +1877,16 @@ char msg[];
 
 #undef yyless
 #define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
+        do \
+                { \
+                /* Undo effects of setting up yytext. */ \
+                yytext[yyleng] = yy_hold_char; \
+                yy_c_buf_p = yytext + n; \
+                yy_hold_char = *yy_c_buf_p; \
+                *yy_c_buf_p = '\0'; \
+                yyleng = n; \
+                } \
+        while ( 0 )
 
 
 /* Internal utility routines. */
@@ -1900,11 +1900,11 @@ char *s1;
 yyconst char *s2;
 int n;
 #endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
+        {
+        register int i;
+        for ( i = 0; i < n; ++i )
+                s1[i] = s2[i];
+        }
 #endif
 
 #ifdef YY_NEED_STRLEN
@@ -1914,13 +1914,13 @@ static int yy_flex_strlen( yyconst char *s )
 static int yy_flex_strlen( s )
 yyconst char *s;
 #endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
+        {
+        register int n;
+        for ( n = 0; s[n]; ++n )
+                ;
 
-	return n;
-	}
+        return n;
+        }
 #endif
 
 
@@ -1930,9 +1930,9 @@ static void *yy_flex_alloc( yy_size_t size )
 static void *yy_flex_alloc( size )
 yy_size_t size;
 #endif
-	{
-	return (void *) malloc( size );
-	}
+        {
+        return (void *) malloc( size );
+        }
 
 #ifdef YY_USE_PROTOS
 static void *yy_flex_realloc( void *ptr, yy_size_t size )
@@ -1941,16 +1941,16 @@ static void *yy_flex_realloc( ptr, size )
 void *ptr;
 yy_size_t size;
 #endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
+        {
+        /* The cast to (char *) in the following accommodates both
+         * implementations that use char* generic pointers, and those
+         * that use void* generic pointers.  It works with the latter
+         * because both ANSI C and C++ allow castless assignment from
+         * any pointer type to void*, and deal with argument conversions
+         * as though doing an assignment.
+         */
+        return (void *) realloc( (char *) ptr, size );
+        }
 
 #ifdef YY_USE_PROTOS
 static void yy_flex_free( void *ptr )
@@ -1958,16 +1958,16 @@ static void yy_flex_free( void *ptr )
 static void yy_flex_free( ptr )
 void *ptr;
 #endif
-	{
-	free( ptr );
-	}
+        {
+        free( ptr );
+        }
 
 #if YY_MAIN
 int main()
-	{
-	yylex();
-	return 0;
-	}
+        {
+        yylex();
+        return 0;
+        }
 #endif
 #line 212 "ssl_expr_scan.l"
 
diff --git a/modules/ssl/ssl_scache_dbm.c b/modules/ssl/ssl_scache_dbm.c
index b03d740..34a898c 100644
--- a/modules/ssl/ssl_scache_dbm.c
+++ b/modules/ssl/ssl_scache_dbm.c
@@ -44,7 +44,7 @@ void ssl_scache_dbm_init(server_rec *s, apr_pool_t *p)
     /* open it once to create it and to make sure it _can_ be created */
     ssl_mutex_on(s);
     if ((rv = apr_dbm_open(&dbm, mc->szSessionCacheDataFile,
-	    APR_DBM_RWCREATE, SSL_DBM_FILE_MODE, mc->pPool)) != APR_SUCCESS) {
+            APR_DBM_RWCREATE, SSL_DBM_FILE_MODE, mc->pPool)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                      "Cannot create SSLSessionCache DBM file `%s'",
                      mc->szSessionCacheDataFile);
@@ -159,7 +159,7 @@ BOOL ssl_scache_dbm_store(server_rec *s, UCHAR *id, int idlen, time_t expiry, SS
     /* and store it to the DBM file */
     ssl_mutex_on(s);
     if ((rv = apr_dbm_open(&dbm, mc->szSessionCacheDataFile,
-	    APR_DBM_RWCREATE, SSL_DBM_FILE_MODE, mc->pPool)) != APR_SUCCESS) {
+            APR_DBM_RWCREATE, SSL_DBM_FILE_MODE, mc->pPool)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                      "Cannot open SSLSessionCache DBM file `%s' for writing "
                      "(store)",
@@ -215,7 +215,7 @@ SSL_SESSION *ssl_scache_dbm_retrieve(server_rec *s, UCHAR *id, int idlen)
      */
     ssl_mutex_on(s);
     if ((rc = apr_dbm_open(&dbm, mc->szSessionCacheDataFile,
-	    APR_DBM_RWCREATE, SSL_DBM_FILE_MODE, mc->pPool)) != APR_SUCCESS) {
+            APR_DBM_RWCREATE, SSL_DBM_FILE_MODE, mc->pPool)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rc, s,
                      "Cannot open SSLSessionCache DBM file `%s' for reading "
                      "(fetch)",
@@ -278,7 +278,7 @@ void ssl_scache_dbm_remove(server_rec *s, UCHAR *id, int idlen)
     /* and delete it from the DBM file */
     ssl_mutex_on(s);
     if ((rv = apr_dbm_open(&dbm, mc->szSessionCacheDataFile,
-	    APR_DBM_RWCREATE, SSL_DBM_FILE_MODE, mc->pPool)) != APR_SUCCESS) {
+            APR_DBM_RWCREATE, SSL_DBM_FILE_MODE, mc->pPool)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                      "Cannot open SSLSessionCache DBM file `%s' for writing "
                      "(delete)",
@@ -384,7 +384,7 @@ static void ssl_scache_dbm_expire(server_rec *s)
 
         /* pass 2: delete expired elements */
         if (apr_dbm_open(&dbm, mc->szSessionCacheDataFile,
-		APR_DBM_RWCREATE,SSL_DBM_FILE_MODE, p) != APR_SUCCESS) {
+                APR_DBM_RWCREATE,SSL_DBM_FILE_MODE, p) != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                          "Cannot re-open SSLSessionCache DBM file `%s' for "
                          "expiring",
@@ -431,7 +431,7 @@ void ssl_scache_dbm_status(request_rec *r, int flags, apr_pool_t *p)
      * XXX - Check what pool is to be used - TBD
      */
     if ((rv = apr_dbm_open(&dbm, mc->szSessionCacheDataFile,
-	                       APR_DBM_RWCREATE, SSL_DBM_FILE_MODE,
+                               APR_DBM_RWCREATE, SSL_DBM_FILE_MODE,
                            mc->pPool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                      "Cannot open SSLSessionCache DBM file `%s' for status "
diff --git a/modules/ssl/ssl_scache_shmcb.c b/modules/ssl/ssl_scache_shmcb.c
index 15adaf4..741a20e 100644
--- a/modules/ssl/ssl_scache_shmcb.c
+++ b/modules/ssl/ssl_scache_shmcb.c
@@ -210,35 +210,35 @@ typedef struct {
 static unsigned int shmcb_get_safe_uint(unsigned int *);
 static void shmcb_set_safe_uint_ex(unsigned char *, const unsigned char *);
 #define shmcb_set_safe_uint(pdest, src) \
-	do { \
-		unsigned int tmp_uint = src; \
-		shmcb_set_safe_uint_ex((unsigned char *)pdest, \
-			(const unsigned char *)(&tmp_uint)); \
-	} while(0)
+        do { \
+                unsigned int tmp_uint = src; \
+                shmcb_set_safe_uint_ex((unsigned char *)pdest, \
+                        (const unsigned char *)(&tmp_uint)); \
+        } while(0)
 #if 0 /* Unused so far */
 static unsigned long shmcb_get_safe_ulong(unsigned long *);
 static void shmcb_set_safe_ulong_ex(unsigned char *, const unsigned char *);
 #define shmcb_set_safe_ulong(pdest, src) \
-	do { \
-		unsigned long tmp_ulong = src; \
-		shmcb_set_safe_ulong_ex((unsigned char *)pdest, \
-			(const unsigned char *)(&tmp_ulong)); \
-	} while(0)
+        do { \
+                unsigned long tmp_ulong = src; \
+                shmcb_set_safe_ulong_ex((unsigned char *)pdest, \
+                        (const unsigned char *)(&tmp_ulong)); \
+        } while(0)
 #endif
 static time_t shmcb_get_safe_time(time_t *);
 static void shmcb_set_safe_time_ex(unsigned char *, const unsigned char *);
 #define shmcb_set_safe_time(pdest, src) \
-	do { \
-		time_t tmp_time = src; \
-		shmcb_set_safe_time_ex((unsigned char *)pdest, \
-			(const unsigned char *)(&tmp_time)); \
-	} while(0)
+        do { \
+                time_t tmp_time = src; \
+                shmcb_set_safe_time_ex((unsigned char *)pdest, \
+                        (const unsigned char *)(&tmp_time)); \
+        } while(0)
 
 /* This is necessary simply so that the size passed to memset() is not a
  * compile-time constant, preventing the compiler from optimising it. */
 static void shmcb_safe_clear(void *ptr, size_t size)
 {
-	memset(ptr, 0, size);
+        memset(ptr, 0, size);
 }
 
 /* Underlying functions for session-caching */
@@ -279,12 +279,12 @@ static unsigned int shmcb_get_safe_uint(unsigned int *ptr)
 {
     unsigned int ret;
     shmcb_set_safe_uint_ex((unsigned char *)(&ret),
-		    (const unsigned char *)ptr);
+                    (const unsigned char *)ptr);
     return ret;
 }
 
 static void shmcb_set_safe_uint_ex(unsigned char *dest,
-				const unsigned char *src)
+                                const unsigned char *src)
 {
     memcpy(dest, src, sizeof(unsigned int));
 }
@@ -294,12 +294,12 @@ static unsigned long shmcb_get_safe_ulong(unsigned long *ptr)
 {
     unsigned long ret;
     shmcb_set_safe_ulong_ex((unsigned char *)(&ret),
-		    (const unsigned char *)ptr);
+                    (const unsigned char *)ptr);
     return ret;
 }
 
 static void shmcb_set_safe_ulong_ex(unsigned char *dest,
-				const unsigned char *src)
+                                const unsigned char *src)
 {
     memcpy(dest, src, sizeof(unsigned long));
 }
@@ -309,12 +309,12 @@ static time_t shmcb_get_safe_time(time_t * ptr)
 {
     time_t ret;
     shmcb_set_safe_time_ex((unsigned char *)(&ret),
-		    (const unsigned char *)ptr);
+                    (const unsigned char *)ptr);
     return ret;
 }
 
 static void shmcb_set_safe_time_ex(unsigned char *dest,
-				const unsigned char *src)
+                                const unsigned char *src)
 {
     memcpy(dest, src, sizeof(time_t));
 }
diff --git a/modules/test/mod_optional_fn_export.c b/modules/test/mod_optional_fn_export.c
index c03224d..5fcb84a 100644
--- a/modules/test/mod_optional_fn_export.c
+++ b/modules/test/mod_optional_fn_export.c
@@ -26,7 +26,7 @@
 static int TestOptionalFn(const char *szStr)
 {
     ap_log_error(APLOG_MARK,APLOG_ERR,OK,NULL,
-		 "Optional function test said: %s",szStr);
+                 "Optional function test said: %s",szStr);
 
     return OK;
 }
diff --git a/modules/test/mod_optional_fn_import.c b/modules/test/mod_optional_fn_import.c
index 9346d1a..10ea358 100644
--- a/modules/test/mod_optional_fn_import.c
+++ b/modules/test/mod_optional_fn_import.c
@@ -28,7 +28,7 @@ static APR_OPTIONAL_FN_TYPE(TestOptionalFn) *pfn;
 static int ImportLogTransaction(request_rec *r)
 {
     if(pfn)
-	return pfn(r->the_request);
+        return pfn(r->the_request);
     return DECLINED;
 }
 
diff --git a/modules/test/mod_optional_hook_export.c b/modules/test/mod_optional_hook_export.c
index 896ad52..e12e5c2 100644
--- a/modules/test/mod_optional_hook_export.c
+++ b/modules/test/mod_optional_hook_export.c
@@ -20,7 +20,7 @@
 #include "http_protocol.h"
 
 AP_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(int,optional_hook_test,(const char *szStr),
-				    (szStr),OK,DECLINED)
+                                    (szStr),OK,DECLINED)
 
 static int ExportLogTransaction(request_rec *r)
 {
diff --git a/modules/test/mod_optional_hook_import.c b/modules/test/mod_optional_hook_import.c
index 7bca53a..7f9fa00 100644
--- a/modules/test/mod_optional_hook_import.c
+++ b/modules/test/mod_optional_hook_import.c
@@ -22,7 +22,7 @@
 static int ImportOptionalHookTestHook(const char *szStr)
 {
     ap_log_error(APLOG_MARK,APLOG_ERR,OK,NULL,"Optional hook test said: %s",
-		 szStr);
+                 szStr);
 
     return OK;
 }
@@ -30,7 +30,7 @@ static int ImportOptionalHookTestHook(const char *szStr)
 static void ImportRegisterHooks(apr_pool_t *p)
 {
     AP_OPTIONAL_HOOK(optional_hook_test,ImportOptionalHookTestHook,NULL,
-		     NULL,APR_HOOK_MIDDLE);
+                     NULL,APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA optional_hook_import_module=
diff --git a/os/bs2000/ebcdic.c b/os/bs2000/ebcdic.c
index 8bdde8b..74074e3 100644
--- a/os/bs2000/ebcdic.c
+++ b/os/bs2000/ebcdic.c
@@ -18,7 +18,7 @@
 #if APR_CHARSET_EBCDIC
 #include "ebcdic.h"
 /*
-	   Initial Port for  Apache-1.3 by <Martin.Kraemer Mch.SNI.De>
+           Initial Port for  Apache-1.3 by <Martin.Kraemer Mch.SNI.De>
 
 "BS2000 OSD" is a POSIX on a main frame. It is made by Siemens AG, Germany.
 Within the POSIX subsystem, the same character set was chosen as in
@@ -149,37 +149,37 @@ f0    8c 49 cd ce cb cf cc e1  70 c0 de db dc 8d 8e df  *................*
 */
 const unsigned char os_toebcdic[256] = {
 /*00*/  0x00, 0x01, 0x02, 0x03, 0x37, 0x2d, 0x2e, 0x2f,
-	0x16, 0x05, 0x15, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  /*................*/
+        0x16, 0x05, 0x15, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  /*................*/
 /*10*/  0x10, 0x11, 0x12, 0x13, 0x3c, 0x3d, 0x32, 0x26,
-	0x18, 0x19, 0x3f, 0x27, 0x1c, 0x1d, 0x1e, 0x1f,  /*................*/
+        0x18, 0x19, 0x3f, 0x27, 0x1c, 0x1d, 0x1e, 0x1f,  /*................*/
 /*20*/  0x40, 0x5a, 0x7f, 0x7b, 0x5b, 0x6c, 0x50, 0x7d,
-	0x4d, 0x5d, 0x5c, 0x4e, 0x6b, 0x60, 0x4b, 0x61,  /* !"#$%&'()*+,-./ */
+        0x4d, 0x5d, 0x5c, 0x4e, 0x6b, 0x60, 0x4b, 0x61,  /* !"#$%&'()*+,-./ */
 /*30*/  0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
-	0xf8, 0xf9, 0x7a, 0x5e, 0x4c, 0x7e, 0x6e, 0x6f,  /*0123456789:;<=>?*/
+        0xf8, 0xf9, 0x7a, 0x5e, 0x4c, 0x7e, 0x6e, 0x6f,  /*0123456789:;<=>?*/
 /*40*/  0x7c, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
-	0xc8, 0xc9, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6,  /*@ABCDEFGHIJKLMNO*/
+        0xc8, 0xc9, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6,  /*@ABCDEFGHIJKLMNO*/
 /*50*/  0xd7, 0xd8, 0xd9, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
-	0xe7, 0xe8, 0xe9, 0xbb, 0xbc, 0xbd, 0x6a, 0x6d,  /*PQRSTUVWXYZ[\]^_*/
+        0xe7, 0xe8, 0xe9, 0xbb, 0xbc, 0xbd, 0x6a, 0x6d,  /*PQRSTUVWXYZ[\]^_*/
 /*60*/  0x4a, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
-	0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,  /*`abcdefghijklmno*/
+        0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,  /*`abcdefghijklmno*/
 /*70*/  0x97, 0x98, 0x99, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
-	0xa7, 0xa8, 0xa9, 0xfb, 0x4f, 0xfd, 0xff, 0x07,  /*pqrstuvwxyz{|}~.*/
+        0xa7, 0xa8, 0xa9, 0xfb, 0x4f, 0xfd, 0xff, 0x07,  /*pqrstuvwxyz{|}~.*/
 /*80*/  0x20, 0x21, 0x22, 0x23, 0x24, 0x04, 0x06, 0x08,
-	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x09, 0x0a, 0x14,  /*................*/
+        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x09, 0x0a, 0x14,  /*................*/
 /*90*/  0x30, 0x31, 0x25, 0x33, 0x34, 0x35, 0x36, 0x17,
-	0x38, 0x39, 0x3a, 0x3b, 0x1a, 0x1b, 0x3e, 0x5f,  /*................*/
+        0x38, 0x39, 0x3a, 0x3b, 0x1a, 0x1b, 0x3e, 0x5f,  /*................*/
 /*a0*/  0x41, 0xaa, 0xb0, 0xb1, 0x9f, 0xb2, 0xd0, 0xb5,
-	0x79, 0xb4, 0x9a, 0x8a, 0xba, 0xca, 0xaf, 0xa1,  /*................*/
+        0x79, 0xb4, 0x9a, 0x8a, 0xba, 0xca, 0xaf, 0xa1,  /*................*/
 /*b0*/  0x90, 0x8f, 0xea, 0xfa, 0xbe, 0xa0, 0xb6, 0xb3,
-	0x9d, 0xda, 0x9b, 0x8b, 0xb7, 0xb8, 0xb9, 0xab,  /*................*/
+        0x9d, 0xda, 0x9b, 0x8b, 0xb7, 0xb8, 0xb9, 0xab,  /*................*/
 /*c0*/  0x64, 0x65, 0x62, 0x66, 0x63, 0x67, 0x9e, 0x68,
-	0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,  /*................*/
+        0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,  /*................*/
 /*d0*/  0xac, 0x69, 0xed, 0xee, 0xeb, 0xef, 0xec, 0xbf,
-	0x80, 0xe0, 0xfe, 0xdd, 0xfc, 0xad, 0xae, 0x59,  /*................*/
+        0x80, 0xe0, 0xfe, 0xdd, 0xfc, 0xad, 0xae, 0x59,  /*................*/
 /*e0*/  0x44, 0x45, 0x42, 0x46, 0x43, 0x47, 0x9c, 0x48,
-	0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,  /*................*/
+        0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,  /*................*/
 /*f0*/  0x8c, 0x49, 0xcd, 0xce, 0xcb, 0xcf, 0xcc, 0xe1,
-	0x70, 0xc0, 0xde, 0xdb, 0xdc, 0x8d, 0x8e, 0xdf   /*................*/
+        0x70, 0xc0, 0xde, 0xdb, 0xdc, 0x8d, 0x8e, 0xdf   /*................*/
 };
 
 /* Translate a memory block from EBCDIC (host charset) to ASCII (net charset)
@@ -189,22 +189,22 @@ const unsigned char os_toebcdic[256] = {
 void
 ebcdic2ascii(unsigned char *dest, const unsigned char *srce, size_t count)
 {
-	while (count-- != 0) {
-		*dest++ = os_toascii[*srce++];
-	}
+        while (count-- != 0) {
+                *dest++ = os_toascii[*srce++];
+        }
 }
 void
 ebcdic2ascii_strictly(unsigned char *dest, const unsigned char *srce, size_t count)
 {
-	while (count-- != 0) {
-		*dest++ = os_toascii_strictly[*srce++];
-	}
+        while (count-- != 0) {
+                *dest++ = os_toascii_strictly[*srce++];
+        }
 }
 void
 ascii2ebcdic(unsigned char *dest, const unsigned char *srce, size_t count)
 {
-	while (count-- != 0) {
-		*dest++ = os_toebcdic[*srce++];
-	}
+        while (count-- != 0) {
+                *dest++ = os_toebcdic[*srce++];
+        }
 }
 #endif /*APR_CHARSET_EBCDIC*/
diff --git a/os/bs2000/os.c b/os/bs2000/os.c
index cd2407f..b62b668 100644
--- a/os/bs2000/os.c
+++ b/os/bs2000/os.c
@@ -44,8 +44,8 @@ static bs2_ForkType forktype = bs2_unknown;
 static void ap_str_toupper(char *str)
 {
     while (*str) {
-	*str = apr_toupper(*str);
-	++str;
+        *str = apr_toupper(*str);
+        ++str;
     }
 }
 
@@ -90,12 +90,12 @@ int os_init_job_environment(server_rec *server, const char *user_name, int one_p
 
     if (one_process) {
 
-	type = forktype = bs2_noFORK;
+        type = forktype = bs2_noFORK;
 
-	ap_log_error(APLOG_MARK, APLOG_ERR, 0, server,
-		     "The debug mode of Apache should only "
-		     "be started by an unprivileged user!");
-	return 0;
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, server,
+                     "The debug mode of Apache should only "
+                     "be started by an unprivileged user!");
+        return 0;
     }
 
     return 0;
@@ -110,27 +110,27 @@ pid_t os_fork(const char *user)
     switch (os_forktype(0)) {
 
       case bs2_FORK:
-	pid = fork();
-	break;
+        pid = fork();
+        break;
 
       case bs2_UFORK:
-	apr_cpystrn(username, user, sizeof username);
+        apr_cpystrn(username, user, sizeof username);
 
-	/* Make user name all upper case - for some versions of ufork() */
-	ap_str_toupper(username);
+        /* Make user name all upper case - for some versions of ufork() */
+        ap_str_toupper(username);
 
-	pid = ufork(username);
-	if (pid == -1 && errno == EPERM) {
-	    ap_log_error(APLOG_MARK, APLOG_EMERG, errno,
-			 NULL, "ufork: Possible mis-configuration "
-			 "for user %s - Aborting.", user);
-	    exit(1);
-	}
-	break;
+        pid = ufork(username);
+        if (pid == -1 && errno == EPERM) {
+            ap_log_error(APLOG_MARK, APLOG_EMERG, errno,
+                         NULL, "ufork: Possible mis-configuration "
+                         "for user %s - Aborting.", user);
+            exit(1);
+        }
+        break;
 
       default:
-	pid = 0;
-	break;
+        pid = 0;
+        break;
     }
 
     return pid;
diff --git a/os/netware/util_nw.c b/os/netware/util_nw.c
index 02f574b..c52a626 100644
--- a/os/netware/util_nw.c
+++ b/os/netware/util_nw.c
@@ -37,13 +37,13 @@ AP_DECLARE(apr_status_t) ap_os_create_privileged_process(
 
 int  _NonAppCheckUnload( void )
 {
-	return nlmUnloadSignaled(1);
+        return nlmUnloadSignaled(1);
 }
 
 // down server event callback
 void ap_down_server_cb(void *, void *)
 {
-	nlmUnloadSignaled(0);
+        nlmUnloadSignaled(0);
     return;
 }
 
diff --git a/os/unix/unixd.c b/os/unix/unixd.c
index b2f65e3..b1e178d 100644
--- a/os/unix/unixd.c
+++ b/os/unix/unixd.c
@@ -63,49 +63,49 @@ unixd_config_rec unixd_config;
 static int set_group_privs(void)
 {
     if (!geteuid()) {
-	const char *name;
+        const char *name;
 
-	/* Get username if passed as a uid */
+        /* Get username if passed as a uid */
 
-	if (unixd_config.user_name[0] == '#') {
-	    struct passwd *ent;
-	    uid_t uid = atoi(&unixd_config.user_name[1]);
+        if (unixd_config.user_name[0] == '#') {
+            struct passwd *ent;
+            uid_t uid = atoi(&unixd_config.user_name[1]);
 
-	    if ((ent = getpwuid(uid)) == NULL) {
-		ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
-			 "getpwuid: couldn't determine user name from uid %u, "
-			 "you probably need to modify the User directive",
-			 (unsigned)uid);
-		return -1;
-	    }
+            if ((ent = getpwuid(uid)) == NULL) {
+                ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                         "getpwuid: couldn't determine user name from uid %u, "
+                         "you probably need to modify the User directive",
+                         (unsigned)uid);
+                return -1;
+            }
 
-	    name = ent->pw_name;
-	}
-	else
-	    name = unixd_config.user_name;
+            name = ent->pw_name;
+        }
+        else
+            name = unixd_config.user_name;
 
 #if !defined(OS2) && !defined(TPF)
-	/* OS/2 and TPF don't support groups. */
-
-	/*
-	 * Set the GID before initgroups(), since on some platforms
-	 * setgid() is known to zap the group list.
-	 */
-	if (setgid(unixd_config.group_id) == -1) {
-	    ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
-			"setgid: unable to set group id to Group %u",
-			(unsigned)unixd_config.group_id);
-	    return -1;
-	}
-
-	/* Reset `groups' attributes. */
-
-	if (initgroups(name, unixd_config.group_id) == -1) {
-	    ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
-			"initgroups: unable to set groups for User %s "
-			"and Group %u", name, (unsigned)unixd_config.group_id);
-	    return -1;
-	}
+        /* OS/2 and TPF don't support groups. */
+
+        /*
+         * Set the GID before initgroups(), since on some platforms
+         * setgid() is known to zap the group list.
+         */
+        if (setgid(unixd_config.group_id) == -1) {
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                        "setgid: unable to set group id to Group %u",
+                        (unsigned)unixd_config.group_id);
+            return -1;
+        }
+
+        /* Reset `groups' attributes. */
+
+        if (initgroups(name, unixd_config.group_id) == -1) {
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                        "initgroups: unable to set groups for User %s "
+                        "and Group %u", name, (unsigned)unixd_config.group_id);
+            return -1;
+        }
 #endif /* !defined(OS2) && !defined(TPF) */
     }
     return 0;
@@ -115,32 +115,32 @@ static int set_group_privs(void)
 AP_DECLARE(int) unixd_setup_child(void)
 {
     if (set_group_privs()) {
-	return -1;
+        return -1;
     }
 #ifdef MPE
     /* Only try to switch if we're running as MANAGER.SYS */
     if (geteuid() == 1 && unixd_config.user_id > 1) {
-	GETPRIVMODE();
-	if (setuid(unixd_config.user_id) == -1) {
-	    GETUSERMODE();
-	    ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
-			"setuid: unable to change to uid: %ld",
+        GETPRIVMODE();
+        if (setuid(unixd_config.user_id) == -1) {
+            GETUSERMODE();
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                        "setuid: unable to change to uid: %ld",
                         (long) unixd_config.user_id);
-	    exit(1);
-	}
-	GETUSERMODE();
+            exit(1);
+        }
+        GETUSERMODE();
     }
 #else
     /* Only try to switch if we're running as root */
     if (!geteuid() && (
 #ifdef _OSD_POSIX
-	os_init_job_environment(NULL, unixd_config.user_name, ap_exists_config_define("DEBUG")) != 0 ||
+        os_init_job_environment(NULL, unixd_config.user_name, ap_exists_config_define("DEBUG")) != 0 ||
 #endif
-	setuid(unixd_config.user_id) == -1)) {
-	ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
-		    "setuid: unable to change to uid: %ld",
+        setuid(unixd_config.user_id) == -1)) {
+        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                    "setuid: unable to change to uid: %ld",
                     (long) unixd_config.user_id);
-	return -1;
+        return -1;
     }
 #if defined(HAVE_PRCTL) && defined(PR_SET_DUMPABLE) 
     /* this applies to Linux 2.4+ */
@@ -171,15 +171,15 @@ AP_DECLARE(const char *) unixd_set_user(cmd_parms *cmd, void *dummy,
     unixd_config.user_id = ap_uname2id(arg);
 #if !defined (BIG_SECURITY_HOLE) && !defined (OS2)
     if (unixd_config.user_id == 0) {
-	return "Error:\tApache has not been designed to serve pages while\n"
-		"\trunning as root.  There are known race conditions that\n"
-		"\twill allow any local user to read any file on the system.\n"
-		"\tIf you still desire to serve pages as root then\n"
-		"\tadd -DBIG_SECURITY_HOLE to the CFLAGS env variable\n"
-		"\tand then rebuild the server.\n"
-		"\tIt is strongly suggested that you instead modify the User\n"
-		"\tdirective in your httpd.conf file to list a non-root\n"
-		"\tuser.\n";
+        return "Error:\tApache has not been designed to serve pages while\n"
+                "\trunning as root.  There are known race conditions that\n"
+                "\twill allow any local user to read any file on the system.\n"
+                "\tIf you still desire to serve pages as root then\n"
+                "\tadd -DBIG_SECURITY_HOLE to the CFLAGS env variable\n"
+                "\tand then rebuild the server.\n"
+                "\tIt is strongly suggested that you instead modify the User\n"
+                "\tdirective in your httpd.conf file to list a non-root\n"
+                "\tuser.\n";
     }
 #endif
 
@@ -330,7 +330,7 @@ static apr_status_t ap_unix_create_privileged_process(
     if (args) {
         while (args[i]) {
             i++;
-	    }
+            }
     }
     /* allocate space for 4 new args, the input args, and a null terminator */
     newargs = apr_palloc(p, sizeof(char *) * (i + 4));
@@ -622,8 +622,8 @@ static bs2_ForkType forktype = bs2_unknown;
 static void ap_str_toupper(char *str)
 {
     while (*str) {
-	*str = apr_toupper(*str);
-	++str;
+        *str = apr_toupper(*str);
+        ++str;
     }
 }
 
@@ -668,12 +668,12 @@ int os_init_job_environment(server_rec *server, const char *user_name, int one_p
 
     if (one_process) {
 
-	type = forktype = bs2_noFORK;
+        type = forktype = bs2_noFORK;
 
-	ap_log_error(APLOG_MARK, APLOG_ERR, 0, server,
-		     "The debug mode of Apache should only "
-		     "be started by an unprivileged user!");
-	return 0;
+        ap_log_error(APLOG_MARK, APLOG_ERR, 0, server,
+                     "The debug mode of Apache should only "
+                     "be started by an unprivileged user!");
+        return 0;
     }
 
     return 0;
@@ -688,27 +688,27 @@ pid_t os_fork(const char *user)
     switch (os_forktype(0)) {
 
       case bs2_FORK:
-	pid = fork();
-	break;
+        pid = fork();
+        break;
 
       case bs2_UFORK:
-	apr_cpystrn(username, user, sizeof username);
+        apr_cpystrn(username, user, sizeof username);
 
-	/* Make user name all upper case - for some versions of ufork() */
-	ap_str_toupper(username);
+        /* Make user name all upper case - for some versions of ufork() */
+        ap_str_toupper(username);
 
-	pid = ufork(username);
-	if (pid == -1 && errno == EPERM) {
-	    ap_log_error(APLOG_MARK, APLOG_EMERG, errno,
-			 NULL, "ufork: Possible mis-configuration "
-			 "for user %s - Aborting.", user);
-	    exit(1);
-	}
-	break;
+        pid = ufork(username);
+        if (pid == -1 && errno == EPERM) {
+            ap_log_error(APLOG_MARK, APLOG_EMERG, errno,
+                         NULL, "ufork: Possible mis-configuration "
+                         "for user %s - Aborting.", user);
+            exit(1);
+        }
+        break;
 
       default:
-	pid = 0;
-	break;
+        pid = 0;
+        break;
     }
 
     return pid;
diff --git a/os/win32/util_win32.c b/os/win32/util_win32.c
index 36d99d6..537a882 100644
--- a/os/win32/util_win32.c
+++ b/os/win32/util_win32.c
@@ -121,13 +121,13 @@ PSECURITY_ATTRIBUTES GetNullACL()
     }
     apr_set_os_error(0);
     if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)
-	|| apr_get_os_error()) {
+        || apr_get_os_error()) {
         LocalFree( pSD );
         LocalFree( sa );
         return NULL;
     }
     if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE)
-	|| apr_get_os_error()) {
+        || apr_get_os_error()) {
         LocalFree( pSD );
         LocalFree( sa );
         return NULL;
diff --git a/server/connection.c b/server/connection.c
index 751892f..49f8ef0 100644
--- a/server/connection.c
+++ b/server/connection.c
@@ -34,8 +34,8 @@
 
 APR_HOOK_STRUCT(
             APR_HOOK_LINK(create_connection)
-	    APR_HOOK_LINK(process_connection)
-	    APR_HOOK_LINK(pre_connection)
+            APR_HOOK_LINK(process_connection)
+            APR_HOOK_LINK(pre_connection)
 )
 AP_IMPLEMENT_HOOK_RUN_FIRST(conn_rec *,create_connection,
                             (apr_pool_t *p, server_rec *server, apr_socket_t *csd, long conn_id, void *sbh, apr_bucket_alloc_t *alloc),
diff --git a/server/core.c b/server/core.c
index 9d2778a..9dff466 100644
--- a/server/core.c
+++ b/server/core.c
@@ -260,7 +260,7 @@ static void *merge_core_dir_configs(apr_pool_t *a, void *basev, void *newv)
     }
 
     if (!(new->override_opts & OPT_UNSET)) {
-	conf->override_opts = new->override_opts;
+        conf->override_opts = new->override_opts;
     }
 
     if (new->ap_default_type) {
@@ -750,7 +750,7 @@ char *ap_response_code_string(request_rec *r, int error_index)
                                                       &core_module);
 
     if (dirconf->response_code_strings == NULL) {
-	return NULL;
+        return NULL;
     }
 
     if (dirconf->response_code_strings[error_index] == &errordocument_default) {
@@ -1343,21 +1343,21 @@ static const char *set_override(cmd_parms *cmd, void *d_, const char *l)
     while (l[0]) {
         w = ap_getword_conf(cmd->pool, &l);
 
-	k = w;
-	v = strchr(k, '=');
-	if (v) {
-		*v++ = '\0';
-	}
+        k = w;
+        v = strchr(k, '=');
+        if (v) {
+                *v++ = '\0';
+        }
 
         if (!strcasecmp(w, "Limit")) {
             d->override |= OR_LIMIT;
         }
         else if (!strcasecmp(k, "Options")) {
             d->override |= OR_OPTIONS;
-	    if (v) 
+            if (v) 
                 set_allow_opts(cmd, &(d->override_opts), v);
-	    else
-	        d->override_opts = OPT_ALL;
+            else
+                d->override_opts = OPT_ALL;
         }
         else if (!strcasecmp(w, "FileInfo")) {
             d->override |= OR_FILEINFO;
@@ -1437,8 +1437,8 @@ static const char *set_options(cmd_parms *cmd, void *d_, const char *l)
             return apr_pstrcat(cmd->pool, "Illegal option ", w, NULL);
         }
 
-	if (!(cmd->override_opts & opt) && opt != OPT_NONE) {
-	    return apr_pstrcat(cmd->pool, "Option ", w, " not allowed here", NULL);
+        if (!(cmd->override_opts & opt) && opt != OPT_NONE) {
+            return apr_pstrcat(cmd->pool, "Option ", w, " not allowed here", NULL);
         }
         else if (action == '-') {
             /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
diff --git a/server/mpm/beos/beos.c b/server/mpm/beos/beos.c
index d8be566..a04fc62 100644
--- a/server/mpm/beos/beos.c
+++ b/server/mpm/beos/beos.c
@@ -296,7 +296,7 @@ static apr_status_t beos_accept(void **accepted, ap_listen_rec *lr, apr_pool_t *
     if (APR_STATUS_IS_EINTR(status)) {
         return status;
     }
-	/* This switch statement provides us with better error details. */
+        /* This switch statement provides us with better error details. */
     switch (status) {
 #ifdef ECONNABORTED
         case ECONNABORTED:
@@ -376,7 +376,7 @@ static void set_signals(void)
     /* These next two are handled by sig_term */
     sa.sa_handler = sig_term;
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
     if (sigaction(SIGINT, &sa, NULL) < 0)
         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGINT)");
     
@@ -393,7 +393,7 @@ static void set_signals(void)
     if (sigaction(SIGHUP, &sa, NULL) < 0)
     	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGHUP)");
     if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(" AP_SIG_GRACEFUL_STRING ")");
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(" AP_SIG_GRACEFUL_STRING ")");
 }
 
 /*****************************************************************
@@ -489,7 +489,7 @@ static int32 worker_thread(void *dummy)
 
     mpm_state = AP_MPMQ_RUNNING;
 
-	while (!this_worker_should_exit) {
+        while (!this_worker_should_exit) {
         conn_rec *current_conn;
         void *csd;
 
@@ -603,7 +603,7 @@ static int make_worker(int slot)
     thread_id tid;
 
     if (slot + 1 > ap_max_child_assigned)
-	    ap_max_child_assigned = slot + 1;
+            ap_max_child_assigned = slot + 1;
 
     (void) ap_update_child_status_from_indexes(0, slot, SERVER_STARTING, (request_rec*)NULL);
 
@@ -663,7 +663,7 @@ static void startup_threads(int number_to_start)
             continue;
 
         if (make_worker(i) < 0)
-	        break;
+                break;
 
         --number_to_start;
     }
@@ -704,23 +704,23 @@ static void perform_idle_server_maintenance(void)
         }
 
     	if (i >= ap_max_child_assigned && free_length >= spawn_rate) {
-	         break;
-	    }
+                 break;
+            }
     }
     ap_max_child_assigned = last_non_dead + 1;
 
     if (free_length > 0) {
     	for (i = 0; i < free_length; ++i) {
-	        make_worker(free_slots[i]);
-	    }
-	    /* the next time around we want to spawn twice as many if this
-	     * wasn't good enough, but not if we've just done a graceful
-	     */
-	    if (hold_off_on_exponential_spawning) {
-	        --hold_off_on_exponential_spawning;
-	    } else if (spawn_rate < MAX_SPAWN_RATE) {
-	        spawn_rate *= 2;
-	    }
+                make_worker(free_slots[i]);
+            }
+            /* the next time around we want to spawn twice as many if this
+             * wasn't good enough, but not if we've just done a graceful
+             */
+            if (hold_off_on_exponential_spawning) {
+                --hold_off_on_exponential_spawning;
+            } else if (spawn_rate < MAX_SPAWN_RATE) {
+                spawn_rate *= 2;
+            }
     } else {
         spawn_rate = 1;
     }
@@ -759,13 +759,13 @@ static void server_main_loop(int remaining_threads_to_start)
                                                            (request_rec*)NULL);
                 
                 if (remaining_threads_to_start
-		            && child_slot < ap_thread_limit) {
+                            && child_slot < ap_thread_limit) {
                     /* we're still doing a 1-for-1 replacement of dead
                      * children with new children
                      */
                     make_worker(child_slot);
                     --remaining_threads_to_start;
-		        }
+                        }
 /* TODO
 #if APR_HAS_OTHER_CHILD
             }
@@ -779,9 +779,9 @@ static void server_main_loop(int remaining_threads_to_start)
                  * child.
                  */
                  ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf,
-			                  "long lost child came home! (pid %ld)", pid.pid);
+                                          "long lost child came home! (pid %ld)", pid.pid);
             }
-	    
+            
             /* Don't perform idle maintenance when a child dies,
              * only do it when there's a timeout.  Remember only a
              * finite number of children can die, and it's pretty
@@ -789,7 +789,7 @@ static void server_main_loop(int remaining_threads_to_start)
              */
              continue;
          }
-	     else if (remaining_threads_to_start) {
+             else if (remaining_threads_to_start) {
              /* we hit a 1 second timeout in which none of the previous
               * generation of children needed to be reaped... so assume
               * they're all done, and pick up the slack if any is left.
@@ -913,7 +913,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     remaining_threads_to_start = ap_threads_to_start;
     /* sanity check on the number to start... */
     if (remaining_threads_to_start > ap_thread_limit) {
-	    remaining_threads_to_start = ap_thread_limit;
+            remaining_threads_to_start = ap_thread_limit;
     }
 
     /* If we're doing the single process thing or we're in a graceful_restart
@@ -922,11 +922,11 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
      * do we??
      */
     if (!is_graceful && !one_process) {
-	    startup_threads(remaining_threads_to_start);
-	    remaining_threads_to_start = 0;
+            startup_threads(remaining_threads_to_start);
+            remaining_threads_to_start = 0;
     } else {
-	    /* give the system some time to recover before kicking into
-	     * exponential mode */
+            /* give the system some time to recover before kicking into
+             * exponential mode */
         hold_off_on_exponential_spawning = 10;
     }
 
@@ -934,11 +934,11 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
      * record that we've entered the world !
      */
     ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
-		"%s configured -- resuming normal operations",
-		ap_get_server_version());
+                "%s configured -- resuming normal operations",
+                ap_get_server_version());
 
     ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
-		"Server built: %s", ap_get_server_built());
+                "Server built: %s", ap_get_server_built());
 
     restart_pending = shutdown_pending = 0;
 
@@ -1003,16 +1003,16 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
     if (is_graceful) {
         ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
-		    AP_SIG_GRACEFUL_STRING " received.  Doing graceful restart");
+                    AP_SIG_GRACEFUL_STRING " received.  Doing graceful restart");
     } else {
         /* Kill 'em all.  Since the child acts the same on the parents SIGTERM 
          * and a SIGHUP, we may as well use the same signal, because some user
          * pthreads are stealing signals from us left and right.
          */
-	    
+            
         ap_reclaim_child_processes(1);		/* Start with SIGTERM */
-	    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
-		    "SIGHUP received.  Attempting to restart");
+            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+                    "SIGHUP received.  Attempting to restart");
     }
     
     /* just before we go, tidy up the lock we created to prevent a 
@@ -1070,7 +1070,7 @@ static int beos_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptem
     ap_pid_fname = DEFAULT_PIDLOG;
     ap_max_requests_per_thread = DEFAULT_MAX_REQUESTS_PER_THREAD;
 #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
-	ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
+        ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
 #endif
 
     apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
diff --git a/server/mpm/experimental/event/fdqueue.c b/server/mpm/experimental/event/fdqueue.c
index b016d7e..4245c2a 100644
--- a/server/mpm/experimental/event/fdqueue.c
+++ b/server/mpm/experimental/event/fdqueue.c
@@ -26,7 +26,7 @@ typedef struct recycled_pool
 struct fd_queue_info_t
 {
     apr_int32_t idlers;      /**
-	                          * 0 or positive: number of idle worker threads
+                                  * 0 or positive: number of idle worker threads
                               * negative: number of threads blocked waiting
                               *           for an idle worker
                               */
diff --git a/server/mpm/experimental/leader/leader.c b/server/mpm/experimental/leader/leader.c
index f9d6a2c..329d043 100644
--- a/server/mpm/experimental/leader/leader.c
+++ b/server/mpm/experimental/leader/leader.c
@@ -1534,9 +1534,9 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                 "Server built: %s", ap_get_server_built());
 #ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
-		"AcceptMutex: %s (default: %s)",
-		apr_proc_mutex_name(accept_mutex),
-		apr_proc_mutex_defname());
+                "AcceptMutex: %s (default: %s)",
+                apr_proc_mutex_name(accept_mutex),
+                apr_proc_mutex_defname());
 #endif
     restart_pending = shutdown_pending = 0;
     mpm_state = AP_MPMQ_RUNNING;
@@ -1550,9 +1550,9 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
          * (By "gracefully" we don't mean graceful in the same sense as 
          * "apachectl graceful" where we allow old connections to finish.)
          */
-	if (unixd_killpg(getpgrp(), SIGTERM) < 0) {
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "killpg SIGTERM");
-	}
+        if (unixd_killpg(getpgrp(), SIGTERM) < 0) {
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "killpg SIGTERM");
+        }
         ap_reclaim_child_processes(1);                /* Start with SIGTERM */
 
         if (!child_fatal) {
@@ -1726,7 +1726,7 @@ static int leader_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
     ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
     ap_extended_status = 0;
 #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
-	ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
+        ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
 #endif
 
     apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
@@ -1918,9 +1918,9 @@ static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *ar
        server_limit = MAX_SERVER_LIMIT;
     } 
     else if (server_limit < 1) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "WARNING: Require ServerLimit > 0, setting to 1");
-	server_limit = 1;
+        server_limit = 1;
     }
     return NULL;
 }
@@ -1958,9 +1958,9 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
        thread_limit = MAX_THREAD_LIMIT;
     } 
     else if (thread_limit < 1) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "WARNING: Require ThreadLimit > 0, setting to 1");
-	thread_limit = 1;
+        thread_limit = 1;
     }
     return NULL;
 }
diff --git a/server/mpm/experimental/perchild/perchild.c b/server/mpm/experimental/perchild/perchild.c
index bf38a7c..bae4dc3 100644
--- a/server/mpm/experimental/perchild/perchild.c
+++ b/server/mpm/experimental/perchild/perchild.c
@@ -1319,9 +1319,9 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                  "Server built: %s", ap_get_server_built());
 #ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
-		"AcceptMutex: %s (default: %s)",
-		apr_proc_mutex_name(process_accept_mutex),
-		apr_proc_mutex_defname());
+                "AcceptMutex: %s (default: %s)",
+                apr_proc_mutex_name(process_accept_mutex),
+                apr_proc_mutex_defname());
 #endif
     restart_pending = shutdown_pending = 0;
 
@@ -1497,7 +1497,7 @@ static int perchild_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptem
     ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
     curr_child_num = 0;
 #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
-	ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
+        ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
 #endif
 
     apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
@@ -1956,9 +1956,9 @@ static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *ar
        server_limit = MAX_SERVER_LIMIT;
     } 
     else if (server_limit < 1) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "WARNING: Require ServerLimit > 0, setting to 1");
-	server_limit = 1;
+        server_limit = 1;
     }
     return NULL;
 }
@@ -1996,9 +1996,9 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
        thread_limit = MAX_THREAD_LIMIT;
     } 
     else if (thread_limit < 1) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "WARNING: Require ThreadLimit > 0, setting to 1");
-	thread_limit = 1;
+        thread_limit = 1;
     }
     return NULL;
 }
diff --git a/server/mpm/experimental/threadpool/threadpool.c b/server/mpm/experimental/threadpool/threadpool.c
index 7c9281b..2ea0737 100644
--- a/server/mpm/experimental/threadpool/threadpool.c
+++ b/server/mpm/experimental/threadpool/threadpool.c
@@ -1783,9 +1783,9 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                 "Server built: %s", ap_get_server_built());
 #ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
-		"AcceptMutex: %s (default: %s)",
-		apr_proc_mutex_name(accept_mutex),
-		apr_proc_mutex_defname());
+                "AcceptMutex: %s (default: %s)",
+                apr_proc_mutex_name(accept_mutex),
+                apr_proc_mutex_defname());
 #endif
     restart_pending = shutdown_pending = 0;
     mpm_state = AP_MPMQ_RUNNING;
@@ -1980,7 +1980,7 @@ static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
     ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
     ap_extended_status = 0;
 #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
-	ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
+        ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
 #endif
 
     apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
@@ -2172,9 +2172,9 @@ static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *ar
        server_limit = MAX_SERVER_LIMIT;
     } 
     else if (server_limit < 1) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "WARNING: Require ServerLimit > 0, setting to 1");
-	server_limit = 1;
+        server_limit = 1;
     }
     return NULL;
 }
@@ -2212,9 +2212,9 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
        thread_limit = MAX_THREAD_LIMIT;
     } 
     else if (thread_limit < 1) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "WARNING: Require ThreadLimit > 0, setting to 1");
-	thread_limit = 1;
+        thread_limit = 1;
     }
     return NULL;
 }
diff --git a/server/mpm/mpmt_os2/mpmt_os2.c b/server/mpm/mpmt_os2/mpmt_os2.c
index 3c8a57e..ac40874 100644
--- a/server/mpm/mpmt_os2/mpmt_os2.c
+++ b/server/mpm/mpmt_os2/mpmt_os2.c
@@ -269,15 +269,15 @@ static char master_main()
 
     ap_scoreboard_image->global->restart_time = apr_time_now();
     ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
-		"%s configured -- resuming normal operations",
-		ap_get_server_version());
+                "%s configured -- resuming normal operations",
+                ap_get_server_version());
     ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
-		"Server built: %s", ap_get_server_built());
+                "Server built: %s", ap_get_server_built());
 #ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
-		"AcceptMutex: %s (default: %s)",
-		apr_proc_mutex_name(accept_mutex),
-		apr_proc_mutex_defname());
+                "AcceptMutex: %s (default: %s)",
+                apr_proc_mutex_name(accept_mutex),
+                apr_proc_mutex_defname());
 #endif
     if (one_process) {
         ap_scoreboard_image->parent[0].pid = getpid();
@@ -398,7 +398,7 @@ static void set_signals()
     sa.sa_handler = sig_term;
 
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
 
     if (sigaction(SIGINT, &sa, NULL) < 0)
         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGINT)");
@@ -471,7 +471,7 @@ static int mpmt_os2_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *
     ap_min_spare_threads = DEFAULT_MIN_SPARE_THREAD;
     ap_max_spare_threads = DEFAULT_MAX_SPARE_THREAD;
 #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
-	ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
+        ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
 #endif
 
     return OK;
@@ -501,7 +501,7 @@ static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy, const char
 
 
 static const char *set_min_spare_threads(cmd_parms *cmd, void *dummy,
-					 const char *arg)
+                                         const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
 
@@ -527,7 +527,7 @@ static const char *set_min_spare_threads(cmd_parms *cmd, void *dummy,
 
 
 static const char *set_max_spare_threads(cmd_parms *cmd, void *dummy,
-					 const char *arg)
+                                         const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
 
diff --git a/server/mpm/mpmt_os2/mpmt_os2_child.c b/server/mpm/mpmt_os2/mpmt_os2_child.c
index 95dd515..b1f03e7 100644
--- a/server/mpm/mpmt_os2/mpmt_os2_child.c
+++ b/server/mpm/mpmt_os2/mpmt_os2_child.c
@@ -81,7 +81,7 @@ static void server_maintenance(void *vpArg);
 static void clean_child_exit(int code)
 {
     if (pchild) {
-	apr_pool_destroy(pchild);
+        apr_pool_destroy(pchild);
     }
 
     exit(code);
@@ -471,10 +471,10 @@ static void set_signals()
     sa.sa_handler = sig_term;
 
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
 
     sa.sa_handler = sig_hup;
 
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGHUP)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGHUP)");
 }
diff --git a/server/mpm/netware/mpm_netware.c b/server/mpm/netware/mpm_netware.c
index 65b37b9..282c320 100644
--- a/server/mpm/netware/mpm_netware.c
+++ b/server/mpm/netware/mpm_netware.c
@@ -1127,7 +1127,7 @@ static int CommandLineInterpreter(scr_t screenID, const char *commandLine)
     	    ap_show_modules();
         }
         else if (!strnicmp("DIRECTIVES",&szcommandLine[iCommandLen],3)) {
-	        ap_show_directives();
+                ap_show_directives();
         }
         else if (!strnicmp("SHUTDOWN",&szcommandLine[iCommandLen],3)) {
             printf("Shutdown Requested...\n");
diff --git a/server/mpm/winnt/child.c b/server/mpm/winnt/child.c
index d560187..96942d1 100644
--- a/server/mpm/winnt/child.c
+++ b/server/mpm/winnt/child.c
@@ -276,7 +276,7 @@ static void add_job(SOCKET sock)
 
     new_job = (joblist *) malloc(sizeof(joblist));
     if (new_job == NULL) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "Ouch!  Out of memory in add_job()!");
         return;
     }
@@ -286,10 +286,10 @@ static void add_job(SOCKET sock)
     apr_thread_mutex_lock(allowed_globals.jobmutex);
 
     if (allowed_globals.jobtail != NULL)
-	allowed_globals.jobtail->next = new_job;
+        allowed_globals.jobtail->next = new_job;
     allowed_globals.jobtail = new_job;
     if (!allowed_globals.jobhead)
-	allowed_globals.jobhead = new_job;
+        allowed_globals.jobhead = new_job;
     allowed_globals.jobcount++;
     ReleaseSemaphore(allowed_globals.jobsemaphore, 1, NULL);
 
@@ -307,13 +307,13 @@ static SOCKET remove_job(void)
 
     if (shutdown_in_progress && !allowed_globals.jobhead) {
         apr_thread_mutex_unlock(allowed_globals.jobmutex);
-	return (INVALID_SOCKET);
+        return (INVALID_SOCKET);
     }
     job = allowed_globals.jobhead;
     ap_assert(job);
     allowed_globals.jobhead = job->next;
     if (allowed_globals.jobhead == NULL)
-	allowed_globals.jobtail = NULL;
+        allowed_globals.jobtail = NULL;
     apr_thread_mutex_unlock(allowed_globals.jobmutex);
     sock = job->sock;
     free(job);
@@ -356,9 +356,9 @@ static unsigned int __stdcall win9x_accept(void * dummy)
     head_listener = ap_listeners;
 
     while (!shutdown_in_progress) {
-	tv.tv_sec = wait_time;
-	tv.tv_usec = 0;
-	memcpy(&main_fds, &listenfds, sizeof(fd_set));
+        tv.tv_sec = wait_time;
+        tv.tv_usec = 0;
+        memcpy(&main_fds, &listenfds, sizeof(fd_set));
 
         /* First parameter of select() is ignored on Windows */
         rc = select(0, &main_fds, NULL, NULL, &tv);
@@ -381,30 +381,30 @@ static unsigned int __stdcall win9x_accept(void * dummy)
                              "Too many errors in select loop. Child process exiting.");
                 break;
             }
-	} else {
-	    ap_listen_rec *lr;
+        } else {
+            ap_listen_rec *lr;
 
-	    lr = find_ready_listener(&main_fds);
-	    if (lr != NULL) {
+            lr = find_ready_listener(&main_fds);
+            if (lr != NULL) {
                 /* fetch the native socket descriptor */
                 apr_os_sock_get(&nsd, lr->sd);
-	    }
-	}
+            }
+        }
 
-	do {
+        do {
             clen = sizeof(sa_client);
             csd = accept(nsd, (struct sockaddr *) &sa_client, &clen);
         } while (csd < 0 && APR_STATUS_IS_EINTR(apr_get_netos_error()));
 
-	if (csd < 0) {
+        if (csd < 0) {
             if (APR_STATUS_IS_ECONNABORTED(apr_get_netos_error())) {
-		ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_netos_error(), ap_server_conf,
-			    "accept: (client socket)");
+                ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_netos_error(), ap_server_conf,
+                            "accept: (client socket)");
             }
-	}
-	else {
-	    add_job(csd);
-	}
+        }
+        else {
+            add_job(csd);
+        }
     }
     SetEvent(exit_event);
     return 0;
@@ -809,7 +809,7 @@ static void cleanup_thread(HANDLE *handles, int *thread_cnt, int thread_to_clean
 
     CloseHandle(handles[thread_to_clean]);
     for (i = thread_to_clean; i < ((*thread_cnt) - 1); i++)
-	handles[i] = handles[i + 1];
+        handles[i] = handles[i + 1];
     (*thread_cnt)--;
 }
 
diff --git a/server/mpm/winnt/mpm_winnt.c b/server/mpm/winnt/mpm_winnt.c
index 565edb3..a52ada8 100644
--- a/server/mpm/winnt/mpm_winnt.c
+++ b/server/mpm/winnt/mpm_winnt.c
@@ -132,9 +132,9 @@ static const char *set_threads_per_child (cmd_parms *cmd, void *dummy, char *arg
         ap_threads_per_child = thread_limit;
     }
     else if (ap_threads_per_child < 1) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "WARNING: Require ThreadsPerChild > 0, setting to 1");
-	ap_threads_per_child = 1;
+        ap_threads_per_child = 1;
     }
     return NULL;
 }
@@ -171,9 +171,9 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
        thread_limit = MAX_THREAD_LIMIT;
     } 
     else if (thread_limit < 1) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "WARNING: Require ThreadLimit > 0, setting to 1");
-	thread_limit = 1;
+        thread_limit = 1;
     }
     return NULL;
 }
@@ -244,9 +244,9 @@ void setup_signal_names(char *prefix)
 {
     apr_snprintf(signal_name_prefix, sizeof(signal_name_prefix), prefix);    
     apr_snprintf(signal_shutdown_name, sizeof(signal_shutdown_name), 
-	"%s_shutdown", signal_name_prefix);    
+        "%s_shutdown", signal_name_prefix);    
     apr_snprintf(signal_restart_name, sizeof(signal_restart_name), 
-	"%s_restart", signal_name_prefix);    
+        "%s_restart", signal_name_prefix);    
 }
 
 int volatile is_graceful = 0;
@@ -277,7 +277,7 @@ AP_DECLARE(void) ap_signal_parent(ap_signal_parent_e type)
                break;
            }
         }
-	return;
+        return;
     }
 
     switch(type) {
@@ -300,19 +300,19 @@ AP_DECLARE(void) ap_signal_parent(ap_signal_parent_e type)
 
     e = OpenEvent(EVENT_MODIFY_STATE, FALSE, signal_name);
     if (!e) {
-	/* Um, problem, can't signal the parent, which means we can't
-	 * signal ourselves to die. Ignore for now...
-	 */
-	ap_log_error(APLOG_MARK, APLOG_EMERG, apr_get_os_error(), ap_server_conf,
+        /* Um, problem, can't signal the parent, which means we can't
+         * signal ourselves to die. Ignore for now...
+         */
+        ap_log_error(APLOG_MARK, APLOG_EMERG, apr_get_os_error(), ap_server_conf,
                      "OpenEvent on %s event", signal_name);
-	return;
+        return;
     }
     if (SetEvent(e) == 0) {
-	/* Same problem as above */
-	ap_log_error(APLOG_MARK, APLOG_EMERG, apr_get_os_error(), ap_server_conf,
+        /* Same problem as above */
+        ap_log_error(APLOG_MARK, APLOG_EMERG, apr_get_os_error(), ap_server_conf,
                      "SetEvent on %s event", signal_name);
-	CloseHandle(e);
-	return;
+        CloseHandle(e);
+        return;
     }
     CloseHandle(e);
 }
@@ -390,7 +390,7 @@ void get_handles_from_parent(server_rec *s, HANDLE *child_exit_event,
 
     rv = ap_reopen_scoreboard(s->process->pool, scoreboard_shm, 1);
     if (rv || !(sb_shared = apr_shm_baseaddr_get(*scoreboard_shm))) {
-	ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, 
                      "Child %d: Unable to reopen the scoreboard from the parent", my_pid);
         exit(APEXIT_CHILDINIT);
     }
@@ -1402,7 +1402,7 @@ static int winnt_pre_config(apr_pool_t *pconf_, apr_pool_t *plog, apr_pool_t *pt
     ap_pid_fname = DEFAULT_PIDLOG;
     ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
 #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
-	ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
+        ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
 #endif
     /* use_acceptex which is enabled by default is not available on Win9x.
      */
diff --git a/server/mpm/winnt/service.c b/server/mpm/winnt/service.c
index 4d24891..67902e7 100644
--- a/server/mpm/winnt/service.c
+++ b/server/mpm/winnt/service.c
@@ -181,9 +181,9 @@ static LRESULT CALLBACK monitor_service_9x_proc(HWND hWnd, UINT msg,
             && (die_on_logoff || (lParam != ENDSESSION_LOGOFF)))
     {
         ap_signal_parent(SIGNAL_PARENT_SHUTDOWN);
-	if (wParam)
+        if (wParam)
             /* Don't leave this message until we are dead! */
-	    WaitForSingleObject(globdat.mpm_thread, 30000);
+            WaitForSingleObject(globdat.mpm_thread, 30000);
         return 0;
     }
     return (DefWindowProc(hWnd, msg, wParam, lParam));
@@ -214,9 +214,9 @@ static DWORD WINAPI monitor_service_9x_thread(void *service_name)
     wc.hbrBackground = NULL;
     wc.lpszMenuName  = NULL;
     if (service_name)
-	wc.lpszClassName = "ApacheWin95ServiceMonitor";
+        wc.lpszClassName = "ApacheWin95ServiceMonitor";
     else
-	wc.lpszClassName = "ApacheWin95SystemMonitor";
+        wc.lpszClassName = "ApacheWin95SystemMonitor";
  
     die_on_logoff = service_name ? FALSE : TRUE;
 
@@ -255,8 +255,8 @@ static DWORD WINAPI monitor_service_9x_thread(void *service_name)
         if (msg.message == WM_CLOSE)
             DestroyWindow(hwndMain); 
         else {
-	    TranslateMessage(&msg);
-	    DispatchMessage(&msg);
+            TranslateMessage(&msg);
+            DispatchMessage(&msg);
         }
     }
     globdat.service_thread_id = 0;
@@ -397,7 +397,7 @@ static int ReportStatusToSCMgr(int currentState, int exitCode, int waitHint)
         }
         else {
             globdat.ssStatus.dwCheckPoint = ++checkPoint;
-	    globdat.ssStatus.dwControlsAccepted = 0;
+            globdat.ssStatus.dwControlsAccepted = 0;
             if(waitHint)
                 globdat.ssStatus.dwWaitHint = waitHint;
         }
@@ -797,7 +797,7 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
     apr_status_t rv;
     
     fprintf(stderr,reconfig ? "Reconfiguring the %s service\n"
-		   : "Installing the %s service\n", mpm_display_name);
+                   : "Installing the %s service\n", mpm_display_name);
 
     /* ###: utf-ize */
     if (GetModuleFileName(NULL, exe_path, sizeof(exe_path)) == 0)
@@ -844,10 +844,10 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
                 ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_ERR, 
                              apr_get_os_error(), NULL,
                              "ChangeServiceConfig failed");
-	        /* !schService aborts configuration below */
-	        CloseServiceHandle(schService);
-	        schService = NULL;
-	    }
+                /* !schService aborts configuration below */
+                CloseServiceHandle(schService);
+                schService = NULL;
+            }
         }
         else {
             /* RPCSS is the Remote Procedure Call (RPC) Locator required 
@@ -880,7 +880,7 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
                 return (rv);
             }
         }
-	
+        
         CloseServiceHandle(schService);
         CloseServiceHandle(schSCManager);
     }
@@ -980,7 +980,7 @@ apr_status_t mpm_service_uninstall(void)
         if (!schService) {
            rv = apr_get_os_error();
            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
-			"%s: OpenService failed", mpm_display_name);
+                        "%s: OpenService failed", mpm_display_name);
            return (rv);
         }
         
@@ -996,7 +996,7 @@ apr_status_t mpm_service_uninstall(void)
 
         if (DeleteService(schService) == 0) {
             rv = apr_get_os_error();
-	    ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
                          "%s: Failed to delete the service.", mpm_display_name);
             return (rv);
         }
@@ -1019,7 +1019,7 @@ apr_status_t mpm_service_uninstall(void)
             ap_regkey_close(key);
         }
         if (rv != APR_SUCCESS) {
-	    ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
                          "%s: Failed to remove the RunServices registry "
                          "entry.", mpm_display_name);
         }
diff --git a/server/mpm/worker/worker.c b/server/mpm/worker/worker.c
index 1f46ea6..e0d0830 100644
--- a/server/mpm/worker/worker.c
+++ b/server/mpm/worker/worker.c
@@ -1714,9 +1714,9 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                 "Server built: %s", ap_get_server_built());
 #ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
-		"AcceptMutex: %s (default: %s)",
-		apr_proc_mutex_name(accept_mutex),
-		apr_proc_mutex_defname());
+                "AcceptMutex: %s (default: %s)",
+                apr_proc_mutex_name(accept_mutex),
+                apr_proc_mutex_defname());
 #endif
     restart_pending = shutdown_pending = 0;
     mpm_state = AP_MPMQ_RUNNING;
@@ -1959,7 +1959,7 @@ static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
     ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
     ap_extended_status = 0;
 #ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
-	ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
+        ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
 #endif
 
     apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
@@ -2151,9 +2151,9 @@ static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *ar
        server_limit = MAX_SERVER_LIMIT;
     } 
     else if (server_limit < 1) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "WARNING: Require ServerLimit > 0, setting to 1");
-	server_limit = 1;
+        server_limit = 1;
     }
     return NULL;
 }
@@ -2191,9 +2191,9 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
        thread_limit = MAX_THREAD_LIMIT;
     } 
     else if (thread_limit < 1) {
-	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
                      "WARNING: Require ThreadLimit > 0, setting to 1");
-	thread_limit = 1;
+        thread_limit = 1;
     }
     return NULL;
 }
diff --git a/server/mpm_common.c b/server/mpm_common.c
index c55a79e..163946b 100644
--- a/server/mpm_common.c
+++ b/server/mpm_common.c
@@ -1049,7 +1049,7 @@ void ap_mpm_rewrite_args(process_rec *process)
 apr_uint32_t ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
 
 const char *ap_mpm_set_max_mem_free(cmd_parms *cmd, void *dummy,
-	                            const char *arg)
+                                    const char *arg)
 {
     long value;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
@@ -1111,7 +1111,7 @@ const char *ap_mpm_set_exception_hook(cmd_parms *cmd, void *dummy,
     }
 
     if (cmd->server->is_virtual) {
-	return "EnableExceptionHook directive not allowed in <VirtualHost>";
+        return "EnableExceptionHook directive not allowed in <VirtualHost>";
     }
 
     if (strcasecmp(arg, "on") == 0) {
diff --git a/server/request.c b/server/request.c
index 31270ee..e26e27e 100644
--- a/server/request.c
+++ b/server/request.c
@@ -825,7 +825,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
                 }
 
                 res = ap_parse_htaccess(&htaccess_conf, r, opts.override,
-					opts.override_opts,
+                                        opts.override_opts,
                                         apr_pstrdup(r->pool, r->filename),
                                         sconf->access_name);
                 if (res) {
diff --git a/server/util_filter.c b/server/util_filter.c
index 9a59f91..f8327aa 100644
--- a/server/util_filter.c
+++ b/server/util_filter.c
@@ -343,7 +343,7 @@ static ap_filter_t *add_any_filter_handle(ap_filter_rec_t *frec, void *ctx,
             fscan = fscan->next;
 
         f->next = fscan->next;
-	fscan->next = f;
+        fscan->next = f;
     }
 
     if (frec->ftype < AP_FTYPE_CONNECTION && (*r_filters == *c_filters)) {
diff --git a/server/util_md5.c b/server/util_md5.c
index 744f3f2..fad70fa 100644
--- a/server/util_md5.c
+++ b/server/util_md5.c
@@ -70,8 +70,8 @@ AP_DECLARE(char *) ap_md5_binary(apr_pool_t *p, const unsigned char *buf, int le
     apr_md5_final(hash, &my_md5);
 
     for (i = 0, r = result; i < APR_MD5_DIGESTSIZE; i++) {
-	*r++ = hex[hash[i] >> 4];
-	*r++ = hex[hash[i] & 0xF];
+        *r++ = hex[hash[i] >> 4];
+        *r++ = hex[hash[i] & 0xF];
     }
     *r = '\0';
 
@@ -142,10 +142,10 @@ AP_DECLARE(char *) ap_md5contextTo64(apr_pool_t *a, apr_md5_ctx_t *context)
 
     p = encodedDigest;
     for (i = 0; i < sizeof(digest); i += 3) {
-	*p++ = basis_64[digest[i] >> 2];
-	*p++ = basis_64[((digest[i] & 0x3) << 4) | ((int) (digest[i + 1] & 0xF0) >> 4)];
-	*p++ = basis_64[((digest[i + 1] & 0xF) << 2) | ((int) (digest[i + 2] & 0xC0) >> 6)];
-	*p++ = basis_64[digest[i + 2] & 0x3F];
+        *p++ = basis_64[digest[i] >> 2];
+        *p++ = basis_64[((digest[i] & 0x3) << 4) | ((int) (digest[i + 1] & 0xF0) >> 4)];
+        *p++ = basis_64[((digest[i + 1] & 0xF) << 2) | ((int) (digest[i + 2] & 0xC0) >> 6)];
+        *p++ = basis_64[digest[i + 2] & 0x3F];
     }
     *p-- = '\0';
     *p-- = '=';
@@ -163,7 +163,7 @@ AP_DECLARE(char *) ap_md5digest(apr_pool_t *p, apr_file_t *infile)
     apr_md5_init(&context);
     nbytes = sizeof(buf);
     while (apr_file_read(infile, buf, &nbytes) == APR_SUCCESS) {
-	apr_md5_update(&context, buf, nbytes);
+        apr_md5_update(&context, buf, nbytes);
         nbytes = sizeof(buf);
     }
     apr_file_seek(infile, APR_SET, &offset);
diff --git a/server/vhost.c b/server/vhost.c
index 487e791..a26bfdf 100644
--- a/server/vhost.c
+++ b/server/vhost.c
@@ -726,12 +726,12 @@ static void fix_hostname(request_rec *r)
     }
     else if (port) {
         /* Don't throw the Host: header's port number away:
-	   save it in parsed_uri -- ap_get_server_port() needs it! */
+           save it in parsed_uri -- ap_get_server_port() needs it! */
         /* @@@ XXX there should be a better way to pass the port.
-	 *         Like r->hostname, there should be a r->portno
-	 */
+         *         Like r->hostname, there should be a r->portno
+         */
         r->parsed_uri.port = port;
-	r->parsed_uri.port_str = apr_itoa(r->pool, (int)port);
+        r->parsed_uri.port_str = apr_itoa(r->pool, (int)port);
     }
 
     /* if the hostname is an IPv6 numeric address string, it was validated 
diff --git a/support/htcacheclean.c b/support/htcacheclean.c
index 20c184f..6e3eb8a 100644
--- a/support/htcacheclean.c
+++ b/support/htcacheclean.c
@@ -824,7 +824,7 @@ int main(int argc, const char * const argv[])
                 }
                 benice = 1;
                 break;
-		
+                
             case 't':
                 if (deldirs) {
                     usage();
diff --git a/support/logresolve.c b/support/logresolve.c
index 3d28b72..f490745 100644
--- a/support/logresolve.c
+++ b/support/logresolve.c
@@ -214,7 +214,7 @@ int main(int argc, const char * const argv[])
 
         /* Check if this could even be an IP address */
         if (!apr_isxdigit(line[0]) && line[0] != ':') {
-	        withname++;
+                withname++;
             apr_file_puts(line, outfile);
             continue;    
         }
@@ -228,7 +228,7 @@ int main(int argc, const char * const argv[])
         hostname = (char *) apr_hash_get(cache, line, APR_HASH_KEY_STRING);
         if (hostname) {
             apr_file_printf(outfile, "%s %s", hostname, space + 1);
-	        cachehits++;
+                cachehits++;
             continue;
         }
 
@@ -236,7 +236,7 @@ int main(int argc, const char * const argv[])
         status = apr_sockaddr_info_get(&ip, line, APR_UNSPEC ,0, 0, pool);
         if (status != APR_SUCCESS) {
             /* Not an IP address */
-	        withname++;
+                withname++;
             *space = ' ';
             apr_file_puts(line, outfile);
             continue;
@@ -246,7 +246,7 @@ int main(int argc, const char * const argv[])
          * "parsed as an IP address". It does not mean we actually resolved
          * the IP address into a hostname.
          */ 
-	    resolves++;
+            resolves++;
         
         /* From here on our we cache each result, even if it was not
          * succesful 
diff --git a/support/win32/wintty.c b/support/win32/wintty.c
index 01a354b..bb66ebd 100644
--- a/support/win32/wintty.c
+++ b/support/win32/wintty.c
@@ -136,7 +136,7 @@ int main(int argc, char** argv)
                 case '?':
                     printf(options, arg0);
                     exit(1);
-		default:
+                default:
                     printf("wintty option %s not recognized, use -? for help.\n\n", *argv);
                     exit(1);
             }
@@ -214,7 +214,7 @@ int main(int argc, char** argv)
         
     if (isservice) {
 #ifdef WE_EVER_FIGURE_OUT_WHY_THIS_DOESNT_WORK
-	hsavedesk = GetThreadDesktop(GetCurrentThreadId());
+        hsavedesk = GetThreadDesktop(GetCurrentThreadId());
         if (!hsavedesk || hsavedesk == INVALID_HANDLE_VALUE) {
             printerr("GetThreadDesktop(GetTID()) failed (%d)\n", GetLastError());
         }
diff --git a/test/cls.c b/test/cls.c
index f2b0192..1311a88 100644
--- a/test/cls.c
+++ b/test/cls.c
@@ -35,32 +35,32 @@ static int checkmask(const char *data, const char *mask)
     int i, ch, d;
 
     for (i = 0; mask[i] != '\0' && mask[i] != '*'; i++) {
-	ch = mask[i];
-	d = data[i];
-	if (ch == '@') {
-	    if (!isupper(d))
-		return 0;
-	}
-	else if (ch == '$') {
-	    if (!islower(d))
-		return 0;
-	}
-	else if (ch == '#') {
-	    if (!isdigit(d))
-		return 0;
-	}
-	else if (ch == '&') {
-	    if (!isxdigit(d))
-		return 0;
-	}
-	else if (ch != d)
-	    return 0;
+        ch = mask[i];
+        d = data[i];
+        if (ch == '@') {
+            if (!isupper(d))
+                return 0;
+        }
+        else if (ch == '$') {
+            if (!islower(d))
+                return 0;
+        }
+        else if (ch == '#') {
+            if (!isdigit(d))
+                return 0;
+        }
+        else if (ch == '&') {
+            if (!isxdigit(d))
+                return 0;
+        }
+        else if (ch != d)
+            return 0;
     }
 
     if (mask[i] == '*')
-	return 1;
+        return 1;
     else
-	return (data[i] == '\0');
+        return (data[i] == '\0');
 }
 
 /*
@@ -72,19 +72,19 @@ static int hex2sec(const char *x)
     unsigned int j;
 
     for (i = 0, j = 0; i < 8; i++) {
-	ch = x[i];
-	j <<= 4;
-	if (isdigit(ch))
-	    j |= ch - '0';
-	else if (isupper(ch))
-	    j |= ch - ('A' - 10);
-	else
-	    j |= ch - ('a' - 10);
+        ch = x[i];
+        j <<= 4;
+        if (isdigit(ch))
+            j |= ch - '0';
+        else if (isupper(ch))
+            j |= ch - ('A' - 10);
+        else
+            j |= ch - ('a' - 10);
     }
     if (j == 0xffffffff)
-	return -1;		/* so that it works with 8-byte ints */
+        return -1;		/* so that it works with 8-byte ints */
     else
-	return j;
+        return j;
 }
 
 int main(int argc, char **argv)
@@ -103,78 +103,78 @@ int main(int argc, char **argv)
     const char time_format[] = "%e %b %Y %R";
 
     if (argc != 2) {
-	printf("Usage: cls directory\n");
-	exit(0);
+        printf("Usage: cls directory\n");
+        exit(0);
     }
 
     d = opendir(argv[1]);
     if (d == NULL) {
-	perror("opendir");
-	exit(1);
+        perror("opendir");
+        exit(1);
     }
 
     for (;;) {
-	e = readdir(d);
-	if (e == NULL)
-	    break;
-	s = e->d_name;
-	if (s[0] == '.' || s[0] == '#')
-	    continue;
-	sprintf(path, "%s/%s", argv[1], s);
-	fp = fopen(path, "r");
-	if (fp == NULL) {
-	    perror("fopen");
-	    continue;
-	}
-	if (fgets(line, 1034, fp) == NULL) {
-	    perror("fgets");
-	    fclose(fp);
-	    continue;
-	}
-	if (!checkmask(line, "&&&&&&&& &&&&&&&& &&&&&&&& &&&&&&&& &&&&&&&&\n")) {
-	    fprintf(stderr, "Bad cache file\n");
-	    fclose(fp);
-	    continue;
-	}
-	date = hex2sec(line);
-	lmod = hex2sec(line + 9);
-	expire = hex2sec(line + 18);
-	ver = hex2sec(line + 27);
-	len = hex2sec(line + 35);
-	if (fgets(line, 1034, fp) == NULL) {
-	    perror("fgets");
-	    fclose(fp);
-	    continue;
-	}
-	fclose(fp);
-	i = strlen(line);
-	if (strncmp(line, "X-URL: ", 7) != 0 || line[i - 1] != '\n') {
-	    fprintf(stderr, "Bad cache file\n");
-	    continue;
-	}
-	line[i - 1] = '\0';
-	if (date != -1) {
-	    ts = *gmtime(&date);
-	    strftime(sdate, 30, time_format, &ts);
-	}
-	else
-	    strcpy(sdate, "-");
+        e = readdir(d);
+        if (e == NULL)
+            break;
+        s = e->d_name;
+        if (s[0] == '.' || s[0] == '#')
+            continue;
+        sprintf(path, "%s/%s", argv[1], s);
+        fp = fopen(path, "r");
+        if (fp == NULL) {
+            perror("fopen");
+            continue;
+        }
+        if (fgets(line, 1034, fp) == NULL) {
+            perror("fgets");
+            fclose(fp);
+            continue;
+        }
+        if (!checkmask(line, "&&&&&&&& &&&&&&&& &&&&&&&& &&&&&&&& &&&&&&&&\n")) {
+            fprintf(stderr, "Bad cache file\n");
+            fclose(fp);
+            continue;
+        }
+        date = hex2sec(line);
+        lmod = hex2sec(line + 9);
+        expire = hex2sec(line + 18);
+        ver = hex2sec(line + 27);
+        len = hex2sec(line + 35);
+        if (fgets(line, 1034, fp) == NULL) {
+            perror("fgets");
+            fclose(fp);
+            continue;
+        }
+        fclose(fp);
+        i = strlen(line);
+        if (strncmp(line, "X-URL: ", 7) != 0 || line[i - 1] != '\n') {
+            fprintf(stderr, "Bad cache file\n");
+            continue;
+        }
+        line[i - 1] = '\0';
+        if (date != -1) {
+            ts = *gmtime(&date);
+            strftime(sdate, 30, time_format, &ts);
+        }
+        else
+            strcpy(sdate, "-");
 
-	if (lmod != -1) {
-	    ts = *gmtime(&lmod);
-	    strftime(slmod, 30, time_format, &ts);
-	}
-	else
-	    strcpy(slmod, "-");
+        if (lmod != -1) {
+            ts = *gmtime(&lmod);
+            strftime(slmod, 30, time_format, &ts);
+        }
+        else
+            strcpy(slmod, "-");
 
-	if (expire != -1) {
-	    ts = *gmtime(&expire);
-	    strftime(sexpire, 30, time_format, &ts);
-	}
-	else
-	    strcpy(sexpire, "-");
+        if (expire != -1) {
+            ts = *gmtime(&expire);
+            strftime(sexpire, 30, time_format, &ts);
+        }
+        else
+            strcpy(sexpire, "-");
 
-	printf("%s: %d; %s  %s  %s\n", line + 7, ver, sdate, slmod, sexpire);
+        printf("%s: %d; %s  %s  %s\n", line + 7, ver, sdate, slmod, sexpire);
     }
 
     closedir(d);
diff --git a/test/test-writev.c b/test/test-writev.c
index 072689a..4740738 100644
--- a/test/test-writev.c
+++ b/test/test-writev.c
@@ -57,36 +57,36 @@ void main( int argc, char **argv )
 
     if( argc != 3 ) {
 usage:
-	fprintf( stderr, "usage: test-writev a.b.c.d port#\n" );
-	exit( 1 );
+        fprintf( stderr, "usage: test-writev a.b.c.d port#\n" );
+        exit( 1 );
     }
     server_addr.sin_family = AF_INET;
     server_addr.sin_addr.s_addr = inet_addr( argv[1] );
     if( server_addr.sin_addr.s_addr == INADDR_NONE ) {
-	fprintf( stderr, "bogus address\n" );
-	goto usage;
+        fprintf( stderr, "bogus address\n" );
+        goto usage;
     }
     server_addr.sin_port = htons( atoi( argv[2] ) );
 
     s = socket( AF_INET, SOCK_STREAM, 0 );
     if( s < 0 ) {
-	perror("socket");
-	exit(1);
+        perror("socket");
+        exit(1);
     }
     if( connect( s, (struct sockaddr *)&server_addr, sizeof( server_addr ) )
-	!= 0 ) {
-	perror("connect");
-	exit(1);
+        != 0 ) {
+        perror("connect");
+        exit(1);
     }
 
     if( setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char*)&just_say_no,
-	sizeof(just_say_no)) != 0 ) {
-	perror( "TCP_NODELAY" );
-	exit(1);
+        sizeof(just_say_no)) != 0 ) {
+        perror( "TCP_NODELAY" );
+        exit(1);
     }
     /* now build up a two part writev and write it out */
     for( i = 0; i < sizeof( buf ); ++i ) {
-	buf[i] = 'x';
+        buf[i] = 'x';
     }
     vector[0].iov_base = buf;
     vector[0].iov_len = sizeof(buf);
diff --git a/test/time-sem.c b/test/time-sem.c
index 6f6e5da..792caec 100644
--- a/test/time-sem.c
+++ b/test/time-sem.c
@@ -23,16 +23,16 @@ to be used:
     - NFS filesystems absolutely suck for fcntl() and flock()
 
     - uslock absolutely sucks on single-processor IRIX boxes, but
-	absolutely rocks on multi-processor boxes.  The converse
-	is true for fcntl.  sysvsem seems a moderate balance.
+        absolutely rocks on multi-processor boxes.  The converse
+        is true for fcntl.  sysvsem seems a moderate balance.
 
     - Under Solaris you can't have too many processes use SEM_UNDO, there
-	might be a tuneable somewhere that increases the limit from 29.
-	We're not sure what the tunable is, so there's a define
-	NO_SEM_UNDO which can be used to simulate us trapping/blocking
-	signals to be able to properly release the semaphore on a clean
-	child death.  You'll also need to define NEED_UNION_SEMUN
-	under solaris.
+        might be a tuneable somewhere that increases the limit from 29.
+        We're not sure what the tunable is, so there's a define
+        NO_SEM_UNDO which can be used to simulate us trapping/blocking
+        signals to be able to properly release the semaphore on a clean
+        child death.  You'll also need to define NEED_UNION_SEMUN
+        under solaris.
 
 You'll need to define USE_SHMGET_SCOREBOARD if anonymous shared mmap()
 doesn't work on your system (i.e. linux).
@@ -101,9 +101,9 @@ accept_mutex_init(void)
     fcntl_fd = open("test-lock-thing", O_CREAT | O_WRONLY | O_EXCL, 0644);
     if (fcntl_fd == -1)
     {
-	perror ("open");
-	fprintf (stderr, "Cannot open lock file: %s\n", "test-lock-thing");
-	exit (1);
+        perror ("open");
+        fprintf (stderr, "Cannot open lock file: %s\n", "test-lock-thing");
+        exit (1);
     }
     unlink("test-lock-thing");
 }
@@ -113,11 +113,11 @@ void accept_mutex_on(void)
     int ret;
     
     while ((ret = fcntl(fcntl_fd, F_SETLKW, &lock_it)) < 0 && errno == EINTR)
-	continue;
+        continue;
 
     if (ret < 0) {
-	perror ("fcntl lock_it");
-	exit(1);
+        perror ("fcntl lock_it");
+        exit(1);
     }
 }
 
@@ -125,8 +125,8 @@ void accept_mutex_off(void)
 {
     if (fcntl (fcntl_fd, F_SETLKW, &unlock_it) < 0)
     {
-	perror ("fcntl unlock_it");
-	exit(1);
+        perror ("fcntl unlock_it");
+        exit(1);
     }
 }
 
@@ -149,9 +149,9 @@ void accept_mutex_init(void)
     flock_fd = open(FNAME, O_CREAT | O_WRONLY | O_EXCL, 0644);
     if (flock_fd == -1)
     {
-	perror ("open");
-	fprintf (stderr, "Cannot open lock file: %s\n", "test-lock-thing");
-	exit (1);
+        perror ("open");
+        fprintf (stderr, "Cannot open lock file: %s\n", "test-lock-thing");
+        exit (1);
     }
 }
 
@@ -159,8 +159,8 @@ void accept_mutex_child_init(void)
 {
     flock_fd = open(FNAME, O_WRONLY, 0600);
     if (flock_fd == -1) {
-	perror("open");
-	exit(1);
+        perror("open");
+        exit(1);
     }
 }
 
@@ -174,11 +174,11 @@ void accept_mutex_on(void)
     int ret;
     
     while ((ret = flock(flock_fd, LOCK_EX)) < 0 && errno == EINTR)
-	continue;
+        continue;
 
     if (ret < 0) {
-	perror ("flock(LOCK_EX)");
-	exit(1);
+        perror ("flock(LOCK_EX)");
+        exit(1);
     }
 }
 
@@ -186,8 +186,8 @@ void accept_mutex_off(void)
 {
     if (flock (flock_fd, LOCK_UN) < 0)
     {
-	perror ("flock(LOCK_UN)");
-	exit(1);
+        perror ("flock(LOCK_UN)");
+        exit(1);
     }
 }
 
@@ -211,9 +211,9 @@ void accept_mutex_init(void)
 #ifdef NEED_UNION_SEMUN
     /* believe it or not, you need to define this under solaris */
     union semun {
-	int val;
-	struct semid_ds *buf;
-	ushort *array;
+        int val;
+        struct semid_ds *buf;
+        ushort *array;
     };
 #endif
 
@@ -243,8 +243,8 @@ void accept_mutex_on()
 
 #ifdef NO_SEM_UNDO
     if (sigprocmask(SIG_BLOCK, &accept_block_mask, &accept_previous_mask)) {
-	perror("sigprocmask(SIG_BLOCK)");
-	exit (1);
+        perror("sigprocmask(SIG_BLOCK)");
+        exit (1);
     }
     op.sem_flg = 0;
 #else
@@ -253,8 +253,8 @@ void accept_mutex_on()
     op.sem_num = 0;
     op.sem_op  = -1;
     if (semop(sem_id, &op, 1) < 0) {
-	perror ("accept_mutex_on");
-	exit (1);
+        perror ("accept_mutex_on");
+        exit (1);
     }
 }
 
@@ -270,13 +270,13 @@ void accept_mutex_off()
     op.sem_flg = SEM_UNDO;
 #endif
     if (semop(sem_id, &op, 1) < 0) {
-	perror ("accept_mutex_off");
+        perror ("accept_mutex_off");
         exit (1);
     }
 #ifdef NO_SEM_UNDO
     if (sigprocmask(SIG_SETMASK, &accept_previous_mask, NULL)) {
-	perror("sigprocmask(SIG_SETMASK)");
-	exit (1);
+        perror("sigprocmask(SIG_SETMASK)");
+        exit (1);
     }
 #endif
 }
@@ -304,27 +304,27 @@ void accept_mutex_init(void)
 
     fd = open ("/dev/zero", O_RDWR);
     if (fd == -1) {
-	perror ("open(/dev/zero)");
-	exit (1);
+        perror ("open(/dev/zero)");
+        exit (1);
     }
     mutex = (pthread_mutex_t *)mmap ((caddr_t)0, sizeof (*mutex),
-		    PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+                    PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
     if (mutex == (void *)(caddr_t)-1) {
-	perror ("mmap");
-	exit (1);
+        perror ("mmap");
+        exit (1);
     }
     close (fd);
     if (pthread_mutexattr_init(&mattr)) {
-	perror ("pthread_mutexattr_init");
-	exit (1);
+        perror ("pthread_mutexattr_init");
+        exit (1);
     }
     if (pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED)) {
-	perror ("pthread_mutexattr_setpshared");
-	exit (1);
+        perror ("pthread_mutexattr_setpshared");
+        exit (1);
     }
     if (pthread_mutex_init(mutex, &mattr)) {
-	perror ("pthread_mutex_init");
-	exit (1);
+        perror ("pthread_mutex_init");
+        exit (1);
     }
     sigfillset(&accept_block_mask);
     sigdelset(&accept_block_mask, SIGHUP);
@@ -335,24 +335,24 @@ void accept_mutex_init(void)
 void accept_mutex_on()
 {
     if (sigprocmask(SIG_BLOCK, &accept_block_mask, &accept_previous_mask)) {
-	perror("sigprocmask(SIG_BLOCK)");
-	exit (1);
+        perror("sigprocmask(SIG_BLOCK)");
+        exit (1);
     }
     if (pthread_mutex_lock (mutex)) {
-	perror ("pthread_mutex_lock");
-	exit (1);
+        perror ("pthread_mutex_lock");
+        exit (1);
     }
 }
 
 void accept_mutex_off()
 {
     if (pthread_mutex_unlock (mutex)) {
-	perror ("pthread_mutex_unlock");
-	exit (1);
+        perror ("pthread_mutex_unlock");
+        exit (1);
     }
     if (sigprocmask(SIG_SETMASK, &accept_previous_mask, NULL)) {
-	perror("sigprocmask(SIG_SETMASK)");
-	exit (1);
+        perror("sigprocmask(SIG_SETMASK)");
+        exit (1);
     }
 }
 
@@ -423,10 +423,10 @@ static void *get_shared_mem(apr_size_t size)
 
     /* allocate shared memory for the shared_counter */
     result = (unsigned long *)mmap ((caddr_t)0, size,
-		    PROT_READ|PROT_WRITE, MAP_ANON|MAP_SHARED, -1, 0);
+                    PROT_READ|PROT_WRITE, MAP_ANON|MAP_SHARED, -1, 0);
     if (result == (void *)(caddr_t)-1) {
-	perror ("mmap");
-	exit (1);
+        perror ("mmap");
+        exit (1);
     }
     return result;
 }
@@ -448,8 +448,8 @@ static void *get_shared_mem(apr_size_t size)
 #endif
 
     if ((shmid = shmget(shmkey, size, IPC_CREAT | SHM_R | SHM_W)) == -1) {
-	perror("shmget");
-	exit(1);
+        perror("shmget");
+        exit(1);
     }
 
 #ifdef MOVEBREAK
@@ -463,29 +463,29 @@ static void *get_shared_mem(apr_size_t size)
      * attach the segment and then move break back down. Ugly
      */
     if ((obrk = sbrk(MOVEBREAK)) == (char *) -1) {
-	perror("sbrk");
+        perror("sbrk");
     }
 #endif
 
 #define BADSHMAT	((void *)(-1))
     if ((result = shmat(shmid, 0, 0)) == BADSHMAT) {
-	perror("shmat");
+        perror("shmat");
     }
     /*
      * We must avoid leaving segments in the kernel's
      * (small) tables.
      */
     if (shmctl(shmid, IPC_RMID, NULL) != 0) {
-	perror("shmctl(IPC_RMID)");
+        perror("shmctl(IPC_RMID)");
     }
     if (result == BADSHMAT)	/* now bailout */
-	exit(1);
+        exit(1);
 
 #ifdef MOVEBREAK
     if (obrk == (char *) -1)
-	return;			/* nothing else to do */
+        return;			/* nothing else to do */
     if (sbrk(-(MOVEBREAK)) == (char *) -1) {
-	perror("sbrk 2");
+        perror("sbrk 2");
     }
 #endif
     return result;
@@ -513,8 +513,8 @@ void main (int argc, char **argv)
     unsigned long *shared_counter;
 
     if (argc != 3) {
-	fprintf (stderr, "Usage: time-sem num-child num iter\n");
-	exit (1);
+        fprintf (stderr, "Usage: time-sem num-child num iter\n");
+        exit (1);
     }
 
     num_child = atoi (argv[1]);
@@ -532,54 +532,54 @@ void main (int argc, char **argv)
     accept_mutex_on ();
 
     for (i = 0; i < num_child; ++i) {
-	pid = fork();
-	if (pid == 0) {
-	    /* child, do our thing */
-	    accept_mutex_child_init();
-	    for (i = 0; i < num_iter; ++i) {
-		unsigned long tmp;
-
-		accept_mutex_on ();
-		tmp = *shared_counter;
-		YIELD;
-		*shared_counter = tmp + 1;
-		accept_mutex_off ();
-	    }
-	    exit (0);
-	} else if (pid == -1) {
-	    perror ("fork");
-	    exit (1);
-	}
+        pid = fork();
+        if (pid == 0) {
+            /* child, do our thing */
+            accept_mutex_child_init();
+            for (i = 0; i < num_iter; ++i) {
+                unsigned long tmp;
+
+                accept_mutex_on ();
+                tmp = *shared_counter;
+                YIELD;
+                *shared_counter = tmp + 1;
+                accept_mutex_off ();
+            }
+            exit (0);
+        } else if (pid == -1) {
+            perror ("fork");
+            exit (1);
+        }
     }
 
     /* a quick test to see that nothing is screwed up */
     if (*shared_counter != 0) {
-	puts ("WTF! shared_counter != 0 before the children have been started!");
-	exit (1);
+        puts ("WTF! shared_counter != 0 before the children have been started!");
+        exit (1);
     }
 
     gettimeofday (&first, NULL);
     /* launch children into action */
     accept_mutex_off ();
     for (i = 0; i < num_child; ++i) {
-	if (wait(NULL) == -1) {
-	    perror ("wait");
-	}
+        if (wait(NULL) == -1) {
+            perror ("wait");
+        }
     }
     gettimeofday (&last, NULL);
 
     if (*shared_counter != num_child * num_iter) {
-	printf ("WTF! shared_counter != num_child * num_iter!\n"
-		"shared_counter = %lu\nnum_child = %d\nnum_iter=%d\n",
-		*shared_counter,
-		num_child, num_iter);
+        printf ("WTF! shared_counter != num_child * num_iter!\n"
+                "shared_counter = %lu\nnum_child = %d\nnum_iter=%d\n",
+                *shared_counter,
+                num_child, num_iter);
     }
 
     last.tv_sec -= first.tv_sec;
     ms = last.tv_usec - first.tv_usec;
     if (ms < 0) {
-	--last.tv_sec;
-	ms += 1000000;
+        --last.tv_sec;
+        ms += 1000000;
     }
     last.tv_usec = ms;
     printf ("%8lu.%06lu\n", last.tv_sec, last.tv_usec);
diff --git a/test/zb.c b/test/zb.c
index 93a6f6a..a85fa7a 100644
--- a/test/zb.c
+++ b/test/zb.c
@@ -1,6 +1,6 @@
 
 /*                          ZeusBench V1.01
-			    ===============
+                            ===============
 
 This program is Copyright (C) Zeus Technology Limited 1996.
 
@@ -196,11 +196,11 @@ void output_results()
   printf("Document Length:        %d\n", doclen);  
   printf("Concurency Level:       %d\n", concurrency);
   printf("Time taken for tests:   %d.%03d seconds\n", 
-	 timetaken/1000, timetaken%1000);
+         timetaken/1000, timetaken%1000);
   printf("Complete requests:      %d\n", done);
   printf("Failed requests:        %d\n", bad);
   if(bad) printf("   (Connect: %d, Length: %d, Exceptions: %d)\n",
-		 err_conn, err_length, err_except);
+                 err_conn, err_length, err_except);
   if(keepalive) printf("Keep-Alive requests:    %d\n", doneka);
   printf("Bytes transferred:      %d\n", totalread);
   printf("HTML transferred:       %d\n", totalbread);
@@ -209,7 +209,7 @@ void output_results()
   if(timetaken) {
     printf("Requests per seconds:   %.2f\n", 1000*(float)(done)/timetaken);
     printf("Transfer rate:          %.2f kb/s\n", 
-	   (float)(totalread)/timetaken);
+           (float)(totalread)/timetaken);
   }
 
   {
@@ -266,8 +266,8 @@ void start_connect(struct connection *c)
       close(c->fd);
       err_conn++;
       if(bad++>10) {
-	printf("\nTest aborted after 10 failures\n\n");
-	exit(1);
+        printf("\nTest aborted after 10 failures\n\n");
+        exit(1);
       } 
       start_connect(c);
     }      
@@ -352,44 +352,44 @@ void read_connection(struct connection *c)
     if(!s) {
        /* read rest next time */
       if(space) 
-	return;
+        return;
       else {
-	/* header is in invalid or too big - close connection */
-	close(c->fd);
-	if(bad++>10) {
-	  printf("\nTest aborted after 10 failures\n\n");
-	  exit(1);
-	} 
-	FD_CLR(c->fd, &writebits);
-	start_connect(c);
+        /* header is in invalid or too big - close connection */
+        close(c->fd);
+        if(bad++>10) {
+          printf("\nTest aborted after 10 failures\n\n");
+          exit(1);
+        } 
+        FD_CLR(c->fd, &writebits);
+        start_connect(c);
       }	
     }
     else {
       /* have full header */
       if(!good) {
-	/* this is first time, extract some interesting info */
-	char *p, *q;
-	p = strstr(c->cbuff, "Server:");
-	q = server_name;
-	if(p) { p+=8; while(*p>32) *q++ = *p++; }
-	*q = 0;
+        /* this is first time, extract some interesting info */
+        char *p, *q;
+        p = strstr(c->cbuff, "Server:");
+        q = server_name;
+        if(p) { p+=8; while(*p>32) *q++ = *p++; }
+        *q = 0;
       }
-	
+        
       c->gotheader = 1;
       *s = 0; /* terminate at end of header */
       if(keepalive && 
-	 (strstr(c->cbuff, "Keep-Alive") 
-	  || strstr(c->cbuff, "keep-alive")))  /* for benefit of MSIIS */
-	{
-	char *cl;
-	cl = strstr(c->cbuff, "Content-Length:");
-	/* for cacky servers like NCSA which break the spec and send a 
-	   lower case 'l' */
-	if(!cl) cl = strstr(c->cbuff, "Content-length:");
-	if(cl) {
-	  c->keepalive=1;
-	  c->length = atoi(cl+16);
-	}
+         (strstr(c->cbuff, "Keep-Alive") 
+          || strstr(c->cbuff, "keep-alive")))  /* for benefit of MSIIS */
+        {
+        char *cl;
+        cl = strstr(c->cbuff, "Content-Length:");
+        /* for cacky servers like NCSA which break the spec and send a 
+           lower case 'l' */
+        if(!cl) cl = strstr(c->cbuff, "Content-length:");
+        if(cl) {
+          c->keepalive=1;
+          c->length = atoi(cl+16);
+        }
       }
       c->bread += c->cbx - (s+l-c->cbuff) + r-tocopy;
       totalbread += c->bread;
@@ -454,8 +454,8 @@ int test()
 
   /* setup request */
   sprintf(request,"GET %s HTTP/1.0\r\nUser-Agent: ZeusBench/1.0\r\n"
-	  "%sHost: %s\r\nAccept: */*\r\n\r\n", file, 
-	  keepalive?"Connection: Keep-Alive\r\n":"", machine );
+          "%sHost: %s\r\nAccept: */*\r\n\r\n", file, 
+          keepalive?"Connection: Keep-Alive\r\n":"", machine );
     
   reqlen = strlen(request);
 
@@ -491,10 +491,10 @@ int test()
     for(i=0; i<concurrency; i++) {
       int s = con[i].fd;
       if(FD_ISSET(s, &sel_except)) {
-	bad++; 
-	err_except++;
-	start_connect(&con[i]);
-	continue;
+        bad++; 
+        err_except++;
+        start_connect(&con[i]);
+        continue;
       }
       if(FD_ISSET(s, &sel_read)) read_connection(&con[i]);
       if(FD_ISSET(s, &sel_write)) write_request(&con[i]);
@@ -511,7 +511,7 @@ int test()
 void usage(char *progname) {
   printf("\nZeusBench v1.0\n\n");
   printf("Usage: %s <machine> <file> [-k] [-n requests | -t timelimit (sec)]"
-	 "\n\t\t[-c concurrency] [-p port] \n",progname);
+         "\n\t\t[-c concurrency] [-p port] \n",progname);
   printf("Filename should start with a '/' e.g. /index.html\n\n");
   exit(EINVAL);
 }
@@ -534,8 +534,8 @@ int main(int argc, char **argv) {
     case 'n': 
       requests = atoi(optarg);
       if(!requests) {
-	printf("Invalid number of requests\n");
-	exit(1);
+        printf("Invalid number of requests\n");
+        exit(1);
       }
       break;
     case 'k':
