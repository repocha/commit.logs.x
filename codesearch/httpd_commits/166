commit 99a95be90fcf2bb69dbcae8d6995d7adf5c4409d
Author: Jim Jagielski <jim@apache.org>
Date:   Thu Nov 10 15:11:44 2005 +0000

    No functional Change: Removing trailing whitespace. This also
    means that "blank" lines consisting of just spaces or
    tabs are now really blank lines
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@332306 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/modules/aaa/mod_auth_basic.c b/modules/aaa/mod_auth_basic.c
index ee296a4..c6192b3 100644
--- a/modules/aaa/mod_auth_basic.c
+++ b/modules/aaa/mod_auth_basic.c
@@ -256,7 +256,7 @@ static int authenticate_basic_user(request_rec *r)
 
         current_provider = current_provider->next;
     } while (current_provider);
-    
+
     if (auth_result != AUTH_GRANTED) {
         int return_code;
 
@@ -280,7 +280,7 @@ static int authenticate_basic_user(request_rec *r)
             break;
         case AUTH_GENERAL_ERROR:
         default:
-            /* We'll assume that the module has already said what its error 
+            /* We'll assume that the module has already said what its error
              * was in the logs.
              */
             return_code = HTTP_INTERNAL_SERVER_ERROR;
diff --git a/modules/aaa/mod_auth_digest.c b/modules/aaa/mod_auth_digest.c
index 395fee0..8a0ee5a 100644
--- a/modules/aaa/mod_auth_digest.c
+++ b/modules/aaa/mod_auth_digest.c
@@ -51,7 +51,7 @@
  *       The only problem is that it allows replay attacks when somebody
  *       captures a packet sent to one server and sends it to another
  *       one. Should we add "AuthDigestNcCheck Strict"?
- *   - expired nonces give amaya fits.  
+ *   - expired nonces give amaya fits.
  */
 
 #include "apr_sha1.h"
@@ -80,8 +80,8 @@
 
 #include "mod_auth.h"
 
-/* Disable shmem until pools/init gets sorted out 
- * remove following two lines when fixed 
+/* Disable shmem until pools/init gets sorted out
+ * remove following two lines when fixed
  */
 #undef APR_HAS_SHARED_MEMORY
 #define APR_HAS_SHARED_MEMORY 0
@@ -200,7 +200,7 @@ module AP_MODULE_DECLARE_DATA auth_digest_module;
 
 static apr_status_t cleanup_tables(void *not_used)
 {
-    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+    ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                   "Digest: cleaning up shared memory");
     fflush(stderr);
 
@@ -238,7 +238,7 @@ static apr_status_t initialize_secret(server_rec *s)
     if (status != APR_SUCCESS) {
         char buf[120];
         ap_log_error(APLOG_MARK, APLOG_CRIT, status, s,
-                     "Digest: error generating secret: %s", 
+                     "Digest: error generating secret: %s",
                      apr_strerror(status, buf, sizeof(buf)));
         return status;
     }
@@ -447,13 +447,13 @@ static const char *add_authn_provider(cmd_parms *cmd, void *config,
     digest_config_rec *conf = (digest_config_rec*)config;
     authn_provider_list *newp;
     const char *provider_name;
-    
+
     if (strcasecmp(arg, "on") == 0) {
         provider_name = AUTHN_DEFAULT_PROVIDER;
     }
     else if (strcasecmp(arg, "off") == 0) {
         /* Clear all configured providers and return. */
-        conf->providers = NULL; 
+        conf->providers = NULL;
         return NULL;
     }
     else {
@@ -540,7 +540,7 @@ static const char *set_nonce_lifetime(cmd_parms *cmd, void *config,
     char *endptr;
     long  lifetime;
 
-    lifetime = strtol(t, &endptr, 10); 
+    lifetime = strtol(t, &endptr, 10);
     if (endptr < (t+strlen(t)) && !apr_isspace(*endptr)) {
         return apr_pstrcat(cmd->pool,
                            "Invalid time in AuthDigestNonceLifetime: ",
@@ -608,7 +608,7 @@ static const char *set_shmem_size(cmd_parms *cmd, void *config,
     char *endptr;
     long  size, min;
 
-    size = strtol(size_str, &endptr, 10); 
+    size = strtol(size_str, &endptr, 10);
     while (apr_isspace(*endptr)) endptr++;
     if (*endptr == '\0' || *endptr == 'b' || *endptr == 'B') {
         ;
@@ -645,23 +645,23 @@ static const char *set_shmem_size(cmd_parms *cmd, void *config,
 
 static const command_rec digest_cmds[] =
 {
-    AP_INIT_TAKE1("AuthName", set_realm, NULL, OR_AUTHCFG, 
+    AP_INIT_TAKE1("AuthName", set_realm, NULL, OR_AUTHCFG,
      "The authentication realm (e.g. \"Members Only\")"),
     AP_INIT_ITERATE("AuthDigestProvider", add_authn_provider, NULL, OR_AUTHCFG,
                      "specify the auth providers for a directory or location"),
-    AP_INIT_ITERATE("AuthDigestQop", set_qop, NULL, OR_AUTHCFG, 
+    AP_INIT_ITERATE("AuthDigestQop", set_qop, NULL, OR_AUTHCFG,
      "A list of quality-of-protection options"),
-    AP_INIT_TAKE1("AuthDigestNonceLifetime", set_nonce_lifetime, NULL, OR_AUTHCFG, 
+    AP_INIT_TAKE1("AuthDigestNonceLifetime", set_nonce_lifetime, NULL, OR_AUTHCFG,
      "Maximum lifetime of the server nonce (seconds)"),
-    AP_INIT_TAKE1("AuthDigestNonceFormat", set_nonce_format, NULL, OR_AUTHCFG, 
+    AP_INIT_TAKE1("AuthDigestNonceFormat", set_nonce_format, NULL, OR_AUTHCFG,
      "The format to use when generating the server nonce"),
-    AP_INIT_FLAG("AuthDigestNcCheck", set_nc_check, NULL, OR_AUTHCFG, 
+    AP_INIT_FLAG("AuthDigestNcCheck", set_nc_check, NULL, OR_AUTHCFG,
      "Whether or not to check the nonce-count sent by the client"),
-    AP_INIT_TAKE1("AuthDigestAlgorithm", set_algorithm, NULL, OR_AUTHCFG, 
+    AP_INIT_TAKE1("AuthDigestAlgorithm", set_algorithm, NULL, OR_AUTHCFG,
      "The algorithm used for the hash calculation"),
-    AP_INIT_ITERATE("AuthDigestDomain", set_uri_list, NULL, OR_AUTHCFG, 
+    AP_INIT_ITERATE("AuthDigestDomain", set_uri_list, NULL, OR_AUTHCFG,
      "A list of URI's which belong to the same protection space as the current URI"),
-    AP_INIT_TAKE1("AuthDigestShmemSize", set_shmem_size, NULL, RSRC_CONF, 
+    AP_INIT_TAKE1("AuthDigestShmemSize", set_shmem_size, NULL, RSRC_CONF,
      "The amount of shared memory to allocate for keeping track of clients"),
     {NULL}
 };
@@ -1300,13 +1300,13 @@ static void note_digest_auth_failure(request_rec *r,
      * unneccessarily (it's usually > 200 bytes!).
      */
 
-    
+
     /* don't send domain
      * - for proxy requests
      * - if it's no specified
      */
     if (r->proxyreq || !conf->uri_list) {
-        domain = NULL;  
+        domain = NULL;
     }
     else {
         domain = conf->uri_list;
@@ -1464,7 +1464,7 @@ static int check_nonce(request_rec *r, digest_header_rec *resp,
         if (dt > conf->nonce_lifetime) {
             ap_log_rerror(APLOG_MARK, APLOG_INFO, 0,r,
                           "Digest: user %s: nonce expired (%.2f seconds old "
-                          "- max lifetime %.2f) - sending new nonce", 
+                          "- max lifetime %.2f) - sending new nonce",
                           r->user, (double)apr_time_sec(dt),
                           (double)apr_time_sec(conf->nonce_lifetime));
             note_digest_auth_failure(r, conf, resp, 1);
@@ -1536,7 +1536,7 @@ static const char *new_digest(const request_rec *r,
 }
 
 
-static void copy_uri_components(apr_uri_t *dst, 
+static void copy_uri_components(apr_uri_t *dst,
                                 apr_uri_t *src, request_rec *r) {
     if (src->scheme && src->scheme[0] != '\0') {
         dst->scheme = src->scheme;
@@ -1684,30 +1684,30 @@ static int authenticate_digest_user(request_rec *r)
             ap_unescape_url(d_uri.query);
         }
         else if (r_uri.query) {
-            /* MSIE compatibility hack.  MSIE has some RFC issues - doesn't 
+            /* MSIE compatibility hack.  MSIE has some RFC issues - doesn't
              * include the query string in the uri Authorization component
              * or when computing the response component.  the second part
              * works out ok, since we can hash the header and get the same
              * result.  however, the uri from the request line won't match
-             * the uri Authorization component since the header lacks the 
+             * the uri Authorization component since the header lacks the
              * query string, leaving us incompatable with a (broken) MSIE.
-             * 
+             *
              * the workaround is to fake a query string match if in the proper
              * environment - BrowserMatch MSIE, for example.  the cool thing
-             * is that if MSIE ever fixes itself the simple match ought to 
+             * is that if MSIE ever fixes itself the simple match ought to
              * work and this code won't be reached anyway, even if the
              * environment is set.
              */
 
-            if (apr_table_get(r->subprocess_env, 
+            if (apr_table_get(r->subprocess_env,
                               "AuthDigestEnableQueryStringHack")) {
-            
+
                 ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, "Digest: "
                               "applying AuthDigestEnableQueryStringHack "
                               "to uri <%s>", resp->raw_request_uri);
 
                d_uri.query = r_uri.query;
-            } 
+            }
         }
 
         if (r->method_number == M_CONNECT) {
@@ -1800,7 +1800,7 @@ static int authenticate_digest_user(request_rec *r)
          */
         return HTTP_INTERNAL_SERVER_ERROR;
     }
-    
+
     if (resp->message_qop == NULL) {
         /* old (rfc-2069) style digest */
         if (strcmp(resp->digest, old_digest(r, resp, conf->ha1))) {
diff --git a/modules/aaa/mod_authn_alias.c b/modules/aaa/mod_authn_alias.c
index 83d0677..648ab05 100644
--- a/modules/aaa/mod_authn_alias.c
+++ b/modules/aaa/mod_authn_alias.c
@@ -51,19 +51,19 @@ static authn_status authn_alias_check_password(request_rec *r, const char *user,
 
     const char *provider_name = apr_table_get(r->notes, AUTHN_PROVIDER_NAME_NOTE);
     authn_status ret = AUTH_USER_NOT_FOUND;
-    authn_alias_srv_conf *authcfg = 
-        (authn_alias_srv_conf *)ap_get_module_config(r->server->module_config, 
+    authn_alias_srv_conf *authcfg =
+        (authn_alias_srv_conf *)ap_get_module_config(r->server->module_config,
                                                      &authn_alias_module);
 
     if (provider_name) {
-        provider_alias_rec *prvdraliasrec = apr_hash_get(authcfg->alias_rec, 
+        provider_alias_rec *prvdraliasrec = apr_hash_get(authcfg->alias_rec,
                                                          provider_name, APR_HASH_KEY_STRING);
         ap_conf_vector_t *orig_dir_config = r->per_dir_config;
 
-        /* If we found the alias provider in the list, then merge the directory 
+        /* If we found the alias provider in the list, then merge the directory
            configurations and call the real provider */
         if (prvdraliasrec) {
-            r->per_dir_config = ap_merge_per_dir_configs(r->pool, orig_dir_config, 
+            r->per_dir_config = ap_merge_per_dir_configs(r->pool, orig_dir_config,
                                                          prvdraliasrec->sec_auth);
             ret = prvdraliasrec->provider->check_password(r,user,password);
             r->per_dir_config = orig_dir_config;
@@ -83,19 +83,19 @@ static authn_status authn_alias_get_realm_hash(request_rec *r, const char *user,
 
     const char *provider_name = apr_table_get(r->notes, AUTHN_PROVIDER_NAME_NOTE);
     authn_status ret = AUTH_USER_NOT_FOUND;
-    authn_alias_srv_conf *authcfg = 
-        (authn_alias_srv_conf *)ap_get_module_config(r->server->module_config, 
+    authn_alias_srv_conf *authcfg =
+        (authn_alias_srv_conf *)ap_get_module_config(r->server->module_config,
                                                      &authn_alias_module);
 
     if (provider_name) {
-        provider_alias_rec *prvdraliasrec = apr_hash_get(authcfg->alias_rec, 
+        provider_alias_rec *prvdraliasrec = apr_hash_get(authcfg->alias_rec,
                                                          provider_name, APR_HASH_KEY_STRING);
         ap_conf_vector_t *orig_dir_config = r->per_dir_config;
 
-        /* If we found the alias provider in the list, then merge the directory 
+        /* If we found the alias provider in the list, then merge the directory
            configurations and call the real provider */
         if (prvdraliasrec) {
-            r->per_dir_config = ap_merge_per_dir_configs(r->pool, orig_dir_config, 
+            r->per_dir_config = ap_merge_per_dir_configs(r->pool, orig_dir_config,
                                                          prvdraliasrec->sec_auth);
             ret = prvdraliasrec->provider->get_realm_hash(r,user,realm,rethash);
             r->per_dir_config = orig_dir_config;
@@ -131,8 +131,8 @@ static const char *authaliassection(cmd_parms *cmd, void *mconfig, const char *a
     char *provider_name;
     const char *errmsg;
     ap_conf_vector_t *new_auth_config = ap_create_per_dir_config(cmd->pool);
-    authn_alias_srv_conf *authcfg = 
-        (authn_alias_srv_conf *)ap_get_module_config(cmd->server->module_config, 
+    authn_alias_srv_conf *authcfg =
+        (authn_alias_srv_conf *)ap_get_module_config(cmd->server->module_config,
                                                      &authn_alias_module);
 
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
@@ -170,7 +170,7 @@ static const char *authaliassection(cmd_parms *cmd, void *mconfig, const char *a
         provider_alias_rec *prvdraliasrec = apr_pcalloc(cmd->pool, sizeof(provider_alias_rec));
         const authn_provider *provider = ap_lookup_provider(AUTHN_PROVIDER_GROUP, provider_name,"0");
 
-        /* Save off the new directory config along with the original provider name 
+        /* Save off the new directory config along with the original provider name
            and function pointer data */
         prvdraliasrec->sec_auth = new_auth_config;
         prvdraliasrec->provider_name = provider_name;
diff --git a/modules/aaa/mod_authn_anon.c b/modules/aaa/mod_authn_anon.c
index b0e48fb..e3c308d 100644
--- a/modules/aaa/mod_authn_anon.c
+++ b/modules/aaa/mod_authn_anon.c
@@ -20,7 +20,7 @@
  * as the password.
  *
  * Just add the following tokes to your <directory> setup:
- * 
+ *
  * Anonymous                    magic-userid [magic-userid]...
  *
  * Anonymous_MustGiveEmail      [ on | off ] default = on
@@ -28,8 +28,8 @@
  * Anonymous_VerifyEmail        [ on | off ] default = off
  * Anonymous_NoUserId           [ on | off ] default = off
  *
- * The magic user id is something like 'anonymous', it is NOT case sensitive. 
- * 
+ * The magic user id is something like 'anonymous', it is NOT case sensitive.
+ *
  * The MustGiveEmail flag can be used to force users to enter something
  * in the password field (like an email address). Default is on.
  *
@@ -38,7 +38,7 @@
  * in broken GUIs like W95 is often given by the user. The Default is off.
  *
  * Dirk.vanGulik@jrc.it; http://ewse.ceo.org; http://me-www.jrc.it/~dirkx
- * 
+ *
  */
 
 #include "apr_strings.h"
@@ -113,7 +113,7 @@ static const char *anon_set_string_slots(cmd_parms *cmd,
 
 static const command_rec authn_anon_cmds[] =
 {
-    AP_INIT_ITERATE("Anonymous", anon_set_string_slots, NULL, OR_AUTHCFG, 
+    AP_INIT_ITERATE("Anonymous", anon_set_string_slots, NULL, OR_AUTHCFG,
      "a space-separated list of user IDs"),
     AP_INIT_FLAG("Anonymous_MustGiveEmail", ap_set_flag_slot,
      (void *)APR_OFFSETOF(authn_anon_config_rec, mustemail),
diff --git a/modules/aaa/mod_authn_dbd.c b/modules/aaa/mod_authn_dbd.c
index 39e7562..15d1ae4 100644
--- a/modules/aaa/mod_authn_dbd.c
+++ b/modules/aaa/mod_authn_dbd.c
@@ -202,7 +202,7 @@ static void authn_dbd_hooks(apr_pool_t *p)
         &authn_dbd_password,
         &authn_dbd_realm
     };
-    
+
     ap_register_provider(p, AUTHN_PROVIDER_GROUP, "dbd", "0", &authn_dbd_provider);
 }
 module AP_MODULE_DECLARE_DATA authn_dbd_module =
diff --git a/modules/aaa/mod_authn_dbm.c b/modules/aaa/mod_authn_dbm.c
index 2f66203..d9ed980 100644
--- a/modules/aaa/mod_authn_dbm.c
+++ b/modules/aaa/mod_authn_dbm.c
@@ -16,9 +16,9 @@
 
 /*
  * http_auth: authentication
- * 
+ *
  * Rob McCool & Brian Behlendorf.
- * 
+ *
  * Adapted to Apache by rst.
  *
  */
@@ -54,12 +54,12 @@ static void *create_authn_dbm_dir_config(apr_pool_t *p, char *d)
     return conf;
 }
 
-static const char *set_dbm_type(cmd_parms *cmd, 
-                                void *dir_config, 
+static const char *set_dbm_type(cmd_parms *cmd,
+                                void *dir_config,
                                 const char *arg)
 {
     authn_dbm_config_rec *conf = dir_config;
-   
+
     conf->dbmtype = apr_pstrdup(cmd->pool, arg);
     return NULL;
 }
@@ -85,7 +85,7 @@ static apr_status_t fetch_dbm_value(const char *dbmtype, const char *dbmfile,
     apr_datum_t key, val;
     apr_status_t rv;
 
-    rv = apr_dbm_open_ex(&f, dbmtype, dbmfile, APR_DBM_READONLY, 
+    rv = apr_dbm_open_ex(&f, dbmtype, dbmfile, APR_DBM_READONLY,
                          APR_OS_DEFAULT, pool);
 
     if (rv != APR_SUCCESS) {
@@ -106,7 +106,7 @@ static apr_status_t fetch_dbm_value(const char *dbmtype, const char *dbmfile,
     }
 
     apr_dbm_close(f);
-    
+
     return rv;
 }
 
diff --git a/modules/aaa/mod_authnz_ldap.c b/modules/aaa/mod_authnz_ldap.c
index e1ef01b..586f80b 100644
--- a/modules/aaa/mod_authnz_ldap.c
+++ b/modules/aaa/mod_authnz_ldap.c
@@ -67,9 +67,9 @@ typedef struct {
     int compare_dn_on_server;       /* If true, will use server to do DN compare */
 
     int have_ldap_url;              /* Set if we have found an LDAP url */
- 
+
     apr_array_header_t *groupattr;  /* List of Group attributes */
-    int group_attrib_is_dn;         /* If true, the group attribute is the DN, otherwise, 
+    int group_attrib_is_dn;         /* If true, the group attribute is the DN, otherwise,
                                         it's the exact string passed by the HTTP client */
 
     int secure;                     /* True if SSL connections are requested */
@@ -106,12 +106,12 @@ static char* derive_codepage_from_lang (apr_pool_t *p, char *language)
 {
     int lang_len;
     char *charset;
-    
+
     if (!language)          /* our default codepage */
         return apr_pstrdup(p, "ISO-8859-1");
     else
         lang_len = strlen(language);
-    
+
     charset = (char*) apr_hash_get(charset_conversions, language, APR_HASH_KEY_STRING);
 
     if (!charset) {
@@ -163,14 +163,14 @@ static apr_xlate_t* get_conv_set (request_rec *r)
  * combined with a filter made up of the attribute provided with the URL,
  * and the actual username passed by the HTTP client. For example, assume
  * that the LDAP URL is
- * 
+ *
  *   ldap://ldap.airius.com/ou=People, o=Airius?uid??(posixid=*)
  *
  * Further, assume that the userid passed by the client was `userj'.  The
  * search filter will be (&(posixid=*)(uid=userj)).
  */
 #define FILTER_LENGTH MAX_STRING_LEN
-static void authn_ldap_build_filter(char *filtbuf, 
+static void authn_ldap_build_filter(char *filtbuf,
                              request_rec *r,
                              const char* sent_user,
                              const char* sent_filter,
@@ -210,13 +210,13 @@ static void authn_ldap_build_filter(char *filtbuf,
         }
     }
 
-    /* 
-     * Create the first part of the filter, which consists of the 
+    /*
+     * Create the first part of the filter, which consists of the
      * config-supplied portions.
      */
     apr_snprintf(filtbuf, FILTER_LENGTH, "(&(%s)(%s=", filter, sec->attribute);
 
-    /* 
+    /*
      * Now add the client-supplied username to the filter, ensuring that any
      * LDAP filter metachars are escaped.
      */
@@ -264,8 +264,8 @@ static void authn_ldap_build_filter(char *filtbuf,
 #endif
     *q = '\0';
 
-    /* 
-     * Append the closing parens of the filter, unless doing so would 
+    /*
+     * Append the closing parens of the filter, unless doing so would
      * overrun the buffer.
      */
     if (q + 2 <= filtbuf_end)
@@ -274,7 +274,7 @@ static void authn_ldap_build_filter(char *filtbuf,
 
 static void *create_authnz_ldap_dir_config(apr_pool_t *p, char *d)
 {
-    authn_ldap_config_t *sec = 
+    authn_ldap_config_t *sec =
         (authn_ldap_config_t *)apr_pcalloc(p, sizeof(authn_ldap_config_t));
 
     sec->pool = p;
@@ -284,7 +284,7 @@ static void *create_authnz_ldap_dir_config(apr_pool_t *p, char *d)
 /*
     sec->authz_enabled = 1;
 */
-    sec->groupattr = apr_array_make(p, GROUPATTR_MAX_ELTS, 
+    sec->groupattr = apr_array_make(p, GROUPATTR_MAX_ELTS,
                                     sizeof(struct mod_auth_ldap_groupattr_entry_t));
 
     sec->have_ldap_url = 0;
@@ -347,9 +347,9 @@ static authn_status authn_ldap_check_password(request_rec *r, const char *user,
     if (!sec->enabled) {
         return AUTH_USER_NOT_FOUND;
     }
-*/    
+*/
 
-    /* 
+    /*
      * Basic sanity checks before any LDAP operations even happen.
      */
     if (!sec->have_ldap_url) {
@@ -365,7 +365,7 @@ start_over:
                                        sec->secure);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, 
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                       "[%" APR_PID_T_FMT "] auth_ldap authenticate: no sec->host - weird...?", getpid());
         return AUTH_GENERAL_ERROR;
     }
@@ -405,7 +405,7 @@ start_over:
 
     /* handle bind failure */
     if (result != LDAP_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, 
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                       "[%" APR_PID_T_FMT "] auth_ldap authenticate: "
                       "user %s authentication failed; URI %s [%s][%s]",
                       getpid(), user, r->uri, ldc->reason, ldap_err2string(result));
@@ -442,7 +442,7 @@ start_over:
         }
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                   "[%" APR_PID_T_FMT "] auth_ldap authenticate: accepting %s", getpid(), user);
 
     return AUTH_GRANTED;
@@ -491,7 +491,7 @@ static int authz_ldap_check_user_access(request_rec *r)
     if (!sec->enabled) {
         return DECLINED;
     }
-*/    
+*/
 
     if (!sec->have_ldap_url) {
         return DECLINED;
@@ -506,12 +506,12 @@ static int authz_ldap_check_user_access(request_rec *r)
                                   apr_pool_cleanup_null);
     }
     else {
-        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, 
+        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                       "[%" APR_PID_T_FMT "] auth_ldap authorise: no sec->host - weird...?", getpid());
         return sec->auth_authoritative? HTTP_UNAUTHORIZED : DECLINED;
     }
 
-    /* 
+    /*
      * If there are no elements in the group attribute array, the default should be
      * member and uniquemember; populate the array now.
      */
@@ -583,49 +583,49 @@ static int authz_ldap_check_user_access(request_rec *r)
 
         t = reqs[x].requirement;
         w = ap_getword_white(r->pool, &t);
-    
+
         if (strcmp(w, "ldap-user") == 0) {
             if (req->dn == NULL || strlen(req->dn) == 0) {
                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                               "[%" APR_PID_T_FMT "] auth_ldap authorise: "
-                              "require user: user's DN has not been defined; failing authorisation", 
+                              "require user: user's DN has not been defined; failing authorisation",
                               getpid());
                 return sec->auth_authoritative? HTTP_UNAUTHORIZED : DECLINED;
             }
-            /* 
+            /*
              * First do a whole-line compare, in case it's something like
              *   require user Babs Jensen
              */
             result = util_ldap_cache_compare(r, ldc, sec->url, req->dn, sec->attribute, t);
             switch(result) {
                 case LDAP_COMPARE_TRUE: {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                                   "[%" APR_PID_T_FMT "] auth_ldap authorise: "
                                   "require user: authorisation successful", getpid());
                     return OK;
                 }
                 default: {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                                   "[%" APR_PID_T_FMT "] auth_ldap authorise: require user: "
                                   "authorisation failed [%s][%s]", getpid(),
                                   ldc->reason, ldap_err2string(result));
                 }
             }
-            /* 
-             * Now break apart the line and compare each word on it 
+            /*
+             * Now break apart the line and compare each word on it
              */
             while (t[0]) {
                 w = ap_getword_conf(r->pool, &t);
                 result = util_ldap_cache_compare(r, ldc, sec->url, req->dn, sec->attribute, w);
                 switch(result) {
                     case LDAP_COMPARE_TRUE: {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                                       "[%" APR_PID_T_FMT "] auth_ldap authorise: "
                                       "require user: authorisation successful", getpid());
                         return OK;
                     }
                     default: {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                                       "[%" APR_PID_T_FMT "] auth_ldap authorise: "
                                       "require user: authorisation failed [%s][%s]",
                                       getpid(), ldc->reason, ldap_err2string(result));
@@ -637,7 +637,7 @@ static int authz_ldap_check_user_access(request_rec *r)
             if (req->dn == NULL || strlen(req->dn) == 0) {
                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                               "[%" APR_PID_T_FMT "] auth_ldap authorise: "
-                              "require dn: user's DN has not been defined; failing authorisation", 
+                              "require dn: user's DN has not been defined; failing authorisation",
                               getpid());
                 return sec->auth_authoritative? HTTP_UNAUTHORIZED : DECLINED;
             }
@@ -645,13 +645,13 @@ static int authz_ldap_check_user_access(request_rec *r)
             result = util_ldap_cache_comparedn(r, ldc, sec->url, req->dn, t, sec->compare_dn_on_server);
             switch(result) {
                 case LDAP_COMPARE_TRUE: {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                                   "[%" APR_PID_T_FMT "] auth_ldap authorise: "
                                   "require dn: authorisation successful", getpid());
                     return OK;
                 }
                 default: {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                                   "[%" APR_PID_T_FMT "] auth_ldap authorise: "
                                   "require dn \"%s\": LDAP error [%s][%s]",
                                   getpid(), t, ldc->reason, ldap_err2string(result));
@@ -666,42 +666,42 @@ static int authz_ldap_check_user_access(request_rec *r)
                 if (req->dn == NULL || strlen(req->dn) == 0) {
                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                                   "[%" APR_PID_T_FMT "] auth_ldap authorise: require group: "
-                                  "user's DN has not been defined; failing authorisation", 
+                                  "user's DN has not been defined; failing authorisation",
                                   getpid());
                     return sec->auth_authoritative? HTTP_UNAUTHORIZED : DECLINED;
                 }
             }
             else {
                 if (req->user == NULL || strlen(req->user) == 0) {
-                    /* We weren't called in the authentication phase, so we didn't have a 
+                    /* We weren't called in the authentication phase, so we didn't have a
                      * chance to set the user field. Do so now. */
                     req->user = r->user;
                 }
             }
 
-            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                           "[%" APR_PID_T_FMT "] auth_ldap authorise: require group: "
-                          "testing for group membership in \"%s\"", 
+                          "testing for group membership in \"%s\"",
                           getpid(), t);
 
             for (i = 0; i < sec->groupattr->nelts; i++) {
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                               "[%" APR_PID_T_FMT "] auth_ldap authorise: require group: "
                               "testing for %s: %s (%s)", getpid(),
                               ent[i].name, sec->group_attrib_is_dn ? req->dn : req->user, t);
 
-                result = util_ldap_cache_compare(r, ldc, sec->url, t, ent[i].name, 
+                result = util_ldap_cache_compare(r, ldc, sec->url, t, ent[i].name,
                                      sec->group_attrib_is_dn ? req->dn : req->user);
                 switch(result) {
                     case LDAP_COMPARE_TRUE: {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                                       "[%" APR_PID_T_FMT "] auth_ldap authorise: require group: "
                                       "authorisation successful (attribute %s) [%s][%s]",
                                       getpid(), ent[i].name, ldc->reason, ldap_err2string(result));
                         return OK;
                     }
                     default: {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                                       "[%" APR_PID_T_FMT "] auth_ldap authorise: require group \"%s\": "
                                       "authorisation failed [%s][%s]",
                                       getpid(), t, ldc->reason, ldap_err2string(result));
@@ -713,7 +713,7 @@ static int authz_ldap_check_user_access(request_rec *r)
             if (req->dn == NULL || strlen(req->dn) == 0) {
                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                               "[%" APR_PID_T_FMT "] auth_ldap authorise: "
-                              "require ldap-attribute: user's DN has not been defined; failing authorisation", 
+                              "require ldap-attribute: user's DN has not been defined; failing authorisation",
                               getpid());
                 return sec->auth_authoritative? HTTP_UNAUTHORIZED : DECLINED;
             }
@@ -728,17 +728,17 @@ static int authz_ldap_check_user_access(request_rec *r)
                                                  w, value);
                 switch(result) {
                     case LDAP_COMPARE_TRUE: {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG,
                                       0, r, "[%" APR_PID_T_FMT "] auth_ldap authorise: "
                                       "require attribute: authorisation "
                                       "successful", getpid());
                         return OK;
                     }
                     default: {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG,
                                       0, r, "[%" APR_PID_T_FMT "] auth_ldap authorise: "
                                       "require attribute: authorisation "
-                                      "failed [%s][%s]", getpid(), 
+                                      "failed [%s][%s]", getpid(),
                                       ldc->reason, ldap_err2string(result));
                     }
                 }
@@ -748,13 +748,13 @@ static int authz_ldap_check_user_access(request_rec *r)
             if (req->dn == NULL || strlen(req->dn) == 0) {
                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                               "[%" APR_PID_T_FMT "] auth_ldap authorise: "
-                              "require ldap-filter: user's DN has not been defined; failing authorisation", 
+                              "require ldap-filter: user's DN has not been defined; failing authorisation",
                               getpid());
                 return sec->auth_authoritative? HTTP_UNAUTHORIZED : DECLINED;
             }
             if (t[0]) {
                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-                              "[%" APR_PID_T_FMT "] auth_ldap authorise: checking filter %s", 
+                              "[%" APR_PID_T_FMT "] auth_ldap authorise: checking filter %s",
                               getpid(), t);
 
                 /* Build the username filter */
@@ -767,33 +767,33 @@ static int authz_ldap_check_user_access(request_rec *r)
                 /* Make sure that the filtered search returned the correct user dn */
                 if (result == LDAP_SUCCESS) {
                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
-                                  "[%" APR_PID_T_FMT "] auth_ldap authorise: checking dn match %s", 
+                                  "[%" APR_PID_T_FMT "] auth_ldap authorise: checking dn match %s",
                                   getpid(), dn);
-                    result = util_ldap_cache_comparedn(r, ldc, sec->url, req->dn, dn, 
+                    result = util_ldap_cache_comparedn(r, ldc, sec->url, req->dn, dn,
                          sec->compare_dn_on_server);
                 }
 
                 switch(result) {
                     case LDAP_COMPARE_TRUE: {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG,
                                       0, r, "[%" APR_PID_T_FMT "] auth_ldap authorise: "
                                       "require ldap-filter: authorisation "
                                       "successful", getpid());
                         return OK;
                     }
                     case LDAP_FILTER_ERROR: {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG,
                                       0, r, "[%" APR_PID_T_FMT "] auth_ldap authorise: "
                                       "require ldap-filter: %s authorisation "
-                                      "failed [%s][%s]", getpid(), 
+                                      "failed [%s][%s]", getpid(),
                                       filtbuf, ldc->reason, ldap_err2string(result));
                         break;
                     }
                     default: {
-                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 
+                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG,
                                       0, r, "[%" APR_PID_T_FMT "] auth_ldap authorise: "
                                       "require ldap-filter: authorisation "
-                                      "failed [%s][%s]", getpid(), 
+                                      "failed [%s][%s]", getpid(),
                                       ldc->reason, ldap_err2string(result));
                     }
                 }
@@ -802,19 +802,19 @@ static int authz_ldap_check_user_access(request_rec *r)
     }
 
     if (!method_restricted) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
-                      "[%" APR_PID_T_FMT "] auth_ldap authorise: agreeing because non-restricted", 
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
+                      "[%" APR_PID_T_FMT "] auth_ldap authorise: agreeing because non-restricted",
                       getpid());
         return OK;
     }
 
     if (!sec->auth_authoritative) {
-        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                       "[%" APR_PID_T_FMT "] auth_ldap authorise: declining to authorise", getpid());
         return DECLINED;
     }
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                   "[%" APR_PID_T_FMT "] auth_ldap authorise: authorisation denied", getpid());
     ap_note_basic_auth_failure (r);
 
@@ -822,11 +822,11 @@ static int authz_ldap_check_user_access(request_rec *r)
 }
 
 
-/* 
+/*
  * Use the ldap url parsing routines to break up the ldap url into
  * host and port.
  */
-static const char *mod_auth_ldap_parse_url(cmd_parms *cmd, 
+static const char *mod_auth_ldap_parse_url(cmd_parms *cmd,
                                     void *config,
                                     const char *url,
                                     const char *mode)
@@ -855,9 +855,9 @@ static const char *mod_auth_ldap_parse_url(cmd_parms *cmd,
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0,
                  cmd->server, "[%" APR_PID_T_FMT "] auth_ldap url parse: attrib: %s", getpid(), urld->lud_attrs? urld->lud_attrs[0] : "(null)");
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0,
-                 cmd->server, "[%" APR_PID_T_FMT "] auth_ldap url parse: scope: %s", getpid(), 
-                 (urld->lud_scope == LDAP_SCOPE_SUBTREE? "subtree" : 
-                  urld->lud_scope == LDAP_SCOPE_BASE? "base" : 
+                 cmd->server, "[%" APR_PID_T_FMT "] auth_ldap url parse: scope: %s", getpid(),
+                 (urld->lud_scope == LDAP_SCOPE_SUBTREE? "subtree" :
+                  urld->lud_scope == LDAP_SCOPE_BASE? "base" :
                   urld->lud_scope == LDAP_SCOPE_ONELEVEL? "onelevel" : "unknown"));
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0,
                  cmd->server, "[%" APR_PID_T_FMT "] auth_ldap url parse: filter: %s", getpid(), urld->lud_filter);
@@ -896,7 +896,7 @@ static const char *mod_auth_ldap_parse_url(cmd_parms *cmd,
 
     if (urld->lud_filter) {
         if (urld->lud_filter[0] == '(') {
-            /* 
+            /*
              * Get rid of the surrounding parens; later on when generating the
              * filter, they'll be put back.
              */
@@ -939,7 +939,7 @@ static const char *mod_auth_ldap_parse_url(cmd_parms *cmd,
     else
     {
         sec->port = urld->lud_port? urld->lud_port : LDAP_PORT;
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, 
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
                      "LDAP: auth_ldap not using SSL connections");
     }
 
@@ -981,7 +981,7 @@ static const char *mod_auth_ldap_add_group_attribute(cmd_parms *cmd, void *confi
 
     new = apr_array_push(sec->groupattr);
     new->name = apr_pstrdup(cmd->pool, arg);
-  
+
     return NULL;
 }
 
@@ -994,7 +994,7 @@ static const char *set_charset_config(cmd_parms *cmd, void *config, const char *
 
 static const command_rec authnz_ldap_cmds[] =
 {
-    AP_INIT_TAKE12("AuthLDAPURL", mod_auth_ldap_parse_url, NULL, OR_AUTHCFG, 
+    AP_INIT_TAKE12("AuthLDAPURL", mod_auth_ldap_parse_url, NULL, OR_AUTHCFG,
                   "URL to define LDAP connection. This should be an RFC 2255 complaint\n"
                   "URL of the form ldap://host[:port]/basedn[?attrib[?scope[?filter]]].\n"
                   "<ul>\n"
@@ -1079,17 +1079,17 @@ static int authnz_ldap_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *
     const char *charset_confname = ap_get_module_config(s->module_config,
                                                       &authnz_ldap_module);
     apr_status_t status;
-    
+
     /*
     authn_ldap_config_t *sec = (authn_ldap_config_t *)
-                                    ap_get_module_config(s->module_config, 
+                                    ap_get_module_config(s->module_config,
                                                          &authnz_ldap_module);
 
     if (sec->secure)
     {
         if (!util_ldap_ssl_supported(s))
         {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s, 
+            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, s,
                      "LDAP: SSL connections (ldaps://) not supported by utilLDAP");
             return(!OK);
         }
@@ -1112,15 +1112,15 @@ static int authnz_ldap_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *
     charset_confname = ap_server_root_relative(p, charset_confname);
     if (!charset_confname) {
         ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
-                     "Invalid charset conversion config path %s", 
+                     "Invalid charset conversion config path %s",
                      (const char *)ap_get_module_config(s->module_config,
                                                         &authnz_ldap_module));
         return HTTP_INTERNAL_SERVER_ERROR;
     }
-    if ((status = ap_pcfg_openfile(&f, ptemp, charset_confname)) 
+    if ((status = ap_pcfg_openfile(&f, ptemp, charset_confname))
                 != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, status, s,
-                     "could not open charset conversion config file %s.", 
+                     "could not open charset conversion config file %s.",
                      charset_confname);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -1143,11 +1143,11 @@ static int authnz_ldap_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *
         }
     }
     ap_cfg_closefile(f);
-    
+
     to_charset = derive_codepage_from_lang (p, "utf-8");
     if (to_charset == NULL) {
         ap_log_error(APLOG_MARK, APLOG_ERR, status, s,
-                     "could not find the UTF-8 charset in the file %s.", 
+                     "could not find the UTF-8 charset in the file %s.",
                      charset_confname);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
diff --git a/modules/aaa/mod_authz_dbm.c b/modules/aaa/mod_authz_dbm.c
index 8c21112..a69c747 100644
--- a/modules/aaa/mod_authz_dbm.c
+++ b/modules/aaa/mod_authz_dbm.c
@@ -90,7 +90,7 @@ module AP_MODULE_DECLARE_DATA authz_dbm_module;
  *      key=username value=":"groupname [":"anything here is ignored]
  * otherwise we now (0.8.14+) assume that the format is
  *      key=username value=groupname
- * The first allows the password and group files to be the same 
+ * The first allows the password and group files to be the same
  * physical DBM file;   key=username value=password":"groupname[":"anything]
  *
  * mark@telescope.org, 22Sep95
@@ -104,7 +104,7 @@ static apr_status_t get_dbm_grp(request_rec *r, char *key1, char *key2,
     apr_status_t retval;
     apr_dbm_t *f;
 
-    retval = apr_dbm_open_ex(&f, dbtype, dbmgrpfile, APR_DBM_READONLY, 
+    retval = apr_dbm_open_ex(&f, dbtype, dbmgrpfile, APR_DBM_READONLY,
                              APR_OS_DEFAULT, r->pool);
 
     if (retval != APR_SUCCESS) {
@@ -166,10 +166,10 @@ static int dbm_check_auth(request_rec *r)
 
         t = reqs[x].requirement;
         w = ap_getword_white(r->pool, &t);
- 
+
         if (!strcasecmp(w, "file-group")) {
             filegroup = apr_table_get(r->notes, AUTHZ_GROUP_NOTE);
-            
+
             if (!filegroup) {
                 /* mod_authz_owner is not present or not
                  * authoritative. We are just a helper module for testing
diff --git a/modules/aaa/mod_authz_default.c b/modules/aaa/mod_authz_default.c
index 88859b2..0576a0c 100644
--- a/modules/aaa/mod_authz_default.c
+++ b/modules/aaa/mod_authz_default.c
@@ -59,7 +59,7 @@ static int check_user_access(request_rec *r)
     const apr_array_header_t *reqs_arr = ap_requires(r);
     require_line *reqs;
 
-    /* BUG FIX: tadc, 11-Nov-1995.  If there is no "requires" directive, 
+    /* BUG FIX: tadc, 11-Nov-1995.  If there is no "requires" directive,
      * then any user will do.
      */
     if (!reqs_arr) {
@@ -84,7 +84,7 @@ static int check_user_access(request_rec *r)
     }
 
     /* if we aren't authoritative, any require directive could be
-     * considered valid even if noone groked it.  However, if we are 
+     * considered valid even if noone groked it.  However, if we are
      * authoritative, we can warn the user they did something wrong.
      *
      * That something could be a missing "AuthAuthoritative off", but
diff --git a/modules/aaa/mod_authz_groupfile.c b/modules/aaa/mod_authz_groupfile.c
index 9f83866..77a63b9 100644
--- a/modules/aaa/mod_authz_groupfile.c
+++ b/modules/aaa/mod_authz_groupfile.c
@@ -21,24 +21,24 @@
  * and the presense of a
  *
  *         require group <list-of-groups>
- * 
+ *
  * In an applicable limit/directory block for that method.
  *
- * If there are no AuthGroupFile directives valid for 
+ * If there are no AuthGroupFile directives valid for
  * the request; we DECLINED.
- * 
+ *
  * If the AuthGroupFile is defined; but somehow not
  * accessible: we SERVER_ERROR (was DECLINED).
  *
  * If there are no 'require ' directives defined for
  * this request then we DECLINED (was OK).
- * 
+ *
  * If there are no 'require ' directives valid for
  * this request method then we DECLINED. (was OK)
  *
  * If there are any 'require group' blocks and we
  * are not in any group - we HTTP_UNAUTHORIZE
- * unless we are non-authoritative; in which  
+ * unless we are non-authoritative; in which
  * case we DECLINED.
  *
  */
@@ -65,12 +65,12 @@ static void *create_authz_groupfile_dir_config(apr_pool_t *p, char *d)
 {
     authz_groupfile_config_rec *conf = apr_palloc(p, sizeof(*conf));
 
-    conf->groupfile = NULL;    
+    conf->groupfile = NULL;
     conf->authoritative = 1; /* keep the fortress secure by default */
     return conf;
 }
 
-static const char *set_authz_groupfile_slot(cmd_parms *cmd, void *offset, const char *f, 
+static const char *set_authz_groupfile_slot(cmd_parms *cmd, void *offset, const char *f,
                                  const char *t)
 {
     if (t && strcmp(t, "standard")) {
@@ -163,7 +163,7 @@ static int check_user_access(request_rec *r)
     char *reason = NULL;
 
     /* If there is no group file - then we are not
-     * configured. So decline. 
+     * configured. So decline.
      */
     if (!(conf->groupfile)) {
         return DECLINED;
@@ -171,8 +171,8 @@ static int check_user_access(request_rec *r)
 
     if (!reqs_arr) {
         return DECLINED; /* XXX change from legacy */
-    } 
-    
+    }
+
     reqs = (require_line *)reqs_arr->elts;
 
     for (x = 0; x < reqs_arr->nelts; x++) {
@@ -187,7 +187,7 @@ static int check_user_access(request_rec *r)
         /* needs mod_authz_owner to be present */
         if (!strcasecmp(w, "file-group")) {
             filegroup = apr_table_get(r->notes, AUTHZ_GROUP_NOTE);
-            
+
             if (!filegroup) {
                 /* mod_authz_owner is not present or not
                  * authoritative. We are just a helper module for testing
diff --git a/modules/aaa/mod_authz_host.c b/modules/aaa/mod_authz_host.c
index b817b9e..582f32c 100644
--- a/modules/aaa/mod_authz_host.c
+++ b/modules/aaa/mod_authz_host.c
@@ -16,9 +16,9 @@
 
 /*
  * Security options etc.
- * 
+ *
  * Module derived from code originally written by Rob McCool
- * 
+ *
  */
 
 #include "apr_strings.h"
@@ -106,7 +106,7 @@ static const char *order(cmd_parms *cmd, void *dv, const char *arg)
     return NULL;
 }
 
-static const char *allow_cmd(cmd_parms *cmd, void *dv, const char *from, 
+static const char *allow_cmd(cmd_parms *cmd, void *dv, const char *from,
                              const char *where_c)
 {
     authz_host_dir_conf *d = (authz_host_dir_conf *) dv;
diff --git a/modules/aaa/mod_authz_owner.c b/modules/aaa/mod_authz_owner.c
index 8f56879..050860d 100644
--- a/modules/aaa/mod_authz_owner.c
+++ b/modules/aaa/mod_authz_owner.c
@@ -195,7 +195,7 @@ static int check_file_owner(request_rec *r)
     if (!required_owner || !conf->authoritative) {
         return DECLINED;
     }
-    
+
     /* allow file-group passed to group db modules either if this is the
      * only applicable requirement here or if a file-owner failed but we're
      * not authoritative.
diff --git a/modules/aaa/mod_authz_user.c b/modules/aaa/mod_authz_user.c
index 0296b35..cc6d808 100644
--- a/modules/aaa/mod_authz_user.c
+++ b/modules/aaa/mod_authz_user.c
@@ -61,7 +61,7 @@ static int check_user_access(request_rec *r)
     const apr_array_header_t *reqs_arr = ap_requires(r);
     require_line *reqs;
 
-    /* BUG FIX: tadc, 11-Nov-1995.  If there is no "requires" directive, 
+    /* BUG FIX: tadc, 11-Nov-1995.  If there is no "requires" directive,
      * then any user will do.
      */
     if (!reqs_arr) {
@@ -81,7 +81,7 @@ static int check_user_access(request_rec *r)
             return OK;
         }
         if (!strcasecmp(w, "user")) {
-            /* And note that there are applicable requirements 
+            /* And note that there are applicable requirements
              * which we consider ourselves the owner of.
              */
             required_user = 1;
@@ -107,7 +107,7 @@ static int check_user_access(request_rec *r)
                   "access to %s failed, reason: user '%s' does not meet "
                   "'require'ments for user/valid-user to be allowed access",
                   r->uri, user);
-        
+
     ap_note_auth_failure(r);
     return HTTP_UNAUTHORIZED;
 }
diff --git a/modules/arch/netware/libprews.c b/modules/arch/netware/libprews.c
index a76b02f..7654ee4 100644
--- a/modules/arch/netware/libprews.c
+++ b/modules/arch/netware/libprews.c
@@ -19,7 +19,7 @@
   stops.  By using these functions instead of defining a main()
   and calling ExitThread(TSR_THREAD, 0), the load time of the
   shared NLM is faster and memory size reduced.
-   
+
   You may also want to override these in your own Apache module
   to do any cleanup other than the mechanism Apache modules
   provide.
@@ -58,7 +58,7 @@ int _NonAppStart
 
 #ifdef USE_WINSOCK
     WSADATA wsaData;
-    
+
     return WSAStartup((WORD) MAKEWORD(2, 0), &wsaData);
 #else
     return 0;
diff --git a/modules/arch/netware/mod_netware.c b/modules/arch/netware/mod_netware.c
index f7fd0b0..0c296c4 100644
--- a/modules/arch/netware/mod_netware.c
+++ b/modules/arch/netware/mod_netware.c
@@ -75,9 +75,9 @@ static const char *set_extension_map(cmd_parms *cmd, netware_dir_config *m,
 
     if (*ext == '.')
         ++ext;
-  
+
     if (CGIhdlr != NULL) {
-        len = strlen(CGIhdlr);    
+        len = strlen(CGIhdlr);
         for (i=0; i<len; i++) {
             if (CGIhdlr[i] == '\\') {
                 CGIhdlr[i] = '/';
@@ -94,7 +94,7 @@ static const char *set_extension_map(cmd_parms *cmd, netware_dir_config *m,
 }
 
 static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
-                                         request_rec *r, apr_pool_t *p, 
+                                         request_rec *r, apr_pool_t *p,
                                          cgi_exec_info_t *e_info)
 {
     char *ext = NULL;
@@ -104,7 +104,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
     apr_file_t *fh;
     const char *args = "";
 
-    d = (netware_dir_config *)ap_get_module_config(r->per_dir_config, 
+    d = (netware_dir_config *)ap_get_module_config(r->per_dir_config,
                                                &netware_module);
 
     if (e_info->process_cgi) {
@@ -135,7 +135,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
     if (!ext) {
         ext = "";
     }
-    
+
     /* eliminate the '.' if there is one */
     if (*ext == '.')
         ++ext;
@@ -173,7 +173,7 @@ static void register_hooks(apr_pool_t *p)
 }
 
 static const command_rec netware_cmds[] = {
-AP_INIT_TAKE23("CGIMapExtension", set_extension_map, NULL, OR_FILEINFO, 
+AP_INIT_TAKE23("CGIMapExtension", set_extension_map, NULL, OR_FILEINFO,
               "Full path to the CGI NLM module followed by a file extension. If the "
               "first parameter is set to \"OS\" then the following file extension is "
               "treated as NLM. The optional parameter \"detach\" can be specified if "
diff --git a/modules/arch/netware/mod_nw_ssl.c b/modules/arch/netware/mod_nw_ssl.c
index 54e81f2..43ce874 100644
--- a/modules/arch/netware/mod_nw_ssl.c
+++ b/modules/arch/netware/mod_nw_ssl.c
@@ -29,7 +29,7 @@
  *
  *  Examples:
  *
- *          SecureListen 443 "SSL CertificateIP"  
+ *          SecureListen 443 "SSL CertificateIP"
  *          SecureListen 123.45.67.89:443 mycert
  */
 
@@ -183,7 +183,7 @@ static unsigned long parse_addr(const char *w, unsigned short *ports)
     hep = gethostbyname(w);
 
     if ((!hep) || (hep->h_addrtype != AF_INET || !hep->h_addr_list[0])) {
-        /* XXX Should be echoing by h_errno the actual failure, no? 
+        /* XXX Should be echoing by h_errno the actual failure, no?
          * ap_log_error would be good here.  Better yet - APRize.
          */
         fprintf(stderr, "Cannot resolve host name %s --- exiting!\n", w);
@@ -212,7 +212,7 @@ static int find_secure_listener(seclisten_rec *lr)
             sl->used = 1;
             return sl->fd;
         }
-    }    
+    }
     return -1;
 }
 
@@ -221,11 +221,11 @@ static char *get_port_key(conn_rec *c)
     seclistenup_rec *sl;
 
     for (sl = ap_seclistenersup; sl; sl = sl->next) {
-        if ((sl->port == (c->local_addr)->port) && 
+        if ((sl->port == (c->local_addr)->port) &&
             ((strcmp(sl->addr, "0.0.0.0") == 0) || (strcmp(sl->addr, c->local_ip) == 0))) {
             return sl->key;
         }
-    }    
+    }
     return NULL;
 }
 
@@ -239,7 +239,7 @@ static int make_secure_socket(apr_pool_t *pconf, const struct sockaddr_in *serve
     unsigned int optParam;
     WSAPROTOCOL_INFO SecureProtoInfo;
     int no = 1;
-    
+
     if (server->sin_addr.s_addr != htonl(INADDR_ANY))
         apr_snprintf(addr, sizeof(addr), "address %s port %d",
             inet_ntoa(server->sin_addr), ntohs(server->sin_port));
@@ -251,22 +251,22 @@ static int make_secure_socket(apr_pool_t *pconf, const struct sockaddr_in *serve
 
     SecureProtoInfo.iAddressFamily = AF_INET;
     SecureProtoInfo.iSocketType = SOCK_STREAM;
-    SecureProtoInfo.iProtocol = IPPROTO_TCP;   
+    SecureProtoInfo.iProtocol = IPPROTO_TCP;
     SecureProtoInfo.iSecurityScheme = SECURITY_PROTOCOL_SSL;
 
     s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP,
             (LPWSAPROTOCOL_INFO)&SecureProtoInfo, 0, 0);
-            
+
     if (s == INVALID_SOCKET) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf,
-                     "make_secure_socket: failed to get a socket for %s", 
+                     "make_secure_socket: failed to get a socket for %s",
                      addr);
         return -1;
     }
-        
+
     if (!mutual) {
         optParam = SO_SSL_ENABLE | SO_SSL_SERVER;
-                    
+
         if (WSAIoctl(s, SO_SSL_SET_FLAGS, (char *)&optParam,
             sizeof(optParam), NULL, 0, NULL, NULL, NULL)) {
             ap_log_error(APLOG_MARK, APLOG_CRIT, WSAGetLastError(), sconf,
@@ -303,7 +303,7 @@ static int make_secure_socket(apr_pool_t *pconf, const struct sockaddr_in *serve
     }
 
     optParam = SO_TLS_UNCLEAN_SHUTDOWN;
-    WSAIoctl(s, SO_SSL_SET_FLAGS, (char *)&optParam, sizeof(optParam), 
+    WSAIoctl(s, SO_SSL_SET_FLAGS, (char *)&optParam, sizeof(optParam),
              NULL, 0, NULL, NULL, NULL);
 
     return s;
@@ -355,7 +355,7 @@ int convert_secure_socket(conn_rec *c, apr_socket_t *csd)
     	unicpy(keyFileName, L"SSL CertificateIP");
     	sWS2Opts.wallet = keyFileName;    /* no client certificate */
     	sWS2Opts.walletlen = unilen(keyFileName);
-    
+
     	sNWTLSOpts.walletProvider 		= WAL_PROV_KMO;	//the wallet provider defined in wdefs.h
     }
 
@@ -368,7 +368,7 @@ int convert_secure_socket(conn_rec *c, apr_socket_t *csd)
         if(SOCKET_ERROR == rcode ){
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server,
                      "Error: %d with ioctl (SO_TLS_SET_CLIENT)", WSAGetLastError());
-        }		
+        }
         return rcode;
 }
 
@@ -379,11 +379,11 @@ int SSLize_Socket(SOCKET socketHnd, char *key, request_rec *r)
     struct nwtlsopts    sNWTLSOpts;
     unicode_t SASKey[512];
     unsigned long ulFlag;
-    
+
     memset((char *)&sWS2Opts, 0, sizeof(struct tlsserveropts));
     memset((char *)&sNWTLSOpts, 0, sizeof(struct nwtlsopts));
-    
-    
+
+
     ulFlag = SO_TLS_ENABLE;
     rcode = WSAIoctl(socketHnd, SO_TLS_SET_FLAGS, &ulFlag, sizeof(unsigned long), NULL, 0, NULL, NULL, NULL);
     if(rcode)
@@ -392,18 +392,18 @@ int SSLize_Socket(SOCKET socketHnd, char *key, request_rec *r)
                      "Error: %d with WSAIoctl(SO_TLS_SET_FLAGS, SO_TLS_ENABLE)", WSAGetLastError());
         goto ERR;
     }
-    
-    
+
+
     ulFlag = SO_TLS_SERVER;
     rcode = WSAIoctl(socketHnd, SO_TLS_SET_FLAGS, &ulFlag, sizeof(unsigned long),NULL, 0, NULL, NULL, NULL);
-    
+
     if(rcode)
     {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                      "Error: %d with WSAIoctl(SO_TLS_SET_FLAGS, SO_TLS_SERVER)", WSAGetLastError());
         goto ERR;
     }
-    
+
     loc2uni(UNI_LOCAL_DEFAULT, SASKey, key, 0, 0);
 
     //setup the tlsserveropts struct
@@ -413,9 +413,9 @@ int SSLize_Socket(SOCKET socketHnd, char *key, request_rec *r)
     sWS2Opts.sidentries = 0;
     sWS2Opts.siddir = NULL;
     sWS2Opts.options = &sNWTLSOpts;
-    
+
     //setup the nwtlsopts structure
-    
+
     sNWTLSOpts.walletProvider               = WAL_PROV_KMO;
     sNWTLSOpts.keysList                     = NULL;
     sNWTLSOpts.numElementsInKeyList         = 0;
@@ -425,29 +425,29 @@ int SSLize_Socket(SOCKET socketHnd, char *key, request_rec *r)
     sNWTLSOpts.reserved1                    = NULL;
     sNWTLSOpts.reserved2                    = NULL;
     sNWTLSOpts.reserved3                    = NULL;
-    
-    
-    rcode = WSAIoctl(socketHnd, 
-                     SO_TLS_SET_SERVER, 
-                     &sWS2Opts, 
-                     sizeof(struct tlsserveropts), 
-                     NULL, 
-                     0, 
-                     NULL, 
-                     NULL, 
+
+
+    rcode = WSAIoctl(socketHnd,
+                     SO_TLS_SET_SERVER,
+                     &sWS2Opts,
+                     sizeof(struct tlsserveropts),
+                     NULL,
+                     0,
+                     NULL,
+                     NULL,
                      NULL);
     if(SOCKET_ERROR == rcode) {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                      "Error: %d with WSAIoctl(SO_TLS_SET_SERVER)", WSAGetLastError());
         goto ERR;
     }
-    
+
 ERR:
     return rcode;
 }
 
-static const char *set_secure_listener(cmd_parms *cmd, void *dummy, 
-                                       const char *ips, const char* key, 
+static const char *set_secure_listener(cmd_parms *cmd, void *dummy,
+                                       const char *ips, const char* key,
                                        const char* mutual)
 {
     NWSSLSrvConfigRec* sc = get_nwssl_cfg(cmd->server);
@@ -459,27 +459,27 @@ static const char *set_secure_listener(cmd_parms *cmd, void *dummy,
     apr_sockaddr_t *sa;
     int found_listener = 0;
 
-    
-    if (err != NULL) 
+
+    if (err != NULL)
         return err;
 
     ports = strchr(ips, ':');
-    
-    if (ports != NULL) {    
+
+    if (ports != NULL) {
         if (ports == ips)
             return "Missing IP address";
         else if (ports[1] == '\0')
             return "Address must end in :<port-number>";
-            
+
         *(ports++) = '\0';
     }
     else {
         ports = (char*)ips;
     }
-    
-    new = apr_pcalloc(cmd->server->process->pool, sizeof(seclisten_rec)); 
+
+    new = apr_pcalloc(cmd->server->process->pool, sizeof(seclisten_rec));
     new->local_addr.sin_family = AF_INET;
-    
+
     if (ports == ips) {
         new->local_addr.sin_addr.s_addr = htonl(INADDR_ANY);
         addr = apr_pstrdup(cmd->server->process->pool, "0.0.0.0");
@@ -488,12 +488,12 @@ static const char *set_secure_listener(cmd_parms *cmd, void *dummy,
         new->local_addr.sin_addr.s_addr = parse_addr(ips, NULL);
         addr = apr_pstrdup(cmd->server->process->pool, ips);
     }
-    
+
     port = atoi(ports);
-    
-    if (!port) 
+
+    if (!port)
         return "Port must be numeric";
-        
+
     /* If the specified addr:port was created previously, put the listen
        socket record back on the ap_listeners list so that the socket
        will be reused rather than recreated */
@@ -529,7 +529,7 @@ static const char *set_secure_listener(cmd_parms *cmd, void *dummy,
     }
 
     apr_table_add(sc->sltable, ports, addr);
-    
+
     new->local_addr.sin_port = htons(port);
     new->fd = -1;
     new->used = 0;
@@ -542,7 +542,7 @@ static const char *set_secure_listener(cmd_parms *cmd, void *dummy,
     return NULL;
 }
 
-static const char *set_secure_upgradeable_listener(cmd_parms *cmd, void *dummy, 
+static const char *set_secure_upgradeable_listener(cmd_parms *cmd, void *dummy,
                                        const char *ips, const char* key)
 {
     NWSSLSrvConfigRec* sc = get_nwssl_cfg(cmd->server);
@@ -552,23 +552,23 @@ static const char *set_secure_upgradeable_listener(cmd_parms *cmd, void *dummy,
     unsigned short port;
     seclistenup_rec *new;
 
-    if (err != NULL) 
+    if (err != NULL)
         return err;
 
     ports = strchr(ips, ':');
-    
-    if (ports != NULL) {    
+
+    if (ports != NULL) {
         if (ports == ips)
             return "Missing IP address";
         else if (ports[1] == '\0')
             return "Address must end in :<port-number>";
-            
+
         *(ports++) = '\0';
     }
     else {
         ports = (char*)ips;
     }
-    
+
     if (ports == ips) {
         addr = apr_pstrdup(cmd->pool, "0.0.0.0");
     }
@@ -577,13 +577,13 @@ static const char *set_secure_upgradeable_listener(cmd_parms *cmd, void *dummy,
     }
 
     port = atoi(ports);
-    
-    if (!port) 
+
+    if (!port)
         return "Port must be numeric";
 
     apr_table_set(sc->slutable, ports, addr);
 
-    new = apr_pcalloc(cmd->pool, sizeof(seclistenup_rec)); 
+    new = apr_pcalloc(cmd->pool, sizeof(seclistenup_rec));
     new->next = ap_seclistenersup;
     strcpy(new->key, key);
     new->addr = addr;
@@ -632,8 +632,8 @@ static int nwssl_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
     seclisten_rec **secwalk;
     apr_sockaddr_t *sa;
     int found;
-    
-  /* Pull all of the listeners that were created by mod_nw_ssl out of the 
+
+  /* Pull all of the listeners that were created by mod_nw_ssl out of the
      ap_listeners list so that the normal listen socket processing does
      automatically close them */
     nw_old_listeners = NULL;
@@ -647,7 +647,7 @@ static int nwssl_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                 ap_listen_rec *new;
                 seclisten_rec *secnew;
                 apr_port_t oldport;
-    
+
                 oldport = sa->port;
                 /* If both ports are equivalent, then if their names are equivalent,
                  * then we will re-use the existing record.
@@ -670,7 +670,7 @@ static int nwssl_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                     break;
                 }
             }
-    
+
             walk = &(*walk)->next;
         }
         if (!found && &(*secwalk)->next) {
@@ -684,10 +684,10 @@ static int nwssl_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
     ap_seclistenersup = NULL;
     certlist = apr_array_make(pconf, 1, sizeof(char *));
 
-    /* Now that we have removed all of the mod_nw_ssl created socket records, 
+    /* Now that we have removed all of the mod_nw_ssl created socket records,
        allow the normal listen socket handling to occur.
        NOTE: If for any reason mod_nw_ssl is removed as a built-in module,
-       the following call must be put back into the pre-config handler of the 
+       the following call must be put back into the pre-config handler of the
        MPM.  It is only here to ensure that mod_nw_ssl fixes up the listen
        socket list before anything else looks at it. */
     ap_listen_pre_config();
@@ -697,7 +697,7 @@ static int nwssl_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
 
 static int nwssl_pre_connection(conn_rec *c, void *csd)
 {
-    
+
     if (apr_table_get(c->notes, "nwconv-ssl")) {
         convert_secure_socket(c, (apr_socket_t*)csd);
     }
@@ -708,7 +708,7 @@ static int nwssl_pre_connection(conn_rec *c, void *csd)
         csd_data->is_secure = 0;
         ap_set_module_config(c->conn_config, &nwssl_module, (void*)csd_data);
     }
-    
+
     return OK;
 }
 
@@ -770,8 +770,8 @@ static int nwssl_post_config(apr_pool_t *pconf, apr_pool_t *plog,
         }
 
         if (sl->fd < 0)
-            sl->fd = make_secure_socket(s->process->pool, &sl->local_addr, sl->key, sl->mutual, s);            
-            
+            sl->fd = make_secure_socket(s->process->pool, &sl->local_addr, sl->key, sl->mutual, s);
+
         if (sl->fd >= 0) {
             apr_os_sock_info_t sock_info;
 
@@ -784,10 +784,10 @@ static int nwssl_post_config(apr_pool_t *pconf, apr_pool_t *plog,
             apr_os_sock_make(&sd, &sock_info, s->process->pool);
 
             lr = apr_pcalloc(s->process->pool, sizeof(ap_listen_rec));
-        
+
             if (lr) {
                 lr->sd = sd;
-                if ((status = apr_sockaddr_info_get(&lr->bind_addr, sl->addr, APR_UNSPEC, sl->port, 0, 
+                if ((status = apr_sockaddr_info_get(&lr->bind_addr, sl->addr, APR_UNSPEC, sl->port, 0,
                                               s->process->pool)) != APR_SUCCESS) {
                     ap_log_perror(APLOG_MARK, APLOG_CRIT, status, pconf,
                                  "alloc_listener: failed to set up sockaddr for %s:%d", sl->addr, sl->port);
@@ -800,7 +800,7 @@ static int nwssl_post_config(apr_pool_t *pconf, apr_pool_t *plog,
         } else {
             return HTTP_INTERNAL_SERVER_ERROR;
         }
-    } 
+    }
 
     for (slu = ap_seclistenersup; slu; slu = slu->next) {
         /* Check the listener list for a matching upgradeable listener */
@@ -815,7 +815,7 @@ static int nwssl_post_config(apr_pool_t *pconf, apr_pool_t *plog,
             ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, plog,
                          "No Listen directive found for upgradeable listener %s:%d", slu->addr, slu->port);
         }
-    }    
+    }
 
     build_cert_list(s->process->pool);
 
@@ -842,8 +842,8 @@ static int compare_ipports(void *rec, const char *key, const char *value)
 {
     conn_rec *c = (conn_rec*)rec;
 
-    if (value && 
-        ((strcmp(value, "0.0.0.0") == 0) || (strcmp(value, c->local_ip) == 0))) 
+    if (value &&
+        ((strcmp(value, "0.0.0.0") == 0) || (strcmp(value, c->local_ip) == 0)))
     {
         return 0;
     }
@@ -998,7 +998,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
 
         case 'R':
         case 'r':
-            if (strcEQ(var, "REQUEST_METHOD")) 
+            if (strcEQ(var, "REQUEST_METHOD"))
                 result = r->method;
             else if (strcEQ(var, "REQUEST_SCHEME"))
                 result = ap_http_scheme(r);
@@ -1007,7 +1007,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
             else if (strcEQ(var, "REQUEST_FILENAME"))
                 result = r->filename;
             else if (strcEQ(var, "REMOTE_HOST"))
-                result = ap_get_remote_host(r->connection, r->per_dir_config, 
+                result = ap_get_remote_host(r->connection, r->per_dir_config,
                                             REMOTE_NAME, NULL);
             else if (strcEQ(var, "REMOTE_IDENT"))
                 result = ap_get_remote_logname(r);
@@ -1018,7 +1018,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
         case 'S':
         case 's':
             if (strcEQn(var, "SSL", 3)) break; /* shortcut common case */
-            
+
             if (strcEQ(var, "SERVER_ADMIN"))
                 result = r->server->server_admin;
             else if (strcEQ(var, "SERVER_NAME"))
@@ -1030,7 +1030,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
             else if (strcEQ(var, "SCRIPT_FILENAME"))
                 result = r->filename;
             break;
-            
+
         default:
             if (strcEQ(var, "PATH_INFO"))
                 result = r->path_info;
@@ -1055,7 +1055,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
 
                 /* XXX-Can't get specific SSL info from NetWare */
         /* SSLConnRec *sslconn = myConnConfig(c);
-        if (strlen(var) > 4 && strcEQn(var, "SSL_", 4) 
+        if (strlen(var) > 4 && strcEQn(var, "SSL_", 4)
             && sslconn && sslconn->ssl)
             result = ssl_var_lookup_ssl(p, c, var+4);*/
 
@@ -1196,7 +1196,7 @@ static apr_status_t ssl_io_filter_Upgrade(ap_filter_t *f,
     }
 
     key = get_port_key(r->connection);
-    
+
     if (csd && key) {
         int sockdes;
         apr_os_sock_get(&sockdes, csd);
@@ -1216,8 +1216,8 @@ static apr_status_t ssl_io_filter_Upgrade(ap_filter_t *f,
     ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                  "Awaiting re-negotiation handshake");
 
-    /* Now that we have initialized the ssl connection which added the ssl_io_filter, 
-       pass the brigade off to the connection based output filters so that the 
+    /* Now that we have initialized the ssl connection which added the ssl_io_filter,
+       pass the brigade off to the connection based output filters so that the
        request can complete encrypted */
     return ap_pass_brigade(f->c->output_filters, bb);
 }
@@ -1258,7 +1258,7 @@ static void register_hooks(apr_pool_t *p)
 
     APR_REGISTER_OPTIONAL_FN(ssl_is_https);
     APR_REGISTER_OPTIONAL_FN(ssl_var_lookup);
-    
+
     APR_REGISTER_OPTIONAL_FN(ssl_proxy_enable);
     APR_REGISTER_OPTIONAL_FN(ssl_engine_disable);
 }
diff --git a/modules/arch/win32/mod_isapi.c b/modules/arch/win32/mod_isapi.c
index b7e061a..bf99360 100644
--- a/modules/arch/win32/mod_isapi.c
+++ b/modules/arch/win32/mod_isapi.c
@@ -20,19 +20,19 @@
  * redesign by William Rowe <wrowe@covalent.net>, and hints from many
  * other developer/users who have hit on specific flaws.
  *
- * This module implements the ISAPI Handler architecture, allowing 
+ * This module implements the ISAPI Handler architecture, allowing
  * Apache to load Internet Server Applications (ISAPI extensions),
  * similar to the support in IIS, Zope, O'Reilly's WebSite and others.
  *
- * It is a complete implementation of the ISAPI 2.0 specification, 
- * except for "Microsoft extensions" to the API which provide 
+ * It is a complete implementation of the ISAPI 2.0 specification,
+ * except for "Microsoft extensions" to the API which provide
  * asynchronous I/O.  It is further extended to include additional
  * "Microsoft extentions" through IIS 5.0, with some deficiencies
  * where one-to-one mappings don't exist.
  *
  * Refer to /manual/mod/mod_isapi.html for additional details on
  * configuration and use, but check this source for specific support
- * of the API, 
+ * of the API,
  */
 
 #include "ap_config.h"
@@ -77,13 +77,13 @@ typedef struct isapi_dir_conf {
 
 typedef struct isapi_loaded isapi_loaded;
 
-apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r, 
+apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r,
                           const char *fpath, isapi_loaded** isa);
 
 static void *create_isapi_dir_config(apr_pool_t *p, char *dummy)
 {
     isapi_dir_conf *dir = apr_palloc(p, sizeof(isapi_dir_conf));
-    
+
     dir->read_ahead_buflen = ISAPI_UNDEF;
     dir->log_unsupported   = ISAPI_UNDEF;
     dir->log_to_errlog     = ISAPI_UNDEF;
@@ -98,7 +98,7 @@ static void *merge_isapi_dir_configs(apr_pool_t *p, void *base_, void *add_)
     isapi_dir_conf *base = (isapi_dir_conf *) base_;
     isapi_dir_conf *add = (isapi_dir_conf *) add_;
     isapi_dir_conf *dir = apr_palloc(p, sizeof(isapi_dir_conf));
-    
+
     dir->read_ahead_buflen = (add->read_ahead_buflen == ISAPI_UNDEF)
                                 ? base->read_ahead_buflen
                                  : add->read_ahead_buflen;
@@ -114,11 +114,11 @@ static void *merge_isapi_dir_configs(apr_pool_t *p, void *base_, void *add_)
     dir->fake_async        = (add->fake_async == ISAPI_UNDEF)
                                 ? base->fake_async
                                  : add->fake_async;
-    
+
     return dir;
 }
 
-static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy, 
+static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
                                        const char *filename)
 {
     isapi_loaded *isa;
@@ -140,8 +140,8 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
                      "ISAPI: invalid module path, skipping %s", filename);
         return NULL;
     }
-    if ((rv = apr_stat(&tmp, fspec, APR_FINFO_TYPE, 
-                      cmd->temp_pool)) != APR_SUCCESS) { 
+    if ((rv = apr_stat(&tmp, fspec, APR_FINFO_TYPE,
+                      cmd->temp_pool)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_WARNING, rv, cmd->server,
             "ISAPI: unable to stat, skipping %s", fspec);
         return NULL;
@@ -153,7 +153,7 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
     }
 
     /* Load the extention as cached (with null request_rec) */
-    rv = isapi_lookup(cmd->pool, cmd->server, NULL, fspec, &isa); 
+    rv = isapi_lookup(cmd->pool, cmd->server, NULL, fspec, &isa);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_WARNING, rv, cmd->server,
                      "ISAPI: unable to cache, skipping %s", fspec);
@@ -165,26 +165,26 @@ static const char *isapi_cmd_cachefile(cmd_parms *cmd, void *dummy,
 
 static const command_rec isapi_cmds[] = {
     AP_INIT_TAKE1("ISAPIReadAheadBuffer", ap_set_int_slot,
-        (void *)APR_OFFSETOF(isapi_dir_conf, read_ahead_buflen), 
+        (void *)APR_OFFSETOF(isapi_dir_conf, read_ahead_buflen),
         OR_FILEINFO, "Maximum client request body to initially pass to the"
                      " ISAPI handler (default: 49152)"),
     AP_INIT_FLAG("ISAPILogNotSupported", ap_set_flag_slot,
-        (void *)APR_OFFSETOF(isapi_dir_conf, log_unsupported), 
+        (void *)APR_OFFSETOF(isapi_dir_conf, log_unsupported),
         OR_FILEINFO, "Log requests not supported by the ISAPI server"
                      " on or off (default: off)"),
     AP_INIT_FLAG("ISAPIAppendLogToErrors", ap_set_flag_slot,
-        (void *)APR_OFFSETOF(isapi_dir_conf, log_to_errlog), 
+        (void *)APR_OFFSETOF(isapi_dir_conf, log_to_errlog),
         OR_FILEINFO, "Send all Append Log requests to the error log"
                      " on or off (default: off)"),
     AP_INIT_FLAG("ISAPIAppendLogToQuery", ap_set_flag_slot,
-        (void *)APR_OFFSETOF(isapi_dir_conf, log_to_query), 
+        (void *)APR_OFFSETOF(isapi_dir_conf, log_to_query),
         OR_FILEINFO, "Append Log requests are concatinated to the query args"
                      " on or off (default: on)"),
     AP_INIT_FLAG("ISAPIFakeAsync", ap_set_flag_slot,
-        (void *)APR_OFFSETOF(isapi_dir_conf, fake_async), 
+        (void *)APR_OFFSETOF(isapi_dir_conf, fake_async),
         OR_FILEINFO, "Fake Asynchronous support for isapi callbacks"
                      " on or off [Experimental] (default: off)"),
-    AP_INIT_ITERATE("ISAPICacheFile", isapi_cmd_cachefile, NULL, 
+    AP_INIT_ITERATE("ISAPICacheFile", isapi_cmd_cachefile, NULL,
         RSRC_CONF, "Cache the specified ISAPI extension in-process"),
     {NULL}
 };
@@ -222,7 +222,7 @@ static apr_status_t isapi_unload(isapi_loaded *isa, int force)
     /* All done with the DLL... get rid of it...
      *
      * If optionally cached, and we weren't asked to force the unload,
-     * pass HSE_TERM_ADVISORY_UNLOAD, and if it returns 1, unload, 
+     * pass HSE_TERM_ADVISORY_UNLOAD, and if it returns 1, unload,
      * otherwise, leave it alone (it didn't choose to cooperate.)
      */
     if (!isa->handle) {
@@ -245,7 +245,7 @@ static apr_status_t cleanup_isapi(void *isa_)
 {
     isapi_loaded* isa = (isapi_loaded*) isa_;
 
-    /* We must force the module to unload, we are about 
+    /* We must force the module to unload, we are about
      * to lose the isapi structure's allocation entirely.
      */
     return isapi_unload(isa, 1);
@@ -261,13 +261,13 @@ static apr_status_t isapi_load(apr_pool_t *p, server_rec *s, isapi_loaded *isa)
      * assure a given isapi can be fooled into behaving well.
      *
      * The tricky bit, they aren't really a per-dir sort of
-     * config, they will always be constant across every 
+     * config, they will always be constant across every
      * reference to the .dll no matter what context (vhost,
      * location, etc) they apply to.
      */
     isa->report_version = MAKELONG(0, 5); /* Revision 5.0 */
     isa->timeout = 300 * 1000000; /* microsecs, not used */
-    
+
     rv = apr_dso_load(&isa->handle, isa->filename, p);
     if (rv)
     {
@@ -310,20 +310,20 @@ static apr_status_t isapi_load(apr_pool_t *p, server_rec *s, isapi_loaded *isa)
     if (!(isa->GetExtensionVersion)(isa->isapi_version)) {
         apr_status_t rv = apr_get_os_error();
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
-                     "ISAPI: failed call to GetExtensionVersion() in %s", 
+                     "ISAPI: failed call to GetExtensionVersion() in %s",
                      isa->filename);
         apr_dso_unload(isa->handle);
         isa->handle = NULL;
         return rv;
     }
 
-    apr_pool_cleanup_register(p, isa, cleanup_isapi, 
+    apr_pool_cleanup_register(p, isa, cleanup_isapi,
                               apr_pool_cleanup_null);
 
     return APR_SUCCESS;
 }
 
-apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r, 
+apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r,
                           const char *fpath, isapi_loaded** isa)
 {
     apr_status_t rv;
@@ -338,7 +338,7 @@ apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r,
     if (*isa) {
 
         /* If we find this lock exists, use a set-aside copy of gainlock
-         * to avoid race conditions on NULLing the in_progress variable 
+         * to avoid race conditions on NULLing the in_progress variable
          * when the load has completed.  Release the global isapi hash
          * lock so other requests can proceed, then rdlock for completion
          * of loading our desired dll or wrlock if we would like to retry
@@ -355,10 +355,10 @@ apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r,
             return rv;
         }
 
-            
+
         if ((*isa)->last_load_rv == APR_SUCCESS) {
             apr_thread_mutex_unlock(loaded.lock);
-            if ((rv = apr_thread_rwlock_rdlock(gainlock)) 
+            if ((rv = apr_thread_rwlock_rdlock(gainlock))
                     != APR_SUCCESS) {
                 return rv;
             }
@@ -368,7 +368,7 @@ apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r,
         }
 
         if (apr_time_now() > (*isa)->last_load_time + ISAPI_RETRY) {
-        
+
             /* Remember last_load_time before releasing the global
              * hash lock to avoid colliding with another thread
              * that hit this exception at the same time as our
@@ -378,13 +378,13 @@ apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r,
             apr_time_t check_time = (*isa)->last_load_time;
             apr_thread_mutex_unlock(loaded.lock);
 
-            if ((rv = apr_thread_rwlock_wrlock(gainlock)) 
+            if ((rv = apr_thread_rwlock_wrlock(gainlock))
                     != APR_SUCCESS) {
                 return rv;
             }
 
             /* If last_load_time is unchanged, we still own this
-             * retry, otherwise presume another thread provided 
+             * retry, otherwise presume another thread provided
              * our retry (for good or ill).  Relock the global
              * hash for updating last_load_ vars, so their update
              * is always atomic to the global lock.
@@ -416,7 +416,7 @@ apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r,
     }
 
     /* If the module was not found, it's time to create a hash key entry
-     * before releasing the hash lock to avoid multiple threads from 
+     * before releasing the hash lock to avoid multiple threads from
      * loading the same module.
      */
     key = apr_pstrdup(loaded.pool, fpath);
@@ -437,8 +437,8 @@ apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r,
     }
 
     apr_hash_set(loaded.hash, key, APR_HASH_KEY_STRING, *isa);
-    
-    /* Now attempt to load the isapi on our own time, 
+
+    /* Now attempt to load the isapi on our own time,
      * allow other isapi processing to resume.
      */
     apr_thread_mutex_unlock(loaded.lock);
@@ -457,7 +457,7 @@ apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r,
     }
     else if (!r && (rv != APR_SUCCESS)) {
         /* We must leave a rwlock around for requests to retry
-         * loading this dll after timeup... since we were in 
+         * loading this dll after timeup... since we were in
          * the setup code we had avoided creating this lock.
          */
         apr_thread_rwlock_create(&(*isa)->in_progress, loaded.pool);
@@ -485,19 +485,19 @@ struct isapi_cid {
     apr_thread_mutex_t      *completed;
 };
 
-int APR_THREAD_FUNC GetServerVariable (isapi_cid    *cid, 
+int APR_THREAD_FUNC GetServerVariable (isapi_cid    *cid,
                                        char         *variable_name,
-                                       void         *buf_data, 
+                                       void         *buf_data,
                                        apr_uint32_t *buf_size)
 {
     request_rec *r = cid->r;
     const char *result;
     apr_uint32_t len;
 
-    if (!strcmp(variable_name, "ALL_HTTP")) 
+    if (!strcmp(variable_name, "ALL_HTTP"))
     {
-        /* crlf delimited, colon split, comma separated and 
-         * null terminated list of HTTP_ vars 
+        /* crlf delimited, colon split, comma separated and
+         * null terminated list of HTTP_ vars
          */
         const apr_array_header_t *arr = apr_table_elts(r->subprocess_env);
         const apr_table_entry_t *elts = (const apr_table_entry_t *)arr->elts;
@@ -508,13 +508,13 @@ int APR_THREAD_FUNC GetServerVariable (isapi_cid    *cid,
                 len += strlen(elts[i].key) + strlen(elts[i].val) + 3;
             }
         }
-  
+
         if (*buf_size < len + 1) {
             *buf_size = len + 1;
             SetLastError(ERROR_INSUFFICIENT_BUFFER);
             return 0;
         }
-    
+
         for (i = 0; i < arr->nelts; i++) {
             if (!strncmp(elts[i].key, "HTTP_", 5)) {
                 strcpy(buf_data, elts[i].key);
@@ -531,10 +531,10 @@ int APR_THREAD_FUNC GetServerVariable (isapi_cid    *cid,
         *buf_size = len + 1;
         return 1;
     }
-    
-    if (!strcmp(variable_name, "ALL_RAW")) 
+
+    if (!strcmp(variable_name, "ALL_RAW"))
     {
-        /* crlf delimited, colon split, comma separated and 
+        /* crlf delimited, colon split, comma separated and
          * null terminated list of the raw request header
          */
         const apr_array_header_t *arr = apr_table_elts(r->headers_in);
@@ -544,13 +544,13 @@ int APR_THREAD_FUNC GetServerVariable (isapi_cid    *cid,
         for (len = 0, i = 0; i < arr->nelts; i++) {
             len += strlen(elts[i].key) + strlen(elts[i].val) + 4;
         }
-  
+
         if (*buf_size < len + 1) {
             *buf_size = len + 1;
             SetLastError(ERROR_INSUFFICIENT_BUFFER);
             return 0;
         }
-    
+
         for (i = 0; i < arr->nelts; i++) {
             strcpy(buf_data, elts[i].key);
             ((char*)buf_data) += strlen(elts[i].key);
@@ -565,7 +565,7 @@ int APR_THREAD_FUNC GetServerVariable (isapi_cid    *cid,
         *buf_size = len + 1;
         return 1;
     }
-    
+
     /* Not a special case */
     result = apr_table_get(r->subprocess_env, variable_name);
 
@@ -586,8 +586,8 @@ int APR_THREAD_FUNC GetServerVariable (isapi_cid    *cid,
     return 0;
 }
 
-int APR_THREAD_FUNC ReadClient(isapi_cid    *cid, 
-                               void         *buf_data, 
+int APR_THREAD_FUNC ReadClient(isapi_cid    *cid,
+                               void         *buf_data,
                                apr_uint32_t *buf_size)
 {
     request_rec *r = cid->r;
@@ -611,7 +611,7 @@ int APR_THREAD_FUNC ReadClient(isapi_cid    *cid,
     return (res >= 0);
 }
 
-/* Common code invoked for both HSE_REQ_SEND_RESPONSE_HEADER and 
+/* Common code invoked for both HSE_REQ_SEND_RESPONSE_HEADER and
  * the newer HSE_REQ_SEND_RESPONSE_HEADER_EX ServerSupportFunction(s)
  * as well as other functions that write responses and presume that
  * the support functions above are optional.
@@ -621,9 +621,9 @@ int APR_THREAD_FUNC ReadClient(isapi_cid    *cid,
  * get a proper count of bytes consumed.  The argument passed to stat
  * isn't counted as the head bytes are.
  */
-static apr_ssize_t send_response_header(isapi_cid *cid, 
+static apr_ssize_t send_response_header(isapi_cid *cid,
                                         const char *stat,
-                                        const char *head, 
+                                        const char *head,
                                         apr_size_t statlen,
                                         apr_size_t headlen)
 {
@@ -675,8 +675,8 @@ static apr_ssize_t send_response_header(isapi_cid *cid,
             while (toklen && apr_isspace(*stattok)) {
                 ++stattok; --toklen;
             }
-            /* Now decide if we follow the xxx message 
-             * or the http/x.x xxx message format 
+            /* Now decide if we follow the xxx message
+             * or the http/x.x xxx message format
              */
             if (toklen && apr_isdigit(*stattok)) {
                 statlen -= toklen;
@@ -701,27 +701,27 @@ static apr_ssize_t send_response_header(isapi_cid *cid,
             head = apr_pstrndup(cid->r->pool, head, headlen);
         }
     }
- 
-    /* Seems IIS does not enforce the requirement for \r\n termination 
-     * on HSE_REQ_SEND_RESPONSE_HEADER, but we won't panic... 
+
+    /* Seems IIS does not enforce the requirement for \r\n termination
+     * on HSE_REQ_SEND_RESPONSE_HEADER, but we won't panic...
      * ap_scan_script_header_err_strs handles this aspect for us.
      *
-     * Parse them out, or die trying 
+     * Parse them out, or die trying
      */
     if (stat) {
-        cid->r->status = ap_scan_script_header_err_strs(cid->r, NULL, 
+        cid->r->status = ap_scan_script_header_err_strs(cid->r, NULL,
                                         &termch, &termarg, stat, head, NULL);
         cid->ecb->dwHttpStatusCode = cid->r->status;
     }
     else {
-        cid->r->status = ap_scan_script_header_err_strs(cid->r, NULL, 
+        cid->r->status = ap_scan_script_header_err_strs(cid->r, NULL,
                                         &termch, &termarg, head, NULL);
         if (cid->ecb->dwHttpStatusCode && cid->r->status == HTTP_OK
                 && cid->ecb->dwHttpStatusCode != HTTP_OK) {
             /* We tried every way to Sunday to get the status...
              * so now we fall back on dwHttpStatusCode if it appears
              * ap_scan_script_header fell back on the default code.
-             * Any other results set dwHttpStatusCode to the decoded 
+             * Any other results set dwHttpStatusCode to the decoded
              * status value.
              */
             cid->r->status = cid->ecb->dwHttpStatusCode;
@@ -735,14 +735,14 @@ static apr_ssize_t send_response_header(isapi_cid *cid,
         return -1;
     }
 
-    /* If only Status was passed, we consumed nothing 
+    /* If only Status was passed, we consumed nothing
      */
     if (!head_present)
         return 0;
 
     cid->headers_set = 1;
 
-    /* If all went well, tell the caller we consumed the headers complete 
+    /* If all went well, tell the caller we consumed the headers complete
      */
     if (!termch)
         return(ate + headlen);
@@ -759,9 +759,9 @@ static apr_ssize_t send_response_header(isapi_cid *cid,
     return ate;
 }
 
-int APR_THREAD_FUNC WriteClient(isapi_cid    *cid, 
-                                void         *buf_data, 
-                                apr_uint32_t *size_arg, 
+int APR_THREAD_FUNC WriteClient(isapi_cid    *cid,
+                                void         *buf_data,
+                                apr_uint32_t *size_arg,
                                 apr_uint32_t  flags)
 {
     request_rec *r = cid->r;
@@ -800,20 +800,20 @@ int APR_THREAD_FUNC WriteClient(isapi_cid    *cid,
 
     if ((flags & HSE_IO_ASYNC) && cid->completion) {
         if (rv == OK) {
-            cid->completion(cid->ecb, cid->completion_arg, 
+            cid->completion(cid->ecb, cid->completion_arg,
                             *size_arg, ERROR_SUCCESS);
         }
         else {
-            cid->completion(cid->ecb, cid->completion_arg, 
+            cid->completion(cid->ecb, cid->completion_arg,
                             *size_arg, ERROR_WRITE_FAULT);
         }
     }
     return (rv == OK);
 }
 
-int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid, 
+int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
                                           apr_uint32_t  HSE_code,
-                                          void         *buf_data, 
+                                          void         *buf_data,
                                           apr_uint32_t *buf_size,
                                           apr_uint32_t *data_type)
 {
@@ -874,7 +874,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
             apr_bucket_brigade *bb;
             apr_bucket *b;
             bb = apr_brigade_create(cid->r->pool, c->bucket_alloc);
-            b = apr_bucket_transient_create((char*) data_type + ate, 
+            b = apr_bucket_transient_create((char*) data_type + ate,
                                            headlen - ate, c->bucket_alloc);
             APR_BRIGADE_INSERT_TAIL(bb, b);
             b = apr_bucket_flush_create(c->bucket_alloc);
@@ -931,7 +931,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
                            "is not supported: %s", r->filename);
         SetLastError(ERROR_INVALID_PARAMETER);
         return 0;
-        
+
     case HSE_APPEND_LOG_PARAMETER:
         /* Log buf_data, of buf_size bytes, in the URI Query (cs-uri-query) field
          */
@@ -947,10 +947,10 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
                           "ISAPI: %s: %s", cid->r->filename,
                           (char*) buf_data);
         return 1;
-        
+
     case HSE_REQ_IO_COMPLETION:
-        /* Emulates a completion port...  Record callback address and 
-         * user defined arg, we will call this after any async request 
+        /* Emulates a completion port...  Record callback address and
+         * user defined arg, we will call this after any async request
          * (e.g. transmitfile) as if the request executed async.
          * Per MS docs... HSE_REQ_IO_COMPLETION replaces any prior call
          * to HSE_REQ_IO_COMPLETION, and buf_data may be set to NULL.
@@ -988,12 +988,12 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
             SetLastError(ERROR_INVALID_PARAMETER);
             return 0;
         }
-        
+
         /* Presume the handle was opened with the CORRECT semantics
-         * for TransmitFile 
+         * for TransmitFile
          */
-        if ((rv = apr_os_file_put(&fd, &tf->hFile, 
-                                  APR_READ | APR_XTHREAD, r->pool)) 
+        if ((rv = apr_os_file_put(&fd, &tf->hFile,
+                                  APR_READ | APR_XTHREAD, r->pool))
                 != APR_SUCCESS) {
             return 0;
         }
@@ -1008,7 +1008,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
             }
             fsize = fi.size - tf->Offset;
         }
-        
+
         /* apr_dupfile_oshandle (&fd, tf->hFile, r->pool); */
         bb = apr_brigade_create(r->pool, c->bucket_alloc);
 
@@ -1022,12 +1022,12 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
          * (handled after this case).
          */
         if ((tf->dwFlags & HSE_IO_SEND_HEADERS) && tf->pszStatusCode) {
-            ate = send_response_header(cid, tf->pszStatusCode,  
+            ate = send_response_header(cid, tf->pszStatusCode,
                                             (char*)tf->pHead,
                                             strlen(tf->pszStatusCode),
                                             tf->HeadLength);
         }
-        else if (!cid->headers_set && tf->pHead && tf->HeadLength 
+        else if (!cid->headers_set && tf->pHead && tf->HeadLength
                                    && *(char*)tf->pHead) {
             ate = send_response_header(cid, NULL, (char*)tf->pHead,
                                             0, tf->HeadLength);
@@ -1040,7 +1040,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
         }
 
         if (tf->pHead && (apr_size_t)ate < tf->HeadLength) {
-            b = apr_bucket_transient_create((char*)tf->pHead + ate, 
+            b = apr_bucket_transient_create((char*)tf->pHead + ate,
                                             tf->HeadLength - ate,
                                             c->bucket_alloc);
             APR_BRIGADE_INSERT_TAIL(bb, b);
@@ -1054,7 +1054,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
              * no greater than MAX(apr_size_t), and more granular than that
              * in case the brigade code/filters attempt to read it directly.
              */
-            b = apr_bucket_file_create(fd, tf->Offset, AP_MAX_SENDFILE, 
+            b = apr_bucket_file_create(fd, tf->Offset, AP_MAX_SENDFILE,
                                        r->pool, c->bucket_alloc);
             while (fsize > AP_MAX_SENDFILE) {
                 apr_bucket *bc;
@@ -1067,17 +1067,17 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
         }
         else
 #endif
-            b = apr_bucket_file_create(fd, tf->Offset, (apr_size_t)fsize, 
+            b = apr_bucket_file_create(fd, tf->Offset, (apr_size_t)fsize,
                                        r->pool, c->bucket_alloc);
         APR_BRIGADE_INSERT_TAIL(bb, b);
-        
+
         if (tf->pTail && tf->TailLength) {
             sent += tf->TailLength;
-            b = apr_bucket_transient_create((char*)tf->pTail, 
+            b = apr_bucket_transient_create((char*)tf->pTail,
                                             tf->TailLength, c->bucket_alloc);
             APR_BRIGADE_INSERT_TAIL(bb, b);
         }
-        
+
         b = apr_bucket_flush_create(c->bucket_alloc);
         APR_BRIGADE_INSERT_TAIL(bb, b);
         ap_pass_brigade(r->output_filters, bb);
@@ -1089,21 +1089,21 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
         if (tf->dwFlags & HSE_IO_ASYNC) {
             if (tf->pfnHseIO) {
                 if (rv == OK) {
-                    tf->pfnHseIO(cid->ecb, tf->pContext, 
+                    tf->pfnHseIO(cid->ecb, tf->pContext,
                                  ERROR_SUCCESS, sent);
                 }
                 else {
-                    tf->pfnHseIO(cid->ecb, tf->pContext, 
+                    tf->pfnHseIO(cid->ecb, tf->pContext,
                                  ERROR_WRITE_FAULT, sent);
                 }
             }
             else if (cid->completion) {
                 if (rv == OK) {
-                    cid->completion(cid->ecb, cid->completion_arg, 
+                    cid->completion(cid->ecb, cid->completion_arg,
                                     sent, ERROR_SUCCESS);
                 }
                 else {
-                    cid->completion(cid->ecb, cid->completion_arg, 
+                    cid->completion(cid->ecb, cid->completion_arg,
                                     sent, ERROR_WRITE_FAULT);
                 }
             }
@@ -1129,9 +1129,9 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
         apr_uint32_t read = 0;
         int res;
         if (!cid->dconf.fake_async) {
-            if (cid->dconf.log_unsupported) 
+            if (cid->dconf.log_unsupported)
                 ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
-                            "ISAPI: asynchronous I/O not supported: %s", 
+                            "ISAPI: asynchronous I/O not supported: %s",
                             r->filename);
             SetLastError(ERROR_INVALID_PARAMETER);
             return 0;
@@ -1149,11 +1149,11 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
 
         if ((*data_type & HSE_IO_ASYNC) && cid->completion) {
             if (res >= 0) {
-                cid->completion(cid->ecb, cid->completion_arg, 
+                cid->completion(cid->ecb, cid->completion_arg,
                                 read, ERROR_SUCCESS);
             }
             else {
-                cid->completion(cid->ecb, cid->completion_arg, 
+                cid->completion(cid->ecb, cid->completion_arg,
                                 read, ERROR_READ_FAULT);
             }
         }
@@ -1176,8 +1176,8 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
         char* test_uri = apr_pstrndup(r->pool, (char *)buf_data, *buf_size);
 
         subreq = ap_sub_req_lookup_uri(test_uri, r, NULL);
-        info->cchMatchingURL = strlen(test_uri);        
-        info->cchMatchingPath = apr_cpystrn(info->lpszPath, subreq->filename, 
+        info->cchMatchingURL = strlen(test_uri);
+        info->cchMatchingPath = apr_cpystrn(info->lpszPath, subreq->filename,
                                       sizeof(info->lpszPath)) - info->lpszPath;
 
         /* Mapping started with assuming both strings matched.
@@ -1185,8 +1185,8 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
          * terminating slashes for directory matches.
          */
         if (subreq->path_info && *subreq->path_info) {
-            apr_cpystrn(info->lpszPath + info->cchMatchingPath, 
-                        subreq->path_info, 
+            apr_cpystrn(info->lpszPath + info->cchMatchingPath,
+                        subreq->path_info,
                         sizeof(info->lpszPath) - info->cchMatchingPath);
             info->cchMatchingURL -= strlen(subreq->path_info);
             if (subreq->finfo.filetype == APR_DIR
@@ -1206,18 +1206,18 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
         /* If the matched isn't a file, roll match back to the prior slash */
         if (subreq->finfo.filetype == APR_NOFILE) {
             while (info->cchMatchingPath && info->cchMatchingURL) {
-                if (info->lpszPath[info->cchMatchingPath - 1] == '/') 
+                if (info->lpszPath[info->cchMatchingPath - 1] == '/')
                     break;
                 --info->cchMatchingPath;
                 --info->cchMatchingURL;
             }
         }
-        
+
         /* Paths returned with back slashes */
         for (test_uri = info->lpszPath; *test_uri; ++test_uri)
             if (*test_uri == '/')
                 *test_uri = '\\';
-        
+
         /* is a combination of:
          * HSE_URL_FLAGS_READ         0x001 Allow read
          * HSE_URL_FLAGS_WRITE        0x002 Allow write
@@ -1232,7 +1232,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
          *
          * XxX: As everywhere, EXEC flags could use some work...
          *      and this could go further with more flags, as desired.
-         */ 
+         */
         info->dwFlags = (subreq->finfo.protection & APR_UREAD    ? 0x001 : 0)
                       | (subreq->finfo.protection & APR_UWRITE   ? 0x002 : 0)
                       | (subreq->finfo.protection & APR_UEXECUTE ? 0x204 : 0);
@@ -1252,7 +1252,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
             ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                           "ISAPI: ServerSupportFunction "
                           "HSE_REQ_GET_CERT_INFO_EX "
-                          "is not supported: %s", r->filename);        
+                          "is not supported: %s", r->filename);
         SetLastError(ERROR_INVALID_PARAMETER);
         return 0;
 
@@ -1262,9 +1262,9 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
 
         /*  Ignore shi->fKeepConn - we don't want the advise
          */
-        apr_ssize_t ate = send_response_header(cid, shi->pszStatus, 
+        apr_ssize_t ate = send_response_header(cid, shi->pszStatus,
                                                shi->pszHeader,
-                                               shi->cchStatus, 
+                                               shi->cchStatus,
                                                shi->cchHeader);
         if (ate < 0) {
             SetLastError(ERROR_INVALID_PARAMETER);
@@ -1274,7 +1274,7 @@ int APR_THREAD_FUNC ServerSupportFunction(isapi_cid    *cid,
             apr_bucket_brigade *bb;
             apr_bucket *b;
             bb = apr_brigade_create(cid->r->pool, c->bucket_alloc);
-            b = apr_bucket_transient_create(shi->pszHeader + ate, 
+            b = apr_bucket_transient_create(shi->pszHeader + ate,
                                             shi->cchHeader - ate,
                                             c->bucket_alloc);
             APR_BRIGADE_INSERT_TAIL(bb, b);
@@ -1339,14 +1339,14 @@ apr_status_t isapi_handler (request_rec *r)
     const char *val;
     apr_uint32_t read;
     int res;
-    
-    if(strcmp(r->handler, "isapi-isa") 
+
+    if(strcmp(r->handler, "isapi-isa")
         && strcmp(r->handler, "isapi-handler")) {
         /* Hang on to the isapi-isa for compatibility with older docs
          * (wtf did '-isa' mean in the first place?) but introduce
          * a newer and clearer "isapi-handler" name.
          */
-        return DECLINED;    
+        return DECLINED;
     }
     dconf = ap_get_module_config(r->per_dir_config, &isapi_module);
     e = r->subprocess_env;
@@ -1370,7 +1370,7 @@ apr_status_t isapi_handler (request_rec *r)
         return HTTP_NOT_FOUND;
     }
 
-    if (isapi_lookup(r->pool, r->server, r, r->filename, &isa) 
+    if (isapi_lookup(r->pool, r->server, r, r->filename, &isa)
            != APR_SUCCESS) {
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -1388,7 +1388,7 @@ apr_status_t isapi_handler (request_rec *r)
      * NULL or zero out most fields.
      */
     cid = apr_pcalloc(r->pool, sizeof(isapi_cid));
-    
+
     /* Fixup defaults for dconf */
     cid->dconf.read_ahead_buflen = (dconf->read_ahead_buflen == ISAPI_UNDEF)
                                      ? 49152 : dconf->read_ahead_buflen;
@@ -1406,7 +1406,7 @@ apr_status_t isapi_handler (request_rec *r)
     cid->isa = isa;
     cid->r = r;
     r->status = 0;
-    
+
     cid->ecb->cbSize = sizeof(EXTENSION_CONTROL_BLOCK);
     cid->ecb->dwVersion = isa->report_version;
     cid->ecb->dwHttpStatusCode = 0;
@@ -1418,7 +1418,7 @@ apr_status_t isapi_handler (request_rec *r)
     cid->ecb->lpszPathInfo = (char*) apr_table_get(e, "PATH_INFO");
     cid->ecb->lpszPathTranslated = (char*) apr_table_get(e, "PATH_TRANSLATED");
     cid->ecb->lpszContentType = (char*) apr_table_get(e, "CONTENT_TYPE");
-    
+
     /* Set up the callbacks */
     cid->ecb->GetServerVariable = GetServerVariable;
     cid->ecb->WriteClient = WriteClient;
@@ -1491,8 +1491,8 @@ apr_status_t isapi_handler (request_rec *r)
      * unlocked the mutex.
      */
     if (cid->dconf.fake_async) {
-        rv = apr_thread_mutex_create(&cid->completed, 
-                                     APR_THREAD_MUTEX_UNNESTED, 
+        rv = apr_thread_mutex_create(&cid->completed,
+                                     APR_THREAD_MUTEX_UNNESTED,
                                      r->pool);
         if (cid->completed && (rv == APR_SUCCESS)) {
             rv = apr_thread_mutex_lock(cid->completed);
@@ -1549,14 +1549,14 @@ apr_status_t isapi_handler (request_rec *r)
             }
             break;
 
-        case HSE_STATUS_ERROR:    
+        case HSE_STATUS_ERROR:
             /* end response if we have yet to do so.
              */
             r->status = HTTP_INTERNAL_SERVER_ERROR;
             break;
 
         default:
-            /* TODO: log unrecognized retval for debugging 
+            /* TODO: log unrecognized retval for debugging
              */
              ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                            "ISAPI: return code %d from HttpExtensionProc() "
@@ -1582,7 +1582,7 @@ apr_status_t isapi_handler (request_rec *r)
 
         return OK;  /* NOT r->status or cid->r->status, even if it has changed. */
     }
-    
+
     /* As the client returned no error, and if we did not error out
      * ourselves, trust dwHttpStatusCode to say something relevant.
      */
@@ -1612,7 +1612,7 @@ static int isapi_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pte
                      "ISAPI: could not create the isapi cache pool");
         return APR_EGENERAL;
     }
-    
+
     loaded.hash = apr_hash_make(loaded.pool);
     if (!loaded.hash) {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
@@ -1620,7 +1620,7 @@ static int isapi_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pte
         return APR_EGENERAL;
     }
 
-    rv = apr_thread_mutex_create(&loaded.lock, APR_THREAD_MUTEX_DEFAULT, 
+    rv = apr_thread_mutex_create(&loaded.lock, APR_THREAD_MUTEX_DEFAULT,
                                  loaded.pool);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, rv, 0, NULL,
diff --git a/modules/arch/win32/mod_win32.c b/modules/arch/win32/mod_win32.c
index e313ad9..a57397d 100644
--- a/modules/arch/win32/mod_win32.c
+++ b/modules/arch/win32/mod_win32.c
@@ -35,15 +35,15 @@
 extern OSVERSIONINFO osver; /* hiding in mpm_winnt.c */
 static int win_nt;
 
-/* 
+/*
  * CGI Script stuff for Win32...
  */
-typedef enum { eFileTypeUNKNOWN, eFileTypeBIN, eFileTypeEXE16, eFileTypeEXE32, 
+typedef enum { eFileTypeUNKNOWN, eFileTypeBIN, eFileTypeEXE16, eFileTypeEXE32,
                eFileTypeSCRIPT } file_type_e;
-typedef enum { INTERPRETER_SOURCE_UNSET, INTERPRETER_SOURCE_REGISTRY_STRICT, 
-               INTERPRETER_SOURCE_REGISTRY, INTERPRETER_SOURCE_SHEBANG 
+typedef enum { INTERPRETER_SOURCE_UNSET, INTERPRETER_SOURCE_REGISTRY_STRICT,
+               INTERPRETER_SOURCE_REGISTRY, INTERPRETER_SOURCE_SHEBANG
              } interpreter_source_e;
-AP_DECLARE(file_type_e) ap_get_win32_interpreter(const request_rec *, 
+AP_DECLARE(file_type_e) ap_get_win32_interpreter(const request_rec *,
                                                  char **interpreter,
                                                  char **arguments);
 
@@ -69,9 +69,9 @@ static void *merge_win32_dir_configs(apr_pool_t *p, void *basev, void *addv)
     win32_dir_conf *add = (win32_dir_conf *) addv;
 
     new = (win32_dir_conf *) apr_pcalloc(p, sizeof(win32_dir_conf));
-    new->script_interpreter_source = (add->script_interpreter_source 
+    new->script_interpreter_source = (add->script_interpreter_source
                                            != INTERPRETER_SOURCE_UNSET)
-                                   ? add->script_interpreter_source 
+                                   ? add->script_interpreter_source
                                    : base->script_interpreter_source;
     return new;
 }
@@ -90,7 +90,7 @@ static const char *set_interpreter_source(cmd_parms *cmd, void *dv,
         d->script_interpreter_source = INTERPRETER_SOURCE_SHEBANG;
     }
     else {
-        return apr_pstrcat(cmd->temp_pool, "ScriptInterpreterSource \"", arg, 
+        return apr_pstrcat(cmd->temp_pool, "ScriptInterpreterSource \"", arg,
                            "\" must be \"registry\", \"registry-strict\" or "
                            "\"script\"", NULL);
     }
@@ -104,7 +104,7 @@ static const char *set_interpreter_source(cmd_parms *cmd, void *dv,
  * varies between msdos and Windows applications.
  * For subsystem 2 [GUI] the default is the system Ansi CP.
  * For subsystem 3 [CLI] the default is the system OEM CP.
- */ 
+ */
 static void prep_string(const char ** str, apr_pool_t *p)
 {
     const char *ch = *str;
@@ -141,7 +141,7 @@ static void prep_string(const char ** str, apr_pool_t *p)
 /* Somewhat more exciting ... figure out where the registry has stashed the
  * ExecCGI or Open command - it may be nested one level deep (or more???)
  */
-static char* get_interpreter_from_win32_registry(apr_pool_t *p, 
+static char* get_interpreter_from_win32_registry(apr_pool_t *p,
                                                  const char* ext,
                                                  int strict)
 {
@@ -153,11 +153,11 @@ static char* get_interpreter_from_win32_registry(apr_pool_t *p,
     char execopen_path[] = "SHELL\\OPEN\\COMMAND";
     char *type_name;
     char *buffer;
-    
+
     if (!ext) {
         return NULL;
     }
-    /* 
+    /*
      * Future optimization:
      * When the registry is successfully searched, store the strings for
      * interpreter and arguments in an ext hash to speed up subsequent look-ups
@@ -175,12 +175,12 @@ static char* get_interpreter_from_win32_registry(apr_pool_t *p,
 
     if (rv == APR_SUCCESS && type_name[0]) {
         /* Open the key associated with the script filetype extension */
-        rv = ap_regkey_open(&name_key, AP_REGKEY_CLASSES_ROOT, type_name, 
+        rv = ap_regkey_open(&name_key, AP_REGKEY_CLASSES_ROOT, type_name,
                             APR_READ, p);
     }
 
     /* Open the key for the script command path by:
-     * 
+     *
      *   1) the 'named' filetype key for ExecCGI/Command
      *   2) the extension's type key for ExecCGI/Command
      *
@@ -241,7 +241,7 @@ static apr_array_header_t *split_argv(apr_pool_t *p, const char *interp,
 {
     apr_array_header_t *args = apr_array_make(p, 8, sizeof(char*));
     char *d = apr_palloc(p, strlen(interp)+1);
-    const char *ch = interp; 
+    const char *ch = interp;
     const char **arg;
     int prgtaken = 0;
     int argtaken = 0;
@@ -289,8 +289,8 @@ static apr_array_header_t *split_argv(apr_pool_t *p, const char *interp,
             ch += 2;
             continue;
         }
-        if ((*ch == '\"') && ((*(ch + 1) == '$') 
-                              || (*(ch + 1) == '%')) && (*(ch + 2) == '1') 
+        if ((*ch == '\"') && ((*(ch + 1) == '$')
+                              || (*(ch + 1) == '%')) && (*(ch + 2) == '1')
             && (*(ch + 3) == '\"')) {
             prgtaken = 1;
             arg = (const char**)apr_array_push(args);
@@ -374,7 +374,7 @@ static apr_array_header_t *split_argv(apr_pool_t *p, const char *interp,
 
 
 static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
-                                         request_rec *r, apr_pool_t *p, 
+                                         request_rec *r, apr_pool_t *p,
                                          cgi_exec_info_t *e_info)
 {
     const apr_array_header_t *elts_arr = apr_table_elts(r->subprocess_env);
@@ -386,7 +386,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
     const char *args = "";
     int i;
 
-    d = (win32_dir_conf *)ap_get_module_config(r->per_dir_config, 
+    d = (win32_dir_conf *)ap_get_module_config(r->per_dir_config,
                                                &win32_module);
 
     if (e_info->cmd_type) {
@@ -406,7 +406,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
      * we will consider.
      */
     ext = strrchr(apr_filepath_name_get(*cmd), '.');
-    
+
     /* If the file has an extension and it is not .com and not .exe and
      * we've been instructed to search the registry, then do so.
      * Let apr_proc_create do all of the .bat/.cmd dirty work.
@@ -415,13 +415,13 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
                 || !strcasecmp(ext,".bat") || !strcasecmp(ext,".cmd"))) {
         interpreter = "";
     }
-    if (!interpreter && ext 
-          && (d->script_interpreter_source 
+    if (!interpreter && ext
+          && (d->script_interpreter_source
                      == INTERPRETER_SOURCE_REGISTRY
-           || d->script_interpreter_source 
+           || d->script_interpreter_source
                      == INTERPRETER_SOURCE_REGISTRY_STRICT)) {
          /* Check the registry */
-        int strict = (d->script_interpreter_source 
+        int strict = (d->script_interpreter_source
                       == INTERPRETER_SOURCE_REGISTRY_STRICT);
         interpreter = get_interpreter_from_win32_registry(r->pool, ext,
                                                           strict);
@@ -431,7 +431,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
         else {
             ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                  strict ? "No ExecCGI verb found for files of type '%s'."
-                        : "No ExecCGI or Open verb found for files of type '%s'.", 
+                        : "No ExecCGI or Open verb found for files of type '%s'.",
                  ext);
         }
     }
@@ -441,7 +441,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
         apr_size_t bytes = sizeof(buffer);
         apr_size_t i;
 
-        /* Need to peek into the file figure out what it really is... 
+        /* Need to peek into the file figure out what it really is...
          * ### aught to go back and build a cache for this one of these days.
          */
         if ((rv = apr_file_open(&fh, *cmd, APR_READ | APR_BUFFERED,
@@ -464,7 +464,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
          * would signify utf-8 text files.
          *
          * Since MS configuration files are all protecting utf-8 encoded
-         * Unicode path, file and resource names, we already have the correct 
+         * Unicode path, file and resource names, we already have the correct
          * WinNT encoding.  But at least eat the stupid three bytes up front.
          *
          * ### A more thorough check would also allow UNICODE text in buf, and
@@ -496,7 +496,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
         }
         else if (bytes >= sizeof(IMAGE_DOS_HEADER)) {
             /* Not a script, is it an executable? */
-            IMAGE_DOS_HEADER *hdr = (IMAGE_DOS_HEADER*)buffer;    
+            IMAGE_DOS_HEADER *hdr = (IMAGE_DOS_HEADER*)buffer;
             if (hdr->e_magic == IMAGE_DOS_SIGNATURE) {
                 if (hdr->e_lfarlc < 0x40) {
                     /* Ought to invoke this 16 bit exe by a stub, (cmd /c?) */
@@ -528,7 +528,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
      * application (following the OEM or Ansi code page in effect.)
      */
     for (i = 0; i < elts_arr->nelts; ++i) {
-        if (win_nt && elts[i].key && *elts[i].key 
+        if (win_nt && elts[i].key && *elts[i].key
                 && (strncmp(elts[i].key, "HTTP_", 5) == 0
                  || strncmp(elts[i].key, "SERVER_", 7) == 0
                  || strncmp(elts[i].key, "REQUEST_", 8) == 0
@@ -541,7 +541,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
     return APR_SUCCESS;
 }
 
-static int win32_pre_config(apr_pool_t *pconf_, apr_pool_t *plog, apr_pool_t *ptemp) 
+static int win32_pre_config(apr_pool_t *pconf_, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     win_nt = (osver.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS);
     return OK;
diff --git a/modules/cache/cache_hash.c b/modules/cache/cache_hash.c
index b5c1adb..efbfa40 100644
--- a/modules/cache/cache_hash.c
+++ b/modules/cache/cache_hash.c
@@ -213,7 +213,7 @@ static cache_hash_entry_t **find_entry(cache_hash_t *ht,
             hash = hash * 33 + *p;
         }
     }
-    
+
     /* scan linked list */
     for (hep = &ht->array[hash % ht->max], he = *hep;
          he;
@@ -275,7 +275,7 @@ CACHE_DECLARE(void *) cache_hash_set(cache_hash_t *ht,
             tval = (*hep)->val;
             (*hep)->val = val;
         }
-        /* Return the object just removed from the cache to let the 
+        /* Return the object just removed from the cache to let the
          * caller clean it up. Cast the constness away upon return.
          */
         return (void *) tval;
diff --git a/modules/cache/cache_storage.c b/modules/cache/cache_storage.c
index 8c83149..3dc7570 100644
--- a/modules/cache/cache_storage.c
+++ b/modules/cache/cache_storage.c
@@ -36,7 +36,7 @@ int cache_remove_url(cache_request_rec *cache, apr_pool_t *p)
     list = cache->providers;
 
     /* Remove the stale cache entry if present. If not, we're
-     * being called from outside of a request; remove the 
+     * being called from outside of a request; remove the
      * non-stalle handle.
      */
     h = cache->stale_handle ? cache->stale_handle : cache->handle;
@@ -72,7 +72,7 @@ int cache_create_entity(request_rec *r, apr_off_t size)
     cache_handle_t *h = apr_pcalloc(r->pool, sizeof(cache_handle_t));
     char *key;
     apr_status_t rv;
-    cache_request_rec *cache = (cache_request_rec *) 
+    cache_request_rec *cache = (cache_request_rec *)
                          ap_get_module_config(r->request_config, &cache_module);
 
     rv = cache_generate_key(r, r->pool, &key);
@@ -175,7 +175,7 @@ int cache_select(request_rec *r)
     apr_status_t rv;
     cache_handle_t *h;
     char *key;
-    cache_request_rec *cache = (cache_request_rec *) 
+    cache_request_rec *cache = (cache_request_rec *)
                          ap_get_module_config(r->request_config, &cache_module);
 
     rv = cache_generate_key(r, r->pool, &key);
@@ -200,7 +200,7 @@ int cache_select(request_rec *r)
 
             /*
              * Check Content-Negotiation - Vary
-             * 
+             *
              * At this point we need to make sure that the object we found in
              * the cache is the same object that would be delivered to the
              * client, when the effects of content negotiation are taken into
@@ -286,7 +286,7 @@ int cache_select(request_rec *r)
                     if (etag) {
                         apr_table_set(r->headers_in, "If-None-Match", etag);
                     }
-                    
+
                     if (lastmod) {
                         apr_table_set(r->headers_in, "If-Modified-Since",
                                       lastmod);
@@ -325,8 +325,8 @@ apr_status_t cache_generate_key_default(request_rec *r, apr_pool_t* p,
     int i;
 
     /* Use the canonical name to improve cache hit rate, but only if this is
-     * not a proxy request. 
-     */ 
+     * not a proxy request.
+     */
     if (!r->proxyreq) {
         /* Use _default_ as the hostname if none present, as in mod_vhost */
         hostname =  ap_get_server_name(r);
@@ -386,8 +386,8 @@ apr_status_t cache_generate_key_default(request_rec *r, apr_pool_t* p,
              * entities.
              */
             port_str = "";
-        }       
-    }       
+        }
+    }
     else {
         /* Use the server port */
         port_str = apr_psprintf(p, ":%u", ap_get_server_port(r));
diff --git a/modules/cache/cache_util.c b/modules/cache/cache_util.c
index eed63f7..f01bddf 100644
--- a/modules/cache/cache_util.c
+++ b/modules/cache/cache_util.c
@@ -72,7 +72,7 @@ static int uri_meets_conditions(apr_uri_t filter, int pathlen, apr_uri_t url)
 }
 
 CACHE_DECLARE(cache_provider_list *)ap_cache_get_providers(request_rec *r,
-                                                  cache_server_conf *conf, 
+                                                  cache_server_conf *conf,
                                                   apr_uri_t uri)
 {
     cache_provider_list *providers = NULL;
@@ -80,7 +80,7 @@ CACHE_DECLARE(cache_provider_list *)ap_cache_get_providers(request_rec *r,
 
     /* loop through all the cacheenable entries */
     for (i = 0; i < conf->cacheenable->nelts; i++) {
-        struct cache_enable *ent = 
+        struct cache_enable *ent =
                                 (struct cache_enable *)conf->cacheenable->elts;
         if (uri_meets_conditions(ent[i].url, ent[i].pathlen, uri)) {
             /* Fetch from global config and add to the list. */
@@ -117,7 +117,7 @@ CACHE_DECLARE(cache_provider_list *)ap_cache_get_providers(request_rec *r,
      * This means we are disabling cachedisable url and below...
      */
     for (i = 0; i < conf->cachedisable->nelts; i++) {
-        struct cache_disable *ent = 
+        struct cache_disable *ent =
                                (struct cache_disable *)conf->cachedisable->elts;
         if (uri_meets_conditions(ent[i].url, ent[i].pathlen, uri)) {
             /* Stop searching now. */
@@ -176,29 +176,29 @@ CACHE_DECLARE(int) ap_cache_check_freshness(cache_handle_t *h,
      * either the request or the cached response means that we must
      * revalidate the request unconditionally, overriding any expiration
      * mechanism. It's equivalent to max-age=0,must-revalidate.
-     * 
+     *
      * - RFC2616 14.32 Pragma: no-cache This is treated the same as
      * Cache-Control: no-cache.
-     * 
+     *
      * - RFC2616 14.9.3 Cache-Control: max-stale, must-revalidate,
      * proxy-revalidate if the max-stale request header exists, modify the
      * stale calculations below so that an object can be at most <max-stale>
      * seconds stale before we request a revalidation, _UNLESS_ a
      * must-revalidate or proxy-revalidate cached response header exists to
      * stop us doing this.
-     * 
+     *
      * - RFC2616 14.9.3 Cache-Control: s-maxage the origin server specifies the
      * maximum age an object can be before it is considered stale. This
      * directive has the effect of proxy|must revalidate, which in turn means
      * simple ignore any max-stale setting.
-     * 
+     *
      * - RFC2616 14.9.4 Cache-Control: max-age this header can appear in both
      * requests and responses. If both are specified, the smaller of the two
      * takes priority.
-     * 
+     *
      * - RFC2616 14.21 Expires: if this request header exists in the cached
      * entity, and it's value is in the past, it has expired.
-     * 
+     *
      */
 
     /* This value comes from the client's initial request. */
@@ -322,10 +322,10 @@ CACHE_DECLARE(int) ap_cache_check_freshness(cache_handle_t *h,
                                 "110 Response is stale");
             }
         }
-        /* 
-         * If none of Expires, Cache-Control: max-age, or Cache-Control: 
-         * s-maxage appears in the response, and the respose header age 
-         * calculated is more than 24 hours add the warning 113 
+        /*
+         * If none of Expires, Cache-Control: max-age, or Cache-Control:
+         * s-maxage appears in the response, and the respose header age
+         * calculated is more than 24 hours add the warning 113
          */
         if ((maxage_cresp == -1) && (smaxage == -1) &&
             (expstr == NULL) && (age > 86400)) {
@@ -451,7 +451,7 @@ CACHE_DECLARE(const char *)ap_cache_tokstr(apr_pool_t *p, const char *list,
 }
 
 /*
- * Converts apr_time_t expressed as hex digits to 
+ * Converts apr_time_t expressed as hex digits to
  * a true apr_time_t.
  */
 CACHE_DECLARE(apr_time_t) ap_cache_hex2usec(const char *x)
@@ -503,8 +503,8 @@ static void cache_hash(const char *it, char *val, int ndepth, int nlength)
     apr_md5_update(&context, (const unsigned char *) it, strlen(it));
     apr_md5_final(digest, &context);
 
-    /* encode 128 bits as 22 characters, using a modified uuencoding 
-     * the encoding is 3 bytes -> 4 characters* i.e. 128 bits is 
+    /* encode 128 bits as 22 characters, using a modified uuencoding
+     * the encoding is 3 bytes -> 4 characters* i.e. 128 bits is
      * 5 x 3 bytes + 1 byte -> 5 * 4 characters + 2 characters
      */
     for (i = 0, k = 0; i < 15; i += 3) {
diff --git a/modules/cache/mod_cache.c b/modules/cache/mod_cache.c
index 6dc5944..c89f503 100644
--- a/modules/cache/mod_cache.c
+++ b/modules/cache/mod_cache.c
@@ -129,12 +129,12 @@ static int cache_url_handler(request_rec *r, int lookup)
                     ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,
                                  r->server, "Adding CACHE_SAVE filter for %s",
                                  r->uri);
-                    ap_add_output_filter_handle(cache_save_filter_handle, 
+                    ap_add_output_filter_handle(cache_save_filter_handle,
                                                 NULL, r, r->connection);
                 }
 
                 ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r->server,
-                             "Adding CACHE_REMOVE_URL filter for %s", 
+                             "Adding CACHE_REMOVE_URL filter for %s",
                              r->uri);
 
                 /* Add cache_remove_url filter to this request to remove a
@@ -144,18 +144,18 @@ static int cache_url_handler(request_rec *r, int lookup)
                  * different due to an internal redirect.
                  */
                 cache->remove_url_filter =
-                    ap_add_output_filter_handle(cache_remove_url_filter_handle, 
+                    ap_add_output_filter_handle(cache_remove_url_filter_handle,
                                                 cache, r, r->connection);
             }
             else {
                 if (cache->stale_headers) {
-                    ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, 
-                                 r->server, "Restoring request headers for %s", 
+                    ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS,
+                                 r->server, "Restoring request headers for %s",
                                  r->uri);
 
                     r->headers_in = cache->stale_headers;
                 }
-                
+
                 /* Delete our per-request configuration. */
                 ap_set_module_config(r->request_config, &cache_module, NULL);
             }
@@ -168,12 +168,12 @@ static int cache_url_handler(request_rec *r, int lookup)
         }
         return DECLINED;
     }
- 
+
     /* if we are a lookup, we are exiting soon one way or another; Restore
      * the headers. */
     if (lookup) {
         if (cache->stale_headers) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r->server, 
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, APR_SUCCESS, r->server,
                          "Restoring request headers.");
             r->headers_in = cache->stale_headers;
         }
@@ -185,7 +185,7 @@ static int cache_url_handler(request_rec *r, int lookup)
     rv = ap_meets_conditions(r);
     if (rv != OK) {
         /* If we are a lookup, we have to return DECLINED as we have no
-         * way of knowing if we will be able to serve the content. 
+         * way of knowing if we will be able to serve the content.
          */
         if (lookup) {
             return DECLINED;
@@ -227,7 +227,7 @@ static int cache_url_handler(request_rec *r, int lookup)
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                      "cache: error returned while trying to return %s "
-                     "cached data", 
+                     "cached data",
                      cache->provider_name);
         return rv;
     }
@@ -246,7 +246,7 @@ static int cache_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     request_rec *r = f->r;
     cache_request_rec *cache;
 
-    cache = (cache_request_rec *) ap_get_module_config(r->request_config, 
+    cache = (cache_request_rec *) ap_get_module_config(r->request_config,
                                                        &cache_module);
 
     if (!cache) {
@@ -262,7 +262,7 @@ static int cache_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
                  "cache: running CACHE_OUT filter");
 
     /* restore status of cached response */
-    /* XXX: This exposes a bug in mem_cache, since it does not 
+    /* XXX: This exposes a bug in mem_cache, since it does not
      * restore the status into it's handle. */
     r->status = cache->handle->cache_obj->info.status;
 
@@ -339,7 +339,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
     }
 
     /* have we already run the cachability check and set up the
-     * cached file handle? 
+     * cached file handle?
      */
     if (cache->in_checked) {
         /* pass the brigades into the cache, then pass them
@@ -363,7 +363,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
      */
 
     /* read expiry date; if a bad date, then leave it so the client can
-     * read it 
+     * read it
      */
     exps = apr_table_get(r->err_headers_out, "Expires");
     if (exps == NULL) {
@@ -409,7 +409,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
      * At this point we decide based on the response headers whether it
      * is appropriate _NOT_ to cache the data from the server. There are
      * a whole lot of conditions that prevent us from caching this data.
-     * They are tested here one by one to be clear and unambiguous. 
+     * They are tested here one by one to be clear and unambiguous.
      */
     if (r->status != HTTP_OK && r->status != HTTP_NON_AUTHORITATIVE
         && r->status != HTTP_MULTIPLE_CHOICES
@@ -421,7 +421,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
          * telling us to serve the cached copy.
          */
         reason = apr_psprintf(p, "Response status %d", r->status);
-    } 
+    }
     else if (exps != NULL && exp == APR_DATE_BAD) {
         /* if a broken Expires header is present, don't cache it */
         reason = apr_pstrcat(p, "Broken expires header: ", exps, NULL);
@@ -439,13 +439,13 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
          */
         reason = "HTTP Status 304 Not Modified";
     }
-    else if (r->status == HTTP_OK && lastmods == NULL && etag == NULL 
+    else if (r->status == HTTP_OK && lastmods == NULL && etag == NULL
              && (exps == NULL) && (conf->no_last_mod_ignore ==0)) {
         /* 200 OK response from HTTP/1.0 and up without Last-Modified,
          * Etag, or Expires headers.
          */
         /* Note: mod-include clears last_modified/expires/etags - this
-         * is why we have an optional function for a key-gen ;-) 
+         * is why we have an optional function for a key-gen ;-)
          */
         reason = "No Last-Modified, Etag, or Expires headers";
     }
@@ -488,7 +488,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
          */
         reason = "Authorization required";
     }
-    else if (ap_cache_liststr(NULL, 
+    else if (ap_cache_liststr(NULL,
                               apr_table_get(r->headers_out, "Vary"),
                               "*", NULL)) {
         reason = "Vary header contains '*'";
@@ -500,7 +500,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
 
     if (reason) {
         ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
-                     "cache: %s not cached. Reason: %s", r->unparsed_uri, 
+                     "cache: %s not cached. Reason: %s", r->unparsed_uri,
                      reason);
 
         /* remove this filter from the chain */
@@ -513,7 +513,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
     /* Make it so that we don't execute this path again. */
     cache->in_checked = 1;
 
-    /* Set the content length if known. 
+    /* Set the content length if known.
      */
     cl = apr_table_get(r->err_headers_out, "Content-Length");
     if (cl == NULL) {
@@ -527,8 +527,8 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
     }
 
     if (!cl) {
-        /* if we don't get the content-length, see if we have all the 
-         * buckets and use their length to calculate the size 
+        /* if we don't get the content-length, see if we have all the
+         * buckets and use their length to calculate the size
          */
         apr_bucket *e;
         int all_buckets_here=0;
@@ -639,7 +639,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
         char *dates;
         /* no date header (or bad header)! */
         /* add one; N.B. use the time _now_ rather than when we were checking
-         * the cache 
+         * the cache
          */
         if (date_in_errhdr == 1) {
             apr_table_unset(r->err_headers_out, "Date");
@@ -667,7 +667,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
         /* if it's in the future, then replace by date */
         lastmod = date;
         lastmods = dates;
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, 
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0,
                      r->server,
                      "cache: Last modified is in the future, "
                      "replacing with now");
@@ -733,7 +733,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
      * trying to update headers for an entity which has already been cached.
      *
      * This may fail, due to an unwritable cache area. E.g. filesystem full,
-     * permissions problems or a read-only (re)mount. This must be handled 
+     * permissions problems or a read-only (re)mount. This must be handled
      * later.
      */
     rv = cache->provider->store_headers(cache->handle, r, info);
@@ -771,7 +771,7 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
 
         /* Before returning we need to handle the possible case of an
          * unwritable cache. Rather than leaving the entity in the cache
-         * and having it constantly re-validated, now that we have recalled 
+         * and having it constantly re-validated, now that we have recalled
          * the body it is safe to try and remove the url from the cache.
          */
         if (rv != APR_SUCCESS) {
@@ -781,8 +781,8 @@ static int cache_save_filter(ap_filter_t *f, apr_bucket_brigade *in)
 
             rv = cache->provider->remove_url(cache->stale_handle, r->pool);
             if (rv != OK) {
-                /* Probably a mod_disk_cache cache area has been (re)mounted 
-                 * read-only, or that there is a permissions problem. 
+                /* Probably a mod_disk_cache cache area has been (re)mounted
+                 * read-only, or that there is a permissions problem.
                  */
                 ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                      "cache: attempt to remove url from cache unsuccessful.");
@@ -840,9 +840,9 @@ static int cache_remove_url_filter(ap_filter_t *f, apr_bucket_brigade *in)
     cache = (cache_request_rec *) f->ctx;
 
     if (!cache) {
-        /* user likely configured CACHE_REMOVE_URL manually; they should really 
+        /* user likely configured CACHE_REMOVE_URL manually; they should really
          * use mod_cache configuration to do that. So:
-         * 1. Remove ourselves 
+         * 1. Remove ourselves
          * 2. Do nothing and bail out
          */
         ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
@@ -899,12 +899,12 @@ static void * merge_cache_config(apr_pool_t *p, void *basev, void *overridesv)
     cache_server_conf *overrides = (cache_server_conf *) overridesv;
 
     /* array of URL prefixes for which caching is disabled */
-    ps->cachedisable = apr_array_append(p, 
-                                        base->cachedisable, 
+    ps->cachedisable = apr_array_append(p,
+                                        base->cachedisable,
                                         overrides->cachedisable);
     /* array of URL prefixes for which caching is enabled */
-    ps->cacheenable = apr_array_append(p, 
-                                       base->cacheenable, 
+    ps->cacheenable = apr_array_append(p,
+                                       base->cacheenable,
                                        overrides->cacheenable);
     /* maximum time to cache a document */
     ps->maxex = (overrides->maxex_set == 0) ? base->maxex : overrides->maxex;
@@ -1017,8 +1017,8 @@ static const char *add_ignore_header(cmd_parms *parms, void *dummy,
     return NULL;
 }
 
-static const char *add_cache_enable(cmd_parms *parms, void *dummy, 
-                                    const char *type, 
+static const char *add_cache_enable(cmd_parms *parms, void *dummy,
+                                    const char *type,
                                     const char *url)
 {
     cache_server_conf *conf;
@@ -1172,7 +1172,7 @@ static void register_hooks(apr_pool_t *p)
     /* cache initializer */
     /* cache handler */
     ap_hook_quick_handler(cache_url_handler, NULL, NULL, APR_HOOK_FIRST);
-    /* cache filters 
+    /* cache filters
      * XXX The cache filters need to run right after the handlers and before
      * any other filters. Consider creating AP_FTYPE_CACHE for this purpose.
      *
@@ -1189,9 +1189,9 @@ static void register_hooks(apr_pool_t *p)
      * filter to ensure that the compressed content is stored.
      * Incrementing filter type by 1 ensures his happens.
      */
-    cache_save_filter_handle = 
-        ap_register_output_filter("CACHE_SAVE", 
-                                  cache_save_filter, 
+    cache_save_filter_handle =
+        ap_register_output_filter("CACHE_SAVE",
+                                  cache_save_filter,
                                   NULL,
                                   AP_FTYPE_CONTENT_SET+1);
     /*
@@ -1210,9 +1210,9 @@ static void register_hooks(apr_pool_t *p)
      * get compressed again. Incrementing filter type by 1 ensures
      * his happens.
      */
-    cache_out_filter_handle = 
-        ap_register_output_filter("CACHE_OUT", 
-                                  cache_out_filter, 
+    cache_out_filter_handle =
+        ap_register_output_filter("CACHE_OUT",
+                                  cache_out_filter,
                                   NULL,
                                   AP_FTYPE_CONTENT_SET+1);
     /*
diff --git a/modules/cache/mod_disk_cache.c b/modules/cache/mod_disk_cache.c
index 7c33c02..33c32d5 100644
--- a/modules/cache/mod_disk_cache.c
+++ b/modules/cache/mod_disk_cache.c
@@ -36,13 +36,13 @@
  *      regenerate <hash> using HeaderName+HeaderValue+.../foo/bar/baz
  *      re-read in <hash>.header (must be format #2)
  *   read in <hash>.data
- *   
+ *
  * Format #1:
  *   apr_uint32_t format;
  *   apr_time_t expire;
  *   apr_array_t vary_headers (delimited by CRLF)
  *
- * Format #2: 
+ * Format #2:
  *   disk_cache_info_t (first sizeof(apr_uint32_t) bytes is the format)
  *   entity name (dobj->name) [length is in disk_cache_info_t->name_len]
  *   r->headers_out (delimited by CRLF)
@@ -59,7 +59,7 @@ static apr_status_t store_headers(cache_handle_t *h, request_rec *r, cache_info
 static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b);
 static apr_status_t recall_headers(cache_handle_t *h, request_rec *r);
 static apr_status_t recall_body(cache_handle_t *h, apr_pool_t *p, apr_bucket_brigade *bb);
-static apr_status_t read_array(request_rec *r, apr_array_header_t* arr, 
+static apr_status_t read_array(request_rec *r, apr_array_header_t* arr,
                                apr_file_t *file);
 
 /*
@@ -70,7 +70,7 @@ static char *header_file(apr_pool_t *p, disk_cache_conf *conf,
                          disk_cache_object_t *dobj, const char *name)
 {
     if (!dobj->hashfile) {
-        dobj->hashfile = ap_cache_generate_name(p, conf->dirlevels, 
+        dobj->hashfile = ap_cache_generate_name(p, conf->dirlevels,
                                                 conf->dirlength, name);
     }
 
@@ -88,7 +88,7 @@ static char *data_file(apr_pool_t *p, disk_cache_conf *conf,
                        disk_cache_object_t *dobj, const char *name)
 {
     if (!dobj->hashfile) {
-        dobj->hashfile = ap_cache_generate_name(p, conf->dirlevels, 
+        dobj->hashfile = ap_cache_generate_name(p, conf->dirlevels,
                                                 conf->dirlength, name);
     }
 
@@ -251,12 +251,12 @@ static const char* regen_key(apr_pool_t *p, apr_table_t *headers,
     iov = apr_palloc(p, sizeof(struct iovec) * nvec);
     elts = (const char **) varray->elts;
 
-    /* TODO: 
+    /* TODO:
      *    - Handle multiple-value headers better. (sort them?)
      *    - Handle Case in-sensitive Values better.
-     *        This isn't the end of the world, since it just lowers the cache 
+     *        This isn't the end of the world, since it just lowers the cache
      *        hit rate, but it would be nice to fix.
-     *  
+     *
      * The majority are case insenstive if they are values (encoding etc).
      * Most of rfc2616 is case insensitive on header contents.
      *
@@ -411,7 +411,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
         rc = read_array(r, varray, dobj->hfd);
         if (rc != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server,
-                         "disk_cache: Cannot parse vary header file: %s", 
+                         "disk_cache: Cannot parse vary header file: %s",
                          dobj->hdrsfile);
             return DECLINED;
         }
@@ -437,8 +437,8 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
     }
     else {
         apr_off_t offset = 0;
-        /* This wasn't a Vary Format file, so we must seek to the 
-         * start of the file again, so that later reads work. 
+        /* This wasn't a Vary Format file, so we must seek to the
+         * start of the file again, so that later reads work.
          */
         apr_file_seek(dobj->hfd, APR_SET, &offset);
         nkey = key;
@@ -573,7 +573,7 @@ static int remove_url(cache_handle_t *h, apr_pool_t *p)
     return OK;
 }
 
-static apr_status_t read_array(request_rec *r, apr_array_header_t* arr, 
+static apr_status_t read_array(request_rec *r, apr_array_header_t* arr,
                                apr_file_t *file)
 {
     char w[MAX_STRING_LEN];
@@ -821,7 +821,7 @@ static apr_status_t store_headers(cache_handle_t *h, request_rec *r, cache_info
 
         if (tmp) {
             apr_array_header_t* varray;
-            apr_uint32_t format = VARY_FORMAT_VERSION; 
+            apr_uint32_t format = VARY_FORMAT_VERSION;
 
             mkdir_structure(conf, dobj->hdrsfile, r->pool);
 
@@ -929,7 +929,7 @@ static apr_status_t store_headers(cache_handle_t *h, request_rec *r, cache_info
             return rv;
         }
     }
-    
+
     apr_file_close(dobj->hfd); /* flush and close */
 
     /* Remove old file with the same name. If remove fails, then
diff --git a/modules/cache/mod_file_cache.c b/modules/cache/mod_file_cache.c
index 54d0ff5..c98c643 100644
--- a/modules/cache/mod_file_cache.c
+++ b/modules/cache/mod_file_cache.c
@@ -15,7 +15,7 @@
  */
 
 /*
- * Author: mod_file_cache by Bill Stoddard <stoddard apache.org> 
+ * Author: mod_file_cache by Bill Stoddard <stoddard apache.org>
  *         Based on mod_mmap_static by Dean Gaudet <dgaudet arctic.org>
  *
  * v0.01: initial implementation
@@ -24,22 +24,22 @@
 /*
     Documentation:
 
-    Some sites have a set of static files that are really busy, and 
-    change infrequently (or even on a regular schedule). Save time 
-    by caching open handles to these files. This module, unlike 
-    mod_mmap_static, caches open file handles, not file content. 
+    Some sites have a set of static files that are really busy, and
+    change infrequently (or even on a regular schedule). Save time
+    by caching open handles to these files. This module, unlike
+    mod_mmap_static, caches open file handles, not file content.
     On systems (like Windows) with heavy system call overhead and
     that have an efficient sendfile implementation, caching file handles
     offers several advantages over caching content. First, the file system
     can manage the memory, allowing infrequently hit cached files to
     be paged out. Second, since caching open handles does not consume
     significant resources, it will be possible to enable an AutoLoadCache
-    feature where static files are dynamically loaded in the cache 
+    feature where static files are dynamically loaded in the cache
     as the server runs. On systems that have file change notification,
-    this module can be enhanced to automatically garbage collect 
+    this module can be enhanced to automatically garbage collect
     cached files that change on disk.
 
-    This module should work on Unix systems that have sendfile. Place 
+    This module should work on Unix systems that have sendfile. Place
     cachefile directives into your configuration to direct files to
     be cached.
 
@@ -47,14 +47,14 @@
         cachefile /path/to/file2
         ...
 
-    These files are only cached when the server is restarted, so if you 
-    change the list, or if the files are changed, then you'll need to 
+    These files are only cached when the server is restarted, so if you
+    change the list, or if the files are changed, then you'll need to
     restart the server.
 
     To reiterate that point:  if the files are modified *in place*
     without restarting the server you may end up serving requests that
     are completely bogus.  You should update files by unlinking the old
-    copy and putting a new copy in place. 
+    copy and putting a new copy in place.
 
     There's no such thing as inheriting these files across vhosts or
     whatever... place the directives in the main server only.
@@ -108,7 +108,7 @@ typedef struct {
     apr_mmap_t *mm;
 #endif
     char mtimestr[APR_RFC822_DATE_LEN];
-    char sizestr[21];	/* big enough to hold any 64-bit file size + null */ 
+    char sizestr[21];	/* big enough to hold any 64-bit file size + null */
 } a_file;
 
 typedef struct {
@@ -140,7 +140,7 @@ static void cache_the_file(cmd_parms *cmd, const char *filename, int mmap)
                      "%s, skipping", filename);
         return;
     }
-    if ((rc = apr_stat(&tmp.finfo, fspec, APR_FINFO_MIN, 
+    if ((rc = apr_stat(&tmp.finfo, fspec, APR_FINFO_MIN,
                                  cmd->temp_pool)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
             "mod_file_cache: unable to stat(%s), skipping", fspec);
@@ -176,9 +176,9 @@ static void cache_the_file(cmd_parms *cmd, const char *filename, int mmap)
          * XXX: APR_HAS_LARGE_FILES issue; need to reject this request if
          * size is greater than MAX(apr_size_t) (perhaps greater than 1M?).
          */
-        if ((rc = apr_mmap_create(&new_file->mm, fd, 0, 
+        if ((rc = apr_mmap_create(&new_file->mm, fd, 0,
                                   (apr_size_t)new_file->finfo.size,
-                                  APR_MMAP_READ, cmd->pool)) != APR_SUCCESS) { 
+                                  APR_MMAP_READ, cmd->pool)) != APR_SUCCESS) {
             apr_file_close(fd);
             ap_log_error(APLOG_MARK, APLOG_WARNING, rc, cmd->server,
                          "mod_file_cache: unable to mmap %s, skipping", filename);
@@ -216,7 +216,7 @@ static const char *cachefilehandle(cmd_parms *cmd, void *dummy, const char *file
 #endif
     return NULL;
 }
-static const char *cachefilemmap(cmd_parms *cmd, void *dummy, const char *filename) 
+static const char *cachefilemmap(cmd_parms *cmd, void *dummy, const char *filename)
 {
 #if APR_HAS_MMAP
     cache_the_file(cmd, filename, 1);
@@ -309,7 +309,7 @@ static int sendfile_handler(request_rec *r, a_file *file)
     return OK;
 }
 
-static int file_cache_handler(request_rec *r) 
+static int file_cache_handler(request_rec *r)
 {
     a_file *match;
     int errstatus;
@@ -373,7 +373,7 @@ static int file_cache_handler(request_rec *r)
     apr_table_setn(r->headers_out, "Content-Length", match->sizestr);
 
     /* Call appropriate handler */
-    if (!r->header_only) {    
+    if (!r->header_only) {
         if (match->is_mmapped == TRUE)
             rc = mmap_handler(r, match);
         else
@@ -398,9 +398,9 @@ static void register_hooks(apr_pool_t *p)
     ap_hook_post_config(file_cache_post_config, NULL, NULL, APR_HOOK_MIDDLE);
     ap_hook_translate_name(file_cache_xlat, NULL, NULL, APR_HOOK_MIDDLE);
     /* This trick doesn't work apparently because the translate hooks
-       are single shot. If the core_hook returns OK, then our hook is 
+       are single shot. If the core_hook returns OK, then our hook is
        not called.
-    ap_hook_translate_name(file_cache_xlat, aszPre, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_translate_name(file_cache_xlat, aszPre, NULL, APR_HOOK_MIDDLE);
     */
 
 }
diff --git a/modules/cache/mod_mem_cache.c b/modules/cache/mod_mem_cache.c
index 2d45c2c..e61d190 100644
--- a/modules/cache/mod_mem_cache.c
+++ b/modules/cache/mod_mem_cache.c
@@ -16,14 +16,14 @@
 
 /*
  * Rules for managing obj->refcount:
- * refcount should be incremented when an object is placed in the cache. Insertion 
- *   of an object into the cache and the refcount increment should happen under 
+ * refcount should be incremented when an object is placed in the cache. Insertion
+ *   of an object into the cache and the refcount increment should happen under
  *   protection of the sconf->lock.
  *
  * refcount should be decremented when the object is removed from the cache.
  *   Object should be removed from the cache and the refcount decremented while
  *   under protection of the sconf->lock.
- * 
+ *
  * refcount should be incremented when an object is retrieved from the cache
  *   by a worker thread. The retrieval/find operation and refcount increment
  *   should occur under protection of the sconf->lock
@@ -31,8 +31,8 @@
  * refcount can be atomically decremented w/o protection of the sconf->lock
  *   by worker threads.
  *
- * Any object whose refcount drops to 0 should be freed/cleaned up. A refcount 
- * of 0 means the object is not in the cache and no worker threads are accessing 
+ * Any object whose refcount drops to 0 should be freed/cleaned up. A refcount
+ * of 0 means the object is not in the cache and no worker threads are accessing
  * it.
  */
 #define CORE_PRIVATE
@@ -157,9 +157,9 @@ static const char* memcache_cache_get_key(void*a)
     cache_object_t *obj = (cache_object_t *)a;
     return obj->key;
 }
-/** 
+/**
  * memcache_cache_free()
- * memcache_cache_free is a callback that is only invoked by a thread 
+ * memcache_cache_free is a callback that is only invoked by a thread
  * running in cache_insert(). cache_insert() runs under protection
  * of sconf->lock.  By the time this function has been entered, the cache_object
  * has been ejected from the cache. decrement the refcount and if the refcount drops
@@ -180,21 +180,21 @@ static void memcache_cache_free(void*a)
  * functions return a 'negative' score since priority queues
  * dequeue the object with the highest value first
  */
-static long memcache_lru_algorithm(long queue_clock, void *a) 
+static long memcache_lru_algorithm(long queue_clock, void *a)
 {
     cache_object_t *obj = (cache_object_t *)a;
     mem_cache_object_t *mobj = obj->vobj;
     if (mobj->priority == 0)
         mobj->priority = queue_clock - mobj->total_refs;
 
-    /*	
+    /*
      * a 'proper' LRU function would just be
-     *  mobj->priority = mobj->total_refs; 
+     *  mobj->priority = mobj->total_refs;
      */
     return mobj->priority;
 }
 
-static long memcache_gdsf_algorithm(long queue_clock, void *a) 
+static long memcache_gdsf_algorithm(long queue_clock, void *a)
 {
     cache_object_t *obj = (cache_object_t *)a;
     mem_cache_object_t *mobj = obj->vobj;
@@ -212,7 +212,7 @@ static void cleanup_cache_object(cache_object_t *obj)
 
     /* TODO:
      * We desperately need a more efficient way of allocating objects. We're
-     * making way too many malloc calls to create a fully populated 
+     * making way too many malloc calls to create a fully populated
      * cache object...
      */
 
@@ -236,7 +236,7 @@ static void cleanup_cache_object(cache_object_t *obj)
 #endif
         }
         if (mobj->header_out) {
-            if (mobj->header_out[0].hdr) 
+            if (mobj->header_out[0].hdr)
                 free(mobj->header_out[0].hdr);
             free(mobj->header_out);
         }
@@ -248,7 +248,7 @@ static void cleanup_cache_object(cache_object_t *obj)
         free(mobj);
     }
 }
-static apr_status_t decrement_refcount(void *arg) 
+static apr_status_t decrement_refcount(void *arg)
 {
     cache_object_t *obj = (cache_object_t *) arg;
 
@@ -271,7 +271,7 @@ static apr_status_t decrement_refcount(void *arg)
         if (sconf->lock) {
             apr_thread_mutex_unlock(sconf->lock);
         }
-    } 
+    }
 
     /* If the refcount drops to 0, cleanup the cache object */
     if (!apr_atomic_dec32(&obj->refcount)) {
@@ -295,7 +295,7 @@ static apr_status_t cleanup_cache_mem(void *sconfv)
         apr_thread_mutex_lock(sconf->lock);
     }
     obj = cache_pop(co->cache_cache);
-    while (obj) {         
+    while (obj) {
         /* Iterate over the cache and clean up each unreferenced entry */
         if (!apr_atomic_dec32(&obj->refcount)) {
             cleanup_cache_object(obj);
@@ -303,7 +303,7 @@ static apr_status_t cleanup_cache_mem(void *sconfv)
         obj = cache_pop(co->cache_cache);
     }
 
-    /* Cache is empty, free the cache table */        
+    /* Cache is empty, free the cache table */
     cache_free(co->cache_cache);
 
     if (sconf->lock) {
@@ -332,7 +332,7 @@ static void *create_cache_config(apr_pool_t *p, server_rec *s)
 }
 
 static int create_entity(cache_handle_t *h, cache_type_e type_e,
-                         request_rec *r, const char *key, apr_off_t len) 
+                         request_rec *r, const char *key, apr_off_t len)
 {
     cache_object_t *obj, *tmp_obj;
     mem_cache_object_t *mobj;
@@ -347,12 +347,12 @@ static int create_entity(cache_handle_t *h, cache_type_e type_e,
         len = sconf->max_streaming_buffer_size;
     }
 
-    /* Note: cache_insert() will automatically garbage collect 
+    /* Note: cache_insert() will automatically garbage collect
      * objects from the cache if the max_cache_size threshold is
      * exceeded. This means mod_mem_cache does not need to implement
      * max_cache_size checks.
      */
-    if (len < sconf->min_cache_object_size || 
+    if (len < sconf->min_cache_object_size ||
         len > sconf->max_cache_object_size) {
         ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                      "mem_cache: URL %s failed the size check and will not be cached.",
@@ -361,7 +361,7 @@ static int create_entity(cache_handle_t *h, cache_type_e type_e,
     }
 
     if (type_e == CACHE_TYPE_FILE) {
-        /* CACHE_TYPE_FILE is only valid for local content handled by the 
+        /* CACHE_TYPE_FILE is only valid for local content handled by the
          * default handler. Need a better way to check if the file is
          * local or not.
          */
@@ -405,11 +405,11 @@ static int create_entity(cache_handle_t *h, cache_type_e type_e,
      * avoid multiple threads attempting to cache the same content only
      * to discover at the very end that only one of them will succeed.
      * Furthermore, adding the cache object to the table at the end could
-     * open up a subtle but easy to exploit DoS hole: someone could request 
+     * open up a subtle but easy to exploit DoS hole: someone could request
      * a very large file with multiple requests. Better to detect this here
      * rather than after the cache object has been completely built and
      * initialized...
-     * XXX Need a way to insert into the cache w/o such coarse grained locking 
+     * XXX Need a way to insert into the cache w/o such coarse grained locking
      */
     if (sconf->lock) {
         apr_thread_mutex_lock(sconf->lock);
@@ -418,7 +418,7 @@ static int create_entity(cache_handle_t *h, cache_type_e type_e,
 
     if (!tmp_obj) {
         cache_insert(sconf->cache_cache, obj);
-        /* Add a refcount to account for the reference by the 
+        /* Add a refcount to account for the reference by the
          * hashtable in the cache. Refcount should be 2 now, one
          * for this thread, and one for the cache.
          */
@@ -430,14 +430,14 @@ static int create_entity(cache_handle_t *h, cache_type_e type_e,
 
     if (tmp_obj) {
         /* This thread collided with another thread loading the same object
-         * into the cache at the same time. Defer to the other thread which 
+         * into the cache at the same time. Defer to the other thread which
          * is further along.
          */
         cleanup_cache_object(obj);
         return DECLINED;
     }
 
-    apr_pool_cleanup_register(r->pool, obj, decrement_refcount, 
+    apr_pool_cleanup_register(r->pool, obj, decrement_refcount,
                               apr_pool_cleanup_null);
 
     /* Populate the cache handle */
@@ -447,18 +447,18 @@ static int create_entity(cache_handle_t *h, cache_type_e type_e,
 }
 
 static int create_mem_entity(cache_handle_t *h, request_rec *r,
-                             const char *key, apr_off_t len) 
+                             const char *key, apr_off_t len)
 {
     return create_entity(h, CACHE_TYPE_HEAP, r, key, len);
 }
 
 static int create_fd_entity(cache_handle_t *h, request_rec *r,
-                            const char *key, apr_off_t len) 
+                            const char *key, apr_off_t len)
 {
     return create_entity(h, CACHE_TYPE_FILE, r, key, len);
 }
 
-static int open_entity(cache_handle_t *h, request_rec *r, const char *key) 
+static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
 {
     cache_object_t *obj;
 
@@ -475,7 +475,7 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
             cache_update(sconf->cache_cache, obj);
 
             /* If this is a subrequest, register the cleanup against
-             * the main request. This will prevent the cache object 
+             * the main request. This will prevent the cache object
              * from being cleaned up from under the request after the
              * subrequest is destroyed.
              */
@@ -507,13 +507,13 @@ static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
 }
 
 /* remove_entity()
- * Notes: 
+ * Notes:
  *   refcount should be at least 1 upon entry to this function to account
  *   for this thread's reference to the object. If the refcount is 1, then
  *   object has been removed from the cache by another thread and this thread
  *   is the last thread accessing the object.
  */
-static int remove_entity(cache_handle_t *h) 
+static int remove_entity(cache_handle_t *h)
 {
     cache_object_t *obj = h->cache_obj;
     cache_object_t *tobj = NULL;
@@ -524,7 +524,7 @@ static int remove_entity(cache_handle_t *h)
 
     /* If the entity is still in the cache, remove it and decrement the
      * refcount. If the entity is not in the cache, do nothing. In both cases
-     * decrement_refcount called by the last thread referencing the object will 
+     * decrement_refcount called by the last thread referencing the object will
      * trigger the cleanup.
      */
     tobj = cache_find(sconf->cache_cache, obj->key);
@@ -532,15 +532,15 @@ static int remove_entity(cache_handle_t *h)
         cache_remove(sconf->cache_cache, obj);
         apr_atomic_dec32(&obj->refcount);
     }
-    
+
     if (sconf->lock) {
         apr_thread_mutex_unlock(sconf->lock);
     }
 
     return OK;
 }
-static apr_status_t serialize_table(cache_header_tbl_t **obj, 
-                                    apr_ssize_t *nelts, 
+static apr_status_t serialize_table(cache_header_tbl_t **obj,
+                                    apr_ssize_t *nelts,
                                     apr_table_t *table)
 {
     const apr_array_header_t *elts_arr = apr_table_elts(table);
@@ -549,7 +549,7 @@ static apr_status_t serialize_table(cache_header_tbl_t **obj,
     apr_size_t len = 0;
     apr_size_t idx = 0;
     char *buf;
-   
+
     *nelts = elts_arr->nelts;
     if (*nelts == 0 ) {
         *obj=NULL;
@@ -586,15 +586,15 @@ static apr_status_t serialize_table(cache_header_tbl_t **obj,
     }
     return APR_SUCCESS;
 }
-static int unserialize_table( cache_header_tbl_t *ctbl, 
-                              int num_headers, 
+static int unserialize_table( cache_header_tbl_t *ctbl,
+                              int num_headers,
                               apr_table_t *t )
 {
     int i;
 
     for (i = 0; i < num_headers; ++i) {
         apr_table_addn(t, ctbl[i].hdr, ctbl[i].val);
-    } 
+    }
 
     return APR_SUCCESS;
 }
@@ -602,7 +602,7 @@ static int unserialize_table( cache_header_tbl_t *ctbl,
 /* remove_url()
  * Notes:
  */
-static int remove_url(cache_handle_t *h, apr_pool_t *p) 
+static int remove_url(cache_handle_t *h, apr_pool_t *p)
 {
     cache_object_t *obj;
     int cleanup = 0;
@@ -610,8 +610,8 @@ static int remove_url(cache_handle_t *h, apr_pool_t *p)
     if (sconf->lock) {
         apr_thread_mutex_lock(sconf->lock);
     }
- 
-    obj = h->cache_obj; 
+
+    obj = h->cache_obj;
     if (obj) {
         cache_remove(sconf->cache_cache, obj);
         /* For performance, cleanup cache object after releasing the lock */
@@ -628,11 +628,11 @@ static int remove_url(cache_handle_t *h, apr_pool_t *p)
     return OK;
 }
 
-static apr_status_t recall_headers(cache_handle_t *h, request_rec *r) 
+static apr_status_t recall_headers(cache_handle_t *h, request_rec *r)
 {
     int rc;
     mem_cache_object_t *mobj = (mem_cache_object_t*) h->cache_obj->vobj;
- 
+
     h->req_hdrs = apr_table_make(r->pool, mobj->num_req_hdrs);
     h->resp_hdrs = apr_table_make(r->pool, mobj->num_header_out);
 
@@ -643,7 +643,7 @@ static apr_status_t recall_headers(cache_handle_t *h, request_rec *r)
     return rc;
 }
 
-static apr_status_t recall_body(cache_handle_t *h, apr_pool_t *p, apr_bucket_brigade *bb) 
+static apr_status_t recall_body(cache_handle_t *h, apr_pool_t *p, apr_bucket_brigade *bb)
 {
     apr_bucket *b;
     mem_cache_object_t *mobj = (mem_cache_object_t*) h->cache_obj->vobj;
@@ -674,10 +674,10 @@ static apr_status_t store_headers(cache_handle_t *h, request_rec *r, cache_info
     apr_table_t *headers_out;
 
     /*
-     * The cache needs to keep track of the following information: 
-     * - Date, LastMod, Version, ReqTime, RespTime, ContentLength 
-     * - The original request headers (for Vary) 
-     * - The original response headers (for returning with a cached response) 
+     * The cache needs to keep track of the following information:
+     * - Date, LastMod, Version, ReqTime, RespTime, ContentLength
+     * - The original request headers (for Vary)
+     * - The original response headers (for returning with a cached response)
      * - The body of the message
      */
     rc = serialize_table(&mobj->req_hdrs,
@@ -716,7 +716,7 @@ static apr_status_t store_headers(cache_handle_t *h, request_rec *r, cache_info
     return APR_SUCCESS;
 }
 
-static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b) 
+static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b)
 {
     apr_status_t rv;
     cache_object_t *obj = h->cache_obj;
@@ -779,10 +779,10 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_bri
         mobj->type = CACHE_TYPE_HEAP;
     }
 
-    /* 
+    /*
      * FD cacheing is not enabled or the content was not
      * suitable for fd caching.
-     */  
+     */
     if (mobj->m == NULL) {
         mobj->m = malloc(mobj->m_len);
         if (mobj->m == NULL) {
@@ -802,8 +802,8 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_bri
 
         if (APR_BUCKET_IS_EOS(e)) {
             if (mobj->m_len > obj->count) {
-                /* Caching a streamed response. Reallocate a buffer of the 
-                 * correct size and copy the streamed response into that 
+                /* Caching a streamed response. Reallocate a buffer of the
+                 * correct size and copy the streamed response into that
                  * buffer */
                 char *buf = malloc(obj->count);
                 if (!buf) {
@@ -815,7 +815,7 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_bri
 
                 /* Now comes the crufty part... there is no way to tell the
                  * cache that the size of the object has changed. We need
-                 * to remove the object, update the size and re-add the 
+                 * to remove the object, update the size and re-add the
                  * object, all under protection of the lock.
                  */
                 if (sconf->lock) {
@@ -831,14 +831,14 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_bri
                     cache_remove(sconf->cache_cache, obj);
                     /* For illustration, cache no longer has reference to the object
                      * so decrement the refcount
-                     * apr_atomic_dec32(&obj->refcount); 
+                     * apr_atomic_dec32(&obj->refcount);
                      */
                     mobj->m_len = obj->count;
 
                     cache_insert(sconf->cache_cache, obj);
                     /* For illustration, cache now has reference to the object, so
                      * increment the refcount
-                     * apr_atomic_inc32(&obj->refcount); 
+                     * apr_atomic_inc32(&obj->refcount);
                      */
                 }
                 else if (tobj) {
@@ -851,7 +851,7 @@ static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_bri
                     /* Object has been ejected from the cache, add it back to the cache */
                     mobj->m_len = obj->count;
                     cache_insert(sconf->cache_cache, obj);
-                    apr_atomic_inc32(&obj->refcount); 
+                    apr_atomic_inc32(&obj->refcount);
                 }
 
                 if (sconf->lock) {
@@ -906,7 +906,7 @@ static int mem_cache_post_config(apr_pool_t *p, apr_pool_t *plog,
         return DONE;
     }
     if (sconf->max_streaming_buffer_size > sconf->max_cache_object_size) {
-        /* Issue a notice only if something other than the default config 
+        /* Issue a notice only if something other than the default config
          * is being used */
         if (sconf->max_streaming_buffer_size != DEFAULT_MAX_STREAMING_BUFFER_SIZE &&
             sconf->max_cache_object_size != DEFAULT_MAX_CACHE_OBJECT_SIZE) {
@@ -928,7 +928,7 @@ static int mem_cache_post_config(apr_pool_t *p, apr_pool_t *plog,
     }
 
     sconf->cache_cache = cache_init(sconf->max_object_cnt,
-                                    sconf->max_cache_size,                                   
+                                    sconf->max_cache_size,
                                     memcache_get_priority,
                                     sconf->cache_remove_algorithm,
                                     memcache_get_pos,
@@ -945,8 +945,8 @@ static int mem_cache_post_config(apr_pool_t *p, apr_pool_t *plog,
     return -1;
 
 }
- 
-static const char 
+
+static const char
 *set_max_cache_size(cmd_parms *parms, void *in_struct_ptr, const char *arg)
 {
     apr_size_t val;
@@ -957,7 +957,7 @@ static const char
     sconf->max_cache_size = val*1024;
     return NULL;
 }
-static const char 
+static const char
 *set_min_cache_object_size(cmd_parms *parms, void *in_struct_ptr, const char *arg)
 {
     apr_size_t val;
@@ -968,7 +968,7 @@ static const char
     sconf->min_cache_object_size = val;
     return NULL;
 }
-static const char 
+static const char
 *set_max_cache_object_size(cmd_parms *parms, void *in_struct_ptr, const char *arg)
 {
     apr_size_t val;
@@ -979,7 +979,7 @@ static const char
     sconf->max_cache_object_size = val;
     return NULL;
 }
-static const char 
+static const char
 *set_max_object_count(cmd_parms *parms, void *in_struct_ptr, const char *arg)
 {
     apr_size_t val;
@@ -991,7 +991,7 @@ static const char
     return NULL;
 }
 
-static const char 
+static const char
 *set_cache_removal_algorithm(cmd_parms *parms, void *name, const char *arg)
 {
     if (strcasecmp("LRU", arg)) {
diff --git a/modules/dav/fs/dbm.c b/modules/dav/fs/dbm.c
index f2d0511..9d61908 100644
--- a/modules/dav/fs/dbm.c
+++ b/modules/dav/fs/dbm.c
@@ -129,13 +129,13 @@ dav_error * dav_dbm_open_direct(apr_pool_t *p, const char *pathname, int ro,
     *pdb = NULL;
 
     if ((status = apr_dbm_open(&file, pathname,
-                               ro ? APR_DBM_READONLY : APR_DBM_RWCREATE, 
+                               ro ? APR_DBM_READONLY : APR_DBM_RWCREATE,
                                APR_OS_DEFAULT, p))
                 != APR_SUCCESS
         && !ro) {
         /* ### do something with 'status' */
 
-        /* we can't continue if we couldn't open the file 
+        /* we can't continue if we couldn't open the file
            and we need to write */
         return dav_fs_dbm_error(NULL, p, status);
     }
diff --git a/modules/dav/fs/lock.c b/modules/dav/fs/lock.c
index d57ac39..4258a66 100644
--- a/modules/dav/fs/lock.c
+++ b/modules/dav/fs/lock.c
@@ -41,7 +41,7 @@
 
 /*
 ** LOCK DATABASES
-** 
+**
 ** Lockdiscovery information is stored in the single lock database specified
 ** by the DAVLockDB directive.  Information about this db is stored in the
 ** global server configuration.
@@ -107,7 +107,7 @@ struct dav_locktoken {
 
 /*
 ** We need to reliably size the fixed-length portion of
-** dav_lock_discovery; best to separate it into another 
+** dav_lock_discovery; best to separate it into another
 ** struct for a convenient sizeof, unless we pack lock_discovery.
 */
 typedef struct dav_lock_discovery_fixed
@@ -146,7 +146,7 @@ typedef struct dav_lock_indirect
 
 
 /*
-** Stored direct lock info - full lock_discovery length:  
+** Stored direct lock info - full lock_discovery length:
 ** prefix + Fixed length + lock token + 2 strings + 2 nulls (one for each string)
 */
 #define dav_size_direct(a)	(1 + sizeof(dav_lock_discovery_fixed) \
@@ -258,7 +258,7 @@ static dav_error * dav_fs_parse_locktoken(
                              "The opaquelocktoken has an incorrect format "
                              "and could not be parsed.");
     }
-    
+
     *locktoken_p = locktoken;
     return NULL;
 }
@@ -480,7 +480,7 @@ static dav_error * dav_fs_save_lock_record(dav_lockdb *lockdb, apr_datum_t key,
         (void) dav_dbm_delete(lockdb->info->db, key);
         return NULL;
     }
-                
+
     while(dp) {
         val.dsize += dav_size_direct(dp);
         dp = dp->next;
@@ -506,7 +506,7 @@ static dav_error * dav_fs_save_lock_record(dav_lockdb *lockdb, apr_datum_t key,
             *ptr++ = '\0';
         }
         else {
-            memcpy(ptr, dp->owner, strlen(dp->owner) + 1);	
+            memcpy(ptr, dp->owner, strlen(dp->owner) + 1);
             ptr += strlen(dp->owner) + 1;
         }
         if (dp->auth_user == NULL) {
@@ -588,7 +588,7 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, apr_datum_t key,
 
     if ((err = dav_dbm_fetch(lockdb->info->db, key, &val)) != NULL)
         return err;
-        
+
     if (!val.dsize)
         return NULL;
 
@@ -613,7 +613,7 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, apr_datum_t key,
 
             if (*(val.dptr + offset) == '\0') {
                 ++offset;
-            } 
+            }
             else {
                 dp->auth_user = apr_pstrdup(p, val.dptr + offset);
                 offset += strlen(dp->auth_user) + 1;
@@ -655,7 +655,7 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, apr_datum_t key,
             offset += sizeof(ip->timeout);
             memcpy(&ip->key.dsize, val.dptr + offset, sizeof(ip->key.dsize)); /* length of datum */
             offset += sizeof(ip->key.dsize);
-            ip->key.dptr = apr_palloc(p, ip->key.dsize); 
+            ip->key.dptr = apr_palloc(p, ip->key.dsize);
             memcpy(ip->key.dptr, val.dptr + offset, ip->key.dsize);
             offset += ip->key.dsize;
 
@@ -710,7 +710,7 @@ static dav_error * dav_fs_resolve(dav_lockdb *lockdb,
     dav_error *err;
     dav_lock_discovery *dir;
     dav_lock_indirect *ind;
-        
+
     if ((err = dav_fs_load_lock_record(lockdb, indirect->key,
                                        DAV_CREATE_LIST,
                                        &dir, &ind)) != NULL) {
@@ -721,7 +721,7 @@ static dav_error * dav_fs_resolve(dav_lockdb *lockdb,
         *ref_dp = dir;
         *ref_ip = ind;
     }
-                
+
     for (; dir != NULL; dir = dir->next) {
         if (!dav_compare_locktoken(indirect->locktoken, dir->locktoken)) {
             *direct = dir;
@@ -783,7 +783,7 @@ static const char *dav_fs_get_supportedlock(const dav_resource *resource)
 **    for the given directory.
 */
 static dav_error * dav_fs_load_locknull_list(apr_pool_t *p, const char *dirpath,
-                                             dav_buffer *pbuf) 
+                                             dav_buffer *pbuf)
 {
     apr_finfo_t finfo;
     apr_file_t *file = NULL;
@@ -888,7 +888,7 @@ static dav_error * dav_fs_save_locknull_list(apr_pool_t *p, const char *dirpath,
         || amt != pbuf->cur_len) {
         err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
                             apr_psprintf(p,
-                                        "Error writing %" APR_SIZE_T_FMT 
+                                        "Error writing %" APR_SIZE_T_FMT
                                         " bytes to %s",
                                         pbuf->cur_len, pathname));
     }
diff --git a/modules/dav/fs/repos.c b/modules/dav/fs/repos.c
index 039b7a6..f288399 100644
--- a/modules/dav/fs/repos.c
+++ b/modules/dav/fs/repos.c
@@ -183,7 +183,7 @@ struct dav_stream {
     const char *pathname;       /* we may need to remove it at close time */
 };
 
-/* returns an appropriate HTTP status code given an APR status code for a 
+/* returns an appropriate HTTP status code given an APR status code for a
  * failed I/O operation.  ### use something besides 500? */
 #define MAP_IO2HTTP(e) (APR_STATUS_IS_ENOSPC(e) ? HTTP_INSUFFICIENT_STORAGE : \
                         HTTP_INTERNAL_SERVER_ERROR)
@@ -232,7 +232,7 @@ dav_error * dav_fs_dir_file_name(
         if (dirlen > 0) {
             rv = apr_filepath_root(&rootpath, &testpath, 0, ctx->pool);
         }
-        
+
         /* remove trailing slash from dirpath, unless it's a root path
          */
         if ((rv == APR_SUCCESS && testpath && *testpath)
@@ -241,7 +241,7 @@ dav_error * dav_fs_dir_file_name(
                 dirpath[dirlen - 1] = '\0';
             }
         }
-        
+
         /* ###: Looks like a response could be appropriate
          *
          * APR_SUCCESS     here tells us the dir is a root
@@ -272,7 +272,7 @@ dav_error * dav_fs_dir_file_name(
 static void dav_format_time(int style, apr_time_t sec, char *buf)
 {
     apr_time_exp_t tms;
-    
+
     /* ### what to do if fails? */
     (void) apr_time_exp_gmt(&tms, sec);
 
@@ -330,14 +330,14 @@ static dav_error * dav_fs_copymove_file(
                                      "Could not set permissions on destination");
             }
         }
-    } 
+    }
     else {
         perms = APR_OS_DEFAULT;
     }
 
     dav_set_bufsize(p, pbuf, DAV_FS_COPY_BLOCKSIZE);
 
-    if ((apr_file_open(&inf, src, APR_READ | APR_BINARY, APR_OS_DEFAULT, p)) 
+    if ((apr_file_open(&inf, src, APR_READ | APR_BINARY, APR_OS_DEFAULT, p))
             != APR_SUCCESS) {
         /* ### use something besides 500? */
         return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -345,7 +345,7 @@ static dav_error * dav_fs_copymove_file(
     }
 
     /* ### do we need to deal with the umask? */
-    status = apr_file_open(&outf, dst, APR_WRITE | APR_CREATE | APR_TRUNCATE 
+    status = apr_file_open(&outf, dst, APR_WRITE | APR_CREATE | APR_TRUNCATE
                            | APR_BINARY, perms, p);
     if (status != APR_SUCCESS) {
         apr_file_close(inf);
@@ -361,7 +361,7 @@ static dav_error * dav_fs_copymove_file(
         if (status != APR_SUCCESS && status != APR_EOF) {
             apr_file_close(inf);
             apr_file_close(outf);
-            
+
             if (apr_file_remove(dst, p) != APR_SUCCESS) {
                 /* ### ACK! Inconsistent state... */
 
@@ -750,7 +750,7 @@ static dav_error * dav_fs_get_parent_resource(const dav_resource *resource,
      */
     testpath = ctx->pathname;
     rv = apr_filepath_root(&testroot, &testpath, 0, ctx->pool);
-    if ((rv != APR_SUCCESS && rv != APR_ERELATIVE) 
+    if ((rv != APR_SUCCESS && rv != APR_ERELATIVE)
         || !testpath || !*testpath) {
         *result_parent = NULL;
         return NULL;
@@ -765,7 +765,7 @@ static dav_error * dav_fs_get_parent_resource(const dav_resource *resource,
     parent_ctx->pool = ctx->pool;
 
     dirpath = ap_make_dirstr_parent(ctx->pool, ctx->pathname);
-    if (strlen(dirpath) > 1 && dirpath[strlen(dirpath) - 1] == '/') 
+    if (strlen(dirpath) > 1 && dirpath[strlen(dirpath) - 1] == '/')
         dirpath[strlen(dirpath) - 1] = '\0';
     parent_ctx->pathname = dirpath;
 
@@ -782,7 +782,7 @@ static dav_error * dav_fs_get_parent_resource(const dav_resource *resource,
         parent_resource->uri = uri;
     }
 
-    rv = apr_stat(&parent_ctx->finfo, parent_ctx->pathname, 
+    rv = apr_stat(&parent_ctx->finfo, parent_ctx->pathname,
                   APR_FINFO_NORM, ctx->pool);
     if (rv == APR_SUCCESS || rv == APR_INCOMPLETE) {
         parent_resource->exists = 1;
@@ -1056,9 +1056,9 @@ static dav_error * dav_fs_copymove_walker(dav_walk_resource *wres,
         }
     }
     else {
-        err = dav_fs_copymove_file(ctx->is_move, ctx->pool, 
-                                   srcinfo->pathname, dstinfo->pathname, 
-                                   &srcinfo->finfo, 
+        err = dav_fs_copymove_file(ctx->is_move, ctx->pool,
+                                   srcinfo->pathname, dstinfo->pathname,
+                                   &srcinfo->finfo,
                                    ctx->res_dst->exists ? &dstinfo->finfo : NULL,
                                    &ctx->work_buf);
         /* ### push a higher-level description? */
@@ -1141,13 +1141,13 @@ static dav_error *dav_fs_copymove_resource(
     /* not a collection */
     if ((err = dav_fs_copymove_file(is_move, src->info->pool,
                                     src->info->pathname, dst->info->pathname,
-                                    &src->info->finfo, 
+                                    &src->info->finfo,
                                     dst->exists ? &dst->info->finfo : NULL,
                                     &work_buf)) != NULL) {
         /* ### push a higher-level description? */
         return err;
     }
-        
+
     /* copy/move properties as well */
     return dav_fs_copymoveset(is_move, src->info->pool, src, dst, &work_buf);
 }
@@ -1223,10 +1223,10 @@ static dav_error * dav_fs_move_resource(
          * so try it
          */
         dirpath = ap_make_dirstr_parent(dstinfo->pool, dstinfo->pathname);
-        /* 
+        /*
          * XXX: If missing dev ... then what test?
          * Really need a try and failover for those platforms.
-         * 
+         *
          */
         rv = apr_stat(&finfo, dirpath, APR_FINFO_DEV, dstinfo->pool);
         if ((rv == APR_SUCCESS || rv == APR_INCOMPLETE)
@@ -1456,7 +1456,7 @@ static dav_error * dav_fs_walker(dav_fs_walker_context *fsctx, int depth)
         len = strlen(dirent.name);
 
         /* avoid recursing into our current, parent, or state directories */
-        if (dirent.name[0] == '.' 
+        if (dirent.name[0] == '.'
               && (len == 1 || (dirent.name[1] == '.' && len == 2))) {
             continue;
         }
@@ -1481,7 +1481,7 @@ static dav_error * dav_fs_walker(dav_fs_walker_context *fsctx, int depth)
 
 
         /* ### Optimize me, dirent can give us what we need! */
-        status = apr_stat(&fsctx->info1.finfo, fsctx->path1.buf, 
+        status = apr_stat(&fsctx->info1.finfo, fsctx->path1.buf,
                           APR_FINFO_NORM | APR_FINFO_LINK, pool);
         if (status != APR_SUCCESS && status != APR_INCOMPLETE) {
             /* woah! where'd it go? */
@@ -1611,7 +1611,7 @@ static dav_error * dav_fs_walker(dav_fs_walker_context *fsctx, int depth)
             ** resource, query the lock database to force removal
             ** of both the lock entry and .locknull, if necessary..
             ** Sure, the query in PROPFIND would do this.. after
-            ** the locknull resource was already included in the 
+            ** the locknull resource was already included in the
             ** return.
             **
             ** NOTE: we assume the caller has opened the lock database
@@ -1773,7 +1773,7 @@ static const char *dav_fs_getetag(const dav_resource *resource)
 {
     dav_resource_private *ctx = resource->info;
 
-    if (!resource->exists) 
+    if (!resource->exists)
         return apr_pstrdup(ctx->pool, "");
 
     if (ctx->finfo.filetype != 0) {
diff --git a/modules/dav/lock/locks.c b/modules/dav/lock/locks.c
index a9eefee..4abd4ad 100644
--- a/modules/dav/lock/locks.c
+++ b/modules/dav/lock/locks.c
@@ -418,7 +418,7 @@ static apr_datum_t dav_generic_build_key(apr_pool_t *p,
 }
 
 /*
- * dav_generic_lock_expired:  return 1 (true) if the given timeout is in the 
+ * dav_generic_lock_expired:  return 1 (true) if the given timeout is in the
  *    past or present (the lock has expired), or 0 (false) if in the future
  *    (the lock has not yet expired).
  */
@@ -647,7 +647,7 @@ static dav_error * dav_generic_load_lock_record(dav_lockdb *lockdb,
             /* length of datum */
             ip->key.dsize = *((int *) (val.dptr + offset));
             offset += sizeof(ip->key.dsize);
-            ip->key.dptr = apr_palloc(p, ip->key.dsize); 
+            ip->key.dptr = apr_palloc(p, ip->key.dsize);
             memcpy(ip->key.dptr, val.dptr + offset, ip->key.dsize);
             offset += ip->key.dsize;
 
diff --git a/modules/dav/main/liveprop.c b/modules/dav/main/liveprop.c
index 15c72cb..cedae06 100644
--- a/modules/dav/main/liveprop.c
+++ b/modules/dav/main/liveprop.c
@@ -128,7 +128,7 @@ DAV_DECLARE(long) dav_get_liveprop_info(int propid,
     return 0;
 }
 
-DAV_DECLARE(void) dav_register_liveprop_group(apr_pool_t *p, 
+DAV_DECLARE(void) dav_register_liveprop_group(apr_pool_t *p,
                                               const dav_liveprop_group *group)
 {
     /* register the namespace URIs */
diff --git a/modules/dav/main/mod_dav.c b/modules/dav/main/mod_dav.c
index 937aead..d1ca371 100644
--- a/modules/dav/main/mod_dav.c
+++ b/modules/dav/main/mod_dav.c
@@ -440,13 +440,13 @@ static void dav_send_one_response(dav_response *response,
       }
       ap_fputc(output, bb, '>');
     }
-    
+
     ap_fputstrs(output, bb,
                 DEBUG_CR "<D:href>",
                 dav_xml_escape_uri(pool, response->href),
                 "</D:href>" DEBUG_CR,
                 NULL);
-    
+
     if (response->propresult.propstats == NULL) {
       /* use the Status-Line text from Apache.  Note, this will
        * default to 500 Internal Server Error if first->status
@@ -464,7 +464,7 @@ static void dav_send_one_response(dav_response *response,
         ap_fputs(output, bb, t->text);
       }
     }
-    
+
     if (response->desc != NULL) {
       /*
        * We supply the description, so we know it doesn't have to
@@ -476,7 +476,7 @@ static void dav_send_one_response(dav_response *response,
                   "</D:responsedescription>" DEBUG_CR,
                   NULL);
     }
-    
+
     ap_fputs(output, bb, "</D:response>" DEBUG_CR);
 }
 
@@ -514,9 +514,9 @@ static apr_status_t dav_finish_multistatus(request_rec *r,
                                            apr_bucket_brigade *bb)
 {
     apr_bucket *b;
-    
+
     ap_fputs(r->output_filters, bb, "</D:multistatus>" DEBUG_CR);
-    
+
     /* indicate the end of the response body */
     b = apr_bucket_eos_create(r->connection->bucket_alloc);
     APR_BRIGADE_INSERT_TAIL(bb, b);
@@ -1437,7 +1437,7 @@ static dav_error *dav_gen_supported_reports(request_rec *r,
             if (elem->first_child == NULL) {
                 /* show all supported reports */
                 for (rp = reports; rp->nmspace != NULL; ++rp) {
-                    /* Note: we presume reports->namespace is 
+                    /* Note: we presume reports->namespace is
                      * properly XML/URL quoted */
                     s = apr_psprintf(r->pool,
                                      "<D:supported-report D:name=\"%s\" "
@@ -1478,7 +1478,7 @@ static dav_error *dav_gen_supported_reports(request_rec *r,
                             if (strcmp(name, rp->name) == 0
                                 && strcmp(nmspace, rp->nmspace) == 0) {
                                 /* Note: we presume reports->nmspace is
-                                 * properly XML/URL quoted 
+                                 * properly XML/URL quoted
                                  */
                                 s = apr_psprintf(r->pool,
                                                  "<D:supported-report "
@@ -4557,7 +4557,7 @@ static int dav_handler(request_rec *r)
     if (r->parsed_uri.fragment != NULL) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "buggy client used un-escaped hash in Request-URI");
-        return dav_error_response(r, HTTP_BAD_REQUEST, 
+        return dav_error_response(r, HTTP_BAD_REQUEST,
                                   "The request was invalid: the URI included "
                                   "an un-escaped hash character");
     }
@@ -4769,7 +4769,7 @@ static int dav_fixups(request_rec *r)
     /* ### this is wrong.  We should only be setting the r->handler for the
      * requests that mod_dav knows about.  If we set the handler for M_POST
      * requests, then CGI scripts that use POST will return the source for the
-     * script.  However, mod_dav DOES handle POST, so something else needs 
+     * script.  However, mod_dav DOES handle POST, so something else needs
      * to be fixed.
      */
     if (r->method_number != M_POST) {
diff --git a/modules/dav/main/util.c b/modules/dav/main/util.c
index c60fc26..ce77f2a 100644
--- a/modules/dav/main/util.c
+++ b/modules/dav/main/util.c
@@ -33,7 +33,7 @@
 #include "http_log.h"
 #include "http_protocol.h"
 
-DAV_DECLARE(dav_error*) dav_new_error(apr_pool_t *p, int status, 
+DAV_DECLARE(dav_error*) dav_new_error(apr_pool_t *p, int status,
                                       int error_id, const char *desc)
 {
     int save_errno = errno;
@@ -49,7 +49,7 @@ DAV_DECLARE(dav_error*) dav_new_error(apr_pool_t *p, int status,
     return err;
 }
 
-DAV_DECLARE(dav_error*) dav_new_error_tag(apr_pool_t *p, int status, 
+DAV_DECLARE(dav_error*) dav_new_error_tag(apr_pool_t *p, int status,
                                           int error_id, const char *desc,
                                           const char *namespace,
                                           const char *tagname)
@@ -63,8 +63,8 @@ DAV_DECLARE(dav_error*) dav_new_error_tag(apr_pool_t *p, int status,
 }
 
 
-DAV_DECLARE(dav_error*) dav_push_error(apr_pool_t *p, int status, 
-                                       int error_id, const char *desc, 
+DAV_DECLARE(dav_error*) dav_push_error(apr_pool_t *p, int status,
+                                       int error_id, const char *desc,
                                        dav_error *prev)
 {
     dav_error *err = apr_pcalloc(p, sizeof(*err));
@@ -77,7 +77,7 @@ DAV_DECLARE(dav_error*) dav_push_error(apr_pool_t *p, int status,
     return err;
 }
 
-DAV_DECLARE(void) dav_check_bufsize(apr_pool_t * p, dav_buffer *pbuf, 
+DAV_DECLARE(void) dav_check_bufsize(apr_pool_t * p, dav_buffer *pbuf,
                                     apr_size_t extra_needed)
 {
     /* grow the buffer if necessary */
@@ -91,7 +91,7 @@ DAV_DECLARE(void) dav_check_bufsize(apr_pool_t * p, dav_buffer *pbuf,
     }
 }
 
-DAV_DECLARE(void) dav_set_bufsize(apr_pool_t * p, dav_buffer *pbuf, 
+DAV_DECLARE(void) dav_set_bufsize(apr_pool_t * p, dav_buffer *pbuf,
                                   apr_size_t size)
 {
     /* NOTE: this does not retain prior contents */
@@ -113,7 +113,7 @@ DAV_DECLARE(void) dav_set_bufsize(apr_pool_t * p, dav_buffer *pbuf,
 
 
 /* initialize a buffer and copy the specified (null-term'd) string into it */
-DAV_DECLARE(void) dav_buffer_init(apr_pool_t *p, dav_buffer *pbuf, 
+DAV_DECLARE(void) dav_buffer_init(apr_pool_t *p, dav_buffer *pbuf,
                                   const char *str)
 {
     dav_set_bufsize(p, pbuf, strlen(str));
@@ -121,7 +121,7 @@ DAV_DECLARE(void) dav_buffer_init(apr_pool_t *p, dav_buffer *pbuf,
 }
 
 /* append a string to the end of the buffer, adjust length */
-DAV_DECLARE(void) dav_buffer_append(apr_pool_t *p, dav_buffer *pbuf, 
+DAV_DECLARE(void) dav_buffer_append(apr_pool_t *p, dav_buffer *pbuf,
                                     const char *str)
 {
     apr_size_t len = strlen(str);
@@ -132,7 +132,7 @@ DAV_DECLARE(void) dav_buffer_append(apr_pool_t *p, dav_buffer *pbuf,
 }
 
 /* place a string on the end of the buffer, do NOT adjust length */
-DAV_DECLARE(void) dav_buffer_place(apr_pool_t *p, dav_buffer *pbuf, 
+DAV_DECLARE(void) dav_buffer_place(apr_pool_t *p, dav_buffer *pbuf,
                                    const char *str)
 {
     apr_size_t len = strlen(str);
@@ -142,8 +142,8 @@ DAV_DECLARE(void) dav_buffer_place(apr_pool_t *p, dav_buffer *pbuf,
 }
 
 /* place some memory on the end of a buffer; do NOT adjust length */
-DAV_DECLARE(void) dav_buffer_place_mem(apr_pool_t *p, dav_buffer *pbuf, 
-                                       const void *mem, apr_size_t amt, 
+DAV_DECLARE(void) dav_buffer_place_mem(apr_pool_t *p, dav_buffer *pbuf,
+                                       const void *mem, apr_size_t amt,
                                        apr_size_t pad)
 {
     dav_check_bufsize(p, pbuf, amt + pad);
@@ -237,7 +237,7 @@ DAV_DECLARE(dav_lookup_result) dav_lookup_uri(const char *uri,
     /* we have verified the scheme, port, and general structure */
 
     /*
-    ** Hrm.  IE5 will pass unqualified hostnames for both the 
+    ** Hrm.  IE5 will pass unqualified hostnames for both the
     ** Host: and Destination: headers.  This breaks the
     ** http_vhost.c::matches_aliases function.
     **
@@ -297,7 +297,7 @@ DAV_DECLARE(int) dav_validate_root(const apr_xml_doc *doc,
 }
 
 /* find and return the (unique) child with a given DAV: tagname */
-DAV_DECLARE(apr_xml_elem *) dav_find_child(const apr_xml_elem *elem, 
+DAV_DECLARE(apr_xml_elem *) dav_find_child(const apr_xml_elem *elem,
                                            const char *tagname)
 {
     apr_xml_elem *child = elem->first_child;
@@ -533,7 +533,7 @@ static dav_error * dav_add_if_state(apr_pool_t *p, dav_if_header *ih,
 
     new_sl->condition = condition;
     new_sl->type      = t;
-    
+
     if (t == dav_if_opaquelock) {
         dav_error *err;
 
@@ -568,7 +568,7 @@ static char *dav_fetch_next_token(char **str, char term)
 {
     char *sp;
     char *token;
-        
+
     token = *str + 1;
 
     while (*token && (*token == ' ' || *token == '\t'))
@@ -604,7 +604,7 @@ static dav_error * dav_process_if_header(request_rec *r, dav_if_header **p_ih)
     const dav_hooks_locks *locks_hooks = DAV_GET_HOOKS_LOCKS(r);
     enum {no_tagged, tagged, unknown} list_type = unknown;
     int condition;
-        
+
     *p_ih = NULL;
 
     if ((str = apr_pstrdup(r->pool, apr_table_get(r->headers_in, "If"))) == NULL)
@@ -621,7 +621,7 @@ static dav_error * dav_process_if_header(request_rec *r, dav_if_header **p_ih)
                                      "Invalid If-header: unclosed \"<\" or "
                                      "unexpected tagged-list production.");
             }
-            
+
             /* 2518 specifies this must be an absolute URI; just take the
              * relative part for later comparison against r->uri */
             if (apr_uri_parse(r->pool, uri, &parsed_uri) != APR_SUCCESS) {
@@ -876,14 +876,14 @@ static dav_error * dav_validate_resource_state(apr_pool_t *p,
         /* lock_list now determines whether we're in State 1, 2, or 3. */
     }
 
-    /* 
+    /*
     ** For a new, exclusive lock: if any locks exist, fail.
     ** For a new, shared lock:    if an exclusive lock exists, fail.
     **                            else, do not require a token to be seen.
     */
     if (flags & DAV_LOCKSCOPE_EXCLUSIVE) {
         if (lock_list != NULL) {
-            return dav_new_error(p, HTTP_LOCKED, 0, 
+            return dav_new_error(p, HTTP_LOCKED, 0,
                                  "Existing lock(s) on the requested resource "
                                  "prevent an exclusive lock.");
         }
@@ -1160,13 +1160,13 @@ static dav_error * dav_validate_resource_state(apr_pool_t *p,
                     ** the lock, only the same user may submit that locktoken
                     ** to manipulate a resource.
                     */
-                    if (lock->auth_user && 
+                    if (lock->auth_user &&
                         (!r->user ||
                          strcmp(lock->auth_user, r->user))) {
                         const char *errmsg;
 
                         errmsg = apr_pstrcat(p, "User \"",
-                                            r->user, 
+                                            r->user,
                                             "\" submitted a locktoken created "
                                             "by user \"",
                                             lock->auth_user, "\".", NULL);
@@ -1204,9 +1204,9 @@ static dav_error * dav_validate_resource_state(apr_pool_t *p,
                 /* Request is predicated on some unknown state token,
                  * which must be presumed to *not* match, so fail
                  * unless this is a Not condition. */
-                
+
                 if (state_list->condition == DAV_IF_COND_NORMAL) {
-                    reason = 
+                    reason =
                         "an unknown state token was supplied";
                     goto state_list_failed;
                 }
@@ -1417,7 +1417,7 @@ static dav_error * dav_validate_walker(dav_walk_resource *wres, int calltype)
 ** On error, return appropriate HTTP_* code, and log error. If a multi-stat
 ** error is necessary, response will point to it, else NULL.
 */
-DAV_DECLARE(dav_error *) dav_validate_request(request_rec *r, 
+DAV_DECLARE(dav_error *) dav_validate_request(request_rec *r,
                                               dav_resource *resource,
                                               int depth,
                                               dav_locktoken *locktoken,
@@ -1449,7 +1449,7 @@ DAV_DECLARE(dav_error *) dav_validate_request(request_rec *r,
     if (response != NULL)
         *response = NULL;
 
-    /* Do the standard checks for conditional requests using 
+    /* Do the standard checks for conditional requests using
      * If-..-Since, If-Match etc */
     if ((result = ap_meets_conditions(r)) != OK) {
         /* ### fix this up... how? */
@@ -1545,7 +1545,7 @@ DAV_DECLARE(dav_error *) dav_validate_request(request_rec *r,
                                               if_header,
                                               flags | DAV_VALIDATE_IS_PARENT,
                                               &work_buf, r);
-            
+
             /*
             ** This error occurred on the parent resource. This implies that
             ** we have to create a multistatus response (to report the error
@@ -1554,7 +1554,7 @@ DAV_DECLARE(dav_error *) dav_validate_request(request_rec *r,
             */
             if (err != NULL) {
                 new_response = apr_pcalloc(r->pool, sizeof(*new_response));
-                
+
                 new_response->href = parent_resource->uri;
                 new_response->status = err->status;
                 new_response->desc =
@@ -1567,11 +1567,11 @@ DAV_DECLARE(dav_error *) dav_validate_request(request_rec *r,
                                                     " The error was: ",
                                                     err->desc, NULL);
                 }
-                
+
                 /* assert: DAV_VALIDATE_PARENT implies response != NULL */
                 new_response->next = *response;
                 *response = new_response;
-                
+
                 err = NULL;
             }
         }
@@ -1642,20 +1642,20 @@ DAV_DECLARE(dav_error *) dav_validate_request(request_rec *r,
  * else NULL if no If-header, or no positive locktokens.
  */
 DAV_DECLARE(dav_error *) dav_get_locktoken_list(request_rec *r,
-                                                dav_locktoken_list **ltl) 
+                                                dav_locktoken_list **ltl)
 {
     dav_error *err;
     dav_if_header *if_header;
     dav_if_state_list *if_state;
-    dav_locktoken_list *lock_token = NULL;                
-        
+    dav_locktoken_list *lock_token = NULL;
+
     *ltl = NULL;
 
     if ((err = dav_process_if_header(r, &if_header)) != NULL) {
         /* ### add a higher-level description? */
         return err;
     }
-                         
+
     while (if_header != NULL) {
         if_state = if_header->state;        /* Begining of the if_state linked list */
         while (if_state != NULL)        {
@@ -1666,7 +1666,7 @@ DAV_DECLARE(dav_error *) dav_get_locktoken_list(request_rec *r,
                 lock_token->next = *ltl;
                 *ltl = lock_token;
             }
-            if_state = if_state->next; 
+            if_state = if_state->next;
         }
         if_header = if_header->next;
     }
@@ -1750,7 +1750,7 @@ DAV_DECLARE(void) dav_add_vary_header(request_rec *in_req,
  * auto_checkout - set to 1 if auto-checkout enabled
  */
 static dav_error * dav_can_auto_checkout(
-    request_rec *r,                                         
+    request_rec *r,
     dav_resource *resource,
     dav_auto_version auto_version,
     dav_lockdb **lockdb,
diff --git a/modules/dav/main/util_lock.c b/modules/dav/main/util_lock.c
index cf960ef..6d50e1c 100644
--- a/modules/dav/main/util_lock.c
+++ b/modules/dav/main/util_lock.c
@@ -55,7 +55,7 @@ DAV_DECLARE(const char *) dav_lock_get_activelock(request_rec *r,
     /* If no locks or no lock provider, there are no locks */
     if (lock == NULL || hooks == NULL) {
         /*
-        ** Since resourcediscovery is defined with (activelock)*, 
+        ** Since resourcediscovery is defined with (activelock)*,
         ** <D:activelock/> shouldn't be necessary for an empty lock.
         */
         return "";
@@ -129,7 +129,7 @@ DAV_DECLARE(const char *) dav_lock_get_activelock(request_rec *r,
             */
             dav_buffer_append(p, pbuf, lock->owner);
         }
-                
+
         dav_buffer_append(p, pbuf, "<D:timeout>");
         if (lock->timeout == DAV_TIMEOUT_INFINITE) {
             dav_buffer_append(p, pbuf, "Infinite");
@@ -223,7 +223,7 @@ DAV_DECLARE(dav_error *) dav_lock_parse_lockinfo(request_rec *r,
             ** Store a full <DAV:owner> element with namespace definitions
             ** and an xml:lang definition, if applicable.
             */
-            apr_xml_to_text(p, child, APR_XML_X2T_FULL_NS_LANG, doc->namespaces, 
+            apr_xml_to_text(p, child, APR_XML_X2T_FULL_NS_LANG, doc->namespaces,
                             NULL, &text, NULL);
             lock->owner = text;
 
@@ -359,7 +359,7 @@ DAV_DECLARE(dav_error *) dav_add_lock(request_rec *r,
 ** dav_lock_query:  Opens the lock database. Returns a linked list of
 **    dav_lock structures for all direct locks on path.
 */
-DAV_DECLARE(dav_error*) dav_lock_query(dav_lockdb *lockdb, 
+DAV_DECLARE(dav_error*) dav_lock_query(dav_lockdb *lockdb,
                                        const dav_resource *resource,
                                        dav_lock **locks)
 {
@@ -507,7 +507,7 @@ DAV_DECLARE(int) dav_unlock(request_rec *r, const dav_resource *resource,
     /* 2518 requires the entire lock to be removed if resource/locktoken
      * point to an indirect lock.  We need resource of the _direct_
      * lock in order to walk down the tree and remove the locks.  So,
-     * If locktoken != null_locktoken, 
+     * If locktoken != null_locktoken,
      *    Walk up the resource hierarchy until we see a direct lock.
      *    Or, we could get the direct lock's db/key, pick out the URL
      *    and do a subrequest.  I think walking up is faster and will work
@@ -711,7 +711,7 @@ DAV_DECLARE(int) dav_get_resource_state(request_rec *r,
         if (r->path_info != NULL && *r->path_info != '\0') {
             return DAV_RESOURCE_NULL;
         }
-        
+
         if ((err = (*hooks->open_lockdb)(r, 1, 1, &lockdb)) == NULL) {
             /* note that we might see some expired locks... *shrug* */
             err = (*hooks->has_locks)(lockdb, resource, &locks_present);
diff --git a/modules/debug/mod_bucketeer.c b/modules/debug/mod_bucketeer.c
index 215617e..93b2e29 100644
--- a/modules/debug/mod_bucketeer.c
+++ b/modules/debug/mod_bucketeer.c
@@ -69,7 +69,7 @@ static apr_status_t bucketeer_out_filter(ap_filter_t *f,
     c = ap_get_module_config(r->server->module_config, &bucketeer_module);
 
     /* If have a context, it means we've done this before successfully. */
-    if (!ctx) {  
+    if (!ctx) {
         if (!r->content_type || strncmp(r->content_type, "text/", 5)) {
             ap_remove_output_filter(f);
             return ap_pass_brigade(f->next, bb);
@@ -77,7 +77,7 @@ static apr_status_t bucketeer_out_filter(ap_filter_t *f,
 
         /* We're cool with filtering this. */
         ctx = f->ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));
-        ctx->bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc); 
+        ctx->bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);
         apr_table_unset(f->r->headers_out, "Content-Length");
     }
 
@@ -98,9 +98,9 @@ static apr_status_t bucketeer_out_filter(ap_filter_t *f,
             return ap_pass_brigade(f->next, ctx->bb);
         }
 
-        if (APR_BUCKET_IS_FLUSH(e)) {     
+        if (APR_BUCKET_IS_FLUSH(e)) {
             /*
-             * Ignore flush buckets for the moment.. 
+             * Ignore flush buckets for the moment..
              * we decide what to stream
              */
             continue;
@@ -143,7 +143,7 @@ static apr_status_t bucketeer_out_filter(ap_filter_t *f,
                         ap_pass_brigade(f->next, ctx->bb);
                        /* apr_brigade_cleanup(ctx->bb);*/
                     }
-                }                       
+                }
             }
             /* XXX: really should append this to the next 'real' bucket */
             if (lastpos < i) {
@@ -157,7 +157,7 @@ static apr_status_t bucketeer_out_filter(ap_filter_t *f,
                 lastpos = i;
                 APR_BRIGADE_INSERT_TAIL(ctx->bb, p);
             }
-        }     
+        }
     }
 
     return APR_SUCCESS;
diff --git a/modules/debug/mod_dumpio.c b/modules/debug/mod_dumpio.c
index 997b701..2a27e98 100644
--- a/modules/debug/mod_dumpio.c
+++ b/modules/debug/mod_dumpio.c
@@ -47,7 +47,7 @@ typedef struct dumpio_conf_t {
 static void dumpit(ap_filter_t *f, apr_bucket *b)
 {
     conn_rec *c = f->c;
-    
+
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, c->base_server,
         "mod_dumpio:  %s (%s-%s): %" APR_SIZE_T_FMT " bytes",
                 f->frec->name,
@@ -91,7 +91,7 @@ static void dumpit(ap_filter_t *f, apr_bucket *b)
    (( mode ) == AP_MODE_EXHAUSTIVE) ? "exhaustive" : \
    (( mode ) == AP_MODE_INIT) ? "init" : "unknown" \
  )
-       
+
 static int dumpio_input_filter (ap_filter_t *f, apr_bucket_brigade *bb,
     ap_input_mode_t mode, apr_read_type_e block, apr_off_t readbytes)
 {
@@ -125,9 +125,9 @@ static int dumpio_output_filter (ap_filter_t *f, apr_bucket_brigade *bb)
 {
     apr_bucket *b;
     conn_rec *c = f->c;
-    
+
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, c->base_server, "mod_dumpio: %s", f->frec->name) ;
-    
+
     for (b = APR_BRIGADE_FIRST(bb); b != APR_BRIGADE_SENTINEL(bb); b = APR_BUCKET_NEXT(b)) {
         /*
          * If we ever see an EOS, make sure to FLUSH.
@@ -138,7 +138,7 @@ static int dumpio_output_filter (ap_filter_t *f, apr_bucket_brigade *bb)
         }
         dumpit(f, b);
     }
-    
+
     return ap_pass_brigade(f->next, bb) ;
 }
 
@@ -147,7 +147,7 @@ static int dumpio_pre_conn(conn_rec *c, void *csd)
     dumpio_conf_t *ptr =
     (dumpio_conf_t *) ap_get_module_config(c->base_server->module_config,
                                            &dumpio_module);
-    
+
     if (ptr->enable_input)
         ap_add_input_filter("DUMPIO_IN", NULL, NULL, c);
     if (ptr->enable_output)
@@ -181,7 +181,7 @@ static const char *dumpio_enable_input(cmd_parms *cmd, void *dummy, int arg)
     dumpio_conf_t *ptr =
     (dumpio_conf_t *) ap_get_module_config(cmd->server->module_config,
                                            &dumpio_module);
-    
+
     ptr->enable_input = arg;
     return NULL;
 }
@@ -191,7 +191,7 @@ static const char *dumpio_enable_output(cmd_parms *cmd, void *dummy, int arg)
     dumpio_conf_t *ptr =
     (dumpio_conf_t *) ap_get_module_config(cmd->server->module_config,
                                            &dumpio_module);
-    
+
     ptr->enable_output = arg;
     return NULL;
 }
diff --git a/modules/echo/mod_echo.c b/modules/echo/mod_echo.c
index 9d223f8..65b69a9 100644
--- a/modules/echo/mod_echo.c
+++ b/modules/echo/mod_echo.c
@@ -64,7 +64,7 @@ static int process_echo_connection(conn_rec *c)
 
         /* Get a single line of input from the client */
         if ((rv = ap_get_brigade(c->input_filters, bb, AP_MODE_GETLINE,
-                                 APR_BLOCK_READ, 0) != APR_SUCCESS || 
+                                 APR_BLOCK_READ, 0) != APR_SUCCESS ||
              APR_BRIGADE_EMPTY(bb))) {
             apr_brigade_destroy(bb);
             break;
@@ -81,7 +81,7 @@ static int process_echo_connection(conn_rec *c)
     return OK;
 }
 
-static const command_rec echo_cmds[] = 
+static const command_rec echo_cmds[] =
 {
     AP_INIT_FLAG("ProtocolEcho", echo_on, NULL, RSRC_CONF,
                  "Run an echo server on this host"),
diff --git a/modules/experimental/mod_case_filter.c b/modules/experimental/mod_case_filter.c
index 0c3938b..9eef27b 100644
--- a/modules/experimental/mod_case_filter.c
+++ b/modules/experimental/mod_case_filter.c
@@ -104,7 +104,7 @@ static const char *CaseFilterEnable(cmd_parms *cmd, void *dummy, int arg)
     return NULL;
     }
 
-static const command_rec CaseFilterCmds[] = 
+static const command_rec CaseFilterCmds[] =
     {
     AP_INIT_FLAG("CaseFilter", CaseFilterEnable, NULL, RSRC_CONF,
                  "Run a case filter on this host"),
diff --git a/modules/experimental/mod_case_filter_in.c b/modules/experimental/mod_case_filter_in.c
index 2b1d420..924feb4 100644
--- a/modules/experimental/mod_case_filter_in.c
+++ b/modules/experimental/mod_case_filter_in.c
@@ -120,8 +120,8 @@ static apr_status_t CaseFilterInFilter(ap_filter_t *f,
 
     return APR_SUCCESS;
 }
-            
-        
+
+
 static const char *CaseFilterInEnable(cmd_parms *cmd, void *dummy, int arg)
 {
     CaseFilterInConfig *pConfig
@@ -132,7 +132,7 @@ static const char *CaseFilterInEnable(cmd_parms *cmd, void *dummy, int arg)
     return NULL;
 }
 
-static const command_rec CaseFilterInCmds[] = 
+static const command_rec CaseFilterInCmds[] =
 {
     AP_INIT_FLAG("CaseFilterIn", CaseFilterInEnable, NULL, RSRC_CONF,
                  "Run an input case filter on this host"),
@@ -142,7 +142,7 @@ static const command_rec CaseFilterInCmds[] =
 
 static void CaseFilterInRegisterHooks(apr_pool_t *p)
 {
-    ap_hook_insert_filter(CaseFilterInInsertFilter, NULL, NULL, 
+    ap_hook_insert_filter(CaseFilterInInsertFilter, NULL, NULL,
                           APR_HOOK_MIDDLE);
     ap_register_input_filter(s_szCaseFilterName, CaseFilterInFilter, NULL,
                              AP_FTYPE_RESOURCE);
diff --git a/modules/experimental/mod_example.c b/modules/experimental/mod_example.c
index eab1ebd..dd7fd5b 100644
--- a/modules/experimental/mod_example.c
+++ b/modules/experimental/mod_example.c
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-/* 
+/*
  * Apache example module.  Provide demonstrations of how modules do things.
  * It is not meant to be used in a production server.  Since it participates
  * in all of the processing phases, it could conceivable interfere with
@@ -458,7 +458,7 @@ static void trace_add(server_rec *s, request_rec *r, x_cfg *mconfig,
 /* at it.  If it returns any other value, it's treated as the text of an    */
 /* error message.                                                           */
 /*--------------------------------------------------------------------------*/
-/* 
+/*
  * Command handler for the NO_ARGS "Example" directive.  All we do is mark the
  * call in the trace log, and flag the applicability of the directive to the
  * current location in that location's configuration record.
@@ -489,7 +489,7 @@ static const char *cmd_example(cmd_parms *cmd, void *mconfig)
 /* calling send_http_header().  Otherwise, no header will be sent at all,   */
 /* and the output sent to the client will actually be HTTP-uncompliant.     */
 /*--------------------------------------------------------------------------*/
-/* 
+/*
  * Sample content handler.  All this does is display the call list that has
  * been built up so far.
  *
@@ -627,7 +627,7 @@ static int x_handler(request_rec *r)
 /* see the individual handler comments below for details.                   */
 /*                                                                          */
 /*--------------------------------------------------------------------------*/
-/* 
+/*
  * This function is called during server initialisation.  Any information
  * that needs to be recorded must be in static cells, since there's no
  * configuration record.
@@ -635,7 +635,7 @@ static int x_handler(request_rec *r)
  * There is no return value.
  */
 
-/* 
+/*
  * This function is called when an heavy-weight process (such as a child) is
  * being run down or destroyed.  As with the child initialisation function,
  * any information that needs to be recorded must be in static cells, since
@@ -644,7 +644,7 @@ static int x_handler(request_rec *r)
  * There is no return value.
  */
 
-/* 
+/*
  * This function is called during server initialisation when an heavy-weight
  * process (such as a child) is being initialised.  As with the
  * module initialisation function, any information that needs to be recorded
@@ -1014,7 +1014,7 @@ static int x_pre_connection(conn_rec *c, void *csd)
  * some other protocol.  Both echo and POP3 modules are available as
  * examples.
  *
- * The return VALUE is OK, DECLINED, or HTTP_mumble.  If we return OK, no 
+ * The return VALUE is OK, DECLINED, or HTTP_mumble.  If we return OK, no
  * further modules are called for this phase.
  */
 static int x_process_connection(conn_rec *c)
@@ -1244,9 +1244,9 @@ static int x_logger(request_rec *r)
 /* Which functions are responsible for which hooks in the server.           */
 /*                                                                          */
 /*--------------------------------------------------------------------------*/
-/* 
+/*
  * Each function our module provides to handle a particular hook is
- * specified here.  The functions are registered using 
+ * specified here.  The functions are registered using
  * ap_hook_foo(name, predecessors, successors, position)
  * where foo is the name of the hook.
  *
@@ -1262,7 +1262,7 @@ static int x_logger(request_rec *r)
  *                 modules use the same relative position, Apache will
  *                 determine which to call first.
  *                 If your module relies on another module to run first,
- *                 or another module running after yours, use the 
+ *                 or another module running after yours, use the
  *                 predecessors and/or successors.
  *
  * The number in brackets indicates the order in which the routine is called
@@ -1309,7 +1309,7 @@ static void x_register_hooks(apr_pool_t *p)
 /* collisions of directive names between modules.                           */
 /*                                                                          */
 /*--------------------------------------------------------------------------*/
-/* 
+/*
  * List of directives specific to our module.
  */
 static const command_rec x_cmds[] =
@@ -1329,7 +1329,7 @@ static const command_rec x_cmds[] =
 /* the static hooks into our module from the other parts of the server.     */
 /*                                                                          */
 /*--------------------------------------------------------------------------*/
-/* 
+/*
  * Module definition for configuration.  If a particular callback is not
  * needed, replace its routine name below with the word NULL.
  */
diff --git a/modules/filters/mod_charset_lite.c b/modules/filters/mod_charset_lite.c
index e2a2560..61a27ed 100644
--- a/modules/filters/mod_charset_lite.c
+++ b/modules/filters/mod_charset_lite.c
@@ -45,10 +45,10 @@
 #define INPUT_XLATE_BUF_SIZE  (8*1024)  /* size of translation buffer used on input */
 
 #define XLATE_MIN_BUFF_LEFT 128  /* flush once there is no more than this much
-                                  * space left in the translation buffer 
+                                  * space left in the translation buffer
                                   */
 
-#define FATTEST_CHAR  8          /* we don't handle chars wider than this that straddle 
+#define FATTEST_CHAR  8          /* we don't handle chars wider than this that straddle
                                   * two buckets
                                   */
 
@@ -67,15 +67,15 @@ typedef enum {
 /* registered name of the output translation filter */
 #define XLATEOUT_FILTER_NAME "XLATEOUT"
 /* registered name of input translation filter */
-#define XLATEIN_FILTER_NAME  "XLATEIN" 
+#define XLATEIN_FILTER_NAME  "XLATEIN"
 
 typedef struct charset_dir_t {
     /** debug level; -1 means uninitialized, 0 means no debug */
     int debug;
     const char *charset_source; /* source encoding */
     const char *charset_default; /* how to ship on wire */
-    /** module does ap_add_*_filter()? */    
-    enum {IA_INIT, IA_IMPADD, IA_NOIMPADD} implicit_add; 
+    /** module does ap_add_*_filter()? */
+    enum {IA_INIT, IA_IMPADD, IA_NOIMPADD} implicit_add;
 } charset_dir_t;
 
 /* charset_filter_ctx_t is created for each filter instance; because the same
@@ -126,14 +126,14 @@ static void *merge_charset_dir_conf(apr_pool_t *p, void *basev, void *overridesv
         *over = (charset_dir_t *)overridesv;
 
     /* If it is defined in the current container, use it.  Otherwise, use the one
-     * from the enclosing container. 
+     * from the enclosing container.
      */
 
-    a->debug = 
+    a->debug =
         over->debug != -1 ? over->debug : base->debug;
-    a->charset_default = 
+    a->charset_default =
         over->charset_default ? over->charset_default : base->charset_default;
-    a->charset_source = 
+    a->charset_source =
         over->charset_source ? over->charset_source : base->charset_source;
     a->implicit_add =
         over->implicit_add != IA_INIT ? over->implicit_add : base->implicit_add;
@@ -153,7 +153,7 @@ static const char *add_charset_source(cmd_parms *cmd, void *in_dc,
 
 /* CharsetDefault charset
  */
-static const char *add_charset_default(cmd_parms *cmd, void *in_dc, 
+static const char *add_charset_default(cmd_parms *cmd, void *in_dc,
                                        const char *name)
 {
     charset_dir_t *dc = in_dc;
@@ -164,7 +164,7 @@ static const char *add_charset_default(cmd_parms *cmd, void *in_dc,
 
 /* CharsetOptions optionflag...
  */
-static const char *add_charset_options(cmd_parms *cmd, void *in_dc, 
+static const char *add_charset_options(cmd_parms *cmd, void *in_dc,
                                        const char *flag)
 {
     charset_dir_t *dc = in_dc;
@@ -179,7 +179,7 @@ static const char *add_charset_options(cmd_parms *cmd, void *in_dc,
         dc->debug = atoi(flag + 11);
     }
     else {
-        return apr_pstrcat(cmd->temp_pool, 
+        return apr_pstrcat(cmd->temp_pool,
                            "Invalid CharsetOptions option: ",
                            flag,
                            NULL);
@@ -194,7 +194,7 @@ static const char *add_charset_options(cmd_parms *cmd, void *in_dc,
  */
 static int find_code_page(request_rec *r)
 {
-    charset_dir_t *dc = ap_get_module_config(r->per_dir_config, 
+    charset_dir_t *dc = ap_get_module_config(r->per_dir_config,
                                              &charset_lite_module);
     charset_req_t *reqinfo;
     charset_filter_ctx_t *input_ctx, *output_ctx;
@@ -228,21 +228,21 @@ static int find_code_page(request_rec *r)
     /* catch proxy requests */
     if (r->proxyreq) return DECLINED;
     /* mod_rewrite indicators */
-    if (!strncmp(r->filename, "redirect:", 9)) return DECLINED; 
-    if (!strncmp(r->filename, "gone:", 5)) return DECLINED; 
-    if (!strncmp(r->filename, "passthrough:", 12)) return DECLINED; 
-    if (!strncmp(r->filename, "forbidden:", 10)) return DECLINED; 
-    
+    if (!strncmp(r->filename, "redirect:", 9)) return DECLINED;
+    if (!strncmp(r->filename, "gone:", 5)) return DECLINED;
+    if (!strncmp(r->filename, "passthrough:", 12)) return DECLINED;
+    if (!strncmp(r->filename, "forbidden:", 10)) return DECLINED;
+
     mime_type = r->content_type ? r->content_type : ap_default_type(r);
 
     /* If mime type isn't text or message, bail out.
      */
 
 /* XXX When we handle translation of the request body, watch out here as
- *     1.3 allowed additional mime types: multipart and 
+ *     1.3 allowed additional mime types: multipart and
  *     application/x-www-form-urlencoded
  */
-             
+
     if (strncasecmp(mime_type, "text/", 5) &&
 #if APR_CHARSET_EBCDIC || AP_WANT_DIR_TRANSLATION
         /* On an EBCDIC machine, be willing to translate mod_autoindex-
@@ -283,8 +283,8 @@ static int find_code_page(request_rec *r)
     /* Get storage for the request data and the output filter context.
      * We rarely need the input filter context, so allocate that separately.
      */
-    reqinfo = (charset_req_t *)apr_pcalloc(r->pool, 
-                                           sizeof(charset_req_t) + 
+    reqinfo = (charset_req_t *)apr_pcalloc(r->pool,
+                                           sizeof(charset_req_t) +
                                            sizeof(charset_filter_ctx_t));
     output_ctx = (charset_filter_ctx_t *)(reqinfo + 1);
 
@@ -305,8 +305,8 @@ static int find_code_page(request_rec *r)
     switch (r->method_number) {
     case M_PUT:
     case M_POST:
-        /* Set up input translation.  Note: A request body can be included 
-         * with the OPTIONS method, but for now we don't set up translation 
+        /* Set up input translation.  Note: A request body can be included
+         * with the OPTIONS method, but for now we don't set up translation
          * of it.
          */
         input_ctx = apr_pcalloc(r->pool, sizeof(charset_filter_ctx_t));
@@ -315,7 +315,7 @@ static int find_code_page(request_rec *r)
         input_ctx->tmp = apr_palloc(r->pool, INPUT_XLATE_BUF_SIZE);
         input_ctx->dc = dc;
         reqinfo->input_ctx = input_ctx;
-        rv = apr_xlate_open(&input_ctx->xlate, dc->charset_source, 
+        rv = apr_xlate_open(&input_ctx->xlate, dc->charset_source,
                             dc->charset_default, r->pool);
         if (rv != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
@@ -358,20 +358,20 @@ static int configured_on_output(request_rec *r, const char *filter_name)
 static void xlate_insert_filter(request_rec *r)
 {
     /* Hey... don't be so quick to use reqinfo->dc here; reqinfo may be NULL */
-    charset_req_t *reqinfo = ap_get_module_config(r->request_config, 
+    charset_req_t *reqinfo = ap_get_module_config(r->request_config,
                                                   &charset_lite_module);
-    charset_dir_t *dc = ap_get_module_config(r->per_dir_config, 
+    charset_dir_t *dc = ap_get_module_config(r->per_dir_config,
                                              &charset_lite_module);
 
     if (reqinfo) {
         if (reqinfo->output_ctx && !configured_on_output(r, XLATEOUT_FILTER_NAME)) {
-            ap_add_output_filter(XLATEOUT_FILTER_NAME, reqinfo->output_ctx, r, 
+            ap_add_output_filter(XLATEOUT_FILTER_NAME, reqinfo->output_ctx, r,
                                  r->connection);
         }
         else if (dc->debug >= DBGLVL_FLOW) {
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                           "xlate output filter not added implicitly because %s",
-                          !reqinfo->output_ctx ? 
+                          !reqinfo->output_ctx ?
                           "no output configuration available" :
                           "another module added the filter");
         }
@@ -443,7 +443,7 @@ static apr_status_t send_eos(ap_filter_t *f)
     return rv;
 }
 
-static apr_status_t set_aside_partial_char(charset_filter_ctx_t *ctx, 
+static apr_status_t set_aside_partial_char(charset_filter_ctx_t *ctx,
                                            const char *partial,
                                            apr_size_t partial_len)
 {
@@ -456,8 +456,8 @@ static apr_status_t set_aside_partial_char(charset_filter_ctx_t *ctx,
     }
     else {
         rv = APR_INCOMPLETE;
-        ctx->ees = EES_LIMIT; /* we don't handle chars this wide which straddle 
-                               * buckets 
+        ctx->ees = EES_LIMIT; /* we don't handle chars this wide which straddle
+                               * buckets
                                */
     }
     return rv;
@@ -465,7 +465,7 @@ static apr_status_t set_aside_partial_char(charset_filter_ctx_t *ctx,
 
 static apr_status_t finish_partial_char(charset_filter_ctx_t *ctx,
                                         /* input buffer: */
-                                        const char **cur_str, 
+                                        const char **cur_str,
                                         apr_size_t *cur_len,
                                         /* output buffer: */
                                         char **out_str,
@@ -530,7 +530,7 @@ static void log_xlate_error(ap_filter_t *f, apr_status_t rv)
         strcpy(msgbuf, "xlate filter - incomplete char at end of input - ");
         cur = 0;
         while ((apr_size_t)cur < ctx->saved) {
-            apr_snprintf(msgbuf + strlen(msgbuf), sizeof(msgbuf) - strlen(msgbuf), 
+            apr_snprintf(msgbuf + strlen(msgbuf), sizeof(msgbuf) - strlen(msgbuf),
                          "%02X", (unsigned)ctx->buf[cur]);
             ++cur;
         }
@@ -602,15 +602,15 @@ static void chk_filter_chain(ap_filter_t *f)
             else {
                 if (strcmp(last_xlate_ctx->dc->charset_default,
                            curctx->dc->charset_source)) {
-                    /* incompatible translation 
+                    /* incompatible translation
                      * if our filter instance is incompatible with an instance
                      * already in place, noop our instance
-                     * Notes: 
+                     * Notes:
                      * . We are only willing to noop our own instance.
                      * . It is possible to noop another instance which has not
                      *   yet run, but this is not currently implemented.
                      *   Hopefully it will not be needed.
-                     * . It is not possible to noop an instance which has 
+                     * . It is not possible to noop an instance which has
                      *   already run.
                      */
                     if (last_xlate_ctx == f->ctx) {
@@ -680,7 +680,7 @@ static void chk_filter_chain(ap_filter_t *f)
  */
 static apr_status_t xlate_brigade(charset_filter_ctx_t *ctx,
                                   apr_bucket_brigade *bb,
-                                  char *buffer, 
+                                  char *buffer,
                                   apr_size_t *buffer_avail,
                                   int *hit_eos)
 {
@@ -737,7 +737,7 @@ static apr_status_t xlate_brigade(charset_filter_ctx_t *ctx,
                                            buffer_avail);
                 buffer  += old_buffer_avail - *buffer_avail;
                 bucket  += old_bucket_avail - bucket_avail;
-                
+
                 if (rv == APR_INCOMPLETE) { /* partial character at end of input */
                     /* We need to save the final byte(s) for next time; we can't
                      * convert it until we look at the next bucket.
@@ -781,7 +781,7 @@ static apr_status_t xlate_brigade(charset_filter_ctx_t *ctx,
     return rv;
 }
 
-/* xlate_out_filter() handles (almost) arbitrary conversions from one charset 
+/* xlate_out_filter() handles (almost) arbitrary conversions from one charset
  * to another...
  * translation is determined in the fixup hook (find_code_page), which is
  * where the filter's context data is set up... the context data gives us
@@ -802,7 +802,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     int done;
     apr_status_t rv = APR_SUCCESS;
 
-    if (!ctx) { 
+    if (!ctx) {
         /* this is SetOutputFilter path; grab the preallocated context,
          * if any; note that if we decided not to do anything in an earlier
          * handler, we won't even have a reqinfo
@@ -833,7 +833,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
         const char *mime_type = f->r->content_type ? f->r->content_type : ap_default_type(f->r);
 
         /* XXX When we handle translation of the request body, watch out here as
-         *     1.3 allowed additional mime types: multipart and 
+         *     1.3 allowed additional mime types: multipart and
          *     application/x-www-form-urlencoded
          */
         if (strncasecmp(mime_type, "text/", 5) == 0 ||
@@ -854,7 +854,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
 #endif
         strncasecmp(mime_type, "message/", 8) == 0) {
 
-            rv = apr_xlate_open(&ctx->xlate, 
+            rv = apr_xlate_open(&ctx->xlate,
                         dc->charset_default, dc->charset_source, f->r->pool);
             if (rv != APR_SUCCESS) {
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r,
@@ -865,7 +865,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
         }
         else {
                 ctx->noop = 1;
-                if (dc->debug >= DBGLVL_GORY) 
+                if (dc->debug >= DBGLVL_GORY)
                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r,
                                   "mime type is %s; no translation selected",
                                   mime_type);
@@ -925,7 +925,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
                 break;
             }
             consumed_bucket = dptr; /* for axing when we're done reading it */
-            dptr = APR_BUCKET_NEXT(dptr); /* get ready for when we access the 
+            dptr = APR_BUCKET_NEXT(dptr); /* get ready for when we access the
                                           * next bucket */
         }
         /* Try to fill up our tmp buffer with translated data. */
@@ -937,7 +937,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
                  * bucket.
                  */
                 char *tmp_tmp;
-                
+
                 tmp_tmp = tmp + sizeof(tmp) - space_avail;
                 rv = finish_partial_char(ctx,
                                          &cur_str, &cur_len,
@@ -947,11 +947,11 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
                 rv = apr_xlate_conv_buffer(ctx->xlate,
                                            cur_str, &cur_avail,
                                            tmp + sizeof(tmp) - space_avail, &space_avail);
-                
+
                 /* Update input ptr and len after consuming some bytes */
                 cur_str += cur_len - cur_avail;
                 cur_len = cur_avail;
-                
+
                 if (rv == APR_INCOMPLETE) { /* partial character at end of input */
                     /* We need to save the final byte(s) for next time; we can't
                      * convert it until we look at the next bucket.
@@ -975,7 +975,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
             if (rv != APR_SUCCESS) {
                 done = 1;
             }
-            
+
             /* tmp is now empty */
             space_avail = sizeof(tmp);
         }
@@ -998,7 +998,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     return rv;
 }
 
-static int xlate_in_filter(ap_filter_t *f, apr_bucket_brigade *bb, 
+static int xlate_in_filter(ap_filter_t *f, apr_bucket_brigade *bb,
                            ap_input_mode_t mode, apr_read_type_e block,
                            apr_off_t readbytes)
 {
@@ -1011,7 +1011,7 @@ static int xlate_in_filter(ap_filter_t *f, apr_bucket_brigade *bb,
     apr_size_t buffer_size;
     int hit_eos;
 
-    if (!ctx) { 
+    if (!ctx) {
         /* this is SetInputFilter path; grab the preallocated context,
          * if any; note that if we decided not to do anything in an earlier
          * handler, we won't even have a reqinfo
@@ -1048,7 +1048,7 @@ static int xlate_in_filter(ap_filter_t *f, apr_bucket_brigade *bb,
     }
 
     if (APR_BRIGADE_EMPTY(ctx->bb)) {
-        if ((rv = ap_get_brigade(f->next, bb, mode, block, 
+        if ((rv = ap_get_brigade(f->next, bb, mode, block,
                                  readbytes)) != APR_SUCCESS) {
             return rv;
         }
@@ -1071,11 +1071,11 @@ static int xlate_in_filter(ap_filter_t *f, apr_bucket_brigade *bb,
         if (buffer_size < INPUT_XLATE_BUF_SIZE) { /* do we have output? */
             apr_bucket *e;
 
-            e = apr_bucket_heap_create(ctx->tmp, 
+            e = apr_bucket_heap_create(ctx->tmp,
                                        INPUT_XLATE_BUF_SIZE - buffer_size,
                                        NULL, f->r->connection->bucket_alloc);
             /* make sure we insert at the head, because there may be
-             * an eos bucket already there, and the eos bucket should 
+             * an eos bucket already there, and the eos bucket should
              * come after the data
              */
             APR_BRIGADE_INSERT_HEAD(bb, e);
@@ -1102,10 +1102,10 @@ static const command_rec cmds[] =
                   NULL,
                   OR_FILEINFO,
                   "source (html,cgi,ssi) file charset"),
-    AP_INIT_TAKE1("CharsetDefault", 
+    AP_INIT_TAKE1("CharsetDefault",
                   add_charset_default,
                   NULL,
-                  OR_FILEINFO, 
+                  OR_FILEINFO,
                   "name of default charset"),
     AP_INIT_ITERATE("CharsetOptions",
                     add_charset_options,
@@ -1130,7 +1130,7 @@ module AP_MODULE_DECLARE_DATA charset_lite_module =
     STANDARD20_MODULE_STUFF,
     create_charset_dir_conf,
     merge_charset_dir_conf,
-    NULL, 
+    NULL,
     NULL,
     cmds,
     charset_register_hooks
diff --git a/modules/filters/mod_deflate.c b/modules/filters/mod_deflate.c
index f248a82..4a9ae98 100644
--- a/modules/filters/mod_deflate.c
+++ b/modules/filters/mod_deflate.c
@@ -67,7 +67,7 @@ typedef struct deflate_filter_config_t
  * |ID1|ID2|CM |FLG|     MTIME     |XFL|OS |
  * +---+---+---+---+---+---+---+---+---+---+
  */
-static const char gzip_header[10] = 
+static const char gzip_header[10] =
 { '\037', '\213', Z_DEFLATED, 0,
   0, 0, 0, 0, /* mtime */
   0, 0x03 /* Unix OS_CODE */
@@ -152,7 +152,7 @@ static const char *deflate_set_note(cmd_parms *cmd, void *dummy,
 {
     deflate_filter_config *c = ap_get_module_config(cmd->server->module_config,
                                                     &deflate_module);
-    
+
     if (arg2 == NULL) {
         c->note_ratio_name = apr_pstrdup(cmd->pool, arg1);
     }
@@ -264,7 +264,7 @@ static apr_status_t deflate_out_filter(ap_filter_t *f,
             if ( env_value && (strcmp(env_value,"1") == 0) ) {
                 ap_remove_output_filter(f);
                 return ap_pass_brigade(f->next, bb);
-            }            
+            }
         }
 
         /* Let's see what our current Content-Encoding is.
@@ -332,7 +332,7 @@ static apr_status_t deflate_out_filter(ap_filter_t *f,
             token = ap_get_token(r->pool, &accepts, 0);
             while (token && token[0] && strcasecmp(token, "gzip")) {
                 /* skip parameters, XXX: ;q=foo evaluation? */
-                while (*accepts == ';') { 
+                while (*accepts == ';') {
                     ++accepts;
                     token = ap_get_token(r->pool, &accepts, 1);
                 }
@@ -394,7 +394,7 @@ static apr_status_t deflate_out_filter(ap_filter_t *f,
         ctx->stream.next_out = ctx->buffer;
         ctx->stream.avail_out = c->bufferSize;
     }
-    
+
     while (!APR_BRIGADE_EMPTY(bb))
     {
         const char *data;
@@ -627,8 +627,8 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
             return rv;
         }
 
-        len = 10; 
-        rv = apr_brigade_flatten(ctx->bb, deflate_hdr, &len); 
+        len = 10;
+        rv = apr_brigade_flatten(ctx->bb, deflate_hdr, &len);
         if (rv != APR_SUCCESS) {
             return rv;
         }
@@ -784,7 +784,7 @@ static apr_status_t deflate_in_filter(ap_filter_t *f,
                 inflateEnd(&ctx->stream);
 
                 eos = apr_bucket_eos_create(f->c->bucket_alloc);
-                APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, eos); 
+                APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, eos);
                 break;
             }
 
@@ -831,7 +831,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
 {
     int zlib_method;
     int zlib_flags;
-    int deflate_init = 1; 
+    int deflate_init = 1;
     apr_bucket *bkt;
     request_rec *r = f->r;
     deflate_ctx *ctx = f->ctx;
@@ -961,7 +961,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "Insufficient data for inflate");
                 return APR_EGENERAL;
-            } 
+            }
             else  {
                 zlib_method = data[2];
                 zlib_flags = data[3];
@@ -1077,7 +1077,7 @@ static apr_status_t inflate_out_filter(ap_filter_t *f,
             inflateEnd(&ctx->stream);
 
             eos = apr_bucket_eos_create(f->c->bucket_alloc);
-            APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, eos); 
+            APR_BRIGADE_INSERT_TAIL(ctx->proc_bb, eos);
             break;
         }
 
diff --git a/modules/filters/mod_ext_filter.c b/modules/filters/mod_ext_filter.c
index 0fbb0f6..c4f7fe4 100644
--- a/modules/filters/mod_ext_filter.c
+++ b/modules/filters/mod_ext_filter.c
@@ -76,8 +76,8 @@ module AP_MODULE_DECLARE_DATA ext_filter_module;
 static const server_rec *main_server;
 
 static apr_status_t ef_output_filter(ap_filter_t *, apr_bucket_brigade *);
-static apr_status_t ef_input_filter(ap_filter_t *, apr_bucket_brigade *, 
-                                    ap_input_mode_t, apr_read_type_e, 
+static apr_status_t ef_input_filter(ap_filter_t *, apr_bucket_brigade *,
+                                    ap_input_mode_t, apr_read_type_e,
                                     apr_off_t);
 
 #define DBGLVL_SHOWOPTIONS         1
@@ -143,7 +143,7 @@ static const char *add_options(cmd_parms *cmd, void *in_dc,
         dc->log_stderr = 0;
     }
     else {
-        return apr_pstrcat(cmd->temp_pool, 
+        return apr_pstrcat(cmd->temp_pool,
                            "Invalid ExtFilterOptions option: ",
                            arg,
                            NULL);
@@ -196,7 +196,7 @@ static const char *parse_cmd(apr_pool_t *p, const char **args, ef_filter_t *filt
         return "Invalid cmd= parameter";
     }
     filter->command = filter->args[0];
-    
+
     return NULL;
 }
 
@@ -239,7 +239,7 @@ static const char *define_filter(cmd_parms *cmd, void *dummy, const char *args)
                 filter->preserves_content_length = 1;
             }
             else {
-                return apr_psprintf(cmd->pool, 
+                return apr_psprintf(cmd->pool,
                                     "mangled argument `%s'",
                                     token);
             }
@@ -275,14 +275,14 @@ static const char *define_filter(cmd_parms *cmd, void *dummy, const char *args)
             filter->enable_env = token;
             continue;
         }
-        
+
         if (!strncasecmp(args, "disableenv=", 11)) {
             args += 11;
             token = ap_getword_white(cmd->pool, &args);
             filter->disable_env = token;
             continue;
         }
-        
+
         if (!strncasecmp(args, "intype=", 7)) {
             args += 7;
             filter->intype = ap_getword_white(cmd->pool, &args);
@@ -307,7 +307,7 @@ static const char *define_filter(cmd_parms *cmd, void *dummy, const char *args)
                             args);
     }
 
-    /* parsing is done...  register the filter 
+    /* parsing is done...  register the filter
      */
     if (filter->mode == OUTPUT_FILTER) {
         /* XXX need a way to ensure uniqueness among all filters */
@@ -350,12 +350,12 @@ static void register_hooks(apr_pool_t *p)
     ap_hook_post_config(ef_init, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
-static apr_status_t set_resource_limits(request_rec *r, 
+static apr_status_t set_resource_limits(request_rec *r,
                                         apr_procattr_t *procattr)
 {
 #if defined(RLIMIT_CPU)  || defined(RLIMIT_NPROC) || \
     defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined (RLIMIT_AS)
-    core_dir_config *conf = 
+    core_dir_config *conf =
         (core_dir_config *)ap_get_module_config(r->per_dir_config,
                                                 &core_module);
     apr_status_t rv;
@@ -438,12 +438,12 @@ static apr_status_t init_ext_filter_process(ap_filter_t *f)
     rc = apr_procattr_child_errfn_set(ctx->procattr, child_errfn);
     ap_assert(rc == APR_SUCCESS);
     apr_pool_userdata_set(f->r, ERRFN_USERDATA_KEY, apr_pool_cleanup_null, ctx->p);
-    
+
     if (dc->debug >= DBGLVL_ERRORCHECK) {
         rc = apr_procattr_error_check_set(ctx->procattr, 1);
         ap_assert(rc == APR_SUCCESS);
     }
-    
+
     /* add standard CGI variables as well as DOCUMENT_URI, DOCUMENT_PATH_INFO,
      * and QUERY_STRING_UNESCAPED
      */
@@ -462,11 +462,11 @@ static apr_status_t init_ext_filter_process(ap_filter_t *f)
     env = (const char * const *) ap_create_environment(ctx->p,
                                                        f->r->subprocess_env);
 
-    rc = apr_proc_create(ctx->proc, 
-                            ctx->filter->command, 
-                            (const char * const *)ctx->filter->args, 
+    rc = apr_proc_create(ctx->proc,
+                            ctx->filter->command,
+                            (const char * const *)ctx->filter->args,
                             env, /* environment */
-                            ctx->procattr, 
+                            ctx->procattr,
                             ctx->p);
     if (rc != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, f->r,
@@ -483,7 +483,7 @@ static apr_status_t init_ext_filter_process(ap_filter_t *f)
      * be open.
      */
 
-    apr_pool_cleanup_register(ctx->p, ctx->proc->in, 
+    apr_pool_cleanup_register(ctx->p, ctx->proc->in,
                          apr_pool_cleanup_null, /* other mechanism */
                          ef_close_file);
 
@@ -513,7 +513,7 @@ static apr_status_t init_ext_filter_process(ap_filter_t *f)
 
 static const char *get_cfg_string(ef_dir_t *dc, ef_filter_t *filter, apr_pool_t *p)
 {
-    const char *debug_str = dc->debug == -1 ? 
+    const char *debug_str = dc->debug == -1 ?
         "DebugLevel=0" : apr_psprintf(p, "DebugLevel=%d", dc->debug);
     const char *log_stderr_str = dc->log_stderr < 1 ?
         "NoLogStderr" : "LogStderr";
@@ -523,7 +523,7 @@ static const char *get_cfg_string(ef_dir_t *dc, ef_filter_t *filter, apr_pool_t
         "*/*" : filter->intype;
     const char *outtype_str = !filter->outtype ?
         "(unchanged)" : filter->outtype;
-    
+
     return apr_psprintf(p,
                         "ExtFilterOptions %s %s %s ExtFilterInType %s "
                         "ExtFilterOuttype %s",
@@ -583,7 +583,7 @@ static apr_status_t init_filter_instance(ap_filter_t *f)
                 /* wrong IMT for us; don't mess with the output */
                 ctx->noop = 1;
             }
-        } 
+        }
         else {
             ctx->noop = 1;
         }
@@ -608,7 +608,7 @@ static apr_status_t init_filter_instance(ap_filter_t *f)
             ap_set_content_type(f->r, ctx->filter->outtype);
         }
         if (ctx->filter->preserves_content_length != 1) {
-            /* nasty, but needed to avoid confusing the browser 
+            /* nasty, but needed to avoid confusing the browser
              */
             apr_table_unset(f->r->headers_out, "Content-Length");
         }
@@ -627,7 +627,7 @@ static apr_status_t init_filter_instance(ap_filter_t *f)
     return APR_SUCCESS;
 }
 
-/* drain_available_output(): 
+/* drain_available_output():
  *
  * if any data is available from the filter, read it and append it
  * to the the bucket brigade
@@ -663,12 +663,12 @@ static apr_status_t drain_available_output(ap_filter_t *f,
         return APR_SUCCESS;
     }
     /* we should never get here; if we do, a bogus error message would be
-     * the least of our problems 
+     * the least of our problems
      */
     return APR_ANONYMOUS;
 }
 
-static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data, 
+static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data,
                                         apr_size_t len, apr_bucket_brigade *bb)
 {
     ef_ctx_t *ctx = f->ctx;
@@ -676,7 +676,7 @@ static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data,
     apr_status_t rv;
     apr_size_t bytes_written = 0;
     apr_size_t tmplen;
-    
+
     do {
         tmplen = len - bytes_written;
         rv = apr_file_write(ctx->proc->in,
@@ -690,7 +690,7 @@ static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data,
             return rv;
         }
         if (APR_STATUS_IS_EAGAIN(rv)) {
-            /* XXX handle blocking conditions here...  if we block, we need 
+            /* XXX handle blocking conditions here...  if we block, we need
              * to read data from the child process and pass it down to the
              * next filter!
              */
@@ -699,24 +699,24 @@ static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data,
 #if APR_FILES_AS_SOCKETS
                 int num_events;
                 const apr_pollfd_t *pdesc;
-                
+
                 rv = apr_pollset_poll(ctx->pollset, f->r->server->timeout,
                                       &num_events, &pdesc);
                 if (rv || dc->debug >= DBGLVL_GORY) {
                     ap_log_rerror(APLOG_MARK, APLOG_DEBUG,
                                   rv, f->r, "apr_pollset_poll()");
                 }
-                if (rv != APR_SUCCESS && !APR_STATUS_IS_EINTR(rv)) { 
+                if (rv != APR_SUCCESS && !APR_STATUS_IS_EINTR(rv)) {
                     /* some error such as APR_TIMEUP */
                     return rv;
                 }
 #else /* APR_FILES_AS_SOCKETS */
                 /* Yuck... I'd really like to wait until I can read
-                 * or write, but instead I have to sleep and try again 
+                 * or write, but instead I have to sleep and try again
                  */
                 apr_sleep(100000); /* 100 milliseconds */
                 if (dc->debug >= DBGLVL_GORY) {
-                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 
+                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG,
                                   0, f->r, "apr_sleep()");
                 }
 #endif /* APR_FILES_AS_SOCKETS */
@@ -729,9 +729,9 @@ static apr_status_t pass_data_to_filter(ap_filter_t *f, const char *data,
     return rv;
 }
 
-/* ef_unified_filter: 
+/* ef_unified_filter:
  *
- * runs the bucket brigade bb through the filter and puts the result into 
+ * runs the bucket brigade bb through the filter and puts the result into
  * bb, dropping the previous content of bb (the input)
  */
 
@@ -778,7 +778,7 @@ static int ef_unified_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     apr_brigade_cleanup(bb);
     APR_BRIGADE_CONCAT(bb, bb_tmp);
     apr_brigade_destroy(bb_tmp);
-    
+
     if (eos) {
         /* close the child's stdin to signal that no more data is coming;
          * that will cause the child to finish generating output
@@ -788,10 +788,10 @@ static int ef_unified_filter(ap_filter_t *f, apr_bucket_brigade *bb)
                           "apr_file_close(child input)");
             return rv;
         }
-        /* since we've seen eos and closed the child's stdin, set the proper pipe 
-         * timeout; we don't care if we don't return from apr_file_read() for a while... 
+        /* since we've seen eos and closed the child's stdin, set the proper pipe
+         * timeout; we don't care if we don't return from apr_file_read() for a while...
          */
-        rv = apr_file_pipe_timeout_set(ctx->proc->out, 
+        rv = apr_file_pipe_timeout_set(ctx->proc->out,
                                        r->server->timeout);
         if (rv) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
@@ -818,7 +818,7 @@ static int ef_unified_filter(ap_filter_t *f, apr_bucket_brigade *bb)
             }
             return APR_SUCCESS;
         }
-        
+
         if (rv == APR_SUCCESS) {
             b = apr_bucket_heap_create(buf, len, NULL, c->bucket_alloc);
             APR_BRIGADE_INSERT_TAIL(bb, b);
@@ -855,7 +855,7 @@ static apr_status_t ef_output_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     }
 
     rv = ef_unified_filter(f, bb);
-    if (rv != APR_SUCCESS) { 
+    if (rv != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                       "ef_unified_filter() failed");
     }
@@ -867,7 +867,7 @@ static apr_status_t ef_output_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     return rv;
 }
 
-static int ef_input_filter(ap_filter_t *f, apr_bucket_brigade *bb, 
+static int ef_input_filter(ap_filter_t *f, apr_bucket_brigade *bb,
                            ap_input_mode_t mode, apr_read_type_e block,
                            apr_off_t readbytes)
 {
diff --git a/modules/filters/mod_filter.c b/modules/filters/mod_filter.c
index d0687f4..806915e 100644
--- a/modules/filters/mod_filter.c
+++ b/modules/filters/mod_filter.c
@@ -42,7 +42,7 @@
 module AP_MODULE_DECLARE_DATA filter_module;
 
 /**
- * @brief is a filter provider, as defined and implemented by mod_filter.  
+ * @brief is a filter provider, as defined and implemented by mod_filter.
  *
  * The struct is a linked list, with dispatch criteria
  * defined for each filter.  The provider implementation itself is a
@@ -278,10 +278,10 @@ static int filter_lookup(ap_filter_t *f, ap_filter_rec_t *filter)
              * The idea is that by putting this in mod_filter, we relieve
              * filter implementations of the burden of fixing up HTTP headers
              * for cases that are routinely affected by filters.
-             * 
+             *
              * Default is ALWAYS to do nothing, so as not to tread on the
              * toes of filters which want to do it themselves.
-             * 
+             *
              */
             proto_flags = provider->frec->proto_flags;
 
@@ -650,7 +650,7 @@ static const char *filter_provider(cmd_parms *cmd, void *CFG, const char *args)
         str = apr_pstrdup(cmd->pool, condition);
         ap_str_tolower(str);
     }
-   
+
     if (   (provider->dispatch == RESPONSE_HEADERS)
         && !strcmp(str, "content-type")) {
         provider->dispatch = CONTENT_TYPE;
diff --git a/modules/filters/mod_include.c b/modules/filters/mod_include.c
index 7f37b4e..757bad3 100644
--- a/modules/filters/mod_include.c
+++ b/modules/filters/mod_include.c
@@ -1218,7 +1218,7 @@ static int parse_expr(include_ctx_t *ctx, const char *expr, int *was_error)
                     current = root = new;
                     continue;
                 }
-            
+
                 new->left = current->right;
                 new->left->parent = new;
                 new->parent = current;
@@ -1554,7 +1554,7 @@ static int find_file(request_rec *r, const char *directive, const char *tag,
 
             if (rr->status == HTTP_OK && rr->finfo.filetype != 0) {
                 to_send = rr->filename;
-                if ((rv = apr_stat(finfo, to_send, 
+                if ((rv = apr_stat(finfo, to_send,
                     APR_FINFO_GPROT | APR_FINFO_MIN, rr->pool)) != APR_SUCCESS
                     && rv != APR_INCOMPLETE) {
                     error_fmt = "unable to get information about \"%s\" "
@@ -1574,7 +1574,7 @@ static int find_file(request_rec *r, const char *directive, const char *tag,
         }
 
         if (rr) ap_destroy_sub_req(rr);
-        
+
         return ret;
     }
     else if (!strcmp(tag, "virtual")) {
@@ -1862,12 +1862,12 @@ static apr_status_t handle_config(include_ctx_t *ctx, ap_filter_t *f,
             ctx->time_str = ap_ssi_parse_string(ctx, tag_val, NULL, 0,
                                                 SSI_EXPAND_DROP_NAME);
 
-            apr_table_setn(env, "DATE_LOCAL", ap_ht_time(r->pool, date, 
+            apr_table_setn(env, "DATE_LOCAL", ap_ht_time(r->pool, date,
                            ctx->time_str, 0));
-            apr_table_setn(env, "DATE_GMT", ap_ht_time(r->pool, date, 
+            apr_table_setn(env, "DATE_GMT", ap_ht_time(r->pool, date,
                            ctx->time_str, 1));
             apr_table_setn(env, "LAST_MODIFIED",
-                           ap_ht_time(r->pool, r->finfo.mtime, 
+                           ap_ht_time(r->pool, r->finfo.mtime,
                            ctx->time_str, 0));
         }
         else if (!strcmp(tag, "sizefmt")) {
@@ -2215,7 +2215,7 @@ static apr_status_t handle_else(include_ctx_t *ctx, ap_filter_t *f,
     }
 
     DEBUG_DUMP_COND(ctx, " else");
-            
+
     if (ctx->flags & SSI_FLAG_COND_TRUE) {
         ctx->flags &= SSI_FLAG_CLEAR_PRINTING;
     }
@@ -2286,7 +2286,7 @@ static apr_status_t handle_set(include_ctx_t *ctx, ap_filter_t *f,
         return APR_SUCCESS;
     }
 
-    /* we need to use the 'main' request pool to set notes as that is 
+    /* we need to use the 'main' request pool to set notes as that is
      * a notes lifetime
      */
     while (sub) {
@@ -2415,15 +2415,15 @@ static apr_status_t handle_printenv(include_ctx_t *ctx, ap_filter_t *f,
 
 /* This is an implementation of the BNDM search algorithm.
  *
- * Fast and Flexible String Matching by Combining Bit-parallelism and 
- * Suffix Automata (2001) 
+ * Fast and Flexible String Matching by Combining Bit-parallelism and
+ * Suffix Automata (2001)
  * Gonzalo Navarro, Mathieu Raffinot
  *
  * http://www-igm.univ-mlv.fr/~raffinot/ftp/jea2001.ps.gz
  *
  * Initial code submitted by Sascha Schumann.
  */
-   
+
 /* Precompile the bndm_t data structure. */
 static bndm_t *bndm_compile(apr_pool_t *pool, const char *n, apr_size_t nl)
 {
@@ -2447,7 +2447,7 @@ static bndm_t *bndm_compile(apr_pool_t *pool, const char *n, apr_size_t nl)
  *
  * h  - the string to look in
  * hl - length of the string to look for
- * t  - precompiled bndm structure against the pattern 
+ * t  - precompiled bndm structure against the pattern
  *
  * Returns the count of character that is the first match or hl if no
  * match is found.
@@ -3573,7 +3573,7 @@ static apr_status_t includes_filter(ap_filter_t *f, apr_bucket_brigade *b)
 
     /* Always unset the Last-Modified field - see RFC2616 - 13.3.4.
      * We don't know if we are going to be including a file or executing
-     * a program which may change the Last-Modified header or make the 
+     * a program which may change the Last-Modified header or make the
      * content completely dynamic.  Therefore, we can't support these
      * headers.
      * Exception: XBitHack full means we *should* set the Last-Modified field.
@@ -3606,17 +3606,17 @@ static apr_status_t includes_filter(ap_filter_t *f, apr_bucket_brigade *b)
 static int include_fixup(request_rec *r)
 {
     include_dir_config *conf;
- 
+
     conf = ap_get_module_config(r->per_dir_config, &include_module);
- 
-    if (r->handler && (strcmp(r->handler, "server-parsed") == 0)) 
+
+    if (r->handler && (strcmp(r->handler, "server-parsed") == 0))
     {
         if (!r->content_type || !*r->content_type) {
             ap_set_content_type(r, "text/html");
         }
         r->handler = "default-handler";
     }
-    else 
+    else
 #if defined(OS2) || defined(WIN32) || defined(NETWARE)
     /* These OS's don't support xbithack. This is being worked on. */
     {
@@ -3674,7 +3674,7 @@ static void *create_includes_server_config(apr_pool_t *p, server_rec *server)
     result->default_end_tag    = DEFAULT_END_SEQUENCE;
     result->default_start_tag  = DEFAULT_START_SEQUENCE;
 
-    return result; 
+    return result;
 }
 
 static const char *set_xbithack(cmd_parms *cmd, void *mconfig, const char *arg)
@@ -3799,9 +3799,9 @@ static int include_post_config(apr_pool_t *p, apr_pool_t *plog,
 
 static const command_rec includes_cmds[] =
 {
-    AP_INIT_TAKE1("XBitHack", set_xbithack, NULL, OR_OPTIONS, 
+    AP_INIT_TAKE1("XBitHack", set_xbithack, NULL, OR_OPTIONS,
                   "Off, On, or Full"),
-    AP_INIT_TAKE1("SSIErrorMsg", set_default_error_msg, NULL, OR_ALL, 
+    AP_INIT_TAKE1("SSIErrorMsg", set_default_error_msg, NULL, OR_ALL,
                   "a string"),
     AP_INIT_TAKE1("SSITimeFormat", set_default_time_fmt, NULL, OR_ALL,
                   "a strftime(3) formatted string"),
diff --git a/modules/generators/mod_asis.c b/modules/generators/mod_asis.c
index b32338e..01004a7 100644
--- a/modules/generators/mod_asis.c
+++ b/modules/generators/mod_asis.c
@@ -47,7 +47,7 @@ static int asis_handler(request_rec *r)
         return HTTP_NOT_FOUND;
     }
 
-    if ((rv = apr_file_open(&f, r->filename, APR_READ, 
+    if ((rv = apr_file_open(&f, r->filename, APR_READ,
                 APR_OS_DEFAULT, r->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                     "file permissions deny server access: %s", r->filename);
@@ -92,7 +92,7 @@ static int asis_handler(request_rec *r)
         bb = apr_brigade_create(r->pool, c->bucket_alloc);
 #if APR_HAS_LARGE_FILES
         if (r->finfo.size - pos > AP_MAX_SENDFILE) {
-            /* APR_HAS_LARGE_FILES issue; must split into mutiple buckets, 
+            /* APR_HAS_LARGE_FILES issue; must split into mutiple buckets,
              * no greater than MAX(apr_size_t), and more granular than that
              * in case the brigade code/filters attempt to read it directly.
              */
diff --git a/modules/generators/mod_autoindex.c b/modules/generators/mod_autoindex.c
index 9a6cdcc..431d57d 100644
--- a/modules/generators/mod_autoindex.c
+++ b/modules/generators/mod_autoindex.c
@@ -1305,7 +1305,7 @@ static struct ent *make_autoindex_entry(const apr_finfo_t *dirent,
         return (NULL);
     }
 
-    if((autoindex_opts & SHOW_FORBIDDEN)  
+    if((autoindex_opts & SHOW_FORBIDDEN)
         && (rr->status == HTTP_UNAUTHORIZED || rr->status == HTTP_FORBIDDEN)) {
         show_forbidden = 1;
     }
@@ -2070,7 +2070,7 @@ static int index_directory(request_rec *r,
                 else if (qstring[2] == '1') {
                     autoindex_opts |= VERSION_SORT;
                 }
-                strcpy(vval, ";V= "); 
+                strcpy(vval, ";V= ");
                 vval[3] = qstring[2];
                 qstring += qstring[3] ? 4 : 3;
             }
diff --git a/modules/generators/mod_cgi.c b/modules/generators/mod_cgi.c
index c8dc170..87d13b3 100644
--- a/modules/generators/mod_cgi.c
+++ b/modules/generators/mod_cgi.c
@@ -16,14 +16,14 @@
 
 /*
  * http_script: keeps all script-related ramblings together.
- * 
+ *
  * Compliant to CGI/1.1 spec
- * 
+ *
  * Adapted by rst from original NCSA code by Rob McCool
  *
  * Apache adds some new env vars; REDIRECT_URL and REDIRECT_QUERY_STRING for
  * custom error responses, and DOCUMENT_ROOT because we found it useful.
- * It also adds SERVER_ADMIN - useful for scripts to know who to mail when 
+ * It also adds SERVER_ADMIN - useful for scripts to know who to mail when
  * they fail.
  */
 
@@ -165,7 +165,7 @@ static int log_scripterror(request_rec *r, cgi_server_conf * conf, int ret,
     char time_str[APR_CTIME_LEN];
     int log_flags = rv ? APLOG_ERR : APLOG_ERR;
 
-    ap_log_rerror(APLOG_MARK, log_flags, rv, r, 
+    ap_log_rerror(APLOG_MARK, log_flags, rv, r,
                   "%s: %s", error, r->filename);
 
     /* XXX Very expensive mainline case! Open, then getfileinfo! */
@@ -192,7 +192,7 @@ static int log_scripterror(request_rec *r, cgi_server_conf * conf, int ret,
     return ret;
 }
 
-/* Soak up stderr from a script and redirect it to the error log. 
+/* Soak up stderr from a script and redirect it to the error log.
  */
 static apr_status_t log_script_err(request_rec *r, apr_file_t *script_err)
 {
@@ -206,15 +206,15 @@ static apr_status_t log_script_err(request_rec *r, apr_file_t *script_err)
         if (newline) {
             *newline = '\0';
         }
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, 
-                      "%s", argsbuffer);            
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                      "%s", argsbuffer);
     }
 
     return rv;
 }
 
 static int log_script(request_rec *r, cgi_server_conf * conf, int ret,
-                      char *dbuf, const char *sbuf, apr_bucket_brigade *bb, 
+                      char *dbuf, const char *sbuf, apr_bucket_brigade *bb,
                       apr_file_t *script_err)
 {
     const apr_array_header_t *hdrs_arr = apr_table_elts(r->headers_in);
@@ -372,7 +372,7 @@ static void cgi_child_errfn(apr_pool_t *pool, apr_status_t err,
 
 static apr_status_t run_cgi_child(apr_file_t **script_out,
                                   apr_file_t **script_in,
-                                  apr_file_t **script_err, 
+                                  apr_file_t **script_err,
                                   const char *command,
                                   const char * const argv[],
                                   request_rec *r,
@@ -423,7 +423,7 @@ static apr_status_t run_cgi_child(apr_file_t **script_out,
                                    e_info->in_pipe,
                                    e_info->out_pipe,
                                    e_info->err_pipe)) != APR_SUCCESS) ||
-        ((rc = apr_procattr_dir_set(procattr, 
+        ((rc = apr_procattr_dir_set(procattr,
                         ap_make_dirstr_parent(r->pool,
                                               r->filename))) != APR_SUCCESS) ||
 #ifdef RLIMIT_CPU
@@ -454,7 +454,7 @@ static apr_status_t run_cgi_child(apr_file_t **script_out,
         procnew = apr_pcalloc(p, sizeof(*procnew));
         rc = ap_os_create_privileged_process(r, procnew, command, argv, env,
                                              procattr, p);
-    
+
         if (rc != APR_SUCCESS) {
             /* Bad things happened. Everyone should have cleaned up. */
             ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_TOCLIENT, rc, r,
@@ -499,7 +499,7 @@ static apr_status_t default_build_command(const char **cmd, const char ***argv,
 
     if (e_info->process_cgi) {
         *cmd = r->filename;
-        /* Do not process r->args if they contain an '=' assignment 
+        /* Do not process r->args if they contain an '=' assignment
          */
         if (r->args && r->args[0] && !ap_strchr_c(r->args, '=')) {
             args = r->args;
@@ -517,9 +517,9 @@ static apr_status_t default_build_command(const char **cmd, const char ***argv,
             }
         }
     }
-    /* Everything is - 1 to account for the first parameter 
+    /* Everything is - 1 to account for the first parameter
      * which is the program name.
-     */ 
+     */
     if (numwords > APACHE_ARG_MAX - 1) {
         numwords = APACHE_ARG_MAX - 1;    /* Truncate args to prevent overrun */
     }
@@ -577,7 +577,7 @@ static apr_bucket *cgi_bucket_create(request_rec *r,
     apr_status_t rv;
     apr_pollfd_t fd;
     struct cgi_bucket_data *data = apr_palloc(r->pool, sizeof *data);
-    
+
     APR_BUCKET_INIT(b);
     b->free = apr_bucket_free;
     b->list = list;
@@ -596,12 +596,12 @@ static apr_bucket *cgi_bucket_create(request_rec *r,
     fd.client_data = (void *)1;
     rv = apr_pollset_add(data->pollset, &fd);
     AP_DEBUG_ASSERT(rv == APR_SUCCESS);
-    
+
     fd.desc.f = err; /* script's stderr */
     fd.client_data = (void *)2;
     rv = apr_pollset_add(data->pollset, &fd);
     AP_DEBUG_ASSERT(rv == APR_SUCCESS);
-    
+
     data->r = r;
     b->data = data;
     return b;
@@ -696,7 +696,7 @@ static apr_status_t cgi_bucket_read(apr_bucket *b, const char **str,
                           "poll failed waiting for CGI child");
             return rv;
         }
-        
+
         for (; num; num--, results++) {
             if (results[0].client_data == (void *)1) {
                 /* stdout */
@@ -807,7 +807,7 @@ static int cgi_handler(request_rec *r)
     /* build the command line */
     if ((rv = cgi_build_command(&command, &argv, r, p, &e_info)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
-                      "don't know how to spawn child process: %s", 
+                      "don't know how to spawn child process: %s",
                       r->filename);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -835,7 +835,7 @@ static int cgi_handler(request_rec *r)
 
         rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,
                             APR_BLOCK_READ, HUGE_STRING_LEN);
-       
+
         if (rv != APR_SUCCESS) {
             return rv;
         }
@@ -860,11 +860,11 @@ static int cgi_handler(request_rec *r)
             /* If the child stopped, we still must read to EOS. */
             if (child_stopped_reading) {
                 continue;
-            } 
+            }
 
             /* read */
             apr_bucket_read(bucket, &data, &len, APR_BLOCK_READ);
-            
+
             if (conf->logname && dbpos < conf->bufbytes) {
                 int cursize;
 
@@ -906,7 +906,7 @@ static int cgi_handler(request_rec *r)
 #if APR_FILES_AS_SOCKETS
     apr_file_pipe_timeout_set(script_in, 0);
     apr_file_pipe_timeout_set(script_err, 0);
-    
+
     b = cgi_bucket_create(r, script_in, script_err, c->bucket_alloc);
 #else
     b = apr_bucket_pipe_create(script_in, c->bucket_alloc);
@@ -956,7 +956,7 @@ static int cgi_handler(request_rec *r)
             r->method_number = M_GET;
 
             /* We already read the message body (if any), so don't allow
-             * the redirected request to think it has one.  We can ignore 
+             * the redirected request to think it has one.  We can ignore
              * Transfer-Encoding, since we used REQUEST_CHUNKED_ERROR.
              */
             apr_table_unset(r->headers_in, "Content-Length");
@@ -975,7 +975,7 @@ static int cgi_handler(request_rec *r)
     }
     else /* nph */ {
         struct ap_filter_t *cur;
-        
+
         /* get rid of all filters up through protocol...  since we
          * haven't parsed off the headers, there is no way they can
          * work
@@ -998,7 +998,7 @@ static int cgi_handler(request_rec *r)
         apr_file_pipe_timeout_set(script_err, r->server->timeout);
         log_script_err(r, script_err);
     }
-    
+
     apr_file_close(script_err);
 
     return OK;                      /* NOT r->status, even if it has changed. */
@@ -1090,7 +1090,7 @@ static apr_status_t include_cmd(include_ctx_t *ctx, ap_filter_t *f,
     if ((rv = cgi_build_command(&command, &argv, r, r->pool,
                                 &e_info)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
-                      "don't know how to spawn cmd child process: %s", 
+                      "don't know how to spawn cmd child process: %s",
                       r->filename);
         return rv;
     }
diff --git a/modules/generators/mod_cgid.c b/modules/generators/mod_cgid.c
index 89a6129..03e16a0 100644
--- a/modules/generators/mod_cgid.c
+++ b/modules/generators/mod_cgid.c
@@ -14,18 +14,18 @@
  * limitations under the License.
  */
 
-/* 
- * http_script: keeps all script-related ramblings together. 
- * 
- * Compliant to cgi/1.1 spec 
- * 
- * Adapted by rst from original NCSA code by Rob McCool 
- * 
- * Apache adds some new env vars; REDIRECT_URL and REDIRECT_QUERY_STRING for 
- * custom error responses, and DOCUMENT_ROOT because we found it useful. 
- * It also adds SERVER_ADMIN - useful for scripts to know who to mail when 
- * they fail. 
- */ 
+/*
+ * http_script: keeps all script-related ramblings together.
+ *
+ * Compliant to cgi/1.1 spec
+ *
+ * Adapted by rst from original NCSA code by Rob McCool
+ *
+ * Apache adds some new env vars; REDIRECT_URL and REDIRECT_QUERY_STRING for
+ * custom error responses, and DOCUMENT_ROOT because we found it useful.
+ * It also adds SERVER_ADMIN - useful for scripts to know who to mail when
+ * they fail.
+ */
 
 #include "apr_lib.h"
 #include "apr_strings.h"
@@ -49,17 +49,17 @@
 #include <sys/types.h>
 #endif
 
-#define CORE_PRIVATE 
+#define CORE_PRIVATE
 
 #include "util_filter.h"
-#include "httpd.h" 
-#include "http_config.h" 
-#include "http_request.h" 
-#include "http_core.h" 
-#include "http_protocol.h" 
-#include "http_main.h" 
-#include "http_log.h" 
-#include "util_script.h" 
+#include "httpd.h"
+#include "http_config.h"
+#include "http_request.h"
+#include "http_core.h"
+#include "http_protocol.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "util_script.h"
 #include "ap_mpm.h"
 #include "unixd.h"
 #include "mod_suexec.h"
@@ -73,17 +73,17 @@
 #include <sys/un.h> /* for sockaddr_un */
 
 
-module AP_MODULE_DECLARE_DATA cgid_module; 
+module AP_MODULE_DECLARE_DATA cgid_module;
 
 static int cgid_start(apr_pool_t *p, server_rec *main_server, apr_proc_t *procnew);
-static int cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *main_server); 
+static int cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *main_server);
 static int handle_exec(include_ctx_t *ctx, ap_filter_t *f, apr_bucket_brigade *bb);
 
 static APR_OPTIONAL_FN_TYPE(ap_register_include_handler) *cgid_pfn_reg_with_ssi;
 static APR_OPTIONAL_FN_TYPE(ap_ssi_get_tag_and_value) *cgid_pfn_gtv;
 static APR_OPTIONAL_FN_TYPE(ap_ssi_parse_string) *cgid_pfn_ps;
 
-static apr_pool_t *pcgi = NULL; 
+static apr_pool_t *pcgi = NULL;
 static int total_modules = 0;
 static pid_t daemon_pid;
 static int daemon_should_exit = 0;
@@ -101,26 +101,26 @@ static void discard_script_output(apr_bucket_brigade *bb);
  */
 static ap_unix_identity_t *cgid_suexec_id_doer(const request_rec *r)
 {
-    return (ap_unix_identity_t *) 
+    return (ap_unix_identity_t *)
                         ap_get_module_config(r->request_config, &cgid_module);
 }
 
 /* KLUDGE --- for back-combatibility, we don't have to check ExecCGI
- * in ScriptAliased directories, which means we need to know if this 
- * request came through ScriptAlias or not... so the Alias module 
- * leaves a note for us. 
- */ 
+ * in ScriptAliased directories, which means we need to know if this
+ * request came through ScriptAlias or not... so the Alias module
+ * leaves a note for us.
+ */
 
-static int is_scriptaliased(request_rec *r) 
-{ 
-    const char *t = apr_table_get(r->notes, "alias-forced-type"); 
-    return t && (!strcasecmp(t, "cgi-script")); 
-} 
+static int is_scriptaliased(request_rec *r)
+{
+    const char *t = apr_table_get(r->notes, "alias-forced-type");
+    return t && (!strcasecmp(t, "cgi-script"));
+}
 
-/* Configuration stuff */ 
+/* Configuration stuff */
 
-#define DEFAULT_LOGBYTES 10385760 
-#define DEFAULT_BUFBYTES 1024 
+#define DEFAULT_LOGBYTES 10385760
+#define DEFAULT_BUFBYTES 1024
 #define DEFAULT_SOCKET  DEFAULT_REL_RUNTIMEDIR "/cgisock"
 
 #define CGI_REQ    1
@@ -153,11 +153,11 @@ static int is_scriptaliased(request_rec *r)
 #define DEFAULT_CONNECT_ATTEMPTS  15
 #endif
 
-typedef struct { 
-    const char *logname; 
-    long logbytes; 
-    int bufbytes; 
-} cgid_server_conf; 
+typedef struct {
+    const char *logname;
+    long logbytes;
+    int bufbytes;
+} cgid_server_conf;
 
 typedef struct {
     int req_type; /* request type (CGI_REQ, SSI_REQ, etc.) */
@@ -199,7 +199,7 @@ static char **create_argv(apr_pool_t *p, char *path, char *user, char *group,
     }
     else {
         /* count the number of keywords */
-        
+
         for (x = 0, numwords = 1; args[x]; x++) {
             if (args[x] == '+') {
                 ++numwords;
@@ -331,16 +331,16 @@ static apr_status_t sock_write(int fd, const void *buf, size_t buf_size)
     return APR_SUCCESS;
 }
 
-static apr_status_t get_req(int fd, request_rec *r, char **argv0, char ***env, 
+static apr_status_t get_req(int fd, request_rec *r, char **argv0, char ***env,
                             cgid_req_t *req)
-{ 
-    int i; 
-    char **environ; 
-    core_request_config *temp_core; 
+{
+    int i;
+    char **environ;
+    core_request_config *temp_core;
     void **rconf;
     apr_status_t stat;
 
-    r->server = apr_pcalloc(r->pool, sizeof(server_rec)); 
+    r->server = apr_pcalloc(r->pool, sizeof(server_rec));
 
     /* read the request header */
     stat = sock_read(fd, req, sizeof(*req));
@@ -356,11 +356,11 @@ static apr_status_t get_req(int fd, request_rec *r, char **argv0, char ***env,
     /* handle module indexes and such */
     rconf = (void **) apr_pcalloc(r->pool, sizeof(void *) * (total_modules + DYNAMIC_MODULE_LIMIT));
 
-    temp_core = (core_request_config *)apr_palloc(r->pool, sizeof(core_module)); 
+    temp_core = (core_request_config *)apr_palloc(r->pool, sizeof(core_module));
     rconf[req->core_module_index] = (void *)temp_core;
-    r->request_config = (ap_conf_vector_t *)rconf; 
+    r->request_config = (ap_conf_vector_t *)rconf;
     ap_set_module_config(r->request_config, &cgid_module, (void *)&req->ugid);
-    
+
     /* Read the filename, argv0, uri, and args */
     r->filename = apr_pcalloc(r->pool, req->filename_len + 1);
     *argv0 = apr_pcalloc(r->pool, req->argv0_len + 1);
@@ -394,46 +394,46 @@ static apr_status_t get_req(int fd, request_rec *r, char **argv0, char ***env,
     *env = environ;
 
 #if 0
-#ifdef RLIMIT_CPU 
-    sock_read(fd, &j, sizeof(int)); 
-    if (j) { 
-        temp_core->limit_cpu = (struct rlimit *)apr_palloc (sizeof(struct rlimit)); 
-        sock_read(fd, temp_core->limit_cpu, sizeof(struct rlimit)); 
-    } 
-    else { 
-        temp_core->limit_cpu = NULL; 
-    } 
-#endif 
-
-#if defined (RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS) 
-    sock_read(fd, &j, sizeof(int)); 
-    if (j) { 
-        temp_core->limit_mem = (struct rlimit *)apr_palloc(r->pool, sizeof(struct rlimit)); 
-        sock_read(fd, temp_core->limit_mem, sizeof(struct rlimit)); 
-    } 
-    else { 
-        temp_core->limit_mem = NULL; 
-    } 
-#endif 
-
-#ifdef RLIMIT_NPROC 
-    sock_read(fd, &j, sizeof(int)); 
-    if (j) { 
-        temp_core->limit_nproc = (struct rlimit *)apr_palloc(r->pool, sizeof(struct rlimit)); 
-        sock_read(fd, temp_core->limit_nproc, sizeof(struct rlimit)); 
-    } 
-    else { 
-        temp_core->limit_nproc = NULL; 
-    } 
-#endif 
+#ifdef RLIMIT_CPU
+    sock_read(fd, &j, sizeof(int));
+    if (j) {
+        temp_core->limit_cpu = (struct rlimit *)apr_palloc (sizeof(struct rlimit));
+        sock_read(fd, temp_core->limit_cpu, sizeof(struct rlimit));
+    }
+    else {
+        temp_core->limit_cpu = NULL;
+    }
+#endif
+
+#if defined (RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
+    sock_read(fd, &j, sizeof(int));
+    if (j) {
+        temp_core->limit_mem = (struct rlimit *)apr_palloc(r->pool, sizeof(struct rlimit));
+        sock_read(fd, temp_core->limit_mem, sizeof(struct rlimit));
+    }
+    else {
+        temp_core->limit_mem = NULL;
+    }
+#endif
+
+#ifdef RLIMIT_NPROC
+    sock_read(fd, &j, sizeof(int));
+    if (j) {
+        temp_core->limit_nproc = (struct rlimit *)apr_palloc(r->pool, sizeof(struct rlimit));
+        sock_read(fd, temp_core->limit_nproc, sizeof(struct rlimit));
+    }
+    else {
+        temp_core->limit_nproc = NULL;
+    }
+#endif
 #endif
 
     return APR_SUCCESS;
-} 
+}
 
-static apr_status_t send_req(int fd, request_rec *r, char *argv0, char **env, 
-                             int req_type) 
-{ 
+static apr_status_t send_req(int fd, request_rec *r, char *argv0, char **env,
+                             int req_type)
+{
     int i;
     cgid_req_t req = {0};
     apr_status_t stat;
@@ -444,13 +444,13 @@ static apr_status_t send_req(int fd, request_rec *r, char *argv0, char **env,
     } else {
         memcpy(&req.ugid, ugid, sizeof(ap_unix_identity_t));
     }
-    
+
     req.req_type = req_type;
     req.ppid = parent_pid;
     req.conn_id = r->connection->id;
     req.core_module_index = core_module.module_index;
     for (req.env_count = 0; env[req.env_count]; req.env_count++) {
-        continue; 
+        continue;
     }
     req.filename_len = strlen(r->filename);
     req.argv0_len = strlen(argv0);
@@ -482,51 +482,51 @@ static apr_status_t send_req(int fd, request_rec *r, char *argv0, char **env,
         if ((stat = sock_write(fd, &curlen, sizeof(curlen))) != APR_SUCCESS) {
             return stat;
         }
-            
+
         if ((stat = sock_write(fd, env[i], curlen)) != APR_SUCCESS) {
             return stat;
         }
     }
 
 #if 0
-#ifdef RLIMIT_CPU 
-    if (conf->limit_cpu) { 
-        len = 1; 
-        stat = sock_write(fd, &len, sizeof(int)); 
-        stat = sock_write(fd, conf->limit_cpu, sizeof(struct rlimit)); 
-    } 
-    else { 
-        len = 0; 
-        stat = sock_write(fd, &len, sizeof(int)); 
-    } 
-#endif 
-
-#if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS) 
-    if (conf->limit_mem) { 
-        len = 1; 
-        stat = sock_write(fd, &len, sizeof(int)); 
-        stat = sock_write(fd, conf->limit_mem, sizeof(struct rlimit)); 
-    } 
-    else { 
-        len = 0; 
-        stat = sock_write(fd, &len, sizeof(int)); 
-    } 
-#endif 
-  
-#ifdef RLIMIT_NPROC 
-    if (conf->limit_nproc) { 
-        len = 1; 
-        stat = sock_write(fd, &len, sizeof(int)); 
-        stat = sock_write(fd, conf->limit_nproc, sizeof(struct rlimit)); 
-    } 
-    else { 
-        len = 0; 
-        stat = sock_write(fd, &len, sizeof(int)); 
-    } 
+#ifdef RLIMIT_CPU
+    if (conf->limit_cpu) {
+        len = 1;
+        stat = sock_write(fd, &len, sizeof(int));
+        stat = sock_write(fd, conf->limit_cpu, sizeof(struct rlimit));
+    }
+    else {
+        len = 0;
+        stat = sock_write(fd, &len, sizeof(int));
+    }
+#endif
+
+#if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
+    if (conf->limit_mem) {
+        len = 1;
+        stat = sock_write(fd, &len, sizeof(int));
+        stat = sock_write(fd, conf->limit_mem, sizeof(struct rlimit));
+    }
+    else {
+        len = 0;
+        stat = sock_write(fd, &len, sizeof(int));
+    }
+#endif
+
+#ifdef RLIMIT_NPROC
+    if (conf->limit_nproc) {
+        len = 1;
+        stat = sock_write(fd, &len, sizeof(int));
+        stat = sock_write(fd, conf->limit_nproc, sizeof(struct rlimit));
+    }
+    else {
+        len = 0;
+        stat = sock_write(fd, &len, sizeof(int));
+    }
 #endif
 #endif
     return APR_SUCCESS;
-} 
+}
 
 static void daemon_signal_handler(int sig)
 {
@@ -551,8 +551,8 @@ static void cgid_child_errfn(apr_pool_t *pool, apr_status_t err,
     ap_log_error(APLOG_MARK, APLOG_ERR, err, r->server, "%s", description);
 }
 
-static int cgid_server(void *data) 
-{ 
+static int cgid_server(void *data)
+{
     struct sockaddr_un unix_addr;
     int sd, sd2, rc;
     mode_t omask;
@@ -561,9 +561,9 @@ static int cgid_server(void *data)
     server_rec *main_server = data;
     apr_hash_t *script_hash = apr_hash_make(pcgi);
 
-    apr_pool_create(&ptrans, pcgi); 
+    apr_pool_create(&ptrans, pcgi);
 
-    apr_signal(SIGCHLD, SIG_IGN); 
+    apr_signal(SIGCHLD, SIG_IGN);
     apr_signal(SIGHUP, daemon_signal_handler);
 
     /* Close our copy of the listening sockets */
@@ -575,10 +575,10 @@ static int cgid_server(void *data)
     apr_hook_sort_all();
 
     if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, 
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server,
                      "Couldn't create unix domain socket");
         return errno;
-    } 
+    }
 
     memset(&unix_addr, 0, sizeof(unix_addr));
     unix_addr.sun_family = AF_UNIX;
@@ -588,34 +588,34 @@ static int cgid_server(void *data)
     rc = bind(sd, (struct sockaddr *)&unix_addr, sizeof(unix_addr));
     umask(omask); /* can't fail, so can't clobber errno */
     if (rc < 0) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, 
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server,
                      "Couldn't bind unix domain socket %s",
-                     sockname); 
+                     sockname);
         return errno;
-    } 
+    }
 
     if (listen(sd, DEFAULT_CGID_LISTENBACKLOG) < 0) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, 
-                     "Couldn't listen on unix domain socket"); 
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server,
+                     "Couldn't listen on unix domain socket");
         return errno;
-    } 
+    }
 
     if (!geteuid()) {
         if (chown(sockname, unixd_config.user_id, -1) < 0) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, 
+            ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server,
                          "Couldn't change owner of unix domain socket %s",
-                         sockname); 
+                         sockname);
             return errno;
         }
     }
-    
+
     unixd_setup_child(); /* if running as root, switch to configured user/group */
 
     while (!daemon_should_exit) {
         int errfileno = STDERR_FILENO;
-        char *argv0; 
-        char **env; 
-        const char * const *argv; 
+        char *argv0;
+        char **env;
+        const char * const *argv;
         apr_int32_t in_pipe;
         apr_int32_t out_pipe;
         apr_int32_t err_pipe;
@@ -639,17 +639,17 @@ static int cgid_server(void *data)
             }
 #endif
             if (errno != EINTR) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, errno, 
+                ap_log_error(APLOG_MARK, APLOG_ERR, errno,
                              (server_rec *)data,
                              "Error accepting on cgid socket");
             }
             continue;
         }
-       
-        r = apr_pcalloc(ptrans, sizeof(request_rec)); 
+
+        r = apr_pcalloc(ptrans, sizeof(request_rec));
         procnew = apr_pcalloc(ptrans, sizeof(*procnew));
-        r->pool = ptrans; 
-        stat = get_req(sd2, r, &argv0, &env, &cgid_req); 
+        r->pool = ptrans;
+        stat = get_req(sd2, r, &argv0, &env, &cgid_req);
         if (stat != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR, stat,
                          main_server,
@@ -696,12 +696,12 @@ static int cgid_server(void *data)
         }
 
         if (((rc = apr_procattr_create(&procattr, ptrans)) != APR_SUCCESS) ||
-            ((cgid_req.req_type == CGI_REQ) && 
+            ((cgid_req.req_type == CGI_REQ) &&
              (((rc = apr_procattr_io_set(procattr,
                                         in_pipe,
                                         out_pipe,
                                         err_pipe)) != APR_SUCCESS) ||
-              /* XXX apr_procattr_child_*_set() is creating an unnecessary 
+              /* XXX apr_procattr_child_*_set() is creating an unnecessary
                * pipe between this process and the child being created...
                * It is cleaned up with the temporary pool for this request.
                */
@@ -734,25 +734,25 @@ static int cgid_server(void *data)
             close(sd2);
 
             if (memcmp(&empty_ugid, &cgid_req.ugid, sizeof(empty_ugid))) {
-                /* We have a valid identity, and can be sure that 
-                 * cgid_suexec_id_doer will return a valid ugid 
+                /* We have a valid identity, and can be sure that
+                 * cgid_suexec_id_doer will return a valid ugid
                  */
                 rc = ap_os_create_privileged_process(r, procnew, argv0, argv,
                                                      (const char * const *)env,
                                                      procattr, ptrans);
             } else {
-                rc = apr_proc_create(procnew, argv0, argv, 
-                                     (const char * const *)env, 
+                rc = apr_proc_create(procnew, argv0, argv,
+                                     (const char * const *)env,
                                      procattr, ptrans);
             }
-                
+
             if (rc != APR_SUCCESS) {
                 /* Bad things happened. Everyone should have cleaned up.
                  * ap_log_rerror() won't work because the header table used by
                  * ap_log_rerror() hasn't been replicated in the phony r
                  */
                 ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server,
-                             "couldn't create child process: %d: %s", rc, 
+                             "couldn't create child process: %d: %s", rc,
                              apr_filepath_name_get(r->filename));
             }
             else {
@@ -779,9 +779,9 @@ static int cgid_server(void *data)
                              (void *)((long)procnew->pid));
             }
         }
-    } 
-    return -1; 
-} 
+    }
+    return -1;
+}
 
 static int cgid_start(apr_pool_t *p, server_rec *main_server,
                       apr_proc_t *procnew)
@@ -816,9 +816,9 @@ static int cgid_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
     return OK;
 }
 
-static int cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, 
-                     server_rec *main_server) 
-{ 
+static int cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
+                     server_rec *main_server)
+{
     apr_proc_t *procnew = NULL;
     int first_time = 0;
     const char *userdata_key = "cgid_init";
@@ -865,31 +865,31 @@ static int cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
         }
     }
     return ret;
-} 
+}
 
-static void *create_cgid_config(apr_pool_t *p, server_rec *s) 
-{ 
-    cgid_server_conf *c = 
-    (cgid_server_conf *) apr_pcalloc(p, sizeof(cgid_server_conf)); 
+static void *create_cgid_config(apr_pool_t *p, server_rec *s)
+{
+    cgid_server_conf *c =
+    (cgid_server_conf *) apr_pcalloc(p, sizeof(cgid_server_conf));
 
-    c->logname = NULL; 
-    c->logbytes = DEFAULT_LOGBYTES; 
-    c->bufbytes = DEFAULT_BUFBYTES; 
-    return c; 
-} 
+    c->logname = NULL;
+    c->logbytes = DEFAULT_LOGBYTES;
+    c->bufbytes = DEFAULT_BUFBYTES;
+    return c;
+}
 
-static void *merge_cgid_config(apr_pool_t *p, void *basev, void *overridesv) 
-{ 
-    cgid_server_conf *base = (cgid_server_conf *) basev, *overrides = (cgid_server_conf *) overridesv; 
+static void *merge_cgid_config(apr_pool_t *p, void *basev, void *overridesv)
+{
+    cgid_server_conf *base = (cgid_server_conf *) basev, *overrides = (cgid_server_conf *) overridesv;
 
-    return overrides->logname ? overrides : base; 
-} 
+    return overrides->logname ? overrides : base;
+}
 
-static const char *set_scriptlog(cmd_parms *cmd, void *dummy, const char *arg) 
-{ 
-    server_rec *s = cmd->server; 
+static const char *set_scriptlog(cmd_parms *cmd, void *dummy, const char *arg)
+{
+    server_rec *s = cmd->server;
     cgid_server_conf *conf = ap_get_module_config(s->module_config,
-                                                  &cgid_module); 
+                                                  &cgid_module);
 
     conf->logname = ap_server_root_relative(cmd->pool, arg);
 
@@ -897,31 +897,31 @@ static const char *set_scriptlog(cmd_parms *cmd, void *dummy, const char *arg)
         return apr_pstrcat(cmd->pool, "Invalid ScriptLog path ",
                            arg, NULL);
     }
-    return NULL; 
-} 
+    return NULL;
+}
 
-static const char *set_scriptlog_length(cmd_parms *cmd, void *dummy, const char *arg) 
-{ 
-    server_rec *s = cmd->server; 
+static const char *set_scriptlog_length(cmd_parms *cmd, void *dummy, const char *arg)
+{
+    server_rec *s = cmd->server;
     cgid_server_conf *conf = ap_get_module_config(s->module_config,
-                                                  &cgid_module); 
+                                                  &cgid_module);
 
-    conf->logbytes = atol(arg); 
-    return NULL; 
-} 
+    conf->logbytes = atol(arg);
+    return NULL;
+}
 
-static const char *set_scriptlog_buffer(cmd_parms *cmd, void *dummy, const char *arg) 
-{ 
-    server_rec *s = cmd->server; 
+static const char *set_scriptlog_buffer(cmd_parms *cmd, void *dummy, const char *arg)
+{
+    server_rec *s = cmd->server;
     cgid_server_conf *conf = ap_get_module_config(s->module_config,
-                                                  &cgid_module); 
+                                                  &cgid_module);
 
-    conf->bufbytes = atoi(arg); 
-    return NULL; 
-} 
+    conf->bufbytes = atoi(arg);
+    return NULL;
+}
 
-static const char *set_script_socket(cmd_parms *cmd, void *dummy, const char *arg) 
-{ 
+static const char *set_script_socket(cmd_parms *cmd, void *dummy, const char *arg)
+{
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -929,126 +929,126 @@ static const char *set_script_socket(cmd_parms *cmd, void *dummy, const char *ar
 
     /* Make sure the pid is appended to the sockname */
     sockname = ap_append_pid(cmd->pool, arg, ".");
-    sockname = ap_server_root_relative(cmd->pool, sockname); 
+    sockname = ap_server_root_relative(cmd->pool, sockname);
 
     if (!sockname) {
         return apr_pstrcat(cmd->pool, "Invalid ScriptSock path",
                            arg, NULL);
     }
 
-    return NULL; 
-} 
+    return NULL;
+}
 
-static const command_rec cgid_cmds[] = 
-{ 
+static const command_rec cgid_cmds[] =
+{
     AP_INIT_TAKE1("ScriptLog", set_scriptlog, NULL, RSRC_CONF,
-                  "the name of a log for script debugging info"), 
+                  "the name of a log for script debugging info"),
     AP_INIT_TAKE1("ScriptLogLength", set_scriptlog_length, NULL, RSRC_CONF,
-                  "the maximum length (in bytes) of the script debug log"), 
+                  "the maximum length (in bytes) of the script debug log"),
     AP_INIT_TAKE1("ScriptLogBuffer", set_scriptlog_buffer, NULL, RSRC_CONF,
-                  "the maximum size (in bytes) to record of a POST request"), 
+                  "the maximum size (in bytes) to record of a POST request"),
     AP_INIT_TAKE1("ScriptSock", set_script_socket, NULL, RSRC_CONF,
                   "the name of the socket to use for communication with "
-                  "the cgi daemon."), 
-    {NULL} 
-}; 
-
-static int log_scripterror(request_rec *r, cgid_server_conf * conf, int ret, 
-                           apr_status_t rv, char *error) 
-{ 
-    apr_file_t *f = NULL; 
-    struct stat finfo; 
+                  "the cgi daemon."),
+    {NULL}
+};
+
+static int log_scripterror(request_rec *r, cgid_server_conf * conf, int ret,
+                           apr_status_t rv, char *error)
+{
+    apr_file_t *f = NULL;
+    struct stat finfo;
     char time_str[APR_CTIME_LEN];
     int log_flags = rv ? APLOG_ERR : APLOG_ERR;
 
-    ap_log_rerror(APLOG_MARK, log_flags, rv, r, 
-                "%s: %s", error, r->filename); 
+    ap_log_rerror(APLOG_MARK, log_flags, rv, r,
+                "%s: %s", error, r->filename);
 
     /* XXX Very expensive mainline case! Open, then getfileinfo! */
-    if (!conf->logname || 
-        ((stat(conf->logname, &finfo) == 0) 
-         && (finfo.st_size > conf->logbytes)) || 
+    if (!conf->logname ||
+        ((stat(conf->logname, &finfo) == 0)
+         && (finfo.st_size > conf->logbytes)) ||
          (apr_file_open(&f, conf->logname,
-                  APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) { 
-        return ret; 
-    } 
+                  APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) {
+        return ret;
+    }
 
-    /* "%% [Wed Jun 19 10:53:21 1996] GET /cgid-bin/printenv HTTP/1.0" */ 
+    /* "%% [Wed Jun 19 10:53:21 1996] GET /cgid-bin/printenv HTTP/1.0" */
     apr_ctime(time_str, apr_time_now());
-    apr_file_printf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, 
-            r->args ? "?" : "", r->args ? r->args : "", r->protocol); 
-    /* "%% 500 /usr/local/apache/cgid-bin */ 
-    apr_file_printf(f, "%%%% %d %s\n", ret, r->filename); 
+    apr_file_printf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri,
+            r->args ? "?" : "", r->args ? r->args : "", r->protocol);
+    /* "%% 500 /usr/local/apache/cgid-bin */
+    apr_file_printf(f, "%%%% %d %s\n", ret, r->filename);
 
-    apr_file_printf(f, "%%error\n%s\n", error); 
+    apr_file_printf(f, "%%error\n%s\n", error);
 
-    apr_file_close(f); 
-    return ret; 
-} 
+    apr_file_close(f);
+    return ret;
+}
 
-static int log_script(request_rec *r, cgid_server_conf * conf, int ret, 
+static int log_script(request_rec *r, cgid_server_conf * conf, int ret,
                       char *dbuf, const char *sbuf, apr_bucket_brigade *bb,
-                      apr_file_t *script_err) 
-{ 
-    const apr_array_header_t *hdrs_arr = apr_table_elts(r->headers_in); 
-    const apr_table_entry_t *hdrs = (apr_table_entry_t *) hdrs_arr->elts; 
-    char argsbuffer[HUGE_STRING_LEN]; 
-    apr_file_t *f = NULL; 
+                      apr_file_t *script_err)
+{
+    const apr_array_header_t *hdrs_arr = apr_table_elts(r->headers_in);
+    const apr_table_entry_t *hdrs = (apr_table_entry_t *) hdrs_arr->elts;
+    char argsbuffer[HUGE_STRING_LEN];
+    apr_file_t *f = NULL;
     apr_bucket *e;
     const char *buf;
     apr_size_t len;
     apr_status_t rv;
     int first;
-    int i; 
-    struct stat finfo; 
+    int i;
+    struct stat finfo;
     char time_str[APR_CTIME_LEN];
 
     /* XXX Very expensive mainline case! Open, then getfileinfo! */
-    if (!conf->logname || 
-        ((stat(conf->logname, &finfo) == 0) 
-         && (finfo.st_size > conf->logbytes)) || 
-         (apr_file_open(&f, conf->logname, 
-                  APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) { 
-        /* Soak up script output */ 
+    if (!conf->logname ||
+        ((stat(conf->logname, &finfo) == 0)
+         && (finfo.st_size > conf->logbytes)) ||
+         (apr_file_open(&f, conf->logname,
+                  APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) {
+        /* Soak up script output */
         discard_script_output(bb);
         if (script_err) {
-            while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, 
-                                 script_err) == APR_SUCCESS) 
-                continue; 
+            while (apr_file_gets(argsbuffer, HUGE_STRING_LEN,
+                                 script_err) == APR_SUCCESS)
+                continue;
         }
-        return ret; 
-    } 
+        return ret;
+    }
 
-    /* "%% [Wed Jun 19 10:53:21 1996] GET /cgid-bin/printenv HTTP/1.0" */ 
+    /* "%% [Wed Jun 19 10:53:21 1996] GET /cgid-bin/printenv HTTP/1.0" */
     apr_ctime(time_str, apr_time_now());
-    apr_file_printf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, 
-            r->args ? "?" : "", r->args ? r->args : "", r->protocol); 
-    /* "%% 500 /usr/local/apache/cgid-bin" */ 
-    apr_file_printf(f, "%%%% %d %s\n", ret, r->filename); 
-
-    apr_file_puts("%request\n", f); 
-    for (i = 0; i < hdrs_arr->nelts; ++i) { 
-        if (!hdrs[i].key) 
-            continue; 
-        apr_file_printf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val); 
-    } 
-    if ((r->method_number == M_POST || r->method_number == M_PUT) 
-        && *dbuf) { 
-        apr_file_printf(f, "\n%s\n", dbuf); 
-    } 
-
-    apr_file_puts("%response\n", f); 
-    hdrs_arr = apr_table_elts(r->err_headers_out); 
-    hdrs = (const apr_table_entry_t *) hdrs_arr->elts; 
-
-    for (i = 0; i < hdrs_arr->nelts; ++i) { 
-        if (!hdrs[i].key) 
-            continue; 
-        apr_file_printf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val); 
-    } 
-
-    if (sbuf && *sbuf) 
-        apr_file_printf(f, "%s\n", sbuf); 
+    apr_file_printf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri,
+            r->args ? "?" : "", r->args ? r->args : "", r->protocol);
+    /* "%% 500 /usr/local/apache/cgid-bin" */
+    apr_file_printf(f, "%%%% %d %s\n", ret, r->filename);
+
+    apr_file_puts("%request\n", f);
+    for (i = 0; i < hdrs_arr->nelts; ++i) {
+        if (!hdrs[i].key)
+            continue;
+        apr_file_printf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
+    }
+    if ((r->method_number == M_POST || r->method_number == M_PUT)
+        && *dbuf) {
+        apr_file_printf(f, "\n%s\n", dbuf);
+    }
+
+    apr_file_puts("%response\n", f);
+    hdrs_arr = apr_table_elts(r->err_headers_out);
+    hdrs = (const apr_table_entry_t *) hdrs_arr->elts;
+
+    for (i = 0; i < hdrs_arr->nelts; ++i) {
+        if (!hdrs[i].key)
+            continue;
+        apr_file_printf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
+    }
+
+    if (sbuf && *sbuf)
+        apr_file_printf(f, "%s\n", sbuf);
 
     first = 1;
 
@@ -1072,29 +1072,29 @@ static int log_script(request_rec *r, cgid_server_conf * conf, int ret,
     }
 
     if (script_err) {
-        if (apr_file_gets(argsbuffer, HUGE_STRING_LEN, 
-                          script_err) == APR_SUCCESS) { 
-            apr_file_puts("%stderr\n", f); 
-            apr_file_puts(argsbuffer, f); 
-            while (apr_file_gets(argsbuffer, HUGE_STRING_LEN, 
-                                 script_err) == APR_SUCCESS) 
-                apr_file_puts(argsbuffer, f); 
-            apr_file_puts("\n", f); 
-        } 
+        if (apr_file_gets(argsbuffer, HUGE_STRING_LEN,
+                          script_err) == APR_SUCCESS) {
+            apr_file_puts("%stderr\n", f);
+            apr_file_puts(argsbuffer, f);
+            while (apr_file_gets(argsbuffer, HUGE_STRING_LEN,
+                                 script_err) == APR_SUCCESS)
+                apr_file_puts(argsbuffer, f);
+            apr_file_puts("\n", f);
+        }
     }
 
     if (script_err) {
-        apr_file_close(script_err); 
+        apr_file_close(script_err);
     }
 
-    apr_file_close(f); 
-    return ret; 
-} 
+    apr_file_close(f);
+    return ret;
+}
 
 static apr_status_t close_unix_socket(void *thefd)
 {
     int fd = (int)((long)thefd);
-    
+
     return close(fd);
 }
 
@@ -1115,7 +1115,7 @@ static int connect_to_daemon(int *sdptr, request_rec *r,
     while (1) {
         ++connect_tries;
         if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-            return log_scripterror(r, conf, HTTP_INTERNAL_SERVER_ERROR, errno, 
+            return log_scripterror(r, conf, HTTP_INTERNAL_SERVER_ERROR, errno,
                                    "unable to create socket to cgi daemon");
         }
         if (connect(sd, (struct sockaddr *)&unix_addr, sizeof(unix_addr)) < 0) {
@@ -1131,7 +1131,7 @@ static int connect_to_daemon(int *sdptr, request_rec *r,
             }
             else {
                 close(sd);
-                return log_scripterror(r, conf, HTTP_SERVICE_UNAVAILABLE, errno, 
+                return log_scripterror(r, conf, HTTP_SERVICE_UNAVAILABLE, errno,
                                        "unable to connect to cgi daemon after multiple tries");
             }
         }
@@ -1171,10 +1171,10 @@ static void discard_script_output(apr_bucket_brigade *bb)
     }
 }
 
-/**************************************************************** 
- * 
- * Actual cgid handling... 
- */ 
+/****************************************************************
+ *
+ * Actual cgid handling...
+ */
 
 struct cleanup_script_info {
     request_rec *r;
@@ -1271,18 +1271,18 @@ static apr_status_t cleanup_script(void *vptr)
     return cleanup_nonchild_process(info->r, pid);
 }
 
-static int cgid_handler(request_rec *r) 
-{ 
+static int cgid_handler(request_rec *r)
+{
     conn_rec *c = r->connection;
-    int retval, nph, dbpos = 0; 
-    char *argv0, *dbuf = NULL; 
+    int retval, nph, dbpos = 0;
+    char *argv0, *dbuf = NULL;
     apr_bucket_brigade *bb;
     apr_bucket *b;
     cgid_server_conf *conf;
     int is_included;
     int seen_eos, child_stopped_reading;
     int sd;
-    char **env; 
+    char **env;
     apr_file_t *tempsock;
     struct cleanup_script_info *info;
     apr_status_t rv;
@@ -1290,36 +1290,36 @@ static int cgid_handler(request_rec *r)
     if (strcmp(r->handler,CGI_MAGIC_TYPE) && strcmp(r->handler,"cgi-script"))
         return DECLINED;
 
-    conf = ap_get_module_config(r->server->module_config, &cgid_module); 
-    is_included = !strcmp(r->protocol, "INCLUDED"); 
+    conf = ap_get_module_config(r->server->module_config, &cgid_module);
+    is_included = !strcmp(r->protocol, "INCLUDED");
 
     if ((argv0 = strrchr(r->filename, '/')) != NULL)
         argv0++;
     else
         argv0 = r->filename;
- 
-    nph = !(strncmp(argv0, "nph-", 4)); 
 
-    argv0 = r->filename; 
+    nph = !(strncmp(argv0, "nph-", 4));
 
-    if (!(ap_allow_options(r) & OPT_EXECCGI) && !is_scriptaliased(r)) 
-        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, 
-                               "Options ExecCGI is off in this directory"); 
-    if (nph && is_included) 
-        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, 
-                               "attempt to include NPH CGI script"); 
+    argv0 = r->filename;
+
+    if (!(ap_allow_options(r) & OPT_EXECCGI) && !is_scriptaliased(r))
+        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,
+                               "Options ExecCGI is off in this directory");
+    if (nph && is_included)
+        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,
+                               "attempt to include NPH CGI script");
 
 #if defined(OS2) || defined(WIN32)
-#error mod_cgid does not work on this platform.  If you teach it to, look 
+#error mod_cgid does not work on this platform.  If you teach it to, look
 #error at mod_cgi.c for required code in this path.
-#else 
-    if (r->finfo.filetype == 0) 
-        return log_scripterror(r, conf, HTTP_NOT_FOUND, 0, 
-                               "script not found or unable to stat"); 
-#endif 
-    if (r->finfo.filetype == APR_DIR) 
-        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, 
-                               "attempt to invoke directory as script"); 
+#else
+    if (r->finfo.filetype == 0)
+        return log_scripterror(r, conf, HTTP_NOT_FOUND, 0,
+                               "script not found or unable to stat");
+#endif
+    if (r->finfo.filetype == APR_DIR)
+        return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,
+                               "attempt to invoke directory as script");
 
     if ((r->used_path_info == AP_REQ_REJECT_PATH_INFO) &&
         r->path_info && *r->path_info)
@@ -1329,21 +1329,21 @@ static int cgid_handler(request_rec *r)
                                "AcceptPathInfo off disallows user's path");
     }
 /*
-    if (!ap_suexec_enabled) { 
-        if (!ap_can_exec(&r->finfo)) 
-            return log_scripterror(r, conf, HTTP_FORBIDDEN, 0, 
-                                   "file permissions deny server execution"); 
-    } 
+    if (!ap_suexec_enabled) {
+        if (!ap_can_exec(&r->finfo))
+            return log_scripterror(r, conf, HTTP_FORBIDDEN, 0,
+                                   "file permissions deny server execution");
+    }
 */
-    ap_add_common_vars(r); 
-    ap_add_cgi_vars(r); 
-    env = ap_create_environment(r->pool, r->subprocess_env); 
+    ap_add_common_vars(r);
+    ap_add_cgi_vars(r);
+    env = ap_create_environment(r->pool, r->subprocess_env);
 
     if ((retval = connect_to_daemon(&sd, r, conf)) != OK) {
         return retval;
     }
 
-    rv = send_req(sd, r, argv0, env, CGI_REQ); 
+    rv = send_req(sd, r, argv0, env, CGI_REQ);
     if (rv != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                      "write to cgi daemon process");
@@ -1361,18 +1361,18 @@ static int cgid_handler(request_rec *r)
      * a cleanup for the apr_file_t which will close the socket, so we'll
      * get rid of the cleanup we registered when we created the socket.
      */
-    
+
     apr_os_pipe_put_ex(&tempsock, &sd, 1, r->pool);
     apr_pool_cleanup_kill(r->pool, (void *)((long)sd), close_unix_socket);
 
-    if ((argv0 = strrchr(r->filename, '/')) != NULL) 
-        argv0++; 
-    else 
-        argv0 = r->filename; 
+    if ((argv0 = strrchr(r->filename, '/')) != NULL)
+        argv0++;
+    else
+        argv0 = r->filename;
 
-    /* Transfer any put/post args, CERN style... 
-     * Note that we already ignore SIGPIPE in the core server. 
-     */ 
+    /* Transfer any put/post args, CERN style...
+     * Note that we already ignore SIGPIPE in the core server.
+     */
     bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
     seen_eos = 0;
     child_stopped_reading = 0;
@@ -1385,11 +1385,11 @@ static int cgid_handler(request_rec *r)
 
         rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,
                             APR_BLOCK_READ, HUGE_STRING_LEN);
-       
+
         if (rv != APR_SUCCESS) {
             return rv;
         }
- 
+
         for (bucket = APR_BRIGADE_FIRST(bb);
              bucket != APR_BRIGADE_SENTINEL(bb);
              bucket = APR_BUCKET_NEXT(bucket))
@@ -1410,11 +1410,11 @@ static int cgid_handler(request_rec *r)
             /* If the child stopped, we still must read to EOS. */
             if (child_stopped_reading) {
                 continue;
-            } 
+            }
 
             /* read */
             apr_bucket_read(bucket, &data, &len, APR_BLOCK_READ);
-            
+
             if (conf->logname && dbpos < conf->bufbytes) {
                 int cursize;
 
@@ -1441,7 +1441,7 @@ static int cgid_handler(request_rec *r)
         apr_brigade_cleanup(bb);
     }
     while (!seen_eos);
- 
+
     if (conf->logname) {
         dbuf[dbpos] = '\0';
     }
@@ -1452,11 +1452,11 @@ static int cgid_handler(request_rec *r)
      */
     shutdown(sd, 1);
 
-    /* Handle script return... */ 
-    if (!nph) { 
-        const char *location; 
-        char sbuf[MAX_STRING_LEN]; 
-        int ret; 
+    /* Handle script return... */
+    if (!nph) {
+        const char *location;
+        char sbuf[MAX_STRING_LEN];
+        int ret;
 
         bb = apr_brigade_create(r->pool, c->bucket_alloc);
         b = apr_bucket_pipe_create(tempsock, c->bucket_alloc);
@@ -1464,47 +1464,47 @@ static int cgid_handler(request_rec *r)
         b = apr_bucket_eos_create(c->bucket_alloc);
         APR_BRIGADE_INSERT_TAIL(bb, b);
 
-        if ((ret = ap_scan_script_header_err_brigade(r, bb, sbuf))) { 
-            return log_script(r, conf, ret, dbuf, sbuf, bb, NULL); 
-        } 
+        if ((ret = ap_scan_script_header_err_brigade(r, bb, sbuf))) {
+            return log_script(r, conf, ret, dbuf, sbuf, bb, NULL);
+        }
 
-        location = apr_table_get(r->headers_out, "Location"); 
+        location = apr_table_get(r->headers_out, "Location");
 
-        if (location && location[0] == '/' && r->status == 200) { 
+        if (location && location[0] == '/' && r->status == 200) {
 
             /* Soak up all the script output */
             discard_script_output(bb);
             apr_brigade_destroy(bb);
-            /* This redirect needs to be a GET no matter what the original 
-             * method was. 
-             */ 
-            r->method = apr_pstrdup(r->pool, "GET"); 
-            r->method_number = M_GET; 
-
-            /* We already read the message body (if any), so don't allow 
-             * the redirected request to think it has one. We can ignore 
-             * Transfer-Encoding, since we used REQUEST_CHUNKED_ERROR. 
-             */ 
-            apr_table_unset(r->headers_in, "Content-Length"); 
-
-            ap_internal_redirect_handler(location, r); 
-            return OK; 
-        } 
-        else if (location && r->status == 200) { 
-            /* XX Note that if a script wants to produce its own Redirect 
-             * body, it now has to explicitly *say* "Status: 302" 
-             */ 
+            /* This redirect needs to be a GET no matter what the original
+             * method was.
+             */
+            r->method = apr_pstrdup(r->pool, "GET");
+            r->method_number = M_GET;
+
+            /* We already read the message body (if any), so don't allow
+             * the redirected request to think it has one. We can ignore
+             * Transfer-Encoding, since we used REQUEST_CHUNKED_ERROR.
+             */
+            apr_table_unset(r->headers_in, "Content-Length");
+
+            ap_internal_redirect_handler(location, r);
+            return OK;
+        }
+        else if (location && r->status == 200) {
+            /* XX Note that if a script wants to produce its own Redirect
+             * body, it now has to explicitly *say* "Status: 302"
+             */
             discard_script_output(bb);
             apr_brigade_destroy(bb);
-            return HTTP_MOVED_TEMPORARILY; 
-        } 
+            return HTTP_MOVED_TEMPORARILY;
+        }
 
         ap_pass_brigade(r->output_filters, bb);
-    } 
+    }
 
     if (nph) {
         struct ap_filter_t *cur;
-        
+
         /* get rid of all filters up through protocol...  since we
          * haven't parsed off the headers, there is no way they can
          * work
@@ -1522,10 +1522,10 @@ static int cgid_handler(request_rec *r)
         b = apr_bucket_eos_create(c->bucket_alloc);
         APR_BRIGADE_INSERT_TAIL(bb, b);
         ap_pass_brigade(r->output_filters, bb);
-    } 
+    }
 
-    return OK; /* NOT r->status, even if it has changed. */ 
-} 
+    return OK; /* NOT r->status, even if it has changed. */
+}
 
 
 
@@ -1622,13 +1622,13 @@ static void add_ssi_vars(request_rec *r)
 static int include_cmd(include_ctx_t *ctx, ap_filter_t *f,
                        apr_bucket_brigade *bb, char *command)
 {
-    char **env; 
+    char **env;
     int sd;
     int retval;
     apr_file_t *tempsock = NULL;
     request_rec *r = f->r;
     cgid_server_conf *conf = ap_get_module_config(r->server->module_config,
-                                                  &cgid_module); 
+                                                  &cgid_module);
     struct cleanup_script_info *info;
 
     add_ssi_vars(r);
@@ -1638,14 +1638,14 @@ static int include_cmd(include_ctx_t *ctx, ap_filter_t *f,
         return retval;
     }
 
-    send_req(sd, r, command, env, SSI_REQ); 
+    send_req(sd, r, command, env, SSI_REQ);
 
     info = apr_palloc(r->pool, sizeof(struct cleanup_script_info));
     info->r = r;
     info->conn_id = r->connection->id;
     info->conf = conf;
     /* for this type of request, the script is invoked through an
-     * intermediate shell process...  cleanup_script is only able 
+     * intermediate shell process...  cleanup_script is only able
      * to knock out the shell process, not the actual script
      */
     apr_pool_cleanup_register(r->pool, info,
@@ -1761,13 +1761,13 @@ static void register_hook(apr_pool_t *p)
     ap_hook_handler(cgid_handler, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
-module AP_MODULE_DECLARE_DATA cgid_module = { 
-    STANDARD20_MODULE_STUFF, 
-    NULL, /* dir config creater */ 
-    NULL, /* dir merger --- default is to override */ 
-    create_cgid_config, /* server config */ 
-    merge_cgid_config, /* merge server config */ 
-    cgid_cmds, /* command table */ 
-    register_hook /* register_handlers */ 
-}; 
+module AP_MODULE_DECLARE_DATA cgid_module = {
+    STANDARD20_MODULE_STUFF,
+    NULL, /* dir config creater */
+    NULL, /* dir merger --- default is to override */
+    create_cgid_config, /* server config */
+    merge_cgid_config, /* merge server config */
+    cgid_cmds, /* command table */
+    register_hook /* register_handlers */
+};
 
diff --git a/modules/generators/mod_info.c b/modules/generators/mod_info.c
index a944c38..f34972e 100644
--- a/modules/generators/mod_info.c
+++ b/modules/generators/mod_info.c
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-/* 
+/*
  * Info Module.  Display configuration information for the server and
  * all included modules.
  *
@@ -29,15 +29,15 @@
  * GET /server-info?config - Returns full configuration
  * GET /server-info?hooks - Returns a listing of the modules active for each hook
  *
- * Original Author: 
+ * Original Author:
  *   Rasmus Lerdorf <rasmus vex.net>, May 1996
  *
- * Modified By: 
+ * Modified By:
  *   Lou Langholtz <ldl usi.utah.edu>, July 1997
  *
  * Apache 2.0 Port:
  *   Ryan Morgan <rmorgan covalent.net>, August 2000
- * 
+ *
  */
 
 
@@ -220,7 +220,7 @@ typedef struct
  * hook_get_t is a pointer to a function that takes void as an argument and
  * returns a pointer to an apr_array_header_t.  The nasty WIN32 ifdef
  * is required to account for the fact that the ap_hook* calls all use
- * STDCALL calling convention. 
+ * STDCALL calling convention.
  */
 typedef apr_array_header_t *(
 #ifdef WIN32
@@ -387,8 +387,8 @@ static int show_server_settings(request_rec * r)
     ap_rputs("<dt><strong>Server Built With:</strong>\n"
              "<tt style=\"white-space: pre;\">\n", r);
 
-    /* TODO: Not all of these defines are getting set like they do in main.c. 
-     *       Missing some headers? 
+    /* TODO: Not all of these defines are getting set like they do in main.c.
+     *       Missing some headers?
      */
 
 #ifdef BIG_SECURITY_HOLE
diff --git a/modules/generators/mod_status.c b/modules/generators/mod_status.c
index 6f28d02..cf121a4 100644
--- a/modules/generators/mod_status.c
+++ b/modules/generators/mod_status.c
@@ -233,7 +233,7 @@ static int status_handler(request_rec *r)
     clock_t tu, ts, tcu, tcs;
     ap_generation_t worker_generation;
 
-    if (strcmp(r->handler, STATUS_MAGIC_TYPE) && 
+    if (strcmp(r->handler, STATUS_MAGIC_TYPE) &&
         strcmp(r->handler, "server-status")) {
         return DECLINED;
     }
@@ -288,7 +288,7 @@ static int status_handler(request_rec *r)
                                 + 1) > 0)
                         apr_table_set(r->headers_out,
                                       status_options[i].hdr_out_str,
-                                      loc + 
+                                      loc +
                                       strlen(status_options[i].hdr_out_str) +
                                       1);
                     else
@@ -314,7 +314,7 @@ static int status_handler(request_rec *r)
         clock_t proc_tu = 0, proc_ts = 0, proc_tcu = 0, proc_tcs = 0;
         clock_t tmp_tu, tmp_ts, tmp_tcu, tmp_tcs;
 #endif
-        
+
         ps_record = ap_get_scoreboard_process(i);
         for (j = 0; j < thread_limit; ++j) {
             int indx = (i * thread_limit) + j;
@@ -574,7 +574,7 @@ static int status_handler(request_rec *r)
                     req_time = 0L;
                 else
                     req_time = (long)
-                        ((ws_record->stop_time - 
+                        ((ws_record->stop_time -
                           ws_record->start_time) / 1000);
                 if (req_time < 0L)
                     req_time = 0L;
@@ -593,7 +593,7 @@ static int status_handler(request_rec *r)
                     worker_pid = ps_record->pid;
                     worker_generation = ps_record->generation;
                 }
- 
+
                 if (no_table_report) {
                     if (ws_record->status == SERVER_DEAD)
                         ap_rprintf(r,
@@ -607,7 +607,7 @@ static int status_handler(request_rec *r)
                                    i, (int) worker_generation,
                                    worker_pid,
                                    (int)conn_lres, my_lres, lres);
-                    
+
                     switch (ws_record->status) {
                     case SERVER_READY:
                         ap_rputs("Ready", r);
@@ -646,7 +646,7 @@ static int status_handler(request_rec *r)
                         ap_rputs("?STATE?", r);
                         break;
                     }
-                    
+
                     ap_rprintf(r, "] "
 #ifdef HAVE_TIMES
                                "u%g s%g cu%g cs%g"
@@ -692,7 +692,7 @@ static int status_handler(request_rec *r)
                                    worker_pid,
                                    (int)conn_lres,
                                    my_lres, lres);
-                    
+
                     switch (ws_record->status) {
                     case SERVER_READY:
                         ap_rputs("</td><td>_", r);
@@ -731,7 +731,7 @@ static int status_handler(request_rec *r)
                         ap_rputs("</td><td>?", r);
                         break;
                     }
-                    
+
                     ap_rprintf(r,
                                "\n</td>"
 #ifdef HAVE_TIMES
@@ -747,11 +747,11 @@ static int status_handler(request_rec *r)
                                (long)apr_time_sec(nowtime -
                                                   ws_record->last_used),
                                (long)req_time);
-                    
+
                     ap_rprintf(r, "</td><td>%-1.1f</td><td>%-2.2f</td><td>%-2.2f\n",
                                (float)conn_bytes / KBYTE, (float) my_bytes / MBYTE,
                                (float)bytes / MBYTE);
-                    
+
                     if (ws_record->status == SERVER_BUSY_READ)
                         ap_rprintf(r,
                                    "</td><td>?</td><td nowrap>?</td><td nowrap>..reading.. </td></tr>\n\n");
@@ -800,11 +800,11 @@ static int status_handler(request_rec *r)
 
     {
         /* Run extension hooks to insert extra content. */
-        int flags = 
-            (short_report ? AP_STATUS_SHORT : 0) | 
+        int flags =
+            (short_report ? AP_STATUS_SHORT : 0) |
             (no_table_report ? AP_STATUS_NOTABLE : 0) |
             (ap_extended_status ? AP_STATUS_EXTENDED : 0);
-        
+
         ap_run_status_hook(r, flags);
     }
 
diff --git a/modules/http/byterange_filter.c b/modules/http/byterange_filter.c
index 06a0167..bf4bd54 100644
--- a/modules/http/byterange_filter.c
+++ b/modules/http/byterange_filter.c
@@ -170,29 +170,29 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(ap_filter_t *f,
     }
 
     num_ranges = ap_set_byterange(r);
-    
+
     /* We have nothing to do, get out of the way. */
     if (num_ranges == 0) {
         ap_remove_output_filter(f);
         return ap_pass_brigade(f->next, bb);
     }
-    
+
     ctx = apr_pcalloc(r->pool, sizeof(*ctx));
     ctx->num_ranges = num_ranges;
     /* create a brigade in case we never call ap_save_brigade() */
     ctx->bb = apr_brigade_create(r->pool, c->bucket_alloc);
-    
+
     if (ctx->num_ranges > 1) {
         /* Is ap_make_content_type required here? */
         const char *orig_ct = ap_make_content_type(r, r->content_type);
         ctx->boundary = apr_psprintf(r->pool, "%" APR_UINT64_T_HEX_FMT "%lx",
                                      (apr_uint64_t)r->request_time, (long) getpid());
-        
+
         ap_set_content_type(r, apr_pstrcat(r->pool, "multipart",
                                            use_range_x(r) ? "/x-" : "/",
                                            "byteranges; boundary=",
                                            ctx->boundary, NULL));
-        
+
         ctx->bound_head = apr_pstrcat(r->pool,
                                       CRLF "--", ctx->boundary,
                                       CRLF "Content-type: ",
diff --git a/modules/http/chunk_filter.c b/modules/http/chunk_filter.c
index c5175e6..4bbb27a 100644
--- a/modules/http/chunk_filter.c
+++ b/modules/http/chunk_filter.c
@@ -52,7 +52,7 @@ apr_status_t ap_http_chunk_filter(ap_filter_t *f, apr_bucket_brigade *b)
         apr_off_t bytes = 0;
         apr_bucket *eos = NULL;
         apr_bucket *flush = NULL;
-        /* XXX: chunk_hdr must remain at this scope since it is used in a 
+        /* XXX: chunk_hdr must remain at this scope since it is used in a
          *      transient bucket.
          */
         char chunk_hdr[20]; /* enough space for the snprintf below */
diff --git a/modules/http/http_core.c b/modules/http/http_core.c
index 6b4c9e6..e6d75ae 100644
--- a/modules/http/http_core.c
+++ b/modules/http/http_core.c
@@ -54,7 +54,7 @@ static const char *set_keep_alive_timeout(cmd_parms *cmd, void *dummy,
 }
 
 static const char *set_keep_alive(cmd_parms *cmd, void *dummy,
-                                  const char *arg) 
+                                  const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
     if (err != NULL) {
@@ -110,17 +110,17 @@ static int ap_process_http_async_connection(conn_rec *c)
 {
     request_rec *r;
     conn_state_t *cs = c->cs;
-    
+
     AP_DEBUG_ASSERT(cs->state == CONN_STATE_READ_REQUEST_LINE);
-    
+
     while (cs->state == CONN_STATE_READ_REQUEST_LINE) {
         ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);
-            
+
         if ((r = ap_read_request(c))) {
 
             c->keepalive = AP_CONN_UNKNOWN;
             /* process the request if it was read without error */
-                                                       
+
             ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);
             if (r->status == HTTP_OK) {
                 cs->state = CONN_STATE_HANDLER;
@@ -158,13 +158,13 @@ static int ap_process_http_connection(conn_rec *c)
      * Read and process each request found on our connection
      * until no requests are left or we decide to close.
      */
- 
+
     ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);
     while ((r = ap_read_request(c)) != NULL) {
 
         c->keepalive = AP_CONN_UNKNOWN;
         /* process the request if it was read without error */
- 
+
         ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);
         if (r->status == HTTP_OK) {
             cs->state = CONN_STATE_HANDLER;
@@ -181,9 +181,9 @@ static int ap_process_http_connection(conn_rec *c)
 
         if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted)
             break;
- 
+
         ap_update_child_status(c->sbh, SERVER_BUSY_KEEPALIVE, NULL);
- 
+
         if (ap_graceful_stop_signalled())
             break;
 
@@ -194,7 +194,7 @@ static int ap_process_http_connection(conn_rec *c)
         apr_socket_timeout_set(csd, c->base_server->keep_alive_timeout);
         /* Go straight to select() to wait for the next request */
     }
- 
+
     return OK;
 }
 
@@ -219,13 +219,13 @@ static void register_hooks(apr_pool_t *p)
      * use a different processing function
      */
     int async_mpm = 0;
-    if (ap_mpm_query(AP_MPMQ_IS_ASYNC, &async_mpm) == APR_SUCCESS 
+    if (ap_mpm_query(AP_MPMQ_IS_ASYNC, &async_mpm) == APR_SUCCESS
         && async_mpm == 1) {
         ap_hook_process_connection(ap_process_http_async_connection, NULL,
                                    NULL, APR_HOOK_REALLY_LAST);
     }
     else {
-        ap_hook_process_connection(ap_process_http_connection, NULL, NULL, 
+        ap_hook_process_connection(ap_process_http_connection, NULL, NULL,
                                    APR_HOOK_REALLY_LAST);
     }
 
@@ -237,7 +237,7 @@ static void register_hooks(apr_pool_t *p)
         ap_register_input_filter("HTTP_IN", ap_http_filter,
                                  NULL, AP_FTYPE_PROTOCOL);
     ap_http_header_filter_handle =
-        ap_register_output_filter("HTTP_HEADER", ap_http_header_filter, 
+        ap_register_output_filter("HTTP_HEADER", ap_http_header_filter,
                                   NULL, AP_FTYPE_PROTOCOL);
     ap_chunk_filter_handle =
         ap_register_output_filter("CHUNK", ap_http_chunk_filter,
diff --git a/modules/http/http_etag.c b/modules/http/http_etag.c
index 765ee97..8cd955d 100644
--- a/modules/http/http_etag.c
+++ b/modules/http/http_etag.c
@@ -73,7 +73,7 @@ AP_DECLARE(char *) ap_make_etag(request_rec *r, int force_weak)
     cfg = (core_dir_config *)ap_get_module_config(r->per_dir_config,
                                                   &core_module);
     etag_bits = (cfg->etag_bits & (~ cfg->etag_remove)) | cfg->etag_add;
-    
+
     /*
      * If it's a file (or we wouldn't be here) and no ETags
      * should be set for files, return an empty string and
@@ -173,7 +173,7 @@ AP_DECLARE(void) ap_set_etag(request_rec *r)
 
     if (!r->vlist_validator) {
         etag = ap_make_etag(r, 0);
-    
+
         /* If we get a blank etag back, don't set the header. */
         if (!etag[0]) {
             return;
diff --git a/modules/http/http_filters.c b/modules/http/http_filters.c
index 88e1802..8d65fb8 100644
--- a/modules/http/http_filters.c
+++ b/modules/http/http_filters.c
@@ -69,10 +69,10 @@ typedef struct http_filter_ctx {
     int eos_sent;
 } http_ctx_t;
 
-/* This is the HTTP_INPUT filter for HTTP requests and responses from 
- * proxied servers (mod_proxy).  It handles chunked and content-length 
+/* This is the HTTP_INPUT filter for HTTP requests and responses from
+ * proxied servers (mod_proxy).  It handles chunked and content-length
  * bodies.  This can only be inserted/used after the headers
- * are successfully parsed. 
+ * are successfully parsed.
  */
 apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
                             ap_input_mode_t mode, apr_read_type_e block,
@@ -97,8 +97,8 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
         ctx->eos_sent = 0;
 
         /* LimitRequestBody does not apply to proxied responses.
-         * Consider implementing this check in its own filter. 
-         * Would adding a directive to limit the size of proxied 
+         * Consider implementing this check in its own filter.
+         * Would adding a directive to limit the size of proxied
          * responses be useful?
          */
         if (!f->r->proxyreq) {
@@ -144,12 +144,12 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
             }
 
             /* If we have a limit in effect and we know the C-L ahead of
-             * time, stop it here if it is invalid. 
-             */ 
+             * time, stop it here if it is invalid.
+             */
             if (ctx->limit && ctx->limit < ctx->remaining) {
                 apr_bucket_brigade *bb;
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
-                          "Requested content-length of %" APR_OFF_T_FMT 
+                          "Requested content-length of %" APR_OFF_T_FMT
                           " is larger than the configured limit"
                           " of %" APR_OFF_T_FMT, ctx->remaining, ctx->limit);
                 bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);
@@ -183,7 +183,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
 
         /* Since we're about to read data, send 100-Continue if needed.
          * Only valid on chunked and C-L bodies where the C-L is > 0. */
-        if ((ctx->state == BODY_CHUNK || 
+        if ((ctx->state == BODY_CHUNK ||
             (ctx->state == BODY_LENGTH && ctx->remaining > 0)) &&
             f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1)) {
             char *tmp;
@@ -254,7 +254,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
                 ctx->eos_sent = 1;
                 return APR_SUCCESS;
             }
-        } 
+        }
     }
 
     if (ctx->eos_sent) {
@@ -262,7 +262,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
         APR_BRIGADE_INSERT_TAIL(b, e);
         return APR_SUCCESS;
     }
-        
+
     if (!ctx->remaining) {
         switch (ctx->state) {
         case BODY_NONE:
@@ -351,7 +351,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
         ctx->remaining -= totalread;
     }
 
-    /* If we have no more bytes remaining on a C-L request, 
+    /* If we have no more bytes remaining on a C-L request,
      * save the callter a roundtrip to discover EOS.
      */
     if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {
@@ -368,7 +368,7 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
         if (ctx->limit < ctx->limit_used) {
             apr_bucket_brigade *bb;
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r,
-                          "Read content-length of %" APR_OFF_T_FMT 
+                          "Read content-length of %" APR_OFF_T_FMT
                           " is larger than the configured limit"
                           " of %" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);
             bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);
@@ -853,11 +853,11 @@ AP_DECLARE_NONSTD(int) ap_send_http_trace(request_rec *r)
 
     /* If configured to accept a body, echo the body */
     if (bodylen) {
-        b = apr_bucket_pool_create(bodyread, bodylen, 
+        b = apr_bucket_pool_create(bodyread, bodylen,
                                    r->pool, bb->bucket_alloc);
         APR_BRIGADE_INSERT_TAIL(bb, b);
     }
-    
+
     ap_pass_brigade(r->output_filters,  bb);
 
     return DONE;
@@ -953,7 +953,7 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,
         apr_table_unset(r->headers_out, "Content-Length");
     }
 
-    apr_table_setn(r->headers_out, "Content-Type", 
+    apr_table_setn(r->headers_out, "Content-Type",
                    ap_make_content_type(r, r->content_type));
 
     if (r->content_encoding) {
@@ -1094,7 +1094,7 @@ AP_DECLARE(int) ap_discard_request_body(request_rec *r)
         if (rv != APR_SUCCESS) {
             /* FIXME: If we ever have a mapping from filters (apr_status_t)
              * to HTTP error codes, this would be a good place for them.
-             * 
+             *
              * If we received the special case AP_FILTER_ERROR, it means
              * that the filters have already handled this error.
              * Otherwise, we should assume we have a bad request.
@@ -1174,7 +1174,7 @@ AP_DECLARE(int) ap_discard_request_body(request_rec *r)
  *    return the length of the input block. When it is done reading, it will
  *    return 0 if EOF, or -1 if there was an error.
  *    If an error occurs on input, we force an end to keepalive.
- *    
+ *
  *    This step also sends a 100 Continue response to HTTP/1.1 clients if appropriate.
  */
 
@@ -1272,11 +1272,11 @@ AP_DECLARE(long) ap_get_client_block(request_rec *r, char *buffer,
 
     rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,
                         APR_BLOCK_READ, bufsiz);
-  
+
     /* We lose the failure code here.  This is why ap_get_client_block should
      * not be used.
      */
-    if (rv != APR_SUCCESS) { 
+    if (rv != APR_SUCCESS) {
         /* if we actually fail here, we want to just return and
          * stop trying to read data from the client.
          */
diff --git a/modules/http/http_protocol.c b/modules/http/http_protocol.c
index 1ee501a..46ee7e6 100644
--- a/modules/http/http_protocol.c
+++ b/modules/http/http_protocol.c
@@ -459,7 +459,7 @@ AP_DECLARE(int) ap_method_register(apr_pool_t *p, const char *methname)
     if (methname == NULL) {
         return M_INVALID;
     }
-    
+
     /* Check if the method was previously registered.  If it was
      * return the associated method number.
      */
@@ -467,7 +467,7 @@ AP_DECLARE(int) ap_method_register(apr_pool_t *p, const char *methname)
                                   APR_HASH_KEY_STRING);
     if (methnum != NULL)
         return *methnum;
-        
+
     if (cur_method_number > METHOD_NUMBER_LAST) {
         /* The method registry  has run out of dynamically
          * assignable method numbers. Log this and return M_INVALID.
@@ -822,9 +822,9 @@ AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct)
     else if (!r->content_type || strcmp(r->content_type, ct)) {
         r->content_type = ct;
 
-        /* Insert filters requested by the AddOutputFiltersByType 
-         * configuration directive. Content-type filters must be 
-         * inserted after the content handlers have run because 
+        /* Insert filters requested by the AddOutputFiltersByType
+         * configuration directive. Content-type filters must be
+         * inserted after the content handlers have run because
          * only then, do we reliably know the content-type.
          */
         ap_add_output_filters_by_type(r);
@@ -1107,7 +1107,7 @@ AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)
      */
     r->eos_sent = 0;
 
-    /* and we need to get rid of any RESOURCE filters that might be lurking 
+    /* and we need to get rid of any RESOURCE filters that might be lurking
      * around, thinking they are in the middle of the original request
      */
 
@@ -1196,11 +1196,11 @@ AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)
          * as a text message, so first check the custom response
          * string to ensure that it is a text-string (using the
          * same test used in ap_die(), i.e. does it start with a ").
-         * 
-         * If it's not a text string, we've got a recursive error or 
+         *
+         * If it's not a text string, we've got a recursive error or
          * an external redirect.  If it's a recursive error, ap_die passes
-         * us the second error code so we can write both, and has already 
-         * backed up to the original error.  If it's an external redirect, 
+         * us the second error code so we can write both, and has already
+         * backed up to the original error.  If it's an external redirect,
          * it hasn't happened yet; we may never know if it fails.
          */
         if (custom_response[0] == '\"') {
diff --git a/modules/http/http_request.c b/modules/http/http_request.c
index adbf4be..5ee236e 100644
--- a/modules/http/http_request.c
+++ b/modules/http/http_request.c
@@ -55,12 +55,12 @@
  * Mainline request processing...
  */
 
-/* XXX A cleaner and faster way to do this might be to pass the request_rec 
- * down the filter chain as a parameter.  It would need to change for 
- * subrequest vs. main request filters; perhaps the subrequest filter could 
+/* XXX A cleaner and faster way to do this might be to pass the request_rec
+ * down the filter chain as a parameter.  It would need to change for
+ * subrequest vs. main request filters; perhaps the subrequest filter could
  * make the switch.
  */
-static void update_r_in_filters(ap_filter_t *f, 
+static void update_r_in_filters(ap_filter_t *f,
                                 request_rec *from,
                                 request_rec *to)
 {
@@ -103,8 +103,8 @@ AP_DECLARE(void) ap_die(int type, request_rec *r)
         if (r_1st_err != r) {
             /* The recursive error was caused by an ErrorDocument specifying
              * an internal redirect to a bad URI.  ap_internal_redirect has
-             * changed the filter chains to point to the ErrorDocument's 
-             * request_rec.  Back out those changes so we can safely use the 
+             * changed the filter chains to point to the ErrorDocument's
+             * request_rec.  Back out those changes so we can safely use the
              * original failing request_rec to send the canned error message.
              *
              * ap_send_error_response gets rid of existing resource filters
@@ -168,7 +168,7 @@ AP_DECLARE(void) ap_die(int type, request_rec *r)
              * more informative (than the plain canned) messages to us.
              * Propagate them to ErrorDocuments via the ERROR_NOTES variable:
              */
-            if ((error_notes = apr_table_get(r->notes, 
+            if ((error_notes = apr_table_get(r->notes,
                                              "error-notes")) != NULL) {
                 apr_table_setn(r->subprocess_env, "ERROR_NOTES", error_notes);
             }
@@ -196,7 +196,7 @@ static void check_pipeline(conn_rec *c)
     /* ### is zero correct? that means "read one line" */
     if (c->keepalive != AP_CONN_CLOSE) {
         apr_bucket_brigade *bb = apr_brigade_create(c->pool, c->bucket_alloc);
-        if (ap_get_brigade(c->input_filters, bb, AP_MODE_EATCRLF, 
+        if (ap_get_brigade(c->input_filters, bb, AP_MODE_EATCRLF,
                        APR_NONBLOCK_READ, 0) != APR_SUCCESS) {
             c->data_in_input_filters = 0;  /* we got APR_EOF or an error */
         }
@@ -217,15 +217,15 @@ void ap_process_async_request(request_rec *r)
     /* Give quick handlers a shot at serving the request on the fast
      * path, bypassing all of the other Apache hooks.
      *
-     * This hook was added to enable serving files out of a URI keyed 
-     * content cache ( e.g., Mike Abbott's Quick Shortcut Cache, 
+     * This hook was added to enable serving files out of a URI keyed
+     * content cache ( e.g., Mike Abbott's Quick Shortcut Cache,
      * described here: http://oss.sgi.com/projects/apache/mod_qsc.html )
      *
      * It may have other uses as well, such as routing requests directly to
      * content handlers that have the ability to grok HTTP and do their
-     * own access checking, etc (e.g. servlet engines). 
-     * 
-     * Use this hook with extreme care and only if you know what you are 
+     * own access checking, etc (e.g. servlet engines).
+     *
+     * Use this hook with extreme care and only if you know what you are
      * doing.
      */
     if (ap_extended_status)
@@ -388,7 +388,7 @@ static request_rec *internal_internal_redirect(const char *new_uri,
         ap_add_output_filter_handle(ap_subreq_core_filter_handle,
                                     NULL, new, new->connection);
     }
-    
+
     update_r_in_filters(new->input_filters, r, new);
     update_r_in_filters(new->output_filters, r, new);
 
@@ -517,7 +517,7 @@ AP_DECLARE(void) ap_internal_redirect_handler(const char *new_uri, request_rec *
     }
 }
 
-AP_DECLARE(void) ap_allow_methods(request_rec *r, int reset, ...) 
+AP_DECLARE(void) ap_allow_methods(request_rec *r, int reset, ...)
 {
     const char *method;
     va_list methods;
diff --git a/modules/http/mod_mime.c b/modules/http/mod_mime.c
index 0937f2e..462d792 100644
--- a/modules/http/mod_mime.c
+++ b/modules/http/mod_mime.c
@@ -16,9 +16,9 @@
 
 /*
  * http_mime.c: Sends/gets MIME headers for requests
- * 
+ *
  * Rob McCool
- * 
+ *
  */
 
 #include "apr.h"
@@ -39,16 +39,16 @@
 /* XXXX - fix me / EBCDIC
  *        there was a cludge here which would use its
  *        own version apr_isascii(). Indicating that
- *        on some platforms that might be needed. 
+ *        on some platforms that might be needed.
  *
- *        #define OS_ASC(c) (c)             -- for mere mortals 
+ *        #define OS_ASC(c) (c)             -- for mere mortals
  *     or
  *        #define OS_ASC(c) (ebcdic2ascii[c]) -- for dino's
  *
  *        #define apr_isascii(c) ((OS_ASC(c) & 0x80) == 0)
  */
 
-/* XXXXX - fix me - See note with NOT_PROXY 
+/* XXXXX - fix me - See note with NOT_PROXY
  */
 
 typedef struct attrib_info {
@@ -83,13 +83,13 @@ typedef struct {
     char *default_language;     /* Language if no AddLanguage ext found */
 
     int multimatch;       /* Extensions to include in multiview matching
-                           * for filenames, e.g. Filters and Handlers 
+                           * for filenames, e.g. Filters and Handlers
                            */
     int use_path_info;    /* If set to 0, only use filename.
                            * If set to 1, append PATH_INFO to filename for
                            *   lookups.
                            * If set to 2, this value is unset and is
-                           *   effectively 0.  
+                           *   effectively 0.
                            */
 } mime_dir_config;
 
@@ -170,9 +170,9 @@ static void *overlay_extension_mappings(apr_pool_t *p,
     return new_info;
 }
 
-/* Member is the offset within an extension_info of the pointer to reset 
+/* Member is the offset within an extension_info of the pointer to reset
  */
-static void remove_items(apr_pool_t *p, apr_array_header_t *remove, 
+static void remove_items(apr_pool_t *p, apr_array_header_t *remove,
                          apr_hash_t *mappings)
 {
     attrib_info *suffix = (attrib_info *) remove->elts;
@@ -184,7 +184,7 @@ static void remove_items(apr_pool_t *p, apr_array_header_t *remove,
         if (exinfo && *(const char**)((char *)exinfo + suffix[i].offset)) {
             extension_info *copyinfo = exinfo;
             exinfo = (extension_info*)apr_palloc(p, sizeof(*exinfo));
-            apr_hash_set(mappings, suffix[i].name, 
+            apr_hash_set(mappings, suffix[i].name,
                          APR_HASH_KEY_STRING, exinfo);
             memcpy(exinfo, copyinfo, sizeof(*exinfo));
             *(const char**)((char *)exinfo + suffix[i].offset) = NULL;
@@ -243,7 +243,7 @@ static void *merge_mime_dir_configs(apr_pool_t *p, void *basev, void *addv)
     return new;
 }
 
-static const char *add_extension_info(cmd_parms *cmd, void *m_, 
+static const char *add_extension_info(cmd_parms *cmd, void *m_,
                                       const char *value_, const char* ext)
 {
     mime_dir_config *m=m_;
@@ -279,7 +279,7 @@ static const char *add_extension_info(cmd_parms *cmd, void *m_,
  * This keeps the association from being inherited, but not
  * from being re-added at a subordinate level.
  */
-static const char *remove_extension_info(cmd_parms *cmd, void *m_, 
+static const char *remove_extension_info(cmd_parms *cmd, void *m_,
                                          const char *ext)
 {
     mime_dir_config *m = (mime_dir_config *) m_;
@@ -309,7 +309,7 @@ static const char *set_types_config(cmd_parms *cmd, void *dummy,
     return NULL;
 }
 
-static const char *multiviews_match(cmd_parms *cmd, void *m_, 
+static const char *multiviews_match(cmd_parms *cmd, void *m_,
                                     const char *include)
 {
     mime_dir_config *m = (mime_dir_config *) m_;
@@ -329,14 +329,14 @@ static const char *multiviews_match(cmd_parms *cmd, void *m_,
         m->multimatch |= MULTIMATCH_NEGOTIATED;
     }
     else if (strcasecmp(include, "Filters") == 0) {
-        if (m->multimatch && (m->multimatch & (MULTIMATCH_NEGOTIATED 
+        if (m->multimatch && (m->multimatch & (MULTIMATCH_NEGOTIATED
                                              | MULTIMATCH_ANY))) {
             return "Filters is incompatible with Any and NegotiatedOnly";
         }
         m->multimatch |= MULTIMATCH_FILTERS;
     }
     else if (strcasecmp(include, "Handlers") == 0) {
-        if (m->multimatch && (m->multimatch & (MULTIMATCH_NEGOTIATED 
+        if (m->multimatch && (m->multimatch & (MULTIMATCH_NEGOTIATED
                                              | MULTIMATCH_ANY))) {
             return "Handlers is incompatible with Any and NegotiatedOnly";
         }
@@ -351,54 +351,54 @@ static const char *multiviews_match(cmd_parms *cmd, void *m_,
 
 static const command_rec mime_cmds[] =
 {
-    AP_INIT_ITERATE2("AddCharset", add_extension_info, 
+    AP_INIT_ITERATE2("AddCharset", add_extension_info,
         (void *)APR_OFFSETOF(extension_info, charset_type), OR_FILEINFO,
         "a charset (e.g., iso-2022-jp), followed by one or more "
         "file extensions"),
-    AP_INIT_ITERATE2("AddEncoding", add_extension_info, 
+    AP_INIT_ITERATE2("AddEncoding", add_extension_info,
         (void *)APR_OFFSETOF(extension_info, encoding_type), OR_FILEINFO,
         "an encoding (e.g., gzip), followed by one or more file extensions"),
-    AP_INIT_ITERATE2("AddHandler", add_extension_info, 
+    AP_INIT_ITERATE2("AddHandler", add_extension_info,
         (void *)APR_OFFSETOF(extension_info, handler), OR_FILEINFO,
         "a handler name followed by one or more file extensions"),
-    AP_INIT_ITERATE2("AddInputFilter", add_extension_info, 
+    AP_INIT_ITERATE2("AddInputFilter", add_extension_info,
         (void *)APR_OFFSETOF(extension_info, input_filters), OR_FILEINFO,
         "input filter name (or ; delimited names) followed by one or "
         "more file extensions"),
-    AP_INIT_ITERATE2("AddLanguage", add_extension_info, 
+    AP_INIT_ITERATE2("AddLanguage", add_extension_info,
         (void *)APR_OFFSETOF(extension_info, language_type), OR_FILEINFO,
         "a language (e.g., fr), followed by one or more file extensions"),
-    AP_INIT_ITERATE2("AddOutputFilter", add_extension_info, 
-        (void *)APR_OFFSETOF(extension_info, output_filters), OR_FILEINFO, 
+    AP_INIT_ITERATE2("AddOutputFilter", add_extension_info,
+        (void *)APR_OFFSETOF(extension_info, output_filters), OR_FILEINFO,
         "output filter name (or ; delimited names) followed by one or "
         "more file extensions"),
-    AP_INIT_ITERATE2("AddType", add_extension_info, 
-        (void *)APR_OFFSETOF(extension_info, forced_type), OR_FILEINFO, 
+    AP_INIT_ITERATE2("AddType", add_extension_info,
+        (void *)APR_OFFSETOF(extension_info, forced_type), OR_FILEINFO,
         "a mime type followed by one or more file extensions"),
     AP_INIT_TAKE1("DefaultLanguage", ap_set_string_slot,
         (void*)APR_OFFSETOF(mime_dir_config, default_language), OR_FILEINFO,
         "language to use for documents with no other language file extension"),
     AP_INIT_ITERATE("MultiviewsMatch", multiviews_match, NULL, OR_FILEINFO,
         "NegotiatedOnly (default), Handlers and/or Filters, or Any"),
-    AP_INIT_ITERATE("RemoveCharset", remove_extension_info, 
+    AP_INIT_ITERATE("RemoveCharset", remove_extension_info,
         (void *)APR_OFFSETOF(extension_info, charset_type), OR_FILEINFO,
         "one or more file extensions"),
-    AP_INIT_ITERATE("RemoveEncoding", remove_extension_info, 
+    AP_INIT_ITERATE("RemoveEncoding", remove_extension_info,
         (void *)APR_OFFSETOF(extension_info, encoding_type), OR_FILEINFO,
         "one or more file extensions"),
-    AP_INIT_ITERATE("RemoveHandler", remove_extension_info, 
+    AP_INIT_ITERATE("RemoveHandler", remove_extension_info,
         (void *)APR_OFFSETOF(extension_info, handler), OR_FILEINFO,
         "one or more file extensions"),
-    AP_INIT_ITERATE("RemoveInputFilter", remove_extension_info, 
+    AP_INIT_ITERATE("RemoveInputFilter", remove_extension_info,
         (void *)APR_OFFSETOF(extension_info, input_filters), OR_FILEINFO,
         "one or more file extensions"),
-    AP_INIT_ITERATE("RemoveLanguage", remove_extension_info, 
+    AP_INIT_ITERATE("RemoveLanguage", remove_extension_info,
         (void *)APR_OFFSETOF(extension_info, language_type), OR_FILEINFO,
         "one or more file extensions"),
-    AP_INIT_ITERATE("RemoveOutputFilter", remove_extension_info, 
+    AP_INIT_ITERATE("RemoveOutputFilter", remove_extension_info,
         (void *)APR_OFFSETOF(extension_info, output_filters), OR_FILEINFO,
         "one or more file extensions"),
-    AP_INIT_ITERATE("RemoveType", remove_extension_info, 
+    AP_INIT_ITERATE("RemoveType", remove_extension_info,
         (void *)APR_OFFSETOF(extension_info, forced_type), OR_FILEINFO,
         "one or more file extensions"),
     AP_INIT_TAKE1("TypesConfig", set_types_config, NULL, RSRC_CONF,
@@ -426,15 +426,15 @@ static int mime_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
     types_confname = ap_server_root_relative(p, types_confname);
     if (!types_confname) {
         ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
-                     "Invalid mime types config path %s", 
+                     "Invalid mime types config path %s",
                      (const char *)ap_get_module_config(s->module_config,
                                                         &mime_module));
         return HTTP_INTERNAL_SERVER_ERROR;
     }
-    if ((status = ap_pcfg_openfile(&f, ptemp, types_confname)) 
+    if ((status = ap_pcfg_openfile(&f, ptemp, types_confname))
                 != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, status, s,
-                     "could not open mime types config file %s.", 
+                     "could not open mime types config file %s.",
                      types_confname);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -781,7 +781,7 @@ static int find_ct(request_rec *r)
     ext = ap_getword(r->pool, &fn, '.');
     *((const char **)apr_array_push(exception_list)) = ext;
 
-    /* Parse filename extensions which can be in any order 
+    /* Parse filename extensions which can be in any order
      */
     while (*fn && (ext = ap_getword(r->pool, &fn, '.'))) {
         const extension_info *exinfo = NULL;
@@ -848,7 +848,7 @@ static int find_ct(request_rec *r)
             }
             /* The following extensions are not 'Found'.  That is, they don't
              * make any contribution to metadata negotation, so they must have
-             * been explicitly requested by name. 
+             * been explicitly requested by name.
              */
             if (exinfo->handler && r->proxyreq == PROXYREQ_NONE) {
                 r->handler = exinfo->handler;
@@ -862,7 +862,7 @@ static int find_ct(request_rec *r)
              */
             if (exinfo->input_filters && r->proxyreq == PROXYREQ_NONE) {
                 const char *filter, *filters = exinfo->input_filters;
-                while (*filters 
+                while (*filters
                     && (filter = ap_getword(r->pool, &filters, ';'))) {
                     ap_add_input_filter(filter, NULL, r, r->connection);
                 }
@@ -872,7 +872,7 @@ static int find_ct(request_rec *r)
             }
             if (exinfo->output_filters && r->proxyreq == PROXYREQ_NONE) {
                 const char *filter, *filters = exinfo->output_filters;
-                while (*filters 
+                while (*filters
                     && (filter = ap_getword(r->pool, &filters, ';'))) {
                     ap_add_output_filter(filter, NULL, r, r->connection);
                 }
@@ -896,7 +896,7 @@ static int find_ct(request_rec *r)
      * skip the notes to alert mod_negotiation we are clueless.
      */
     if (found_metadata) {
-        apr_table_setn(r->notes, "ap-mime-exceptions-list", 
+        apr_table_setn(r->notes, "ap-mime-exceptions-list",
                        (void *)exception_list);
     }
 
@@ -972,7 +972,7 @@ static void register_hooks(apr_pool_t *p)
 {
     ap_hook_post_config(mime_post_config,NULL,NULL,APR_HOOK_MIDDLE);
     ap_hook_type_checker(find_ct,NULL,NULL,APR_HOOK_MIDDLE);
-    /* 
+    /*
      * this hook seems redundant ... is there any reason a type checker isn't
      * allowed to do this already?  I'd think that fixups in general would be
      * the last opportunity to get the filters right.
diff --git a/modules/ldap/util_ldap.c b/modules/ldap/util_ldap.c
index 3bc2906..c48235b 100644
--- a/modules/ldap/util_ldap.c
+++ b/modules/ldap/util_ldap.c
@@ -16,9 +16,9 @@
 
 /*
  * util_ldap.c: LDAP things
- * 
+ *
  * Original code from auth_ldap module for Apache v1.3:
- * Copyright 1998, 1999 Enbridge Pipelines Inc. 
+ * Copyright 1998, 1999 Enbridge Pipelines Inc.
  * Copyright 1999-2001 Dave Carrigan
  */
 
@@ -92,7 +92,7 @@ static void util_ldap_strdup (char **str, const char *newstr)
 static int util_ldap_handler(request_rec *r)
 {
     util_ldap_state_t *st = (util_ldap_state_t *)
-                            ap_get_module_config(r->server->module_config, 
+                            ap_get_module_config(r->server->module_config,
                                                  &ldap_module);
 
     r->allowed |= (1 << M_GET);
@@ -193,7 +193,7 @@ static apr_status_t uldap_connection_cleanup(void *param)
 
         /* unlock this entry */
         uldap_connection_close(ldc);
-    
+
     }
 
     return APR_SUCCESS;
@@ -206,7 +206,7 @@ static apr_status_t uldap_connection_cleanup(void *param)
  *
  * Returns LDAP_SUCCESS on success; and an error code on failure
  */
-static int uldap_connection_open(request_rec *r, 
+static int uldap_connection_open(request_rec *r,
                                  util_ldap_connection_t *ldc)
 {
     int rc = 0;
@@ -214,7 +214,7 @@ static int uldap_connection_open(request_rec *r,
     int version  = LDAP_VERSION3;
     apr_ldap_err_t *result = NULL;
     struct timeval timeOut = {10,0};    /* 10 second connection timeout */
-    util_ldap_state_t *st = 
+    util_ldap_state_t *st =
         (util_ldap_state_t *)ap_get_module_config(r->server->module_config,
         &ldap_module);
 
@@ -279,7 +279,7 @@ static int uldap_connection_open(request_rec *r,
 
         /* switch on SSL/TLS */
         if (APR_LDAP_NONE != ldc->secure) {
-            apr_ldap_set_option(ldc->pool, ldc->ldap, 
+            apr_ldap_set_option(ldc->pool, ldc->ldap,
                                 APR_LDAP_OPT_TLS, &ldc->secure, &(result));
             if (LDAP_SUCCESS != result->rc) {
                 ldap_unbind_s(ldc->ldap);
@@ -298,7 +298,7 @@ static int uldap_connection_open(request_rec *r,
 
 /*XXX All of the #ifdef's need to be removed once apr-util 1.2 is released */
 #ifdef APR_LDAP_OPT_VERIFY_CERT
-        apr_ldap_set_option(ldc->pool, ldc->ldap, 
+        apr_ldap_set_option(ldc->pool, ldc->ldap,
                             APR_LDAP_OPT_VERIFY_CERT, &(st->verify_svr_cert), &(result));
 #else
 #if defined(LDAPSSL_VERIFY_SERVER)
@@ -326,7 +326,7 @@ static int uldap_connection_open(request_rec *r,
         if (st->connectionTimeout > 0) {
             timeOut.tv_sec = st->connectionTimeout;
         }
-    
+
         if (st->connectionTimeout >= 0) {
             rc = apr_ldap_set_option(ldc->pool, ldc->ldap, LDAP_OPT_NETWORK_TIMEOUT,
                                      (void *)&timeOut, &(result));
@@ -337,14 +337,14 @@ static int uldap_connection_open(request_rec *r,
         }
 #endif
 
-    
+
     }
 
 
     /* loop trying to bind up to 10 times if LDAP_SERVER_DOWN error is
      * returned.  Break out of the loop on Success or any other error.
      *
-     * NOTE: Looping is probably not a great idea. If the server isn't 
+     * NOTE: Looping is probably not a great idea. If the server isn't
      * responding the chances it will respond after a few tries are poor.
      * However, the original code looped and it only happens on
      * the error condition.
@@ -382,7 +382,7 @@ static int uldap_connection_open(request_rec *r,
  *
  * Returns 1 on compare failure, 0 otherwise.
  */
-static int compare_client_certs(apr_array_header_t *srcs, 
+static int compare_client_certs(apr_array_header_t *srcs,
                                 apr_array_header_t *dests)
 {
     int i = 0;
@@ -419,20 +419,20 @@ static int compare_client_certs(apr_array_header_t *srcs,
  * Find an existing ldap connection struct that matches the
  * provided ldap connection parameters.
  *
- * If not found in the cache, a new ldc structure will be allocated 
- * from st->pool and returned to the caller.  If found in the cache, 
+ * If not found in the cache, a new ldc structure will be allocated
+ * from st->pool and returned to the caller.  If found in the cache,
  * a pointer to the existing ldc structure will be returned.
  */
-static util_ldap_connection_t * 
+static util_ldap_connection_t *
             uldap_connection_find(request_rec *r,
                                   const char *host, int port,
                                   const char *binddn, const char *bindpw,
-                                  deref_options deref, int secure) 
+                                  deref_options deref, int secure)
 {
     struct util_ldap_connection_t *l, *p; /* To traverse the linked list */
     int secureflag = secure;
 
-    util_ldap_state_t *st = 
+    util_ldap_state_t *st =
         (util_ldap_state_t *)ap_get_module_config(r->server->module_config,
         &ldap_module);
 
@@ -440,7 +440,7 @@ static util_ldap_connection_t *
 #if APR_HAS_THREADS
     /* mutex lock this function */
     if (!st->mutex) {
-        apr_thread_mutex_create(&st->mutex, APR_THREAD_MUTEX_DEFAULT, 
+        apr_thread_mutex_create(&st->mutex, APR_THREAD_MUTEX_DEFAULT,
                                 st->pool);
     }
     apr_thread_mutex_lock(st->mutex);
@@ -457,13 +457,13 @@ static util_ldap_connection_t *
 #if APR_HAS_THREADS
         if (APR_SUCCESS == apr_thread_mutex_trylock(l->lock)) {
 #endif
-        if (   (l->port == port) && (strcmp(l->host, host) == 0) 
-            && ((!l->binddn && !binddn) || (l->binddn && binddn 
-                                             && !strcmp(l->binddn, binddn))) 
-            && ((!l->bindpw && !bindpw) || (l->bindpw && bindpw 
-                                             && !strcmp(l->bindpw, bindpw))) 
-            && (l->deref == deref) && (l->secure == secureflag) 
-            && !compare_client_certs(st->client_certs, l->client_certs)) 
+        if (   (l->port == port) && (strcmp(l->host, host) == 0)
+            && ((!l->binddn && !binddn) || (l->binddn && binddn
+                                             && !strcmp(l->binddn, binddn)))
+            && ((!l->bindpw && !bindpw) || (l->bindpw && bindpw
+                                             && !strcmp(l->bindpw, bindpw)))
+            && (l->deref == deref) && (l->secure == secureflag)
+            && !compare_client_certs(st->client_certs, l->client_certs))
         {
             break;
         }
@@ -486,9 +486,9 @@ static util_ldap_connection_t *
             if (APR_SUCCESS == apr_thread_mutex_trylock(l->lock)) {
 
 #endif
-            if ((l->port == port) && (strcmp(l->host, host) == 0) && 
+            if ((l->port == port) && (strcmp(l->host, host) == 0) &&
                 (l->deref == deref) && (l->secure == secureflag) &&
-                !compare_client_certs(st->client_certs, l->client_certs)) 
+                !compare_client_certs(st->client_certs, l->client_certs))
             {
                 /* the bind credentials have changed */
                 l->bound = 0;
@@ -515,7 +515,7 @@ static util_ldap_connection_t *
      */
     if (!l) {
 
-        /* 
+        /*
          * Add the new connection entry to the linked list. Note that we
          * don't actually establish an LDAP connection yet; that happens
          * the first time authentication is requested.
@@ -568,18 +568,18 @@ static util_ldap_connection_t *
 /*
  * Compares two DNs to see if they're equal. The only way to do this correctly
  * is to search for the dn and then do ldap_get_dn() on the result. This should
- * match the initial dn, since it would have been also retrieved with 
- * ldap_get_dn(). This is expensive, so if the configuration value 
+ * match the initial dn, since it would have been also retrieved with
+ * ldap_get_dn(). This is expensive, so if the configuration value
  * compare_dn_on_server is false, just does an ordinary strcmp.
  *
  * The lock for the ldap cache should already be acquired.
  */
-static int uldap_cache_comparedn(request_rec *r, util_ldap_connection_t *ldc, 
-                                 const char *url, const char *dn, 
+static int uldap_cache_comparedn(request_rec *r, util_ldap_connection_t *ldc,
+                                 const char *url, const char *dn,
                                  const char *reqdn, int compare_dn_on_server)
 {
     int result = 0;
-    util_url_node_t *curl; 
+    util_url_node_t *curl;
     util_url_node_t curnode;
     util_dn_compare_node_t *node;
     util_dn_compare_node_t newnode;
@@ -588,7 +588,7 @@ static int uldap_cache_comparedn(request_rec *r, util_ldap_connection_t *ldc,
     char *searchdn;
 
     util_ldap_state_t *st = (util_ldap_state_t *)
-                            ap_get_module_config(r->server->module_config, 
+                            ap_get_module_config(r->server->module_config,
                                                  &ldap_module);
 
     /* get cache entry (or create one) */
@@ -617,7 +617,7 @@ static int uldap_cache_comparedn(request_rec *r, util_ldap_connection_t *ldc,
     if (curl) {
         /* no - it's a server side compare */
         LDAP_CACHE_LOCK();
-    
+
         /* is it in the compare cache? */
         newnode.reqdn = (char *)reqdn;
         node = util_ald_cache_fetch(curl->dn_compare_cache, &newnode);
@@ -628,7 +628,7 @@ static int uldap_cache_comparedn(request_rec *r, util_ldap_connection_t *ldc,
             ldc->reason = "DN Comparison TRUE (cached)";
             return LDAP_COMPARE_TRUE;
         }
-    
+
         /* unlock this read lock */
         LDAP_CACHE_UNLOCK();
     }
@@ -647,9 +647,9 @@ start_over:
 
     /* search for reqdn */
     if ((result = ldap_search_ext_s(ldc->ldap, (char *)reqdn, LDAP_SCOPE_BASE,
-                                    "(objectclass=*)", NULL, 1, 
-                                    NULL, NULL, NULL, -1, &res)) 
-            == LDAP_SERVER_DOWN) 
+                                    "(objectclass=*)", NULL, 1,
+                                    NULL, NULL, NULL, -1, &res))
+            == LDAP_SERVER_DOWN)
     {
         ldc->reason = "DN Comparison ldap_search_ext_s() "
                       "failed with server down";
@@ -677,11 +677,11 @@ start_over:
             LDAP_CACHE_LOCK();
             newnode.reqdn = (char *)reqdn;
             newnode.dn = (char *)dn;
-            
+
             node = util_ald_cache_fetch(curl->dn_compare_cache, &newnode);
             if (   (node == NULL)
-                || (strcmp(reqdn, node->reqdn) != 0) 
-                || (strcmp(dn, node->dn) != 0)) 
+                || (strcmp(reqdn, node->reqdn) != 0)
+                || (strcmp(dn, node->dn) != 0))
             {
                 util_ald_cache_insert(curl->dn_compare_cache, &newnode);
             }
@@ -697,10 +697,10 @@ start_over:
 
 /*
  * Does an generic ldap_compare operation. It accepts a cache that it will use
- * to lookup the compare in the cache. We cache two kinds of compares 
+ * to lookup the compare in the cache. We cache two kinds of compares
  * (require group compares) and (require user compares). Each compare has a different
  * cache node: require group includes the DN; require user does not because the
- * require user cache is owned by the 
+ * require user cache is owned by the
  *
  */
 static int uldap_cache_compare(request_rec *r, util_ldap_connection_t *ldc,
@@ -708,7 +708,7 @@ static int uldap_cache_compare(request_rec *r, util_ldap_connection_t *ldc,
                                const char *attrib, const char *value)
 {
     int result = 0;
-    util_url_node_t *curl; 
+    util_url_node_t *curl;
     util_url_node_t curnode;
     util_compare_node_t *compare_nodep;
     util_compare_node_t the_compare_node;
@@ -732,15 +732,15 @@ static int uldap_cache_compare(request_rec *r, util_ldap_connection_t *ldc,
         /* make a comparison to the cache */
         LDAP_CACHE_LOCK();
         curtime = apr_time_now();
-    
+
         the_compare_node.dn = (char *)dn;
         the_compare_node.attrib = (char *)attrib;
         the_compare_node.value = (char *)value;
         the_compare_node.result = 0;
-    
-        compare_nodep = util_ald_cache_fetch(curl->compare_cache, 
+
+        compare_nodep = util_ald_cache_fetch(curl->compare_cache,
                                              &the_compare_node);
-    
+
         if (compare_nodep != NULL) {
             /* found it... */
             if (curtime - compare_nodep->lastcompare > st->compare_cache_ttl) {
@@ -787,7 +787,7 @@ start_over:
                                  (char *)dn,
                                  (char *)attrib,
                                  (char *)value))
-                                               == LDAP_SERVER_DOWN) { 
+                                               == LDAP_SERVER_DOWN) {
         /* connection failed - try again */
         ldc->reason = "ldap_compare_s() failed with server down";
         uldap_connection_unbind(ldc);
@@ -795,7 +795,7 @@ start_over:
     }
 
     ldc->reason = "Comparison complete";
-    if ((LDAP_COMPARE_TRUE == result) || 
+    if ((LDAP_COMPARE_TRUE == result) ||
         (LDAP_COMPARE_FALSE == result) ||
         (LDAP_NO_SUCH_ATTRIBUTE == result)) {
         if (curl) {
@@ -805,13 +805,13 @@ start_over:
             the_compare_node.result = result;
 
             /* If the node doesn't exist then insert it, otherwise just update
-             * it with the last results 
+             * it with the last results
              */
-            compare_nodep = util_ald_cache_fetch(curl->compare_cache, 
+            compare_nodep = util_ald_cache_fetch(curl->compare_cache,
                                                  &the_compare_node);
-            if (   (compare_nodep == NULL) 
-                || (strcmp(the_compare_node.dn, compare_nodep->dn) != 0) 
-                || (strcmp(the_compare_node.attrib,compare_nodep->attrib) != 0) 
+            if (   (compare_nodep == NULL)
+                || (strcmp(the_compare_node.dn, compare_nodep->dn) != 0)
+                || (strcmp(the_compare_node.attrib,compare_nodep->attrib) != 0)
                 || (strcmp(the_compare_node.value, compare_nodep->value) != 0))
             {
                 util_ald_cache_insert(curl->compare_cache, &the_compare_node);
@@ -839,9 +839,9 @@ start_over:
 }
 
 static int uldap_cache_checkuserid(request_rec *r, util_ldap_connection_t *ldc,
-                                   const char *url, const char *basedn, 
+                                   const char *url, const char *basedn,
                                    int scope, char **attrs, const char *filter,
-                                   const char *bindpw, const char **binddn, 
+                                   const char *bindpw, const char **binddn,
                                    const char ***retvals)
 {
     const char **vals = NULL;
@@ -857,14 +857,14 @@ static int uldap_cache_checkuserid(request_rec *r, util_ldap_connection_t *ldc,
     util_search_node_t the_search_node;
     apr_time_t curtime;
 
-    util_ldap_state_t *st = 
+    util_ldap_state_t *st =
         (util_ldap_state_t *)ap_get_module_config(r->server->module_config,
         &ldap_module);
 
     /* Get the cache node for this url */
     LDAP_CACHE_LOCK();
     curnode.url = url;
-    curl = (util_url_node_t *)util_ald_cache_fetch(st->util_ldap_cache, 
+    curl = (util_url_node_t *)util_ald_cache_fetch(st->util_ldap_cache,
                                                    &curnode);
     if (curl == NULL) {
         curl = util_ald_create_caches(st, url);
@@ -874,26 +874,26 @@ static int uldap_cache_checkuserid(request_rec *r, util_ldap_connection_t *ldc,
     if (curl) {
         LDAP_CACHE_LOCK();
         the_search_node.username = filter;
-        search_nodep = util_ald_cache_fetch(curl->search_cache, 
+        search_nodep = util_ald_cache_fetch(curl->search_cache,
                                             &the_search_node);
         if (search_nodep != NULL) {
-    
+
             /* found entry in search cache... */
             curtime = apr_time_now();
-    
+
             /*
-             * Remove this item from the cache if its expired. If the sent 
-             * password doesn't match the storepassword, the entry will 
-             * be removed and readded later if the credentials pass 
+             * Remove this item from the cache if its expired. If the sent
+             * password doesn't match the storepassword, the entry will
+             * be removed and readded later if the credentials pass
              * authentication.
              */
             if ((curtime - search_nodep->lastbind) > st->search_cache_ttl) {
                 /* ...but entry is too old */
                 util_ald_cache_remove(curl->search_cache, search_nodep);
             }
-            else if (   (search_nodep->bindpw) 
-                     && (search_nodep->bindpw[0] != '\0') 
-                     && (strcmp(search_nodep->bindpw, bindpw) == 0)) 
+            else if (   (search_nodep->bindpw)
+                     && (search_nodep->bindpw[0] != '\0')
+                     && (strcmp(search_nodep->bindpw, bindpw) == 0))
             {
                 /* ...and entry is valid */
                 *binddn = search_nodep->dn;
@@ -907,7 +907,7 @@ static int uldap_cache_checkuserid(request_rec *r, util_ldap_connection_t *ldc,
         LDAP_CACHE_UNLOCK();
     }
 
-    /*	
+    /*
      * At this point, there is no valid cached search, so lets do the search.
      */
 
@@ -924,10 +924,10 @@ start_over:
 
     /* try do the search */
     if ((result = ldap_search_ext_s(ldc->ldap,
-                                    (char *)basedn, scope, 
-                                    (char *)filter, attrs, 0, 
-                                    NULL, NULL, NULL, -1, &res)) 
-            == LDAP_SERVER_DOWN) 
+                                    (char *)basedn, scope,
+                                    (char *)filter, attrs, 0,
+                                    NULL, NULL, NULL, -1, &res))
+            == LDAP_SERVER_DOWN)
     {
         ldc->reason = "ldap_search_ext_s() for user failed with server down";
         uldap_connection_unbind(ldc);
@@ -940,12 +940,12 @@ start_over:
         return result;
     }
 
-    /* 
+    /*
      * We should have found exactly one entry; to find a different
      * number is an error.
      */
     count = ldap_count_entries(ldc->ldap, res);
-    if (count != 1) 
+    if (count != 1)
     {
         if (count == 0 )
             ldc->reason = "User not found";
@@ -963,7 +963,7 @@ start_over:
     *binddn = apr_pstrdup(r->pool, dn);
     ldap_memfree(dn);
 
-    /* 
+    /*
      * A bind to the server with an empty password always succeeds, so
      * we check to ensure that the password is not empty. This implies
      * that users who actually do have empty passwords will never be
@@ -976,7 +976,7 @@ start_over:
         return LDAP_INVALID_CREDENTIALS;
     }
 
-    /* 
+    /*
      * Attempt to bind with the retrieved dn and the password. If the bind
      * fails, it means that the password is wrong (the dn obviously
      * exists, since we just retrieved it)
@@ -1024,7 +1024,7 @@ start_over:
             /* get values */
             values = ldap_get_values(ldc->ldap, entry, attrs[i]);
             while (values && values[j]) {
-                str = str ? apr_pstrcat(r->pool, str, "; ", values[j], NULL) 
+                str = str ? apr_pstrcat(r->pool, str, "; ", values[j], NULL)
                           : apr_pstrdup(r->pool, values[j]);
                 j++;
             }
@@ -1035,7 +1035,7 @@ start_over:
         *retvals = vals;
     }
 
-    /* 		
+    /*
      * Add the new username to the search cache.
      */
     if (curl) {
@@ -1047,13 +1047,13 @@ start_over:
         the_search_node.vals = vals;
         the_search_node.numvals = numvals;
 
-        /* Search again to make sure that another thread didn't ready insert 
-         * this node into the cache before we got here. If it does exist then 
-         * update the lastbind 
+        /* Search again to make sure that another thread didn't ready insert
+         * this node into the cache before we got here. If it does exist then
+         * update the lastbind
          */
-        search_nodep = util_ald_cache_fetch(curl->search_cache, 
+        search_nodep = util_ald_cache_fetch(curl->search_cache,
                                             &the_search_node);
-        if ((search_nodep == NULL) || 
+        if ((search_nodep == NULL) ||
             (strcmp(*binddn, search_nodep->dn) != 0)) {
 
             /* Nothing in cache, insert new entry */
@@ -1086,8 +1086,8 @@ start_over:
  * with password checking removed.
  */
 static int uldap_cache_getuserdn(request_rec *r, util_ldap_connection_t *ldc,
-                                 const char *url, const char *basedn, 
-                                 int scope, char **attrs, const char *filter, 
+                                 const char *url, const char *basedn,
+                                 int scope, char **attrs, const char *filter,
                                  const char **binddn, const char ***retvals)
 {
     const char **vals = NULL;
@@ -1103,14 +1103,14 @@ static int uldap_cache_getuserdn(request_rec *r, util_ldap_connection_t *ldc,
     util_search_node_t the_search_node;
     apr_time_t curtime;
 
-    util_ldap_state_t *st = 
+    util_ldap_state_t *st =
         (util_ldap_state_t *)ap_get_module_config(r->server->module_config,
         &ldap_module);
 
     /* Get the cache node for this url */
     LDAP_CACHE_LOCK();
     curnode.url = url;
-    curl = (util_url_node_t *)util_ald_cache_fetch(st->util_ldap_cache, 
+    curl = (util_url_node_t *)util_ald_cache_fetch(st->util_ldap_cache,
                                                    &curnode);
     if (curl == NULL) {
         curl = util_ald_create_caches(st, url);
@@ -1120,13 +1120,13 @@ static int uldap_cache_getuserdn(request_rec *r, util_ldap_connection_t *ldc,
     if (curl) {
         LDAP_CACHE_LOCK();
         the_search_node.username = filter;
-        search_nodep = util_ald_cache_fetch(curl->search_cache, 
+        search_nodep = util_ald_cache_fetch(curl->search_cache,
                                             &the_search_node);
         if (search_nodep != NULL) {
-    
+
             /* found entry in search cache... */
             curtime = apr_time_now();
-    
+
             /*
              * Remove this item from the cache if its expired.
              */
@@ -1147,7 +1147,7 @@ static int uldap_cache_getuserdn(request_rec *r, util_ldap_connection_t *ldc,
         LDAP_CACHE_UNLOCK();
     }
 
-    /*	
+    /*
      * At this point, there is no valid cached search, so lets do the search.
      */
 
@@ -1165,9 +1165,9 @@ start_over:
     /* try do the search */
     if ((result = ldap_search_ext_s(ldc->ldap,
                                     (char *)basedn, scope,
-                                    (char *)filter, attrs, 0, 
-                                    NULL, NULL, NULL, -1, &res)) 
-            == LDAP_SERVER_DOWN) 
+                                    (char *)filter, attrs, 0,
+                                    NULL, NULL, NULL, -1, &res))
+            == LDAP_SERVER_DOWN)
     {
         ldc->reason = "ldap_search_ext_s() for user failed with server down";
         uldap_connection_unbind(ldc);
@@ -1180,12 +1180,12 @@ start_over:
         return result;
     }
 
-    /* 
+    /*
      * We should have found exactly one entry; to find a different
      * number is an error.
      */
     count = ldap_count_entries(ldc->ldap, res);
-    if (count != 1) 
+    if (count != 1)
     {
         if (count == 0 )
             ldc->reason = "User not found";
@@ -1219,7 +1219,7 @@ start_over:
             /* get values */
             values = ldap_get_values(ldc->ldap, entry, attrs[i]);
             while (values && values[j]) {
-                str = str ? apr_pstrcat(r->pool, str, "; ", values[j], NULL) 
+                str = str ? apr_pstrcat(r->pool, str, "; ", values[j], NULL)
                           : apr_pstrdup(r->pool, values[j]);
                 j++;
             }
@@ -1230,7 +1230,7 @@ start_over:
         *retvals = vals;
     }
 
-    /* 		
+    /*
      * Add the new username to the search cache.
      */
     if (curl) {
@@ -1242,13 +1242,13 @@ start_over:
         the_search_node.vals = vals;
         the_search_node.numvals = numvals;
 
-        /* Search again to make sure that another thread didn't ready insert 
-         * this node into the cache before we got here. If it does exist then 
-         * update the lastbind 
+        /* Search again to make sure that another thread didn't ready insert
+         * this node into the cache before we got here. If it does exist then
+         * update the lastbind
          */
         search_nodep = util_ald_cache_fetch(curl->search_cache,
                                             &the_search_node);
-        if ((search_nodep == NULL) || 
+        if ((search_nodep == NULL) ||
             (strcmp(*binddn, search_nodep->dn) != 0)) {
 
             /* Nothing in cache, insert new entry */
@@ -1273,7 +1273,7 @@ start_over:
 }
 
 /*
- * Reports if ssl support is enabled 
+ * Reports if ssl support is enabled
  *
  * 1 = enabled, 0 = not enabled
  */
@@ -1290,28 +1290,28 @@ static int uldap_ssl_supported(request_rec *r)
 /* config directives */
 
 
-static const char *util_ldap_set_cache_bytes(cmd_parms *cmd, void *dummy, 
+static const char *util_ldap_set_cache_bytes(cmd_parms *cmd, void *dummy,
                                              const char *bytes)
 {
-    util_ldap_state_t *st = 
-        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
+    util_ldap_state_t *st =
+        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config,
                                                   &ldap_module);
 
     st->cache_bytes = atol(bytes);
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
                  "[%" APR_PID_T_FMT "] ldap cache: Setting shared memory "
-                 " cache size to %" APR_SIZE_T_FMT " bytes.", 
+                 " cache size to %" APR_SIZE_T_FMT " bytes.",
                  getpid(), st->cache_bytes);
 
     return NULL;
 }
 
-static const char *util_ldap_set_cache_file(cmd_parms *cmd, void *dummy, 
+static const char *util_ldap_set_cache_file(cmd_parms *cmd, void *dummy,
                                             const char *file)
 {
-    util_ldap_state_t *st = 
-        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
+    util_ldap_state_t *st =
+        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config,
                                                   &ldap_module);
 
     if (file) {
@@ -1321,34 +1321,34 @@ static const char *util_ldap_set_cache_file(cmd_parms *cmd, void *dummy,
         st->cache_file = NULL;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, 
-                 "LDAP cache: Setting shared memory cache file to %s bytes.", 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+                 "LDAP cache: Setting shared memory cache file to %s bytes.",
                  st->cache_file);
 
     return NULL;
 }
 
-static const char *util_ldap_set_cache_ttl(cmd_parms *cmd, void *dummy, 
+static const char *util_ldap_set_cache_ttl(cmd_parms *cmd, void *dummy,
                                            const char *ttl)
 {
-    util_ldap_state_t *st = 
-        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
+    util_ldap_state_t *st =
+        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config,
                                                   &ldap_module);
 
     st->search_cache_ttl = atol(ttl) * 1000000;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
                  "[%" APR_PID_T_FMT "] ldap cache: Setting cache TTL to %ld microseconds.",
                  getpid(), st->search_cache_ttl);
 
     return NULL;
 }
 
-static const char *util_ldap_set_cache_entries(cmd_parms *cmd, void *dummy, 
+static const char *util_ldap_set_cache_entries(cmd_parms *cmd, void *dummy,
                                                const char *size)
 {
-    util_ldap_state_t *st = 
-        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
+    util_ldap_state_t *st =
+        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config,
                                                   &ldap_module);
 
 
@@ -1357,34 +1357,34 @@ static const char *util_ldap_set_cache_entries(cmd_parms *cmd, void *dummy,
         st->search_cache_size = 0;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
                  "[%" APR_PID_T_FMT "] ldap cache: Setting search cache size to %ld entries.",
                  getpid(), st->search_cache_size);
 
     return NULL;
 }
 
-static const char *util_ldap_set_opcache_ttl(cmd_parms *cmd, void *dummy, 
+static const char *util_ldap_set_opcache_ttl(cmd_parms *cmd, void *dummy,
                                              const char *ttl)
 {
-    util_ldap_state_t *st = 
-        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
+    util_ldap_state_t *st =
+        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config,
                                                   &ldap_module);
 
     st->compare_cache_ttl = atol(ttl) * 1000000;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, 
-                 "[%" APR_PID_T_FMT "] ldap cache: Setting operation cache TTL to %ld microseconds.", 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
+                 "[%" APR_PID_T_FMT "] ldap cache: Setting operation cache TTL to %ld microseconds.",
                  getpid(), st->compare_cache_ttl);
 
     return NULL;
 }
 
-static const char *util_ldap_set_opcache_entries(cmd_parms *cmd, void *dummy, 
+static const char *util_ldap_set_opcache_entries(cmd_parms *cmd, void *dummy,
                                                  const char *size)
 {
-    util_ldap_state_t *st = 
-        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
+    util_ldap_state_t *st =
+        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config,
                                                   &ldap_module);
 
     st->compare_cache_size = atol(size);
@@ -1392,7 +1392,7 @@ static const char *util_ldap_set_opcache_entries(cmd_parms *cmd, void *dummy,
         st->compare_cache_size = 0;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
                  "[%" APR_PID_T_FMT "] ldap cache: Setting operation cache size to %ld "
                  "entries.", getpid(), st->compare_cache_size);
 
@@ -1488,10 +1488,10 @@ static int util_ldap_parse_cert_type(const char *type)
  *
  * This directive may only be used globally.
  */
-static const char *util_ldap_set_trusted_global_cert(cmd_parms *cmd, 
-                                                     void *dummy, 
-                                                     const char *type, 
-                                                     const char *file, 
+static const char *util_ldap_set_trusted_global_cert(cmd_parms *cmd,
+                                                     void *dummy,
+                                                     const char *type,
+                                                     const char *file,
                                                      const char *password)
 {
     util_ldap_state_t *st =
@@ -1539,8 +1539,8 @@ static const char *util_ldap_set_trusted_global_cert(cmd_parms *cmd,
 
         cert->path = ap_server_root_relative(cmd->pool, file);
         if (cert->path &&
-            ((rv = apr_stat (&finfo, cert->path, APR_FINFO_MIN, cmd->pool)) 
-                != APR_SUCCESS)) 
+            ((rv = apr_stat (&finfo, cert->path, APR_FINFO_MIN, cmd->pool))
+                != APR_SUCCESS))
         {
             ap_log_error(APLOG_MARK, APLOG_ERR, rv, cmd->server,
                          "LDAP: Could not open SSL trusted certificate "
@@ -1562,10 +1562,10 @@ static const char *util_ldap_set_trusted_global_cert(cmd_parms *cmd,
  * - certificate file / directory / nickname
  * - certificate password (optional)
  */
-static const char *util_ldap_set_trusted_client_cert(cmd_parms *cmd, 
-                                                     void *config, 
-                                                     const char *type, 
-                                                     const char *file, 
+static const char *util_ldap_set_trusted_client_cert(cmd_parms *cmd,
+                                                     void *config,
+                                                     const char *type,
+                                                     const char *file,
                                                      const char *password)
 {
     util_ldap_state_t *st =
@@ -1584,7 +1584,7 @@ static const char *util_ldap_set_trusted_client_cert(cmd_parms *cmd,
                                            "not recognised. It should be one "
                                            "of CERT_DER, CERT_BASE64, "
                                            "CERT_NICKNAME, CERT_PFX,"
-                                           "KEY_DER, KEY_BASE64, KEY_PFX", 
+                                           "KEY_DER, KEY_BASE64, KEY_PFX",
                                            type);
         }
         else if (APR_LDAP_CA_TYPE_DER == cert_type ||
@@ -1611,7 +1611,7 @@ static const char *util_ldap_set_trusted_client_cert(cmd_parms *cmd,
 
     /* add the certificate to the global array */
     cert = (apr_ldap_opt_tls_cert_t *)apr_array_push(st->global_certs);
-    cert->type = cert_type; 
+    cert->type = cert_type;
     cert->path = file;
     cert->password = password;
 
@@ -1621,8 +1621,8 @@ static const char *util_ldap_set_trusted_client_cert(cmd_parms *cmd,
 
         cert->path = ap_server_root_relative(cmd->pool, file);
         if (cert->path &&
-            ((rv = apr_stat (&finfo, cert->path, APR_FINFO_MIN, cmd->pool)) 
-                != APR_SUCCESS)) 
+            ((rv = apr_stat (&finfo, cert->path, APR_FINFO_MIN, cmd->pool))
+                != APR_SUCCESS))
         {
             ap_log_error(APLOG_MARK, APLOG_ERR, rv, cmd->server,
                          "LDAP: Could not open SSL client certificate "
@@ -1639,13 +1639,13 @@ static const char *util_ldap_set_trusted_client_cert(cmd_parms *cmd,
 
 /**
  * Set LDAPTrustedMode.
- *                    
+ *
  * This directive sets what encryption mode to use on a connection:
  * - None (No encryption)
  * - SSL (SSL encryption)
  * - STARTTLS (TLS encryption)
- */ 
-static const char *util_ldap_set_trusted_mode(cmd_parms *cmd, void *dummy, 
+ */
+static const char *util_ldap_set_trusted_mode(cmd_parms *cmd, void *dummy,
                                               const char *mode)
 {
     util_ldap_state_t *st =
@@ -1675,8 +1675,8 @@ static const char *util_ldap_set_trusted_mode(cmd_parms *cmd, void *dummy,
     return(NULL);
 }
 
-static const char *util_ldap_set_verify_srv_cert(cmd_parms *cmd, 
-                                                 void *dummy, 
+static const char *util_ldap_set_verify_srv_cert(cmd_parms *cmd,
+                                                 void *dummy,
                                                  int mode)
 {
     util_ldap_state_t *st =
@@ -1684,7 +1684,7 @@ static const char *util_ldap_set_verify_srv_cert(cmd_parms *cmd,
                                               &ldap_module);
 
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
-                      "LDAP: SSL verify server certificate - %s", 
+                      "LDAP: SSL verify server certificate - %s",
                       mode?"TRUE":"FALSE");
 
     st->verify_svr_cert = mode;
@@ -1693,12 +1693,12 @@ static const char *util_ldap_set_verify_srv_cert(cmd_parms *cmd,
 }
 
 
-static const char *util_ldap_set_connection_timeout(cmd_parms *cmd, 
-                                                    void *dummy, 
+static const char *util_ldap_set_connection_timeout(cmd_parms *cmd,
+                                                    void *dummy,
                                                     const char *ttl)
 {
-    util_ldap_state_t *st = 
-        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config, 
+    util_ldap_state_t *st =
+        (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config,
                                                   &ldap_module);
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
 
@@ -1709,7 +1709,7 @@ static const char *util_ldap_set_connection_timeout(cmd_parms *cmd,
 #ifdef LDAP_OPT_NETWORK_TIMEOUT
     st->connectionTimeout = atol(ttl);
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
                  "[%" APR_PID_T_FMT "] ldap connection: Setting connection timeout to "
                  "%ld seconds.", getpid(), st->connectionTimeout);
 #else
@@ -1724,7 +1724,7 @@ static const char *util_ldap_set_connection_timeout(cmd_parms *cmd,
 
 static void *util_ldap_create_config(apr_pool_t *p, server_rec *s)
 {
-    util_ldap_state_t *st = 
+    util_ldap_state_t *st =
         (util_ldap_state_t *)apr_pcalloc(p, sizeof(util_ldap_state_t));
 
     st->pool = p;
@@ -1746,7 +1746,7 @@ static void *util_ldap_create_config(apr_pool_t *p, server_rec *s)
     return st;
 }
 
-static void *util_ldap_merge_config(apr_pool_t *p, void *basev, 
+static void *util_ldap_merge_config(apr_pool_t *p, void *basev,
                                     void *overridesv)
 {
     util_ldap_state_t *st = apr_pcalloc(p, sizeof(util_ldap_state_t));
@@ -1762,11 +1762,11 @@ static void *util_ldap_merge_config(apr_pool_t *p, void *basev,
     st->compare_cache_size = base->compare_cache_size;
     st->connections = base->connections;
     st->ssl_supported = base->ssl_supported;
-    st->global_certs = apr_array_append(p, base->global_certs, 
+    st->global_certs = apr_array_append(p, base->global_certs,
                                            overrides->global_certs);
-    st->client_certs = apr_array_append(p, base->client_certs, 
+    st->client_certs = apr_array_append(p, base->client_certs,
                                            overrides->client_certs);
-    st->secure = (overrides->secure_set == 0) ? base->secure 
+    st->secure = (overrides->secure_set == 0) ? base->secure
                                               : overrides->secure;
 
     return st;
@@ -1778,7 +1778,7 @@ static apr_status_t util_ldap_cleanup_module(void *data)
     server_rec *s = data;
     util_ldap_state_t *st = (util_ldap_state_t *)ap_get_module_config(
         s->module_config, &ldap_module);
-    
+
     if (st->ssl_supported) {
         apr_ldap_ssl_deinit();
     }
@@ -1787,7 +1787,7 @@ static apr_status_t util_ldap_cleanup_module(void *data)
 
 }
 
-static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog, 
+static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
                                  apr_pool_t *ptemp, server_rec *s)
 {
     apr_status_t result;
@@ -1795,7 +1795,7 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
     util_ldap_state_t *st_vhost;
 
     util_ldap_state_t *st = (util_ldap_state_t *)
-                            ap_get_module_config(s->module_config, 
+                            ap_get_module_config(s->module_config,
                                                  &ldap_module);
 
     void *data;
@@ -1815,7 +1815,7 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
         /* If the cache file already exists then delete it.  Otherwise we are
          * going to run into problems creating the shared memory. */
         if (st->cache_file) {
-            char *lck_file = apr_pstrcat(st->pool, st->cache_file, ".lck", 
+            char *lck_file = apr_pstrcat(st->pool, st->cache_file, ".lck",
                                          NULL);
             apr_file_remove(lck_file, ptemp);
         }
@@ -1824,8 +1824,8 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
     }
 
 #if APR_HAS_SHARED_MEMORY
-    /* initializing cache if shared memory size is not zero and we already 
-     * don't have shm address 
+    /* initializing cache if shared memory size is not zero and we already
+     * don't have shm address
      */
     if (!st->cache_shm && st->cache_bytes > 0) {
 #endif
@@ -1839,13 +1839,13 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
 
 #if APR_HAS_SHARED_MEMORY
         if (st->cache_file) {
-            st->lock_file = apr_pstrcat(st->pool, st->cache_file, ".lck", 
+            st->lock_file = apr_pstrcat(st->pool, st->cache_file, ".lck",
                                         NULL);
         }
 #endif
 
-        result = apr_global_mutex_create(&st->util_ldap_cache_lock, 
-                                         st->lock_file, APR_LOCK_DEFAULT, 
+        result = apr_global_mutex_create(&st->util_ldap_cache_lock,
+                                         st->lock_file, APR_LOCK_DEFAULT,
                                          st->pool);
         if (result != APR_SUCCESS) {
             return result;
@@ -1854,7 +1854,7 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
 #ifdef AP_NEED_SET_MUTEX_PERMS
         result = unixd_set_global_mutex_perms(st->util_ldap_cache_lock);
         if (result != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, result, s, 
+            ap_log_error(APLOG_MARK, APLOG_CRIT, result, s,
                          "LDAP cache: failed to set mutex permissions");
             return result;
         }
@@ -1864,16 +1864,16 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
         s_vhost = s->next;
         while (s_vhost) {
             st_vhost = (util_ldap_state_t *)
-                       ap_get_module_config(s_vhost->module_config, 
+                       ap_get_module_config(s_vhost->module_config,
                                             &ldap_module);
 
 #if APR_HAS_SHARED_MEMORY
             st_vhost->cache_shm = st->cache_shm;
             st_vhost->cache_rmm = st->cache_rmm;
             st_vhost->cache_file = st->cache_file;
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, result, s, 
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, result, s,
                          "LDAP merging Shared Cache conf: shm=0x%pp rmm=0x%pp "
-                         "for VHOST: %s", st->cache_shm, st->cache_rmm, 
+                         "for VHOST: %s", st->cache_shm, st->cache_rmm,
                          s_vhost->server_hostname);
 #endif
             st_vhost->lock_file = st->lock_file;
@@ -1882,13 +1882,13 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
 #if APR_HAS_SHARED_MEMORY
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, 
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
                      "LDAP cache: LDAPSharedCacheSize is zero, disabling "
                      "shared memory cache");
     }
 #endif
-    
-    /* log the LDAP SDK used 
+
+    /* log the LDAP SDK used
      */
     {
         apr_ldap_err_t *result = NULL;
@@ -1899,7 +1899,7 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
     }
 
     apr_pool_cleanup_register(p, s, util_ldap_cleanup_module,
-                              util_ldap_cleanup_module); 
+                              util_ldap_cleanup_module);
 
     /*
      * Initialize SSL support, and log the result for the benefit of the admin.
@@ -1907,9 +1907,9 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
      * If SSL is not supported it is not necessarily an error, as the
      * application may not want to use it.
      */
-    rc = apr_ldap_ssl_init(p, 
-                      NULL, 
-                      0, 
+    rc = apr_ldap_ssl_init(p,
+                      NULL,
+                      0,
                       &(result_err));
     if (APR_SUCCESS == rc) {
         rc = apr_ldap_set_option(p, NULL, APR_LDAP_OPT_TLS_CERT,
@@ -1923,7 +1923,7 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
     }
     else {
         st->ssl_supported = 0;
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, 
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
                      "LDAP: SSL support unavailable%s%s",
                      result_err ? ": " : "",
                      result_err ? result_err->reason : "");
@@ -1935,12 +1935,12 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
 static void util_ldap_child_init(apr_pool_t *p, server_rec *s)
 {
     apr_status_t sts;
-    util_ldap_state_t *st = ap_get_module_config(s->module_config, 
+    util_ldap_state_t *st = ap_get_module_config(s->module_config,
                                                  &ldap_module);
 
     if (!st->util_ldap_cache_lock) return;
 
-    sts = apr_global_mutex_child_init(&st->util_ldap_cache_lock, 
+    sts = apr_global_mutex_child_init(&st->util_ldap_cache_lock,
                                       st->lock_file, p);
     if (sts != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, sts, s,
@@ -1951,34 +1951,34 @@ static void util_ldap_child_init(apr_pool_t *p, server_rec *s)
 }
 
 static const command_rec util_ldap_cmds[] = {
-    AP_INIT_TAKE1("LDAPSharedCacheSize", util_ldap_set_cache_bytes, 
+    AP_INIT_TAKE1("LDAPSharedCacheSize", util_ldap_set_cache_bytes,
                   NULL, RSRC_CONF,
                   "Set the size of the shared memory cache (in bytes). Use "
                   "0 to disable the shared memory cache. (default: 100000)"),
 
-    AP_INIT_TAKE1("LDAPSharedCacheFile", util_ldap_set_cache_file, 
+    AP_INIT_TAKE1("LDAPSharedCacheFile", util_ldap_set_cache_file,
                   NULL, RSRC_CONF,
                   "Set the file name for the shared memory cache."),
 
-    AP_INIT_TAKE1("LDAPCacheEntries", util_ldap_set_cache_entries, 
+    AP_INIT_TAKE1("LDAPCacheEntries", util_ldap_set_cache_entries,
                   NULL, RSRC_CONF,
                   "Set the maximum number of entries that are possible in the "
                   "LDAP search cache. Use 0 for no limit. "
                   "-1 disables the cache. (default: 1024)"),
 
-    AP_INIT_TAKE1("LDAPCacheTTL", util_ldap_set_cache_ttl, 
+    AP_INIT_TAKE1("LDAPCacheTTL", util_ldap_set_cache_ttl,
                   NULL, RSRC_CONF,
                   "Set the maximum time (in seconds) that an item can be "
                   "cached in the LDAP search cache. Use 0 for no limit. "
                   "(default 600)"),
 
-    AP_INIT_TAKE1("LDAPOpCacheEntries", util_ldap_set_opcache_entries, 
+    AP_INIT_TAKE1("LDAPOpCacheEntries", util_ldap_set_opcache_entries,
                   NULL, RSRC_CONF,
                   "Set the maximum number of entries that are possible "
                   "in the LDAP compare cache. Use 0 for no limit. "
                   "Use -1 to disable the cache. (default: 1024)"),
 
-    AP_INIT_TAKE1("LDAPOpCacheTTL", util_ldap_set_opcache_ttl, 
+    AP_INIT_TAKE1("LDAPOpCacheTTL", util_ldap_set_opcache_ttl,
                   NULL, RSRC_CONF,
                   "Set the maximum time (in seconds) that an item is cached "
                   "in the LDAP operation cache. Use 0 for no limit. "
@@ -2004,17 +2004,17 @@ static const command_rec util_ldap_cmds[] = {
                    "CERT_NICKNAME, KEY_DER, or KEY_BASE64. Third arg is an "
                    "optional passphrase if applicable."),
 
-    AP_INIT_TAKE1("LDAPTrustedMode", util_ldap_set_trusted_mode, 
+    AP_INIT_TAKE1("LDAPTrustedMode", util_ldap_set_trusted_mode,
                   NULL, RSRC_CONF,
                   "Specify the type of security that should be applied to "
                   "an LDAP connection. One of; NONE, SSL or STARTTLS."),
 
-    AP_INIT_FLAG("LDAPVerifyServerCert", util_ldap_set_verify_srv_cert, 
+    AP_INIT_FLAG("LDAPVerifyServerCert", util_ldap_set_verify_srv_cert,
                   NULL, RSRC_CONF,
                   "Set to 'ON' requires that the server certificate be verified "
                   "before a secure LDAP connection can be establish.  Default 'ON'"),
 
-    AP_INIT_TAKE1("LDAPConnectionTimeout", util_ldap_set_connection_timeout, 
+    AP_INIT_TAKE1("LDAPConnectionTimeout", util_ldap_set_connection_timeout,
                   NULL, RSRC_CONF,
                   "Specify the LDAP socket connection timeout in seconds "
                   "(default: 10)"),
diff --git a/modules/ldap/util_ldap_cache.c b/modules/ldap/util_ldap_cache.c
index c717904..04c52a7 100644
--- a/modules/ldap/util_ldap_cache.c
+++ b/modules/ldap/util_ldap_cache.c
@@ -16,9 +16,9 @@
 
 /*
  * util_ldap_cache.c: LDAP cache things
- * 
+ *
  * Original code from auth_ldap module for Apache v1.3:
- * Copyright 1998, 1999 Enbridge Pipelines Inc. 
+ * Copyright 1998, 1999 Enbridge Pipelines Inc.
  * Copyright 1999-2001 Dave Carrigan
  */
 
@@ -100,14 +100,14 @@ void util_ldap_url_node_display(request_rec *r, util_ald_cache_t *cache, void *n
                 type_str = "DN Compares";
                 break;
         }
-        
+
         if (cache_node->marktime) {
             apr_ctime(date_str, cache_node->marktime);
         }
-        else 
+        else
             date_str[0] = 0;
 
-        ap_rprintf(r, 
+        ap_rprintf(r,
                    "<tr valign='top'>"
                    "<td nowrap>%s (%s)</td>"
                    "<td nowrap>%ld</td>"
@@ -299,7 +299,7 @@ void util_ldap_compare_node_display(request_rec *r, util_ald_cache_t *cache, voi
         cmp_result = apr_itoa(r->pool, node->result);
     }
 
-    ap_rprintf(r, 
+    ap_rprintf(r,
                "<tr valign='top'>"
                "<td nowrap>%s</td>"
                "<td nowrap>%s</td>"
@@ -360,7 +360,7 @@ void util_ldap_dn_compare_node_display(request_rec *r, util_ald_cache_t *cache,
 {
     util_dn_compare_node_t *node = n;
 
-    ap_rprintf(r, 
+    ap_rprintf(r,
                "<tr valign='top'>"
                "<td nowrap>%s</td>"
                "<td nowrap>%s</td>"
@@ -412,8 +412,8 @@ apr_status_t util_ldap_cache_init(apr_pool_t *pool, util_ldap_state_t *st)
     size = apr_shm_size_get(st->cache_shm);
 
     /* This will create a rmm "handler" to get into the shared memory area */
-    result = apr_rmm_init(&st->cache_rmm, NULL, 
-                          apr_shm_baseaddr_get(st->cache_shm), size, 
+    result = apr_rmm_init(&st->cache_rmm, NULL,
+                          apr_shm_baseaddr_get(st->cache_shm), size,
                           st->pool);
     if (result != APR_SUCCESS) {
         return result;
diff --git a/modules/ldap/util_ldap_cache_mgr.c b/modules/ldap/util_ldap_cache_mgr.c
index 48018d1..ad42ddb 100644
--- a/modules/ldap/util_ldap_cache_mgr.c
+++ b/modules/ldap/util_ldap_cache_mgr.c
@@ -16,9 +16,9 @@
 
 /*
  * util_ldap_cache_mgr.c: LDAP cache manager things
- * 
+ *
  * Original code from auth_ldap module for Apache v1.3:
- * Copyright 1998, 1999 Enbridge Pipelines Inc. 
+ * Copyright 1998, 1999 Enbridge Pipelines Inc.
  * Copyright 1999-2001 Dave Carrigan
  */
 
@@ -138,7 +138,7 @@ const char *util_ald_strdup(util_ald_cache_t *cache, const char *s)
 
 /*
  * Computes the hash on a set of strings. The first argument is the number
- * of strings to hash, the rest of the args are strings. 
+ * of strings to hash, the rest of the args are strings.
  * Algorithm taken from glibc.
  */
 unsigned long util_ald_hash_string(int nstr, ...)
@@ -147,7 +147,7 @@ unsigned long util_ald_hash_string(int nstr, ...)
     va_list args;
     unsigned long h=0, g;
     char *str, *p;
-  
+
     va_start(args, nstr);
     for (i=0; i < nstr; ++i) {
         str = va_arg(args, char *);
@@ -204,8 +204,8 @@ void util_ald_cache_purge(util_ald_cache_t *cache)
     }
 
     t = apr_time_now();
-    cache->avg_purgetime = 
-         ((t - cache->last_purge) + (cache->avg_purgetime * (cache->numpurges-1))) / 
+    cache->avg_purgetime =
+         ((t - cache->last_purge) + (cache->avg_purgetime * (cache->numpurges-1))) /
          cache->numpurges;
 }
 
@@ -265,7 +265,7 @@ util_url_node_t *util_ald_create_caches(util_ldap_state_t *st, const char *url)
 
 util_ald_cache_t *util_ald_create_cache(util_ldap_state_t *st,
                                 long cache_size,
-                                unsigned long (*hashfunc)(void *), 
+                                unsigned long (*hashfunc)(void *),
                                 int (*comparefunc)(void *, void *),
                                 void * (*copyfunc)(util_ald_cache_t *cache, void *),
                                 void (*freefunc)(util_ald_cache_t *cache, void *),
@@ -365,7 +365,7 @@ void *util_ald_cache_fetch(util_ald_cache_t *cache, void *payload)
     cache->fetches++;
 
     hashval = (*cache->hash)(payload) % cache->size;
-    for (p = cache->nodes[hashval]; 
+    for (p = cache->nodes[hashval];
          p && !(*cache->compare)(p->payload, payload);
     p = p->next) ;
 
@@ -379,7 +379,7 @@ void *util_ald_cache_fetch(util_ald_cache_t *cache, void *payload)
 }
 
 /*
- * Insert an item into the cache. 
+ * Insert an item into the cache.
  * *** Does not catch duplicates!!! ***
  */
 void *util_ald_cache_insert(util_ald_cache_t *cache, void *payload)
@@ -435,7 +435,7 @@ void util_ald_cache_remove(util_ald_cache_t *cache, void *payload)
 {
     unsigned long hashval;
     util_cache_node_t *p, *q;
-  
+
     if (cache == NULL)
         return;
 
@@ -491,7 +491,7 @@ char *util_ald_cache_display_stats(request_rec *r, util_ald_cache_t *cache, char
     chainlen = nchains? (double)totchainlen / (double)nchains : 0;
 
     if (id) {
-        buf2 = apr_psprintf(p, 
+        buf2 = apr_psprintf(p,
                  "<a href=\"%s?%s\">%s</a>",
              r->uri,
              id,
@@ -501,7 +501,7 @@ char *util_ald_cache_display_stats(request_rec *r, util_ald_cache_t *cache, char
         buf2 = name;
     }
 
-    buf = apr_psprintf(p, 
+    buf = apr_psprintf(p,
              "<tr valign='top'>"
              "<td nowrap>%s</td>"
              "<td align='right' nowrap>%lu (%.0f%% full)</td>"
@@ -510,7 +510,7 @@ char *util_ald_cache_display_stats(request_rec *r, util_ald_cache_t *cache, char
              "<td align='right'>%.0f%%</td>"
              "<td align='right'>%lu/%lu</td>",
          buf2,
-         cache->numentries, 
+         cache->numentries,
          (double)cache->numentries / (double)cache->maxentries * 100.0,
          chainlen,
          cache->hits,
@@ -526,13 +526,13 @@ char *util_ald_cache_display_stats(request_rec *r, util_ald_cache_t *cache, char
         buf = apr_psprintf(p,
                  "%s"
                  "<td align='right'>%lu</td>\n"
-                 "<td align='right' nowrap>%s</td>\n", 
+                 "<td align='right' nowrap>%s</td>\n",
              buf,
              cache->numpurges,
              str_ctime);
     }
     else {
-        buf = apr_psprintf(p, 
+        buf = apr_psprintf(p,
                  "%s<td colspan='2' align='center'>(none)</td>\n",
              buf);
     }
@@ -585,10 +585,10 @@ char *util_ald_cache_display(request_rec *r, util_ldap_state_t *st)
                        "</tr>\n"
                        "</table>\n</p>\n",
                        buf,
-                       cachetype[0] == 'm'? "Main" : 
-                       (cachetype[0] == 's' ? "Search" : 
+                       cachetype[0] == 'm'? "Main" :
+                       (cachetype[0] == 's' ? "Search" :
                         (cachetype[0] == 'c' ? "Compares" : "DNCompares")));
-            
+
             switch (cachetype[0]) {
                 case 'm':
                     if (util_ldap_cache->marktime) {
@@ -645,7 +645,7 @@ char *util_ald_cache_display(request_rec *r, util_ldap_state_t *st)
                         }
                     }
                     ap_rputs("</table>\n</p>\n", r);
-                    
+
 
                     break;
                 case 's':
@@ -660,7 +660,7 @@ char *util_ald_cache_display(request_rec *r, util_ldap_state_t *st)
                     if (n) {
                         for (i=0; i < n->search_cache->size; ++i) {
                             for (p = n->search_cache->nodes[i]; p != NULL; p = p->next) {
-    
+
                                 (*n->search_cache->display)(r, n->search_cache, p->payload);
                             }
                         }
@@ -681,7 +681,7 @@ char *util_ald_cache_display(request_rec *r, util_ldap_state_t *st)
                     if (n) {
                         for (i=0; i < n->compare_cache->size; ++i) {
                             for (p = n->compare_cache->nodes[i]; p != NULL; p = p->next) {
-    
+
                                 (*n->compare_cache->display)(r, n->compare_cache, p->payload);
                             }
                         }
@@ -699,7 +699,7 @@ char *util_ald_cache_display(request_rec *r, util_ldap_state_t *st)
                     if (n) {
                         for (i=0; i < n->dn_compare_cache->size; ++i) {
                             for (p = n->dn_compare_cache->nodes[i]; p != NULL; p = p->next) {
-    
+
                                 (*n->dn_compare_cache->display)(r, n->dn_compare_cache, p->payload);
                             }
                         }
@@ -732,19 +732,19 @@ char *util_ald_cache_display(request_rec *r, util_ldap_state_t *st)
 
         id1 = apr_psprintf(pool, argfmt, "main", 0, 0);
         buf = util_ald_cache_display_stats(r, st->util_ldap_cache, "LDAP URL Cache", id1);
-    
+
         for (i=0; i < util_ldap_cache->size; ++i) {
             for (p = util_ldap_cache->nodes[i],j=0; p != NULL; p = p->next,j++) {
-    
+
                 n = (util_url_node_t *)p->payload;
-    
+
                 t1 = apr_psprintf(pool, "%s (Searches)", n->url);
                 t2 = apr_psprintf(pool, "%s (Compares)", n->url);
                 t3 = apr_psprintf(pool, "%s (DNCompares)", n->url);
                 id1 = apr_psprintf(pool, argfmt, "srch", i, j);
                 id2 = apr_psprintf(pool, argfmt, "cmpr", i, j);
                 id3 = apr_psprintf(pool, argfmt, "dncp", i, j);
-    
+
                 buf = apr_psprintf(pool, "%s\n\n"
                                          "%s\n\n"
                                          "%s\n\n"
diff --git a/modules/loggers/mod_log_config.c b/modules/loggers/mod_log_config.c
index 268096f..629a1e7 100644
--- a/modules/loggers/mod_log_config.c
+++ b/modules/loggers/mod_log_config.c
@@ -45,7 +45,7 @@
  * the VirtualHost will _not_ be used. This makes this module compatable
  * with the CLF and config log modules, where the use of TransferLog
  * inside the VirtualHost section overrides its use outside.
- * 
+ *
  * Examples:
  *
  *    TransferLog    logs/access_log
@@ -176,20 +176,20 @@ static int xfer_flags = (APR_WRITE | APR_APPEND | APR_CREATE | APR_LARGEFILE);
 static apr_fileperms_t xfer_perms = APR_OS_DEFAULT;
 static apr_hash_t *log_hash;
 static apr_status_t ap_default_log_writer(request_rec *r,
-                           void *handle, 
+                           void *handle,
                            const char **strs,
                            int *strl,
                            int nelts,
                            apr_size_t len);
 static apr_status_t ap_buffered_log_writer(request_rec *r,
-                           void *handle, 
+                           void *handle,
                            const char **strs,
                            int *strl,
                            int nelts,
                            apr_size_t len);
-static void *ap_default_log_writer_init(apr_pool_t *p, server_rec *s, 
+static void *ap_default_log_writer_init(apr_pool_t *p, server_rec *s,
                                         const char* name);
-static void *ap_buffered_log_writer_init(apr_pool_t *p, server_rec *s, 
+static void *ap_buffered_log_writer_init(apr_pool_t *p, server_rec *s,
                                         const char* name);
 
 static ap_log_writer_init* ap_log_set_writer_init(ap_log_writer_init *handle);
@@ -242,10 +242,10 @@ typedef struct {
  * be NULL, which means this module does no logging for this
  * request. format might be NULL, in which case the default_format
  * from the multi_log_state should be used, or if that is NULL as
- * well, use the CLF. 
+ * well, use the CLF.
  * log_writer is NULL before the log file is opened and is
  * set to a opaque structure (usually a fd) after it is opened.
- 
+
  */
 typedef struct {
     apr_file_t *handle;
@@ -507,7 +507,7 @@ static const char *log_cookie(request_rec *r, char *a)
             start_cookie += strlen(a) + 1; /* cookie_name + '=' */
             cookie = apr_pstrdup(r->pool, start_cookie);
             /* kill everything in cookie after ';' */
-            end_cookie = strchr(cookie, ';'); 
+            end_cookie = strchr(cookie, ';');
             if (end_cookie) {
                 *end_cookie = '\0';
             }
@@ -619,7 +619,7 @@ static const char *log_request_duration(request_rec *r, char *a)
 
 static const char *log_request_duration_microseconds(request_rec *r, char *a)
 {
-    return apr_psprintf(r->pool, "%" APR_TIME_T_FMT, 
+    return apr_psprintf(r->pool, "%" APR_TIME_T_FMT,
                         (apr_time_now() - r->request_time));
 }
 
@@ -675,7 +675,7 @@ static const char *log_connection_status(request_rec *r, char *a)
     if (r->connection->aborted)
         return "X";
 
-    if (r->connection->keepalive == AP_CONN_KEEPALIVE && 
+    if (r->connection->keepalive == AP_CONN_KEEPALIVE &&
         (!r->server->keep_alive_max ||
          (r->server->keep_alive_max - r->connection->keepalives) > 0)) {
         return "+";
@@ -767,7 +767,7 @@ static char *parse_log_item(apr_pool_t *p, log_format_item *it, const char **sa)
         it->arg = "%";
         it->func = constant_item;
         *sa = ++s;
-    
+
         return NULL;
     }
 
@@ -1153,10 +1153,10 @@ static config_log_state *open_config_log(server_rec *s, apr_pool_t *p,
     if (cls->fname == NULL) {
         return cls;             /* Leave it NULL to decline.  */
     }
-    
+
     cls->log_writer = log_writer_init(p, s, cls->fname);
     if (cls->log_writer == NULL)
-        return NULL; 
+        return NULL;
 
     return cls;
 }
@@ -1175,7 +1175,7 @@ static int open_multi_logs(server_rec *s, apr_pool_t *p)
         if (format) {
             mls->default_format = parse_log_string(p, format, &dummy);
         }
-    }    
+    }
 
     if (!mls->default_format) {
         mls->default_format = parse_log_string(p, DEFAULT_LOG_FORMAT, &dummy);
@@ -1233,7 +1233,7 @@ static apr_status_t flush_all_logs(void *data)
 
     if (!buffered_logs)
         return APR_SUCCESS;
-    
+
     for (; s; s = s->next) {
         mls = ap_get_module_config(s->module_config, &log_config_module);
         log_list = NULL;
@@ -1288,12 +1288,12 @@ static void init_child(apr_pool_t *p, server_rec *s)
     if (buffered_logs) {
         int i;
         buffered_log **array = (buffered_log **)all_buffered_logs->elts;
-        
+
         apr_pool_cleanup_register(p, s, flush_all_logs, flush_all_logs);
 
         for (i = 0; i < all_buffered_logs->nelts; i++) {
             buffered_log *this = array[i];
-            
+
 #if APR_HAS_THREADS
             if (mpm_threads > 1) {
                 apr_status_t rv;
@@ -1318,7 +1318,7 @@ static void init_child(apr_pool_t *p, server_rec *s)
     }
 }
 
-static void ap_register_log_handler(apr_pool_t *p, char *tag, 
+static void ap_register_log_handler(apr_pool_t *p, char *tag,
                                     ap_log_handler_fn_t *handler, int def)
 {
     ap_log_handler *log_struct = apr_palloc(p, sizeof(*log_struct));
@@ -1329,7 +1329,7 @@ static void ap_register_log_handler(apr_pool_t *p, char *tag,
 }
 static ap_log_writer_init* ap_log_set_writer_init(ap_log_writer_init *handle)
 {
-    ap_log_writer_init *old = log_writer_init; 
+    ap_log_writer_init *old = log_writer_init;
     log_writer_init = handle;
 
     return old;
@@ -1337,14 +1337,14 @@ static ap_log_writer_init* ap_log_set_writer_init(ap_log_writer_init *handle)
 }
 static ap_log_writer *ap_log_set_writer(ap_log_writer *handle)
 {
-    ap_log_writer *old = log_writer; 
+    ap_log_writer *old = log_writer;
     log_writer = handle;
 
     return old;
 }
 
 static apr_status_t ap_default_log_writer( request_rec *r,
-                           void *handle, 
+                           void *handle,
                            const char **strs,
                            int *strl,
                            int nelts,
@@ -1367,7 +1367,7 @@ static apr_status_t ap_default_log_writer( request_rec *r,
 
     return rv;
 }
-static void *ap_default_log_writer_init(apr_pool_t *p, server_rec *s, 
+static void *ap_default_log_writer_init(apr_pool_t *p, server_rec *s,
                                         const char* name)
 {
     if (*name == '|') {
@@ -1398,13 +1398,13 @@ static void *ap_default_log_writer_init(apr_pool_t *p, server_rec *s,
         return fd;
     }
 }
-static void *ap_buffered_log_writer_init(apr_pool_t *p, server_rec *s, 
+static void *ap_buffered_log_writer_init(apr_pool_t *p, server_rec *s,
                                         const char* name)
 {
     buffered_log *b;
     b = apr_pcalloc(p, sizeof(buffered_log));
     b->handle = ap_default_log_writer_init(p, s, name);
-    
+
     if (b->handle) {
         *(buffered_log **)apr_array_push(all_buffered_logs) = b;
         return b;
@@ -1413,7 +1413,7 @@ static void *ap_buffered_log_writer_init(apr_pool_t *p, server_rec *s,
         return NULL;
 }
 static apr_status_t ap_buffered_log_writer(request_rec *r,
-                                           void *handle, 
+                                           void *handle,
                                            const char **strs,
                                            int *strl,
                                            int nelts,
@@ -1443,7 +1443,7 @@ static apr_status_t ap_buffered_log_writer(request_rec *r,
         }
         w = len;
         rv = apr_file_write(buf->handle, str, &w);
-        
+
     }
     else {
         for (i = 0, s = &buf->outbuf[buf->outcnt]; i < nelts; ++i) {
@@ -1461,7 +1461,7 @@ static apr_status_t ap_buffered_log_writer(request_rec *r,
 static int log_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     static APR_OPTIONAL_FN_TYPE(ap_register_log_handler) *log_pfn_register;
-    
+
     log_pfn_register = APR_RETRIEVE_OPTIONAL_FN(ap_register_log_handler);
 
     if (log_pfn_register) {
@@ -1504,12 +1504,12 @@ static void register_hooks(apr_pool_t *p)
     ap_hook_open_logs(init_config_log,NULL,NULL,APR_HOOK_MIDDLE);
     ap_hook_log_transaction(multi_log_transaction,NULL,NULL,APR_HOOK_MIDDLE);
 
-    /* Init log_hash before we register the optional function. It is 
+    /* Init log_hash before we register the optional function. It is
      * possible for the optional function, ap_register_log_handler,
      * to be called before any other mod_log_config hooks are called.
      * As a policy, we should init everything required by an optional function
      * before calling APR_REGISTER_OPTIONAL_FN.
-     */ 
+     */
     log_hash = apr_hash_make(p);
     APR_REGISTER_OPTIONAL_FN(ap_register_log_handler);
     APR_REGISTER_OPTIONAL_FN(ap_log_set_writer_init);
diff --git a/modules/loggers/mod_log_forensic.c b/modules/loggers/mod_log_forensic.c
index f8cabfa..008243f 100644
--- a/modules/loggers/mod_log_forensic.c
+++ b/modules/loggers/mod_log_forensic.c
@@ -115,7 +115,7 @@ static int log_init(apr_pool_t *pc, apr_pool_t *p, apr_pool_t *pt,
     return OK;
 }
 
-  
+
 /* e is the first _invalid_ location in q
    N.B. returns the terminating NUL.
  */
diff --git a/modules/loggers/mod_logio.c b/modules/loggers/mod_logio.c
index f4d639c..c05e4c9f 100644
--- a/modules/loggers/mod_logio.c
+++ b/modules/loggers/mod_logio.c
@@ -139,7 +139,7 @@ static int logio_pre_conn(conn_rec *c, void *csd) {
 static int logio_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     static APR_OPTIONAL_FN_TYPE(ap_register_log_handler) *log_pfn_register;
-    
+
     log_pfn_register = APR_RETRIEVE_OPTIONAL_FN(ap_register_log_handler);
 
     if (log_pfn_register) {
diff --git a/modules/mappers/mod_actions.c b/modules/mappers/mod_actions.c
index 6c934ee..643f650 100644
--- a/modules/mappers/mod_actions.c
+++ b/modules/mappers/mod_actions.c
@@ -23,9 +23,9 @@
  * Usage instructions:
  *
  * Action mime/type /cgi-bin/script
- * 
- * will activate /cgi-bin/script when a file of content type mime/type is 
- * requested. It sends the URL and file path of the requested document using 
+ *
+ * will activate /cgi-bin/script when a file of content type mime/type is
+ * requested. It sends the URL and file path of the requested document using
  * the standard CGI PATH_INFO and PATH_TRANSLATED environment variables.
  *
  * Script PUT /cgi-bin/script
@@ -89,7 +89,7 @@ static void *merge_action_dir_configs(apr_pool_t *p, void *basev, void *addv)
     return new;
 }
 
-static const char *add_action(cmd_parms *cmd, void *m_v, 
+static const char *add_action(cmd_parms *cmd, void *m_v,
                               const char *type, const char *script,
                               const char *option)
 {
@@ -110,8 +110,8 @@ static const char *add_action(cmd_parms *cmd, void *m_v,
 static const char *set_script(cmd_parms *cmd, void *m_v,
                               const char *method, const char *script)
 {
-    action_dir_config *m = (action_dir_config *)m_v;    
-    
+    action_dir_config *m = (action_dir_config *)m_v;
+
     /* ap_method_register recognizes already registered methods,
      * so don't bother to check its previous existence explicitely.
      */
diff --git a/modules/mappers/mod_alias.c b/modules/mappers/mod_alias.c
index 2ddbf95..efaf601 100644
--- a/modules/mappers/mod_alias.c
+++ b/modules/mappers/mod_alias.c
@@ -16,10 +16,10 @@
 
 /*
  * http_alias.c: Stuff for dealing with directory aliases
- * 
+ *
  * Original by Rob McCool, rewritten in succession by David Robinson
  * and rst.
- * 
+ *
  */
 
 #include "apr_strings.h"
@@ -168,7 +168,7 @@ static const char *add_alias_regex(cmd_parms *cmd, void *dummy, const char *f,
 
 static const char *add_redirect_internal(cmd_parms *cmd,
                                          alias_dir_conf *dirconf,
-                                         const char *arg1, const char *arg2, 
+                                         const char *arg1, const char *arg2,
                                          const char *arg3, int use_regex)
 {
     alias_entry *new;
@@ -258,14 +258,14 @@ static const command_rec alias_cmds[] =
                   "a regular expression and a filename"),
     AP_INIT_TAKE2("ScriptAliasMatch", add_alias_regex, "cgi-script", RSRC_CONF,
                   "a regular expression and a filename"),
-    AP_INIT_TAKE23("RedirectMatch", add_redirect_regex, 
+    AP_INIT_TAKE23("RedirectMatch", add_redirect_regex,
                    (void *) HTTP_MOVED_TEMPORARILY, OR_FILEINFO,
                    "an optional status, then a regular expression and "
                    "destination URL"),
     AP_INIT_TAKE2("RedirectTemp", add_redirect2,
                   (void *) HTTP_MOVED_TEMPORARILY, OR_FILEINFO,
                   "a document to be redirected, then the destination URL"),
-    AP_INIT_TAKE2("RedirectPermanent", add_redirect2, 
+    AP_INIT_TAKE2("RedirectPermanent", add_redirect2,
                   (void *) HTTP_MOVED_PERMANENTLY, OR_FILEINFO,
                   "a document to be redirected, then the destination URL"),
     {NULL}
@@ -331,15 +331,15 @@ static char *try_alias_list(request_rec *r, apr_array_header_t *aliases,
                         apr_uri_t uri;
                         apr_uri_parse(r->pool, found, &uri);
                         /* Do not escape the query string or fragment. */
-                        found = apr_uri_unparse(r->pool, &uri, 
+                        found = apr_uri_unparse(r->pool, &uri,
                                                 APR_URI_UNP_OMITQUERY);
                         found = ap_escape_uri(r->pool, found);
                         if (uri.query) {
-                            found = apr_pstrcat(r->pool, found, "?", 
+                            found = apr_pstrcat(r->pool, found, "?",
                                                 uri.query, NULL);
                         }
                         if (uri.fragment) {
-                            found = apr_pstrcat(r->pool, found, "#", 
+                            found = apr_pstrcat(r->pool, found, "#",
                                                 uri.fragment, NULL);
                         }
                     }
diff --git a/modules/mappers/mod_dir.c b/modules/mappers/mod_dir.c
index eca688f..bc870ab 100644
--- a/modules/mappers/mod_dir.c
+++ b/modules/mappers/mod_dir.c
@@ -105,7 +105,7 @@ static int fixup_dir(request_rec *r)
     if (r->finfo.filetype != APR_DIR) {
         return DECLINED;
     }
-    
+
     /* In case mod_mime wasn't present, and no handler was assigned. */
     if (!r->handler) {
         r->handler = DIR_MAGIC_TYPE;
@@ -120,7 +120,7 @@ static int fixup_dir(request_rec *r)
                                                &dir_module);
 
     /* Redirect requests that are not '/' terminated */
-    if (r->uri[0] == '\0' || r->uri[strlen(r->uri) - 1] != '/') 
+    if (r->uri[0] == '\0' || r->uri[strlen(r->uri) - 1] != '/')
     {
         char *ifile;
 
@@ -129,8 +129,8 @@ static int fixup_dir(request_rec *r)
         }
 
         /* Only redirect non-get requests if we have no note to warn
-         * that this browser cannot handle redirs on non-GET requests 
-         * (such as Microsoft's WebFolders). 
+         * that this browser cannot handle redirs on non-GET requests
+         * (such as Microsoft's WebFolders).
          */
         if ((r->method_number != M_GET)
                 && apr_table_get(r->subprocess_env, "redirect-carefully")) {
@@ -180,12 +180,12 @@ static int fixup_dir(request_rec *r)
 
         /* The sub request lookup is very liberal, and the core map_to_storage
          * handler will almost always result in HTTP_OK as /foo/index.html
-         * may be /foo with PATH_INFO="/index.html", or even / with 
+         * may be /foo with PATH_INFO="/index.html", or even / with
          * PATH_INFO="/foo/index.html". To get around this we insist that the
          * the index be a regular filetype.
          *
-         * Another reason is that the core handler also makes the assumption 
-         * that if r->finfo is still NULL by the time it gets called, the 
+         * Another reason is that the core handler also makes the assumption
+         * that if r->finfo is still NULL by the time it gets called, the
          * file does not exist.
          */
         if (rr->status == HTTP_OK
@@ -194,7 +194,7 @@ static int fixup_dir(request_rec *r)
             ap_internal_fast_redirect(rr, r);
             return OK;
         }
-            
+
         /* If the request returned a redirect, propagate it to the client */
 
         if (ap_is_HTTP_REDIRECT(rr->status)
diff --git a/modules/mappers/mod_imagemap.c b/modules/mappers/mod_imagemap.c
index 90ec579..59aca95 100644
--- a/modules/mappers/mod_imagemap.c
+++ b/modules/mappers/mod_imagemap.c
@@ -29,14 +29,14 @@
  *
  * Randy Terbush, randy@zyzzyva.com
  * port to Apache module format, "base_uri" and support for relative URLs
- * 
+ *
  * James H. Cloos, Jr., cloos@jhcloos.com
  * Added point datatype, using code in NCSA's version 1.8 imagemap.c
  * program, as distributed with version 1.4.1 of their server.
  * The point code is originally added by Craig Milo Rogers, Rogers@ISI.Edu
  *
  * Nathan Kurz, nate@tripod.com
- * Rewrite/reorganization.  New handling of default, base and relative URLs.  
+ * Rewrite/reorganization.  New handling of default, base and relative URLs.
  * New Configuration directives:
  *    ImapMenu {none, formatted, semiformatted, unformatted}
  *    ImapDefault {error, nocontent, referer, menu, URL}
@@ -415,7 +415,7 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
 
         if (directory && (slen = strlen(directory))) {
 
-            /* for each '..',  knock a directory off the end 
+            /* for each '..',  knock a directory off the end
                by ending the string right at the last slash.
                But only consider the directory portion: don't eat
                into the server name.  And only try if a directory
@@ -591,7 +591,7 @@ static int imap_handler_internal(request_rec *r)
     char *imap_default;
     char *imap_base;
 
-    ap_configfile_t *imap; 
+    ap_configfile_t *imap;
 
     icr = ap_get_module_config(r->per_dir_config, &imagemap_module);
 
diff --git a/modules/mappers/mod_negotiation.c b/modules/mappers/mod_negotiation.c
index 9676adf..86a50d7 100644
--- a/modules/mappers/mod_negotiation.c
+++ b/modules/mappers/mod_negotiation.c
@@ -381,7 +381,7 @@ static float atoq(const char *string)
         /* better only one division later, than dealing with fscking
          * IEEE format 0.1 factors ...
          */
-        int i = 0;        
+        int i = 0;
 
         if (*++string >= '0' && *string <= '9') {
             i += (*string - '0') * 100;
diff --git a/modules/mappers/mod_rewrite.c b/modules/mappers/mod_rewrite.c
index 0baad43..9e094b3 100644
--- a/modules/mappers/mod_rewrite.c
+++ b/modules/mappers/mod_rewrite.c
@@ -866,7 +866,7 @@ static int prefix_stat(const char *path, apr_pool_t *pool)
 
     if (rv == APR_SUCCESS) {
         apr_finfo_t sb;
-        
+
         if (apr_stat(&sb, statpath, APR_FINFO_MIN, pool) == APR_SUCCESS) {
             return 1;
         }
@@ -1296,7 +1296,7 @@ static char *lookup_map_dbmfile(request_rec *r, const char *file,
     apr_datum_t dbmval;
     char *value;
 
-    if (apr_dbm_open_ex(&dbmfp, dbmtype, file, APR_DBM_READONLY, APR_OS_DEFAULT, 
+    if (apr_dbm_open_ex(&dbmfp, dbmtype, file, APR_DBM_READONLY, APR_OS_DEFAULT,
                         r->pool) != APR_SUCCESS) {
         return NULL;
     }
@@ -1421,7 +1421,7 @@ static char *lookup_map_program(request_rec *r, apr_file_t *fpin,
             else if (i) {
                 curbuf->next = apr_palloc(r->pool, sizeof(*buflist));
                 curbuf = curbuf->next;
-                
+
             }
             curbuf->next = NULL;
 
@@ -1768,7 +1768,7 @@ static char *lookup_variable(char *var, rewrite_ctx *ctx)
                 return (char *)result;
             }
             break;
-            
+
         case  5:
             if (!strcmp(var, "HTTPS")) {
                 int flag = rewrite_is_https && rewrite_is_https(r->connection);
@@ -4532,7 +4532,7 @@ static int hook_fixup(request_rec *r)
                 cp = r->filename + skip;
 
                 if ((cp = ap_strchr(cp, '/')) != NULL && *(++cp)) {
-                    rewritelog((r, 2, dconf->directory, 
+                    rewritelog((r, 2, dconf->directory,
                                 "trying to replace prefix %s with %s",
                                 dconf->directory, dconf->baseurl));
 
diff --git a/modules/mappers/mod_so.c b/modules/mappers/mod_so.c
index e9b3163..7e23031 100644
--- a/modules/mappers/mod_so.c
+++ b/modules/mappers/mod_so.c
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-/* 
+/*
  * This module is used to load Apache modules at runtime. This means that the
  * server functionality can be extended without recompiling and even without
- * taking the server down at all. Only a HUP or AP_SIG_GRACEFUL signal 
+ * taking the server down at all. Only a HUP or AP_SIG_GRACEFUL signal
  * needs to be sent to the server to reload the dynamically loaded modules.
  *
  * To use, you'll first need to build your module as a shared library, then
@@ -40,7 +40,7 @@
  *
  * To use the shared module, move the .so file(s) into an appropriate
  * directory. You might like to create a directory called "modules" under you
- * server root for this (e.g. /usr/local/httpd/modules). 
+ * server root for this (e.g. /usr/local/httpd/modules).
  *
  * Then edit your conf/httpd.conf file, and add LoadModule lines. For
  * example
@@ -56,8 +56,8 @@
  * directive to get these log messages).
  *
  * If you edit the LoadModule directives while the server is live you can get
- * Apache to re-load the modules by sending it a HUP or AP_SIG_GRACEFUL 
- * signal as normal.  You can use this to dynamically change the capability 
+ * Apache to re-load the modules by sending it a HUP or AP_SIG_GRACEFUL
+ * signal as normal.  You can use this to dynamically change the capability
  * of your server without bringing it down.
  *
  * Because currently there is only limited builtin support in the Configure
@@ -114,7 +114,7 @@ static void *so_sconf_create(apr_pool_t *p, server_rec *s)
     so_server_conf *soc;
 
     soc = (so_server_conf *)apr_pcalloc(p, sizeof(so_server_conf));
-    soc->loaded_modules = apr_array_make(p, DYNAMIC_MODULE_LIMIT, 
+    soc->loaded_modules = apr_array_make(p, DYNAMIC_MODULE_LIMIT,
                                      sizeof(ap_module_symbol_t));
 
     return (void *)soc;
@@ -144,12 +144,12 @@ static apr_status_t unload_module(void *data)
     return APR_SUCCESS;
 }
 
-/* 
+/*
  * This is called for the directive LoadModule and actually loads
  * a shared object file into the address space of the server process.
  */
 
-static const char *load_module(cmd_parms *cmd, void *dummy, 
+static const char *load_module(cmd_parms *cmd, void *dummy,
                                const char *modname, const char *filename)
 {
     apr_dso_handle_t *modhandle;
@@ -169,16 +169,16 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
     *(ap_directive_t **)dummy = NULL;
 
     if (!szModuleFile) {
-        return apr_pstrcat(cmd->pool, "Invalid LoadModule path ", 
+        return apr_pstrcat(cmd->pool, "Invalid LoadModule path ",
                            filename, NULL);
     }
 
-    /* 
+    /*
      * check for already existing module
-     * If it already exists, we have nothing to do 
+     * If it already exists, we have nothing to do
      * Check both dynamically-loaded modules and statically-linked modules.
      */
-    sconf = (so_server_conf *)ap_get_module_config(cmd->server->module_config, 
+    sconf = (so_server_conf *)ap_get_module_config(cmd->server->module_config,
                                                 &so_module);
     modie = (ap_module_symbol_t *)sconf->loaded_modules->elts;
     for (i = 0; i < sconf->loaded_modules->nelts; i++) {
@@ -255,7 +255,7 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
         char my_error[256];
 
         return apr_pstrcat(cmd->pool, "Can't locate API module structure `",
-                          modname, "' in file ", szModuleFile, ": ", 
+                          modname, "' in file ", szModuleFile, ": ",
                           apr_dso_error(modhandle, my_error, sizeof(my_error)),
                           NULL);
     }
@@ -263,9 +263,9 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
     modp->dynamic_load_handle = (apr_dso_handle_t *)modhandle;
     modi->modp = modp;
 
-    /* 
+    /*
      * Make sure the found module structure is really a module structure
-     * 
+     *
      */
     if (modp->magic != MODULE_MAGIC_COOKIE) {
         return apr_pstrcat(cmd->pool, "API module structure `", modname,
@@ -273,7 +273,7 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
                           " perhaps this is not an Apache module DSO?", NULL);
     }
 
-    /* 
+    /*
      * Add this module to the Apache core structures
      */
     error = ap_add_loaded_module(modp, cmd->pool);
@@ -281,14 +281,14 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
         return error;
     }
 
-    /* 
+    /*
      * Register a cleanup in the config apr_pool_t (normally pconf). When
      * we do a restart (or shutdown) this cleanup will cause the
      * shared object to be unloaded.
      */
     apr_pool_cleanup_register(cmd->pool, modi, unload_module, apr_pool_cleanup_null);
 
-    /* 
+    /*
      * Finally we need to run the configuration process for the module
      */
     ap_single_module_configure(cmd->pool, cmd->server, modp);
@@ -296,7 +296,7 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
     return NULL;
 }
 
-/* 
+/*
  * This implements the LoadFile directive and loads an arbitrary
  * shared object file into the adress space of the server process.
  */
@@ -307,21 +307,21 @@ static const char *load_file(cmd_parms *cmd, void *dummy, const char *filename)
     const char *file;
 
     file = ap_server_root_relative(cmd->pool, filename);
-    
+
     if (!file) {
-        return apr_pstrcat(cmd->pool, "Invalid LoadFile path ", 
+        return apr_pstrcat(cmd->pool, "Invalid LoadFile path ",
                            filename, NULL);
     }
 
     if (apr_dso_load(&handle, file, cmd->pool) != APR_SUCCESS) {
         char my_error[256];
 
-        return apr_pstrcat(cmd->pool, "Cannot load ", filename, 
-                          " into server: ", 
+        return apr_pstrcat(cmd->pool, "Cannot load ", filename,
+                          " into server: ",
                           apr_dso_error(handle, my_error, sizeof(my_error)),
                           NULL);
     }
-    
+
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                  "loaded file %s", filename);
 
@@ -335,7 +335,7 @@ static module *ap_find_loaded_module_symbol(server_rec *s, const char *modname)
     ap_module_symbol_t *modie;
     int i;
 
-    sconf = (so_server_conf *)ap_get_module_config(s->module_config, 
+    sconf = (so_server_conf *)ap_get_module_config(s->module_config,
                                                    &so_module);
     modie = (ap_module_symbol_t *)sconf->loaded_modules->elts;
 
@@ -364,7 +364,7 @@ static void dump_loaded_modules(apr_pool_t *p, server_rec *s)
 
     apr_file_printf(out, "Loaded Modules:\n");
 
-    sconf = (so_server_conf *)ap_get_module_config(s->module_config, 
+    sconf = (so_server_conf *)ap_get_module_config(s->module_config,
                                                    &so_module);
     for (i = 0; ; i++) {
         modi = &ap_prelinked_module_symbols[i];
@@ -389,15 +389,15 @@ static void dump_loaded_modules(apr_pool_t *p, server_rec *s)
 
 static const char *load_file(cmd_parms *cmd, void *dummy, const char *filename)
 {
-    ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, cmd->pool, 
+    ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, cmd->pool,
                  "WARNING: LoadFile not supported on this platform");
     return NULL;
 }
 
-static const char *load_module(cmd_parms *cmd, void *dummy, 
+static const char *load_module(cmd_parms *cmd, void *dummy,
                                const char *modname, const char *filename)
 {
-    ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, cmd->pool, 
+    ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0, cmd->pool,
                  "WARNING: LoadModule not supported on this platform");
     return NULL;
 }
diff --git a/modules/mappers/mod_speling.c b/modules/mappers/mod_speling.c
index 82f15ba..4441d64 100644
--- a/modules/mappers/mod_speling.c
+++ b/modules/mappers/mod_speling.c
@@ -239,7 +239,7 @@ static int check_speling(request_rec *r)
     filoc = ap_rind(r->filename, '/');
     /*
      * Don't do anything if the request doesn't contain a slash, or
-     * requests "/" 
+     * requests "/"
      */
     if (filoc == -1 || strcmp(r->uri, "/") == 0) {
         return DECLINED;
@@ -376,8 +376,8 @@ static int check_speling(request_rec *r)
               sizeof(misspelled_file), sort_by_quality);
 
         /*
-         * Conditions for immediate redirection: 
-         *     a) the first candidate was not found by stripping the suffix 
+         * Conditions for immediate redirection:
+         *     a) the first candidate was not found by stripping the suffix
          * AND b) there exists only one candidate OR the best match is not
          *        ambiguous
          * then return a redirection right away.
@@ -396,7 +396,7 @@ static int check_speling(request_rec *r)
                           ap_construct_url(r->pool, nuri, r));
 
             ap_log_rerror(APLOG_MARK, APLOG_INFO, APR_SUCCESS,
-                          r, 
+                          r,
                           ref ? "Fixed spelling: %s to %s from %s"
                               : "Fixed spelling: %s to %s",
                           r->uri, nuri, ref);
@@ -478,7 +478,7 @@ static int check_speling(request_rec *r)
                 if (i > 0 && i < candidates->nelts - 1
                     && variant[i].quality != SP_VERYDIFFERENT
                     && variant[i + 1].quality == SP_VERYDIFFERENT) {
-                    *(const char **)apr_array_push(t) = 
+                    *(const char **)apr_array_push(t) =
                                    "</ul>\nFurthermore, the following related "
                                    "documents were found:\n<ul>\n";
                 }
@@ -501,7 +501,7 @@ static int check_speling(request_rec *r)
 
             apr_table_mergen(r->subprocess_env, "VARIANTS",
                             apr_array_pstrcat(p, v, ','));
-          
+
             apr_pool_destroy(sub_pool);
 
             ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
diff --git a/modules/mappers/mod_userdir.c b/modules/mappers/mod_userdir.c
index 495f340..0c84d43 100644
--- a/modules/mappers/mod_userdir.c
+++ b/modules/mappers/mod_userdir.c
@@ -73,8 +73,8 @@
 #endif
 
 
-/* 
- * The default directory in user's home dir 
+/*
+ * The default directory in user's home dir
  * In the default install, the module is disabled
  */
 #ifndef DEFAULT_USER_DIR
@@ -259,7 +259,7 @@ static int translate_userdir(request_rec *r)
                  * Crummy hack. Need to figure out whether we have been
                  * redirected to a URL or to a file on some drive. Since I
                  * know of no protocols that are a single letter, ignore
-                 * a : as the first or second character, and assume a file 
+                 * a : as the first or second character, and assume a file
                  * was specified
                  */
                 if (strchr(x + 2, ':'))
@@ -300,7 +300,7 @@ static int translate_userdir(request_rec *r)
          * anyway, in the hope that some handler might handle it. This can be
          * used, for example, to run a CGI script for the user.
          */
-        if (filename && (!*userdirs 
+        if (filename && (!*userdirs
                       || ((rv = apr_stat(&statbuf, filename, APR_FINFO_MIN,
                                          r->pool)) == APR_SUCCESS
                                              || rv == APR_INCOMPLETE))) {
@@ -342,7 +342,7 @@ static ap_unix_identity_t *get_suexec_id_doer(const request_rec *r)
     }
 
     ugid->userdir = 1;
-#endif 
+#endif
     return ugid;
 }
 #endif /* HAVE_UNIX_SUEXEC */
diff --git a/modules/mappers/mod_vhost_alias.c b/modules/mappers/mod_vhost_alias.c
index 5dd54f8..4d3e1c8 100644
--- a/modules/mappers/mod_vhost_alias.c
+++ b/modules/mappers/mod_vhost_alias.c
@@ -16,7 +16,7 @@
 
 /*
  * mod_vhost_alias.c: support for dynamically configured mass virtual hosting
- * 
+ *
  * Copyright (c) 1998-1999 Demon Internet Ltd.
  *
  * This software was submitted by Demon Internet to the Apache Software Foundation
@@ -123,7 +123,7 @@ static const char *vhost_alias_set(cmd_parms *cmd, void *dummy, const char *map)
     mva_mode_e mode, *pmode;
     const char **pmap;
     const char *p;
-  
+
     conf = (mva_sconf_t *) ap_get_module_config(cmd->server->module_config,
                                                 &vhost_alias_module);
     /* there ought to be a better way of doing this */
@@ -214,17 +214,17 @@ static const char *vhost_alias_set(cmd_parms *cmd, void *dummy, const char *map)
 
 static const command_rec mva_commands[] =
 {
-    AP_INIT_TAKE1("VirtualScriptAlias", vhost_alias_set, 
-                  &vhost_alias_set_cgi_root_name, RSRC_CONF, 
+    AP_INIT_TAKE1("VirtualScriptAlias", vhost_alias_set,
+                  &vhost_alias_set_cgi_root_name, RSRC_CONF,
                   "how to create a ScriptAlias based on the host"),
-    AP_INIT_TAKE1("VirtualDocumentRoot", vhost_alias_set, 
-                  &vhost_alias_set_doc_root_name, RSRC_CONF, 
+    AP_INIT_TAKE1("VirtualDocumentRoot", vhost_alias_set,
+                  &vhost_alias_set_doc_root_name, RSRC_CONF,
                   "how to create the DocumentRoot based on the host"),
-    AP_INIT_TAKE1("VirtualScriptAliasIP", vhost_alias_set, 
-                  &vhost_alias_set_cgi_root_ip, RSRC_CONF, 
+    AP_INIT_TAKE1("VirtualScriptAliasIP", vhost_alias_set,
+                  &vhost_alias_set_cgi_root_ip, RSRC_CONF,
                   "how to create a ScriptAlias based on the host"),
-    AP_INIT_TAKE1("VirtualDocumentRootIP", vhost_alias_set, 
-                  &vhost_alias_set_doc_root_ip, RSRC_CONF, 
+    AP_INIT_TAKE1("VirtualDocumentRootIP", vhost_alias_set,
+                  &vhost_alias_set_doc_root_ip, RSRC_CONF,
                   "how to create the DocumentRoot based on the host"),
     { NULL }
 };
@@ -276,7 +276,7 @@ static void vhost_alias_interpolate(request_rec *r, const char *name,
     dots[ndots] = p;
 
     r->filename = NULL;
-  
+
     dest = buf;
     last = '\0';
     while (*map) {
@@ -386,7 +386,7 @@ static int mva_translate(request_rec *r)
     const char *name, *map, *uri;
     mva_mode_e mode;
     const char *cgi;
-  
+
     conf = (mva_sconf_t *) ap_get_module_config(r->server->module_config,
                                               &vhost_alias_module);
     cgi = NULL;
@@ -409,7 +409,7 @@ static int mva_translate(request_rec *r)
     else {
         return DECLINED;
     }
-  
+
     if (mode == VHOST_ALIAS_NAME) {
         name = ap_get_server_name(r);
     }
@@ -421,7 +421,7 @@ static int mva_translate(request_rec *r)
     }
 
     /* ### There is an optimization available here to determine the
-     * absolute portion of the path from the server config phase, 
+     * absolute portion of the path from the server config phase,
      * through the first % segment, and note that portion of the path
      * canonical_path buffer.
      */
diff --git a/modules/metadata/mod_cern_meta.c b/modules/metadata/mod_cern_meta.c
index ebe5933..2afe210 100644
--- a/modules/metadata/mod_cern_meta.c
+++ b/modules/metadata/mod_cern_meta.c
@@ -18,13 +18,13 @@
  * mod_cern_meta.c
  * version 0.1.0
  * status beta
- * 
+ *
  * Andrew Wilson <Andrew.Wilson@cm.cf.ac.uk> 25.Jan.96
  *
  * *** IMPORTANT ***
  * This version of mod_cern_meta.c controls Meta File behaviour on a
  * per-directory basis.  Previous versions of the module defined behaviour
- * on a per-server basis.  The upshot is that you'll need to revisit your 
+ * on a per-server basis.  The upshot is that you'll need to revisit your
  * configuration files in order to make use of the new module.
  * ***
  *
@@ -38,30 +38,30 @@
  * who can exploit this module.  It should be noted that there are probably
  * more sensitive ways of managing the Expires: header specifically.
  *
- * The module obeys the following directives, which can appear 
+ * The module obeys the following directives, which can appear
  * in the server's .conf files and in .htaccess files.
  *
- *  MetaFiles <on|off> 
+ *  MetaFiles <on|off>
  *
- *    turns on|off meta file processing for any directory.  
+ *    turns on|off meta file processing for any directory.
  *    Default value is off
  *
  *        # turn on MetaFiles in this directory
  *        MetaFiles on
  *
  *  MetaDir <directory name>
- *      
+ *
  *    specifies the name of the directory in which Apache can find
  *    meta information files.  The directory is usually a 'hidden'
  *    subdirectory of the directory that contains the file being
  *    accessed.  eg:
  *
- *        # .meta files are in the *same* directory as the 
+ *        # .meta files are in the *same* directory as the
  *        # file being accessed
  *        MetaDir .
  *
  *    the default is to look in a '.web' subdirectory. This is the
- *    same as for CERN 3.+ webservers and behaviour is the same as 
+ *    same as for CERN 3.+ webservers and behaviour is the same as
  *    for the directive:
  *
  *        MetaDir .web
@@ -87,7 +87,7 @@
  *
  *   DOCUMENT_ROOT/somedir/.web/index.html.meta
  *
- * and will use its contents to generate additional MIME header 
+ * and will use its contents to generate additional MIME header
  * information.
  *
  * For more information on the CERN Meta file semantics see:
@@ -98,7 +98,7 @@
  * 29.Jan.96 pfopen/pfclose instead of fopen/fclose
  *           DECLINE when real file not found, we may be checking each
  *           of the index.html/index.shtml/index.htm variants and don't
- *           need to report missing ones as spurious errors. 
+ *           need to report missing ones as spurious errors.
  * 31.Jan.96 log_error reports about a malformed .meta file, rather
  *           than a script error.
  * 20.Jun.96 MetaFiles <on|off> default off, added, so that module
diff --git a/modules/metadata/mod_env.c b/modules/metadata/mod_env.c
index abaed01..1739868 100644
--- a/modules/metadata/mod_env.c
+++ b/modules/metadata/mod_env.c
@@ -55,14 +55,14 @@ static void *merge_env_dir_configs(apr_pool_t *p, void *basev, void *addv)
 
     int i;
 
-    /* 
+    /*
      * res->vars = copy_table( p, base->vars );
      * foreach $unsetenv ( @add->unsetenv )
      *     table_unset( res->vars, $unsetenv );
      * foreach $element ( @add->vars )
      *     table_set( res->vars, $element.key, $element.val );
      *
-     * add->unsetenv already removed the vars from add->vars, 
+     * add->unsetenv already removed the vars from add->vars,
      * if they preceeded the UnsetEnv directive.
      */
     res->vars = apr_table_copy(p, base->vars);
@@ -95,7 +95,7 @@ static const char *add_env_module_vars_passed(cmd_parms *cmd, void *sconf_,
     env_dir_config_rec *sconf = sconf_;
     apr_table_t *vars = sconf->vars;
     const char *env_var;
-    
+
     env_var = getenv(arg);
     if (env_var != NULL) {
         apr_table_setn(vars, arg, apr_pstrdup(cmd->pool, env_var));
@@ -112,7 +112,7 @@ static const char *add_env_module_vars_set(cmd_parms *cmd, void *sconf_,
                                            const char *name, const char *value)
 {
     env_dir_config_rec *sconf = sconf_;
-    
+
     /* name is mandatory, value is optional.  no value means
      * set the variable to an empty string
      */
diff --git a/modules/metadata/mod_expires.c b/modules/metadata/mod_expires.c
index 1603297..f2e91fc 100644
--- a/modules/metadata/mod_expires.c
+++ b/modules/metadata/mod_expires.c
@@ -18,13 +18,13 @@
  * mod_expires.c
  * version 0.0.11
  * status beta
- * 
+ *
  * Andrew Wilson <Andrew.Wilson@cm.cf.ac.uk> 26.Jan.96
  *
  * This module allows you to control the form of the Expires: header
  * that Apache issues for each access.  Directives can appear in
  * configuration files or in .htaccess files so expiry semantics can
- * be defined on a per-directory basis.  
+ * be defined on a per-directory basis.
  *
  * DIRECTIVE SYNTAX
  *
@@ -56,7 +56,7 @@
  *
  * Another example, our html pages can change all the time, the gifs
  * tend not to change often:
- * 
+ *
  *     # pages are hot (1 week), images are cold (1 month)
  *     ExpiresByType text/html A604800
  *     ExpiresByType image/gif A2592000
@@ -85,7 +85,7 @@
  *     ExpiresByType type/encoding "<base> [plus] {<num> <type>}*"
  *
  * where <base> is one of:
- *      access  
+ *      access
  *      now             equivalent to 'access'
  *      modification
  *
@@ -134,8 +134,8 @@
  *              rely on presence of HTTP_TIME_FORMAT in Apache 1.1+.
  * 21.Feb.96    This version (0.0.9) reverses assumptions made in 0.0.8
  *              about star/star handlers.  Reverting to 0.0.7 behaviour.
- * 08.Jun.96    allows ExpiresDefault to be used with responses that use 
- *              the DefaultType by not DECLINING, but instead skipping 
+ * 08.Jun.96    allows ExpiresDefault to be used with responses that use
+ *              the DefaultType by not DECLINING, but instead skipping
  *              the table_get check and then looking for an ExpiresDefault.
  *              [Rob Hartill]
  * 04.Nov.96    'const' definitions added.
@@ -324,7 +324,7 @@ static const char *set_expiresbytype(cmd_parms *cmd, void *in_dir_config,
     if ((strlen(++check) == 1) && (*check == '*')) {
         dir_config->wildcards = 1;
     }
-    
+
     if ((response = check_code(cmd->pool, code, &real_code)) == NULL) {
         apr_table_setn(dir_config->expiresbytype, mime, real_code);
         return NULL;
@@ -399,7 +399,7 @@ static int set_expiration_fields(request_rec *r, const char *code,
 
     switch (code[0]) {
     case 'M':
-        if (r->finfo.filetype == 0) { 
+        if (r->finfo.filetype == 0) {
             /* file doesn't exist on disk, so we can't do anything based on
              * modification time.  Note that this does _not_ log an error.
              */
@@ -410,7 +410,7 @@ static int set_expiration_fields(request_rec *r, const char *code,
         additional = apr_time_from_sec(additional_sec);
         break;
     case 'A':
-        /* there's been some discussion and it's possible that 
+        /* there's been some discussion and it's possible that
          * 'access time' will be stored in request structure
          */
         base = r->request_time;
@@ -418,7 +418,7 @@ static int set_expiration_fields(request_rec *r, const char *code,
         additional = apr_time_from_sec(additional_sec);
         break;
     default:
-        /* expecting the add_* routines to be case-hardened this 
+        /* expecting the add_* routines to be case-hardened this
          * is just a reminder that module is beta
          */
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
@@ -472,7 +472,7 @@ static apr_status_t expires_filter(ap_filter_t *f,
          * this module.  First, check to see if there is an applicable
          * ExpiresByType directive.
          */
-        expiry = apr_table_get(conf->expiresbytype, 
+        expiry = apr_table_get(conf->expiresbytype,
                                ap_field_noparam(r->pool, r->content_type));
         if (expiry == NULL) {
             int usedefault = 1;
@@ -530,7 +530,7 @@ static void expires_insert_filter(request_rec *r)
     conf = (expires_dir_config *) ap_get_module_config(r->per_dir_config,
                                                        &expires_module);
 
-    /* Check to see if the filter is enabled and if there are any applicable 
+    /* Check to see if the filter is enabled and if there are any applicable
      * config directives for this directory scope
      */
     if (conf->active != ACTIVE_ON ||
diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index cf798d8..ac8c515 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -43,8 +43,8 @@
  *
  * When the request is processed, the header directives are processed in
  * this order: firstly, the main server, then the virtual server handling
- * this request (if any), then any <Directory> sections (working downwards 
- * from the root dir), then an <Location> sections (working down from 
+ * this request (if any), then any <Directory> sections (working downwards
+ * from the root dir), then an <Location> sections (working down from
  * shortest URL component), the any <File> sections. This order is
  * important if any 'set' or 'unset' actions are used. For example,
  * the following two directives have different effect if applied in
@@ -100,7 +100,7 @@ static char hdr_out = '1';  /* Header onsuccess */
 static char hdr_err = '2';  /* Header always */
 
 /*
- * There is an array of struct format_tag per Header/RequestHeader 
+ * There is an array of struct format_tag per Header/RequestHeader
  * config directive
  */
 typedef struct {
@@ -151,8 +151,8 @@ static const char *constant_item(request_rec *r, char *stuff)
 }
 static const char *header_request_duration(request_rec *r, char *a)
 {
-    return apr_psprintf(r->pool, "D=%" APR_TIME_T_FMT, 
-                        (apr_time_now() - r->request_time)); 
+    return apr_psprintf(r->pool, "D=%" APR_TIME_T_FMT,
+                        (apr_time_now() - r->request_time));
 }
 static const char *header_request_time(request_rec *r, char *a)
 {
@@ -165,9 +165,9 @@ static const char *unwrap_header(apr_pool_t *p, const char *hdr)
 {
     if (ap_strchr_c(hdr, APR_ASCII_LF) || ap_strchr_c(hdr, APR_ASCII_CR)) {
         char *ptr;
-        
+
         hdr = ptr = apr_pstrdup(p, hdr);
-        
+
         do {
             if (*ptr == APR_ASCII_LF || *ptr == APR_ASCII_CR)
                 *ptr = APR_ASCII_BLANK;
@@ -189,7 +189,7 @@ static const char *header_request_env_var(request_rec *r, char *a)
 static const char *header_request_ssl_var(request_rec *r, char *name)
 {
     if (header_ssl_lookup) {
-        const char *val = header_ssl_lookup(r->pool, r->server, 
+        const char *val = header_ssl_lookup(r->pool, r->server,
                                             r->connection, r, name);
         if (val && val[0])
             return unwrap_header(r->pool, val);
@@ -231,7 +231,7 @@ static void *merge_headers_config(apr_pool_t *p, void *basev, void *overridesv)
 
     return newconf;
 }
- 
+
 static char *parse_misc_string(apr_pool_t *p, format_tag *tag, const char **sa)
 {
     const char *s;
@@ -270,7 +270,7 @@ static char *parse_misc_string(apr_pool_t *p, format_tag *tag, const char **sa)
                 *d++ = '\n';
                 s++;
                 break;
-            case 't':   
+            case 't':
                 *d++ = '\t';
                 s++;
                 break;
@@ -293,7 +293,7 @@ static char *parse_misc_string(apr_pool_t *p, format_tag *tag, const char **sa)
 }
 
 static char *parse_format_tag(apr_pool_t *p, format_tag *tag, const char **sa)
-{ 
+{
     const char *s = *sa;
     const char * (*tag_handler)(request_rec *,char *);
 
@@ -333,13 +333,13 @@ static char *parse_format_tag(apr_pool_t *p, format_tag *tag, const char **sa)
 }
 
 /*
- * A format string consists of white space, text and optional format 
- * tags in any order. E.g., 
+ * A format string consists of white space, text and optional format
+ * tags in any order. E.g.,
  *
  * Header add MyHeader "Free form text %D %t more text"
  *
  * Decompose the format string into its tags. Each tag (struct format_tag)
- * contains a pointer to the function used to format the tag. Then save each 
+ * contains a pointer to the function used to format the tag. Then save each
  * tag in the tag array anchored in the header_entry.
  */
 static char *parse_format_string(apr_pool_t *p, header_entry *hdr, const char *s)
@@ -446,7 +446,7 @@ static APR_INLINE const char *header_inout_cmd(cmd_parms *cmd,
             condition_var = envclause + 4;
         }
     }
-    
+
     if ((colon = ap_strchr_c(hdr, ':'))) {
         hdr = apr_pstrmemdup(cmd->pool, hdr, colon-hdr);
     }
@@ -489,23 +489,23 @@ static const char *header_cmd(cmd_parms *cmd, void *indirconf,
 }
 
 /*
- * Process the tags in the format string. Tags may be format specifiers 
+ * Process the tags in the format string. Tags may be format specifiers
  * (%D, %t, etc.), whitespace or text strings. For each tag, run the handler
  * (formatter) specific to the tag. Handlers return text strings.
- * Concatenate the return from each handler into one string that is 
+ * Concatenate the return from each handler into one string that is
  * returned from this call.
  */
-static char* process_tags(header_entry *hdr, request_rec *r) 
+static char* process_tags(header_entry *hdr, request_rec *r)
 {
     int i;
     const char *s;
     char *str = NULL;
 
     format_tag *tag = (format_tag*) hdr->ta->elts;
- 
+
     for (i = 0; i < hdr->ta->nelts; i++) {
         s = tag[i].func(r, tag[i].arg);
-        if (str == NULL) 
+        if (str == NULL)
             str = apr_pstrdup(r->pool, s);
         else
             str = apr_pstrcat(r->pool, str, s, NULL);
@@ -515,7 +515,7 @@ static char* process_tags(header_entry *hdr, request_rec *r)
 
 static int echo_header(echo_do *v, const char *key, const char *val)
 {
-    /* If the input header (key) matches the regex, echo it intact to 
+    /* If the input header (key) matches the regex, echo it intact to
      * r->headers_out.
      */
     if (!ap_regexec(v->hdr->regex, key, 0, NULL, 0)) {
@@ -572,7 +572,7 @@ static void do_headers_fixup(request_rec *r, apr_table_t *headers,
             echo_do v;
             v.r = r;
             v.hdr = hdr;
-            apr_table_do((int (*) (void *, const char *, const char *)) 
+            apr_table_do((int (*) (void *, const char *, const char *))
                          echo_header, (void *) &v, r->headers_in, NULL);
             break;
         }
diff --git a/modules/metadata/mod_mime_magic.c b/modules/metadata/mod_mime_magic.c
index 6440c4d..faaea0e 100644
--- a/modules/metadata/mod_mime_magic.c
+++ b/modules/metadata/mod_mime_magic.c
@@ -229,7 +229,7 @@ static int mget(request_rec *, union VALUETYPE *, unsigned char *,
 static int mcheck(request_rec *, union VALUETYPE *, struct magic *);
 static void mprint(request_rec *, union VALUETYPE *, struct magic *);
 
-static int uncompress(request_rec *, int, 
+static int uncompress(request_rec *, int,
                       unsigned char **, apr_size_t);
 static long from_oct(int, char *);
 static int fsmagic(request_rec *r, const char *fn);
@@ -885,7 +885,7 @@ static int tryit(request_rec *r, unsigned char *buf, apr_size_t nb,
     /*
      * Try compression stuff
      */
-        if (checkzmagic == 1) {  
+        if (checkzmagic == 1) {
                         if (zmagic(r, buf, nb) == 1)
                         return OK;
         }
@@ -933,8 +933,8 @@ static int apprentice(server_rec *s, apr_pool_t *p)
         ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s,
                      MODNAME ": Invalid magic file path %s", conf->magicfile);
         return -1;
-    }        
-    if ((result = apr_file_open(&f, fname, APR_READ | APR_BUFFERED, 
+    }
+    if ((result = apr_file_open(&f, fname, APR_READ | APR_BUFFERED,
                                 APR_OS_DEFAULT, p) != APR_SUCCESS)) {
         ap_log_error(APLOG_MARK, APLOG_ERR, result, s,
                      MODNAME ": can't read magic file %s", fname);
@@ -957,7 +957,7 @@ static int apprentice(server_rec *s, apr_pool_t *p)
             *last = '\0';
             --last;
         }
-        
+
         /* skip leading whitespace */
         ws_offset = 0;
         while (line[ws_offset] && apr_isspace(line[ws_offset])) {
@@ -2127,16 +2127,16 @@ static int create_uncompress_child(struct uncompress_parms *parm, apr_pool_t *cn
     apr_procattr_t *procattr;
     apr_proc_t *procnew;
 
-    /* XXX missing 1.3 logic: 
+    /* XXX missing 1.3 logic:
      *
      * what happens when !compr[parm->method].silent?
      * Should we create the err pipe, read it, and copy to the log?
      */
-        
+
     env = (const char *const *)ap_create_environment(child_context, r->subprocess_env);
 
     if ((apr_procattr_create(&procattr, child_context) != APR_SUCCESS) ||
-        (apr_procattr_io_set(procattr, APR_FULL_BLOCK, 
+        (apr_procattr_io_set(procattr, APR_FULL_BLOCK,
                            APR_FULL_BLOCK, APR_NO_PIPE)   != APR_SUCCESS) ||
         (apr_procattr_dir_set(procattr, r->filename)        != APR_SUCCESS) ||
         (apr_procattr_cmdtype_set(procattr, APR_PROGRAM)    != APR_SUCCESS)) {
@@ -2169,7 +2169,7 @@ static int create_uncompress_child(struct uncompress_parms *parm, apr_pool_t *cn
     return (rc);
 }
 
-static int uncompress(request_rec *r, int method, 
+static int uncompress(request_rec *r, int method,
                       unsigned char **newch, apr_size_t n)
 {
     struct uncompress_parms parm;
@@ -2341,7 +2341,7 @@ static int revision_suffix(request_rec *r)
                 apr_pstrdup(r->pool, sub->content_encoding);
         if (sub->content_languages) {
             int n;
-            r->content_languages = apr_array_copy(r->pool, 
+            r->content_languages = apr_array_copy(r->pool,
                                                   sub->content_languages);
             for (n = 0; n < r->content_languages->nelts; ++n) {
                 char **lang = ((char **)r->content_languages->elts) + n;
diff --git a/modules/metadata/mod_setenvif.c b/modules/metadata/mod_setenvif.c
index bd0ccfb..c28fc1c 100644
--- a/modules/metadata/mod_setenvif.c
+++ b/modules/metadata/mod_setenvif.c
@@ -18,7 +18,7 @@
  * mod_setenvif.c
  * Set environment variables based on matching request headers or
  * attributes against regex strings
- * 
+ *
  * Paul Sutton <paul@ukweb.com> 27 Oct 1996
  * Based on mod_browser by Alexei Kosut <akosut@organic.com>
  */
@@ -34,12 +34,12 @@
  *
  * where name is either a HTTP request header name, or one of the
  * special values (see below). 'name' may be a regex when it is used
- * to specify an HTTP request header name. The 'value' of the header 
+ * to specify an HTTP request header name. The 'value' of the header
  & (or the value of the special value from below) are compared against
  * the regex argument. If this is a simple string, a simple sub-string
  * match is performed. Otherwise, a request expression match is
  * done. If the value matches the string or regular expression, the
- * environment variables listed as var ... are set. Each var can 
+ * environment variables listed as var ... are set. Each var can
  * be in one of three formats: var, which sets the named variable
  * (the value value "1"); var=value, which sets the variable to
  * the given value; or !var, which unsets the variable is it has
@@ -169,7 +169,7 @@ static void *merge_setenvif_config(apr_pool_t *p, void *basev, void *overridesv)
 #define ICASE_MAGIC	((void *)(&setenvif_module))
 #define SEI_MAGIC_HEIRLOOM "setenvif-phase-flag"
 
-static int is_header_regex(apr_pool_t *p, const char* name) 
+static int is_header_regex(apr_pool_t *p, const char* name)
 {
     /* If a Header name contains characters other than:
      *    -,_,[A-Z\, [a-z] and [0-9].
@@ -570,7 +570,7 @@ static int match_headers(request_rec *r)
                     elts = (const apr_table_entry_t *) arr->elts;
                     val = NULL;
                     for (j = 0; j < arr->nelts; ++j) {
-                        if (!ap_regexec(b->pnamereg, elts[j].key, 0, NULL, 0)) { 
+                        if (!ap_regexec(b->pnamereg, elts[j].key, 0, NULL, 0)) {
                             val = elts[j].val;
                         }
                     }
diff --git a/modules/metadata/mod_unique_id.c b/modules/metadata/mod_unique_id.c
index ebb63eb..1185f19 100644
--- a/modules/metadata/mod_unique_id.c
+++ b/modules/metadata/mod_unique_id.c
@@ -47,10 +47,10 @@ typedef struct {
  * cannot guarantee the thread_id will be an integer.
  *
  * This code looks like it won't give a unique ID with the new thread logic.
- * It will.  The reason is, we don't increment the counter in a thread_safe 
+ * It will.  The reason is, we don't increment the counter in a thread_safe
  * manner.  Because the thread_index is also in the unique ID now, this does
  * not matter.  In order for the id to not be unique, the same thread would
- * have to get the same counter twice in the same second. 
+ * have to get the same counter twice in the same second.
  */
 
 /* Comments:
@@ -123,7 +123,7 @@ static unique_id_rec cur_unique_id;
 /*
  * Number of elements in the structure unique_id_rec.
  */
-#define UNIQUE_ID_REC_MAX 5 
+#define UNIQUE_ID_REC_MAX 5
 
 static unsigned short unique_id_rec_offset[UNIQUE_ID_REC_MAX],
                       unique_id_rec_size[UNIQUE_ID_REC_MAX],
@@ -199,12 +199,12 @@ static int unique_id_global_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *pt
      * If the server is pummelled with restart requests we could possibly end
      * up in a situation where we're starting again during the same second
      * that has been used in previous identifiers.  Avoid that situation.
-     * 
+     *
      * In truth, for this to actually happen not only would it have to restart
      * in the same second, but it would have to somehow get the same pids as
      * one of the other servers that was running in that second. Which would
      * mean a 64k wraparound on pids ... not very likely at all.
-     * 
+     *
      * But protecting against it is relatively cheap.  We just sleep into the
      * next second.
      */
@@ -222,7 +222,7 @@ static void unique_id_child_init(apr_pool_t *p, server_rec *s)
      * physical machine there are multiple servers (i.e. using Listen). But
      * it's guaranteed that none of them will share the same pids between
      * children.
-     * 
+     *
      * XXX: for multithread this needs to use a pid/tid combo and probably
      * needs to be expanded to 32 bits
      */
@@ -299,7 +299,7 @@ static int gen_unique_id(request_rec *r)
         apr_table_setn(r->subprocess_env, "UNIQUE_ID", e);
         return DECLINED;
     }
-    
+
     new_unique_id.in_addr = cur_unique_id.in_addr;
     new_unique_id.pid = cur_unique_id.pid;
     new_unique_id.counter = cur_unique_id.counter;
@@ -323,7 +323,7 @@ static int gen_unique_id(request_rec *r)
      */
     x[k++] = '\0';
     x[k++] = '\0';
-    
+
     /* alloc str and do the uuencoding */
     str = (char *)apr_palloc(r->pool, unique_id_rec_size_uu + 1);
     k = 0;
@@ -353,7 +353,7 @@ static void register_hooks(apr_pool_t *p)
 {
     ap_hook_post_config(unique_id_global_init, NULL, NULL, APR_HOOK_MIDDLE);
     ap_hook_child_init(unique_id_child_init, NULL, NULL, APR_HOOK_MIDDLE);
-    ap_hook_post_read_request(gen_unique_id, NULL, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_post_read_request(gen_unique_id, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 module AP_MODULE_DECLARE_DATA unique_id_module = {
diff --git a/modules/metadata/mod_usertrack.c b/modules/metadata/mod_usertrack.c
index 21840f3..a7dd1a2 100644
--- a/modules/metadata/mod_usertrack.c
+++ b/modules/metadata/mod_usertrack.c
@@ -106,7 +106,7 @@ static void make_cookie(request_rec *r)
     dcfg = ap_get_module_config(r->per_dir_config, &usertrack_module);
 
     /* XXX: hmm, this should really tie in with mod_unique_id */
-    apr_snprintf(cookiebuf, sizeof(cookiebuf), "%s.%" APR_TIME_T_FMT, rname, 
+    apr_snprintf(cookiebuf, sizeof(cookiebuf), "%s.%" APR_TIME_T_FMT, rname,
                  apr_time_now());
 
     if (cls->expires) {
@@ -117,7 +117,7 @@ static void make_cookie(request_rec *r)
 
         if ((dcfg->style == CT_UNSET) || (dcfg->style == CT_NETSCAPE)) {
             apr_time_exp_t tms;
-            apr_time_exp_gmt(&tms, r->request_time 
+            apr_time_exp_gmt(&tms, r->request_time
                                  + apr_time_from_sec(cls->expires));
             new_cookie = apr_psprintf(r->pool,
                                        "%s; expires=%s, "
@@ -295,7 +295,7 @@ static const char *set_cookie_exp(cmd_parms *parms, void *dummy,
     }
 
     /*
-     * The harder case - stolen from mod_expires 
+     * The harder case - stolen from mod_expires
      *
      * CookieExpires "[plus] {<num> <type>}*"
      */
diff --git a/modules/metadata/mod_version.c b/modules/metadata/mod_version.c
index 47b938a..203c12f 100644
--- a/modules/metadata/mod_version.c
+++ b/modules/metadata/mod_version.c
@@ -17,7 +17,7 @@
 /*
  * mod_version.c
  * Allow conditional configuration depending on the httpd version
- * 
+ *
  * Andr Malo (nd/perlig.de), January 2004
  *
  * Some stuff coded here is heavily based on the core <IfModule>
@@ -163,7 +163,7 @@ static int match_version(apr_pool_t *pool, char *version_string,
     rc = !ap_regexec(compiled, to_match, 0, NULL, 0);
 
     ap_pregfree(pool, compiled);
-    return rc;    
+    return rc;
 }
 
 /*
diff --git a/modules/proxy/ajp_header.c b/modules/proxy/ajp_header.c
index a72183a..002b5b3 100644
--- a/modules/proxy/ajp_header.c
+++ b/modules/proxy/ajp_header.c
@@ -18,20 +18,20 @@
 #include "ajp.h"
 
 static const char *response_trans_headers[] = {
-    "Content-Type", 
-    "Content-Language", 
-    "Content-Length", 
-    "Date", 
-    "Last-Modified", 
-    "Location", 
-    "Set-Cookie", 
-    "Set-Cookie2", 
-    "Servlet-Engine", 
-    "Status", 
+    "Content-Type",
+    "Content-Language",
+    "Content-Length",
+    "Date",
+    "Last-Modified",
+    "Location",
+    "Set-Cookie",
+    "Set-Cookie2",
+    "Servlet-Engine",
+    "Status",
     "WWW-Authenticate"
 };
 
-static const char *long_res_header_for_sc(int sc) 
+static const char *long_res_header_for_sc(int sc)
 {
     const char *rc = NULL;
     sc = sc & 0X00FF;
@@ -56,7 +56,7 @@ static int sc_for_req_header(const char *header_name)
      */
     if (len < 4 || len > 15)
         return UNKNOWN_METHOD;
-    
+
     while (*p)
         header[i++] = apr_toupper(*p++);
     header[i] = '\0';
@@ -158,7 +158,7 @@ static const unsigned char sc_for_req_method_table[] = {
     SC_M_MKWORKSPACE,
     SC_M_MKACTIVITY,
     SC_M_BASELINE_CONTROL,
-    SC_M_MERGE,           
+    SC_M_MERGE,
     0                       /* M_INVALID */
 };
 
@@ -218,7 +218,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                          "Into ajp_marshal_into_msgb");
 
-    if ((method = sc_for_req_method_by_id(r->method_number)) == UNKNOWN_METHOD) { 
+    if ((method = sc_for_req_method_by_id(r->method_number)) == UNKNOWN_METHOD) {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                "ajp_marshal_into_msgb - No such method %s",
                r->method);
@@ -274,7 +274,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
                 return AJP_EOVERFLOW;
             }
         }
-        
+
         if (ajp_msg_append_string(msg, elts[i].val)) {
             ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                    "ajp_marshal_into_msgb: "
@@ -297,7 +297,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
         }
     }
  */
-        
+
     if (r->user) {
         if (ajp_msg_append_uint8(msg, SC_A_REMOTE_USER) ||
             ajp_msg_append_string(msg, r->user)) {
@@ -337,7 +337,7 @@ static apr_status_t ajp_marshal_into_msgb(ajp_msg_t *msg,
     }
 /* XXX: Is the subprocess_env a right place?
  * <Location /examples>
- *   ProxyPass ajp://remote:8009/servlets-examples 
+ *   ProxyPass ajp://remote:8009/servlets-examples
  *   SetEnv SSL_SESSION_ID CUSTOM_SSL_SESSION_ID
  * </Location>
  */
@@ -436,10 +436,10 @@ AJPV13_RESPONSE/AJPV14_RESPONSE:=
     *body_chunk
     terminator      boolean <! -- recycle connection or not  -->
 
-req_header_name := 
+req_header_name :=
     sc_req_header_name | (string)
 
-res_header_name := 
+res_header_name :=
     sc_res_header_name | (string)
 
 header_value :=
@@ -504,7 +504,7 @@ static apr_status_t ajp_unmarshal_response(ajp_msg_t *msg,
         if (rc != APR_SUCCESS) {
             return rc;
         }
-                
+
         if ((name & 0XFF00) == 0XA000) {
             ajp_msg_peek_uint16(msg, &name);
             stringname = long_res_header_for_sc(name);
@@ -555,7 +555,7 @@ static apr_status_t ajp_unmarshal_response(ajp_msg_t *msg,
         ap_xlate_proto_from_ascii(value, strlen(value));
 #endif
         ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
-               "ajp_unmarshal_response: Header[%d] [%s] = [%s]", 
+               "ajp_unmarshal_response: Header[%d] [%s] = [%s]",
                        i, stringname, value);
 
         apr_table_add(r->headers_out, stringname, value);
@@ -589,7 +589,7 @@ apr_status_t ajp_send_header(apr_socket_t *sock,
         return rc;
     }
 
-    rc = ajp_marshal_into_msgb(msg, r, uri);    
+    rc = ajp_marshal_into_msgb(msg, r, uri);
     if (rc != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                "ajp_send_header: ajp_marshal_into_msgb failed");
@@ -615,7 +615,7 @@ apr_status_t ajp_read_header(apr_socket_t *sock,
 {
     apr_byte_t result;
     apr_status_t rc;
-   
+
     if (*msg) {
         rc = ajp_msg_reuse(*msg);
         if (rc != APR_SUCCESS) {
diff --git a/modules/proxy/ajp_link.c b/modules/proxy/ajp_link.c
index 8a73506..e5cd2c1 100644
--- a/modules/proxy/ajp_link.c
+++ b/modules/proxy/ajp_link.c
@@ -28,9 +28,9 @@ apr_status_t ajp_ilink_send(apr_socket_t *sock, ajp_msg_t *msg)
                       "ajp_ilink_send(): NULL socket provided");
         return AJP_EINVAL;
     }
-    
+
     ajp_msg_end(msg);
-    
+
     length = msg->len;
     buf    = (char *)msg->buf;
 
@@ -68,7 +68,7 @@ static apr_status_t ilink_read(apr_socket_t *sock, apr_byte_t *buf,
             continue;
         else if (status != APR_SUCCESS)
             return status;          /* any error. */
-            
+
         rdlen += length;
         length = len - rdlen;
     }
@@ -89,15 +89,15 @@ apr_status_t ajp_ilink_receive(apr_socket_t *sock, ajp_msg_t *msg)
     }
 
     hlen = msg->header_len;
-    
+
     status = ilink_read(sock, msg->buf, hlen);
-    
+
     if (status != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, status, NULL,
                      "ajp_ilink_receive() can't receive header");
         return AJP_ENO_HEADER;
     }
-    
+
     status = ajp_msg_check_header(msg, &blen);
 
     if (status != APR_SUCCESS) {
diff --git a/modules/proxy/ajp_msg.c b/modules/proxy/ajp_msg.c
index 21bda25..53988bc 100644
--- a/modules/proxy/ajp_msg.c
+++ b/modules/proxy/ajp_msg.c
@@ -42,7 +42,7 @@ char * ajp_msg_dump(apr_pool_t *pool, ajp_msg_t *msg, char *err)
         len = 1024;
     rv = apr_palloc(pool, bl);
     apr_snprintf(rv, bl,
-                 "ajp_msg_dump(): %s pos=%" APR_SIZE_T_FMT 
+                 "ajp_msg_dump(): %s pos=%" APR_SIZE_T_FMT
                  " len=%" APR_SIZE_T_FMT " max=%d\n",
                  err, msg->pos, msg->len, AJP_MSG_BUFFER_SZ);
     bl -= strlen(rv);
@@ -79,7 +79,7 @@ char * ajp_msg_dump(apr_pool_t *pool, ajp_msg_t *msg, char *err)
         p = rv + strlen(rv);
 
     }
-    
+
     return rv;
 }
 
@@ -120,7 +120,7 @@ apr_status_t ajp_msg_check_header(ajp_msg_t *msg, apr_size_t *len)
     msg->len = msglen + AJP_HEADER_LEN;
     msg->pos = AJP_HEADER_LEN;
     *len     = msglen;
-    
+
     return APR_SUCCESS;
 }
 
@@ -134,7 +134,7 @@ apr_status_t ajp_msg_reset(ajp_msg_t *msg)
 {
     msg->len = AJP_HEADER_LEN;
     msg->pos = AJP_HEADER_LEN;
-    
+
     return APR_SUCCESS;
 }
 
@@ -177,14 +177,14 @@ apr_status_t ajp_msg_end(ajp_msg_t *msg)
 
     msg->buf[2] = (apr_byte_t)((len >> 8) & 0xFF);
     msg->buf[3] = (apr_byte_t)(len & 0xFF);
-    
+
     return APR_SUCCESS;
 }
 
 static APR_INLINE int ajp_log_overflow(ajp_msg_t *msg, const char *context)
 {
     ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
-                 "%s(): BufferOverflowException %" APR_SIZE_T_FMT 
+                 "%s(): BufferOverflowException %" APR_SIZE_T_FMT
                  " %" APR_SIZE_T_FMT,
                  context, msg->pos, msg->len);
     return AJP_EOVERFLOW;
@@ -260,8 +260,8 @@ apr_status_t ajp_msg_append_uint8(ajp_msg_t *msg, apr_byte_t value)
 }
 
 /**
- *  Add a String in AJP message, and transform the String in ASCII 
- *  if convert is set and we're on an EBCDIC machine    
+ *  Add a String in AJP message, and transform the String in ASCII
+ *  if convert is set and we're on an EBCDIC machine
  *
  * @param msg       AJP Message to get value from
  * @param value     Pointer to String
@@ -341,7 +341,7 @@ apr_status_t ajp_msg_get_uint32(ajp_msg_t *msg, apr_uint32_t *rvalue)
     value |= ((msg->buf[(msg->pos++)] & 0xFF) << 16);
     value |= ((msg->buf[(msg->pos++)] & 0xFF) << 8);
     value |= ((msg->buf[(msg->pos++)] & 0xFF));
-    
+
     *rvalue = value;
     return APR_SUCCESS;
 }
@@ -357,7 +357,7 @@ apr_status_t ajp_msg_get_uint32(ajp_msg_t *msg, apr_uint32_t *rvalue)
 apr_status_t ajp_msg_get_uint16(ajp_msg_t *msg, apr_uint16_t *rvalue)
 {
     apr_uint16_t value;
-    
+
     if ((msg->pos + 1) > msg->len) {
         return ajp_log_overflow(msg, "ajp_msg_get_uint16");
     }
@@ -384,10 +384,10 @@ apr_status_t ajp_msg_peek_uint16(ajp_msg_t *msg, apr_uint16_t *rvalue)
     if ((msg->pos + 1) > msg->len) {
         return ajp_log_overflow(msg, "ajp_msg_peek_uint16");
     }
-    
+
     value = ((msg->buf[(msg->pos)] & 0xFF) << 8);
     value += ((msg->buf[(msg->pos + 1)] & 0xFF));
-    
+
     *rvalue = value;
     return APR_SUCCESS;
 }
@@ -405,7 +405,7 @@ apr_status_t ajp_msg_peek_uint8(ajp_msg_t *msg, apr_byte_t *rvalue)
     if (msg->pos > msg->len) {
         return ajp_log_overflow(msg, "ajp_msg_peek_uint8");
     }
-    
+
     *rvalue = msg->buf[msg->pos];
     return APR_SUCCESS;
 }
@@ -423,7 +423,7 @@ apr_status_t ajp_msg_get_uint8(ajp_msg_t *msg, apr_byte_t *rvalue)
     if (msg->pos > msg->len) {
         return ajp_log_overflow(msg, "ajp_msg_get_uint8");
     }
-    
+
     *rvalue = msg->buf[msg->pos++];
     return APR_SUCCESS;
 }
@@ -441,7 +441,7 @@ apr_status_t ajp_msg_get_string(ajp_msg_t *msg, const char **rvalue)
     apr_uint16_t size;
     apr_size_t   start;
     apr_status_t status;
-       
+
     status = ajp_msg_get_uint16(msg, &size);
     start = msg->pos;
 
@@ -504,11 +504,11 @@ apr_status_t ajp_msg_create(apr_pool_t *pool, ajp_msg_t **rmsg)
                       "ajp_msg_create(): can't allocate AJP message memory");
         return APR_ENOPOOL;
     }
-    
+
     msg->server_side = 0;
 
     msg->buf = (apr_byte_t *)apr_palloc(pool, AJP_MSG_BUFFER_SZ);
-    
+
     /* XXX: This should never happen
      * In case if the OS cannont allocate 8K of data
      * we are in serious trouble
@@ -524,7 +524,7 @@ apr_status_t ajp_msg_create(apr_pool_t *pool, ajp_msg_t **rmsg)
     msg->len = 0;
     msg->header_len = AJP_HEADER_LEN;
     *rmsg = msg;
-    
+
     return APR_SUCCESS;
 }
 
@@ -542,7 +542,7 @@ apr_status_t ajp_msg_copy(ajp_msg_t *smsg, ajp_msg_t *dmsg)
                      "ajp_msg_copy(): destination msg is null");
         return AJP_EINVAL;
     }
-    
+
     if (smsg->len > AJP_MSG_BUFFER_SZ) {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
                      "ajp_msg_copy(): destination buffer too "
@@ -576,11 +576,11 @@ apr_status_t ajp_msg_serialize_ping(ajp_msg_t *msg)
 
     if ((rc = ajp_msg_append_uint8(msg, CMD_AJP13_PING)) != APR_SUCCESS)
         return rc;
-        
+
     return APR_SUCCESS;
 }
 
-/** 
+/**
  * Serialize in an AJP Message a CPING command
  *
  * +-----------------------+
@@ -597,6 +597,6 @@ apr_status_t ajp_msg_serialize_cping(ajp_msg_t *msg)
 
     if ((rc = ajp_msg_append_uint8(msg, CMD_AJP13_CPING)) != APR_SUCCESS)
         return rc;
-        
+
     return APR_SUCCESS;
 }
diff --git a/modules/proxy/mod_proxy.c b/modules/proxy/mod_proxy.c
index 1ee15ba..1424fe7 100644
--- a/modules/proxy/mod_proxy.c
+++ b/modules/proxy/mod_proxy.c
@@ -91,7 +91,7 @@ static const char *set_worker_param(apr_pool_t *p,
     }
     else if (!strcasecmp(key, "ttl")) {
         /* Time in seconds that will destroy all the connections
-         * that exced the smax 
+         * that exced the smax
          */
         ival = atoi(val);
         if (ival < 1)
@@ -166,7 +166,7 @@ static const char *set_worker_param(apr_pool_t *p,
         else
             return "KeepAlive must be On|Off";
         worker->keepalive_set = 1;
-    }    
+    }
     else if (!strcasecmp(key, "route")) {
         /* Worker route.
          */
@@ -189,35 +189,35 @@ static const char *set_worker_param(apr_pool_t *p,
         for (v = val; *v; v++) {
             if (*v == '+') {
                 mode = 1;
-                v++;    
+                v++;
             }
             else if (*v == '-') {
                 mode = 0;
-                v++;    
+                v++;
             }
             if (*v == 'D' || *v == 'd') {
                 if (mode)
                     worker->status |= PROXY_WORKER_DISABLED;
                 else
-                    worker->status &= ~PROXY_WORKER_DISABLED;                    
+                    worker->status &= ~PROXY_WORKER_DISABLED;
             }
             else if (*v == 'S' || *v == 's') {
                 if (mode)
                     worker->status |= PROXY_WORKER_STOPPED;
                 else
-                    worker->status &= ~PROXY_WORKER_STOPPED;                    
+                    worker->status &= ~PROXY_WORKER_STOPPED;
             }
             else if (*v == 'E' || *v == 'e') {
                 if (mode)
                     worker->status |= PROXY_WORKER_IN_ERROR;
                 else
-                    worker->status &= ~PROXY_WORKER_IN_ERROR;                    
+                    worker->status &= ~PROXY_WORKER_IN_ERROR;
             }
             else {
-                return "Unknow status parameter option";    
+                return "Unknow status parameter option";
             }
         }
-    }    
+    }
     else {
         return "unknown Worker parameter";
     }
@@ -364,7 +364,7 @@ static int proxy_detect(request_rec *r)
         if (!(r->parsed_uri.hostname
               && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))
               && ap_matches_request_vhost(r, r->parsed_uri.hostname,
-                                          (apr_port_t)(r->parsed_uri.port_str ? r->parsed_uri.port 
+                                          (apr_port_t)(r->parsed_uri.port_str ? r->parsed_uri.port
                                                        : ap_default_port(r))))) {
             r->proxyreq = PROXYREQ_PROXY;
             r->uri = r->unparsed_uri;
@@ -432,25 +432,25 @@ static int proxy_walk(request_rec *r)
     proxy_dir_conf *entry_proxy;
     int num_sec = sconf->sec_proxy->nelts;
     /* XXX: shouldn't we use URI here?  Canonicalize it first?
-     * Pass over "proxy:" prefix 
+     * Pass over "proxy:" prefix
      */
     const char *proxyname = r->filename + 6;
     int j;
 
-    for (j = 0; j < num_sec; ++j) 
+    for (j = 0; j < num_sec; ++j)
     {
         entry_config = sec_proxy[j];
         entry_proxy = ap_get_module_config(entry_config, &proxy_module);
 
         /* XXX: What about case insensitive matching ???
          * Compare regex, fnmatch or string as appropriate
-         * If the entry doesn't relate, then continue 
+         * If the entry doesn't relate, then continue
          */
-        if (entry_proxy->r 
+        if (entry_proxy->r
               ? ap_regexec(entry_proxy->r, proxyname, 0, NULL, 0)
               : (entry_proxy->p_is_fnmatch
                    ? apr_fnmatch(entry_proxy->p, proxyname, 0)
-                   : strncmp(proxyname, entry_proxy->p, 
+                   : strncmp(proxyname, entry_proxy->p,
                                         strlen(entry_proxy->p)))) {
             continue;
         }
@@ -608,14 +608,14 @@ static int proxy_handler(request_rec *r)
         /* set configured max-forwards */
         maxfwd = conf->maxfwd;
     }
-    apr_table_set(r->headers_in, "Max-Forwards", 
+    apr_table_set(r->headers_in, "Max-Forwards",
                   apr_psprintf(r->pool, "%ld", (maxfwd > 0) ? maxfwd : 0));
 
     if (r->method_number == M_TRACE) {
         core_server_config *coreconf = (core_server_config *)
                             ap_get_module_config(sconf, &core_module);
 
-        if (coreconf->trace_enable == AP_TRACE_DISABLE) 
+        if (coreconf->trace_enable == AP_TRACE_DISABLE)
         {
             /* Allow "error-notes" string to be printed by ap_send_error_response()
              * Note; this goes nowhere, canned error response need an overhaul.
@@ -632,7 +632,7 @@ static int proxy_handler(request_rec *r)
          * the client a 100 Continue response till the connection has
          * been established
          */
-        if (coreconf->trace_enable != AP_TRACE_EXTENDED 
+        if (coreconf->trace_enable != AP_TRACE_EXTENDED
             && (r->read_length || r->read_chunked || r->remaining))
         {
             /* Allow "error-notes" string to be printed by ap_send_error_response()
@@ -751,7 +751,7 @@ static int proxy_handler(request_rec *r)
         }
         else if (access_status == HTTP_SERVICE_UNAVAILABLE) {
             /* Recoverable server error.
-             * We can failover to another worker 
+             * We can failover to another worker
              * Mark the worker as unusable if member of load balancer
              */
             if (balancer) {
@@ -767,7 +767,7 @@ static int proxy_handler(request_rec *r)
         /* Try again if the worker is unusable and the service is
          * unavailable.
          */
-    } while (!PROXY_WORKER_IS_USABLE(worker) && 
+    } while (!PROXY_WORKER_IS_USABLE(worker) &&
              max_attempts > attempts++);
 
     if (DECLINED == access_status) {
@@ -821,16 +821,16 @@ static void * create_proxy_config(apr_pool_t *p, server_rec *s)
     ps->io_buffer_size_set = 0;
     ps->maxfwd = DEFAULT_MAX_FORWARDS;
     ps->maxfwd_set = 0;
-    ps->error_override = 0; 
-    ps->error_override_set = 0; 
+    ps->error_override = 0;
+    ps->error_override_set = 0;
     ps->preserve_host_set = 0;
-    ps->preserve_host = 0;    
+    ps->preserve_host = 0;
     ps->timeout = 0;
     ps->timeout_set = 0;
     ps->badopt = bad_error;
     ps->badopt_set = 0;
     ps->pool = p;
-        
+
     return ps;
 }
 
@@ -993,7 +993,7 @@ static const char *
     const apr_array_header_t *arr;
     const apr_table_entry_t *elts;
     int i;
-    
+
     while (*arg) {
         word = ap_getword_conf(cmd->pool, &arg);
         if (!f)
@@ -1007,7 +1007,7 @@ static const char *
                     return "Invalid ProxyPass parameter.  Parameter must be "
                            "in the form 'key=value'";
                 else
-                    return "ProxyPass can not have a path when defined in a location"; 
+                    return "ProxyPass can not have a path when defined in a location";
             }
             else
                 *val++ = '\0';
@@ -1023,7 +1023,7 @@ static const char *
     new->real = apr_pstrdup(cmd->pool, r);
     if (r[0] == '!' && r[1] == '\0')
         return NULL;
-    
+
     arr = apr_table_elts(params);
     elts = (const apr_table_entry_t *)arr->elts;
     /* Distinguish the balancer from woker */
@@ -1035,7 +1035,7 @@ static const char *
                                                     conf, r);
             if (err)
                 return apr_pstrcat(cmd->temp_pool, "ProxyPass ", err, NULL);
-        }        
+        }
         for (i = 0; i < arr->nelts; i++) {
             const char *err = set_balancer_param(conf, cmd->pool, balancer, elts[i].key,
                                                  elts[i].val);
@@ -1079,7 +1079,7 @@ static const char *
     } else {
         if ( r == NULL)
             return "ProxyPassReverse needs a path when not defined in a location";
-        else 
+        else
             return "ProxyPassReverse can not have a path when defined in a location";
     }
 
@@ -1325,7 +1325,7 @@ static const char*
     psf->timeout_set=1;
     psf->timeout=apr_time_from_sec(timeout);
 
-    return NULL;    
+    return NULL;
 }
 
 static const char*
@@ -1348,7 +1348,7 @@ static const char*
     }
 
     psf->viaopt_set = 1;
-    return NULL;    
+    return NULL;
 }
 
 static const char*
@@ -1369,7 +1369,7 @@ static const char*
     }
 
     psf->badopt_set = 1;
-    return NULL;    
+    return NULL;
 }
 
 static const char*
@@ -1390,7 +1390,7 @@ static const char*
     }
 
     psf->proxy_status_set = 1;
-    return NULL;    
+    return NULL;
 }
 
 static const char *add_member(cmd_parms *cmd, void *dummy, const char *arg)
@@ -1407,7 +1407,7 @@ static const char *add_member(cmd_parms *cmd, void *dummy, const char *arg)
     const apr_array_header_t *arr;
     const apr_table_entry_t *elts;
     int i;
-    
+
     if (cmd->path)
         path = apr_pstrdup(cmd->pool, cmd->path);
     while (*arg) {
@@ -1433,7 +1433,7 @@ static const char *add_member(cmd_parms *cmd, void *dummy, const char *arg)
         return "BalancerMember must define balancer name when outside <Proxy > section";
     if (!name)
         return "BalancerMember must define remote proxy server";
-    
+
     ap_str_tolower(path);   /* lowercase scheme://hostname */
 
     /* Try to find existing worker */
@@ -1441,10 +1441,10 @@ static const char *add_member(cmd_parms *cmd, void *dummy, const char *arg)
     if (!worker) {
         const char *err;
         if ((err = ap_proxy_add_worker(&worker, cmd->pool, conf, name)) != NULL)
-            return apr_pstrcat(cmd->temp_pool, "BalancerMember ", err, NULL); 
+            return apr_pstrcat(cmd->temp_pool, "BalancerMember ", err, NULL);
     }
     PROXY_COPY_CONF_PARAMS(worker, conf);
-    
+
     arr = apr_table_elts(params);
     elts = (const apr_table_entry_t *)arr->elts;
     for (i = 0; i < arr->nelts; i++) {
@@ -1454,7 +1454,7 @@ static const char *add_member(cmd_parms *cmd, void *dummy, const char *arg)
             return apr_pstrcat(cmd->temp_pool, "BalancerMember ", err, NULL);
     }
     /* Try to find the balancer */
-    balancer = ap_proxy_get_balancer(cmd->temp_pool, conf, path); 
+    balancer = ap_proxy_get_balancer(cmd->temp_pool, conf, path);
     if (!balancer) {
         const char *err = ap_proxy_add_balancer(&balancer,
                                                 cmd->pool,
@@ -1496,13 +1496,13 @@ static const char *
          */
         name = ap_getword_conf(cmd->temp_pool, &arg);
     }
- 
+
     if (strncasecmp(name, "balancer:", 9) == 0) {
         balancer = ap_proxy_get_balancer(cmd->pool, conf, name);
         if (!balancer) {
             return apr_pstrcat(cmd->temp_pool, "ProxySet can not find '",
                                name, "' Balancer.", NULL);
-        }        
+        }
     }
     else {
         worker = ap_proxy_get_worker(cmd->temp_pool, conf, name);
@@ -1538,7 +1538,7 @@ static void ap_add_per_proxy_conf(server_rec *s, ap_conf_vector_t *dir_config)
     proxy_server_conf *sconf = ap_get_module_config(s->module_config,
                                                     &proxy_module);
     void **new_space = (void **)apr_array_push(sconf->sec_proxy);
-    
+
     *new_space = dir_config;
 }
 
@@ -1579,7 +1579,7 @@ static const char *proxysection(cmd_parms *cmd, void *mconfig, const char *arg)
     if (!strncasecmp(cmd->path, "proxy:", 6))
         cmd->path += 6;
 
-    /* XXX Ignore case?  What if we proxy a case-insensitive server?!? 
+    /* XXX Ignore case?  What if we proxy a case-insensitive server?!?
      * While we are at it, shouldn't we also canonicalize the entire
      * scheme?  See proxy_fixup()
      */
@@ -1628,7 +1628,7 @@ static const char *proxysection(cmd_parms *cmd, void *mconfig, const char *arg)
 
 static const command_rec proxy_cmds[] =
 {
-    AP_INIT_RAW_ARGS("<Proxy", proxysection, NULL, RSRC_CONF, 
+    AP_INIT_RAW_ARGS("<Proxy", proxysection, NULL, RSRC_CONF,
     "Container for directives affecting resources located in the proxied "
     "location"),
     AP_INIT_RAW_ARGS("<ProxyMatch", proxysection, (void*)1, RSRC_CONF,
@@ -1674,7 +1674,7 @@ static const command_rec proxy_cmds[] =
     AP_INIT_TAKE1("ProxyBadHeader", set_bad_opt, NULL, RSRC_CONF,
      "How to handle bad header line in response: IsError | Ignore | StartBody"),
     AP_INIT_RAW_ARGS("BalancerMember", add_member, NULL, RSRC_CONF|ACCESS_CONF,
-     "A balancer name and scheme with list of params"), 
+     "A balancer name and scheme with list of params"),
     AP_INIT_TAKE1("ProxyStatus", set_status_opt, NULL, RSRC_CONF,
      "Configure Status: proxy status to one of: on | off | full"),
     AP_INIT_RAW_ARGS("ProxySet", set_proxy_param, NULL, RSRC_CONF|ACCESS_CONF,
@@ -1689,7 +1689,7 @@ static APR_OPTIONAL_FN_TYPE(ssl_var_lookup) *proxy_ssl_val = NULL;
 
 PROXY_DECLARE(int) ap_proxy_ssl_enable(conn_rec *c)
 {
-    /* 
+    /*
      * if c == NULL just check if the optional function was imported
      * else run the optional function so ssl filters are inserted
      */
@@ -1764,7 +1764,7 @@ static int proxy_status_hook(request_rec *r, int flags)
         ap_rvputs(r, balancer->name, "</h1>\n\n", NULL);
         ap_rputs("\n\n<table border=\"0\"><tr>"
                  "<th>SSes</th><th>Timeout</th><th>Method</th>"
-                 "</tr>\n<tr>", r);                
+                 "</tr>\n<tr>", r);
         ap_rvputs(r, "<td>", balancer->sticky, NULL);
         ap_rprintf(r, "</td><td>%" APR_TIME_T_FMT "</td>",
                    apr_time_sec(balancer->timeout));
@@ -1827,7 +1827,7 @@ static int proxy_status_hook(request_rec *r, int flags)
 static void child_init(apr_pool_t *p, server_rec *s)
 {
     proxy_worker *reverse = NULL;
-    
+
     while (s) {
         void *sconf = s->module_config;
         proxy_server_conf *conf;
@@ -1835,7 +1835,7 @@ static void child_init(apr_pool_t *p, server_rec *s)
         int i;
 
         conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
-        /* Initialize worker's shared scoreboard data */ 
+        /* Initialize worker's shared scoreboard data */
         worker = (proxy_worker *)conf->workers->elts;
         for (i = 0; i < conf->workers->nelts; i++) {
             ap_proxy_initialize_worker_share(conf, worker, s);
@@ -1848,7 +1848,7 @@ static void child_init(apr_pool_t *p, server_rec *s)
             ap_proxy_initialize_worker(conf->forward, s);
             /* Do not disable worker in case of errors */
             conf->forward->s->status |= PROXY_WORKER_IGNORE_ERRORS;
-            /* Disable address cache for generic forward worker */ 
+            /* Disable address cache for generic forward worker */
             conf->forward->is_address_reusable = 0;
         }
         if (!reverse) {
@@ -1860,7 +1860,7 @@ static void child_init(apr_pool_t *p, server_rec *s)
             ap_proxy_initialize_worker(reverse, s);
             /* Do not disable worker in case of errors */
             reverse->s->status |= PROXY_WORKER_IGNORE_ERRORS;
-            /* Disable address cache for generic reverse worker */ 
+            /* Disable address cache for generic reverse worker */
             reverse->is_address_reusable = 0;
         }
         conf->reverse = reverse;
@@ -1877,7 +1877,7 @@ static int proxy_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
 {
     APR_OPTIONAL_HOOK(ap, status_hook, proxy_status_hook, NULL, NULL,
                       APR_HOOK_MIDDLE);
-    /* Reset workers count on gracefull restart */ 
+    /* Reset workers count on gracefull restart */
     proxy_lb_workers = 0;
     return OK;
 }
@@ -1893,7 +1893,7 @@ static void register_hooks(apr_pool_t *p)
      * initializes.
      */
     static const char *const aszPred[] = { "mpm_winnt.c", NULL};
-    
+
     APR_REGISTER_OPTIONAL_FN(ap_proxy_lb_workers);
     /* handler */
     ap_hook_handler(proxy_handler, NULL, NULL, APR_HOOK_FIRST);
@@ -1906,11 +1906,11 @@ static void register_hooks(apr_pool_t *p)
     /* post read_request handling */
     ap_hook_post_read_request(proxy_detect, NULL, NULL, APR_HOOK_FIRST);
     /* pre config handling */
-    ap_hook_pre_config(proxy_pre_config, NULL, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_pre_config(proxy_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
     /* post config handling */
     ap_hook_post_config(proxy_post_config, NULL, NULL, APR_HOOK_MIDDLE);
     /* child init handling */
-    ap_hook_child_init(child_init, aszPred, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_child_init(child_init, aszPred, NULL, APR_HOOK_MIDDLE);
 
 }
 
@@ -1933,19 +1933,19 @@ APR_HOOK_STRUCT(
     APR_HOOK_LINK(request_status)
 )
 
-APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(proxy, PROXY, int, scheme_handler, 
+APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(proxy, PROXY, int, scheme_handler,
                                      (request_rec *r, proxy_worker *worker,
-                                      proxy_server_conf *conf, 
-                                      char *url, const char *proxyhost, 
+                                      proxy_server_conf *conf,
+                                      char *url, const char *proxyhost,
                                       apr_port_t proxyport),(r,worker,conf,
                                       url,proxyhost,proxyport),DECLINED)
-APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(proxy, PROXY, int, canon_handler, 
+APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(proxy, PROXY, int, canon_handler,
                                       (request_rec *r, char *url),(r,
                                       url),DECLINED)
 APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(proxy, PROXY, int, pre_request, (
                                       proxy_worker **worker,
                                       proxy_balancer **balancer,
-                                      request_rec *r, 
+                                      request_rec *r,
                                       proxy_server_conf *conf,
                                       char **url),(worker,balancer,
                                       r,conf,url),DECLINED)
@@ -1959,6 +1959,6 @@ APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(proxy, PROXY, int, fixups,
                                     (request_rec *r), (r),
                                     OK, DECLINED)
 APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(proxy, PROXY, int, request_status,
-                                    (int *status, request_rec *r), 
+                                    (int *status, request_rec *r),
                                     (status, r),
                                     OK, DECLINED)
diff --git a/modules/proxy/mod_proxy_ajp.c b/modules/proxy/mod_proxy_ajp.c
index afee93e..22e7cef 100644
--- a/modules/proxy/mod_proxy_ajp.c
+++ b/modules/proxy/mod_proxy_ajp.c
@@ -198,7 +198,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
 
         /* Try to send something */
         ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
-                     "proxy: data to read (max %" APR_SIZE_T_FMT 
+                     "proxy: data to read (max %" APR_SIZE_T_FMT
                      " at %" APR_SIZE_T_FMT ")", bufsiz, msg->pos);
 
         status = apr_brigade_flatten(input_brigade, buff, &bufsiz);
diff --git a/modules/proxy/mod_proxy_balancer.c b/modules/proxy/mod_proxy_balancer.c
index 0862854..988508a 100644
--- a/modules/proxy/mod_proxy_balancer.c
+++ b/modules/proxy/mod_proxy_balancer.c
@@ -33,7 +33,7 @@ static int proxy_balancer_canon(request_rec *r, char *url)
 
     if (strncasecmp(url, "balancer:", 9) == 0) {
         url += 9;
-    }    
+    }
     else {
         return DECLINED;
     }
@@ -78,7 +78,7 @@ static int init_balancer_members(proxy_server_conf *conf, server_rec *s,
                                  proxy_balancer *balancer)
 {
     int i;
-    proxy_worker *workers;    
+    proxy_worker *workers;
 
     workers = (proxy_worker *)balancer->workers->elts;
 
@@ -111,7 +111,7 @@ static char *get_path_param(apr_pool_t *pool, char *url,
                             const char *name)
 {
     char *path = NULL;
-    
+
     for (path = strstr(url, name); path; path = strstr(path + 1, name)) {
         path += (strlen(name) + 1);
         if (*path == '=') {
@@ -137,13 +137,13 @@ static char *get_cookie_param(request_rec *r, const char *name)
     const char *start_cookie;
 
     if ((cookies = apr_table_get(r->headers_in, "Cookie"))) {
-        for (start_cookie = ap_strstr_c(cookies, name); start_cookie; 
+        for (start_cookie = ap_strstr_c(cookies, name); start_cookie;
              start_cookie = ap_strstr_c(start_cookie + 1, name)) {
             if (start_cookie == cookies ||
                 start_cookie[-1] == ';' ||
                 start_cookie[-1] == ',' ||
                 isspace(start_cookie[-1])) {
-                
+
                 start_cookie += strlen(name);
                 while(*start_cookie && isspace(*start_cookie))
                     ++start_cookie;
@@ -161,7 +161,7 @@ static char *get_cookie_param(request_rec *r, const char *name)
                     return cookie;
                 }
             }
-        }     
+        }
     }
     return NULL;
 }
@@ -235,13 +235,13 @@ static proxy_worker *find_best_worker(proxy_balancer *balancer,
                                       request_rec *r)
 {
     proxy_worker *candidate = NULL;
-    
+
     if (PROXY_THREAD_LOCK(balancer) != APR_SUCCESS)
-        return NULL;    
+        return NULL;
 
     candidate = (*balancer->lbmethod->finder)(balancer, r);
 
-/*    
+/*
         PROXY_THREAD_UNLOCK(balancer);
         return NULL;
 */
@@ -258,10 +258,10 @@ static proxy_worker *find_best_worker(proxy_balancer *balancer,
          */
 #if APR_HAS_THREADS
         if (balancer->timeout) {
-            /* XXX: This can perhaps be build using some 
+            /* XXX: This can perhaps be build using some
              * smarter mechanism, like tread_cond.
-             * But since the statuses can came from 
-             * different childs, use the provided algo. 
+             * But since the statuses can came from
+             * different childs, use the provided algo.
              */
             apr_interval_time_t timeout = balancer->timeout;
             apr_interval_time_t step, tval = 0;
@@ -290,7 +290,7 @@ static int rewrite_url(request_rec *r, proxy_worker *worker,
 {
     const char *scheme = strstr(*url, "://");
     const char *path = NULL;
-    
+
     if (scheme)
         path = ap_strchr_c(scheme + 3, '/');
 
@@ -302,7 +302,7 @@ static int rewrite_url(request_rec *r, proxy_worker *worker,
     }
 
     *url = apr_pstrcat(r->pool, worker->name, path, NULL);
-   
+
     return OK;
 }
 
@@ -317,7 +317,7 @@ static int proxy_balancer_pre_request(proxy_worker **worker,
     apr_status_t rv;
 
     *worker = NULL;
-    /* Step 1: check if the url is for us 
+    /* Step 1: check if the url is for us
      * The url we can handle starts with 'balancer://'
      * If balancer is already provided skip the search
      * for balancer, because this is failover attempt.
@@ -325,9 +325,9 @@ static int proxy_balancer_pre_request(proxy_worker **worker,
     if (!*balancer &&
         !(*balancer = ap_proxy_get_balancer(r->pool, conf, *url)))
         return DECLINED;
-    
+
     /* Step 2: find the session route */
-    
+
     runtime = find_session_route(*balancer, r, &route, url);
     /* Lock the LoadBalancer
      * XXX: perhaps we need the process lock here
@@ -341,7 +341,7 @@ static int proxy_balancer_pre_request(proxy_worker **worker,
         int i, total_factor = 0;
         proxy_worker *workers;
         /* We have a sticky load balancer
-         * Update the workers status 
+         * Update the workers status
          * so that even session routes get
          * into account.
          */
@@ -376,7 +376,7 @@ static int proxy_balancer_pre_request(proxy_worker **worker,
             ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                          "proxy: BALANCER: (%s). All workers are in error state",
                          (*balancer)->name);
-        
+
             return HTTP_SERVICE_UNAVAILABLE;
         }
         *worker = runtime;
@@ -398,7 +398,7 @@ static int proxy_balancer_pre_request(proxy_worker **worker,
                  (*balancer)->name, (*worker)->name, *url);
 
     return access_status;
-} 
+}
 
 static int proxy_balancer_post_request(proxy_worker *worker,
                                        proxy_balancer *balancer,
@@ -420,17 +420,17 @@ static int proxy_balancer_post_request(proxy_worker *worker,
      * track on that.
      */
 
-    PROXY_THREAD_UNLOCK(balancer);        
+    PROXY_THREAD_UNLOCK(balancer);
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "proxy_balancer_post_request for (%s)", balancer->name);
 
     return OK;
-} 
+}
 
 static void recalc_factors(proxy_balancer *balancer)
 {
     int i;
-    proxy_worker *workers;    
+    proxy_worker *workers;
 
 
     /* Recalculate lbfactors */
@@ -448,7 +448,7 @@ static void recalc_factors(proxy_balancer *balancer)
     }
 }
 
-/* Manages the loadfactors and member status 
+/* Manages the loadfactors and member status
  */
 static int balancer_handler(request_rec *r)
 {
@@ -580,9 +580,9 @@ static int balancer_handler(request_rec *r)
             for (n = 0; n < balancer->workers->nelts; n++) {
                 ap_rputs("        <httpd:worker>\n", r);
                 ap_rvputs(r, "          <httpd:scheme>", worker->scheme,
-                          "</httpd:scheme>\n", NULL);                
+                          "</httpd:scheme>\n", NULL);
                 ap_rvputs(r, "          <httpd:hostname>", worker->hostname,
-                          "</httpd:hostname>\n", NULL);                
+                          "</httpd:hostname>\n", NULL);
                ap_rprintf(r, "          <httpd:loadfactor>%d</httpd:loadfactor>\n",
                           worker->s->lbfactor);
                 ap_rputs("        </httpd:worker>\n", r);
@@ -593,7 +593,7 @@ static int balancer_handler(request_rec *r)
             ++balancer;
         }
         ap_rputs("  </httpd:balancers>\n", r);
-        ap_rputs("</httpd:manager>", r);         
+        ap_rputs("</httpd:manager>", r);
     }
     else {
         ap_set_content_type(r, "text/html");
@@ -611,11 +611,11 @@ static int balancer_handler(request_rec *r)
             ap_rputs("<hr />\n<h3>LoadBalancer Status for ", r);
             ap_rvputs(r, "<a href=\"", r->uri, "?b=",
                       balancer->name + sizeof("balancer://") - 1,
-                      "\">", NULL); 
+                      "\">", NULL);
             ap_rvputs(r, balancer->name, "</a></h3>\n\n", NULL);
             ap_rputs("\n\n<table border=\"0\" style=\"text-align: left;\"><tr>"
                 "<th>StickySession</th><th>Timeout</th><th>FailoverAttempts</th><th>Method</th>"
-                "</tr>\n<tr>", r);                
+                "</tr>\n<tr>", r);
             ap_rvputs(r, "<td>", balancer->sticky, NULL);
             ap_rprintf(r, "</td><td>%" APR_TIME_T_FMT "</td>",
                 apr_time_sec(balancer->timeout));
@@ -635,7 +635,7 @@ static int balancer_handler(request_rec *r)
                 ap_rvputs(r, "<tr>\n<td><a href=\"", r->uri, "?b=",
                           balancer->name + sizeof("balancer://") - 1, "&w=",
                           ap_escape_uri(r->pool, worker->name),
-                          "\">", NULL); 
+                          "\">", NULL);
                 ap_rvputs(r, worker->name, "</a></td>", NULL);
                 ap_rvputs(r, "<td>", worker->s->route, NULL);
                 ap_rvputs(r, "</td><td>", worker->s->redirect, NULL);
@@ -660,25 +660,25 @@ static int balancer_handler(request_rec *r)
             ap_rputs("<h3>Edit worker settings for ", r);
             ap_rvputs(r, wsel->name, "</h3>\n", NULL);
             ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
-            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
+            ap_rvputs(r, r->uri, "\">\n<dl>", NULL);
             ap_rputs("<table><tr><td>Load factor:</td><td><input name=\"lf\" type=text ", r);
-            ap_rprintf(r, "value=\"%d\"></td><tr>\n", wsel->s->lbfactor);            
+            ap_rprintf(r, "value=\"%d\"></td><tr>\n", wsel->s->lbfactor);
             ap_rputs("<tr><td>Route:</td><td><input name=\"wr\" type=text ", r);
-            ap_rvputs(r, "value=\"", wsel->route, NULL); 
-            ap_rputs("\"></td><tr>\n", r);            
+            ap_rvputs(r, "value=\"", wsel->route, NULL);
+            ap_rputs("\"></td><tr>\n", r);
             ap_rputs("<tr><td>Route Redirect:</td><td><input name=\"rr\" type=text ", r);
-            ap_rvputs(r, "value=\"", wsel->redirect, NULL); 
-            ap_rputs("\"></td><tr>\n", r);            
+            ap_rvputs(r, "value=\"", wsel->redirect, NULL);
+            ap_rputs("\"></td><tr>\n", r);
             ap_rputs("<tr><td>Status:</td><td>Disabled: <input name=\"dw\" value=\"Disable\" type=radio", r);
             if (wsel->s->status & PROXY_WORKER_DISABLED)
                 ap_rputs(" checked", r);
             ap_rputs("> | Enabled: <input name=\"dw\" value=\"Enable\" type=radio", r);
             if (!(wsel->s->status & PROXY_WORKER_DISABLED))
                 ap_rputs(" checked", r);
-            ap_rputs("></td><tr>\n", r);            
+            ap_rputs("></td><tr>\n", r);
             ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
             ap_rvputs(r, "</table>\n<input type=hidden name=\"w\" ",  NULL);
-            ap_rvputs(r, "value=\"", ap_escape_uri(r->pool, wsel->name), "\">\n", NULL); 
+            ap_rvputs(r, "value=\"", ap_escape_uri(r->pool, wsel->name), "\">\n", NULL);
             ap_rvputs(r, "<input type=hidden name=\"b\" ", NULL);
             ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                       "\">\n</form>\n", NULL);
@@ -688,7 +688,7 @@ static int balancer_handler(request_rec *r)
             ap_rputs("<h3>Edit balancer settings for ", r);
             ap_rvputs(r, bsel->name, "</h3>\n", NULL);
             ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
-            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
+            ap_rvputs(r, r->uri, "\">\n<dl>", NULL);
             ap_rputs("<table><tr><td>StickySession Identifier:</td><td><input name=\"ss\" type=text ", r);
             if (bsel->sticky)
                 ap_rvputs(r, "value=\"", bsel->sticky, "\"", NULL);
@@ -733,8 +733,8 @@ static void child_init(apr_pool_t *p, server_rec *s)
         proxy_balancer *balancer;
         int i;
         conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
-    
-        /* Initialize shared scoreboard data */ 
+
+        /* Initialize shared scoreboard data */
         balancer = (proxy_balancer *)conf->balancers->elts;
         for (i = 0; i < conf->balancers->nelts; i++) {
             init_balancer_members(conf, s, balancer);
@@ -790,7 +790,7 @@ static void child_init(apr_pool_t *p, server_rec *s)
  *   b a d c d a c d b d ...
  *
  */
- 
+
 static proxy_worker *find_best_byrequests(proxy_balancer *balancer,
                                 request_rec *r)
 {
@@ -798,7 +798,7 @@ static proxy_worker *find_best_byrequests(proxy_balancer *balancer,
     int total_factor = 0;
     proxy_worker *worker = (proxy_worker *)balancer->workers->elts;
     proxy_worker *mycandidate = NULL;
- 
+
 
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "proxy: Entering byrequests for BALANCER (%s)",
@@ -859,7 +859,7 @@ static proxy_worker *find_best_bytraffic(proxy_balancer *balancer,
     apr_off_t curmin = 0;
     proxy_worker *worker = (proxy_worker *)balancer->workers->elts;
     proxy_worker *mycandidate = NULL;
-    
+
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "proxy: Entering bytraffic for BALANCER (%s)",
                  balancer->name);
@@ -887,7 +887,7 @@ static proxy_worker *find_best_bytraffic(proxy_balancer *balancer,
         }
         worker++;
     }
-    
+
     if (mycandidate) {
         mycandidate->s->elected++;
     }
@@ -925,8 +925,8 @@ static void ap_proxy_balancer_register_hook(apr_pool_t *p)
      /* manager handler */
     ap_hook_handler(balancer_handler, NULL, NULL, APR_HOOK_FIRST);
     ap_hook_child_init(child_init, aszPred, NULL, APR_HOOK_MIDDLE);
-    proxy_hook_pre_request(proxy_balancer_pre_request, NULL, NULL, APR_HOOK_FIRST);    
-    proxy_hook_post_request(proxy_balancer_post_request, NULL, NULL, APR_HOOK_FIRST);    
+    proxy_hook_pre_request(proxy_balancer_pre_request, NULL, NULL, APR_HOOK_FIRST);
+    proxy_hook_post_request(proxy_balancer_post_request, NULL, NULL, APR_HOOK_FIRST);
     proxy_hook_canon_handler(proxy_balancer_canon, NULL, NULL, APR_HOOK_FIRST);
     ap_register_provider(p, PROXY_LBMETHOD, "bytraffic", "0", &bytraffic);
     ap_register_provider(p, PROXY_LBMETHOD, "byrequests", "0", &byrequests);
diff --git a/modules/proxy/mod_proxy_connect.c b/modules/proxy/mod_proxy_connect.c
index 4444a3c..4238362 100644
--- a/modules/proxy/mod_proxy_connect.c
+++ b/modules/proxy/mod_proxy_connect.c
@@ -23,7 +23,7 @@
 
 module AP_MODULE_DECLARE_DATA proxy_connect_module;
 
-/*  
+/*
  * This handles Netscape CONNECT method secure proxy requests.
  * A connection is opened to the specified host and data is
  * passed through between the WWW site and the browser.
@@ -32,8 +32,8 @@ module AP_MODULE_DECLARE_DATA proxy_connect_module;
  * "Tunneling SSL Through a WWW Proxy" currently at
  * http://www.mcom.com/newsref/std/tunneling_ssl.html.
  *
- * If proxyhost and proxyport are set, we send a CONNECT to 
- * the specified proxy..  
+ * If proxyhost and proxyport are set, we send a CONNECT to
+ * the specified proxy..
  *
  * FIXME: this doesn't log the number of bytes sent, but
  *        that may be okay, since the data is supposed to
@@ -73,8 +73,8 @@ static int proxy_connect_canon(request_rec *r, char *url)
 
 /* CONNECT handler */
 static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
-                                 proxy_server_conf *conf, 
-                                 char *url, const char *proxyname, 
+                                 proxy_server_conf *conf,
+                                 char *url, const char *proxyname,
                                  apr_port_t proxyport)
 {
     apr_pool_t *p = r->pool;
@@ -239,7 +239,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
         ap_xlate_proto_to_ascii(buffer, nbytes);
         apr_socket_send(client_socket, buffer, &nbytes);
 #if 0
-        /* This is safer code, but it doesn't work yet.  I'm leaving it 
+        /* This is safer code, but it doesn't work yet.  I'm leaving it
          * here so that I can fix it later.
          */
         r->status = HTTP_OK;
diff --git a/modules/proxy/mod_proxy_ftp.c b/modules/proxy/mod_proxy_ftp.c
index 1465827..ef2bb90 100644
--- a/modules/proxy/mod_proxy_ftp.c
+++ b/modules/proxy/mod_proxy_ftp.c
@@ -733,7 +733,7 @@ apr_status_t proxy_ftp_cleanup(request_rec *r, proxy_conn_rec *backend)
 
     backend->close_on_recycle = 1;
     ap_set_module_config(r->connection->conn_config, &proxy_ftp_module, NULL);
-    ap_proxy_release_connection("FTP", backend, r->server);    
+    ap_proxy_release_connection("FTP", backend, r->server);
 
     return OK;
 }
@@ -769,7 +769,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
     char buffer[MAX_STRING_LEN];
     char *ftpmessage = NULL;
     char *path, *strp, *type_suffix, *cwd = NULL;
-    apr_uri_t uri; 
+    apr_uri_t uri;
     char *user = NULL;
 /*    char *account = NULL; how to supply an account in a URL? */
     const char *password = NULL;
@@ -914,8 +914,8 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                                     connectname, APR_UNSPEC,
                                     connectport, 0,
                                     address_pool);
-    if (worker->is_address_reusable && !worker->cp->addr) {        
-        worker->cp->addr = connect_addr;            
+    if (worker->is_address_reusable && !worker->cp->addr) {
+        worker->cp->addr = connect_addr;
         PROXY_THREAD_UNLOCK(worker);
     }
     /*
@@ -945,9 +945,9 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
             }
             return status;
         }
-        /* TODO: see if ftp could use determine_connection */ 
+        /* TODO: see if ftp could use determine_connection */
         backend->addr = connect_addr;
-        ap_set_module_config(c->conn_config, &proxy_ftp_module, backend);        
+        ap_set_module_config(c->conn_config, &proxy_ftp_module, backend);
     }
 
 
@@ -1221,7 +1221,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                 }
 
 #if !defined (TPF) && !defined(BEOS)
-                if (conf->recv_buffer_size > 0 
+                if (conf->recv_buffer_size > 0
                         && (rv = apr_socket_opt_set(data_sock, APR_SO_RCVBUF,
                                                     conf->recv_buffer_size))) {
                     ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
@@ -1309,7 +1309,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                 }
 
 #if !defined (TPF) && !defined(BEOS)
-                if (conf->recv_buffer_size > 0 
+                if (conf->recv_buffer_size > 0
                         && (rv = apr_socket_opt_set(data_sock, APR_SO_RCVBUF,
                                                     conf->recv_buffer_size))) {
                     ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
@@ -1355,7 +1355,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
         local_port = local_addr->port;
         apr_sockaddr_ip_get(&local_ip, local_addr);
 
-        if ((rv = apr_socket_opt_set(local_sock, APR_SO_REUSEADDR, one)) 
+        if ((rv = apr_socket_opt_set(local_sock, APR_SO_REUSEADDR, one))
                 != APR_SUCCESS) {
 #ifndef _OSD_POSIX              /* BS2000 has this option "always on" */
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
@@ -1478,7 +1478,7 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
             ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                              "proxy: FTP: SIZE shows this is a directory");
             dirlisting = 1;
-            rc = proxy_ftp_command(apr_pstrcat(p, "CWD ", 
+            rc = proxy_ftp_command(apr_pstrcat(p, "CWD ",
                            ftp_escape_globbingchars(p, path), CRLF, NULL),
                            r, origin, bb, &ftpmessage);
             /* possible results: 250, 421, 500, 501, 502, 530, 550 */
@@ -1778,10 +1778,10 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
                      "proxy: FTP: start body send");
 
         /* read the body, pass it to the output filters */
-        while (ap_get_brigade(data->input_filters, 
-                              bb, 
-                              AP_MODE_READBYTES, 
-                              APR_BLOCK_READ, 
+        while (ap_get_brigade(data->input_filters,
+                              bb,
+                              AP_MODE_READBYTES,
+                              APR_BLOCK_READ,
                               conf->io_buffer_size) == APR_SUCCESS) {
 #if DEBUGGING
             {
diff --git a/modules/proxy/mod_proxy_http.c b/modules/proxy/mod_proxy_http.c
index 449cb9f..8333321 100644
--- a/modules/proxy/mod_proxy_http.c
+++ b/modules/proxy/mod_proxy_http.c
@@ -92,7 +92,7 @@ static int proxy_http_canon(request_rec *r, char *url)
     if (ap_strchr_c(host, ':')) { /* if literal IPv6 address */
         host = apr_pstrcat(r->pool, "[", host, "]", NULL);
     }
-    r->filename = apr_pstrcat(r->pool, "proxy:", scheme, "://", host, sport, 
+    r->filename = apr_pstrcat(r->pool, "proxy:", scheme, "://", host, sport,
             "/", path, (search) ? "?" : "", (search) ? search : "", NULL);
     return OK;
 }
@@ -228,20 +228,20 @@ static apr_status_t stream_reqbody_chunked(apr_pool_t *p,
         apr_brigade_length(input_brigade, 1, &bytes);
 
         hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr),
-                               "%" APR_UINT64_T_HEX_FMT CRLF, 
+                               "%" APR_UINT64_T_HEX_FMT CRLF,
                                (apr_uint64_t)bytes);
-        
+
         ap_xlate_proto_to_ascii(chunk_hdr, hdr_len);
         e = apr_bucket_transient_create(chunk_hdr, hdr_len,
                                         bucket_alloc);
         APR_BRIGADE_INSERT_HEAD(input_brigade, e);
-        
+
         /*
          * Append the end-of-chunk CRLF
          */
         e = apr_bucket_immortal_create(ASCII_CRLF, 2, bucket_alloc);
         APR_BRIGADE_INSERT_TAIL(input_brigade, e);
-        
+
         if (header_brigade) {
             /* we never sent the header brigade, so go ahead and
              * take care of that now
@@ -267,7 +267,7 @@ static apr_status_t stream_reqbody_chunked(apr_pool_t *p,
         else {
             bb = input_brigade;
         }
-        
+
         /* The request is flushed below this loop with chunk EOS header */
         status = pass_brigade(bucket_alloc, r, p_conn, origin, bb, 0);
         if (status != APR_SUCCESS) {
@@ -388,7 +388,7 @@ static apr_status_t stream_reqbody_cl(apr_pool_t *p,
         else {
             bb = input_brigade;
         }
-        
+
         /* Once we hit EOS, we are ready to flush. */
         status = pass_brigade(bucket_alloc, r, p_conn, origin, bb, seen_eos);
         if (status != APR_SUCCESS) {
@@ -407,7 +407,7 @@ static apr_status_t stream_reqbody_cl(apr_pool_t *p,
             return status;
         }
     }
-    
+
     if (bytes_streamed != cl_val) {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                      "proxy: client %s given Content-Length did not match"
@@ -520,7 +520,7 @@ static apr_status_t spool_reqbody_cl(apr_pool_t *p,
             }
 
         }
-        
+
         bytes_spooled += bytes;
 
         if (seen_eos) {
@@ -605,7 +605,7 @@ apr_status_t ap_proxy_http_request(apr_pool_t *p, request_rec *r,
     /* strip connection listed hop-by-hop headers from the request */
     /* even though in theory a connection: close coming from the client
      * should not affect the connection to the server, it's unlikely
-     * that subsequent client requests will hit this thread/process, 
+     * that subsequent client requests will hit this thread/process,
      * so we cancel server keepalive if the client does.
      */
     if (ap_proxy_liststr(apr_table_get(r->headers_in,
@@ -641,25 +641,25 @@ apr_status_t ap_proxy_http_request(apr_pool_t *p, request_rec *r,
         } else {
             buf = apr_pstrcat(p, "Host: ", uri->hostname, CRLF, NULL);
         }
-    } 
+    }
     else {
-        /* don't want to use r->hostname, as the incoming header might have a 
-         * port attached 
+        /* don't want to use r->hostname, as the incoming header might have a
+         * port attached
          */
-        const char* hostname = apr_table_get(r->headers_in,"Host");        
+        const char* hostname = apr_table_get(r->headers_in,"Host");
         if (!hostname) {
             hostname =  r->server->server_hostname;
             ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                           "proxy: no HTTP 0.9 request (with no host line) "
                           "on incoming request and preserve host set "
-                          "forcing hostname to be %s for uri %s", 
-                          hostname, 
+                          "forcing hostname to be %s for uri %s",
+                          hostname,
                           r->uri );
         }
         buf = apr_pstrcat(p, "Host: ", hostname, CRLF, NULL);
     }
     ap_xlate_proto_to_ascii(buf, strlen(buf));
-    e = apr_bucket_pool_create(buf, strlen(buf), p, c->bucket_alloc);        
+    e = apr_bucket_pool_create(buf, strlen(buf), p, c->bucket_alloc);
     APR_BRIGADE_INSERT_TAIL(header_brigade, e);
 
     /* handle Via */
@@ -741,7 +741,7 @@ apr_status_t ap_proxy_http_request(apr_pool_t *p, request_rec *r,
     headers_in_array = apr_table_elts(r->headers_in);
     headers_in = (const apr_table_entry_t *) headers_in_array->elts;
     for (counter = 0; counter < headers_in_array->nelts; counter++) {
-        if (headers_in[counter].key == NULL 
+        if (headers_in[counter].key == NULL
              || headers_in[counter].val == NULL
 
             /* Already sent */
@@ -755,7 +755,7 @@ apr_status_t ap_proxy_http_request(apr_pool_t *p, request_rec *r,
              || !strcasecmp(headers_in[counter].key, "Trailer")
              || !strcasecmp(headers_in[counter].key, "Upgrade")
 
-            /* XXX: @@@ FIXME: "Proxy-Authorization" should *only* be 
+            /* XXX: @@@ FIXME: "Proxy-Authorization" should *only* be
              * suppressed if THIS server requested the authentication,
              * not when a frontend proxy requested it!
              *
@@ -830,7 +830,7 @@ apr_status_t ap_proxy_http_request(apr_pool_t *p, request_rec *r,
      * that the can and have done so unless they they remove
      * their decoding from the headers_in T-E list.
      * XXX: Make this extensible, but in doing so, presume the
-     * encoding has been done by the extensions' handler, and 
+     * encoding has been done by the extensions' handler, and
      * do not modify add_te_chunked's logic
      */
     if (old_te_val && strcmp(old_te_val, "chunked") != 0) {
@@ -900,7 +900,7 @@ apr_status_t ap_proxy_http_request(apr_pool_t *p, request_rec *r,
      * surrender once we hit 80 bytes less than MAX_MEM_SPOOL
      * (an arbitrary value.)
      */
-    } while ((bytes_read < MAX_MEM_SPOOL - 80) 
+    } while ((bytes_read < MAX_MEM_SPOOL - 80)
               && !APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade)));
 
     /* Use chunked request body encoding or send a content-length body?
@@ -909,10 +909,10 @@ apr_status_t ap_proxy_http_request(apr_pool_t *p, request_rec *r,
      *
      *   We have no request body (handled by RB_STREAM_CL)
      *
-     *   We have a request body length <= MAX_MEM_SPOOL 
+     *   We have a request body length <= MAX_MEM_SPOOL
      *
      *   The administrator has setenv force-proxy-request-1.0
-     *   
+     *
      *   The client sent a C-L body, and the administrator has
      *   not setenv proxy-sendchunked or has set setenv proxy-sendcl
      *
@@ -935,12 +935,12 @@ apr_status_t ap_proxy_http_request(apr_pool_t *p, request_rec *r,
      * input to a temporary file.  Chunked is always preferable.
      *
      * We can only trust the client-provided C-L if the T-E header
-     * is absent, and the filters are unchanged (the body won't 
+     * is absent, and the filters are unchanged (the body won't
      * be resized by another content filter).
      */
     if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {
         /* The whole thing fit, so our decision is trivial, use
-         * the filtered bytes read from the client for the request 
+         * the filtered bytes read from the client for the request
          * body Content-Length.
          *
          * If we expected no body, and read no body, do not set
@@ -952,7 +952,7 @@ apr_status_t ap_proxy_http_request(apr_pool_t *p, request_rec *r,
         rb_method = RB_STREAM_CL;
     }
     else if (old_te_val) {
-        if (force10 
+        if (force10
              || (apr_table_get(r->subprocess_env, "proxy-sendcl")
                   && !apr_table_get(r->subprocess_env, "proxy-sendchunks"))) {
             rb_method = RB_SPOOL_CL;
@@ -965,7 +965,7 @@ apr_status_t ap_proxy_http_request(apr_pool_t *p, request_rec *r,
         if (r->input_filters == r->proto_input_filters) {
             rb_method = RB_STREAM_CL;
         }
-        else if (!force10 
+        else if (!force10
                   && apr_table_get(r->subprocess_env, "proxy-sendchunks")
                   && !apr_table_get(r->subprocess_env, "proxy-sendcl")) {
             rb_method = RB_STREAM_CHUNKED;
@@ -995,11 +995,11 @@ skip_body:
     /* send the request body, if any. */
     switch(rb_method) {
     case RB_STREAM_CHUNKED:
-        status = stream_reqbody_chunked(p, r, p_conn, origin, header_brigade, 
+        status = stream_reqbody_chunked(p, r, p_conn, origin, header_brigade,
                                         input_brigade);
         break;
     case RB_STREAM_CL:
-        status = stream_reqbody_cl(p, r, p_conn, origin, header_brigade, 
+        status = stream_reqbody_cl(p, r, p_conn, origin, header_brigade,
                                    input_brigade, old_cl_val);
         break;
     case RB_SPOOL_CL:
@@ -1018,7 +1018,7 @@ skip_body:
         ap_log_error(APLOG_MARK, APLOG_ERR, status, r->server,
                      "proxy: pass request body failed to %pI (%s)"
                      " from %s (%s)",
-                     p_conn->addr, 
+                     p_conn->addr,
                      p_conn->hostname ? p_conn->hostname: "",
                      c->remote_ip,
                      c->remote_host ? c->remote_host: "");
@@ -1265,7 +1265,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                 buffer[13] = '\0';
             }
             r->status_line = apr_pstrdup(p, &buffer[9]);
-            
+
 
             /* read the headers. */
             /* N.B. for HTTP/1.0 clients, we have to fold line-wrapped headers*/
@@ -1312,10 +1312,10 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
             /* can't have both Content-Length and Transfer-Encoding */
             if (apr_table_get(r->headers_out, "Transfer-Encoding")
                     && apr_table_get(r->headers_out, "Content-Length")) {
-                /* 
+                /*
                  * 2616 section 4.4, point 3: "if both Transfer-Encoding
                  * and Content-Length are received, the latter MUST be
-                 * ignored"; 
+                 * ignored";
                  *
                  * To help mitigate HTTP Splitting, unset Content-Length
                  * and shut down the backend server connection
@@ -1335,7 +1335,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
             ap_proxy_clear_connection(p, r->headers_out);
             if ((buf = apr_table_get(r->headers_out, "Content-Type"))) {
                 ap_set_content_type(r, apr_pstrdup(p, buf));
-            }            
+            }
             ap_proxy_pre_http_request(origin,rp);
 
             /* handle Via header in response */
@@ -1442,7 +1442,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
 
             ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                          "proxy: start body send");
-             
+
             /*
              * if we are overriding the errors, we can't put the content
              * of the page into the brigade
@@ -1456,7 +1456,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                     apr_off_t readbytes;
                     apr_status_t rv;
 
-                    rv = ap_get_brigade(rp->input_filters, bb, 
+                    rv = ap_get_brigade(rp->input_filters, bb,
                                         AP_MODE_READBYTES, mode,
                                         conf->io_buffer_size);
 
@@ -1467,7 +1467,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                         /* flush to the client and switch to blocking mode */
                         e = apr_bucket_flush_create(c->bucket_alloc);
                         APR_BRIGADE_INSERT_TAIL(bb, e);
-                        if (ap_pass_brigade(r->output_filters, bb) 
+                        if (ap_pass_brigade(r->output_filters, bb)
                             || c->aborted) {
                             backend->close = 1;
                             break;
@@ -1486,7 +1486,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                     }
                     /* next time try a non-blocking read */
                     mode = APR_NONBLOCK_READ;
-                    
+
                     apr_brigade_length(bb, 0, &readbytes);
                     backend->worker->s->read += readbytes;
 #if DEBUGGING
@@ -1565,7 +1565,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
            }
             return status;
         }
-    } else 
+    } else
         return OK;
 }
 
@@ -1583,7 +1583,7 @@ apr_status_t ap_proxy_http_cleanup(const char *scheme, request_rec *r,
     if (backend->close || (r->proto_num < HTTP_VERSION(1,1))) {
         backend->close_on_recycle = 1;
         ap_set_module_config(r->connection->conn_config, &proxy_http_module, NULL);
-        ap_proxy_release_connection(scheme, backend, r->server);    
+        ap_proxy_release_connection(scheme, backend, r->server);
     }
     return OK;
 }
@@ -1599,7 +1599,7 @@ apr_status_t ap_proxy_http_cleanup(const char *scheme, request_rec *r,
  */
 static int proxy_http_handler(request_rec *r, proxy_worker *worker,
                               proxy_server_conf *conf,
-                              char *url, const char *proxyname, 
+                              char *url, const char *proxyname,
                               apr_port_t proxyport)
 {
     int status;
@@ -1660,9 +1660,9 @@ static int proxy_http_handler(request_rec *r, proxy_worker *worker,
     }
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
              "proxy: HTTP: serving URL %s", url);
-    
-    
-    /* only use stored info for top-level pages. Sub requests don't share 
+
+
+    /* only use stored info for top-level pages. Sub requests don't share
      * in keepalives
      */
     if (!r->main) {
@@ -1705,7 +1705,7 @@ static int proxy_http_handler(request_rec *r, proxy_worker *worker,
                                                  c, r->server)) != OK)
             goto cleanup;
     }
-   
+
     /* Step Four: Send the Request */
     if ((status = ap_proxy_http_request(p, r, backend, backend->connection,
                                         conf, uri, url, server_portstr)) != OK)
diff --git a/modules/proxy/proxy_util.c b/modules/proxy/proxy_util.c
index 0fb499b..96a743e 100644
--- a/modules/proxy/proxy_util.c
+++ b/modules/proxy/proxy_util.c
@@ -38,7 +38,7 @@ static int proxy_match_domainname(struct dirconn_entry *This, request_rec *r);
 static int proxy_match_hostname(struct dirconn_entry *This, request_rec *r);
 static int proxy_match_word(struct dirconn_entry *This, request_rec *r);
 
-APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(proxy, PROXY, int, create_req, 
+APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(proxy, PROXY, int, create_req,
                                    (request_rec *r, request_rec *pr), (r, pr),
                                    OK, DECLINED)
 
@@ -132,7 +132,7 @@ PROXY_DECLARE(void) ap_proxy_c2hex(int ch, char *x)
  * Convert a URL-encoded string to canonical form.
  * It decodes characters which need not be encoded,
  * and encodes those which must be encoded, and does not touch
- * those which must not be touched. 
+ * those which must not be touched.
  */
 PROXY_DECLARE(char *)ap_proxy_canonenc(apr_pool_t *p, const char *x, int len, enum enctype t,
     int forcedec, int proxyreq)
@@ -495,14 +495,14 @@ PROXY_DECLARE(void) ap_proxy_sec2hex(int t, char *y)
 PROXY_DECLARE(int) ap_proxyerror(request_rec *r, int statuscode, const char *message)
 {
     apr_table_setn(r->notes, "error-notes",
-    apr_pstrcat(r->pool, 
+    apr_pstrcat(r->pool,
         "The proxy server could not handle the request "
         "<em><a href=\"", ap_escape_uri(r->pool, r->uri),
         "\">", ap_escape_html(r->pool, r->method),
-        "&nbsp;", 
+        "&nbsp;",
         ap_escape_html(r->pool, r->uri), "</a></em>.<p>\n"
         "Reason: <strong>",
-        ap_escape_html(r->pool, message), 
+        ap_escape_html(r->pool, message),
         "</strong></p>", NULL));
 
     /* Allow "error-notes" string to be printed by ap_send_error_response() */
@@ -698,7 +698,7 @@ static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r)
         != APR_SUCCESS) {
 #if DEBUGGING
         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-             "2)IP-NoMatch: hostname=%s msg=Host not found", 
+             "2)IP-NoMatch: hostname=%s msg=Host not found",
              host);
 #endif
         return 0;
@@ -711,7 +711,7 @@ static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r)
         if (This->addr.s_addr == (ip->s_addr & This->mask.s_addr)) {
 #if DEBUGGING
         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                 "3)IP-Match: %s[%s] <-> ", host, 
+                 "3)IP-Match: %s[%s] <-> ", host,
                  inet_ntoa(*ip));
         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                  "%s/", inet_ntoa(This->addr));
@@ -723,7 +723,7 @@ static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r)
 #if DEBUGGING
         else {
                 ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                 "3)IP-NoMatch: %s[%s] <-> ", host, 
+                 "3)IP-NoMatch: %s[%s] <-> ", host,
                  inet_ntoa(*ip));
                 ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                  "%s/", inet_ntoa(This->addr));
@@ -868,7 +868,7 @@ static int proxy_match_word(struct dirconn_entry *This, request_rec *r)
 }
 
 /* checks whether a host in uri_addr matches proxyblock */
-PROXY_DECLARE(int) ap_proxy_checkproxyblock(request_rec *r, proxy_server_conf *conf, 
+PROXY_DECLARE(int) ap_proxy_checkproxyblock(request_rec *r, proxy_server_conf *conf,
                              apr_sockaddr_t *uri_addr)
 {
     int j;
@@ -915,7 +915,7 @@ PROXY_DECLARE(int) ap_proxy_pre_http_request(conn_rec *c, request_rec *r)
 }
 
 /*
- * converts a series of buckets into a string 
+ * converts a series of buckets into a string
  * XXX: BillS says this function performs essentially the same function as
  * ap_rgetline() in protocol.c. Deprecate this function and use ap_rgetline()
  * instead? I think ap_proxy_string_read() will not work properly on non ASCII
@@ -938,7 +938,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_string_read(conn_rec *c, apr_bucket_brigade
     /* loop through each brigade */
     while (!found) {
         /* get brigade from network one line at a time */
-        if (APR_SUCCESS != (rv = ap_get_brigade(c->input_filters, bb, 
+        if (APR_SUCCESS != (rv = ap_get_brigade(c->input_filters, bb,
                                                 AP_MODE_GETLINE,
                                                 APR_BLOCK_READ,
                                                 0))) {
@@ -1149,7 +1149,7 @@ PROXY_DECLARE(proxy_balancer *) ap_proxy_get_balancer(apr_pool_t *p,
     char *c, *uri = apr_pstrdup(p, url);
     int i;
 
-    c = strchr(uri, ':');   
+    c = strchr(uri, ':');
     if (c == NULL || c[1] != '/' || c[2] != '/' || c[3] == '\0')
        return NULL;
     /* remove path from uri */
@@ -1243,7 +1243,7 @@ PROXY_DECLARE(proxy_worker *) ap_proxy_get_worker(apr_pool_t *p,
     } else {
         ap_str_tolower(url_copy);
     }
-    
+
     worker = (proxy_worker *)conf->workers->elts;
 
     /*
@@ -1280,7 +1280,7 @@ static void init_conn_pool(apr_pool_t *p, proxy_worker *worker)
     proxy_conn_pool *cp;
 
     /*
-     * Create a connection pool's subpool. 
+     * Create a connection pool's subpool.
      * This pool is used for connection recycling.
      * Once the worker is added it is never removed but
      * it can be disabled.
@@ -1288,10 +1288,10 @@ static void init_conn_pool(apr_pool_t *p, proxy_worker *worker)
     apr_pool_create(&pool, p);
     /*
      * Alloc from the same pool as worker.
-     * proxy_conn_pool is permanently attached to the worker. 
+     * proxy_conn_pool is permanently attached to the worker.
      */
     cp = (proxy_conn_pool *)apr_pcalloc(p, sizeof(proxy_conn_pool));
-    cp->pool = pool;    
+    cp->pool = pool;
     worker->cp = cp;
 }
 
@@ -1345,7 +1345,7 @@ PROXY_DECLARE(proxy_worker *) ap_proxy_create_worker(apr_pool_t *p)
     return worker;
 }
 
-PROXY_DECLARE(void) 
+PROXY_DECLARE(void)
 ap_proxy_add_worker_to_balancer(apr_pool_t *pool, proxy_balancer *balancer,
                                 proxy_worker *worker)
 {
@@ -1562,7 +1562,7 @@ static apr_status_t connection_destructor(void *resource, void *params,
 {
     proxy_conn_rec *conn = (proxy_conn_rec *)resource;
 
-    /* Destroy the pool only if not called from reslist_destroy */    
+    /* Destroy the pool only if not called from reslist_destroy */
     if (conn->worker->cp->pool)
         apr_pool_destroy(conn->pool);
 
@@ -1645,7 +1645,7 @@ PROXY_DECLARE(apr_status_t) ap_proxy_initialize_worker(proxy_worker *worker, ser
             worker->smax = worker->hmax;
         /* Set min to be lower then smax */
         if (worker->min > worker->smax)
-            worker->min = worker->smax; 
+            worker->min = worker->smax;
     }
     else {
         /* This will supress the apr_reslist creation */
@@ -1813,7 +1813,7 @@ ap_proxy_determine_connection(apr_pool_t *p, request_rec *r,
                  uri->port);
 
     /*
-     * allocate these out of the specified connection pool 
+     * allocate these out of the specified connection pool
      * The scheme handler decides if this is permanent or
      * short living pool.
      */
@@ -1918,7 +1918,7 @@ static int is_socket_connected(apr_socket_t *sock)
 
 {
     apr_size_t buffer_len = 1;
-    char test_buffer[1]; 
+    char test_buffer[1];
     apr_status_t socket_status;
     apr_interval_time_t current_timeout;
 
@@ -1995,7 +1995,7 @@ PROXY_DECLARE(int) ap_proxy_connect_backend(const char *proxy_function,
         }
         /* Set a keepalive option */
         if (worker->keepalive) {
-            if ((rv = apr_socket_opt_set(newsock, 
+            if ((rv = apr_socket_opt_set(newsock,
                             APR_SO_KEEPALIVE, 1)) != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                              "apr_socket_opt_set(SO_KEEPALIVE): Failed to set"
@@ -2088,7 +2088,7 @@ PROXY_DECLARE(int) ap_proxy_connection_create(const char *proxy_function,
         if (!ap_proxy_ssl_enable(conn->connection)) {
             ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                          s, "proxy: %s: failed to enable ssl support "
-                         "for %pI (%s)", proxy_function, 
+                         "for %pI (%s)", proxy_function,
                          backend_addr, conn->hostname);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
diff --git a/modules/ssl/mod_ssl.c b/modules/ssl/mod_ssl.c
index af91fa5..6602a31 100644
--- a/modules/ssl/mod_ssl.c
+++ b/modules/ssl/mod_ssl.c
@@ -146,7 +146,7 @@ static const command_rec ssl_config_cmds[] = {
     SSL_CMD_ALL(UserName, TAKE1,
                 "Set user name to SSL variable value")
 
-    /* 
+    /*
      * Proxy configuration for remote SSL connections
      */
     SSL_CMD_SRV(ProxyEngine, FLAG,
@@ -197,11 +197,11 @@ static const command_rec ssl_config_cmds[] = {
                "(arbitrary complex boolean expression - see manual)")
 
     /* Deprecated directives. */
-    AP_INIT_RAW_ARGS("SSLLog", ap_set_deprecated, NULL, OR_ALL, 
+    AP_INIT_RAW_ARGS("SSLLog", ap_set_deprecated, NULL, OR_ALL,
       "SSLLog directive is no longer supported - use ErrorLog."),
-    AP_INIT_RAW_ARGS("SSLLogLevel", ap_set_deprecated, NULL, OR_ALL, 
+    AP_INIT_RAW_ARGS("SSLLogLevel", ap_set_deprecated, NULL, OR_ALL,
       "SSLLogLevel directive is no longer supported - use LogLevel."),
-    
+
     AP_END_CMD
 };
 
@@ -238,8 +238,8 @@ static apr_status_t ssl_cleanup_pre_config(void *data)
      * actually load the error strings once per process due to static
      * variable abuse in OpenSSL. */
 
-    /* 
-     * TODO: determine somewhere we can safely shove out diagnostics 
+    /*
+     * TODO: determine somewhere we can safely shove out diagnostics
      *       (when enabled) at this late stage in the game:
      * CRYPTO_mem_leaks_fp(stderr);
      */
@@ -250,7 +250,7 @@ static int ssl_hook_pre_config(apr_pool_t *pconf,
                                apr_pool_t *plog,
                                apr_pool_t *ptemp)
 {
-    /* We must register the library in full, to ensure our configuration 
+    /* We must register the library in full, to ensure our configuration
      * code can successfully test the SSL environment.
      */
     CRYPTO_malloc_init();
@@ -480,7 +480,7 @@ static void ssl_hook_Insert_Filter(request_rec *r)
 static void ssl_register_hooks(apr_pool_t *p)
 {
     /* ssl_hook_ReadReq needs to use the BrowserMatch settings so must
-     * run after mod_setenvif's post_read_request hook. */ 
+     * run after mod_setenvif's post_read_request hook. */
     static const char *pre_prr[] = { "mod_setenvif.c", NULL };
 
     ssl_io_filter_register(p);
diff --git a/modules/ssl/ssl_engine_config.c b/modules/ssl/ssl_engine_config.c
index 640837a..3105c15 100644
--- a/modules/ssl/ssl_engine_config.c
+++ b/modules/ssl/ssl_engine_config.c
@@ -345,7 +345,7 @@ const char *ssl_cmd_SSLMutex(cmd_parms *cmd,
             file = NULL;
         }
     }
-    
+
     if ((err = ap_check_cmd_context(cmd, GLOBAL_ONLY))) {
         return err;
     }
@@ -382,7 +382,7 @@ const char *ssl_cmd_SSLMutex(cmd_parms *cmd,
 #if APR_HAS_POSIXSEM_SERIALIZE
     else if (!strcasecmp(meth, "posixsem") || !strcasecmp(meth, "sem")) {
         mc->nMutexMech = APR_LOCK_POSIXSEM;
-        /* Posix/SysV semaphores aren't file based, use the literal name 
+        /* Posix/SysV semaphores aren't file based, use the literal name
          * if provided and fall back on APR's default if not.  Today, APR
          * will ignore it, but once supported it has an absurdly short limit.
          */
@@ -415,7 +415,7 @@ const char *ssl_cmd_SSLMutex(cmd_parms *cmd,
     if (file) {
         mc->szMutexFile = ap_server_root_relative(cmd->server->process->pool, file);
         if (!mc->szMutexFile) {
-            return apr_pstrcat(cmd->pool, "Invalid SSLMutex ", meth, 
+            return apr_pstrcat(cmd->pool, "Invalid SSLMutex ", meth,
                                ": filepath ", file, NULL);
         }
     }
@@ -493,10 +493,10 @@ const char *ssl_cmd_SSLCryptoDevice(cmd_parms *cmd,
     else {
         err = "SSLCryptoDevice: Invalid argument; must be one of: "
               "'builtin' (none)";
-        e = ENGINE_get_first(); 
+        e = ENGINE_get_first();
         while (e) {
             ENGINE *en;
-            err = apr_pstrcat(cmd->pool, err, ", '", ENGINE_get_id(e), 
+            err = apr_pstrcat(cmd->pool, err, ", '", ENGINE_get_id(e),
                                          "' (", ENGINE_get_name(e), ")", NULL);
             en = ENGINE_get_next(e);
             ENGINE_free(e);
@@ -511,7 +511,7 @@ const char *ssl_cmd_SSLCryptoDevice(cmd_parms *cmd,
 
 const char *ssl_cmd_SSLRandomSeed(cmd_parms *cmd,
                                   void *dcfg,
-                                  const char *arg1, 
+                                  const char *arg1,
                                   const char *arg2,
                                   const char *arg3)
 {
@@ -658,7 +658,7 @@ static const char *ssl_cmd_check_file(cmd_parms *parms,
     }
 
     return apr_pstrcat(parms->pool, parms->cmd->name,
-                       ": file '", *file, 
+                       ": file '", *file,
                        "' does not exist or is empty", NULL);
 
 }
@@ -690,7 +690,7 @@ static const char *ssl_cmd_check_dir(cmd_parms *parms,
     }
 
     return apr_pstrcat(parms->pool, parms->cmd->name,
-                       ": directory '", *dir, 
+                       ": directory '", *dir,
                        "' does not exist", NULL);
 
 }
@@ -730,7 +730,7 @@ static const char *ssl_cmd_check_aidx_max(cmd_parms *parms,
 
     return apr_psprintf(parms->pool,
                         "%s: only up to %d "
-                        "different %s per virtual host allowed", 
+                        "different %s per virtual host allowed",
                          parms->cmd->name, SSL_AIDX_MAX, desc);
 }
 
@@ -930,7 +930,7 @@ const char *ssl_cmd_SSLVerifyClient(cmd_parms *cmd,
     if ((err = ssl_cmd_verify_parse(cmd, arg, &mode))) {
         return err;
     }
-    
+
     if (cmd->path) {
         dc->nVerifyClient = mode;
     }
@@ -1064,7 +1064,7 @@ const char *ssl_cmd_SSLSessionCache(cmd_parms *cmd,
         mc->nSessionCacheMode      = SSL_SCMODE_DC;
         mc->szSessionCacheDataFile = apr_pstrdup(mc->pPool, arg+3);
         if (!mc->szSessionCacheDataFile) {
-            return apr_pstrcat(cmd->pool, 
+            return apr_pstrcat(cmd->pool,
                                "SSLSessionCache: Invalid cache file path: ",
                                arg+3, NULL);
         }
@@ -1252,7 +1252,7 @@ const char *ssl_cmd_SSLProxyEngine(cmd_parms *cmd, void *dcfg, int flag)
     return NULL;
 }
 
-const char *ssl_cmd_SSLProxyProtocol(cmd_parms *cmd, 
+const char *ssl_cmd_SSLProxyProtocol(cmd_parms *cmd,
                                      void *dcfg,
                                      const char *arg)
 {
@@ -1403,7 +1403,7 @@ const char *ssl_cmd_SSLProxyMachineCertificatePath(cmd_parms *cmd,
 }
 
 
-const char *ssl_cmd_SSLUserName(cmd_parms *cmd, void *dcfg, 
+const char *ssl_cmd_SSLUserName(cmd_parms *cmd, void *dcfg,
                                 const char *arg)
 {
     SSLDirConfigRec *dc = (SSLDirConfigRec *)dcfg;
diff --git a/modules/ssl/ssl_engine_dh.c b/modules/ssl/ssl_engine_dh.c
index 0b9107f..89c4d49 100644
--- a/modules/ssl/ssl_engine_dh.c
+++ b/modules/ssl/ssl_engine_dh.c
@@ -24,7 +24,7 @@
  * | | | | | | (_) | (_| |   \__ \__ \ |
  * |_| |_| |_|\___/ \__,_|___|___/___/_|
  *                      |_____|
- * ssl_engine_dh.c 
+ * ssl_engine_dh.c
  * Diffie-Hellman Built-in Temporary Parameters
  */
 
@@ -153,7 +153,7 @@ close(FP);
 #   generate the DH parameters
 print "1. Generate 512 and 1024 bit Diffie-Hellman parameters (p, g)\n";
 my $rand = '';
-foreach $file (qw(/var/log/messages /var/adm/messages 
+foreach $file (qw(/var/log/messages /var/adm/messages
                   /kernel /vmunix /vmlinuz /etc/hosts /etc/resolv.conf)) {
     if (-f $file) {
         $rand = $file     if ($rand eq '');
@@ -164,7 +164,7 @@ $rand = "-rand $rand" if ($rand ne '');
 system("openssl gendh $rand -out dh512.pem 512");
 system("openssl gendh $rand -out dh1024.pem 1024");
 
-#   generate DH param info 
+#   generate DH param info
 my $dhinfo = '';
 open(FP, "openssl dh -noout -text -in dh512.pem |") || die;
 $dhinfo .= $_ while (<FP>);
diff --git a/modules/ssl/ssl_engine_init.c b/modules/ssl/ssl_engine_init.c
index 8ba727c..54c85fd 100644
--- a/modules/ssl/ssl_engine_init.c
+++ b/modules/ssl/ssl_engine_init.c
@@ -171,7 +171,7 @@ int ssl_init_Module(apr_pool_t *p, apr_pool_t *plog,
      * but it should be initialized for startup before we
      * call ssl_rand_seed() below.
      */
-    mc->pid = getpid(); 
+    mc->pid = getpid();
 
     /*
      * Let us cleanup on restarts and exists
@@ -207,7 +207,7 @@ int ssl_init_Module(apr_pool_t *p, apr_pool_t *plog,
         sc->vhost_id = ssl_util_vhostid(p, s);
         sc->vhost_id_len = strlen(sc->vhost_id);
 
-        if (ap_get_server_protocol(s) && 
+        if (ap_get_server_protocol(s) &&
             strcmp("https", ap_get_server_protocol(s)) == 0) {
             sc->enabled = SSL_ENABLED_TRUE;
         }
@@ -460,7 +460,7 @@ static void ssl_init_ctx_protocol(server_rec *s,
     SSL_CTX_set_options(ctx, SSL_OP_SINGLE_DH_USE);
 
 #ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
-    /* 
+    /*
      * Disallow a session from being resumed during a renegotiation,
      * so that an acceptable cipher suite can be negotiated.
      */
@@ -608,7 +608,7 @@ static void ssl_init_ctx_cipher_suite(server_rec *s,
     }
 
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-                 "Configuring permitted SSL ciphers [%s]", 
+                 "Configuring permitted SSL ciphers [%s]",
                  suite);
 
     if (!SSL_CTX_set_cipher_list(ctx, MODSSL_PCHAR_CAST suite)) {
@@ -657,7 +657,7 @@ static void ssl_init_ctx_cert_chain(server_rec *s,
     int i, n;
     const char *chain = mctx->cert_chain;
 
-    /* 
+    /*
      * Optionally configure extra server certificate chain certificates.
      * This is usually done by OpenSSL automatically when one of the
      * server cert issuers are found under SSLCACertificatePath or in
@@ -683,7 +683,7 @@ static void ssl_init_ctx_cert_chain(server_rec *s,
     }
 
     n = SSL_CTX_use_certificate_chain(mctx->ssl_ctx,
-                                      (char *)chain, 
+                                      (char *)chain,
                                       skip_first, NULL);
     if (n < 0) {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
@@ -833,7 +833,7 @@ static void ssl_check_public_cert(server_rec *s,
     if (SSL_X509_isSGC(cert)) {
         ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
                      "%s server certificate enables "
-                     "Server Gated Cryptography (SGC)", 
+                     "Server Gated Cryptography (SGC)",
                      ssl_asn1_keystr(type));
     }
 
@@ -1019,7 +1019,7 @@ void ssl_init_CheckServers(server_rec *base_server, apr_pool_t *p)
     BOOL conflict = FALSE;
 
     /*
-     * Give out warnings when a server has HTTPS configured 
+     * Give out warnings when a server has HTTPS configured
      * for the HTTP port or vice versa
      */
     for (s = base_server; s; s = s->next) {
@@ -1070,11 +1070,11 @@ void ssl_init_CheckServers(server_rec *base_server, apr_pool_t *p)
                          base_server,
                          "Init: SSL server IP/port conflict: "
                          "%s (%s:%d) vs. %s (%s:%d)",
-                         ssl_util_vhostid(p, s), 
+                         ssl_util_vhostid(p, s),
                          (s->defn_name ? s->defn_name : "unknown"),
                          s->defn_line_number,
                          ssl_util_vhostid(p, ps),
-                         (ps->defn_name ? ps->defn_name : "unknown"), 
+                         (ps->defn_name ? ps->defn_name : "unknown"),
                          ps->defn_line_number);
             conflict = TRUE;
             continue;
@@ -1258,7 +1258,7 @@ apr_status_t ssl_init_ModuleKill(void *data)
      */
     ssl_scache_kill(base_server);
 
-    /* 
+    /*
      * Destroy the temporary keys and params
      */
     ssl_tmp_keys_free(base_server);
diff --git a/modules/ssl/ssl_engine_io.c b/modules/ssl/ssl_engine_io.c
index 5527a5e..0093e3b 100644
--- a/modules/ssl/ssl_engine_io.c
+++ b/modules/ssl/ssl_engine_io.c
@@ -64,10 +64,10 @@
  * - The char* is placed in a brigade and returned
  *
  * Since connection-level input filters in httpd need to be able to
- * handle AP_MODE_GETLINE calls (namely identifying LF-terminated strings), 
+ * handle AP_MODE_GETLINE calls (namely identifying LF-terminated strings),
  * ssl_io_input_getline which will handle this special case.
  *
- * Due to AP_MODE_GETLINE and AP_MODE_SPECULATIVE, we may sometimes have 
+ * Due to AP_MODE_GETLINE and AP_MODE_SPECULATIVE, we may sometimes have
  * 'leftover' decoded data which must be setaside for the next read.  That
  * is currently handled by the char_buffer_{read|write} functions.  So,
  * ssl_io_input_read may be able to fulfill reads without invoking
@@ -81,7 +81,7 @@
  *
  */
 
-/* this custom BIO allows us to hook SSL_write directly into 
+/* this custom BIO allows us to hook SSL_write directly into
  * an apr_bucket_brigade and use transient buckets with the SSL
  * malloc-ed buffer, rather than copying into a mem BIO.
  * also allows us to pass the brigade as data is being written
@@ -141,7 +141,7 @@ static int bio_filter_out_flush(BIO *bio)
     if (outctx->blen) {
         e = apr_bucket_transient_create(outctx->buffer, outctx->blen,
                                         outctx->bb->bucket_alloc);
-        /* we filled this buffer first so add it to the 
+        /* we filled this buffer first so add it to the
          * head of the brigade
          */
         APR_BRIGADE_INSERT_HEAD(outctx->bb, e);
@@ -182,7 +182,7 @@ static int bio_filter_destroy(BIO *bio)
      */
     return 1;
 }
-        
+
 static int bio_filter_out_read(BIO *bio, char *out, int outl)
 {
     /* this is never called */
@@ -213,7 +213,7 @@ static int bio_filter_out_write(BIO *bio, const char *in, int inl)
     }
     else {
         /* pass along the encrypted data
-         * need to flush since we're using SSL's malloc-ed buffer 
+         * need to flush since we're using SSL's malloc-ed buffer
          * which will be overwritten once we leave here
          */
         apr_bucket *bucket = apr_bucket_transient_create(in, inl,
@@ -375,7 +375,7 @@ static apr_status_t brigade_consume(apr_bucket_brigade *bb,
 {
     apr_size_t actual = 0;
     apr_status_t status = APR_SUCCESS;
- 
+
     while (!APR_BRIGADE_EMPTY(bb)) {
         apr_bucket *b = APR_BRIGADE_FIRST(bb);
         const char *str;
@@ -398,11 +398,11 @@ static apr_status_t brigade_consume(apr_bucket_brigade *bb,
          * this sort of case (caller provided buffer) it
          * would be much more trivial for apr_bucket_consume
          * to do all the work that follows, based on the
-         * particular characteristics of the bucket we are 
+         * particular characteristics of the bucket we are
          * consuming here.
          */
         status = apr_bucket_read(b, &str, &str_len, block);
-        
+
         if (status != APR_SUCCESS) {
             if (APR_STATUS_IS_EOF(status)) {
                 /* This stream bucket was consumed */
@@ -471,7 +471,7 @@ static int bio_filter_in_read(BIO *bio, char *in, int inlen)
      */
     if ((SSL_version(inctx->ssl) == SSL2_VERSION) || sslconn->is_proxy) {
         if (bio_filter_out_flush(inctx->bio_out) < 0) {
-            bio_filter_out_ctx_t *outctx = 
+            bio_filter_out_ctx_t *outctx =
                    (bio_filter_out_ctx_t *)(inctx->bio_out->ptr);
             inctx->rc = outctx->rc;
             return -1;
@@ -488,7 +488,7 @@ static int bio_filter_in_read(BIO *bio, char *in, int inlen)
     if (APR_BRIGADE_EMPTY(inctx->bb)) {
 
         inctx->rc = ap_get_brigade(inctx->f->next, inctx->bb,
-                                   AP_MODE_READBYTES, block, 
+                                   AP_MODE_READBYTES, block,
                                    inl);
 
         /* If the read returns EAGAIN or success with an empty
@@ -515,12 +515,12 @@ static int bio_filter_in_read(BIO *bio, char *in, int inlen)
         return (int)inl;
     }
 
-    if (APR_STATUS_IS_EAGAIN(inctx->rc) 
+    if (APR_STATUS_IS_EAGAIN(inctx->rc)
             || APR_STATUS_IS_EINTR(inctx->rc)) {
         BIO_set_retry_read(bio);
         return (int)inl;
     }
-        
+
     /* Unexpected errors and APR_EOF clean out the brigade.
      * Subsequent calls will return APR_EOF.
      */
@@ -625,7 +625,7 @@ static apr_status_t ssl_io_input_read(bio_filter_in_ctx_t *inctx,
              */
             if (APR_STATUS_IS_EAGAIN(inctx->rc)
                     || APR_STATUS_IS_EINTR(inctx->rc)) {
-                /* Already read something, return APR_SUCCESS instead. 
+                /* Already read something, return APR_SUCCESS instead.
                  * On win32 in particular, but perhaps on other kernels,
                  * a blocking call isn't 'always' blocking.
                  */
@@ -725,7 +725,7 @@ static apr_status_t ssl_io_input_getline(bio_filter_in_ctx_t *inctx,
 
     while (tmplen > 0) {
         status = ssl_io_input_read(inctx, buf + offset, &tmplen);
-        
+
         if (status != APR_SUCCESS) {
             return status;
         }
@@ -815,7 +815,7 @@ static apr_status_t ssl_filter_write(ap_filter_t *f,
         }
 
         ap_log_cerror(APLOG_MARK, APLOG_INFO, outctx->rc, c,
-                      "failed to write %" APR_SSIZE_T_FMT 
+                      "failed to write %" APR_SSIZE_T_FMT
                       " of %" APR_SIZE_T_FMT " bytes (%s)",
                       len - (apr_size_t)res, len, reason);
 
@@ -887,7 +887,7 @@ static const char ssl_io_buffer[] = "SSL/TLS Buffer";
 /*
  *  Close the SSL part of the socket connection
  *  (called immediately _before_ the socket is closed)
- *  or called with 
+ *  or called with
  */
 static apr_status_t ssl_filter_io_shutdown(ssl_filter_ctx_t *filter_ctx,
                                            conn_rec *c,
@@ -974,7 +974,7 @@ static apr_status_t ssl_filter_io_shutdown(ssl_filter_ctx_t *filter_ctx,
     if (c->base_server->loglevel >= APLOG_INFO) {
         ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,
                       "Connection closed to child %ld with %s shutdown "
-                      "(server %s)", 
+                      "(server %s)",
                       c->id, type, ssl_util_vhostid(c->pool, c->base_server));
     }
 
@@ -1006,7 +1006,7 @@ static apr_status_t ssl_io_filter_cleanup(void *data)
         SSL_free(filter_ctx->pssl);
         sslconn->ssl = filter_ctx->pssl = NULL;
     }
-  
+
     return APR_SUCCESS;
 }
 
@@ -1051,7 +1051,7 @@ static int ssl_io_filter_connect(ssl_filter_ctx_t *filter_ctx)
                                        (filter_ctx->pbioWrite->ptr);
         apr_status_t rc = inctx->rc ? inctx->rc : outctx->rc ;
         ssl_err = SSL_get_error(filter_ctx->pssl, n);
-        
+
         if (ssl_err == SSL_ERROR_ZERO_RETURN) {
             /*
              * The case where the connection was closed before any data
@@ -1063,7 +1063,7 @@ static int ssl_io_filter_connect(ssl_filter_ctx_t *filter_ctx)
         }
         else if (ssl_err == SSL_ERROR_WANT_READ) {
             /*
-             * This is in addition to what was present earlier. It is 
+             * This is in addition to what was present earlier. It is
              * borrowed from openssl_state_machine.c [mod_tls].
              * TBD.
              */
@@ -1117,7 +1117,7 @@ static int ssl_io_filter_connect(ssl_filter_ctx_t *filter_ctx)
             /* leaving this log message as an error for the moment,
              * according to the mod_ssl docs:
              * "level optional_no_ca is actually against the idea
-             *  of authentication (but can be used to establish 
+             *  of authentication (but can be used to establish
              * SSL test pages, etc.)"
              * optional_no_ca doesn't appear to work as advertised
              * in 1.x
@@ -1205,20 +1205,20 @@ static apr_status_t ssl_io_filter_Upgrade(ap_filter_t *f,
 
     /* Send the interim 101 response. */
     upgradebb = apr_brigade_create(r->pool, f->c->bucket_alloc);
-    
+
     ap_fputstrs(f->next, upgradebb, SWITCH_STATUS_LINE, CRLF,
                 UPGRADE_HEADER, CRLF, CONNECTION_HEADER, CRLF, CRLF, NULL);
 
     b = apr_bucket_flush_create(f->c->bucket_alloc);
     APR_BRIGADE_INSERT_TAIL(upgradebb, b);
-    
+
     rv = ap_pass_brigade(f->next, upgradebb);
     if (rv) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                       "could not send interim 101 Upgrade response");
         return AP_FILTER_ERROR;
     }
-    
+
     ssl_init_ssl_connection(f->c);
 
     ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
@@ -1228,7 +1228,7 @@ static apr_status_t ssl_io_filter_Upgrade(ap_filter_t *f,
     ssl = sslconn->ssl;
 
     /* XXX: Should replace SSL_set_state with SSL_renegotiate(ssl);
-     * However, this causes failures in perl-framework currently, 
+     * However, this causes failures in perl-framework currently,
      * perhaps pre-test if we have already negotiated?
      */
     SSL_set_accept_state(ssl);
@@ -1242,8 +1242,8 @@ static apr_status_t ssl_io_filter_Upgrade(ap_filter_t *f,
         return AP_FILTER_ERROR;
     }
 
-    /* Now that we have initialized the ssl connection which added the ssl_io_filter, 
-       pass the brigade off to the connection based output filters so that the 
+    /* Now that we have initialized the ssl connection which added the ssl_io_filter,
+       pass the brigade off to the connection based output filters so that the
        request can complete encrypted */
     return ap_pass_brigade(f->c->output_filters, bb);
 
@@ -1276,7 +1276,7 @@ static apr_status_t ssl_io_filter_input(ap_filter_t *f,
     }
 
     /* XXX: we don't currently support anything other than these modes. */
-    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE && 
+    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE &&
         mode != AP_MODE_SPECULATIVE && mode != AP_MODE_INIT) {
         return APR_ENOTIMPL;
     }
@@ -1300,9 +1300,9 @@ static apr_status_t ssl_io_filter_input(ap_filter_t *f,
         return APR_SUCCESS;
     }
 
-    if (inctx->mode == AP_MODE_READBYTES || 
+    if (inctx->mode == AP_MODE_READBYTES ||
         inctx->mode == AP_MODE_SPECULATIVE) {
-        /* Protected from truncation, readbytes < MAX_SIZE_T 
+        /* Protected from truncation, readbytes < MAX_SIZE_T
          * FIXME: No, it's *not* protected.  -- jre */
         if (readbytes < len) {
             len = (apr_size_t)readbytes;
@@ -1367,8 +1367,8 @@ static apr_status_t ssl_io_filter_output(ap_filter_t *f,
     while (!APR_BRIGADE_EMPTY(bb)) {
         apr_bucket *bucket = APR_BRIGADE_FIRST(bb);
 
-        /* If it is a flush or EOS, we need to pass this down. 
-         * These types do not require translation by OpenSSL.  
+        /* If it is a flush or EOS, we need to pass this down.
+         * These types do not require translation by OpenSSL.
          */
         if (APR_BUCKET_IS_EOS(bucket) || APR_BUCKET_IS_FLUSH(bucket)) {
             if (bio_filter_out_flush(filter_ctx->pbioWrite) < 0) {
@@ -1416,7 +1416,7 @@ static apr_status_t ssl_io_filter_output(ap_filter_t *f,
             /* filter output */
             const char *data;
             apr_size_t len;
-            
+
             status = apr_bucket_read(bucket, &data, &len, rblock);
 
             if (APR_STATUS_IS_EAGAIN(status)) {
@@ -1464,7 +1464,7 @@ int ssl_io_buffer_fill(request_rec *r)
     apr_bucket_brigade *tempb;
     apr_off_t total = 0; /* total length buffered */
     int eos = 0; /* non-zero once EOS is seen */
-    
+
     /* Create the context which will be passed to the input filter;
      * containing a setaside pool and a brigade which constrain the
      * lifetime of the buffered data. */
@@ -1493,10 +1493,10 @@ int ssl_io_buffer_fill(request_rec *r)
                           "could not read request body for SSL buffer");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
-        
+
         /* Iterate through the returned brigade: setaside each bucket
          * into the context's pool and move it into the brigade. */
-        for (e = APR_BRIGADE_FIRST(tempb); 
+        for (e = APR_BRIGADE_FIRST(tempb);
              e != APR_BRIGADE_SENTINEL(tempb) && !eos; e = next) {
             const char *data;
             apr_size_t len;
@@ -1514,19 +1514,19 @@ int ssl_io_buffer_fill(request_rec *r)
                 }
                 total += len;
             }
-                
+
             rv = apr_bucket_setaside(e, ctx->pool);
             if (rv != APR_SUCCESS) {
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                               "could not setaside bucket for SSL buffer");
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
-            
+
             APR_BUCKET_REMOVE(e);
             APR_BRIGADE_INSERT_TAIL(ctx->bb, e);
         }
 
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, 
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
                       "total of %" APR_OFF_T_FMT " bytes in buffer, eos=%d",
                       total, eos);
 
@@ -1587,7 +1587,7 @@ static apr_status_t ssl_io_filter_buffer(ap_filter_t *f,
             apr_bucket *d = APR_BRIGADE_FIRST(ctx->bb);
 
             e = APR_BUCKET_PREV(e);
-            
+
             /* Unsplice the partitioned segment and move it into the
              * passed-in brigade; no convenient way to do this with
              * the APR_BRIGADE_* macros. */
@@ -1612,7 +1612,7 @@ static apr_status_t ssl_io_filter_buffer(ap_filter_t *f,
 
     if (APR_BRIGADE_EMPTY(ctx->bb)) {
         apr_bucket *e = APR_BRIGADE_LAST(bb);
-        
+
         /* Ensure that the brigade is terminated by an EOS if the
          * buffered request body has been entirely consumed. */
         if (e == APR_BRIGADE_SENTINEL(bb) || !APR_BUCKET_IS_EOS(e)) {
@@ -1690,7 +1690,7 @@ void ssl_io_filter_register(apr_pool_t *p)
 
     ap_register_input_filter  (ssl_io_filter, ssl_io_filter_input,  NULL, AP_FTYPE_CONNECTION + 5);
     ap_register_output_filter (ssl_io_filter, ssl_io_filter_output, NULL, AP_FTYPE_CONNECTION + 5);
-    
+
     ap_register_input_filter  (ssl_io_buffer, ssl_io_filter_buffer, NULL, AP_FTYPE_PROTOCOL - 1);
 
     return;
diff --git a/modules/ssl/ssl_engine_kernel.c b/modules/ssl/ssl_engine_kernel.c
index 032e142..688cb47 100644
--- a/modules/ssl/ssl_engine_kernel.c
+++ b/modules/ssl/ssl_engine_kernel.c
@@ -74,7 +74,7 @@ int ssl_hook_ReadReq(request_rec *r)
          * with using SSL on this request.
          */
         sslconn->non_ssl_request = 0;
-        
+
 
         return HTTP_BAD_REQUEST;
     }
@@ -191,7 +191,7 @@ int ssl_hook_Access(request_rec *r)
             return HTTP_UPGRADE_REQUIRED;
         }
 
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, 
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "access to %s failed, reason: %s",
                       r->filename, "SSL connection required");
 
@@ -214,8 +214,8 @@ int ssl_hook_Access(request_rec *r)
      * reconfigured parameter suite. But Apache's internal API processing
      * makes our life very hard here, because when internal sub-requests occur
      * we nevertheless should avoid multiple unnecessary SSL handshakes (they
-     * require extra network I/O and especially time to perform). 
-     * 
+     * require extra network I/O and especially time to perform).
+     *
      * But the optimization for filtering out the unnecessary handshakes isn't
      * obvious and trivial.  Especially because while Apache is in its
      * sub-request processing the client could force additional handshakes,
@@ -369,7 +369,7 @@ int ssl_hook_Access(request_rec *r)
      * override of SSLVerifyClient
      *
      * We force a renegotiation if the reconfigured/new verify type is
-     * stronger than the currently active verify type. 
+     * stronger than the currently active verify type.
      *
      * The order is: none << optional_no_ca << optional << require
      *
@@ -498,7 +498,7 @@ int ssl_hook_Access(request_rec *r)
      * handshake immediately; once the SSL library moves to the
      * "accept" state, it will reject the SSL packets which the client
      * is sending for the request body.
-     * 
+     *
      * To allow authentication to complete in this auth hook, the
      * solution used here is to fill a (bounded) buffer with the
      * request body, and then to reinject that request body later.
@@ -633,7 +633,7 @@ int ssl_hook_Access(request_rec *r)
                          "Awaiting re-negotiation handshake");
 
             /* XXX: Should replace SSL_set_state with SSL_renegotiate(ssl);
-             * However, this causes failures in perl-framework currently, 
+             * However, this causes failures in perl-framework currently,
              * perhaps pre-test if we have already negotiated?
              */
             SSL_set_state(ssl, SSL_ST_ACCEPT);
@@ -686,7 +686,7 @@ int ssl_hook_Access(request_rec *r)
                 X509_free(peercert);
             }
         }
-        
+
         /*
          * Also check that SSLCipherSuite has been enforced as expected.
          */
@@ -718,7 +718,7 @@ int ssl_hook_Access(request_rec *r)
         else
             ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                           "Failed to set r->user to '%s'", dc->szUserName);
-    } 
+    }
 
     /*
      * Check SSLRequire boolean expressions
@@ -736,7 +736,7 @@ int ssl_hook_Access(request_rec *r)
                               "SSL requirement expression: %s",
                               ssl_expr_get_error());
 
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, 
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "access to %s failed, reason: %s",
                           r->filename, cp);
 
@@ -755,7 +755,7 @@ int ssl_hook_Access(request_rec *r)
             ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                          "Failed expression: %s", req->cpExpr);
 
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, 
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "access to %s failed, reason: %s",
                           r->filename,
                           "SSL requirement expression not fulfilled "
@@ -844,13 +844,13 @@ int ssl_hook_UserCheck(request_rec *r)
      * - ssl not enabled
      * - client did not present a certificate
      */
-    if (!((sc->enabled == SSL_ENABLED_TRUE || sc->enabled == SSL_ENABLED_OPTIONAL) 
+    if (!((sc->enabled == SSL_ENABLED_TRUE || sc->enabled == SSL_ENABLED_OPTIONAL)
           && sslconn && sslconn->ssl && sslconn->client_cert) ||
         !(dc->nOptions & SSL_OPT_FAKEBASICAUTH) || r->user)
     {
         return DECLINED;
     }
-    
+
     if (!sslconn->client_dn) {
         X509_NAME *name = X509_get_subject_name(sslconn->client_cert);
         char *cp = X509_NAME_oneline(name, NULL, 0);
@@ -871,9 +871,9 @@ int ssl_hook_UserCheck(request_rec *r)
      * adding the string "xxj31ZMTZzkVA" as the password in the user file.
      * This is just the crypted variant of the word "password" ;-)
      */
-    auth_line = apr_pstrcat(r->pool, "Basic ", 
-                            ap_pbase64encode(r->pool, 
-                                             apr_pstrcat(r->pool, clientdn, 
+    auth_line = apr_pstrcat(r->pool, "Basic ",
+                            ap_pbase64encode(r->pool,
+                                             apr_pstrcat(r->pool, clientdn,
                                                          ":password", NULL)),
                             NULL);
     apr_table_set(r->headers_in, "Authorization", auth_line);
@@ -1016,7 +1016,7 @@ int ssl_hook_Fixup(request_rec *r)
      * Annotate the SSI/CGI environment with standard SSL information
      */
     /* the always present HTTPS (=HTTP over SSL) flag! */
-    apr_table_setn(env, "HTTPS", "on"); 
+    apr_table_setn(env, "HTTPS", "on");
 
     /* standard SSL environment variables */
     if (dc->nOptions & SSL_OPT_STDENVVARS) {
@@ -1131,7 +1131,7 @@ RSA *ssl_callback_TmpRSA(SSL *ssl, int export, int keylen)
     return (RSA *)mc->pTmpKeys[idx];
 }
 
-/* 
+/*
  * Hand out the already generated DH parameters...
  */
 DH *ssl_callback_TmpDH(SSL *ssl, int export, int keylen)
@@ -1214,7 +1214,7 @@ int ssl_callback_SSLVerify(int ok, X509_STORE_CTX *ctx)
     }
 
     if (verify == SSL_CVERIFY_NONE) {
-        /* 
+        /*
          * SSLProxyVerify is either not configured or set to "none".
          * (this callback doesn't happen in the server context if SSLVerify
          *  is not configured or set to "none")
@@ -1497,7 +1497,7 @@ static void modssl_proxy_info_log(server_rec *s,
     dn = X509_NAME_oneline(name, name_buf, sizeof(name_buf));
 
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-                 SSLPROXY_CERT_CB_LOG_FMT "%s, sending %s", 
+                 SSLPROXY_CERT_CB_LOG_FMT "%s, sending %s",
                  sc->vhost_id, msg, dn ? dn : "-uknown-");
 }
 
@@ -1512,7 +1512,7 @@ static void modssl_proxy_info_log(server_rec *s,
     *pkey = info->x_pkey->dec_pkey; \
     EVP_PKEY_reference_inc(*pkey)
 
-int ssl_callback_proxy_cert(SSL *ssl, MODSSL_CLIENT_CERT_CB_ARG_TYPE **x509, EVP_PKEY **pkey) 
+int ssl_callback_proxy_cert(SSL *ssl, MODSSL_CLIENT_CERT_CB_ARG_TYPE **x509, EVP_PKEY **pkey)
 {
     conn_rec *c = (conn_rec *)SSL_get_app_data(ssl);
     server_rec *s = c->base_server;
@@ -1522,8 +1522,8 @@ int ssl_callback_proxy_cert(SSL *ssl, MODSSL_CLIENT_CERT_CB_ARG_TYPE **x509, EVP
     STACK_OF(X509_NAME) *ca_list;
     STACK_OF(X509_INFO) *certs = sc->proxy->pkp->certs;
     int i, j;
-    
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, 
+
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
                  SSLPROXY_CERT_CB_LOG_FMT "entered",
                  sc->vhost_id);
 
@@ -1533,23 +1533,23 @@ int ssl_callback_proxy_cert(SSL *ssl, MODSSL_CLIENT_CERT_CB_ARG_TYPE **x509, EVP
                      "downstream server wanted client certificate "
                      "but none are configured", sc->vhost_id);
         return FALSE;
-    }                                                                     
+    }
 
     ca_list = SSL_get_client_CA_list(ssl);
 
     if (!ca_list || (sk_X509_NAME_num(ca_list) <= 0)) {
-        /* 
-         * downstream server didn't send us a list of acceptable CA certs, 
+        /*
+         * downstream server didn't send us a list of acceptable CA certs,
          * so we send the first client cert in the list.
-         */   
+         */
         info = sk_X509_INFO_value(certs, 0);
-        
+
         modssl_proxy_info_log(s, info, "no acceptable CA list");
 
         modssl_set_cert_info(info, x509, pkey);
 
         return TRUE;
-    }         
+    }
 
     for (i = 0; i < sk_X509_NAME_num(ca_list); i++) {
         ca_name = sk_X509_NAME_value(ca_list, i);
@@ -1572,7 +1572,7 @@ int ssl_callback_proxy_cert(SSL *ssl, MODSSL_CLIENT_CERT_CB_ARG_TYPE **x509, EVP
                  SSLPROXY_CERT_CB_LOG_FMT
                  "no client certificate found!?", sc->vhost_id);
 
-    return FALSE; 
+    return FALSE;
 }
 
 static void ssl_session_log(server_rec *s,
diff --git a/modules/ssl/ssl_engine_log.c b/modules/ssl/ssl_engine_log.c
index 0c1d1cc..e7766c1 100644
--- a/modules/ssl/ssl_engine_log.c
+++ b/modules/ssl/ssl_engine_log.c
@@ -56,7 +56,7 @@ static const char *ssl_log_annotation(const char *error)
 {
     int i = 0;
 
-    while (ssl_log_annotate[i].cpPattern != NULL 
+    while (ssl_log_annotate[i].cpPattern != NULL
            && ap_strcmp_match(error, ssl_log_annotate[i].cpPattern) != 0)
         i++;
 
@@ -90,12 +90,12 @@ void ssl_log_ssl_error(const char *file, int line, int level, server_rec *s)
         if (annotation) {
             ap_log_error(file, line, level, 0, s,
                          "SSL Library Error: %lu %s %s",
-                         e, err, annotation); 
+                         e, err, annotation);
         }
         else {
             ap_log_error(file, line, level, 0, s,
                          "SSL Library Error: %lu %s",
-                         e, err); 
+                         e, err);
         }
     }
 }
diff --git a/modules/ssl/ssl_engine_mutex.c b/modules/ssl/ssl_engine_mutex.c
index 65924d2..effb01d 100644
--- a/modules/ssl/ssl_engine_mutex.c
+++ b/modules/ssl/ssl_engine_mutex.c
@@ -39,7 +39,7 @@ int ssl_mutex_init(server_rec *s, apr_pool_t *p)
     SSLModConfigRec *mc = myModConfig(s);
     apr_status_t rv;
 
-    if (mc->nMutexMode == SSL_MUTEXMODE_NONE) 
+    if (mc->nMutexMode == SSL_MUTEXMODE_NONE)
         return TRUE;
 
     if (mc->pMutex) {
diff --git a/modules/ssl/ssl_engine_pphrase.c b/modules/ssl/ssl_engine_pphrase.c
index 8512892..ef5bd05 100644
--- a/modules/ssl/ssl_engine_pphrase.c
+++ b/modules/ssl/ssl_engine_pphrase.c
@@ -324,9 +324,9 @@ void ssl_pphrase_Handle(server_rec *s, apr_pool_t *p)
                     for (i=0; i < SSL_AIDX_MAX; i++) {
                         const char *key_id =
                             ssl_asn1_table_keyfmt(p, cpVHostID, i);
-                        ssl_asn1_t *asn1 = 
+                        ssl_asn1_t *asn1 =
                             ssl_asn1_table_get(mc->tPrivateKey, key_id);
-                    
+
                         if (asn1 && (asn1->source_mtime == pkey_mtime)) {
                             ap_log_error(APLOG_MARK, APLOG_INFO,
                                          0, pServ,
@@ -466,20 +466,20 @@ void ssl_pphrase_Handle(server_rec *s, apr_pool_t *p)
              * Log the type of reading
              */
             if (nPassPhraseDialogCur == 0) {
-                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, pServ, 
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, pServ,
                              "unencrypted %s private key - pass phrase not "
                              "required", an);
             }
             else {
                 if (cpPassPhraseCur != NULL) {
                     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0,
-                                 pServ, 
+                                 pServ,
                                  "encrypted %s private key - pass phrase "
                                  "requested", an);
                 }
                 else {
                     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0,
-                                 pServ, 
+                                 pServ,
                                  "encrypted %s private key - pass phrase"
                                  " reused", an);
                 }
@@ -566,7 +566,7 @@ static apr_status_t ssl_pipe_child_create(apr_pool_t *p, const char *progname)
                                    APR_NO_PIPE)) == APR_SUCCESS)) {
         char **args;
         const char *pname;
-        
+
         apr_tokenize_to_argv(progname, &args, p);
         pname = apr_pstrdup(p, args[0]);
         procnew = (apr_proc_t *)apr_pcalloc(p, sizeof(*procnew));
@@ -594,7 +594,7 @@ static int pipe_get_passwd_cb(char *buf, int length, char *prompt, int verify)
     buf[0]='\0';
     rc = apr_file_gets(buf, length, readtty);
     apr_file_puts(APR_EOL_STR, writetty);
-    
+
     if (rc != APR_SUCCESS || apr_file_eof(readtty)) {
         memset(buf, 0, length);
         return 1;  /* failure */
@@ -689,7 +689,7 @@ int ssl_pphrase_Handle_CB(char *buf, int bufsize, int verify, void *srv)
             ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
                          "Init: Requesting pass phrase via piped dialog");
         }
-        else { /* sc->server->pphrase_dialog_type == SSL_PPTYPE_BUILTIN */ 
+        else { /* sc->server->pphrase_dialog_type == SSL_PPTYPE_BUILTIN */
 #ifdef WIN32
             PEMerr(PEM_F_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);
             memset(buf, 0, (unsigned int)bufsize);
@@ -736,11 +736,11 @@ int ssl_pphrase_Handle_CB(char *buf, int bufsize, int verify, void *srv)
         for (;;) {
             apr_file_puts(prompt, writetty);
             if (sc->server->pphrase_dialog_type == SSL_PPTYPE_PIPE) {
-                i = pipe_get_passwd_cb(buf, bufsize, "", FALSE); 
-            }  
+                i = pipe_get_passwd_cb(buf, bufsize, "", FALSE);
+            }
             else { /* sc->server->pphrase_dialog_type == SSL_PPTYPE_BUILTIN */
-                i = EVP_read_pw_string(buf, bufsize, "", FALSE); 
-            }  
+                i = EVP_read_pw_string(buf, bufsize, "", FALSE);
+            }
             if (i != 0) {
                 PEMerr(PEM_F_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);
                 memset(buf, 0, (unsigned int)bufsize);
diff --git a/modules/ssl/ssl_engine_rand.c b/modules/ssl/ssl_engine_rand.c
index 486759c..5b7e60b 100644
--- a/modules/ssl/ssl_engine_rand.c
+++ b/modules/ssl/ssl_engine_rand.c
@@ -62,7 +62,7 @@ int ssl_rand_seed(server_rec *s, apr_pool_t *p, ssl_rsctx_t nCtx, char *prefix)
                 /*
                  * seed in contents of an external file
                  */
-                if (apr_file_open(&fp, pRandSeed->cpPath, 
+                if (apr_file_open(&fp, pRandSeed->cpPath,
                                   APR_READ, APR_OS_DEFAULT, p) != APR_SUCCESS)
                     continue;
                 nDone += ssl_rand_feedfp(p, fp, pRandSeed->nBytes);
@@ -113,7 +113,7 @@ int ssl_rand_seed(server_rec *s, apr_pool_t *p, ssl_rsctx_t nCtx, char *prefix)
                 l = sizeof(my_seed);
                 RAND_seed((unsigned char *)&my_seed, l);
                 nDone += l;
-                
+
                 /*
                  * seed in some current state of the run-time stack (128 bytes)
                  */
diff --git a/modules/ssl/ssl_engine_vars.c b/modules/ssl/ssl_engine_vars.c
index 5f1f571..f9c9d53 100644
--- a/modules/ssl/ssl_engine_vars.c
+++ b/modules/ssl/ssl_engine_vars.c
@@ -117,7 +117,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
 
         case 'R':
         case 'r':
-            if (strcEQ(var, "REQUEST_METHOD")) 
+            if (strcEQ(var, "REQUEST_METHOD"))
                 result = r->method;
             else if (strcEQ(var, "REQUEST_SCHEME"))
                 result = ap_http_scheme(r);
@@ -126,7 +126,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
             else if (strcEQ(var, "REQUEST_FILENAME"))
                 result = r->filename;
             else if (strcEQ(var, "REMOTE_HOST"))
-                result = ap_get_remote_host(r->connection, r->per_dir_config, 
+                result = ap_get_remote_host(r->connection, r->per_dir_config,
                                             REMOTE_NAME, NULL);
             else if (strcEQ(var, "REMOTE_IDENT"))
                 result = ap_get_remote_logname(r);
@@ -137,7 +137,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
         case 'S':
         case 's':
             if (strcEQn(var, "SSL", 3)) break; /* shortcut common case */
-            
+
             if (strcEQ(var, "SERVER_ADMIN"))
                 result = r->server->server_admin;
             else if (strcEQ(var, "SERVER_NAME"))
@@ -149,7 +149,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
             else if (strcEQ(var, "SCRIPT_FILENAME"))
                 result = r->filename;
             break;
-            
+
         default:
             if (strcEQ(var, "PATH_INFO"))
                 result = r->path_info;
@@ -172,7 +172,7 @@ char *ssl_var_lookup(apr_pool_t *p, server_rec *s, conn_rec *c, request_rec *r,
      */
     if (result == NULL && c != NULL) {
         SSLConnRec *sslconn = myConnConfig(c);
-        if (strlen(var) > 4 && strcEQn(var, "SSL_", 4) 
+        if (strlen(var) > 4 && strcEQn(var, "SSL_", 4)
             && sslconn && sslconn->ssl)
             result = ssl_var_lookup_ssl(p, c, var+4);
         else if (strcEQ(var, "REMOTE_ADDR"))
@@ -357,7 +357,7 @@ static char *ssl_var_lookup_ssl_cert(apr_pool_t *p, X509 *xs, char *var)
     }
     else if (strcEQ(var, "A_SIG")) {
         nid = OBJ_obj2nid((ASN1_OBJECT *)X509_get_signature_algorithm(xs));
-        result = apr_pstrdup(p, 
+        result = apr_pstrdup(p,
                              (nid == NID_undef) ? "UNKNOWN" : OBJ_nid2ln(nid));
         resdup = FALSE;
     }
@@ -476,7 +476,7 @@ static char *ssl_var_lookup_ssl_cert_remain(apr_pool_t *p, ASN1_UTCTIME *tm)
 
     /* Fail if the time isn't a valid ASN.1 UTCTIME; RFC3280 mandates
      * that the seconds digits are present even though ASN.1
-     * doesn't. */    
+     * doesn't. */
     if (tm->length < 11 || !ASN1_UTCTIME_check(tm)) {
         return apr_pstrdup(p, "0");
     }
@@ -493,7 +493,7 @@ static char *ssl_var_lookup_ssl_cert_remain(apr_pool_t *p, ASN1_UTCTIME *tm)
     if (apr_time_exp_gmt_get(&then, &exp) != APR_SUCCESS) {
         return apr_pstrdup(p, "0");
     }
-    
+
     diff = (long)((apr_time_sec(then) - apr_time_sec(now)) / (60*60*24));
 
     return diff > 0 ? apr_ltoa(p, diff) : apr_pstrdup(p, "0");
@@ -589,7 +589,7 @@ static char *ssl_var_lookup_ssl_cert_verify(apr_pool_t *p, conn_rec *c)
 
 static char *ssl_var_lookup_ssl_cipher(apr_pool_t *p, conn_rec *c, char *var)
 {
-    SSLConnRec *sslconn = myConnConfig(c);    
+    SSLConnRec *sslconn = myConnConfig(c);
     char *result;
     BOOL resdup;
     int usekeysize, algkeysize;
@@ -676,13 +676,13 @@ apr_array_header_t *ssl_ext_list(apr_pool_t *p, conn_rec *c, int peer,
     }
     ssl = sslconn->ssl;
 
-    /* We accept the "extension" string to be converted as 
-     * a long name (nsComment), short name (DN) or 
+    /* We accept the "extension" string to be converted as
+     * a long name (nsComment), short name (DN) or
      * numeric OID (1.2.3.4).
      */
     oid = OBJ_txt2obj(extension, 0);
     if (!oid) {
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, 
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
                       "Failed to create an object for extension '%s'",
                       extension);
         ERR_clear_error();
@@ -707,9 +707,9 @@ apr_array_header_t *ssl_ext_list(apr_pool_t *p, conn_rec *c, int peer,
 
             /* We want to obtain a string representation of the extensions
              * value and add it to the array we're building.
-             * X509V3_EXT_print() doesn't know about all the possible 
+             * X509V3_EXT_print() doesn't know about all the possible
              * data types, but the value is stored as an ASN1_OCTET_STRING
-             * allowing us a fallback in case of X509V3_EXT_print 
+             * allowing us a fallback in case of X509V3_EXT_print
              * not knowing how to handle the data.
              */
             if (X509V3_EXT_print(bio, ext, 0, 0) == 1 ||
@@ -721,7 +721,7 @@ apr_array_header_t *ssl_ext_list(apr_pool_t *p, conn_rec *c, int peer,
             } else {
                 ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
                               "Found an extension '%s', but failed to "
-                              "create a string from it", extension); 
+                              "create a string from it", extension);
             }
             BIO_vfree(bio);
         }
diff --git a/modules/ssl/ssl_expr_eval.c b/modules/ssl/ssl_expr_eval.c
index 76e0107..ec49827 100644
--- a/modules/ssl/ssl_expr_eval.c
+++ b/modules/ssl/ssl_expr_eval.c
@@ -228,7 +228,7 @@ static char *ssl_expr_eval_func_file(request_rec *r, char *filename)
     apr_size_t len;
     apr_finfo_t finfo;
 
-    if (apr_file_open(&fp, filename, APR_READ|APR_BUFFERED, 
+    if (apr_file_open(&fp, filename, APR_READ|APR_BUFFERED,
                       APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
         ssl_expr_error = "Cannot open file";
         return "";
diff --git a/modules/ssl/ssl_expr_parse.c b/modules/ssl/ssl_expr_parse.c
index ee172a7..d1efa59 100644
--- a/modules/ssl/ssl_expr_parse.c
+++ b/modules/ssl/ssl_expr_parse.c
@@ -1,5 +1,5 @@
 #ifndef lint
-static char const 
+static char const
 ssl_expr_yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28.2.1 2001/07/19 05:46:39 peter Exp $";
 #endif
 #include <stdlib.h>
@@ -530,9 +530,9 @@ case 25:
 break;
 case 26:
 #line 121 "ssl_expr_parse.y"
-{ 
+{
                 ap_regex_t *regex;
-                if ((regex = ap_pregcomp(ssl_expr_info.pool, ssl_expr_yyvsp[0].cpVal, 
+                if ((regex = ap_pregcomp(ssl_expr_info.pool, ssl_expr_yyvsp[0].cpVal,
                                          AP_REG_EXTENDED|AP_REG_NOSUB)) == NULL) {
                     ssl_expr_error = "Failed to compile regular expression";
                     YYERROR;
@@ -544,7 +544,7 @@ case 27:
 #line 130 "ssl_expr_parse.y"
 {
                 ap_regex_t *regex;
-                if ((regex = ap_pregcomp(ssl_expr_info.pool, ssl_expr_yyvsp[0].cpVal, 
+                if ((regex = ap_pregcomp(ssl_expr_info.pool, ssl_expr_yyvsp[0].cpVal,
                                          AP_REG_EXTENDED|AP_REG_NOSUB|AP_REG_ICASE)) == NULL) {
                     ssl_expr_error = "Failed to compile regular expression";
                     YYERROR;
@@ -554,7 +554,7 @@ case 27:
 break;
 case 28:
 #line 141 "ssl_expr_parse.y"
-{ 
+{
                ssl_expr *args = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[-1].cpVal, NULL);
                ssl_expr_yyval.exVal = ssl_expr_make(op_Func, "file", args);
             }
diff --git a/modules/ssl/ssl_expr_scan.c b/modules/ssl/ssl_expr_scan.c
index 705b246..7d7bb85 100644
--- a/modules/ssl/ssl_expr_scan.c
+++ b/modules/ssl/ssl_expr_scan.c
@@ -475,16 +475,16 @@ char *yytext;
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*                      _             _ 
- *  _ __ ___   ___   __| |    ___ ___| |  
- * | '_ ` _ \ / _ \ / _` |   / __/ __| |  
+/*                      _             _
+ *  _ __ ___   ___   __| |    ___ ___| |
+ * | '_ ` _ \ / _ \ / _` |   / __/ __| |
  * | | | | | | (_) | (_| |   \__ \__ \ | mod_ssl - Apache Interface to OpenSSL
  * |_| |_| |_|\___/ \__,_|___|___/___/_| http://www.modssl.org/
- *                      |_____|         
+ *                      |_____|
  *  ssl_expr_scan.l
  *  Expression Scanner
  */
-/* ``Killing for peace is 
+/* ``Killing for peace is
 like fucking for virginity.''
 -- Unknown  */
 /*  _________________________________________________________________
@@ -665,7 +665,7 @@ YY_DECL
 
 #line 58 "ssl_expr_scan.l"
 
-  
+
   char  caStr[MAX_STR_LEN];
   char *cpStr = NULL;
   char  caRegex[MAX_STR_LEN];
@@ -757,7 +757,7 @@ do_action:	/* This label is used only to access EOF actions. */
 case 1:
 YY_RULE_SETUP
 #line 69 "ssl_expr_scan.l"
-{ 
+{
     /* NOP */
 }
         YY_BREAK
@@ -1071,7 +1071,7 @@ YY_RULE_SETUP
 case 46:
 YY_RULE_SETUP
 #line 208 "ssl_expr_scan.l"
-{ 
+{
     return yytext[0];
 }
         YY_BREAK
@@ -1977,7 +1977,7 @@ int yyinput(char *buf, int max_size)
     int n;
 
     if ((n = MIN(max_size, ssl_expr_info.inputbuf
-                         + ssl_expr_info.inputlen 
+                         + ssl_expr_info.inputlen
                          - ssl_expr_info.inputptr)) <= 0)
         return YY_NULL;
     memcpy(buf, ssl_expr_info.inputptr, n);
diff --git a/modules/ssl/ssl_scache.c b/modules/ssl/ssl_scache.c
index 877dc07..b3af2fd 100644
--- a/modules/ssl/ssl_scache.c
+++ b/modules/ssl/ssl_scache.c
@@ -162,7 +162,7 @@ static int ssl_ext_status_hook(request_rec *r, int flags)
     else if (sc->mc->nSessionCacheMode == SSL_SCMODE_DC)
         ssl_scache_dc_status(r, flags, r->pool);
 #endif
-    
+
     ap_rputs("</td></tr>\n", r);
     ap_rputs("</table>\n", r);
     return OK;
diff --git a/modules/ssl/ssl_scache_dbm.c b/modules/ssl/ssl_scache_dbm.c
index 34a898c..ac8b216 100644
--- a/modules/ssl/ssl_scache_dbm.c
+++ b/modules/ssl/ssl_scache_dbm.c
@@ -209,7 +209,7 @@ SSL_SESSION *ssl_scache_dbm_retrieve(server_rec *s, UCHAR *id, int idlen)
     dbmkey.dptr  = (char *)id;
     dbmkey.dsize = idlen;
 
-    /* and fetch it from the DBM file 
+    /* and fetch it from the DBM file
      * XXX: Should we open the dbm against r->pool so the cleanup will
      * do the apr_dbm_close? This would make the code a bit cleaner.
      */
@@ -244,7 +244,7 @@ SSL_SESSION *ssl_scache_dbm_retrieve(server_rec *s, UCHAR *id, int idlen)
         return NULL;
     }
     /* Cast needed, ucpData may be const */
-    memcpy((unsigned char *)ucpData, 
+    memcpy((unsigned char *)ucpData,
            (char *)dbmval.dptr + sizeof(time_t), nData);
     memcpy(&expiry, dbmval.dptr, sizeof(time_t));
 
@@ -347,7 +347,7 @@ static void ssl_scache_dbm_expire(server_rec *s)
 
         /* pass 1: scan DBM database */
         keyidx = 0;
-        if ((rv = apr_dbm_open(&dbm, mc->szSessionCacheDataFile, 
+        if ((rv = apr_dbm_open(&dbm, mc->szSessionCacheDataFile,
                                APR_DBM_RWCREATE,SSL_DBM_FILE_MODE,
                                p)) != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
diff --git a/modules/ssl/ssl_scache_dc.c b/modules/ssl/ssl_scache_dc.c
index 3d7d61c..97f4581 100644
--- a/modules/ssl/ssl_scache_dc.c
+++ b/modules/ssl/ssl_scache_dc.c
@@ -81,8 +81,8 @@ void ssl_scache_dc_init(server_rec *s, apr_pool_t *p)
         ssl_die();
     }
     ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, "distributed scache context initialised");
-    /* 
-     * Success ... 
+    /*
+     * Success ...
      */
     mc->tSessionCacheDataTable = ctx;
     return;
@@ -167,7 +167,7 @@ void ssl_scache_dc_status(request_rec *r, int flags, apr_pool_t *pool)
 {
     SSLModConfigRec *mc = myModConfig(r->server);
 
-    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                   "distributed scache 'ssl_scache_dc_status'");
     ap_rprintf(r, "cache type: <b>DC (Distributed Cache)</b>, "
                " target: <b>%s</b><br>", mc->szSessionCacheDataFile);
diff --git a/modules/ssl/ssl_scache_shmcb.c b/modules/ssl/ssl_scache_shmcb.c
index 741a20e..024d195 100644
--- a/modules/ssl/ssl_scache_shmcb.c
+++ b/modules/ssl/ssl_scache_shmcb.c
@@ -26,7 +26,7 @@
 
 #include "ssl_private.h"
 
-/* 
+/*
  * This shared memory based SSL session cache implementation was
  * originally written by Geoff Thorpe <geoff geoffthorpe.net> for C2Net
  * Europe as a contribution to Ralf Engelschall's mod_ssl project.
@@ -88,7 +88,7 @@
  *   how many session-retrieves have failed.
  * - removes_hit (unsigned long):
  * - removes_miss (unsigned long):
- * 
+ *
  * Following immediately after the header is an array of "divisions".
  * Each division is simply a "queue" immediately followed by its
  * corresponding "cache". Each division handles some pre-defined band
@@ -135,7 +135,7 @@
  * sessions are stored.
  */
 
-/* 
+/*
  * Header - can be memcpy'd to and from the front of the shared
  * memory segment. NB: The first copy (commented out) has the
  * elements in a meaningful order, but due to data-alignment
@@ -161,7 +161,7 @@ typedef struct {
     unsigned int index_size;
 } SHMCBHeader;
 
-/* 
+/*
  * Index - can be memcpy'd to and from an index inside each
  * queue's index array.
  */
@@ -172,7 +172,7 @@ typedef struct {
     unsigned char removed;
 } SHMCBIndex;
 
-/* 
+/*
  * Queue - must be populated by a call to shmcb_get_division
  * and the structure's pointers are used for updating (ie.
  * the structure doesn't need any "set" to update values).
@@ -184,7 +184,7 @@ typedef struct {
     SHMCBIndex *indexes;
 } SHMCBQueue;
 
-/* 
+/*
  * Cache - same comment as for Queue. 'Queue's are in a 1-1
  * correspondance with 'Cache's and are usually carried round
  * in a pair, they are only seperated for clarity.
@@ -341,17 +341,17 @@ void ssl_scache_shmcb_init(server_rec *s, apr_pool_t *p)
     }
 
     /* Use anonymous shm by default, fall back on name-based. */
-    rv = apr_shm_create(&(mc->pSessionCacheDataMM), 
-                        mc->nSessionCacheDataSize, 
+    rv = apr_shm_create(&(mc->pSessionCacheDataMM),
+                        mc->nSessionCacheDataSize,
                         NULL, mc->pPool);
-    
+
     if (APR_STATUS_IS_ENOTIMPL(rv)) {
         /* For a name-based segment, remove it first in case of a
          * previous unclean shutdown. */
         apr_shm_remove(mc->szSessionCacheDataFile, mc->pPool);
-        
-        rv = apr_shm_create(&(mc->pSessionCacheDataMM), 
-                            mc->nSessionCacheDataSize, 
+
+        rv = apr_shm_create(&(mc->pSessionCacheDataMM),
+                            mc->nSessionCacheDataSize,
                             mc->szSessionCacheDataFile,
                             mc->pPool);
     }
@@ -367,7 +367,7 @@ void ssl_scache_shmcb_init(server_rec *s, apr_pool_t *p)
     shm_segsize = apr_shm_size_get(mc->pSessionCacheDataMM);
 
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-                 "shmcb_init allocated %" APR_SIZE_T_FMT 
+                 "shmcb_init allocated %" APR_SIZE_T_FMT
                  " bytes of shared memory",
                  shm_segsize);
     if (!shmcb_init_memory(s, shm_segment, shm_segsize)) {
@@ -378,8 +378,8 @@ void ssl_scache_shmcb_init(server_rec *s, apr_pool_t *p)
     ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
                  "Shared memory session cache initialised");
 
-    /* 
-     * Success ... 
+    /*
+     * Success ...
      */
     mc->tSessionCacheDataTable = shm_segment;
     return;
@@ -509,9 +509,9 @@ void ssl_scache_shmcb_status(request_rec *r, int flags, apr_pool_t *p)
                        (int)(average_expiry - now), (int) (min_expiry - now),
                        (int)(max_expiry - now));
         else
-            ap_rprintf(r, "expiry threshold: <b>Calculation Error!</b>" 
+            ap_rprintf(r, "expiry threshold: <b>Calculation Error!</b>"
                        "<br>");
-        
+
     }
     ap_rprintf(r, "index usage: <b>%d%%</b>, cache usage: <b>%d%%</b>"
                "<br>", index_pct, cache_pct);
@@ -533,7 +533,7 @@ void ssl_scache_shmcb_status(request_rec *r, int flags, apr_pool_t *p)
 
 /*
 **
-** Memory manipulation and low-level cache operations 
+** Memory manipulation and low-level cache operations
 **
 */
 
@@ -546,7 +546,7 @@ static BOOL shmcb_init_memory(
     SHMCBCache cache;
     unsigned int temp, loop, granularity;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
                  "entered shmcb_init_memory()");
 
     /* Calculate some sizes... */
@@ -784,7 +784,7 @@ static BOOL shmcb_remove_session(
 }
 
 
-/* 
+/*
 **
 ** Weirdo cyclic buffer functions
 **
@@ -1015,7 +1015,7 @@ static unsigned int shmcb_expire_division(
             shmcb_set_safe_uint(queue->first_pos, new_pos);
             /* peek to the start of the next session */
             idx = shmcb_get_index(queue, new_pos);
-            /* We can use shmcb_cyclic_space because we've guaranteed 
+            /* We can use shmcb_cyclic_space because we've guaranteed
              * we don't fit the ambiguous full/empty case. */
             shmcb_set_safe_uint(cache->pos_count,
                                shmcb_get_safe_uint(cache->pos_count) -
@@ -1314,7 +1314,7 @@ static BOOL shmcb_remove_session_id(
             session_id_length = SSL_SESSION_get_session_id_length(pSession);
             session_id = SSL_SESSION_get_session_id(pSession);
 
-            if ((session_id_length == idlen) 
+            if ((session_id_length == idlen)
                  && (memcmp(id, session_id, idlen) == 0)) {
                 ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
                             "a match!");
diff --git a/modules/ssl/ssl_util.c b/modules/ssl/ssl_util.c
index edfcb09..92289bd 100644
--- a/modules/ssl/ssl_util.c
+++ b/modules/ssl/ssl_util.c
@@ -66,12 +66,12 @@ apr_file_t *ssl_util_ppopen(server_rec *s, apr_pool_t *p, const char *cmd,
     apr_procattr_t *procattr;
     apr_proc_t *proc;
 
-    if (apr_procattr_create(&procattr, p) != APR_SUCCESS) 
+    if (apr_procattr_create(&procattr, p) != APR_SUCCESS)
         return NULL;
-    if (apr_procattr_io_set(procattr, APR_FULL_BLOCK, APR_FULL_BLOCK, 
+    if (apr_procattr_io_set(procattr, APR_FULL_BLOCK, APR_FULL_BLOCK,
                             APR_FULL_BLOCK) != APR_SUCCESS)
         return NULL;
-    if (apr_procattr_dir_set(procattr, 
+    if (apr_procattr_dir_set(procattr,
                              ap_make_dirstr_parent(p, cmd)) != APR_SUCCESS)
         return NULL;
     if (apr_procattr_cmdtype_set(procattr, APR_PROGRAM) != APR_SUCCESS)
@@ -122,7 +122,7 @@ BOOL ssl_util_path_check(ssl_pathcheck_t pcm, const char *path, apr_pool_t *p)
 
     if (path == NULL)
         return FALSE;
-    if (pcm & SSL_PCM_EXISTS && apr_stat(&finfo, path, 
+    if (pcm & SSL_PCM_EXISTS && apr_stat(&finfo, path,
                                 APR_FINFO_TYPE|APR_FINFO_SIZE, p) != 0)
         return FALSE;
     if (pcm & SSL_PCM_ISREG && finfo.filetype != APR_REG)
@@ -134,20 +134,20 @@ BOOL ssl_util_path_check(ssl_pathcheck_t pcm, const char *path, apr_pool_t *p)
     return TRUE;
 }
 
-ssl_algo_t ssl_util_algotypeof(X509 *pCert, EVP_PKEY *pKey) 
+ssl_algo_t ssl_util_algotypeof(X509 *pCert, EVP_PKEY *pKey)
 {
     ssl_algo_t t;
     EVP_PKEY *pFreeKey = NULL;
-            
+
     t = SSL_ALGO_UNKNOWN;
     if (pCert != NULL)
         pFreeKey = pKey = X509_get_pubkey(pCert);
     if (pKey != NULL) {
         switch (EVP_PKEY_key_type(pKey)) {
-            case EVP_PKEY_RSA: 
+            case EVP_PKEY_RSA:
                 t = SSL_ALGO_RSA;
                 break;
-            case EVP_PKEY_DSA: 
+            case EVP_PKEY_DSA:
                 t = SSL_ALGO_DSA;
                 break;
             default:
@@ -162,16 +162,16 @@ ssl_algo_t ssl_util_algotypeof(X509 *pCert, EVP_PKEY *pKey)
     return t;
 }
 
-char *ssl_util_algotypestr(ssl_algo_t t) 
+char *ssl_util_algotypestr(ssl_algo_t t)
 {
     char *cp;
 
     cp = "UNKNOWN";
     switch (t) {
-        case SSL_ALGO_RSA: 
+        case SSL_ALGO_RSA:
             cp = "RSA";
             break;
-        case SSL_ALGO_DSA: 
+        case SSL_ALGO_DSA:
             cp = "DSA";
             break;
         default:
@@ -307,8 +307,8 @@ static void ssl_util_thr_lock(int mode, int type,
 
 static unsigned long ssl_util_thr_id(void)
 {
-    /* OpenSSL needs this to return an unsigned long.  On OS/390, the pthread 
-     * id is a structure twice that big.  Use the TCB pointer instead as a 
+    /* OpenSSL needs this to return an unsigned long.  On OS/390, the pthread
+     * id is a structure twice that big.  Use the TCB pointer instead as a
      * unique unsigned long.
      */
 #ifdef __MVS__
@@ -328,7 +328,7 @@ static apr_status_t ssl_util_thread_cleanup(void *data)
     CRYPTO_set_locking_callback(NULL);
     CRYPTO_set_id_callback(NULL);
 
-    /* Let the registered mutex cleanups do their own thing 
+    /* Let the registered mutex cleanups do their own thing
      */
     return APR_SUCCESS;
 }
diff --git a/modules/ssl/ssl_util_ssl.c b/modules/ssl/ssl_util_ssl.c
index 9a464c2..cbce6f3 100644
--- a/modules/ssl/ssl_util_ssl.c
+++ b/modules/ssl/ssl_util_ssl.c
@@ -90,7 +90,7 @@ X509 *SSL_read_X509(char* filename, X509 **x509, modssl_read_bio_cb_fn *cb)
         /* 2. try DER+Base64 */
         if ((bioS=BIO_new_file(filename, "r")) == NULL)
             return NULL;
-                      
+
         if ((bioF = BIO_new(BIO_f_base64())) == NULL) {
             BIO_free(bioS);
             return NULL;
@@ -119,8 +119,8 @@ X509 *SSL_read_X509(char* filename, X509 **x509, modssl_read_bio_cb_fn *cb)
 static EVP_PKEY *d2i_PrivateKey_bio(BIO *bio, EVP_PKEY **key)
 {
      return ((EVP_PKEY *)ASN1_d2i_bio(
-             (char *(*)())EVP_PKEY_new, 
-             (char *(*)())d2i_PrivateKey, 
+             (char *(*)())EVP_PKEY_new,
+             (char *(*)())d2i_PrivateKey,
              (bio), (unsigned char **)(key)));
 }
 #endif
@@ -256,7 +256,7 @@ char *SSL_make_ciphersuite(apr_pool_t *p, SSL *ssl)
     char *cpCipherSuite;
     char *cp;
 
-    if (ssl == NULL) 
+    if (ssl == NULL)
         return "";
     if ((sk = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl)) == NULL)
         return "";
@@ -298,7 +298,7 @@ BOOL SSL_X509_isSGC(X509 *cert)
     BOOL is_sgc;
     int idx;
     int i;
-    
+
     is_sgc = FALSE;
     idx = X509_get_ext_by_NID(cert, NID_ext_key_usage, -1);
     if (idx >= 0) {
@@ -328,7 +328,7 @@ BOOL SSL_X509_getBC(X509 *cert, int *ca, int *pathlen)
     int idx;
     BIGNUM *bn = NULL;
     char *cp;
-    
+
     if ((idx = X509_get_ext_by_NID(cert, NID_basic_constraints, -1)) < 0)
         return FALSE;
     ext = X509_get_ext(cert, idx);
@@ -447,7 +447,7 @@ BOOL SSL_X509_INFO_load_path(apr_pool_t *ptemp,
     apr_dir_close(dir);
 
     return ok;
-}              
+}
 
 /*  _________________________________________________________________
 **
@@ -455,7 +455,7 @@ BOOL SSL_X509_INFO_load_path(apr_pool_t *ptemp,
 **  _________________________________________________________________
 */
 
-/* 
+/*
  * Read a file that optionally contains the server certificate in PEM
  * format, possibly followed by a sequence of CA certificates that
  * should be sent to the peer in the SSL Certificate message.
@@ -492,7 +492,7 @@ int SSL_CTX_use_certificate_chain(
     /* create new extra chain by loading the certs */
     n = 0;
     while ((x509 = modssl_PEM_read_bio_X509(bio, NULL, cb, NULL)) != NULL) {
-        if (!SSL_CTX_add_extra_chain_cert(ctx, x509)) { 
+        if (!SSL_CTX_add_extra_chain_cert(ctx, x509)) {
             X509_free(x509);
             BIO_free(bio);
             return -1;
@@ -501,7 +501,7 @@ int SSL_CTX_use_certificate_chain(
     }
     /* Make sure that only the error is just an EOF */
     if ((err = ERR_peek_error()) > 0) {
-        if (!(   ERR_GET_LIB(err) == ERR_LIB_PEM 
+        if (!(   ERR_GET_LIB(err) == ERR_LIB_PEM
               && ERR_GET_REASON(err) == PEM_R_NO_START_LINE)) {
             BIO_free(bio);
             return -1;
diff --git a/os/beos/beosd.c b/os/beos/beosd.c
index 901c9a6..ea8d503 100644
--- a/os/beos/beosd.c
+++ b/os/beos/beosd.c
@@ -49,14 +49,14 @@ int beosd_setup_child(void)
 }
 
 
-AP_DECLARE(const char *) beosd_set_user(cmd_parms *cmd, 
+AP_DECLARE(const char *) beosd_set_user(cmd_parms *cmd,
                                         void *dummy, const char *arg)
 {
     /* no-op */
     return NULL;
 }
 
-AP_DECLARE(const char *) beosd_set_group(cmd_parms *cmd, 
+AP_DECLARE(const char *) beosd_set_group(cmd_parms *cmd,
                                          void *dummy, const char *arg)
 {
     /* no-op */
@@ -78,7 +78,7 @@ AP_DECLARE(apr_status_t) beosd_accept(void **accepted, ap_listen_rec *lr,
     int sockdes;
 
     status = apr_socket_accept(&csd, lr->sd, ptrans);
-    if (status == APR_SUCCESS) { 
+    if (status == APR_SUCCESS) {
         *accepted = csd;
         apr_os_sock_get(&sockdes, csd);
         if (sockdes >= FD_SETSIZE) {
@@ -89,7 +89,7 @@ AP_DECLARE(apr_status_t) beosd_accept(void **accepted, ap_listen_rec *lr,
                          sockdes, FD_SETSIZE);
             apr_socket_close(csd);
             return APR_EINTR;
-        } 
+        }
         return status;
     }
 
diff --git a/os/beos/os.c b/os/beos/os.c
index 57ef386..c7a3c9f 100644
--- a/os/beos/os.c
+++ b/os/beos/os.c
@@ -23,7 +23,7 @@
 #include "os.h"
 #include "httpd.h"
 #include "apr_thread_proc.h"
-#include "ap_mpm.h" /* needed for definition of 
+#include "ap_mpm.h" /* needed for definition of
                      * ap_os_create_privileged_process */
 
 AP_DECLARE(apr_status_t) ap_os_create_privileged_process(
diff --git a/os/bs2000/ebcdic.c b/os/bs2000/ebcdic.c
index 74074e3..dd6e412 100644
--- a/os/bs2000/ebcdic.c
+++ b/os/bs2000/ebcdic.c
@@ -88,7 +88,7 @@ const unsigned char os_toascii_strictly[256] = {
  * are stored as EBCDIC, only the semantics of \012 is completely
  * different from LF (look it up in the apr_table_t above). \015 happens to be
  * mapped to \015 anyway, so there's no special case for it.
- * 
+ *
  * In THIS table, EBCDIC-\012 is mapped to ASCII-\012.
  * This apr_table_t is therefore used wherever an EBCDIC to ASCII conversion is
  * needed in the server.
diff --git a/os/tpf/ebcdic.c b/os/tpf/ebcdic.c
index e71928e..95a81d9 100644
--- a/os/tpf/ebcdic.c
+++ b/os/tpf/ebcdic.c
@@ -176,4 +176,4 @@ ascii2ebcdic(void *dest, const void *srce, size_t count)
     }
 }
 #endif /*APR_CHARSET_EBCDIC*/
- 
+
diff --git a/os/tpf/os.c b/os/tpf/os.c
index 9b9bacc..f1ef95d 100644
--- a/os/tpf/os.c
+++ b/os/tpf/os.c
@@ -34,10 +34,10 @@ int pipe(int fildes[2])
     return(-1);
 }
 #endif
-  
+
 /* fork and exec functions are not defined on
    TPF due to the implementation of tpf_fork() */
- 
+
 pid_t fork(void)
 {
     errno = ENOSYS;
diff --git a/os/unix/unixd.c b/os/unix/unixd.c
index b1e178d..215f0ff 100644
--- a/os/unix/unixd.c
+++ b/os/unix/unixd.c
@@ -142,7 +142,7 @@ AP_DECLARE(int) unixd_setup_child(void)
                     (long) unixd_config.user_id);
         return -1;
     }
-#if defined(HAVE_PRCTL) && defined(PR_SET_DUMPABLE) 
+#if defined(HAVE_PRCTL) && defined(PR_SET_DUMPABLE)
     /* this applies to Linux 2.4+ */
 #ifdef AP_MPM_WANT_SET_COREDUMPDIR
     if (ap_coredumpdir_configured) {
@@ -159,7 +159,7 @@ AP_DECLARE(int) unixd_setup_child(void)
 }
 
 
-AP_DECLARE(const char *) unixd_set_user(cmd_parms *cmd, void *dummy, 
+AP_DECLARE(const char *) unixd_set_user(cmd_parms *cmd, void *dummy,
                                         const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
@@ -186,7 +186,7 @@ AP_DECLARE(const char *) unixd_set_user(cmd_parms *cmd, void *dummy,
     return NULL;
 }
 
-AP_DECLARE(const char *) unixd_set_group(cmd_parms *cmd, void *dummy, 
+AP_DECLARE(const char *) unixd_set_group(cmd_parms *cmd, void *dummy,
                                          const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
@@ -209,7 +209,7 @@ AP_DECLARE(void) unixd_pre_config(apr_pool_t *ptemp)
 
     /* Check for suexec */
     unixd_config.suexec_enabled = 0;
-    if ((apr_stat(&wrapper, SUEXEC_BIN, 
+    if ((apr_stat(&wrapper, SUEXEC_BIN,
                   APR_FINFO_NORM, ptemp)) != APR_SUCCESS) {
         return;
     }
@@ -220,7 +220,7 @@ AP_DECLARE(void) unixd_pre_config(apr_pool_t *ptemp)
 }
 
 
-AP_DECLARE(void) unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit, 
+AP_DECLARE(void) unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
                            const char *arg, const char * arg2, int type)
 {
 #if (defined(RLIMIT_CPU) || defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_NPROC) || defined(RLIMIT_AS)) && APR_HAVE_STRUCT_RLIMIT && APR_HAVE_GETRLIMIT
@@ -407,7 +407,7 @@ AP_DECLARE(apr_status_t) unixd_set_proc_mutex_perms(apr_proc_mutex_t *pmutex)
 #endif
             union semun ick;
             struct semid_ds buf;
-        
+
             apr_os_proc_mutex_get(&ospmutex, pmutex);
             buf.sem_perm.uid = unixd_config.user_id;
             buf.sem_perm.gid = unixd_config.group_id;
@@ -464,7 +464,7 @@ AP_DECLARE(apr_status_t) unixd_accept(void **accepted, ap_listen_rec *lr,
 
     *accepted = NULL;
     status = apr_socket_accept(&csd, lr->sd, ptrans);
-    if (status == APR_SUCCESS) { 
+    if (status == APR_SUCCESS) {
         *accepted = csd;
 #ifdef _OSD_POSIX
         apr_os_sock_get(&sockdes, csd);
diff --git a/os/win32/ap_regkey.c b/os/win32/ap_regkey.c
index 4f3a506..93d1198 100644
--- a/os/win32/ap_regkey.c
+++ b/os/win32/ap_regkey.c
@@ -29,7 +29,7 @@ struct ap_regkey_t {
 
 AP_DECLARE(const ap_regkey_t *) ap_regkey_const(int i)
 {
-    static struct ap_regkey_t ap_regkey_consts[7] = 
+    static struct ap_regkey_t ap_regkey_consts[7] =
     {
         {NULL, HKEY_CLASSES_ROOT},
         {NULL, HKEY_CURRENT_CONFIG},
@@ -55,10 +55,10 @@ apr_status_t regkey_cleanup(void *key)
 }
 
 
-AP_DECLARE(apr_status_t) ap_regkey_open(ap_regkey_t **newkey, 
+AP_DECLARE(apr_status_t) ap_regkey_open(ap_regkey_t **newkey,
                                         const ap_regkey_t *parentkey,
                                         const char *keyname,
-                                        apr_int32_t flags, 
+                                        apr_int32_t flags,
                                         apr_pool_t *pool)
 {
     DWORD access = KEY_QUERY_VALUE;
@@ -69,10 +69,10 @@ AP_DECLARE(apr_status_t) ap_regkey_open(ap_regkey_t **newkey,
     if (flags & APR_READ)
         access |= KEY_READ;
     if (flags & APR_WRITE)
-        access |= KEY_WRITE; 
+        access |= KEY_WRITE;
 
 #if APR_HAS_UNICODE_FS
-    IF_WIN_OS_IS_UNICODE 
+    IF_WIN_OS_IS_UNICODE
     {
         apr_size_t keylen = strlen(keyname) + 1;
         apr_size_t wkeylen = 256;
@@ -84,7 +84,7 @@ AP_DECLARE(apr_status_t) ap_regkey_open(ap_regkey_t **newkey,
             return APR_ENAMETOOLONG;
 
         if (flags & APR_CREATE)
-            rc = RegCreateKeyExW(parentkey->hkey, wkeyname, 0, NULL, 0, 
+            rc = RegCreateKeyExW(parentkey->hkey, wkeyname, 0, NULL, 0,
                                  access, NULL, &hkey, &exists);
         else
             rc = RegOpenKeyExW(parentkey->hkey, wkeyname, 0, access, &hkey);
@@ -94,7 +94,7 @@ AP_DECLARE(apr_status_t) ap_regkey_open(ap_regkey_t **newkey,
     ELSE_WIN_OS_IS_ANSI
     {
         if (flags & APR_CREATE)
-            rc = RegCreateKeyEx(parentkey->hkey, keyname, 0, NULL, 0, 
+            rc = RegCreateKeyEx(parentkey->hkey, keyname, 0, NULL, 0,
                                 access, NULL, &hkey, &exists);
         else
             rc = RegOpenKeyEx(parentkey->hkey, keyname, 0, access, &hkey);
@@ -111,7 +111,7 @@ AP_DECLARE(apr_status_t) ap_regkey_open(ap_regkey_t **newkey,
     *newkey = apr_palloc(pool, sizeof(**newkey));
     (*newkey)->pool = pool;
     (*newkey)->hkey = hkey;
-    apr_pool_cleanup_register((*newkey)->pool, (void *)(*newkey), 
+    apr_pool_cleanup_register((*newkey)->pool, (void *)(*newkey),
                               regkey_cleanup, apr_pool_cleanup_null);
     return APR_SUCCESS;
 }
@@ -127,14 +127,14 @@ AP_DECLARE(apr_status_t) ap_regkey_close(ap_regkey_t *regkey)
 }
 
 
-AP_DECLARE(apr_status_t) ap_regkey_remove(const ap_regkey_t *parent, 
+AP_DECLARE(apr_status_t) ap_regkey_remove(const ap_regkey_t *parent,
                                           const char *keyname,
                                           apr_pool_t *pool)
 {
     LONG rc;
 
 #if APR_HAS_UNICODE_FS
-    IF_WIN_OS_IS_UNICODE 
+    IF_WIN_OS_IS_UNICODE
     {
         apr_size_t keylen = strlen(keyname) + 1;
         apr_size_t wkeylen = 256;
@@ -176,9 +176,9 @@ AP_DECLARE(apr_status_t) ap_regkey_remove(const ap_regkey_t *parent,
 }
 
 
-AP_DECLARE(apr_status_t) ap_regkey_value_get(char **result, 
-                                             ap_regkey_t *key, 
-                                             const char *valuename, 
+AP_DECLARE(apr_status_t) ap_regkey_value_get(char **result,
+                                             ap_regkey_t *key,
+                                             const char *valuename,
                                              apr_pool_t *pool)
 {
     /* Retrieve a registry string value, and explode any envvars
@@ -187,9 +187,9 @@ AP_DECLARE(apr_status_t) ap_regkey_value_get(char **result,
     LONG rc;
     DWORD type;
     apr_size_t size = 0;
-    
+
 #if APR_HAS_UNICODE_FS
-    IF_WIN_OS_IS_UNICODE 
+    IF_WIN_OS_IS_UNICODE
     {
         apr_size_t valuelen = strlen(valuename) + 1;
         apr_size_t wvallen = 256;
@@ -212,7 +212,7 @@ AP_DECLARE(apr_status_t) ap_regkey_value_get(char **result,
 
         wvalue = apr_palloc(pool, size);
         /* Read value based on size query above */
-        rc = RegQueryValueExW(key->hkey, wvalname, 0, &type, 
+        rc = RegQueryValueExW(key->hkey, wvalname, 0, &type,
                               (LPBYTE)wvalue, (DWORD *)&size);
         if (rc != ERROR_SUCCESS) {
             return APR_FROM_OS_ERROR(rc);
@@ -280,10 +280,10 @@ AP_DECLARE(apr_status_t) ap_regkey_value_get(char **result,
 }
 
 
-AP_DECLARE(apr_status_t) ap_regkey_value_set(ap_regkey_t *key, 
-                                             const char *valuename, 
-                                             const char *value, 
-                                             apr_int32_t flags, 
+AP_DECLARE(apr_status_t) ap_regkey_value_set(ap_regkey_t *key,
+                                             const char *valuename,
+                                             const char *value,
+                                             apr_int32_t flags,
                                              apr_pool_t *pool)
 {
     /* Retrieve a registry string value, and explode any envvars
@@ -292,9 +292,9 @@ AP_DECLARE(apr_status_t) ap_regkey_value_set(ap_regkey_t *key,
     LONG rc;
     apr_size_t size = strlen(value) + 1;
     DWORD type = (flags & AP_REGKEY_EXPAND) ? REG_EXPAND_SZ : REG_SZ;
-    
+
 #if APR_HAS_UNICODE_FS
-    IF_WIN_OS_IS_UNICODE 
+    IF_WIN_OS_IS_UNICODE
     {
         apr_size_t alloclen;
         apr_size_t valuelen = strlen(valuename) + 1;
@@ -307,7 +307,7 @@ AP_DECLARE(apr_status_t) ap_regkey_value_set(ap_regkey_t *key,
             return rv;
         else if (valuelen)
             return APR_ENAMETOOLONG;
-        
+
         wvallen = alloclen = size;
         wvalue = apr_palloc(pool, alloclen * 2);
         rv = apr_conv_utf8_to_ucs2(value, &size, wvalue, &wvallen);
@@ -320,7 +320,7 @@ AP_DECLARE(apr_status_t) ap_regkey_value_set(ap_regkey_t *key,
          * converted to bytes; the trailing L'\0' continues to be counted.
          */
         size = (alloclen - wvallen) * 2;
-        rc = RegSetValueExW(key->hkey, wvalname, 0, type, 
+        rc = RegSetValueExW(key->hkey, wvalname, 0, type,
                             (LPBYTE)wvalue, (DWORD)size);
         if (rc != ERROR_SUCCESS)
             return APR_FROM_OS_ERROR(rc);
@@ -338,20 +338,20 @@ AP_DECLARE(apr_status_t) ap_regkey_value_set(ap_regkey_t *key,
 }
 
 
-AP_DECLARE(apr_status_t) ap_regkey_value_raw_get(void **result, 
+AP_DECLARE(apr_status_t) ap_regkey_value_raw_get(void **result,
                                                  apr_size_t *resultsize,
                                                  apr_int32_t *resulttype,
-                                                 ap_regkey_t *key, 
-                                                 const char *valuename, 
+                                                 ap_regkey_t *key,
+                                                 const char *valuename,
                                                  apr_pool_t *pool)
 {
     /* Retrieve a registry string value, and explode any envvars
      * that the system has configured (e.g. %SystemRoot%/someapp.exe)
      */
     LONG rc;
-    
+
 #if APR_HAS_UNICODE_FS
-    IF_WIN_OS_IS_UNICODE 
+    IF_WIN_OS_IS_UNICODE
     {
         apr_size_t valuelen = strlen(valuename) + 1;
         apr_size_t wvallen = 256;
@@ -363,7 +363,7 @@ AP_DECLARE(apr_status_t) ap_regkey_value_raw_get(void **result,
         else if (valuelen)
             return APR_ENAMETOOLONG;
         /* Read to NULL buffer to determine value size */
-        rc = RegQueryValueExW(key->hkey, wvalname, 0, resulttype, 
+        rc = RegQueryValueExW(key->hkey, wvalname, 0, resulttype,
                               NULL, (LPDWORD)resultsize);
         if (rc != ERROR_SUCCESS) {
             return APR_FROM_OS_ERROR(rc);
@@ -371,7 +371,7 @@ AP_DECLARE(apr_status_t) ap_regkey_value_raw_get(void **result,
 
         /* Read value based on size query above */
         *result = apr_palloc(pool, *resultsize);
-        rc = RegQueryValueExW(key->hkey, wvalname, 0, resulttype, 
+        rc = RegQueryValueExW(key->hkey, wvalname, 0, resulttype,
                              (LPBYTE)*result, (LPDWORD)resultsize);
     }
 #endif /* APR_HAS_UNICODE_FS */
@@ -379,14 +379,14 @@ AP_DECLARE(apr_status_t) ap_regkey_value_raw_get(void **result,
     ELSE_WIN_OS_IS_ANSI
     {
         /* Read to NULL buffer to determine value size */
-        rc = RegQueryValueEx(key->hkey, valuename, 0, resulttype, 
+        rc = RegQueryValueEx(key->hkey, valuename, 0, resulttype,
                              NULL, (LPDWORD)resultsize);
         if (rc != ERROR_SUCCESS)
             return APR_FROM_OS_ERROR(rc);
 
         /* Read value based on size query above */
         *result = apr_palloc(pool, *resultsize);
-        rc = RegQueryValueEx(key->hkey, valuename, 0, resulttype, 
+        rc = RegQueryValueEx(key->hkey, valuename, 0, resulttype,
                              (LPBYTE)*result, (LPDWORD)resultsize);
         if (rc != ERROR_SUCCESS)
             return APR_FROM_OS_ERROR(rc);
@@ -400,17 +400,17 @@ AP_DECLARE(apr_status_t) ap_regkey_value_raw_get(void **result,
 }
 
 
-AP_DECLARE(apr_status_t) ap_regkey_value_raw_set(ap_regkey_t *key, 
-                                                 const char *valuename, 
-                                                 const void *value, 
+AP_DECLARE(apr_status_t) ap_regkey_value_raw_set(ap_regkey_t *key,
+                                                 const char *valuename,
+                                                 const void *value,
                                                  apr_size_t valuesize,
                                                  apr_int32_t valuetype,
                                                  apr_pool_t *pool)
 {
     LONG rc;
-    
+
 #if APR_HAS_UNICODE_FS
-    IF_WIN_OS_IS_UNICODE 
+    IF_WIN_OS_IS_UNICODE
     {
         apr_size_t valuelen = strlen(valuename) + 1;
         apr_size_t wvallen = 256;
@@ -422,14 +422,14 @@ AP_DECLARE(apr_status_t) ap_regkey_value_raw_set(ap_regkey_t *key,
         else if (valuelen)
             return APR_ENAMETOOLONG;
 
-        rc = RegSetValueExW(key->hkey, wvalname, 0, valuetype, 
+        rc = RegSetValueExW(key->hkey, wvalname, 0, valuetype,
                             (LPBYTE)value, (DWORD)valuesize);
     }
 #endif /* APR_HAS_UNICODE_FS */
 #if APR_HAS_ANSI_FS
     ELSE_WIN_OS_IS_ANSI
     {
-        rc = RegSetValueEx(key->hkey, valuename, 0, valuetype, 
+        rc = RegSetValueEx(key->hkey, valuename, 0, valuetype,
                             (LPBYTE)value, (DWORD)valuesize);
     }
 #endif
@@ -440,9 +440,9 @@ AP_DECLARE(apr_status_t) ap_regkey_value_raw_set(ap_regkey_t *key,
 }
 
 
-AP_DECLARE(apr_status_t) ap_regkey_value_array_get(apr_array_header_t **result, 
+AP_DECLARE(apr_status_t) ap_regkey_value_array_get(apr_array_header_t **result,
                                                    ap_regkey_t *key,
-                                                   const char *valuename, 
+                                                   const char *valuename,
                                                    apr_pool_t *pool)
 {
     /* Retrieve a registry string value, and explode any envvars
@@ -464,7 +464,7 @@ AP_DECLARE(apr_status_t) ap_regkey_value_array_get(apr_array_header_t **result,
     }
 
 #if APR_HAS_UNICODE_FS
-    IF_WIN_OS_IS_UNICODE 
+    IF_WIN_OS_IS_UNICODE
     {
         apr_size_t alloclen;
         apr_size_t valuelen = strlen(valuename) + 1;
@@ -490,7 +490,7 @@ AP_DECLARE(apr_status_t) ap_regkey_value_array_get(apr_array_header_t **result,
 #if APR_HAS_ANSI_FS
     ELSE_WIN_OS_IS_ANSI
     {
-        /* Small possiblity the array is either unterminated 
+        /* Small possiblity the array is either unterminated
          * or single NULL terminated.  Avert.
          */
         buf = (char *)value;
@@ -524,9 +524,9 @@ AP_DECLARE(apr_status_t) ap_regkey_value_array_get(apr_array_header_t **result,
 }
 
 
-AP_DECLARE(apr_status_t) ap_regkey_value_array_set(ap_regkey_t *key, 
-                                                   const char *valuename, 
-                                                   int nelts, 
+AP_DECLARE(apr_status_t) ap_regkey_value_array_set(ap_regkey_t *key,
+                                                   const char *valuename,
+                                                   int nelts,
                                                    const char * const * elts,
                                                    apr_pool_t *pool)
 {
@@ -536,9 +536,9 @@ AP_DECLARE(apr_status_t) ap_regkey_value_array_set(ap_regkey_t *key,
     int i;
     const void *value;
     apr_size_t bufsize;
-    
+
 #if APR_HAS_UNICODE_FS
-    IF_WIN_OS_IS_UNICODE 
+    IF_WIN_OS_IS_UNICODE
     {
         apr_status_t rv;
         apr_wchar_t *buf;
@@ -604,19 +604,19 @@ AP_DECLARE(apr_status_t) ap_regkey_value_array_set(ap_regkey_t *key,
         value = buf;
     }
 #endif
-    return ap_regkey_value_raw_set(key, valuename, value, 
+    return ap_regkey_value_raw_set(key, valuename, value,
                                    bufsize, REG_MULTI_SZ, pool);
 }
 
 
-AP_DECLARE(apr_status_t) ap_regkey_value_remove(const ap_regkey_t *key, 
+AP_DECLARE(apr_status_t) ap_regkey_value_remove(const ap_regkey_t *key,
                                                 const char *valuename,
                                                 apr_pool_t *pool)
 {
     LONG rc;
 
 #if APR_HAS_UNICODE_FS
-    IF_WIN_OS_IS_UNICODE 
+    IF_WIN_OS_IS_UNICODE
     {
         apr_size_t valuelen = strlen(valuename) + 1;
         apr_size_t wvallen = 256;
diff --git a/os/win32/util_win32.c b/os/win32/util_win32.c
index 537a882..fe07b3c 100644
--- a/os/win32/util_win32.c
+++ b/os/win32/util_win32.c
@@ -31,12 +31,12 @@ AP_DECLARE(apr_status_t) ap_os_proc_filepath(char **binpath, apr_pool_t *p)
     apr_wchar_t wbinpath[APR_PATH_MAX];
 
 #if APR_HAS_UNICODE_FS
-    IF_WIN_OS_IS_UNICODE 
+    IF_WIN_OS_IS_UNICODE
     {
         apr_size_t binlen;
         apr_size_t wbinlen;
         apr_status_t rv;
-        if (!GetModuleFileNameW(NULL, wbinpath, sizeof(wbinpath) 
+        if (!GetModuleFileNameW(NULL, wbinpath, sizeof(wbinpath)
                                               / sizeof(apr_wchar_t))) {
             return apr_get_os_error();
         }
@@ -77,7 +77,7 @@ AP_DECLARE(apr_status_t) ap_os_create_privileged_process(
 
 
 /* This code is stolen from misc/win32/misc.c and apr_private.h
- * This helper code resolves late bound entry points 
+ * This helper code resolves late bound entry points
  * missing from one or more releases of the Win32 API...
  * but it sure would be nice if we didn't duplicate this code
  * from the APR ;-)
@@ -90,7 +90,7 @@ static HMODULE lateDllHandle[DLL_defined] = {
 
 FARPROC ap_load_dll_func(ap_dlltoken_e fnLib, char* fnName, int ordinal)
 {
-    if (!lateDllHandle[fnLib]) { 
+    if (!lateDllHandle[fnLib]) {
         lateDllHandle[fnLib] = LoadLibrary(lateDllName[fnLib]);
         if (!lateDllHandle[fnLib])
             return NULL;
@@ -138,7 +138,7 @@ PSECURITY_ATTRIBUTES GetNullACL()
 }
 
 
-void CleanNullACL(void *sa) 
+void CleanNullACL(void *sa)
 {
     if (sa) {
         LocalFree(((PSECURITY_ATTRIBUTES)sa)->lpSecurityDescriptor);
@@ -148,39 +148,39 @@ void CleanNullACL(void *sa)
 
 
 /*
- * The Win32 call WaitForMultipleObjects will only allow you to wait for 
- * a maximum of MAXIMUM_WAIT_OBJECTS (current 64).  Since the threading 
- * model in the multithreaded version of apache wants to use this call, 
- * we are restricted to a maximum of 64 threads.  This is a simplistic 
+ * The Win32 call WaitForMultipleObjects will only allow you to wait for
+ * a maximum of MAXIMUM_WAIT_OBJECTS (current 64).  Since the threading
+ * model in the multithreaded version of apache wants to use this call,
+ * we are restricted to a maximum of 64 threads.  This is a simplistic
  * routine that will increase this size.
  */
-DWORD wait_for_many_objects(DWORD nCount, CONST HANDLE *lpHandles, 
+DWORD wait_for_many_objects(DWORD nCount, CONST HANDLE *lpHandles,
                             DWORD dwSeconds)
 {
     time_t tStopTime;
     DWORD dwRet = WAIT_TIMEOUT;
     DWORD dwIndex=0;
     BOOL bFirst = TRUE;
-  
+
     tStopTime = time(NULL) + dwSeconds;
-  
+
     do {
         if (!bFirst)
             Sleep(1000);
         else
             bFirst = FALSE;
-          
+
         for (dwIndex = 0; dwIndex * MAXIMUM_WAIT_OBJECTS < nCount; dwIndex++) {
-            dwRet = WaitForMultipleObjects( 
+            dwRet = WaitForMultipleObjects(
                 min(MAXIMUM_WAIT_OBJECTS, nCount - (dwIndex * MAXIMUM_WAIT_OBJECTS)),
-                lpHandles + (dwIndex * MAXIMUM_WAIT_OBJECTS), 
+                lpHandles + (dwIndex * MAXIMUM_WAIT_OBJECTS),
                 0, 0);
-                                           
-            if (dwRet != WAIT_TIMEOUT) {                                          
+
+            if (dwRet != WAIT_TIMEOUT) {
               break;
             }
         }
     } while((time(NULL) < tStopTime) && (dwRet == WAIT_TIMEOUT));
-    
+
     return dwRet;
 }
diff --git a/server/config.c b/server/config.c
index e44674f..a36a01d 100644
--- a/server/config.c
+++ b/server/config.c
@@ -316,7 +316,7 @@ static int ap_invoke_filter_init(ap_filter_t *filters)
             }
         }
         filters = filters->next;
-    } 
+    }
     return OK;
 }
 
@@ -419,19 +419,19 @@ struct ap_mod_list_struct {
     const command_rec *cmd;
 };
 
-static apr_status_t reload_conf_hash(void *baton) 
+static apr_status_t reload_conf_hash(void *baton)
 {
     ap_config_hash = NULL;
     return APR_SUCCESS;
 }
 
-static void rebuild_conf_hash(apr_pool_t *p, int add_prelinked) 
+static void rebuild_conf_hash(apr_pool_t *p, int add_prelinked)
 {
     module **m;
 
     ap_config_hash = apr_hash_make(p);
 
-    apr_pool_cleanup_register(p, NULL, reload_conf_hash, 
+    apr_pool_cleanup_register(p, NULL, reload_conf_hash,
                               apr_pool_cleanup_null);
     if (add_prelinked) {
         for (m = ap_prelinked_modules; *m != NULL; m++) {
@@ -440,7 +440,7 @@ static void rebuild_conf_hash(apr_pool_t *p, int add_prelinked)
     }
 }
 
-static void ap_add_module_commands(module *m, apr_pool_t *p) 
+static void ap_add_module_commands(module *m, apr_pool_t *p)
 {
     apr_pool_t *tpool;
     ap_mod_list *mln;
@@ -1073,7 +1073,7 @@ AP_DECLARE(const char *) ap_build_cont_config(apr_pool_t *p,
     ap_directive_t *sub_tree = NULL;
 
     /* Since this function can be called recursively, allocate
-     * the temporary 8k string buffer from the temp_pool rather 
+     * the temporary 8k string buffer from the temp_pool rather
      * than the stack to avoid over-running a fixed length stack.
      */
     l = apr_palloc(temp_pool, MAX_STRING_LEN);
@@ -1142,14 +1142,14 @@ static const char *ap_walk_config_sub(const ap_directive_t *current,
 
         if (retval != NULL && strcmp(retval, DECLINE_CMD) != 0) {
             /* If the directive in error has already been set, don't
-             * replace it.  Otherwise, an error inside a container 
+             * replace it.  Otherwise, an error inside a container
              * will be reported as occuring on the first line of the
              * container.
              */
             if (!parms->err_directive) {
                 parms->err_directive = current;
             }
-            return retval; 
+            return retval;
         }
     }
 
@@ -1335,7 +1335,7 @@ AP_DECLARE(char *) ap_server_root_relative(apr_pool_t *p, const char *file)
     apr_status_t rv;
     rv = apr_filepath_merge(&newpath, ap_server_root, file,
                             APR_FILEPATH_TRUENAME, p);
-    if (newpath && (rv == APR_SUCCESS || APR_STATUS_IS_EPATHWILD(rv) 
+    if (newpath && (rv == APR_SUCCESS || APR_STATUS_IS_EPATHWILD(rv)
                                       || APR_STATUS_IS_ENOENT(rv)
                                       || APR_STATUS_IS_ENOTDIR(rv))) {
         return newpath;
@@ -1419,7 +1419,7 @@ static const char *execute_now(char *cmd_line, const char *args,
         retval = invoke_cmd(cmd, parms, sub_tree, args);
 
         if (retval != NULL) {
-            return retval; 
+            return retval;
         }
     }
 
@@ -1601,7 +1601,7 @@ static const char *process_resource_config_nofnmatch(server_rec *s,
     parms.override = (RSRC_CONF | OR_ALL) & ~(OR_AUTHCFG | OR_LIMIT);
     parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
 
-    rv = ap_pcfg_openfile(&cfp, p, fname); 
+    rv = ap_pcfg_openfile(&cfp, p, fname);
     if (rv != APR_SUCCESS) {
         char errmsg[120];
         return apr_psprintf(p, "Could not open configuration file %s: %s",
@@ -1664,7 +1664,7 @@ AP_DECLARE(const char *) ap_process_resource_config(server_rec *s,
                                fname, NULL);
         }
 
-        if (!ap_is_directory(p, path)){ 
+        if (!ap_is_directory(p, path)){
             return apr_pstrcat(p, "Include directory '", path, "' not found",
                                NULL);
         }
diff --git a/server/connection.c b/server/connection.c
index 49f8ef0..b23e79e 100644
--- a/server/connection.c
+++ b/server/connection.c
@@ -173,7 +173,7 @@ AP_CORE_DECLARE(void) ap_process_connection(conn_rec *c, void *csd)
     if (rc != OK && rc != DONE) {
         c->aborted = 1;
     }
-    
+
     if (!c->aborted) {
         ap_run_process_connection(c);
     }
diff --git a/server/core.c b/server/core.c
index 9dff466..99b3c39 100644
--- a/server/core.c
+++ b/server/core.c
@@ -435,7 +435,7 @@ static void *merge_core_dir_configs(apr_pool_t *a, void *basev, void *newv)
     }
 
     conf->allow_encoded_slashes = new->allow_encoded_slashes;
-    
+
     return (void*)conf;
 }
 
@@ -476,7 +476,7 @@ static void *create_core_server_config(apr_pool_t *a, server_rec *s)
 #define ACCEPT_FILTER_NAME "dataready"
 #endif
 #endif
-#endif 
+#endif
     apr_table_set(conf->accf_map, "http", ACCEPT_FILTER_NAME);
     apr_table_set(conf->accf_map, "https", "dataready");
 #endif
@@ -1062,7 +1062,7 @@ AP_DECLARE(const char *) ap_check_cmd_context(cmd_parms *cmd,
             return NULL;
         }
     }
-    
+
     if (((forbidden & NOT_IN_DIRECTORY)
          && ((found = find_parent(cmd->directive, "<Directory"))
              || (found = find_parent(cmd->directive, "<DirectoryMatch"))))
@@ -1354,7 +1354,7 @@ static const char *set_override(cmd_parms *cmd, void *d_, const char *l)
         }
         else if (!strcasecmp(k, "Options")) {
             d->override |= OR_OPTIONS;
-            if (v) 
+            if (v)
                 set_allow_opts(cmd, &(d->override_opts), v);
             else
                 d->override_opts = OPT_ALL;
@@ -2234,19 +2234,19 @@ static const char *set_accf_map(cmd_parms *cmd, void *dummy,
     return NULL;
 }
 
-AP_DECLARE(const char*) ap_get_server_protocol(server_rec* s) 
+AP_DECLARE(const char*) ap_get_server_protocol(server_rec* s)
 {
     core_server_config *conf = ap_get_module_config(s->module_config,
                                                     &core_module);
     return conf->protocol;
-} 
+}
 
-AP_DECLARE(void) ap_set_server_protocol(server_rec* s, const char* proto) 
+AP_DECLARE(void) ap_set_server_protocol(server_rec* s, const char* proto)
 {
     core_server_config *conf = ap_get_module_config(s->module_config,
                                                     &core_module);
     conf->protocol = proto;
-} 
+}
 
 static const char *set_protocol(cmd_parms *cmd, void *dummy,
                                 const char *arg)
@@ -2513,7 +2513,7 @@ static const char *include_config (cmd_parms *cmd, void *dummy,
     conffile = ap_server_root_relative(cmd->pool, name);
     if (!conffile) {
         *recursion = 0;
-        return apr_pstrcat(cmd->pool, "Invalid Include path ", 
+        return apr_pstrcat(cmd->pool, "Invalid Include path ",
                            name, NULL);
     }
 
@@ -2596,7 +2596,7 @@ AP_DECLARE(const char *) ap_psignature(const char *prefix, request_rec *r)
     apr_snprintf(sport, sizeof sport, "%u", (unsigned) ap_get_server_port(r));
 
     if (conf->server_signature == srv_sig_withmail) {
-        return apr_pstrcat(r->pool, prefix, "<address>", 
+        return apr_pstrcat(r->pool, prefix, "<address>",
                            ap_get_server_version(),
                            " Server at <a href=\"",
                            ap_is_url(r->server->server_admin) ? "" : "mailto:",
@@ -3085,13 +3085,13 @@ static const char *add_ct_output_filters(cmd_parms *cmd, void *conf_,
     if (!new) {
         return "invalid filter name";
     }
-    
+
     return NULL;
 }
-/* 
- * Insert filters requested by the AddOutputFilterByType 
- * configuration directive. We cannot add filters based 
- * on content-type until after the handler has started 
+/*
+ * Insert filters requested by the AddOutputFilterByType
+ * configuration directive. We cannot add filters based
+ * on content-type until after the handler has started
  * to run. Only then do we reliably know the content-type.
  */
 void ap_add_output_filters_by_type(request_rec *r)
@@ -3129,7 +3129,7 @@ static const char *set_trace_enable(cmd_parms *cmd, void *dummy,
 {
     core_server_config *conf = ap_get_module_config(cmd->server->module_config,
                                                     &core_module);
-    
+
     if (strcasecmp(arg1, "on") == 0) {
         conf->trace_enable = AP_TRACE_ENABLE;
     }
@@ -3373,7 +3373,7 @@ AP_INIT_TAKE1("ThreadStackSize", ap_mpm_set_thread_stacksize, NULL, RSRC_CONF,
 AP_INIT_TAKE1("EnableExceptionHook", ap_mpm_set_exception_hook, NULL, RSRC_CONF,
               "Controls whether exception hook may be called after a crash"),
 #endif
-AP_INIT_TAKE1("TraceEnable", set_trace_enable, NULL, RSRC_CONF, 
+AP_INIT_TAKE1("TraceEnable", set_trace_enable, NULL, RSRC_CONF,
               "'on' (default), 'off' or 'extended' to trace request body content"),
 { NULL }
 };
@@ -3405,9 +3405,9 @@ AP_DECLARE_NONSTD(int) ap_core_translate(request_rec *r)
         && !strncmp(r->uri, r->server->path, r->server->pathlen)
         && (r->server->path[r->server->pathlen - 1] == '/'
             || r->uri[r->server->pathlen] == '/'
-            || r->uri[r->server->pathlen] == '\0')) 
+            || r->uri[r->server->pathlen] == '\0'))
     {
-        /* skip all leading /'s (e.g. http://localhost///foo) 
+        /* skip all leading /'s (e.g. http://localhost///foo)
          * so we are looking at only the relative path.
          */
         char *path = r->uri + r->server->pathlen;
@@ -3430,7 +3430,7 @@ AP_DECLARE_NONSTD(int) ap_core_translate(request_rec *r)
          * /'s in a row.  This happens under windows when the document
          * root ends with a /
          */
-        /* skip all leading /'s (e.g. http://localhost///foo) 
+        /* skip all leading /'s (e.g. http://localhost///foo)
          * so we are looking at only the relative path.
          */
         char *path = r->uri;
@@ -3590,7 +3590,7 @@ static int default_handler(request_rec *r)
 
         if ((status = apr_file_open(&fd, r->filename, APR_READ | APR_BINARY
 #if APR_HAS_SENDFILE
-                            | ((d->enable_sendfile == ENABLE_SENDFILE_OFF) 
+                            | ((d->enable_sendfile == ENABLE_SENDFILE_OFF)
                                                 ? 0 : APR_SENDFILE_ENABLED)
 #endif
                                     , 0, r->pool)) != APR_SUCCESS) {
@@ -3610,7 +3610,7 @@ static int default_handler(request_rec *r)
         if ((errstatus = ap_meets_conditions(r)) != OK) {
             apr_file_close(fd);
             r->status = errstatus;
-        } 
+        }
         else {
             if (bld_content_md5) {
                 apr_table_setn(r->headers_out, "Content-MD5",
@@ -3621,7 +3621,7 @@ static int default_handler(request_rec *r)
              * that which can be stored in a single bucket (where the
              * length field is an apr_size_t), split it into several
              * buckets: */
-            if (sizeof(apr_off_t) > sizeof(apr_size_t) 
+            if (sizeof(apr_off_t) > sizeof(apr_size_t)
                 && r->finfo.size > AP_MAX_SENDFILE) {
                 apr_off_t fsize = r->finfo.size;
                 e = apr_bucket_file_create(fd, 0, AP_MAX_SENDFILE, r->pool,
diff --git a/server/core_filters.c b/server/core_filters.c
index 4a9327a..52ee917 100644
--- a/server/core_filters.c
+++ b/server/core_filters.c
@@ -15,7 +15,7 @@
  */
 
 /**
- * @file  core_filters.c 
+ * @file  core_filters.c
  * @brief Core input/output network filters.
  */
 
@@ -87,7 +87,7 @@ do { \
 static void brigade_move(apr_bucket_brigade *b, apr_bucket_brigade *a,
                          apr_bucket *e)
 {
-    apr_bucket *f;     
+    apr_bucket *f;
 
     if (e != APR_BRIGADE_SENTINEL(b)) {
         f = APR_RING_LAST(&b->list);
@@ -350,7 +350,7 @@ apr_status_t ap_core_output_filter(ap_filter_t *f, apr_bucket_brigade *new_bb)
     apr_bucket_brigade *bb;
     apr_bucket *bucket, *next;
     apr_size_t bytes_in_brigade, non_file_bytes_in_brigade;
-       
+
     if (ctx == NULL) {
         apr_status_t rv;
         ctx = apr_pcalloc(c->pool, sizeof(*ctx));
@@ -368,7 +368,7 @@ apr_status_t ap_core_output_filter(ap_filter_t *f, apr_bucket_brigade *new_bb)
             }
         }
     }
-    
+
     if ((ctx->buffered_bb != NULL) &&
         !APR_BRIGADE_EMPTY(ctx->buffered_bb)) {
         bb = ctx->buffered_bb;
@@ -420,7 +420,7 @@ apr_status_t ap_core_output_filter(ap_filter_t *f, apr_bucket_brigade *new_bb)
         setaside_remaining_output(f, ctx, bb, 0, c);
         return rv;
     }
-    
+
     bytes_in_brigade = 0;
     non_file_bytes_in_brigade = 0;
     for (bucket = APR_BRIGADE_FIRST(bb); bucket != APR_BRIGADE_SENTINEL(bb);
@@ -506,8 +506,8 @@ static void setaside_remaining_output(ap_filter_t *f,
         apr_brigade_destroy(bb);
     }
 }
- 
-#ifndef APR_MAX_IOVEC_SIZE 
+
+#ifndef APR_MAX_IOVEC_SIZE
 #define MAX_IOVEC_TO_WRITE 16
 #else
 #if APR_MAX_IOVEC_SIZE > 16
@@ -656,7 +656,7 @@ static apr_status_t writev_nonblocking(apr_socket_t *s,
     if (arv != APR_SUCCESS) {
         return arv;
     }
-    
+
     for (i = 0; i < nvec; i++) {
         bytes_to_write += vec[i].iov_len;
     }
diff --git a/server/eoc_bucket.c b/server/eoc_bucket.c
index 047e9c8..dcdc97b 100644
--- a/server/eoc_bucket.c
+++ b/server/eoc_bucket.c
@@ -17,7 +17,7 @@
 #include "httpd.h"
 #include "http_connection.h"
 
-static apr_status_t eoc_bucket_read(apr_bucket *b, const char **str, 
+static apr_status_t eoc_bucket_read(apr_bucket *b, const char **str,
                                     apr_size_t *len, apr_read_type_e block)
 {
     *str = NULL;
@@ -31,7 +31,7 @@ AP_DECLARE(apr_bucket *) ap_bucket_eoc_make(apr_bucket *b)
     b->start       = 0;
     b->data        = NULL;
     b->type        = &ap_bucket_type_eoc;
-    
+
     return b;
 }
 
diff --git a/server/eor_bucket.c b/server/eor_bucket.c
index c7c559e..bbc55ba 100644
--- a/server/eor_bucket.c
+++ b/server/eor_bucket.c
@@ -19,7 +19,7 @@
 #include "http_protocol.h"
 #include "scoreboard.h"
 
-static apr_status_t eor_bucket_read(apr_bucket *b, const char **str, 
+static apr_status_t eor_bucket_read(apr_bucket *b, const char **str,
                                     apr_size_t *len, apr_read_type_e block)
 {
     *str = NULL;
@@ -33,7 +33,7 @@ AP_DECLARE(apr_bucket *) ap_bucket_eor_make(apr_bucket *b, request_rec *r)
     b->start       = 0;
     b->data        = r;
     b->type        = &ap_bucket_type_eor;
-    
+
     return b;
 }
 
diff --git a/server/gen_test_char.c b/server/gen_test_char.c
index 81c67f5..be9bc57 100644
--- a/server/gen_test_char.c
+++ b/server/gen_test_char.c
@@ -66,9 +66,9 @@ int main(int argc, char *argv[])
         /* Win32/OS2 have many of the same vulnerable characters
          * as Unix sh, plus the carriage return and percent char.
          * The proper escaping of these characters varies from unix
-         * since Win32/OS2 use carets or doubled-double quotes, 
-         * and neither lf nor cr can be escaped.  We escape unix 
-         * specific as well, to assure that cross-compiled unix 
+         * since Win32/OS2 use carets or doubled-double quotes,
+         * and neither lf nor cr can be escaped.  We escape unix
+         * specific as well, to assure that cross-compiled unix
          * applications behave similiarly when invoked on win32/os2.
          *
          * Rem please keep in-sync with apr's list in win32/filesys.c
diff --git a/server/listen.c b/server/listen.c
index 741df13..0a8ebf3 100644
--- a/server/listen.c
+++ b/server/listen.c
@@ -160,7 +160,7 @@ static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
     stat = apr_socket_opt_set(s, APR_SO_REUSEADDR, one);
     if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
         ap_log_perror(APLOG_MARK, APLOG_CRIT, stat, p,
-                    "make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)", 
+                    "make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)",
                      server->bind_addr);
         apr_socket_close(s);
         return stat;
@@ -197,7 +197,7 @@ static const char* find_accf_name(server_rec *s, const char *proto)
     return accf;
 }
 
-static void ap_apply_accept_filter(apr_pool_t *p, ap_listen_rec *lis, 
+static void ap_apply_accept_filter(apr_pool_t *p, ap_listen_rec *lis,
                                            server_rec *server)
 {
     apr_socket_t *s = lis->sd;
@@ -216,7 +216,7 @@ static void ap_apply_accept_filter(apr_pool_t *p, ap_listen_rec *lis,
 
     if (accf) {
 #if APR_HAS_SO_ACCEPTFILTER
-        rv = apr_socket_accept_filter(s, apr_pstrdup(p, accf), 
+        rv = apr_socket_accept_filter(s, apr_pstrdup(p, accf),
                                       apr_pstrdup(p,""));
         if (rv != APR_SUCCESS && !APR_STATUS_IS_ENOTIMPL(rv)) {
             ap_log_perror(APLOG_MARK, APLOG_WARNING, rv, p,
@@ -225,7 +225,7 @@ static void ap_apply_accept_filter(apr_pool_t *p, ap_listen_rec *lis,
         }
 #else
 #ifdef APR_TCP_DEFER_ACCEPT
-        rv = apr_socket_opt_set(s, APR_TCP_DEFER_ACCEPT, 1);   
+        rv = apr_socket_opt_set(s, APR_TCP_DEFER_ACCEPT, 1);
         if (rv != APR_SUCCESS && !APR_STATUS_IS_ENOTIMPL(rv)) {
             ap_log_perror(APLOG_MARK, APLOG_WARNING, rv, p,
                               "Failed to enable APR_TCP_DEFER_ACCEPT");
@@ -241,7 +241,7 @@ static apr_status_t close_listeners_on_exec(void *v)
     return APR_SUCCESS;
 }
 
-static const char *alloc_listener(process_rec *process, char *addr, 
+static const char *alloc_listener(process_rec *process, char *addr,
                                   apr_port_t port, const char* proto)
 {
     ap_listen_rec **walk, *last;
@@ -515,8 +515,8 @@ AP_DECLARE(int) ap_setup_listeners(server_rec *s)
         proto = ap_get_server_protocol(ls);
         if (!proto) {
             found = 0;
-            /* No protocol was set for this vhost, 
-             * use the default for this listener. 
+            /* No protocol was set for this vhost,
+             * use the default for this listener.
              */
             for (addr = ls->addrs; addr && !found; addr = addr->next) {
                 for (lr = ap_listeners; lr; lr = lr->next) {
@@ -561,7 +561,7 @@ AP_DECLARE(int) ap_setup_listeners(server_rec *s)
     return num_listeners;
 }
 
-AP_DECLARE_NONSTD(void) ap_close_listeners(void) 
+AP_DECLARE_NONSTD(void) ap_close_listeners(void)
 {
     ap_listen_rec *lr;
 
diff --git a/server/log.c b/server/log.c
index 12c8dc9..953782f 100644
--- a/server/log.c
+++ b/server/log.c
@@ -185,7 +185,7 @@ AP_DECLARE(void) ap_open_stderr_log(apr_pool_t *p)
     apr_file_open_stderr(&stderr_log, p);
 }
 
-AP_DECLARE(apr_status_t) ap_replace_stderr_log(apr_pool_t *p, 
+AP_DECLARE(apr_status_t) ap_replace_stderr_log(apr_pool_t *p,
                                                const char *fname)
 {
     apr_file_t *stderr_file;
@@ -328,7 +328,7 @@ static int open_error_log(server_rec *s, apr_pool_t *p)
     return OK;
 }
 
-int ap_open_logs(apr_pool_t *pconf, apr_pool_t *p /* plog */, 
+int ap_open_logs(apr_pool_t *pconf, apr_pool_t *p /* plog */,
                  apr_pool_t *ptemp, server_rec *s_main)
 {
     apr_status_t rc = APR_SUCCESS;
@@ -679,7 +679,7 @@ AP_DECLARE(void) ap_log_pid(apr_pool_t *p, const char *filename)
 
     fname = ap_server_root_relative(p, filename);
     if (!fname) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, APR_EBADPATH, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, APR_EBADPATH,
                      NULL, "Invalid PID file path %s, ignoring.", filename);
         return;
     }
@@ -732,7 +732,7 @@ AP_DECLARE(apr_status_t) ap_read_pid(apr_pool_t *p, const char *filename,
 
     fname = ap_server_root_relative(p, filename);
     if (!fname) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, APR_EBADPATH, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_CRIT, APR_EBADPATH,
                      NULL, "Invalid PID file path %s, ignoring.", filename);
         return APR_EGENERAL;
     }
@@ -794,7 +794,7 @@ static apr_status_t piped_log_spawn(piped_log *pl)
 
     if (((status = apr_procattr_create(&procattr, pl->p)) != APR_SUCCESS) ||
         ((status = apr_procattr_cmdtype_set(procattr,
-                                            APR_SHELLCMD_ENV)) != APR_SUCCESS) || 
+                                            APR_SHELLCMD_ENV)) != APR_SUCCESS) ||
         ((status = apr_procattr_child_in_set(procattr,
                                              ap_piped_log_read_fd(pl),
                                              ap_piped_log_write_fd(pl)))
diff --git a/server/main.c b/server/main.c
index 3b0d207..72f7963 100644
--- a/server/main.c
+++ b/server/main.c
@@ -403,11 +403,11 @@ static void usage(process_rec *process)
                  "  -t -D DUMP_VHOSTS  : show parsed settings (currently only "
                  "vhost settings)");
     ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                 "  -S                 : a synonym for -t -D DUMP_VHOSTS");   
+                 "  -S                 : a synonym for -t -D DUMP_VHOSTS");
     ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                  "  -t -D DUMP_MODULES : show all loaded modules ");
     ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
-                 "  -M                 : a synonym for -t -D DUMP_MODULES");   
+                 "  -M                 : a synonym for -t -D DUMP_MODULES");
     ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                  "  -t                 : run syntax check for config files");
 
@@ -563,7 +563,7 @@ int main(int argc, const char * const argv[])
         case 't':
             configtestonly = 1;
             break;
-        
+
         case 'S':
             configtestonly = 1;
             new = (char **)apr_array_push(ap_server_config_defines);
@@ -575,7 +575,7 @@ int main(int argc, const char * const argv[])
             new = (char **)apr_array_push(ap_server_config_defines);
             *new = "DUMP_MODULES";
             break;
-            
+
         case 'h':
         case '?':
             usage(process);
diff --git a/server/mpm/beos/beos.c b/server/mpm/beos/beos.c
index a04fc62..b5ed9f2 100644
--- a/server/mpm/beos/beos.c
+++ b/server/mpm/beos/beos.c
@@ -29,10 +29,10 @@
  * TODO Items
  *
  * - on exit most worker threads segfault trying to access a kernel page.
- */ 
- 
-#define CORE_PRIVATE 
- 
+ */
+
+#define CORE_PRIVATE
+
 #include <kernel/OS.h>
 #include <unistd.h>
 #include <sys/socket.h>
@@ -40,16 +40,16 @@
 
 #include "apr_strings.h"
 #include "apr_portable.h"
-#include "httpd.h" 
-#include "http_main.h" 
-#include "http_log.h" 
-#include "http_config.h"	/* for read_config */ 
-#include "http_core.h"		/* for get_remote_host */ 
+#include "httpd.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "http_config.h"	/* for read_config */
+#include "http_core.h"		/* for get_remote_host */
 #include "http_connection.h"
 #include "ap_mpm.h"
 #include "beosd.h"
 #include "ap_listen.h"
-#include "scoreboard.h" 
+#include "scoreboard.h"
 #include "mpm_common.h"
 #include "mpm.h"
 #include "mpm_default.h"
@@ -71,7 +71,7 @@ extern int _kset_fd_limit_(int num);
  *    the overhead.
  */
 
-/* we only ever have 1 main process running... */ 
+/* we only ever have 1 main process running... */
 #define HARD_SERVER_LIMIT 1
 
 /* Limit on the threads per process.  Clients will be locked out if more than
@@ -85,7 +85,7 @@ extern int _kset_fd_limit_(int num);
 #define HARD_THREAD_LIMIT 1
 #endif
 #ifndef HARD_THREAD_LIMIT
-#define HARD_THREAD_LIMIT 50 
+#define HARD_THREAD_LIMIT 50
 #endif
 
 /*
@@ -103,12 +103,12 @@ apr_thread_mutex_t *accept_mutex = NULL;
 
 static apr_pool_t *pconf;		/* Pool for config stuff */
 
-static int server_pid; 
+static int server_pid;
 
 
 /*
  * The max child slot ever assigned, preserved across restarts.  Necessary
- * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We use 
+ * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We use
  * this value to optimize routines that have to scan the entire scoreboard.
  */
 int ap_max_child_assigned = -1;
@@ -140,7 +140,7 @@ static void check_restart(void *data);
  */
 static void clean_child_exit(int code, int slot)
 {
-    (void) ap_update_child_status_from_indexes(0, slot, SERVER_DEAD, 
+    (void) ap_update_child_status_from_indexes(0, slot, SERVER_DEAD,
                                                (request_rec*)NULL);
     ap_scoreboard_image->servers[0][slot].tid = 0;
     exit_thread(code);
@@ -160,8 +160,8 @@ ap_generation_t volatile ap_my_generation = 0;
 
 /*
  * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
- * functions to initiate shutdown or restart without relying on signals. 
- * Previously this was initiated in sig_term() and restart() signal handlers, 
+ * functions to initiate shutdown or restart without relying on signals.
+ * Previously this was initiated in sig_term() and restart() signal handlers,
  * but we want to be able to start a shutdown/restart from other sources --
  * e.g. on Win32, from the service manager. Now the service manager can
  * call ap_start_shutdown() or ap_start_restart() as appropiate.  Note that
@@ -183,10 +183,10 @@ static void ap_start_shutdown(void)
      * may well get triggered while we are working through previous attempt
      * to shutdown. We won't worry about even reporting it as it seems a little
      * pointless.
-     */ 
+     */
     if (shutdown_pending == 1)
         return;
-       
+
     shutdown_pending = 1;
 }
 
@@ -254,7 +254,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
         case AP_MPMQ_MIN_SPARE_DAEMONS:
             *result = 0;
             return APR_SUCCESS;
-        case AP_MPMQ_MIN_SPARE_THREADS:    
+        case AP_MPMQ_MIN_SPARE_THREADS:
             *result = max_spare_threads;
             return APR_SUCCESS;
         case AP_MPMQ_MAX_SPARE_DAEMONS:
@@ -287,7 +287,7 @@ static apr_status_t beos_accept(void **accepted, ap_listen_rec *lr, apr_pool_t *
 
     *accepted = NULL;
     status = apr_socket_accept(&csd, lr->sd, ptrans);
-    if (status == APR_SUCCESS) { 
+    if (status == APR_SUCCESS) {
         *accepted = csd;
         apr_os_sock_get(&sockdes, csd);
         return status;
@@ -348,7 +348,7 @@ static void tell_workers_to_exit(void)
         len = 4;
         if (apr_socket_sendto(udp_sock, udp_sa, 0, "die!", &len) != APR_SUCCESS)
             break;
-    }   
+    }
 }
 
 static void set_signals(void)
@@ -379,13 +379,13 @@ static void set_signals(void)
             ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
     if (sigaction(SIGINT, &sa, NULL) < 0)
         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGINT)");
-    
+
     /* We ignore SIGPIPE */
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGPIPE, &sa, NULL) < 0)
     	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGPIPE)");
 
-    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy 
+    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy
      * processing one */
     sigaddset(&sa.sa_mask, SIGHUP);
     sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
@@ -426,7 +426,7 @@ static int32 worker_thread(void *dummy)
      * this we create the ptrans pool, the lifetime of which is the same
      * as each connection and is reset prior to each attempt to
      * process a connection.
-     */ 
+     */
     apr_pool_t *ptrans = NULL;
     apr_pool_t *pworker = NULL;
 
@@ -435,7 +435,7 @@ static int32 worker_thread(void *dummy)
                                   */
 
     on_exit_thread(check_restart, (void*)worker_slot);
-          
+
     /* block the signals for this thread only if we're not running as a
      * single process.
      */
@@ -459,7 +459,7 @@ static int32 worker_thread(void *dummy)
 
     ap_create_sb_handle(&sbh, pworker, 0, worker_slot);
     (void) ap_update_child_status(sbh, SERVER_READY, (request_rec *) NULL);
-                               
+
     /* We add an extra socket here as we add the udp_sock we use for signalling
      * death. This gets added after the others.
      */
@@ -467,21 +467,21 @@ static int32 worker_thread(void *dummy)
 
     for (lr = ap_listeners, i = num_listening_sockets; i--; lr = lr->next) {
         apr_pollfd_t pfd = {0};
-        
+
         pfd.desc_type = APR_POLL_SOCKET;
         pfd.desc.s = lr->sd;
         pfd.reqevents = APR_POLLIN;
         pfd.client_data = lr;
-        
+
         apr_pollset_add(pollset, &pfd);
     }
     {
         apr_pollfd_t pfd = {0};
-        
+
         pfd.desc_type = APR_POLL_SOCKET;
         pfd.desc.s = udp_sock;
         pfd.reqevents = APR_POLLIN;
-        
+
         apr_pollset_add(pollset, &pfd);
     }
 
@@ -496,12 +496,12 @@ static int32 worker_thread(void *dummy)
         /* (Re)initialize this child to a pre-connection state. */
         apr_pool_clear(ptrans);
 
-        if ((ap_max_requests_per_thread > 0 
+        if ((ap_max_requests_per_thread > 0
              && requests_this_child++ >= ap_max_requests_per_thread))
             clean_child_exit(0, worker_slot);
-        
+
         (void) ap_update_child_status(sbh, SERVER_READY, (request_rec *) NULL);
-        
+
         apr_thread_mutex_lock(accept_mutex);
 
         /* We always (presently) have at least 2 sockets we listen on, so
@@ -543,7 +543,7 @@ static int32 worker_thread(void *dummy)
              * ### hmm... this descriptor might have POLLERR rather
              * ### than POLLIN
              */
-            
+
             lr = pdesc[last_poll_idx++].client_data;
 
             /* The only socket we add without client_data is the first, the UDP socket
@@ -581,7 +581,7 @@ got_fd:
             ap_process_connection(current_conn, csd);
             ap_lingering_close(current_conn);
         }
-        
+
         if (ap_my_generation !=
                  ap_scoreboard_image->global->running_generation) { /* restart? */
             /* yeah, this could be non-graceful restart, in which case the
@@ -594,7 +594,7 @@ got_a_black_spot:
 
    	apr_pool_destroy(ptrans);
     apr_pool_destroy(pworker);
-    	
+
     clean_child_exit(0, worker_slot);
 }
 
@@ -617,16 +617,16 @@ static int make_worker(int slot)
     tid = spawn_thread(worker_thread, "apache_worker", B_NORMAL_PRIORITY,
                        (void *)slot);
     if (tid < B_NO_ERROR) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, NULL,
             "spawn_thread: Unable to start a new thread");
         /* In case system resources are maxed out, we don't want
          * Apache running away with the CPU trying to fork over and
-         * over and over again. 
+         * over and over again.
          */
-        (void) ap_update_child_status_from_indexes(0, slot, SERVER_DEAD, 
+        (void) ap_update_child_status_from_indexes(0, slot, SERVER_DEAD,
                                                    (request_rec*)NULL);
-        
-    	sleep(10);       
+
+    	sleep(10);
     	return -1;
     }
     resume_thread(tid);
@@ -644,7 +644,7 @@ static void check_restart(void *data)
     if (!restart_pending && !shutdown_pending) {
         int slot = (int)data;
         make_worker(slot);
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL,
                      "spawning a new worker thread in slot %d", slot);
     }
 }
@@ -737,7 +737,7 @@ static void server_main_loop(int remaining_threads_to_start)
     while (!restart_pending && !shutdown_pending) {
 
         ap_wait_or_timeout(&exitwhy, &status, &pid, pconf);
-         
+
         if (pid.pid >= 0) {
             if (ap_process_child_status(&pid, exitwhy, status) == APEXIT_CHILDFATAL) {
                 shutdown_pending = 1;
@@ -754,10 +754,10 @@ static void server_main_loop(int remaining_threads_to_start)
             }
             if (child_slot >= 0) {
                 ap_scoreboard_image->servers[0][child_slot].tid = 0;
-                (void) ap_update_child_status_from_indexes(0, child_slot, 
-                                                           SERVER_DEAD, 
+                (void) ap_update_child_status_from_indexes(0, child_slot,
+                                                           SERVER_DEAD,
                                                            (request_rec*)NULL);
-                
+
                 if (remaining_threads_to_start
                             && child_slot < ap_thread_limit) {
                     /* we're still doing a 1-for-1 replacement of dead
@@ -781,7 +781,7 @@ static void server_main_loop(int remaining_threads_to_start)
                  ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ap_server_conf,
                                           "long lost child came home! (pid %ld)", pid.pid);
             }
-            
+
             /* Don't perform idle maintenance when a child dies,
              * only do it when there's a timeout.  Remember only a
              * finite number of children can die, and it's pretty
@@ -808,14 +808,14 @@ static void server_main_loop(int remaining_threads_to_start)
 
 /* This is called to not only setup and run for the initial time, but also
  * when we've asked for a restart. This means it must be able to handle both
- * situations. It also means that when we exit here we should have tidied 
+ * situations. It also means that when we exit here we should have tidied
  * up after ourselves fully.
  */
 int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 {
     int remaining_threads_to_start, i,j;
     apr_status_t rv;
-    ap_listen_rec *lr;    
+    ap_listen_rec *lr;
     pconf = _pconf;
     ap_server_conf = s;
 
@@ -827,7 +827,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
             "could not set FD_SETSIZE (_kset_fd_limit_ failed)");
     }
 
-    /* BeOS R5 doesn't support pipes on select() calls, so we use a 
+    /* BeOS R5 doesn't support pipes on select() calls, so we use a
      * UDP socket as these are supported in both R5 and BONE.  If we only cared
      * about BONE we'd use a pipe, but there it is.
      * As we have UDP support in APR, now use the APR functions and check all the
@@ -850,7 +850,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
             "couldn't bind UDP socket!");
         return 1;
     }
- 
+
     if ((num_listening_sockets = ap_setup_listeners(ap_server_conf)) < 1) {
         ap_log_error(APLOG_MARK, APLOG_ALERT, 0, s,
             "no listening sockets available, shutting down");
@@ -860,9 +860,9 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     ap_log_pid(pconf, ap_pid_fname);
 
     /*
-     * Create our locks... 
+     * Create our locks...
      */
-    
+
     /* accept_mutex
      * used to lock around select so we only have one thread
      * in select at a time
@@ -877,9 +877,9 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     }
 
     /*
-     * Startup/shutdown... 
+     * Startup/shutdown...
      */
-    
+
     if (!is_graceful) {
         /* setup the scoreboard shared memory */
         if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) {
@@ -904,8 +904,8 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
     /* If we're doing a graceful_restart then we're going to see a lot
      * of threads exiting immediately when we get into the main loop
-     * below (because we just sent them AP_SIG_GRACEFUL).  This happens 
-     * pretty rapidly... and for each one that exits we'll start a new one 
+     * below (because we just sent them AP_SIG_GRACEFUL).  This happens
+     * pretty rapidly... and for each one that exits we'll start a new one
      * until we reach at least threads_min_free.  But we may be permitted to
      * start more than that, so we'll just keep track of how many we're
      * supposed to start up without the 1 second penalty between each fork.
@@ -947,18 +947,18 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     /* We sit in the server_main_loop() until we somehow manage to exit. When
      * we do, we need to kill the workers we have, so we start by using the
      * tell_workers_to_exit() function, but as it sometimes takes a short while
-     * to accomplish this we have a pause builtin to allow them the chance to 
+     * to accomplish this we have a pause builtin to allow them the chance to
      * gracefully exit.
      */
     if (!one_process) {
-        server_main_loop(remaining_threads_to_start);   
+        server_main_loop(remaining_threads_to_start);
         tell_workers_to_exit();
         snooze(1000000);
     } else {
         worker_thread((void*)0);
     }
     mpm_state = AP_MPMQ_STOPPING;
-        
+
     /* close the UDP socket we've been using... */
     apr_socket_close(udp_sock);
 
@@ -967,14 +967,14 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         pidfile = ap_server_root_relative (pconf, ap_pid_fname);
         if ( pidfile != NULL && unlink(pidfile) == 0)
             ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
-                         "removed PID file %s (pid=%ld)", pidfile, 
+                         "removed PID file %s (pid=%ld)", pidfile,
                          (long)getpid());
     }
 
     if (one_process) {
         return 1;
     }
-        
+
     /*
      * If we get here we're shutting down...
      */
@@ -985,7 +985,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         if (beosd_killpg(getpgrp(), SIGTERM) < 0)
             ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
              "killpg SIGTERM");
-      
+
         /* use ap_reclaim_child_processes starting with SIGTERM */
         ap_reclaim_child_processes(1);
 
@@ -994,7 +994,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
             ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                          "caught SIGTERM, shutting down");
         }
-    
+
         return 1;
     }
 
@@ -1005,21 +1005,21 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                     AP_SIG_GRACEFUL_STRING " received.  Doing graceful restart");
     } else {
-        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM 
+        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM
          * and a SIGHUP, we may as well use the same signal, because some user
          * pthreads are stealing signals from us left and right.
          */
-            
+
         ap_reclaim_child_processes(1);		/* Start with SIGTERM */
             ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                     "SIGHUP received.  Attempting to restart");
     }
-    
-    /* just before we go, tidy up the lock we created to prevent a 
-     * potential leak of semaphores... 
+
+    /* just before we go, tidy up the lock we created to prevent a
+     * potential leak of semaphores...
      */
     apr_thread_mutex_destroy(accept_mutex);
-    
+
     return 0;
 }
 
@@ -1047,7 +1047,7 @@ static int beos_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptem
     /* sigh, want this only the second time around */
     if (restart_num++ == 1) {
         is_graceful = 0;
-        
+
         if (!one_process && !foreground) {
             rv = apr_proc_detach(no_detach ? APR_PROC_DETACH_FOREGROUND
                                            : APR_PROC_DETACH_DAEMONIZE);
@@ -1055,7 +1055,7 @@ static int beos_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptem
                 ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                              "apr_proc_detach failed");
                 return HTTP_INTERNAL_SERVER_ERROR;
-            }                  
+            }
         }
 
         server_pid = getpid();
@@ -1081,11 +1081,11 @@ static int beos_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptem
 static void beos_hooks(apr_pool_t *p)
 {
     one_process = 0;
-    
-    ap_hook_pre_config(beos_pre_config, NULL, NULL, APR_HOOK_MIDDLE); 
+
+    ap_hook_pre_config(beos_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
-static const char *set_threads_to_start(cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_threads_to_start(cmd_parms *cmd, void *dummy, const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1110,15 +1110,15 @@ static const char *set_min_spare_threads(cmd_parms *cmd, void *dummy, const char
 
     min_spare_threads = atoi(arg);
     if (min_spare_threads <= 0) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: detected MinSpareThreads set to non-positive.");
        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Resetting to 1 to avoid almost certain Apache failure.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Please read the documentation.");
        min_spare_threads = 1;
     }
-       
+
     return NULL;
 }
 
@@ -1133,7 +1133,7 @@ static const char *set_max_spare_threads(cmd_parms *cmd, void *dummy, const char
     return NULL;
 }
 
-static const char *set_threads_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_threads_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1142,18 +1142,18 @@ static const char *set_threads_limit (cmd_parms *cmd, void *dummy, const char *a
 
     ap_thread_limit = atoi(arg);
     if (ap_thread_limit > HARD_THREAD_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients of %d exceeds compile time limit "
                     "of %d servers,", ap_thread_limit, HARD_THREAD_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering MaxClients to %d.  To increase, please "
                     "see the", HARD_THREAD_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " HARD_THREAD_LIMIT define in server/mpm/beos/mpm_default.h.");
        ap_thread_limit = HARD_THREAD_LIMIT;
-    } 
+    }
     else if (ap_thread_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require MaxClients > 0, setting to %d", HARD_THREAD_LIMIT);
         ap_thread_limit = HARD_THREAD_LIMIT;
     }
@@ -1187,7 +1187,7 @@ AP_INIT_TAKE1( "MinSpareThreads", set_min_spare_threads, NULL, RSRC_CONF,
   "Minimum number of idle children, to handle request spikes"),
 AP_INIT_TAKE1( "MaxSpareThreads", set_max_spare_threads, NULL, RSRC_CONF,
   "Maximum number of idle children" ),
-AP_INIT_TAKE1( "MaxClients", set_threads_limit, NULL, RSRC_CONF, 
+AP_INIT_TAKE1( "MaxClients", set_threads_limit, NULL, RSRC_CONF,
   "Maximum number of children alive at the same time (max threads)" ),
 AP_INIT_TAKE1( "MaxRequestsPerThread", set_max_requests_per_thread, NULL, RSRC_CONF,
   "Maximum number of requests served by a thread" ),
diff --git a/server/mpm/experimental/event/event.c b/server/mpm/experimental/event/event.c
index f508cfe..c5393c1 100644
--- a/server/mpm/experimental/event/event.c
+++ b/server/mpm/experimental/event/event.c
@@ -176,7 +176,7 @@ typedef struct
     int sd;
 } proc_info;
 
-/* Structure used to pass information to the thread responsible for 
+/* Structure used to pass information to the thread responsible for
  * creating the rest of the threads.
  */
 typedef struct
@@ -204,8 +204,8 @@ typedef struct
 
 /*
  * The max child slot ever assigned, preserved across restarts.  Necessary
- * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We 
- * use this value to optimize routines that have to scan the entire 
+ * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We
+ * use this value to optimize routines that have to scan the entire
  * scoreboard.
  */
 int ap_max_daemons_limit = -1;
@@ -238,14 +238,14 @@ int raise_sigstop_flags;
 static apr_pool_t *pconf;       /* Pool for config stuff */
 static apr_pool_t *pchild;      /* Pool for httpd child stuff */
 
-static pid_t ap_my_pid;         /* Linux getpid() doesn't work except in main 
+static pid_t ap_my_pid;         /* Linux getpid() doesn't work except in main
                                    thread. Use this instead */
 static pid_t parent_pid;
 static apr_os_thread_t *listener_os_thread;
 
-/* The LISTENER_SIGNAL signal will be sent from the main thread to the 
- * listener thread to wake it up for graceful termination (what a child 
- * process from an old generation does when the admin does "apachectl 
+/* The LISTENER_SIGNAL signal will be sent from the main thread to the
+ * listener thread to wake it up for graceful termination (what a child
+ * process from an old generation does when the admin does "apachectl
  * graceful").  This signal will be blocked in all threads of a child
  * process except for the listener thread.
  */
@@ -272,7 +272,7 @@ static void wakeup_listener(void)
     listener_may_exit = 1;
     if (!listener_os_thread) {
         /* XXX there is an obscure path that this doesn't handle perfectly:
-         *     right after listener thread is created but before 
+         *     right after listener thread is created but before
          *     listener_os_thread is set, the first worker thread hits an
          *     error and starts graceful termination
          */
@@ -280,7 +280,7 @@ static void wakeup_listener(void)
     }
     /*
      * we should just be able to "kill(ap_my_pid, LISTENER_SIGNAL)" on all
-     * platforms and wake up the listener thread since it is the only thread 
+     * platforms and wake up the listener thread since it is the only thread
      * with SIGHUP unblocked, but that doesn't work on Linux
      */
 #ifdef HAVE_PTHREAD_KILL
@@ -399,8 +399,8 @@ ap_generation_t volatile ap_my_generation;
 
 /*
  * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
- * functions to initiate shutdown or restart without relying on signals. 
- * Previously this was initiated in sig_term() and restart() signal handlers, 
+ * functions to initiate shutdown or restart without relying on signals.
+ * Previously this was initiated in sig_term() and restart() signal handlers,
  * but we want to be able to start a shutdown/restart from other sources --
  * e.g. on Win32, from the service manager. Now the service manager can
  * call ap_start_shutdown() or ap_start_restart() as appropiate.  Note that
@@ -499,7 +499,7 @@ static void set_signals(void)
                      "sigaction(SIGPIPE)");
 #endif
 
-    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy 
+    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy
      * processing one */
     sigaddset(&sa.sa_mask, SIGHUP);
     sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
@@ -604,14 +604,14 @@ static int process_socket(apr_pool_t * p, apr_socket_t * sock,
         }
 
         /**
-         * XXX If the platform does not have a usable way of bundling 
-         * accept() with a socket readability check, like Win32, 
+         * XXX If the platform does not have a usable way of bundling
+         * accept() with a socket readability check, like Win32,
          * and there are measurable delays before the
          * socket is readable due to the first data packet arriving,
          * it might be better to create the cs on the listener thread
          * with the state set to CONN_STATE_CHECK_REQUEST_LINE_READABLE
          *
-         * FreeBSD users will want to enable the HTTP accept filter 
+         * FreeBSD users will want to enable the HTTP accept filter
          * module in their kernel for the highest performance
          * When the accept filter is active, sockets are kept in the
          * kernel until a HTTP request is received.
@@ -639,7 +639,7 @@ read_request:
             cs->state = CONN_STATE_LINGER;
         }
     }
-    
+
     if (cs->state == CONN_STATE_WRITE_COMPLETION) {
         /* For now, do blocking writes in this thread to transfer the
          * rest of the response.  TODO: Hand off this connection to a
@@ -670,7 +670,7 @@ read_request:
             rc = apr_pollset_add(event_pollset, &cs->pfd);
             return 1;
         }
-        else if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted || 
+        else if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted ||
             ap_graceful_stop_signalled()) {
             c->cs->state = CONN_STATE_LINGER;
         }
@@ -780,7 +780,7 @@ static apr_status_t push2worker(const apr_pollfd_t * pfd,
 
     rc = apr_pollset_remove(pollset, pfd);
 
-    /* 
+    /*
      * Some of the pollset backends, like KQueue or Epoll
      * automagically remove the FD if the socket is closed,
      * therefore, we can accept _SUCCESS or _NOTFOUND,
@@ -793,7 +793,7 @@ static apr_status_t push2worker(const apr_pollfd_t * pfd,
     rc = ap_queue_push(worker_queue, cs->pfd.desc.s, cs, cs->p);
     if (rc != APR_SUCCESS) {
         /* trash the connection; we couldn't queue the connected
-         * socket to a worker 
+         * socket to a worker
          */
         apr_bucket_alloc_destroy(cs->bucket_alloc);
         apr_socket_close(cs->pfd.desc.s);
@@ -1023,7 +1023,7 @@ static void *listener_thread(apr_thread_t * thd, void *dummy)
                     rc = ap_queue_push(worker_queue, csd, NULL, ptrans);
                     if (rc != APR_SUCCESS) {
                         /* trash the connection; we couldn't queue the connected
-                         * socket to a worker 
+                         * socket to a worker
                          */
                         apr_socket_close(csd);
                         ap_log_error(APLOG_MARK, APLOG_CRIT, rc,
@@ -1340,14 +1340,14 @@ static void *APR_THREAD_FUNC start_threads(apr_thread_t * thd, void *dummy)
         }
     }
 
-    /* What state should this child_main process be listed as in the 
+    /* What state should this child_main process be listed as in the
      * scoreboard...?
-     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING, 
+     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING,
      *                                      (request_rec *) NULL);
-     * 
+     *
      *  This state should be listed separately in the scoreboard, in some kind
-     *  of process_status, not mixed in with the worker threads' status.   
-     *  "life_status" is almost right, but it's in the worker's structure, and 
+     *  of process_status, not mixed in with the worker threads' status.
+     *  "life_status" is almost right, but it's in the worker's structure, and
      *  the name could be clearer.   gla
      */
     apr_thread_exit(thd, APR_SUCCESS);
@@ -1412,8 +1412,8 @@ static void join_start_thread(apr_thread_t * start_thread_id)
 {
     apr_status_t rv, thread_rv;
 
-    start_thread_may_exit = 1;  /* tell it to give up in case it is still 
-                                 * trying to take over slots from a 
+    start_thread_may_exit = 1;  /* tell it to give up in case it is still
+                                 * trying to take over slots from a
                                  * previous generation
                                  */
     rv = apr_thread_join(&thread_rv, start_thread_id);
@@ -1470,7 +1470,7 @@ static void child_main(int child_num_arg)
 
     /* Setup worker threads */
 
-    /* clear the storage; we may not create all our threads immediately, 
+    /* clear the storage; we may not create all our threads immediately,
      * and we want a 0 entry to indicate a thread which was not created
      */
     threads = (apr_thread_t **) calloc(1,
@@ -1513,7 +1513,7 @@ static void child_main(int child_num_arg)
     if (one_process) {
         /* Block until we get a terminating signal. */
         apr_signal_thread(check_signal);
-        /* make sure the start thread has finished; signal_threads() 
+        /* make sure the start thread has finished; signal_threads()
          * and join_workers() depend on that
          */
         /* XXX join_start_thread() won't be awakened if one of our
@@ -1558,7 +1558,7 @@ static void child_main(int child_num_arg)
                 }
             }
             if (rv == AP_GRACEFUL || rv == AP_RESTART) {
-                /* make sure the start thread has finished; 
+                /* make sure the start thread has finished;
                  * signal_threads() and join_workers depend on that
                  */
                 join_start_thread(start_thread_id);
@@ -1728,14 +1728,14 @@ static void perform_idle_server_maintenance(void)
                 }
             }
         }
-        if (any_dead_threads 
-            && totally_free_length < idle_spawn_rate 
-            && free_length < MAX_SPAWN_RATE 
+        if (any_dead_threads
+            && totally_free_length < idle_spawn_rate
+            && free_length < MAX_SPAWN_RATE
             && (!ps->pid      /* no process in the slot */
                   || ps->quiescing)) {  /* or at least one is going away */
             if (all_dead_threads) {
                 /* great! we prefer these, because the new process can
-                 * start more threads sooner.  So prioritize this slot 
+                 * start more threads sooner.  So prioritize this slot
                  * by putting it ahead of any slots with active threads.
                  *
                  * first, make room by moving a slot that's potentially still
@@ -1766,7 +1766,7 @@ static void perform_idle_server_maintenance(void)
             sick_child_detected = 0;
         }
         else {
-            /* looks like a basket case.  give up.  
+            /* looks like a basket case.  give up.
              */
             shutdown_pending = 1;
             child_fatal = 1;
@@ -1778,7 +1778,7 @@ static void perform_idle_server_maintenance(void)
             return;
         }
     }
-                                                    
+
     ap_max_daemons_limit = last_non_dead + 1;
 
     if (idle_thread_count > max_spare_threads) {
@@ -2065,7 +2065,7 @@ int ap_mpm_run(apr_pool_t * _pconf, apr_pool_t * plog, server_rec * s)
         ap_reclaim_child_processes(1);
 
         return 1;
-    } 
+    }
 
     /* we've been told to restart */
     apr_signal(SIGHUP, SIG_IGN);
@@ -2096,7 +2096,7 @@ int ap_mpm_run(apr_pool_t * _pconf, apr_pool_t * plog, server_rec * s)
 
     }
     else {
-        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM 
+        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM
          * and a SIGHUP, we may as well use the same signal, because some user
          * pthreads are stealing signals from us left and right.
          */
diff --git a/server/mpm/experimental/event/fdqueue.c b/server/mpm/experimental/event/fdqueue.c
index 4245c2a..b2cf3a9 100644
--- a/server/mpm/experimental/event/fdqueue.c
+++ b/server/mpm/experimental/event/fdqueue.c
@@ -308,7 +308,7 @@ apr_status_t ap_queue_init(fd_queue_t * queue, int queue_capacity,
 }
 
 /**
- * Push a new socket onto the queue. 
+ * Push a new socket onto the queue.
  *
  * precondition: ap_queue_info_wait_for_idler has already been called
  *               to reserve an idle worker thread
@@ -409,7 +409,7 @@ apr_status_t ap_queue_term(fd_queue_t * queue)
         return rv;
     }
     /* we must hold one_big_mutex when setting this... otherwise,
-     * we could end up setting it and waking everybody up just after a 
+     * we could end up setting it and waking everybody up just after a
      * would-be popper checks it but right before they block
      */
     queue->terminated = 1;
diff --git a/server/mpm/experimental/leader/leader.c b/server/mpm/experimental/leader/leader.c
index 329d043..85520b4 100644
--- a/server/mpm/experimental/leader/leader.c
+++ b/server/mpm/experimental/leader/leader.c
@@ -33,7 +33,7 @@
 #include <sys/socket.h>
 #endif
 #if APR_HAVE_SYS_WAIT_H
-#include <sys/wait.h> 
+#include <sys/wait.h>
 #endif
 #ifdef HAVE_SYS_PROCESSOR_H
 #include <sys/processor.h> /* for bindprocessor() */
@@ -43,19 +43,19 @@
 #error The Leader/Follower MPM requires APR threads, but they are unavailable.
 #endif
 
-#define CORE_PRIVATE 
- 
+#define CORE_PRIVATE
+
 #include "ap_config.h"
-#include "httpd.h" 
-#include "http_main.h" 
-#include "http_log.h" 
-#include "http_config.h"        /* for read_config */ 
-#include "http_core.h"          /* for get_remote_host */ 
+#include "httpd.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "http_config.h"        /* for read_config */
+#include "http_core.h"          /* for get_remote_host */
 #include "http_connection.h"
 #include "ap_mpm.h"
 #include "mpm_common.h"
 #include "ap_listen.h"
-#include "scoreboard.h" 
+#include "scoreboard.h"
 #include "mpm_default.h"
 #include "apr_poll.h"
 
@@ -94,7 +94,7 @@
  * the overhead.
  */
 #ifndef DEFAULT_THREAD_LIMIT
-#define DEFAULT_THREAD_LIMIT 64 
+#define DEFAULT_THREAD_LIMIT 64
 #endif
 
 /* Admin can't tune ThreadLimit beyond MAX_THREAD_LIMIT.  We want
@@ -136,7 +136,7 @@ typedef struct {
 } proc_info;
 
 
-/* Structure used to pass information to the thread responsible for 
+/* Structure used to pass information to the thread responsible for
  * creating the rest of the threads.
  */
 typedef struct {
@@ -149,8 +149,8 @@ typedef struct {
 
 /*
  * The max child slot ever assigned, preserved across restarts.  Necessary
- * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We 
- * use this value to optimize routines that have to scan the entire 
+ * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We
+ * use this value to optimize routines that have to scan the entire
  * scoreboard.
  */
 int ap_max_daemons_limit = -1;
@@ -183,7 +183,7 @@ int raise_sigstop_flags;
 static apr_pool_t *pconf;                 /* Pool for config stuff */
 static apr_pool_t *pchild;                /* Pool for httpd child stuff */
 
-static pid_t ap_my_pid; /* Linux getpid() doesn't work except in main 
+static pid_t ap_my_pid; /* Linux getpid() doesn't work except in main
                            thread. Use this instead */
 static pid_t parent_pid;
 
@@ -228,7 +228,7 @@ static worker_wakeup_info *worker_wakeup_create(apr_pool_t *pool)
 }
 
 
-/* Structure used to hold a stack of idle worker threads 
+/* Structure used to hold a stack of idle worker threads
  */
 typedef struct {
     /* 'state' consists of several fields concatenated into a
@@ -282,7 +282,7 @@ static apr_status_t worker_stack_wait(worker_stack *stack,
         else {
             return apr_thread_cond_wait(wakeup->cond, wakeup->mutex);
         }
-    }    
+    }
 }
 
 static apr_status_t worker_stack_awaken_next(worker_stack *stack)
@@ -389,7 +389,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
         case AP_MPMQ_MIN_SPARE_DAEMONS:
             *result = 0;
             return APR_SUCCESS;
-        case AP_MPMQ_MIN_SPARE_THREADS:    
+        case AP_MPMQ_MIN_SPARE_THREADS:
             *result = min_spare_threads;
             return APR_SUCCESS;
         case AP_MPMQ_MAX_SPARE_DAEMONS:
@@ -411,7 +411,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
     return APR_ENOTIMPL;
 }
 
-/* a clean exit from a child with proper cleanup */ 
+/* a clean exit from a child with proper cleanup */
 static void clean_child_exit(int code) __attribute__ ((noreturn));
 static void clean_child_exit(int code)
 {
@@ -441,8 +441,8 @@ ap_generation_t volatile ap_my_generation;
 
 /*
  * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
- * functions to initiate shutdown or restart without relying on signals. 
- * Previously this was initiated in sig_term() and restart() signal handlers, 
+ * functions to initiate shutdown or restart without relying on signals.
+ * Previously this was initiated in sig_term() and restart() signal handlers,
  * but we want to be able to start a shutdown/restart from other sources --
  * e.g. on Win32, from the service manager. Now the service manager can
  * call ap_start_shutdown() or ap_start_restart() as appropiate.  Note that
@@ -514,42 +514,42 @@ static void set_signals(void)
 
     sa.sa_handler = sig_term;
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGTERM)");
 #ifdef SIGINT
     if (sigaction(SIGINT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGINT)");
 #endif
 #ifdef SIGXCPU
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXCPU, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGXCPU)");
 #endif
 #ifdef SIGXFSZ
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXFSZ, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGXFSZ)");
 #endif
 #ifdef SIGPIPE
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGPIPE, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGPIPE)");
 #endif
 
-    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy 
+    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy
      * processing one */
     sigaddset(&sa.sa_mask, SIGHUP);
     sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
     sa.sa_handler = restart;
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGHUP)");
     if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(" AP_SIG_GRACEFUL_STRING ")");
 #else
     if (!one_process) {
@@ -621,16 +621,16 @@ static void check_infinite_requests(void)
     else {
         /* wow! if you're executing this code, you may have set a record.
          * either this child process has served over 2 billion requests, or
-         * you're running a threaded 2.0 on a 16 bit machine.  
+         * you're running a threaded 2.0 on a 16 bit machine.
          *
          * I'll buy pizza and beers at Apachecon for the first person to do
          * the former without cheating (dorking with INT_MAX, or running with
-         * uncommitted performance patches, for example).    
+         * uncommitted performance patches, for example).
          *
          * for the latter case, you probably deserve a beer too.   Greg Ames
          */
-            
-        requests_this_child = INT_MAX;      /* keep going */ 
+
+        requests_this_child = INT_MAX;      /* keep going */
     }
 }
 
@@ -688,7 +688,7 @@ static void *worker_thread(apr_thread_t *thd, void * dummy)
         /* ### check the status */
         (void) apr_pollset_add(pollset, &pfd);
     }
-    
+
     /* TODO: Switch to a system where threads reuse the results from earlier
        poll calls - manoj */
     is_listener = 0;
@@ -725,7 +725,7 @@ static void *worker_thread(apr_thread_t *thd, void * dummy)
             if (workers_may_exit) {
                 break;
             }
-            if (ap_scoreboard_image->parent[process_slot].generation != 
+            if (ap_scoreboard_image->parent[process_slot].generation !=
                 ap_scoreboard_image->global->running_generation) {
                 level = APLOG_DEBUG; /* common to get these at restart time */
             }
@@ -802,7 +802,7 @@ static void *worker_thread(apr_thread_t *thd, void * dummy)
                 if (workers_may_exit) {
                     break;
                 }
-                if (ap_scoreboard_image->parent[process_slot].generation != 
+                if (ap_scoreboard_image->parent[process_slot].generation !=
                     ap_scoreboard_image->global->running_generation) {
                     level = APLOG_DEBUG; /* common to get these at restart time */
                 }
@@ -918,14 +918,14 @@ static void * APR_THREAD_FUNC start_threads(apr_thread_t *thd, void *dummy)
             my_info->pid = my_child_num;
             my_info->tid = i;
             my_info->sd = 0;
-        
+
             /* We are creating threads right now */
             ap_update_child_status_from_indexes(my_child_num, i,
                                                 SERVER_STARTING, NULL);
             /* We let each thread update its own scoreboard entry.  This is
              * done because it lets us deal with tid better.
              */
-            rv = apr_thread_create(&threads[i], thread_attr, 
+            rv = apr_thread_create(&threads[i], thread_attr,
                                    worker_thread, my_info, pchild);
             if (rv != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
@@ -954,15 +954,15 @@ static void * APR_THREAD_FUNC start_threads(apr_thread_t *thd, void *dummy)
             prev_threads_created = threads_created;
         }
     }
-    
-    /* What state should this child_main process be listed as in the 
+
+    /* What state should this child_main process be listed as in the
      * scoreboard...?
-     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING, 
+     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING,
      *                                      (request_rec *) NULL);
-     * 
+     *
      *  This state should be listed separately in the scoreboard, in some kind
-     *  of process_status, not mixed in with the worker threads' status.   
-     *  "life_status" is almost right, but it's in the worker's structure, and 
+     *  of process_status, not mixed in with the worker threads' status.
+     *  "life_status" is almost right, but it's in the worker's structure, and
      *  the name could be clearer.   gla
      */
     apr_thread_exit(thd, APR_SUCCESS);
@@ -991,8 +991,8 @@ static void join_start_thread(apr_thread_t *start_thread_id)
 {
     apr_status_t rv, thread_rv;
 
-    start_thread_may_exit = 1; /* tell it to give up in case it is still 
-                                * trying to take over slots from a 
+    start_thread_may_exit = 1; /* tell it to give up in case it is still
+                                * trying to take over slots from a
                                 * previous generation
                                 */
     rv = apr_thread_join(&thread_rv, start_thread_id);
@@ -1056,13 +1056,13 @@ static void child_main(int child_num_arg)
         /* coding a value of zero means infinity */
         requests_this_child = INT_MAX;
     }
-    
+
     /* Setup worker threads */
 
-    /* clear the storage; we may not create all our threads immediately, 
+    /* clear the storage; we may not create all our threads immediately,
      * and we want a 0 entry to indicate a thread which was not created
      */
-    threads = (apr_thread_t **)calloc(1, 
+    threads = (apr_thread_t **)calloc(1,
                                 sizeof(apr_thread_t *) * ap_threads_per_child);
     if (threads == NULL) {
         ap_log_error(APLOG_MARK, APLOG_ALERT, errno, ap_server_conf,
@@ -1102,7 +1102,7 @@ static void child_main(int child_num_arg)
     if (one_process) {
         /* Block until we get a terminating signal. */
         apr_signal_thread(check_signal);
-        /* make sure the start thread has finished; signal_threads() 
+        /* make sure the start thread has finished; signal_threads()
          * and join_workers() depend on that
          */
         /* XXX join_start_thread() won't be awakened if one of our
@@ -1138,7 +1138,7 @@ static void child_main(int child_num_arg)
     clean_child_exit(resource_shortage ? APEXIT_CHILDSICK : 0);
 }
 
-static int make_child(server_rec *s, int slot) 
+static int make_child(server_rec *s, int slot)
 {
     int pid;
 
@@ -1153,7 +1153,7 @@ static int make_child(server_rec *s, int slot)
     }
 
     if ((pid = fork()) == -1) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, 
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s,
                      "fork: Unable to fork new process");
 
         /* fork didn't succeed. Fix the scoreboard or else
@@ -1177,7 +1177,7 @@ static int make_child(server_rec *s, int slot)
         int status = bindprocessor(BINDPROCESS, (int)getpid(),
                                PROCESSOR_CLASS_ANY);
         if (status != OK)
-            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, 
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno,
                          ap_server_conf,
                          "processor unbind failed %d", status);
 #endif
@@ -1258,7 +1258,7 @@ static void perform_idle_server_maintenance(void)
             status = ws->status;
 
             /* XXX any_dying_threads is probably no longer needed    GLA */
-            any_dying_threads = any_dying_threads || 
+            any_dying_threads = any_dying_threads ||
                                 (status == SERVER_GRACEFUL);
             any_dead_threads = any_dead_threads || (status == SERVER_DEAD);
             all_dead_threads = all_dead_threads &&
@@ -1274,19 +1274,19 @@ static void perform_idle_server_maintenance(void)
             if (status <= SERVER_READY && status != SERVER_DEAD &&
                     !ps->quiescing &&
                     ps->generation == ap_my_generation &&
-                 /* XXX the following shouldn't be necessary if we clean up 
-                  *     properly after seg faults, but we're not yet    GLA 
-                  */     
+                 /* XXX the following shouldn't be necessary if we clean up
+                  *     properly after seg faults, but we're not yet    GLA
+                  */
                     ps->pid != 0) {
                 ++idle_thread_count;
             }
         }
-        if (any_dead_threads && totally_free_length < idle_spawn_rate 
+        if (any_dead_threads && totally_free_length < idle_spawn_rate
                 && (!ps->pid               /* no process in the slot */
                     || ps->quiescing)) {   /* or at least one is going away */
             if (all_dead_threads) {
                 /* great! we prefer these, because the new process can
-                 * start more threads sooner.  So prioritize this slot 
+                 * start more threads sooner.  So prioritize this slot
                  * by putting it ahead of any slots with active threads.
                  *
                  * first, make room by moving a slot that's potentially still
@@ -1320,9 +1320,9 @@ static void perform_idle_server_maintenance(void)
         if (free_length == 0) {
             /* only report this condition once */
             static int reported = 0;
-            
+
             if (!reported) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, 
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                              ap_server_conf,
                              "server reached MaxClients setting, consider"
                              " raising the MaxClients setting");
@@ -1335,7 +1335,7 @@ static void perform_idle_server_maintenance(void)
                 free_length = idle_spawn_rate;
             }
             if (idle_spawn_rate >= 8) {
-                ap_log_error(APLOG_MARK, APLOG_INFO, 0, 
+                ap_log_error(APLOG_MARK, APLOG_INFO, 0,
                              ap_server_conf,
                              "server seems busy, (you may need "
                              "to increase StartServers, ThreadsPerChild "
@@ -1373,7 +1373,7 @@ static void server_main_loop(int remaining_children_to_start)
 
     while (!restart_pending && !shutdown_pending) {
         ap_wait_or_timeout(&exitwhy, &status, &pid, pconf);
-        
+
         if (pid.pid != -1) {
             processed_status = ap_process_child_status(&pid, exitwhy, status);
             if (processed_status == APEXIT_CHILDFATAL) {
@@ -1385,9 +1385,9 @@ static void server_main_loop(int remaining_children_to_start)
             child_slot = find_child_by_pid(&pid);
             if (child_slot >= 0) {
                 for (i = 0; i < ap_threads_per_child; i++)
-                    ap_update_child_status_from_indexes(child_slot, i, SERVER_DEAD, 
+                    ap_update_child_status_from_indexes(child_slot, i, SERVER_DEAD,
                                                         (request_rec *) NULL);
-                
+
                 ap_scoreboard_image->parent[child_slot].pid = 0;
                 ap_scoreboard_image->parent[child_slot].quiescing = 0;
                 if (processed_status == APEXIT_CHILDSICK) {
@@ -1458,13 +1458,13 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                      "ignored during restart");
         changed_limit_at_restart = 0;
     }
-    
+
     /* Initialize cross-process accept lock */
     ap_lock_fname = apr_psprintf(_pconf, "%s.%" APR_PID_T_FMT,
                                  ap_server_root_relative(_pconf, ap_lock_fname),
                                  ap_my_pid);
 
-    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname, 
+    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname,
                                ap_accept_lock_mech, _pconf);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1474,7 +1474,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     }
 
 #if APR_USE_SYSVSEM_SERIALIZE
-    if (ap_accept_lock_mech == APR_LOCK_DEFAULT || 
+    if (ap_accept_lock_mech == APR_LOCK_DEFAULT ||
         ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
 #else
     if (ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
@@ -1547,7 +1547,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     if (shutdown_pending) {
         /* Time to gracefully shut down:
          * Kill child processes, tell them to call child_exit, etc...
-         * (By "gracefully" we don't mean graceful in the same sense as 
+         * (By "gracefully" we don't mean graceful in the same sense as
          * "apachectl graceful" where we allow old connections to finish.)
          */
         if (unixd_killpg(getpgrp(), SIGTERM) < 0) {
@@ -1564,7 +1564,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                              ap_server_conf,
                              "removed PID file %s (pid=%ld)",
                              pidfile, (long)getpid());
-    
+
             ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
                          ap_server_conf, "caught SIGTERM, shutting down");
         }
@@ -1585,21 +1585,21 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
      */
     ++ap_my_generation;
     ap_scoreboard_image->global->running_generation = ap_my_generation;
-    
+
     if (is_graceful) {
         ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                      AP_SIG_GRACEFUL_STRING " received.  Doing graceful restart");
         /* wake up the children...time to die.  But we'll have more soon */
         ap_mpm_pod_killpg(pod, ap_daemons_limit);
-    
+
 
         /* This is mostly for debugging... so that we know what is still
          * gracefully dealing with existing request.
          */
-        
+
     }
     else {
-        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM 
+        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM
          * and a SIGHUP, we may as well use the same signal, because some user
          * pthreads are stealing signals from us left and right.
          */
@@ -1639,7 +1639,7 @@ static int leader_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
     return OK;
 }
 
-static int leader_pre_config(apr_pool_t *pconf, apr_pool_t *plog, 
+static int leader_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                              apr_pool_t *ptemp)
 {
     static int restart_num = 0;
@@ -1672,7 +1672,7 @@ static int leader_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                 pdir->args = max_clients->args;
                 pdir->filename = max_clients->filename;
                 pdir->line_num = max_clients->line_num;
-                
+
                 max_clients->directive = temp.directive;
                 max_clients->args = temp.args;
                 max_clients->filename = temp.filename;
@@ -1751,7 +1751,7 @@ static void leader_hooks(apr_pool_t *p)
 }
 
 static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy,
-                                        const char *arg) 
+                                        const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1772,15 +1772,15 @@ static const char *set_min_spare_threads(cmd_parms *cmd, void *dummy,
 
     min_spare_threads = atoi(arg);
     if (min_spare_threads <= 0) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: detected MinSpareThreads set to non-positive.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Resetting to 1 to avoid almost certain Apache failure.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Please read the documentation.");
        min_spare_threads = 1;
     }
-       
+
     return NULL;
 }
 
@@ -1797,7 +1797,7 @@ static const char *set_max_spare_threads(cmd_parms *cmd, void *dummy,
 }
 
 static const char *set_max_clients (cmd_parms *cmd, void *dummy,
-                                     const char *arg) 
+                                     const char *arg)
 {
     int max_clients;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
@@ -1809,47 +1809,47 @@ static const char *set_max_clients (cmd_parms *cmd, void *dummy,
      * sure that it gets set before MaxClients in the pre_config stage. */
     max_clients = atoi(arg);
     if (max_clients < ap_threads_per_child) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients (%d) must be at least as large",
                     max_clients);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " large as ThreadsPerChild (%d). Automatically",
                     ap_threads_per_child);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " increasing MaxClients to %d.",
                     ap_threads_per_child);
        max_clients = ap_threads_per_child;
     }
     ap_daemons_limit = max_clients / ap_threads_per_child;
     if ((max_clients > 0) && (max_clients % ap_threads_per_child)) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients (%d) is not an integer multiple",
                     max_clients);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " of ThreadsPerChild (%d), lowering MaxClients to %d",
                     ap_threads_per_child,
                     ap_daemons_limit * ap_threads_per_child);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " for a maximum of %d child processes,",
                     ap_daemons_limit);
-       max_clients = ap_daemons_limit * ap_threads_per_child; 
+       max_clients = ap_daemons_limit * ap_threads_per_child;
     }
     if (ap_daemons_limit > server_limit) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients of %d would require %d servers,",
                     max_clients, ap_daemons_limit);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " and would exceed the ServerLimit value of %d.",
                     server_limit);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " Automatically lowering MaxClients to %d.  To increase,",
                     server_limit * ap_threads_per_child);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " please see the ServerLimit directive.");
        ap_daemons_limit = server_limit;
-    } 
+    }
     else if (ap_daemons_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require MaxClients > 0, setting to 1");
         ap_daemons_limit = 1;
     }
@@ -1857,7 +1857,7 @@ static const char *set_max_clients (cmd_parms *cmd, void *dummy,
 }
 
 static const char *set_threads_per_child (cmd_parms *cmd, void *dummy,
-                                          const char *arg) 
+                                          const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1866,29 +1866,29 @@ static const char *set_threads_per_child (cmd_parms *cmd, void *dummy,
 
     ap_threads_per_child = atoi(arg);
     if (ap_threads_per_child > thread_limit) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
                      "value of %d", ap_threads_per_child,
                      thread_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "threads, lowering ThreadsPerChild to %d. To increase, please"
                      " see the", thread_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      " ThreadLimit directive.");
         ap_threads_per_child = thread_limit;
     }
     else if (ap_threads_per_child < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ThreadsPerChild > 0, setting to 1");
         ap_threads_per_child = 1;
     }
     return NULL;
 }
 
-static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     int tmp_server_limit;
-    
+
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -1908,27 +1908,27 @@ static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *ar
         return NULL;
     }
     server_limit = tmp_server_limit;
-    
+
     if (server_limit > MAX_SERVER_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: ServerLimit of %d exceeds compile time limit "
                     "of %d servers,", server_limit, MAX_SERVER_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering ServerLimit to %d.", MAX_SERVER_LIMIT);
        server_limit = MAX_SERVER_LIMIT;
-    } 
+    }
     else if (server_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ServerLimit > 0, setting to 1");
         server_limit = 1;
     }
     return NULL;
 }
 
-static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     int tmp_thread_limit;
-    
+
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -1948,17 +1948,17 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
         return NULL;
     }
     thread_limit = tmp_thread_limit;
-    
+
     if (thread_limit > MAX_THREAD_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: ThreadLimit of %d exceeds compile time limit "
                     "of %d servers,", thread_limit, MAX_THREAD_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering ThreadLimit to %d.", MAX_THREAD_LIMIT);
        thread_limit = MAX_THREAD_LIMIT;
-    } 
+    }
     else if (thread_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ThreadLimit > 0, setting to 1");
         thread_limit = 1;
     }
diff --git a/server/mpm/experimental/perchild/perchild.c b/server/mpm/experimental/perchild/perchild.c
index bae4dc3..740cda5 100644
--- a/server/mpm/experimental/perchild/perchild.c
+++ b/server/mpm/experimental/perchild/perchild.c
@@ -33,16 +33,16 @@
 
 #if !APR_HAS_THREADS
 #error The perchild MPM requires APR threads, but they are unavailable.
-#endif  
+#endif
+
+#define CORE_PRIVATE
 
-#define CORE_PRIVATE 
- 
 #include "ap_config.h"
-#include "httpd.h" 
-#include "http_main.h" 
-#include "http_log.h" 
-#include "http_config.h"    /* for read_config */ 
-#include "http_core.h"      /* for get_remote_host */ 
+#include "httpd.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "http_config.h"    /* for read_config */
+#include "http_core.h"      /* for get_remote_host */
 #include "http_protocol.h"
 #include "http_connection.h"
 #include "ap_mpm.h"
@@ -87,7 +87,7 @@
  * the overhead.
  */
 #ifndef DEFAULT_THREAD_LIMIT
-#define DEFAULT_THREAD_LIMIT 64 
+#define DEFAULT_THREAD_LIMIT 64
 #endif
 
 /* Admin can't tune ThreadLimit beyond MAX_THREAD_LIMIT.  We want
@@ -95,7 +95,7 @@
  */
 #ifndef MAX_THREAD_LIMIT
 #define MAX_THREAD_LIMIT 20000
-#endif 
+#endif
 
 /* Limit on the total --- clients will be locked out if more servers than
  * this are needed.  It is intended solely to keep the server from crashing
@@ -109,7 +109,7 @@
  * the overhead.
  */
 #ifndef DEFAULT_SERVER_LIMIT
-#define DEFAULT_SERVER_LIMIT 8 
+#define DEFAULT_SERVER_LIMIT 8
 #endif
 
 /* Admin can't tune ServerLimit beyond MAX_SERVER_LIMIT.  We want
@@ -166,8 +166,8 @@ struct ap_ctable    *ap_child_table;
 
 /*
  * The max child slot ever assigned, preserved across restarts.  Necessary
- * to deal with NumServers changes across AP_SIG_GRACEFUL restarts.  We 
- * use this value to optimize routines that have to scan the entire child 
+ * to deal with NumServers changes across AP_SIG_GRACEFUL restarts.  We
+ * use this value to optimize routines that have to scan the entire child
  * table.
  *
  * XXX - It might not be worth keeping this code in. There aren't very
@@ -209,7 +209,7 @@ static apr_pool_t *thread_pool_parent; /* Parent of per-thread pools */
 static apr_thread_mutex_t *thread_pool_parent_mutex;
 
 static int child_num;
-static unsigned int my_pid; /* Linux getpid() doesn't work except in 
+static unsigned int my_pid; /* Linux getpid() doesn't work except in
                       main thread. Use this instead */
 /* Keep track of the number of worker threads currently active */
 static int worker_thread_count;
@@ -254,7 +254,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
         case AP_MPMQ_MIN_SPARE_DAEMONS:
             *result = 0;
             return APR_SUCCESS;
-        case AP_MPMQ_MIN_SPARE_THREADS:    
+        case AP_MPMQ_MIN_SPARE_THREADS:
             *result = min_spare_threads;
             return APR_SUCCESS;
         case AP_MPMQ_MAX_SPARE_DAEMONS:
@@ -265,7 +265,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
             return APR_SUCCESS;
         case AP_MPMQ_MAX_REQUESTS_DAEMON:
             *result = ap_max_requests_per_child;
-            return APR_SUCCESS; 
+            return APR_SUCCESS;
         case AP_MPMQ_MAX_DAEMONS:
             *result = num_daemons;
             return APR_SUCCESS;
@@ -296,14 +296,14 @@ static int volatile shutdown_pending;
 static int volatile restart_pending;
 static int volatile is_graceful;
 static int volatile child_fatal;
-/* we don't currently track ap_my_generation, but mod_status 
+/* we don't currently track ap_my_generation, but mod_status
  * references it so it must be defined */
 ap_generation_t volatile ap_my_generation=0;
 
 /*
  * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
- * functions to initiate shutdown or restart without relying on signals. 
- * Previously this was initiated in sig_term() and restart() signal handlers, 
+ * functions to initiate shutdown or restart without relying on signals.
+ * Previously this was initiated in sig_term() and restart() signal handlers,
  * but we want to be able to start a shutdown/restart from other sources --
  * e.g. on Win32, from the service manager. Now the service manager can
  * call ap_start_shutdown() or ap_start_restart() as appropiate.  Note that
@@ -399,7 +399,7 @@ static void set_signals(void)
                      "sigaction(SIGPIPE)");
 #endif
 
-    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy 
+    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy
      * processing one */
     sigaddset(&sa.sa_mask, SIGHUP);
     sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
@@ -466,7 +466,7 @@ static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id,
     }
 
     ap_create_sb_handle(&sbh, p, conn_id / thread_limit, thread_num);
-    current_conn = ap_run_create_connection(p, ap_server_conf, sock, conn_id, 
+    current_conn = ap_run_create_connection(p, ap_server_conf, sock, conn_id,
                                             sbh, bucket_alloc);
     if (current_conn) {
         ap_process_connection(current_conn, sock);
@@ -495,7 +495,7 @@ static int perchild_process_connection(conn_rec *c)
     }
     return DECLINED;
 }
-    
+
 
 static void *worker_thread(apr_thread_t *, void *);
 
@@ -526,7 +526,7 @@ static int start_thread(void)
     }
     else {
         static int reported = 0;
-        
+
         if (!reported) {
             ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                          ap_server_conf,
@@ -652,7 +652,7 @@ static void *worker_thread(apr_thread_t *thd, void *arg)
     apr_thread_mutex_unlock(thread_pool_parent_mutex);
     apr_pool_create(&ptrans, tpool);
 
-    (void) ap_update_child_status_from_indexes(child_num, thread_num, 
+    (void) ap_update_child_status_from_indexes(child_num, thread_num,
                                                SERVER_STARTING,
                                                (request_rec *) NULL);
 
@@ -685,7 +685,7 @@ static void *worker_thread(apr_thread_t *thd, void *arg)
             thread_just_started = 0;
         }
 
-        (void) ap_update_child_status_from_indexes(child_num, thread_num, 
+        (void) ap_update_child_status_from_indexes(child_num, thread_num,
                                                    SERVER_READY,
                                                    (request_rec *) NULL);
 
@@ -764,7 +764,7 @@ static void *worker_thread(apr_thread_t *thd, void *arg)
             }
             else {
                 thread_socket_table[thread_num] = AP_PERCHILD_THISCHILD;
-            }  
+            }
             requests_this_child--;
         }
         else {
@@ -891,7 +891,7 @@ static int check_signal(int signum)
         return 1;
     }
     return 0;
-}                                                                               
+}
 
 typedef struct perchild_header {
     char *headers;
@@ -906,7 +906,7 @@ typedef struct perchild_header {
 static int perchild_header_field(perchild_header *h,
                              const char *fieldname, const char *fieldval)
 {
-    apr_pstrcat(h->p, h->headers, fieldname, ": ", fieldval, CRLF, NULL); 
+    apr_pstrcat(h->p, h->headers, fieldname, ": ", fieldval, CRLF, NULL);
     return 1;
 }
 
@@ -917,7 +917,7 @@ static void child_main(int child_num_arg)
     apr_status_t rv;
     apr_socket_t *sock = NULL;
     ap_listen_rec *lr;
-    
+
     my_pid = getpid();
     ap_fatal_signal_child_setup(ap_server_conf);
     child_num = child_num_arg;
@@ -938,7 +938,7 @@ static void child_main(int child_num_arg)
 
     /*stuff to do before we switch id's, so we have permissions.*/
 
-    rv = SAFE_ACCEPT(apr_proc_mutex_child_init(&process_accept_mutex, 
+    rv = SAFE_ACCEPT(apr_proc_mutex_child_init(&process_accept_mutex,
                                                ap_lock_fname, pchild));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
@@ -957,7 +957,7 @@ static void child_main(int child_num_arg)
     apr_setup_signal_thread();
 
     requests_this_child = ap_max_requests_per_child;
-    
+
 
     /* Setup worker threads */
 
@@ -971,9 +971,9 @@ static void child_main(int child_num_arg)
         worker_thread_free_ids[i] = i;
     }
     apr_pool_create(&thread_pool_parent, pchild);
-    apr_thread_mutex_create(&thread_pool_parent_mutex, 
+    apr_thread_mutex_create(&thread_pool_parent_mutex,
                     APR_THREAD_MUTEX_DEFAULT, pchild);
-    apr_thread_mutex_create(&idle_thread_count_mutex, 
+    apr_thread_mutex_create(&idle_thread_count_mutex,
                     APR_THREAD_MUTEX_DEFAULT, pchild);
     apr_thread_mutex_create(&worker_thread_count_mutex,
                     APR_THREAD_MUTEX_DEFAULT, pchild);
@@ -1035,7 +1035,7 @@ static int make_child(server_rec *s, int slot)
         int status = bindprocessor(BINDPROCESS, (int)getpid(),
                                    PROCESSOR_CLASS_ANY);
         if (status != OK) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, 
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno,
                          ap_server_conf, "processor unbind failed %d", status);
         }
 #endif
@@ -1094,7 +1094,7 @@ static void perform_child_maintenance(void)
 
     /* initialize the free_list */
     free_length = 0;
-    
+
     for (i = 0; i < num_daemons; ++i) {
         if (ap_child_table[i].pid == 0) {
             if (free_length < spawn_rate) {
@@ -1141,7 +1141,7 @@ static void server_main_loop(int remaining_children_to_start)
 
     while (!restart_pending && !shutdown_pending) {
         ap_wait_or_timeout(&exitwhy, &status, &pid, pconf);
-        
+
         if (pid.pid != -1) {
             if (ap_process_child_status(&pid, exitwhy, status)
                 == APEXIT_CHILDFATAL) {
@@ -1163,7 +1163,7 @@ static void server_main_loop(int remaining_children_to_start)
                 ap_update_child_status_from_indexes(child_slot, i, SERVER_DEAD,
                                                     (request_rec *) NULL);
 
-                
+
                 if (remaining_children_to_start
                     && child_slot < num_daemons) {
                     /* we're still doing a 1-for-1 replacement of dead
@@ -1184,9 +1184,9 @@ static void server_main_loop(int remaining_children_to_start)
                 * child table.  Somehow we don't know about this
                 * child.
                 */
-                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, 
+                ap_log_error(APLOG_MARK, APLOG_WARNING, 0,
                              ap_server_conf,
-                             "long lost child came home! (pid %ld)", 
+                             "long lost child came home! (pid %ld)",
                              (long)pid.pid);
             }
             /* Don't perform idle maintenance when a child dies,
@@ -1237,7 +1237,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
     ap_server_conf = s;
 
-    if ((ap_accept_lock_mech == APR_LOCK_SYSVSEM) || 
+    if ((ap_accept_lock_mech == APR_LOCK_SYSVSEM) ||
         (ap_accept_lock_mech == APR_LOCK_POSIXSEM)) {
         ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
                      "Server configured for an accept lock mechanism that "
@@ -1295,8 +1295,8 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 
     /* If we're doing a graceful_restart then we're going to see a lot
      * of children exiting immediately when we get into the main loop
-     * below (because we just sent them AP_SIG_GRACEFUL).  This happens 
-     * pretty rapidly... and for each one that exits we'll start a new one 
+     * below (because we just sent them AP_SIG_GRACEFUL).  This happens
+     * pretty rapidly... and for each one that exits we'll start a new one
      * until we reach at least daemons_min_free.  But we may be permitted to
      * start more than that, so we'll just keep track of how many we're
      * supposed to start up without the 1 second penalty between each fork.
@@ -1347,7 +1347,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                              "removed PID file %s (pid=%ld)",
                              pidfile, (long)getpid());
             }
-    
+
             ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
                          ap_server_conf, "caught SIGTERM, shutting down");
         }
@@ -1372,11 +1372,11 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         /* This is mostly for debugging... so that we know what is still
          * gracefully dealing with existing request.
          */
-    
+
         for (i = 0; i < num_daemons; ++i) {
             if (ap_child_table[i].pid) {
                 ap_child_table[i].status = SERVER_DYING;
-            } 
+            }
         }
         /* give the children the signal to die */
         for (i = 0; i < num_daemons;) {
@@ -1390,7 +1390,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         }
     }
     else {
-        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM 
+        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM
          * and a SIGHUP, we may as well use the same signal, because some user
          * pthreads are stealing signals from us left and right.
          */
@@ -1479,7 +1479,7 @@ static int perchild_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptem
                 ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                              "apr_proc_detach failed");
                 return HTTP_INTERNAL_SERVER_ERROR;
-            }                  
+            }
         }
 
         my_pid = getpid();
@@ -1551,10 +1551,10 @@ static int pass_request(request_rec *r)
     perchild_header h;
     apr_bucket *sockbuck;
     perchild_server_conf *sconf = (perchild_server_conf *)
-                            ap_get_module_config(r->server->module_config, 
+                            ap_get_module_config(r->server->module_config,
                                                  &mpm_perchild_module);
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
                  "passing request to another child.  Vhost: %s, child %d %d",
                  apr_table_get(r->headers_in, "Host"), child_num, sconf->output);
     ap_get_brigade(r->connection->input_filters, bb, AP_MODE_EXHAUSTIVE, APR_NONBLOCK_READ,
@@ -1566,13 +1566,13 @@ static int pass_request(request_rec *r)
             break;
         }
     }
-    
+
     if (!sockbuck) {
     }
-    sockbb = apr_brigade_split(bb, sockbuck); 
+    sockbb = apr_brigade_split(bb, sockbuck);
 
     if (apr_brigade_flatten(bb, request_body, &l) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
                      "Unable to flatten brigade, declining request");
         return DECLINED;
     }
@@ -1580,10 +1580,10 @@ static int pass_request(request_rec *r)
     apr_os_sock_get(&sfd, thesock);
 
     h.p = r->pool;
-    h.headers = apr_pstrcat(h.p, r->the_request, CRLF, "Host: ", r->hostname, 
+    h.headers = apr_pstrcat(h.p, r->the_request, CRLF, "Host: ", r->hostname,
                             CRLF, NULL);
     apr_table_do((int (*) (void *, const char *, const char *))
-                 perchild_header_field, (void *) &h, r->headers_in, NULL); 
+                 perchild_header_field, (void *) &h, r->headers_in, NULL);
     h.headers = apr_pstrcat(h.p, h.headers, CRLF, NULL);
 
     iov[0].iov_base = h.headers;
@@ -1606,17 +1606,17 @@ static int pass_request(request_rec *r)
     msg.msg_control = cmsg;
     msg.msg_controllen = cmsg->cmsg_len;
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
                  "Writing message to %d, passing sd:  %d", sconf->output, sfd);
 
     if ((rv = sendmsg(sconf->output, &msg, 0)) == -1) {
         apr_pool_destroy(r->pool);
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
                  "Writing message failed %d %d", rv, errno);
         return -1;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
                  "Writing message succeeded %d", rv);
 
     apr_pool_destroy(r->pool);
@@ -1644,7 +1644,7 @@ static int perchild_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *pte
                                                       &mpm_perchild_module);
 
         if (sconf->input == -1) {
-            sconf->fullsockname = apr_pstrcat(sr->process->pool, 
+            sconf->fullsockname = apr_pstrcat(sr->process->pool,
                                              sconf->sockname, ".DEFAULT", NULL);
             if (def_sd[0] == -1) {
                 if (!make_perchild_socket(sconf->fullsockname, def_sd)) {
@@ -1678,36 +1678,36 @@ static int perchild_post_read(request_rec *r)
 {
     int thread_num = r->connection->id % thread_limit;
     perchild_server_conf *sconf = (perchild_server_conf *)
-                            ap_get_module_config(r->server->module_config, 
+                            ap_get_module_config(r->server->module_config,
                                                  &mpm_perchild_module);
 
     if (thread_socket_table[thread_num] != AP_PERCHILD_THISCHILD) {
         apr_socket_t *csd = NULL;
 
-        apr_os_sock_put(&csd, &thread_socket_table[thread_num], 
+        apr_os_sock_put(&csd, &thread_socket_table[thread_num],
                         r->connection->pool);
         ap_sock_disable_nagle(csd);
         ap_set_module_config(r->connection->conn_config, &core_module, csd);
         return OK;
     }
     else {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
                      "Determining if request should be passed. "
-                     "Child Num: %d, SD: %d, sd from table: %d, hostname from server: %s", child_num, 
-                     sconf->input, child_info_table[child_num].input, 
+                     "Child Num: %d, SD: %d, sd from table: %d, hostname from server: %s", child_num,
+                     sconf->input, child_info_table[child_num].input,
                      r->server->server_hostname);
         /* sconf is the server config for this vhost, so if our socket
          * is not the same that was set in the config, then the request
          * needs to be passed to another child. */
         if (sconf->input != child_info_table[child_num].input) {
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
                          "Passing request.");
             if (pass_request(r) == -1) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                              ap_server_conf, "Could not pass request to proper "
                              "child, request will not be honored.");
             }
-            longjmp(jmpbuffers[thread_num], 1); 
+            longjmp(jmpbuffers[thread_num], 1);
         }
         return OK;
     }
@@ -1724,10 +1724,10 @@ static void perchild_hooks(apr_pool_t *p)
     one_process = 0;
 
     ap_hook_open_logs(perchild_open_logs, NULL, aszSucc, APR_HOOK_MIDDLE);
-    ap_hook_pre_config(perchild_pre_config, NULL, NULL, APR_HOOK_MIDDLE); 
-    ap_hook_post_config(perchild_post_config, NULL, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_pre_config(perchild_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_post_config(perchild_post_config, NULL, NULL, APR_HOOK_MIDDLE);
 
-    /* Both of these must be run absolutely first.  If this request isn't for 
+    /* Both of these must be run absolutely first.  If this request isn't for
      * this server then we need to forward it to the proper child.  No sense
      * tying up this server running more post_read request hooks if it is
      * just going to be forwarded along.  The process_connection hook allows
@@ -1736,12 +1736,12 @@ static void perchild_hooks(apr_pool_t *p)
      */
     ap_hook_post_read_request(perchild_post_read, NULL, NULL,
                               APR_HOOK_REALLY_FIRST);
-    ap_hook_process_connection(perchild_process_connection, NULL, NULL, 
+    ap_hook_process_connection(perchild_process_connection, NULL, NULL,
                                APR_HOOK_REALLY_FIRST);
 }
 
 static const char *set_num_daemons(cmd_parms *cmd, void *dummy,
-                                   const char *arg) 
+                                   const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1750,18 +1750,18 @@ static const char *set_num_daemons(cmd_parms *cmd, void *dummy,
 
     num_daemons = atoi(arg);
     if (num_daemons > server_limit) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: NumServers of %d exceeds ServerLimit value "
                     "of %d servers,", num_daemons, server_limit);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering NumServers to %d.  To increase, please "
                     "see the", server_limit);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " ServerLimit directive.");
        num_daemons = server_limit;
-    } 
+    }
     else if (num_daemons < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require NumServers > 0, setting to 1");
         num_daemons = 1;
     }
@@ -1769,7 +1769,7 @@ static const char *set_num_daemons(cmd_parms *cmd, void *dummy,
 }
 
 static const char *set_threads_to_start(cmd_parms *cmd, void *dummy,
-                                        const char *arg) 
+                                        const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1778,18 +1778,18 @@ static const char *set_threads_to_start(cmd_parms *cmd, void *dummy,
 
     threads_to_start = atoi(arg);
     if (threads_to_start > thread_limit) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: StartThreads of %d exceeds ThreadLimit value"
                      " of %d threads,", threads_to_start,
                      thread_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      " lowering StartThreads to %d. To increase, please"
                      " see the", thread_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      " ThreadLimit directive.");
     }
     else if (threads_to_start < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require StartThreads > 0, setting to 1");
         threads_to_start = 1;
     }
@@ -1806,15 +1806,15 @@ static const char *set_min_spare_threads(cmd_parms *cmd, void *dummy,
 
     min_spare_threads = atoi(arg);
     if (min_spare_threads <= 0) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: detected MinSpareThreads set to non-positive.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Resetting to 1 to avoid almost certain Apache failure.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Please read the documentation.");
        min_spare_threads = 1;
     }
-       
+
     return NULL;
 }
 
@@ -1828,9 +1828,9 @@ static const char *set_max_spare_threads(cmd_parms *cmd, void *dummy,
 
     max_spare_threads = atoi(arg);
     if (max_spare_threads >= thread_limit) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: detected MinSpareThreads set higher than");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "ThreadLimit. Resetting to %d", thread_limit);
        max_spare_threads = thread_limit;
     }
@@ -1846,9 +1846,9 @@ static const char *set_max_threads(cmd_parms *cmd, void *dummy, const char *arg)
 
     max_threads = atoi(arg);
     if (max_threads > thread_limit) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: detected MaxThreadsPerChild set higher than");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "ThreadLimit. Resetting to %d", thread_limit);
        max_threads = thread_limit;
     }
@@ -1860,16 +1860,16 @@ static const char *set_child_per_uid(cmd_parms *cmd, void *dummy, const char *u,
 {
     int i;
     int max_this_time = atoi(num) + curr_child_num;
-    
+
 
     for (i = curr_child_num; i < max_this_time; i++, curr_child_num++) {
         if (i > num_daemons) {
             return "Trying to use more child ID's than NumServers.  Increase "
                    "NumServers in your config file.";
         }
-    
+
         child_info_table[i].uid = ap_uname2id(u);
-        child_info_table[i].gid = ap_gname2id(g); 
+        child_info_table[i].gid = ap_gname2id(g);
 
 #ifndef BIG_SECURITY_HOLE
         if (child_info_table[i].uid == 0 || child_info_table[i].gid == 0) {
@@ -1890,7 +1890,7 @@ static const char *assign_childuid(cmd_parms *cmd, void *dummy, const char *uid,
     const char *errstr;
     int socks[2];
     perchild_server_conf *sconf = (perchild_server_conf *)
-                            ap_get_module_config(cmd->server->module_config, 
+                            ap_get_module_config(cmd->server->module_config,
                                                  &mpm_perchild_module);
 
     sconf->fullsockname = apr_pstrcat(cmd->pool, sconf->sockname, ".", uid,
@@ -1900,7 +1900,7 @@ static const char *assign_childuid(cmd_parms *cmd, void *dummy, const char *uid,
         return errstr;
     }
 
-    sconf->input = socks[0]; 
+    sconf->input = socks[0];
     sconf->output = socks[1];
 
     for (i = 0; i < num_daemons; i++) {
@@ -1908,10 +1908,10 @@ static const char *assign_childuid(cmd_parms *cmd, void *dummy, const char *uid,
             child_info_table[i].input = sconf->input;
             child_info_table[i].output = sconf->output;
             matching++;
-            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, 
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
                          "filling out child_info_table; UID: %d, GID: %d, "
-                         "SD: %d %d, OUTPUT: %d %d, Child Num: %d", 
-                         child_info_table[i].uid, child_info_table[i].gid, 
+                         "SD: %d %d, OUTPUT: %d %d, Child Num: %d",
+                         child_info_table[i].uid, child_info_table[i].gid,
                          sconf->input, child_info_table[i].input, sconf->output,
                          child_info_table[i].output, i);
         }
@@ -1923,10 +1923,10 @@ static const char *assign_childuid(cmd_parms *cmd, void *dummy, const char *uid,
     return NULL;
 }
 
-static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     int tmp_server_limit;
-    
+
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -1946,27 +1946,27 @@ static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *ar
         return NULL;
     }
     server_limit = tmp_server_limit;
-    
+
     if (server_limit > MAX_SERVER_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: ServerLimit of %d exceeds compile time limit "
                     "of %d servers,", server_limit, MAX_SERVER_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering ServerLimit to %d.", MAX_SERVER_LIMIT);
        server_limit = MAX_SERVER_LIMIT;
-    } 
+    }
     else if (server_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ServerLimit > 0, setting to 1");
         server_limit = 1;
     }
     return NULL;
 }
 
-static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     int tmp_thread_limit;
-    
+
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -1986,17 +1986,17 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
         return NULL;
     }
     thread_limit = tmp_thread_limit;
-    
+
     if (thread_limit > MAX_THREAD_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: ThreadLimit of %d exceeds compile time limit "
                     "of %d servers,", thread_limit, MAX_THREAD_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering ThreadLimit to %d.", MAX_THREAD_LIMIT);
        thread_limit = MAX_THREAD_LIMIT;
-    } 
+    }
     else if (thread_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ThreadLimit > 0, setting to 1");
         thread_limit = 1;
     }
diff --git a/server/mpm/experimental/threadpool/pod.c b/server/mpm/experimental/threadpool/pod.c
index 0da8bba..758c516 100644
--- a/server/mpm/experimental/threadpool/pod.c
+++ b/server/mpm/experimental/threadpool/pod.c
@@ -33,7 +33,7 @@ AP_DECLARE(apr_status_t) ap_mpm_pod_open(apr_pool_t *p, ap_pod_t **pod)
     apr_file_pipe_timeout_set((*pod)->pod_in, 0);
 */
     (*pod)->p = p;
-    
+
     return APR_SUCCESS;
 }
 
diff --git a/server/mpm/experimental/threadpool/threadpool.c b/server/mpm/experimental/threadpool/threadpool.c
index 2ea0737..48d3b87 100644
--- a/server/mpm/experimental/threadpool/threadpool.c
+++ b/server/mpm/experimental/threadpool/threadpool.c
@@ -41,7 +41,7 @@
 #include <sys/socket.h>
 #endif
 #if APR_HAVE_SYS_WAIT_H
-#include <sys/wait.h> 
+#include <sys/wait.h>
 #endif
 #ifdef HAVE_SYS_PROCESSOR_H
 #include <sys/processor.h> /* for bindprocessor() */
@@ -51,20 +51,20 @@
 #error The Worker MPM requires APR threads, but they are unavailable.
 #endif
 
-#define CORE_PRIVATE 
- 
+#define CORE_PRIVATE
+
 #include "ap_config.h"
-#include "httpd.h" 
-#include "http_main.h" 
-#include "http_log.h" 
-#include "http_config.h"        /* for read_config */ 
-#include "http_core.h"          /* for get_remote_host */ 
+#include "httpd.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "http_config.h"        /* for read_config */
+#include "http_core.h"          /* for get_remote_host */
 #include "http_connection.h"
 #include "ap_mpm.h"
 #include "pod.h"
 #include "mpm_common.h"
 #include "ap_listen.h"
-#include "scoreboard.h" 
+#include "scoreboard.h"
 #include "mpm_default.h"
 
 #include <signal.h>
@@ -100,7 +100,7 @@
  * the overhead.
  */
 #ifndef DEFAULT_THREAD_LIMIT
-#define DEFAULT_THREAD_LIMIT 64 
+#define DEFAULT_THREAD_LIMIT 64
 #endif
 
 /* Admin can't tune ThreadLimit beyond MAX_THREAD_LIMIT.  We want
@@ -140,7 +140,7 @@ typedef struct {
     int sd;
 } proc_info;
 
-/* Structure used to pass information to the thread responsible for 
+/* Structure used to pass information to the thread responsible for
  * creating the rest of the threads.
  */
 typedef struct {
@@ -154,8 +154,8 @@ typedef struct {
 
 /*
  * The max child slot ever assigned, preserved across restarts.  Necessary
- * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We 
- * use this value to optimize routines that have to scan the entire 
+ * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We
+ * use this value to optimize routines that have to scan the entire
  * scoreboard.
  */
 int ap_max_daemons_limit = -1;
@@ -188,7 +188,7 @@ int raise_sigstop_flags;
 static apr_pool_t *pconf;                 /* Pool for config stuff */
 static apr_pool_t *pchild;                /* Pool for httpd child stuff */
 
-static pid_t ap_my_pid; /* Linux getpid() doesn't work except in main 
+static pid_t ap_my_pid; /* Linux getpid() doesn't work except in main
                            thread. Use this instead */
 static pid_t parent_pid;
 static apr_os_thread_t *listener_os_thread;
@@ -206,9 +206,9 @@ static apr_proc_mutex_t *accept_mutex;
 #define SAFE_ACCEPT(stmt) (stmt)
 #endif
 
-/* The LISTENER_SIGNAL signal will be sent from the main thread to the 
- * listener thread to wake it up for graceful termination (what a child 
- * process from an old generation does when the admin does "apachectl 
+/* The LISTENER_SIGNAL signal will be sent from the main thread to the
+ * listener thread to wake it up for graceful termination (what a child
+ * process from an old generation does when the admin does "apachectl
  * graceful").  This signal will be blocked in all threads of a child
  * process except for the listener thread.
  */
@@ -232,7 +232,7 @@ typedef struct {
     apr_thread_mutex_t *mutex;
 } worker_wakeup_info;
 
-/* Structure used to hold a stack of idle worker threads 
+/* Structure used to hold a stack of idle worker threads
  */
 typedef struct {
     apr_thread_mutex_t *mutex;
@@ -270,7 +270,7 @@ static apr_status_t worker_stack_wait(worker_stack *stack,
     apr_status_t rv;
 
     wakeup->state = WORKER_IDLE;
-    
+
     if ((rv = apr_thread_mutex_lock(stack->mutex)) != APR_SUCCESS) {
         return rv;
     }
@@ -395,7 +395,7 @@ static void wakeup_listener(void)
     }
     if (!listener_os_thread) {
         /* XXX there is an obscure path that this doesn't handle perfectly:
-         *     right after listener thread is created but before 
+         *     right after listener thread is created but before
          *     listener_os_thread is set, the first worker thread hits an
          *     error and starts graceful termination
          */
@@ -403,7 +403,7 @@ static void wakeup_listener(void)
     }
     /*
      * we should just be able to "kill(ap_my_pid, LISTENER_SIGNAL)" on all
-     * platforms and wake up the listener thread since it is the only thread 
+     * platforms and wake up the listener thread since it is the only thread
      * with SIGHUP unblocked, but that doesn't work on Linux
      */
 #ifdef HAVE_PTHREAD_KILL
@@ -466,7 +466,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
         case AP_MPMQ_MIN_SPARE_DAEMONS:
             *result = 0;
             return APR_SUCCESS;
-        case AP_MPMQ_MIN_SPARE_THREADS:    
+        case AP_MPMQ_MIN_SPARE_THREADS:
             *result = min_spare_threads;
             return APR_SUCCESS;
         case AP_MPMQ_MAX_SPARE_DAEMONS:
@@ -488,7 +488,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
     return APR_ENOTIMPL;
 }
 
-/* a clean exit from a child with proper cleanup */ 
+/* a clean exit from a child with proper cleanup */
 static void clean_child_exit(int code) __attribute__ ((noreturn));
 static void clean_child_exit(int code)
 {
@@ -517,8 +517,8 @@ ap_generation_t volatile ap_my_generation;
 
 /*
  * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
- * functions to initiate shutdown or restart without relying on signals. 
- * Previously this was initiated in sig_term() and restart() signal handlers, 
+ * functions to initiate shutdown or restart without relying on signals.
+ * Previously this was initiated in sig_term() and restart() signal handlers,
  * but we want to be able to start a shutdown/restart from other sources --
  * e.g. on Win32, from the service manager. Now the service manager can
  * call ap_start_shutdown() or ap_start_restart() as appropiate.  Note that
@@ -585,42 +585,42 @@ static void set_signals(void)
 
     sa.sa_handler = sig_term;
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGTERM)");
 #ifdef SIGINT
     if (sigaction(SIGINT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGINT)");
 #endif
 #ifdef SIGXCPU
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXCPU, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGXCPU)");
 #endif
 #ifdef SIGXFSZ
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXFSZ, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGXFSZ)");
 #endif
 #ifdef SIGPIPE
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGPIPE, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGPIPE)");
 #endif
 
-    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy 
+    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy
      * processing one */
     sigaddset(&sa.sa_mask, SIGHUP);
     sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
     sa.sa_handler = restart;
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGHUP)");
     if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(" AP_SIG_GRACEFUL_STRING ")");
 #else
     if (!one_process) {
@@ -695,16 +695,16 @@ static void check_infinite_requests(void)
     else {
         /* wow! if you're executing this code, you may have set a record.
          * either this child process has served over 2 billion requests, or
-         * you're running a threaded 2.0 on a 16 bit machine.  
+         * you're running a threaded 2.0 on a 16 bit machine.
          *
          * I'll buy pizza and beers at Apachecon for the first person to do
          * the former without cheating (dorking with INT_MAX, or running with
-         * uncommitted performance patches, for example).    
+         * uncommitted performance patches, for example).
          *
          * for the latter case, you probably deserve a beer too.   Greg Ames
          */
-            
-        requests_this_child = INT_MAX;      /* keep going */ 
+
+        requests_this_child = INT_MAX;      /* keep going */
     }
 }
 
@@ -794,7 +794,7 @@ static void *listener_thread(apr_thread_t *thd, void * dummy)
             if (listener_may_exit) {
                 break;
             }
-            if (ap_scoreboard_image->parent[process_slot].generation != 
+            if (ap_scoreboard_image->parent[process_slot].generation !=
                 ap_scoreboard_image->global->running_generation) {
                 level = APLOG_DEBUG; /* common to get these at restart time */
             }
@@ -871,7 +871,7 @@ static void *listener_thread(apr_thread_t *thd, void * dummy)
                 if (listener_may_exit) {
                     break;
                 }
-                if (ap_scoreboard_image->parent[process_slot].generation != 
+                if (ap_scoreboard_image->parent[process_slot].generation !=
                     ap_scoreboard_image->global->running_generation) {
                     level = APLOG_DEBUG; /* common to get these at restart time */
                 }
@@ -1091,14 +1091,14 @@ static void * APR_THREAD_FUNC start_threads(apr_thread_t *thd, void *dummy)
             my_info->pid = my_child_num;
             my_info->tid = i;
             my_info->sd = 0;
-        
+
             /* We are creating threads right now */
             ap_update_child_status_from_indexes(my_child_num, i,
                                                 SERVER_STARTING, NULL);
             /* We let each thread update its own scoreboard entry.  This is
              * done because it lets us deal with tid better.
              */
-            rv = apr_thread_create(&threads[i], thread_attr, 
+            rv = apr_thread_create(&threads[i], thread_attr,
                                    worker_thread, my_info, pchild);
             if (rv != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
@@ -1133,15 +1133,15 @@ static void * APR_THREAD_FUNC start_threads(apr_thread_t *thd, void *dummy)
             prev_threads_created = threads_created;
         }
     }
-    
-    /* What state should this child_main process be listed as in the 
+
+    /* What state should this child_main process be listed as in the
      * scoreboard...?
-     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING, 
+     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING,
      *                                      (request_rec *) NULL);
-     * 
+     *
      *  This state should be listed separately in the scoreboard, in some kind
-     *  of process_status, not mixed in with the worker threads' status.   
-     *  "life_status" is almost right, but it's in the worker's structure, and 
+     *  of process_status, not mixed in with the worker threads' status.
+     *  "life_status" is almost right, but it's in the worker's structure, and
      *  the name could be clearer.   gla
      */
     apr_thread_exit(thd, APR_SUCCESS);
@@ -1165,7 +1165,7 @@ static void join_workers(apr_thread_t *listener, apr_thread_t **threads)
          */
 
         iter = 0;
-        while (iter < 10 && 
+        while (iter < 10 &&
 #ifdef HAVE_PTHREAD_KILL
                pthread_kill(*listener_os_thread, 0)
 #else
@@ -1189,7 +1189,7 @@ static void join_workers(apr_thread_t *listener, apr_thread_t **threads)
             }
         }
     }
-    
+
     for (i = 0; i < ap_threads_per_child; i++) {
         if (threads[i]) { /* if we ever created this thread */
             rv = apr_thread_join(&thread_rv, threads[i]);
@@ -1207,8 +1207,8 @@ static void join_start_thread(apr_thread_t *start_thread_id)
 {
     apr_status_t rv, thread_rv;
 
-    start_thread_may_exit = 1; /* tell it to give up in case it is still 
-                                * trying to take over slots from a 
+    start_thread_may_exit = 1; /* tell it to give up in case it is still
+                                * trying to take over slots from a
                                 * previous generation
                                 */
     rv = apr_thread_join(&thread_rv, start_thread_id);
@@ -1271,13 +1271,13 @@ static void child_main(int child_num_arg)
         /* coding a value of zero means infinity */
         requests_this_child = INT_MAX;
     }
-    
+
     /* Setup worker threads */
 
-    /* clear the storage; we may not create all our threads immediately, 
+    /* clear the storage; we may not create all our threads immediately,
      * and we want a 0 entry to indicate a thread which was not created
      */
-    threads = (apr_thread_t **)calloc(1, 
+    threads = (apr_thread_t **)calloc(1,
                                 sizeof(apr_thread_t *) * ap_threads_per_child);
     if (threads == NULL) {
         ap_log_error(APLOG_MARK, APLOG_ALERT, errno, ap_server_conf,
@@ -1312,13 +1312,13 @@ static void child_main(int child_num_arg)
     }
 
     mpm_state = AP_MPMQ_RUNNING;
-    
+
     /* If we are only running in one_process mode, we will want to
      * still handle signals. */
     if (one_process) {
         /* Block until we get a terminating signal. */
         apr_signal_thread(check_signal);
-        /* make sure the start thread has finished; signal_threads() 
+        /* make sure the start thread has finished; signal_threads()
          * and join_workers() depend on that
          */
         /* XXX join_start_thread() won't be awakened if one of our
@@ -1361,7 +1361,7 @@ static void child_main(int child_num_arg)
                 }
             }
             if (rv == AP_GRACEFUL || rv == AP_RESTART) {
-                /* make sure the start thread has finished; 
+                /* make sure the start thread has finished;
                  * signal_threads() and join_workers depend on that
                  */
                 join_start_thread(start_thread_id);
@@ -1387,7 +1387,7 @@ static void child_main(int child_num_arg)
     clean_child_exit(resource_shortage ? APEXIT_CHILDSICK : 0);
 }
 
-static int make_child(server_rec *s, int slot) 
+static int make_child(server_rec *s, int slot)
 {
     int pid;
 
@@ -1402,7 +1402,7 @@ static int make_child(server_rec *s, int slot)
     }
 
     if ((pid = fork()) == -1) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, 
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s,
                      "fork: Unable to fork new process");
 
         /* fork didn't succeed. Fix the scoreboard or else
@@ -1426,7 +1426,7 @@ static int make_child(server_rec *s, int slot)
         int status = bindprocessor(BINDPROCESS, (int)getpid(),
                                PROCESSOR_CLASS_ANY);
         if (status != OK)
-            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, 
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno,
                          ap_server_conf,
                          "processor unbind failed %d", status);
 #endif
@@ -1507,7 +1507,7 @@ static void perform_idle_server_maintenance(void)
             status = ws->status;
 
             /* XXX any_dying_threads is probably no longer needed    GLA */
-            any_dying_threads = any_dying_threads || 
+            any_dying_threads = any_dying_threads ||
                                 (status == SERVER_GRACEFUL);
             any_dead_threads = any_dead_threads || (status == SERVER_DEAD);
             all_dead_threads = all_dead_threads &&
@@ -1523,19 +1523,19 @@ static void perform_idle_server_maintenance(void)
             if (status <= SERVER_READY && status != SERVER_DEAD &&
                     !ps->quiescing &&
                     ps->generation == ap_my_generation &&
-                 /* XXX the following shouldn't be necessary if we clean up 
-                  *     properly after seg faults, but we're not yet    GLA 
-                  */     
+                 /* XXX the following shouldn't be necessary if we clean up
+                  *     properly after seg faults, but we're not yet    GLA
+                  */
                     ps->pid != 0) {
                 ++idle_thread_count;
             }
         }
-        if (any_dead_threads && totally_free_length < idle_spawn_rate 
+        if (any_dead_threads && totally_free_length < idle_spawn_rate
                 && (!ps->pid               /* no process in the slot */
                     || ps->quiescing)) {   /* or at least one is going away */
             if (all_dead_threads) {
                 /* great! we prefer these, because the new process can
-                 * start more threads sooner.  So prioritize this slot 
+                 * start more threads sooner.  So prioritize this slot
                  * by putting it ahead of any slots with active threads.
                  *
                  * first, make room by moving a slot that's potentially still
@@ -1569,9 +1569,9 @@ static void perform_idle_server_maintenance(void)
         if (free_length == 0) {
             /* only report this condition once */
             static int reported = 0;
-            
+
             if (!reported) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, 
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                              ap_server_conf,
                              "server reached MaxClients setting, consider"
                              " raising the MaxClients setting");
@@ -1584,7 +1584,7 @@ static void perform_idle_server_maintenance(void)
                 free_length = idle_spawn_rate;
             }
             if (idle_spawn_rate >= 8) {
-                ap_log_error(APLOG_MARK, APLOG_INFO, 0, 
+                ap_log_error(APLOG_MARK, APLOG_INFO, 0,
                              ap_server_conf,
                              "server seems busy, (you may need "
                              "to increase StartServers, ThreadsPerChild "
@@ -1622,7 +1622,7 @@ static void server_main_loop(int remaining_children_to_start)
 
     while (!restart_pending && !shutdown_pending) {
         ap_wait_or_timeout(&exitwhy, &status, &pid, pconf);
-        
+
         if (pid.pid != -1) {
             processed_status = ap_process_child_status(&pid, exitwhy, status);
             if (processed_status == APEXIT_CHILDFATAL) {
@@ -1634,9 +1634,9 @@ static void server_main_loop(int remaining_children_to_start)
             child_slot = find_child_by_pid(&pid);
             if (child_slot >= 0) {
                 for (i = 0; i < ap_threads_per_child; i++)
-                    ap_update_child_status_from_indexes(child_slot, i, SERVER_DEAD, 
+                    ap_update_child_status_from_indexes(child_slot, i, SERVER_DEAD,
                                                         (request_rec *) NULL);
-                
+
                 ap_scoreboard_image->parent[child_slot].pid = 0;
                 ap_scoreboard_image->parent[child_slot].quiescing = 0;
                 if (processed_status == APEXIT_CHILDSICK) {
@@ -1707,13 +1707,13 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                      "ignored during restart");
         changed_limit_at_restart = 0;
     }
-    
+
     /* Initialize cross-process accept lock */
     ap_lock_fname = apr_psprintf(_pconf, "%s.%" APR_PID_T_FMT,
                                  ap_server_root_relative(_pconf, ap_lock_fname),
                                  ap_my_pid);
 
-    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname, 
+    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname,
                                ap_accept_lock_mech, _pconf);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1723,7 +1723,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     }
 
 #if APR_USE_SYSVSEM_SERIALIZE
-    if (ap_accept_lock_mech == APR_LOCK_DEFAULT || 
+    if (ap_accept_lock_mech == APR_LOCK_DEFAULT ||
         ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
 #else
     if (ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
@@ -1796,7 +1796,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     if (shutdown_pending) {
         /* Time to gracefully shut down:
          * Kill child processes, tell them to call child_exit, etc...
-         * (By "gracefully" we don't mean graceful in the same sense as 
+         * (By "gracefully" we don't mean graceful in the same sense as
          * "apachectl graceful" where we allow old connections to finish.)
          */
         ap_mpm_pod_killpg(pod, ap_daemons_limit, FALSE);
@@ -1811,7 +1811,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                              ap_server_conf,
                              "removed PID file %s (pid=%ld)",
                              pidfile, (long)getpid());
-    
+
             ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
                          ap_server_conf, "caught SIGTERM, shutting down");
         }
@@ -1832,21 +1832,21 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
      */
     ++ap_my_generation;
     ap_scoreboard_image->global->running_generation = ap_my_generation;
-    
+
     if (is_graceful) {
         ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                      AP_SIG_GRACEFUL_STRING " received.  Doing graceful restart");
         /* wake up the children...time to die.  But we'll have more soon */
         ap_mpm_pod_killpg(pod, ap_daemons_limit, TRUE);
-    
+
 
         /* This is mostly for debugging... so that we know what is still
          * gracefully dealing with existing request.
          */
-        
+
     }
     else {
-        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM 
+        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM
          * and a SIGHUP, we may as well use the same signal, because some user
          * pthreads are stealing signals from us left and right.
          */
@@ -1893,7 +1893,7 @@ static int worker_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
     return OK;
 }
 
-static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog, 
+static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                              apr_pool_t *ptemp)
 {
     static int restart_num = 0;
@@ -1903,7 +1903,7 @@ static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
     apr_status_t rv;
 
     mpm_state = AP_MPMQ_STARTING;
-    
+
     /* make sure that "ThreadsPerChild" gets set before "MaxClients" */
     for (pdir = ap_conftree; pdir != NULL; pdir = pdir->next) {
         if (strncasecmp(pdir->directive, "ThreadsPerChild", 15) == 0) {
@@ -1926,7 +1926,7 @@ static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                 pdir->args = max_clients->args;
                 pdir->filename = max_clients->filename;
                 pdir->line_num = max_clients->line_num;
-                
+
                 max_clients->directive = temp.directive;
                 max_clients->args = temp.args;
                 max_clients->filename = temp.filename;
@@ -2005,7 +2005,7 @@ static void threadpool_hooks(apr_pool_t *p)
 }
 
 static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy,
-                                        const char *arg) 
+                                        const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -2026,15 +2026,15 @@ static const char *set_min_spare_threads(cmd_parms *cmd, void *dummy,
 
     min_spare_threads = atoi(arg);
     if (min_spare_threads <= 0) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: detected MinSpareThreads set to non-positive.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Resetting to 1 to avoid almost certain Apache failure.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Please read the documentation.");
        min_spare_threads = 1;
     }
-       
+
     return NULL;
 }
 
@@ -2051,7 +2051,7 @@ static const char *set_max_spare_threads(cmd_parms *cmd, void *dummy,
 }
 
 static const char *set_max_clients (cmd_parms *cmd, void *dummy,
-                                     const char *arg) 
+                                     const char *arg)
 {
     int max_clients;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
@@ -2063,47 +2063,47 @@ static const char *set_max_clients (cmd_parms *cmd, void *dummy,
      * sure that it gets set before MaxClients in the pre_config stage. */
     max_clients = atoi(arg);
     if (max_clients < ap_threads_per_child) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients (%d) must be at least as large",
                     max_clients);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " large as ThreadsPerChild (%d). Automatically",
                     ap_threads_per_child);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " increasing MaxClients to %d.",
                     ap_threads_per_child);
        max_clients = ap_threads_per_child;
     }
     ap_daemons_limit = max_clients / ap_threads_per_child;
     if ((max_clients > 0) && (max_clients % ap_threads_per_child)) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients (%d) is not an integer multiple",
                     max_clients);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " of ThreadsPerChild (%d), lowering MaxClients to %d",
                     ap_threads_per_child,
                     ap_daemons_limit * ap_threads_per_child);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " for a maximum of %d child processes,",
                     ap_daemons_limit);
-       max_clients = ap_daemons_limit * ap_threads_per_child; 
+       max_clients = ap_daemons_limit * ap_threads_per_child;
     }
     if (ap_daemons_limit > server_limit) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients of %d would require %d servers,",
                     max_clients, ap_daemons_limit);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " and would exceed the ServerLimit value of %d.",
                     server_limit);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " Automatically lowering MaxClients to %d.  To increase,",
                     server_limit * ap_threads_per_child);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " please see the ServerLimit directive.");
        ap_daemons_limit = server_limit;
-    } 
+    }
     else if (ap_daemons_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require MaxClients > 0, setting to 1");
         ap_daemons_limit = 1;
     }
@@ -2111,7 +2111,7 @@ static const char *set_max_clients (cmd_parms *cmd, void *dummy,
 }
 
 static const char *set_threads_per_child (cmd_parms *cmd, void *dummy,
-                                          const char *arg) 
+                                          const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -2120,29 +2120,29 @@ static const char *set_threads_per_child (cmd_parms *cmd, void *dummy,
 
     ap_threads_per_child = atoi(arg);
     if (ap_threads_per_child > thread_limit) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
                      "value of %d", ap_threads_per_child,
                      thread_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "threads, lowering ThreadsPerChild to %d. To increase, please"
                      " see the", thread_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      " ThreadLimit directive.");
         ap_threads_per_child = thread_limit;
     }
     else if (ap_threads_per_child < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ThreadsPerChild > 0, setting to 1");
         ap_threads_per_child = 1;
     }
     return NULL;
 }
 
-static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     int tmp_server_limit;
-    
+
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -2162,27 +2162,27 @@ static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *ar
         return NULL;
     }
     server_limit = tmp_server_limit;
-    
+
     if (server_limit > MAX_SERVER_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: ServerLimit of %d exceeds compile time limit "
                     "of %d servers,", server_limit, MAX_SERVER_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering ServerLimit to %d.", MAX_SERVER_LIMIT);
        server_limit = MAX_SERVER_LIMIT;
-    } 
+    }
     else if (server_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ServerLimit > 0, setting to 1");
         server_limit = 1;
     }
     return NULL;
 }
 
-static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     int tmp_thread_limit;
-    
+
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -2202,17 +2202,17 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
         return NULL;
     }
     thread_limit = tmp_thread_limit;
-    
+
     if (thread_limit > MAX_THREAD_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: ThreadLimit of %d exceeds compile time limit "
                     "of %d servers,", thread_limit, MAX_THREAD_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering ThreadLimit to %d.", MAX_THREAD_LIMIT);
        thread_limit = MAX_THREAD_LIMIT;
-    } 
+    }
     else if (thread_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ThreadLimit > 0, setting to 1");
         thread_limit = 1;
     }
diff --git a/server/mpm/mpmt_os2/mpmt_os2.c b/server/mpm/mpmt_os2/mpmt_os2.c
index ac40874..44e8e48 100644
--- a/server/mpm/mpmt_os2/mpmt_os2.c
+++ b/server/mpm/mpmt_os2/mpmt_os2.c
@@ -58,8 +58,8 @@
 #include <os2.h>
 #include <process.h>
 
-/* We don't need many processes, 
- * they're only for redundancy in the event of a crash 
+/* We don't need many processes,
+ * they're only for redundancy in the event of a crash
  */
 #define HARD_SERVER_LIMIT 10
 
@@ -441,10 +441,10 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
             return APR_SUCCESS;
         case AP_MPMQ_MAX_REQUESTS_DAEMON:
             *result = ap_max_requests_per_child;
-            return APR_SUCCESS; 
+            return APR_SUCCESS;
     }
     return APR_ENOTIMPL;
-} 
+}
 
 
 
@@ -459,7 +459,7 @@ int ap_graceful_stop_signalled(void)
 
 static int mpmt_os2_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
 {
-    one_process = ap_exists_config_define("ONE_PROCESS") || 
+    one_process = ap_exists_config_define("ONE_PROCESS") ||
                   ap_exists_config_define("DEBUG");
     is_graceful = 0;
     ap_listen_pre_config();
@@ -512,15 +512,15 @@ static const char *set_min_spare_threads(cmd_parms *cmd, void *dummy,
     ap_min_spare_threads = atoi(arg);
 
     if (ap_min_spare_threads <= 0) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: detected MinSpareThreads set to non-positive.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Resetting to 1 to avoid almost certain Apache failure.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Please read the documentation.");
        ap_min_spare_threads = 1;
     }
-       
+
     return NULL;
 }
 
@@ -550,7 +550,7 @@ static const char *ignore_cmd(cmd_parms *cmd, void *dummy, const char *arg)
 
 static const command_rec mpmt_os2_cmds[] = {
 LISTEN_COMMANDS,
-AP_INIT_TAKE1( "StartServers", set_daemons_to_start, NULL, RSRC_CONF, 
+AP_INIT_TAKE1( "StartServers", set_daemons_to_start, NULL, RSRC_CONF,
   "Number of child processes launched at server startup" ),
 AP_INIT_TAKE1("MinSpareThreads", set_min_spare_threads, NULL, RSRC_CONF,
   "Minimum number of idle children, to handle request spikes"),
diff --git a/server/mpm/mpmt_os2/mpmt_os2_child.c b/server/mpm/mpmt_os2/mpmt_os2_child.c
index b1f03e7..3aef26b 100644
--- a/server/mpm/mpmt_os2/mpmt_os2_child.c
+++ b/server/mpm/mpmt_os2/mpmt_os2_child.c
@@ -39,8 +39,8 @@
 
 /* XXXXXX move these to header file private to this MPM */
 
-/* We don't need many processes, 
- * they're only for redundancy in the event of a crash 
+/* We don't need many processes,
+ * they're only for redundancy in the event of a crash
  */
 #define HARD_SERVER_LIMIT 10
 
@@ -332,7 +332,7 @@ ULONG APIENTRY thread_exception_handler(EXCEPTIONREPORTRECORD *pReportRec,
         kill(getpid(), SIGHUP);
         DosUnwindException(UNWIND_ALL, 0, 0);
     }
-  
+
     return XCPT_CONTINUE_SEARCH;
 }
 
@@ -355,7 +355,7 @@ static void worker_main(void *vpArg)
     int thread_slot = (int)vpArg;
     EXCEPTIONREGISTRATIONRECORD reg_rec = { NULL, thread_exception_handler };
     ap_sb_handle_t *sbh;
-  
+
     /* Trap exceptions in this thread so we don't take down the whole process */
     DosSetExceptionHandler( &reg_rec );
 
@@ -369,7 +369,7 @@ static void worker_main(void *vpArg)
     }
 
     conn_id = ID_FROM_CHILD_THREAD(child_slot, thread_slot);
-    ap_update_child_status_from_indexes(child_slot, thread_slot, SERVER_READY, 
+    ap_update_child_status_from_indexes(child_slot, thread_slot, SERVER_READY,
                                         NULL);
 
     apr_allocator_create(&allocator);
@@ -390,11 +390,11 @@ static void worker_main(void *vpArg)
         }
 
         apr_pool_destroy(pconn);
-        ap_update_child_status_from_indexes(child_slot, thread_slot, 
+        ap_update_child_status_from_indexes(child_slot, thread_slot,
                                             SERVER_READY, NULL);
     }
 
-    ap_update_child_status_from_indexes(child_slot, thread_slot, SERVER_DEAD, 
+    ap_update_child_status_from_indexes(child_slot, thread_slot, SERVER_DEAD,
                                         NULL);
 
     apr_bucket_alloc_destroy(bucket_alloc);
diff --git a/server/mpm/netware/mpm_netware.c b/server/mpm/netware/mpm_netware.c
index 282c320..fb7c356 100644
--- a/server/mpm/netware/mpm_netware.c
+++ b/server/mpm/netware/mpm_netware.c
@@ -17,15 +17,15 @@
 /*
  * httpd.c: simple http daemon for answering WWW file requests
  *
- * 
+ *
  * 03-21-93  Rob McCool wrote original code (up to NCSA HTTPd 1.3)
- * 
+ *
  * 03-06-95  blong
  *  changed server number for child-alone processes to 0 and changed name
  *   of processes
  *
  * 03-10-95  blong
- *      Added numerous speed hacks proposed by Robert S. Thau (rst@ai.mit.edu) 
+ *      Added numerous speed hacks proposed by Robert S. Thau (rst@ai.mit.edu)
  *      including set group before fork, and call gettime before to fork
  *      to set up libraries.
  *
@@ -174,9 +174,9 @@ static int volatile wait_to_finish=1;
 ap_generation_t volatile ap_my_generation=0;
 
 /* a clean exit from a child with proper cleanup */
-static void clean_child_exit(int code, int worker_num, apr_pool_t *ptrans, 
+static void clean_child_exit(int code, int worker_num, apr_pool_t *ptrans,
                              apr_bucket_alloc_t *bucket_alloc) __attribute__ ((noreturn));
-static void clean_child_exit(int code, int worker_num, apr_pool_t *ptrans, 
+static void clean_child_exit(int code, int worker_num, apr_pool_t *ptrans,
                              apr_bucket_alloc_t *bucket_alloc)
 {
     apr_bucket_alloc_destroy(bucket_alloc);
@@ -186,7 +186,7 @@ static void clean_child_exit(int code, int worker_num, apr_pool_t *ptrans,
 
     atomic_dec (&worker_thread_count);
     if (worker_num >=0)
-        ap_update_child_status_from_indexes(0, worker_num, WORKER_DEAD, 
+        ap_update_child_status_from_indexes(0, worker_num, WORKER_DEAD,
                                             (request_rec *) NULL);
     NXThreadExit((void*)&code);
 }
@@ -370,7 +370,7 @@ void worker_main(void *arg)
             clean_child_exit(0, my_worker_num, ptrans, bucket_alloc);
         }
 
-        ap_update_child_status_from_indexes(0, my_worker_num, WORKER_READY, 
+        ap_update_child_status_from_indexes(0, my_worker_num, WORKER_READY,
                                             (request_rec *) NULL);
 
         /*
@@ -431,7 +431,7 @@ void worker_main(void *arg)
                 }
                 else {
                     /* if the error is a wouldblock then maybe we were too
-                        quick try to pull the next request from the listen 
+                        quick try to pull the next request from the listen
                         queue.  Try a few more times then return to our idle
                         listen state. */
                     if (!APR_STATUS_IS_EAGAIN(stat)) {
@@ -490,7 +490,7 @@ void worker_main(void *arg)
                         */
                         ap_log_error(APLOG_MARK, APLOG_EMERG, stat, ap_server_conf,
                             "apr_socket_accept: giving up.");
-                        clean_child_exit(APEXIT_CHILDFATAL, my_worker_num, ptrans, 
+                        clean_child_exit(APEXIT_CHILDFATAL, my_worker_num, ptrans,
                                          bucket_alloc);
                 }
 #endif
@@ -507,7 +507,7 @@ void worker_main(void *arg)
         * We now have a connection, so set it up with the appropriate
         * socket options, file descriptors, and read/write buffers.
         */
-        current_conn = ap_run_create_connection(ptrans, ap_server_conf, csd, 
+        current_conn = ap_run_create_connection(ptrans, ap_server_conf, csd,
                                                 my_worker_num, sbh,
                                                 bucket_alloc);
         if (current_conn) {
@@ -530,7 +530,7 @@ static int make_child(server_rec *s, int slot)
         ap_max_workers_limit = slot + 1;
     }
 
-    ap_update_child_status_from_indexes(0, slot, WORKER_STARTING, 
+    ap_update_child_status_from_indexes(0, slot, WORKER_STARTING,
                                         (request_rec *) NULL);
 
     if (ctx = NXContextAlloc((void (*)(void *)) worker_main, (void*)slot, NX_PRIO_MED, ap_thread_stacksize, NX_CTX_NORMAL, &err)) {
@@ -548,7 +548,7 @@ static int make_child(server_rec *s, int slot)
         /* create thread didn't succeed. Fix the scoreboard or else
         * it will say SERVER_STARTING forever and ever
         */
-        ap_update_child_status_from_indexes(0, slot, WORKER_DEAD, 
+        ap_update_child_status_from_indexes(0, slot, WORKER_DEAD,
                                             (request_rec *) NULL);
 
         /* In case system resources are maxxed out, we don't want
@@ -661,7 +661,7 @@ static void perform_idle_server_maintenance(apr_pool_t *p)
         * while we were counting
         */
         idle_spawn_rate = 1;
-        ap_update_child_status_from_indexes(0, last_non_dead, WORKER_IDLE_KILL, 
+        ap_update_child_status_from_indexes(0, last_non_dead, WORKER_IDLE_KILL,
                                             (request_rec *) NULL);
         DBPRINT1("\nKilling idle thread: %d\n", last_non_dead);
     }
@@ -716,9 +716,9 @@ static void display_settings ()
     int reqs = request_count;
 #ifdef DBINFO_ON
     int wblock = would_block;
-    
+
     would_block = 0;
-#endif    
+#endif
 
     request_count = 0;
 
@@ -779,7 +779,7 @@ static void display_settings ()
     }
     printf ("Total Running:\t%d\tout of: \t%d\n", total, ap_threads_limit);
     printf ("Requests per interval:\t%d\n", reqs);
-    
+
 #ifdef DBINFO_ON
     printf ("Would blocks:\t%d\n", wblock);
     printf ("Successful retries:\t%d\n", retry_success);
@@ -805,9 +805,9 @@ static void show_server_data()
        printf(" %d", lr->bind_addr->port);
        lr = lr->next;
     } while(lr && lr != ap_listeners);
-    
+
     /* Display dynamic modules loaded */
-    printf("\n");    
+    printf("\n");
     for (m = ap_loaded_modules; *m != NULL; m++) {
         if (((module*)*m)->dynamic_load_handle) {
             printf("   Loaded dynamic module %s\n", ((module*)*m)->name);
@@ -921,7 +921,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     mpm_state = AP_MPMQ_STOPPING;
 
 
-    /* Shutdown the listen sockets so that we don't get stuck in a blocking call. 
+    /* Shutdown the listen sockets so that we don't get stuck in a blocking call.
     shutdown_listeners();*/
 
     if (shutdown_pending) { /* Got an unload from the console */
@@ -929,7 +929,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
             "caught SIGTERM, shutting down");
 
         while (worker_thread_count > 0) {
-            printf ("\rShutdown pending. Waiting for %d thread(s) to terminate...", 
+            printf ("\rShutdown pending. Waiting for %d thread(s) to terminate...",
                     worker_thread_count);
             apr_thread_yield();
         }
@@ -1000,7 +1000,7 @@ static void netware_mpm_hooks(apr_pool_t *p)
     ap_hook_pre_config(netware_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
-void netware_rewrite_args(process_rec *process) 
+void netware_rewrite_args(process_rec *process)
 {
     char *def_server_root;
     char optbuf[3];
@@ -1015,10 +1015,10 @@ void netware_rewrite_args(process_rec *process)
     /* Make sure to hold the Apache screen open if exit() is called */
     hold_screen_on_exit = 1;
 
-    /* Rewrite process->argv[]; 
+    /* Rewrite process->argv[];
      *
      * add default -d serverroot from the path of this executable
-     * 
+     *
      * The end result will look like:
      *     The -d serverroot default from the running executable
      */
@@ -1030,14 +1030,14 @@ void netware_rewrite_args(process_rec *process)
             for (i=len; i; i--) {
                 if (s[i] == '\\' || s[i] == '/') {
                     s[i] = '\0';
-                    apr_filepath_merge(&def_server_root, NULL, s, 
+                    apr_filepath_merge(&def_server_root, NULL, s,
                         APR_FILEPATH_TRUENAME, process->pool);
                     break;
                 }
             }
             /* Use process->pool so that the rewritten argv
             * lasts for the lifetime of the server process,
-            * because pconf will be destroyed after the 
+            * because pconf will be destroyed after the
             * initial pre-flight of the config parser.
             */
             mpm_new_argv = apr_array_make(process->pool, process->argc + 2,
@@ -1069,7 +1069,7 @@ void netware_rewrite_args(process_rec *process)
                     break;
                 }
             }
-            process->argc = mpm_new_argv->nelts; 
+            process->argc = mpm_new_argv->nelts;
             process->argv = (const char * const *) mpm_new_argv->elts;
         }
     }
@@ -1096,14 +1096,14 @@ static int CommandLineInterpreter(scr_t screenID, const char *commandLine)
     if (!strnicmp(szCommand, szcommandLine, iCommandLen)) {
         ActivateScreen (getscreenhandle());
 
-        /* If an instance id was not given but the nlm is loaded in 
+        /* If an instance id was not given but the nlm is loaded in
             protected space, then the the command belongs to the
             OS address space instance to pass it on. */
         pID = strstr (szcommandLine, "-p");
         if ((pID == NULL) && nlmisloadedprotected())
             return NOTMYCOMMAND;
 
-        /* If we got an instance id but it doesn't match this 
+        /* If we got an instance id but it doesn't match this
             instance of the nlm, pass it on. */
         if (pID) {
             pID = &pID[2];
@@ -1195,7 +1195,7 @@ static void RemoveConsoleHandler(void)
     NX_UNWRAP_INTERFACE(ConsoleHandler.parser);
 }
 
-static const char *set_threads_to_start(cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_threads_to_start(cmd_parms *cmd, void *dummy, const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1215,15 +1215,15 @@ static const char *set_min_free_threads(cmd_parms *cmd, void *dummy, const char
 
     ap_threads_min_free = atoi(arg);
     if (ap_threads_min_free <= 0) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: detected MinSpareServers set to non-positive.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Resetting to 1 to avoid almost certain Apache failure.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Please read the documentation.");
        ap_threads_min_free = 1;
     }
-       
+
     return NULL;
 }
 
@@ -1238,7 +1238,7 @@ static const char *set_max_free_threads(cmd_parms *cmd, void *dummy, const char
     return NULL;
 }
 
-static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1247,19 +1247,19 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
 
     ap_threads_limit = atoi(arg);
     if (ap_threads_limit > HARD_THREAD_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxThreads of %d exceeds compile time limit "
                     "of %d threads,", ap_threads_limit, HARD_THREAD_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering MaxThreads to %d.  To increase, please "
                     "see the", HARD_THREAD_LIMIT);
        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " HARD_THREAD_LIMIT define in %s.",
                     AP_MPM_HARD_LIMITS_FILE);
        ap_threads_limit = HARD_THREAD_LIMIT;
-    } 
+    }
     else if (ap_threads_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
             "WARNING: Require MaxThreads > 0, setting to 1");
         ap_threads_limit = 1;
     }
diff --git a/server/mpm/prefork/prefork.c b/server/mpm/prefork/prefork.c
index 0859b3d..5d1c169 100644
--- a/server/mpm/prefork/prefork.c
+++ b/server/mpm/prefork/prefork.c
@@ -104,7 +104,7 @@ static ap_pod_t *pod;
 
 /*
  * The max child slot ever assigned, preserved across restarts.  Necessary
- * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We 
+ * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We
  * use this value to optimize routines that have to scan the entire scoreboard.
  */
 int ap_max_daemons_limit = -1;
@@ -141,7 +141,7 @@ char tpf_server_name[INETD_SERVNAME_LENGTH+1];
 static volatile int die_now = 0;
 
 #ifdef GPROF
-/* 
+/*
  * change directory for gprof to plop the gmon.out file
  * configure in httpd.conf:
  * GprofDir $RuntimeDir/   -> $ServerRoot/$RuntimeDir/gmon.out
@@ -149,8 +149,8 @@ static volatile int die_now = 0;
  */
 static void chdir_for_gprof(void)
 {
-    core_server_config *sconf = 
-        ap_get_module_config(ap_server_conf->module_config, &core_module); 
+    core_server_config *sconf =
+        ap_get_module_config(ap_server_conf->module_config, &core_module);
     char *dir = sconf->gprof_dir;
     const char *use_dir;
 
@@ -184,7 +184,7 @@ static void chdir_for_gprof(void)
 
 /* XXX - I don't know if TPF will ever use this module or not, so leave
  * the ap_check_signals calls in but disable them - manoj */
-#define ap_check_signals() 
+#define ap_check_signals()
 
 /* a clean exit from a child with proper cleanup */
 static void clean_child_exit(int code) __attribute__ ((noreturn));
@@ -206,7 +206,7 @@ static void accept_mutex_on(void)
     if (rv != APR_SUCCESS) {
         const char *msg = "couldn't grab the accept mutex";
 
-        if (ap_my_generation != 
+        if (ap_my_generation !=
             ap_scoreboard_image->global->running_generation) {
             ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, NULL, "%s", msg);
             clean_child_exit(0);
@@ -224,7 +224,7 @@ static void accept_mutex_off(void)
     if (rv != APR_SUCCESS) {
         const char *msg = "couldn't release the accept mutex";
 
-        if (ap_my_generation != 
+        if (ap_my_generation !=
             ap_scoreboard_image->global->running_generation) {
             ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, NULL, "%s", msg);
             /* don't exit here... we have a connection to
@@ -386,7 +386,7 @@ static void set_signals(void)
         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
 #ifdef AP_SIG_GRACEFUL_STOP
     if (sigaction(AP_SIG_GRACEFUL_STOP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(" AP_SIG_GRACEFUL_STOP_STRING ")");
 #endif
 #ifdef SIGINT
@@ -409,7 +409,7 @@ static void set_signals(void)
         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGPIPE)");
 #endif
 
-    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy 
+    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy
      * processing one
      */
     sigaddset(&sa.sa_mask, SIGHUP);
@@ -478,7 +478,7 @@ static void child_main(int child_num_arg)
     mpm_state = AP_MPMQ_STARTING; /* for benefit of any hooks that run as this
                                    * child initializes
                                    */
-    
+
     my_child_num = child_num_arg;
     ap_my_pid = getpid();
     requests_this_child = 0;
@@ -533,7 +533,7 @@ static void child_main(int child_num_arg)
     }
 
     mpm_state = AP_MPMQ_RUNNING;
-    
+
     bucket_alloc = apr_bucket_alloc_create(pchild);
 
     while (!die_now) {
@@ -640,7 +640,7 @@ static void child_main(int child_num_arg)
             ap_process_connection(current_conn, csd);
             ap_lingering_close(current_conn);
         }
-        
+
         /* Check the pod and the generation number after processing a
          * connection so that we'll go away if a graceful restart occurred
          * while we were processing the connection or we are the lucky
@@ -715,10 +715,10 @@ static int make_child(server_rec *s, int slot)
         /* by default AIX binds to a single processor
          * this bit unbinds children which will then bind to another cpu
          */
-        int status = bindprocessor(BINDPROCESS, (int)getpid(), 
+        int status = bindprocessor(BINDPROCESS, (int)getpid(),
                                    PROCESSOR_CLASS_ANY);
         if (status != OK) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, 
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno,
                          ap_server_conf, "processor unbind failed %d", status);
         }
 #endif
@@ -729,7 +729,7 @@ static int make_child(server_rec *s, int slot)
          */
         apr_signal(SIGHUP, just_die);
         apr_signal(SIGTERM, just_die);
-        /* The child process just closes listeners on AP_SIG_GRACEFUL.  
+        /* The child process just closes listeners on AP_SIG_GRACEFUL.
          * The pod is used for signalling the graceful restart.
          */
         apr_signal(AP_SIG_GRACEFUL, stop_listening);
@@ -912,7 +912,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                                  ap_server_root_relative(_pconf, ap_lock_fname),
                                  ap_my_pid);
 
-    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname, 
+    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname,
                                ap_accept_lock_mech, _pconf);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -923,7 +923,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     }
 
 #if APR_USE_SYSVSEM_SERIALIZE
-    if (ap_accept_lock_mech == APR_LOCK_DEFAULT || 
+    if (ap_accept_lock_mech == APR_LOCK_DEFAULT ||
         ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
 #else
     if (ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
@@ -996,7 +996,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     restart_pending = shutdown_pending = 0;
 
     mpm_state = AP_MPMQ_RUNNING;
-    
+
     while (!restart_pending && !shutdown_pending) {
         int child_slot;
         apr_exit_why_e exitwhy;
@@ -1024,9 +1024,9 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                                                            (request_rec *) NULL);
                 if (processed_status == APEXIT_CHILDSICK) {
                     /* child detected a resource shortage (E[NM]FILE, ENOBUFS, etc)
-                     * cut the fork rate to the minimum 
+                     * cut the fork rate to the minimum
                      */
-                    idle_spawn_rate = 1; 
+                    idle_spawn_rate = 1;
                 }
                 else if (remaining_children_to_start
                     && child_slot < ap_daemons_limit) {
@@ -1047,7 +1047,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                  * scoreboard.  Somehow we don't know about this
                  * child.
                  */
-                ap_log_error(APLOG_MARK, APLOG_WARNING, 
+                ap_log_error(APLOG_MARK, APLOG_WARNING,
                             0, ap_server_conf,
                             "long lost child came home! (pid %ld)", (long)pid.pid);
             }
@@ -1150,7 +1150,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
            "caught " AP_SIG_GRACEFUL_STOP_STRING ", shutting down gracefully");
 
         if (ap_graceful_shutdown_timeout) {
-            cutoff = apr_time_now() + 
+            cutoff = apr_time_now() +
                      apr_time_from_sec(ap_graceful_shutdown_timeout);
         }
 
@@ -1159,10 +1159,10 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         do {
             /* Pause for a second */
             sleep(1);
-                
+
             /* Relieve any children which have now exited */
             ap_relieve_child_processes();
-            
+
             active_children = 0;
             for (index = 0; index < ap_daemons_limit; ++index) {
                 if (MPM_CHILD_PID(index) != 0) {
@@ -1199,7 +1199,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
      */
     ++ap_my_generation;
     ap_scoreboard_image->global->running_generation = ap_my_generation;
-    
+
     if (is_graceful) {
         ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                     "Graceful restart requested, doing restart");
@@ -1250,7 +1250,7 @@ static int prefork_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
     ap_server_conf = s;
 
     if ((num_listensocks = ap_setup_listeners(ap_server_conf)) < 1) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0, 
+        ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0,
                      NULL, "no listening sockets available, shutting down");
         return DONE;
     }
@@ -1339,7 +1339,7 @@ static void prefork_hooks(apr_pool_t *p)
     ap_hook_pre_config(prefork_pre_config, NULL, NULL, APR_HOOK_REALLY_FIRST);
 }
 
-static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy, const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1359,15 +1359,15 @@ static const char *set_min_free_servers(cmd_parms *cmd, void *dummy, const char
 
     ap_daemons_min_free = atoi(arg);
     if (ap_daemons_min_free <= 0) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: detected MinSpareServers set to non-positive.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Resetting to 1 to avoid almost certain Apache failure.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Please read the documentation.");
        ap_daemons_min_free = 1;
     }
-       
+
     return NULL;
 }
 
@@ -1382,7 +1382,7 @@ static const char *set_max_free_servers(cmd_parms *cmd, void *dummy, const char
     return NULL;
 }
 
-static const char *set_max_clients (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_max_clients (cmd_parms *cmd, void *dummy, const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1391,28 +1391,28 @@ static const char *set_max_clients (cmd_parms *cmd, void *dummy, const char *arg
 
     ap_daemons_limit = atoi(arg);
     if (ap_daemons_limit > server_limit) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients of %d exceeds ServerLimit value "
                     "of %d servers,", ap_daemons_limit, server_limit);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering MaxClients to %d.  To increase, please "
                     "see the ServerLimit", server_limit);
        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " directive.");
        ap_daemons_limit = server_limit;
-    } 
+    }
     else if (ap_daemons_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require MaxClients > 0, setting to 1");
         ap_daemons_limit = 1;
     }
     return NULL;
 }
 
-static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     int tmp_server_limit;
-    
+
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -1432,17 +1432,17 @@ static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *ar
         return NULL;
     }
     server_limit = tmp_server_limit;
-    
+
     if (server_limit > MAX_SERVER_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: ServerLimit of %d exceeds compile time limit "
                     "of %d servers,", server_limit, MAX_SERVER_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering ServerLimit to %d.", MAX_SERVER_LIMIT);
        server_limit = MAX_SERVER_LIMIT;
-    } 
+    }
     else if (server_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ServerLimit > 0, setting to 1");
         server_limit = 1;
     }
diff --git a/server/mpm/winnt/Win9xConHook.c b/server/mpm/winnt/Win9xConHook.c
index 8a07801..c2ee611 100644
--- a/server/mpm/winnt/Win9xConHook.c
+++ b/server/mpm/winnt/Win9xConHook.c
@@ -21,16 +21,16 @@
  *
  * It is well(?) documented by Microsoft that the Win9x HandlerRoutine
  * hooked by the SetConsoleCtrlHandler never receives the CTRL_CLOSE_EVENT,
- * CTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT signals.  
+ * CTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT signals.
  *
- * It is possible to have a second window to monitor the WM_ENDSESSION 
+ * It is possible to have a second window to monitor the WM_ENDSESSION
  * message, but the close button still fails..
- * 
+ *
  * There is a 16bit polling method for the close window option, but this
  * is CPU intensive and requires thunking.
  *
  * Attempts to subclass the 'tty' console fail, since that message thread
- * is actually owned by the 16 bit winoldap.mod process, although the 
+ * is actually owned by the 16 bit winoldap.mod process, although the
  * window reports it is owned by the process/thread of the console app.
  *
  * Win9xConHook is thunks the WM_CLOSE and WM_ENDSESSION messages,
@@ -102,16 +102,16 @@ typedef struct {
 #define gwltty_phandler 0
 #define gwltty_ttywnd 4
 
-/* Forward declaration prototypes for internal functions 
+/* Forward declaration prototypes for internal functions
  */
 static BOOL CALLBACK EnumttyWindow(HWND wnd, LPARAM retwnd);
 static LRESULT WINAPI RegisterWindows9xService(BOOL set_service);
-static LRESULT CALLBACK ttyConsoleCtrlWndProc(HWND hwnd, UINT msg, 
+static LRESULT CALLBACK ttyConsoleCtrlWndProc(HWND hwnd, UINT msg,
                                               WPARAM wParam, LPARAM lParam);
 static DWORD WINAPI ttyConsoleCtrlThread(LPVOID tty);
-static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
+static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
                                 WPARAM wParam, LPARAM lParam);
-static int HookProc(int hc, HWND *hwnd, UINT *msg, 
+static int HookProc(int hc, HWND *hwnd, UINT *msg,
                     WPARAM *wParam, LPARAM *lParam);
 #ifdef DBG
 static VOID DbgPrintf(LPTSTR fmt, ...);
@@ -122,10 +122,10 @@ static VOID DbgPrintf(LPTSTR fmt, ...);
  * by our window hooks, notably the tty processes' context, and by the user
  * who wants tty messages (the app).  Keep it light and simple.
  */
-BOOL __declspec(dllexport) APIENTRY DllMain(HINSTANCE hModule, ULONG ulReason, 
+BOOL __declspec(dllexport) APIENTRY DllMain(HINSTANCE hModule, ULONG ulReason,
                                             LPVOID pctx)
 {
-    if (ulReason == DLL_PROCESS_ATTACH) 
+    if (ulReason == DLL_PROCESS_ATTACH)
     {
         //hmodThis = hModule;
         if (!hookwndmsg) {
@@ -134,18 +134,18 @@ BOOL __declspec(dllexport) APIENTRY DllMain(HINSTANCE hModule, ULONG ulReason,
             hookwndmsg = RegisterWindowMessage("Win9xConHookMsg");
         }
 #ifdef DBG
-//        DbgPrintf("H ProcessAttach:%8.8x\r\n", 
+//        DbgPrintf("H ProcessAttach:%8.8x\r\n",
 //                  GetCurrentProcessId());
 #endif
     }
-    else if ( ulReason == DLL_PROCESS_DETACH ) 
+    else if ( ulReason == DLL_PROCESS_DETACH )
     {
 #ifdef DBG
-//        DbgPrintf("H ProcessDetach:%8.8x\r\n", GetCurrentProcessId());                
+//        DbgPrintf("H ProcessDetach:%8.8x\r\n", GetCurrentProcessId());
 #endif
         if (monitor_hwnd)
             SendMessage(monitor_hwnd, WM_DESTROY, 0, 0);
-        if (is_subclassed) 
+        if (is_subclassed)
             SendMessage(hwtty, hookwndmsg, 0, (LPARAM)hwtty);
         if (hmodHook)
         {
@@ -254,12 +254,12 @@ BOOL __declspec(dllexport) WINAPI FixConsoleCtrlHandler(
             tty.name = "ttyService";
             RegisterWindows9xService(TRUE);
         }
-        else 
+        else
             tty.name = "ttyMonitor";
         hThread = CreateThread(NULL, 0, ttyConsoleCtrlThread,
                                (LPVOID)&tty, 0, &tid);
         if (!hThread)
-            return FALSE;        
+            return FALSE;
         CloseHandle(hThread);
         hmodHook = LoadLibrary("Win9xConHook.dll");
         if (hmodHook)
@@ -268,7 +268,7 @@ BOOL __declspec(dllexport) WINAPI FixConsoleCtrlHandler(
               (HOOKPROC)GetProcAddress(hmodHook, "GetMsgProc"), hmodHook, 0);
             //hhkCallWndProc = SetWindowsHookEx(WH_CALLWNDPROC,
             //  (HOOKPROC)GetProcAddress(hmodHook, "CallWndProc"), hmodHook, 0);
-        }        
+        }
         return TRUE;
     }
     else /* remove */
@@ -302,7 +302,7 @@ BOOL __declspec(dllexport) WINAPI FixConsoleCtrlHandler(
 
 /* ttyConsoleCreateThread is the process that runs within the user app's
  * context.  It creates and pumps the messages of a hidden monitor window,
- * watching for messages from the system, or the associated subclassed tty 
+ * watching for messages from the system, or the associated subclassed tty
  * window.  Things can happen in our context that can't be done from the
  * tty's context, and visa versa, so the subclass procedure and this hidden
  * window work together to make it all happen.
@@ -312,9 +312,9 @@ static DWORD WINAPI ttyConsoleCtrlThread(LPVOID tty)
     WNDCLASS wc;
     MSG msg;
     wc.style         = CS_GLOBALCLASS;
-    wc.lpfnWndProc   = ttyConsoleCtrlWndProc; 
+    wc.lpfnWndProc   = ttyConsoleCtrlWndProc;
     wc.cbClsExtra    = 0;
-    wc.cbWndExtra    = 8; 
+    wc.cbWndExtra    = 8;
     wc.hInstance     = NULL;
     wc.hIcon         = NULL;
     wc.hCursor       = NULL;
@@ -324,33 +324,33 @@ static DWORD WINAPI ttyConsoleCtrlThread(LPVOID tty)
         wc.lpszClassName = "ttyConHookChild";
     else
         wc.lpszClassName = "ApacheWin95ServiceMonitor";
-        
-    if (!RegisterClass(&wc)) { 
+
+    if (!RegisterClass(&wc)) {
 #ifdef DBG
-        DbgPrintf("A proc %8.8x Error creating class %s (%d)\r\n", 
+        DbgPrintf("A proc %8.8x Error creating class %s (%d)\r\n",
                   GetCurrentProcessId(), wc.lpszClassName, GetLastError());
 #endif
         return 0;
     }
 
     /* Create an invisible window */
-    monitor_hwnd = CreateWindow(wc.lpszClassName, ((tty_info*)tty)->name, 
+    monitor_hwnd = CreateWindow(wc.lpszClassName, ((tty_info*)tty)->name,
                                 WS_OVERLAPPED & ~WS_VISIBLE,
-                                CW_USEDEFAULT, CW_USEDEFAULT, 
-                                CW_USEDEFAULT, CW_USEDEFAULT, 
-                                NULL, NULL, 
+                                CW_USEDEFAULT, CW_USEDEFAULT,
+                                CW_USEDEFAULT, CW_USEDEFAULT,
+                                NULL, NULL,
                                 ((tty_info*)tty)->instance, tty);
 
     if (!monitor_hwnd) {
 #ifdef DBG
-        DbgPrintf("A proc %8.8x Error creating window %s %s (%d)\r\n", 
-                  GetCurrentProcessId(), wc.lpszClassName, 
+        DbgPrintf("A proc %8.8x Error creating window %s %s (%d)\r\n",
+                  GetCurrentProcessId(), wc.lpszClassName,
                   ((tty_info*)tty)->name, GetLastError());
 #endif
         return 0;
     }
 
-    while (GetMessage(&msg, NULL, 0, 0)) 
+    while (GetMessage(&msg, NULL, 0, 0))
     {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
@@ -365,10 +365,10 @@ static DWORD WINAPI ttyConsoleCtrlThread(LPVOID tty)
 /* This is the WndProc procedure for our invisible window.
  * When our subclasssed tty window receives the WM_CLOSE, WM_ENDSESSION,
  * or WM_QUERYENDSESSION messages, the message is dispatched to our hidden
- * window (this message process), and we call the installed HandlerRoutine 
+ * window (this message process), and we call the installed HandlerRoutine
  * that was registered by the app.
  */
-static LRESULT CALLBACK ttyConsoleCtrlWndProc(HWND hwnd, UINT msg, 
+static LRESULT CALLBACK ttyConsoleCtrlWndProc(HWND hwnd, UINT msg,
                                               WPARAM wParam, LPARAM lParam)
 {
     if (msg == WM_CREATE)
@@ -377,14 +377,14 @@ static LRESULT CALLBACK ttyConsoleCtrlWndProc(HWND hwnd, UINT msg,
         SetWindowLong(hwnd, gwltty_phandler, (LONG)tty->phandler);
         SetWindowLong(hwnd, gwltty_ttywnd, (LONG)tty->parent);
 #ifdef DBG
-        DbgPrintf("A proc %8.8x created %8.8x %s for tty wnd %8.8x\r\n", 
-                  GetCurrentProcessId(), hwnd, 
+        DbgPrintf("A proc %8.8x created %8.8x %s for tty wnd %8.8x\r\n",
+                  GetCurrentProcessId(), hwnd,
                   tty->name, tty->parent);
 #endif
         if (tty->parent) {
             SetProp(tty->parent, hookwndprop, hwnd);
-            PostMessage(tty->parent, hookwndmsg, 
-                        tty->type, (LPARAM)tty->parent); 
+            PostMessage(tty->parent, hookwndmsg,
+                        tty->type, (LPARAM)tty->parent);
         }
         return 0;
     }
@@ -397,13 +397,13 @@ static LRESULT CALLBACK ttyConsoleCtrlWndProc(HWND hwnd, UINT msg,
 #endif
         if (parent) {
             RemoveProp(parent, hookwndprop);
-            SendMessage(parent, hookwndmsg, 0, (LPARAM)parent); 
+            SendMessage(parent, hookwndmsg, 0, (LPARAM)parent);
         }
         monitor_hwnd = NULL;
     }
     else if (msg == WM_CLOSE)
     {
-        PHANDLER_ROUTINE phandler = 
+        PHANDLER_ROUTINE phandler =
             (PHANDLER_ROUTINE)GetWindowLong(hwnd, gwltty_phandler);
         LRESULT rv = phandler(CTRL_CLOSE_EVENT);
 #ifdef DBG
@@ -416,9 +416,9 @@ static LRESULT CALLBACK ttyConsoleCtrlWndProc(HWND hwnd, UINT msg,
     }
     else if ((msg == WM_QUERYENDSESSION) || (msg == WM_ENDSESSION))
     {
-        if (lParam & ENDSESSION_LOGOFF) 
+        if (lParam & ENDSESSION_LOGOFF)
         {
-            PHANDLER_ROUTINE phandler = 
+            PHANDLER_ROUTINE phandler =
                 (PHANDLER_ROUTINE)GetWindowLong(hwnd, gwltty_phandler);
             LRESULT rv = phandler(CTRL_LOGOFF_EVENT);
 #ifdef DBG
@@ -431,7 +431,7 @@ static LRESULT CALLBACK ttyConsoleCtrlWndProc(HWND hwnd, UINT msg,
         }
         else
         {
-            PHANDLER_ROUTINE phandler = 
+            PHANDLER_ROUTINE phandler =
                 (PHANDLER_ROUTINE)GetWindowLong(hwnd, gwltty_phandler);
             LRESULT rv = phandler(CTRL_SHUTDOWN_EVENT);
 #ifdef DBG
@@ -449,7 +449,7 @@ static LRESULT CALLBACK ttyConsoleCtrlWndProc(HWND hwnd, UINT msg,
 /*  The following internal helpers are invoked by the hooked tty and our app
  */
 
- 
+
 /*  Register or deregister the current process as a Windows9x style service.
  *  Experience shows this call is ignored across processes, so the second
  *  arg to RegisterServiceProcess (process group id) is effectively useless.
@@ -475,7 +475,7 @@ static LRESULT WINAPI RegisterWindows9xService(BOOL set_service)
         hkernel = LoadLibrary("KERNEL32.DLL");
         if (!hkernel)
             return 0;
-    
+
         /* Find the RegisterServiceProcess function */
         register_service_process = (DWORD (WINAPI *)(DWORD, DWORD))
                          GetProcAddress(hkernel, "RegisterServiceProcess");
@@ -484,12 +484,12 @@ static LRESULT WINAPI RegisterWindows9xService(BOOL set_service)
             return 0;
         }
     }
-    
+
     /* Register this process as a service */
     rv = register_service_process(0, set_service != FALSE);
     if (rv)
         is_service = set_service;
-    
+
     if (!is_service)
     {
         /* Unload the kernel library */
@@ -500,15 +500,15 @@ static LRESULT WINAPI RegisterWindows9xService(BOOL set_service)
 }
 
 
-/* 
- * This function only works when this process is the active process 
- * (e.g. once it is running a child process, it can no longer determine 
+/*
+ * This function only works when this process is the active process
+ * (e.g. once it is running a child process, it can no longer determine
  * which console window is its own.)
  */
 static BOOL CALLBACK EnumttyWindow(HWND wnd, LPARAM retwnd)
 {
     char tmp[8];
-    if (GetClassName(wnd, tmp, sizeof(tmp)) && !strcmp(tmp, "tty")) 
+    if (GetClassName(wnd, tmp, sizeof(tmp)) && !strcmp(tmp, "tty"))
     {
         DWORD wndproc, thisproc = GetCurrentProcessId();
         GetWindowThreadProcessId(wnd, &wndproc);
@@ -534,19 +534,19 @@ static BOOL CALLBACK EnumttyWindow(HWND wnd, LPARAM retwnd)
  * to origwndprop property atom we set against the window when we
  * injected this subclass.  This trick did not work with simply a hook.
  */
-static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
+static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
                                 WPARAM wParam, LPARAM lParam)
 {
     WNDPROC origproc = (WNDPROC) GetProp(hwnd, origwndprop);
     if (!origproc)
         return 0;
 
-    if (msg == WM_NCDESTROY 
+    if (msg == WM_NCDESTROY
         || (msg == hookwndmsg && !LOWORD(wParam) && (HWND)lParam == hwnd))
     {
         if (is_subclassed) {
 #ifdef DBG
-            DbgPrintf("W proc %08x hwnd:%08x Subclass removed\r\n", 
+            DbgPrintf("W proc %08x hwnd:%08x Subclass removed\r\n",
                       GetCurrentProcessId(), hwnd);
 #endif
             if (is_service)
@@ -560,13 +560,13 @@ static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
             //hmodLock = NULL;
         }
     }
-    else if (msg == WM_CLOSE || msg == WM_ENDSESSION 
+    else if (msg == WM_CLOSE || msg == WM_ENDSESSION
                              || msg == WM_QUERYENDSESSION)
     {
         HWND child = (HWND)GetProp(hwnd, hookwndprop);
         if (child) {
 #ifdef DBG
-            DbgPrintf("W proc %08x hwnd:%08x forwarded msg:%d\r\n", 
+            DbgPrintf("W proc %08x hwnd:%08x forwarded msg:%d\r\n",
                       GetCurrentProcessId(), hwnd, msg);
 #endif
             return SendMessage(child, msg, wParam, lParam);
@@ -586,18 +586,18 @@ static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg,
  */
 int HookProc(int hc, HWND *hwnd, UINT *msg, WPARAM *wParam, LPARAM *lParam)
 {
-    if (is_tty == -1 && *hwnd) 
+    if (is_tty == -1 && *hwnd)
     {
         char ttybuf[8];
         HWND htty;
         hwtty = *hwnd;
         while (htty = GetParent(hwtty))
             hwtty = htty;
-        is_tty = (GetClassName(hwtty, ttybuf, sizeof(ttybuf)) 
+        is_tty = (GetClassName(hwtty, ttybuf, sizeof(ttybuf))
                   && !strcmp(ttybuf, "tty"));
 #ifdef DBG
         if (is_tty)
-            DbgPrintf("H proc %08x tracking hwnd %08x\r\n", 
+            DbgPrintf("H proc %08x tracking hwnd %08x\r\n",
                       GetCurrentProcessId(), hwtty);
 #endif
     }
@@ -607,12 +607,12 @@ int HookProc(int hc, HWND *hwnd, UINT *msg, WPARAM *wParam, LPARAM *lParam)
         WNDPROC origproc = (WNDPROC)GetWindowLong(hwtty, GWL_WNDPROC);
         //char myname[MAX_PATH];
         //if (GetModuleFileName(hmodThis, myname, sizeof(myname)))
-        //    hmodLock = LoadLibrary(myname);        
+        //    hmodLock = LoadLibrary(myname);
         SetProp(hwtty, origwndprop, origproc);
         SetWindowLong(hwtty, GWL_WNDPROC, (LONG)WndProc);
         is_subclassed = TRUE;
 #ifdef DBG
-        DbgPrintf("H proc %08x hwnd:%08x Subclassed\r\n", 
+        DbgPrintf("H proc %08x hwnd:%08x Subclassed\r\n",
                   GetCurrentProcessId(), hwtty);
 #endif
         if (LOWORD(*wParam) == 2)
@@ -626,7 +626,7 @@ int HookProc(int hc, HWND *hwnd, UINT *msg, WPARAM *wParam, LPARAM *lParam)
 /*
  * PostMessage Hook:
  */
-LRESULT __declspec(dllexport) CALLBACK GetMsgProc(INT hc, WPARAM wParam, 
+LRESULT __declspec(dllexport) CALLBACK GetMsgProc(INT hc, WPARAM wParam,
                                                   LPARAM lParam)
 {
     PMSG pmsg;
@@ -634,12 +634,12 @@ LRESULT __declspec(dllexport) CALLBACK GetMsgProc(INT hc, WPARAM wParam,
     pmsg = (PMSG)lParam;
 
     if (pmsg) {
-        int rv = HookProc(hc, &pmsg->hwnd, &pmsg->message, 
+        int rv = HookProc(hc, &pmsg->hwnd, &pmsg->message,
                           &pmsg->wParam, &pmsg->lParam);
         if (rv != -1)
             return rv;
     }
-    /* 
+    /*
      * CallNextHookEx apparently ignores the hhook argument, so pass NULL
      */
     return CallNextHookEx(NULL, hc, wParam, lParam);
@@ -649,18 +649,18 @@ LRESULT __declspec(dllexport) CALLBACK GetMsgProc(INT hc, WPARAM wParam,
 /*
  * SendMessage Hook:
  */
-LRESULT __declspec(dllexport) CALLBACK CallWndProc(INT hc, WPARAM wParam, 
+LRESULT __declspec(dllexport) CALLBACK CallWndProc(INT hc, WPARAM wParam,
                                                    LPARAM lParam)
 {
     PCWPSTRUCT pcwps = (PCWPSTRUCT)lParam;
-    
+
     if (pcwps) {
-        int rv = HookProc(hc, &pcwps->hwnd, &pcwps->message, 
+        int rv = HookProc(hc, &pcwps->hwnd, &pcwps->message,
                           &pcwps->wParam, &pcwps->lParam);
         if (rv != -1)
             return rv;
     }
-    /* 
+    /*
      * CallNextHookEx apparently ignores the hhook argument, so pass NULL
      */
     return CallNextHookEx(NULL, hc, wParam, lParam);
diff --git a/server/mpm/winnt/child.c b/server/mpm/winnt/child.c
index 96942d1..abb2bb7 100644
--- a/server/mpm/winnt/child.c
+++ b/server/mpm/winnt/child.c
@@ -16,12 +16,12 @@
 
 #ifdef WIN32
 
-#define CORE_PRIVATE 
-#include "httpd.h" 
-#include "http_main.h" 
-#include "http_log.h" 
-#include "http_config.h"	/* for read_config */ 
-#include "http_core.h"		/* for get_remote_host */ 
+#define CORE_PRIVATE
+#include "httpd.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "http_config.h"	/* for read_config */
+#include "http_core.h"		/* for get_remote_host */
 #include "http_connection.h"
 #include "apr_portable.h"
 #include "apr_thread_proc.h"
@@ -74,8 +74,8 @@ void mpm_recycle_completion_context(PCOMP_CONTEXT context)
     /* Recycle the completion context.
      * - clear the ptrans pool
      * - put the context on the queue to be consumed by the accept thread
-     * Note: 
-     * context->accept_socket may be in a disconnected but reusable 
+     * Note:
+     * context->accept_socket may be in a disconnected but reusable
      * state so -don't- close it.
      */
     if (context) {
@@ -111,11 +111,11 @@ PCOMP_CONTEXT mpm_get_completion_context(void)
             ResetEvent(qwait_event);
         }
         apr_thread_mutex_unlock(qlock);
-  
+
         if (!context) {
             /* We failed to grab a context off the queue, consider allocating
-             * a new one out of the child pool. There may be up to 
-             * (ap_threads_per_child + num_listeners) contexts in the system 
+             * a new one out of the child pool. There may be up to
+             * (ap_threads_per_child + num_listeners) contexts in the system
              * at once.
              */
             if (num_completion_contexts >= max_num_completion_contexts) {
@@ -148,7 +148,7 @@ PCOMP_CONTEXT mpm_get_completion_context(void)
 
                 apr_thread_mutex_lock(child_lock);
                 context = (PCOMP_CONTEXT) apr_pcalloc(pchild, sizeof(COMP_CONTEXT));
-  
+
                 context->Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
                 if (context->Overlapped.hEvent == NULL) {
                     /* Hopefully this is a temporary condition ... */
@@ -158,7 +158,7 @@ PCOMP_CONTEXT mpm_get_completion_context(void)
                     apr_thread_mutex_unlock(child_lock);
                     return NULL;
                 }
- 
+
                 /* Create the tranaction pool */
                 apr_allocator_create(&allocator);
                 apr_allocator_max_free_set(allocator, ap_max_mem_free);
@@ -173,10 +173,10 @@ PCOMP_CONTEXT mpm_get_completion_context(void)
                 }
                 apr_allocator_owner_set(allocator, context->ptrans);
                 apr_pool_tag(context->ptrans, "transaction");
- 
+
                 context->accept_socket = INVALID_SOCKET;
                 context->ba = apr_bucket_alloc_create(pchild);
-                apr_atomic_inc32(&num_completion_contexts); 
+                apr_atomic_inc32(&num_completion_contexts);
 
                 apr_thread_mutex_unlock(child_lock);
                 break;
@@ -190,7 +190,7 @@ PCOMP_CONTEXT mpm_get_completion_context(void)
     return context;
 }
 
-apr_status_t mpm_post_completion_context(PCOMP_CONTEXT context, 
+apr_status_t mpm_post_completion_context(PCOMP_CONTEXT context,
                                          io_state_e state)
 {
     LPOVERLAPPED pOverlapped;
@@ -206,7 +206,7 @@ apr_status_t mpm_post_completion_context(PCOMP_CONTEXT context,
 
 /*
  * find_ready_listener()
- * Only used by Win9* and should go away when the win9*_accept() function is 
+ * Only used by Win9* and should go away when the win9*_accept() function is
  * reimplemented using apr_poll().
  */
 static ap_listen_rec *head_listener;
@@ -236,19 +236,19 @@ static APR_INLINE ap_listen_rec *find_ready_listener(fd_set * main_fds)
 
 
 /* Windows 9x specific code...
- * Accept processing for on Windows 95/98 uses a producer/consumer queue 
- * model. A single thread accepts connections and queues the accepted socket 
+ * Accept processing for on Windows 95/98 uses a producer/consumer queue
+ * model. A single thread accepts connections and queues the accepted socket
  * to the accept queue for consumption by a pool of worker threads.
  *
  * win9x_accept()
- *    The accept threads runs this function, which accepts connections off 
+ *    The accept threads runs this function, which accepts connections off
  *    the network and calls add_job() to queue jobs to the accept_queue.
  * add_job()/remove_job()
- *    Add or remove an accepted socket from the list of sockets 
+ *    Add or remove an accepted socket from the list of sockets
  *    connected to clients. allowed_globals.jobmutex protects
  *    against multiple concurrent access to the linked list of jobs.
  * win9x_get_connection()
- *    Calls remove_job() to pull a job from the accept queue. All the worker 
+ *    Calls remove_job() to pull a job from the accept queue. All the worker
  *    threads block on remove_job.
  */
 
@@ -276,7 +276,7 @@ static void add_job(SOCKET sock)
 
     new_job = (joblist *) malloc(sizeof(joblist));
     if (new_job == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "Ouch!  Out of memory in add_job()!");
         return;
     }
@@ -340,7 +340,7 @@ static unsigned int __stdcall win9x_accept(void * dummy)
     struct sockaddr_in sa_client;
 #endif
 
-    /* Setup the listeners 
+    /* Setup the listeners
      * ToDo: Use apr_poll()
      */
     FD_ZERO(&listenfds);
@@ -364,7 +364,7 @@ static unsigned int __stdcall win9x_accept(void * dummy)
         rc = select(0, &main_fds, NULL, NULL, &tv);
 
         if (rc == 0 || (rc == SOCKET_ERROR && APR_STATUS_IS_EINTR(apr_get_netos_error()))) {
-            count_select_errors = 0;    /* reset count of errors */            
+            count_select_errors = 0;    /* reset count of errors */
             continue;
         }
         else if (rc == SOCKET_ERROR) {
@@ -372,7 +372,7 @@ static unsigned int __stdcall win9x_accept(void * dummy)
              * select errors. This count is used to ensure we don't go into
              * a busy loop of continuous errors.
              */
-            ap_log_error(APLOG_MARK, APLOG_INFO, apr_get_netos_error(), ap_server_conf, 
+            ap_log_error(APLOG_MARK, APLOG_INFO, apr_get_netos_error(), ap_server_conf,
                          "select failed with error %d", apr_get_netos_error());
             count_select_errors++;
             if (count_select_errors > MAX_SELECT_ERRORS) {
@@ -435,18 +435,18 @@ static PCOMP_CONTEXT win9x_get_connection(PCOMP_CONTEXT context)
         context->ba = apr_bucket_alloc_create(pchild);
         apr_thread_mutex_unlock(child_lock);
     }
-    
+
     while (1) {
-        apr_pool_clear(context->ptrans);        
+        apr_pool_clear(context->ptrans);
         context->accept_socket = remove_job();
         if (context->accept_socket == INVALID_SOCKET) {
             return NULL;
         }
         len = salen;
         context->sa_server = apr_palloc(context->ptrans, len);
-        if (getsockname(context->accept_socket, 
+        if (getsockname(context->accept_socket,
                         context->sa_server, &len)== SOCKET_ERROR) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(), ap_server_conf, 
+            ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(), ap_server_conf,
                          "getsockname failed");
             continue;
         }
@@ -454,7 +454,7 @@ static PCOMP_CONTEXT win9x_get_connection(PCOMP_CONTEXT context)
         context->sa_client = apr_palloc(context->ptrans, len);
         if ((getpeername(context->accept_socket,
                          context->sa_client, &len)) == SOCKET_ERROR) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(), ap_server_conf, 
+            ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(), ap_server_conf,
                          "getpeername failed");
             memset(&context->sa_client, '\0', sizeof(context->sa_client));
         }
@@ -471,21 +471,21 @@ static PCOMP_CONTEXT win9x_get_connection(PCOMP_CONTEXT context)
 
 
 /* Windows NT/2000 specific code...
- * Accept processing for on Windows NT uses a producer/consumer queue 
+ * Accept processing for on Windows NT uses a producer/consumer queue
  * model. An accept thread accepts connections off the network then issues
- * PostQueuedCompletionStatus() to awake a thread blocked on the ThreadDispatch 
+ * PostQueuedCompletionStatus() to awake a thread blocked on the ThreadDispatch
  * IOCompletionPort.
  *
  * winnt_accept()
- *    One or more accept threads run in this function, each of which accepts 
+ *    One or more accept threads run in this function, each of which accepts
  *    connections off the network and calls PostQueuedCompletionStatus() to
  *    queue an io completion packet to the ThreadDispatch IOCompletionPort.
  * winnt_get_connection()
- *    Worker threads block on the ThreadDispatch IOCompletionPort awaiting 
+ *    Worker threads block on the ThreadDispatch IOCompletionPort awaiting
  *    connections to service.
  */
 #define MAX_ACCEPTEX_ERR_COUNT 100
-static unsigned int __stdcall winnt_accept(void *lr_) 
+static unsigned int __stdcall winnt_accept(void *lr_)
 {
     ap_listen_rec *lr = (ap_listen_rec *)lr_;
     apr_os_sock_info_t sockinfo;
@@ -501,7 +501,7 @@ static unsigned int __stdcall winnt_accept(void *lr_)
     apr_os_sock_get(&nlsd, lr->sd);
 
 #if APR_HAVE_IPV6
-    if (getsockname(nlsd, (struct sockaddr *)&ss_listen, &namelen) == SOCKET_ERROR) { 
+    if (getsockname(nlsd, (struct sockaddr *)&ss_listen, &namelen) == SOCKET_ERROR) {
         ap_log_error(APLOG_MARK,APLOG_ERR, apr_get_netos_error(), ap_server_conf,
                     "winnt_accept: getsockname error on listening socket, is IPv6 available?");
         return 1;
@@ -526,7 +526,7 @@ static unsigned int __stdcall winnt_accept(void *lr_)
             context->accept_socket = socket(ss_listen.ss_family, SOCK_STREAM, IPPROTO_TCP);
             context->socket_family = ss_listen.ss_family;
         }
-        else if (context->socket_family != ss_listen.ss_family) { 
+        else if (context->socket_family != ss_listen.ss_family) {
             closesocket(context->accept_socket);
             context->accept_socket = socket(ss_listen.ss_family, SOCK_STREAM, IPPROTO_TCP);
             context->socket_family = ss_listen.ss_family;
@@ -552,13 +552,13 @@ static unsigned int __stdcall winnt_accept(void *lr_)
             }
         }
 #endif
-        /* AcceptEx on the completion context. The completion context will be 
-         * signaled when a connection is accepted. 
+        /* AcceptEx on the completion context. The completion context will be
+         * signaled when a connection is accepted.
          */
         if (!AcceptEx(nlsd, context->accept_socket,
                       context->buff,
                       0,
-                      PADDED_ADDR_SIZE, 
+                      PADDED_ADDR_SIZE,
                       PADDED_ADDR_SIZE,
                       &BytesRead,
                       &context->Overlapped)) {
@@ -581,13 +581,13 @@ static unsigned int __stdcall winnt_accept(void *lr_)
                                  "Possible causes: dynamic address renewal, or incompatible VPN or firewall software. "
                                  "Try using the Win32DisableAcceptEx directive.", my_pid);
                     err_count = 0;
-                }          
+                }
                 continue;
             }
             else if ((rv != APR_FROM_OS_ERROR(ERROR_IO_PENDING)) &&
                      (rv != APR_FROM_OS_ERROR(WSA_IO_PENDING))) {
                 ++err_count;
-                if (err_count > MAX_ACCEPTEX_ERR_COUNT) { 
+                if (err_count > MAX_ACCEPTEX_ERR_COUNT) {
                     ap_log_error(APLOG_MARK,APLOG_ERR, rv, ap_server_conf,
                                  "Child %d: Encountered too many errors accepting client connections. "
                                  "Possible causes: Unknown. "
@@ -598,9 +598,9 @@ static unsigned int __stdcall winnt_accept(void *lr_)
                 context->accept_socket = INVALID_SOCKET;
                 continue;
             }
-            err_count = 0;  
+            err_count = 0;
 
-            /* Wait for pending i/o. 
+            /* Wait for pending i/o.
              * Wake up once per second to check for shutdown .
              * XXX: We should be waiting on exit_event instead of polling
              */
@@ -611,10 +611,10 @@ static unsigned int __stdcall winnt_accept(void *lr_)
                         /* socket already closed */
                         break;
                     }
-                    if (!GetOverlappedResult((HANDLE)context->accept_socket, 
-                                             &context->Overlapped, 
+                    if (!GetOverlappedResult((HANDLE)context->accept_socket,
+                                             &context->Overlapped,
                                              &BytesRead, FALSE)) {
-                        ap_log_error(APLOG_MARK, APLOG_WARNING, 
+                        ap_log_error(APLOG_MARK, APLOG_WARNING,
                                      apr_get_os_error(), ap_server_conf,
                              "winnt_accept: Asynchronous AcceptEx failed.");
                         closesocket(context->accept_socket);
@@ -633,9 +633,9 @@ static unsigned int __stdcall winnt_accept(void *lr_)
                 continue;
             }
         }
-        err_count = 0;  
-        /* Inherit the listen socket settings. Required for 
-         * shutdown() to work 
+        err_count = 0;
+        /* Inherit the listen socket settings. Required for
+         * shutdown() to work
          */
         if (setsockopt(context->accept_socket, SOL_SOCKET,
                        SO_UPDATE_ACCEPT_CONTEXT, (char *)&nlsd,
@@ -729,7 +729,7 @@ static PCOMP_CONTEXT winnt_get_connection(PCOMP_CONTEXT context)
 
 /*
  * worker_main()
- * Main entry point for the worker threads. Worker threads block in 
+ * Main entry point for the worker threads. Worker threads block in
  * win*_get_connection() awaiting a connection to service.
  */
 static unsigned int __stdcall worker_main(void *thread_num_val)
@@ -752,7 +752,7 @@ static unsigned int __stdcall worker_main(void *thread_num_val)
         else {
             context = win9x_get_connection(context);
         }
-        
+
         if (!context) {
             /* Time for the thread to exit */
             break;
@@ -773,17 +773,17 @@ static unsigned int __stdcall worker_main(void *thread_num_val)
 
         if (c) {
             ap_process_connection(c, context->sock);
-            apr_socket_opt_get(context->sock, APR_SO_DISCONNECTED, 
+            apr_socket_opt_get(context->sock, APR_SO_DISCONNECTED,
                                &disconnected);
             if (!disconnected) {
                 context->accept_socket = INVALID_SOCKET;
                 ap_lingering_close(c);
             }
             else if (!use_acceptex) {
-                /* If the socket is disconnected but we are not using acceptex, 
+                /* If the socket is disconnected but we are not using acceptex,
                  * we cannot reuse the socket. Disconnected sockets are removed
                  * from the apr_socket_t struct by apr_sendfile() to prevent the
-                 * socket descriptor from being inadvertently closed by a call 
+                 * socket descriptor from being inadvertently closed by a call
                  * to apr_socket_close(), so close it directly.
                  */
                 closesocket(context->accept_socket);
@@ -796,7 +796,7 @@ static unsigned int __stdcall worker_main(void *thread_num_val)
         }
     }
 
-    ap_update_child_status_from_indexes(0, thread_num, SERVER_DEAD, 
+    ap_update_child_status_from_indexes(0, thread_num, SERVER_DEAD,
                                         (request_rec *) NULL);
 
     return 0;
@@ -815,8 +815,8 @@ static void cleanup_thread(HANDLE *handles, int *thread_cnt, int thread_to_clean
 
 
 /*
- * child_main() 
- * Entry point for the main control thread for the child process. 
+ * child_main()
+ * Entry point for the main control thread for the child process.
  * This thread creates the accept thread, worker threads and
  * monitors the child process for maintenance and shutdown
  * events.
@@ -829,7 +829,7 @@ static void create_listener_thread()
         _beginthreadex(NULL, 0, win9x_accept,
                        NULL, 0, &tid);
     } else {
-        /* Start an accept thread per listener 
+        /* Start an accept thread per listener
          * XXX: Why would we have a NULL sd in our listeners?
          */
         ap_listen_rec *lr;
@@ -838,7 +838,7 @@ static void create_listener_thread()
          * (ap_threads_per_child + num_listeners). We need the additional
          * completion contexts to prevent server hangs when ThreadsPerChild
          * is configured to something less than or equal to the number
-         * of listeners. This is not a usual case, but people have 
+         * of listeners. This is not a usual case, but people have
          * encountered it.
          * */
         for (lr = ap_listeners; lr ; lr = lr->next) {
@@ -889,7 +889,7 @@ void child_main(apr_pool_t *pconf)
     child_events[1] = max_requests_per_child_event;
 
     allowed_globals.jobsemaphore = CreateSemaphore(NULL, 0, 1000000, NULL);
-    apr_thread_mutex_create(&allowed_globals.jobmutex, 
+    apr_thread_mutex_create(&allowed_globals.jobmutex,
                             APR_THREAD_MUTEX_DEFAULT, pchild);
 
     /*
@@ -903,7 +903,7 @@ void child_main(apr_pool_t *pconf)
                      "Child %d: Failed to acquire the start_mutex. Process will exit.", my_pid);
         exit(APEXIT_CHILDINIT);
     }
-    ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf, 
+    ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
                  "Child %d: Acquired the start mutex.", my_pid);
 
     /*
@@ -925,10 +925,10 @@ void child_main(apr_pool_t *pconf)
         }
     }
 
-    /* 
+    /*
      * Create the pool of worker threads
      */
-    ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf, 
+    ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
                  "Child %d: Starting %d worker threads.", my_pid, ap_threads_per_child);
     child_handles = (HANDLE) apr_pcalloc(pchild, ap_threads_per_child * sizeof(HANDLE));
     apr_thread_mutex_create(&child_lock, APR_THREAD_MUTEX_DEFAULT, pchild);
@@ -946,13 +946,13 @@ void child_main(apr_pool_t *pconf)
             if (child_handles[i] == 0) {
                 ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
                              "Child %d: _beginthreadex failed. Unable to create all worker threads. "
-                             "Created %d of the %d threads requested with the ThreadsPerChild configuration directive.", 
+                             "Created %d of the %d threads requested with the ThreadsPerChild configuration directive.",
                              my_pid, threads_created, ap_threads_per_child);
                 ap_signal_parent(SIGNAL_PARENT_SHUTDOWN);
                 goto shutdown;
             }
             threads_created++;
-            /* Save the score board index in ht keyed to the thread handle. We need this 
+            /* Save the score board index in ht keyed to the thread handle. We need this
              * when cleaning up threads down below...
              */
             apr_thread_mutex_lock(child_lock);
@@ -979,11 +979,11 @@ void child_main(apr_pool_t *pconf)
     }
 
     /* Wait for one of three events:
-     * exit_event: 
-     *    The exit_event is signaled by the parent process to notify 
+     * exit_event:
+     *    The exit_event is signaled by the parent process to notify
      *    the child that it is time to exit.
      *
-     * max_requests_per_child_event: 
+     * max_requests_per_child_event:
      *    This event is signaled by the worker threads to indicate that
      *    the process has handled MaxRequestsPerChild connections.
      *
@@ -998,8 +998,8 @@ void child_main(apr_pool_t *pconf)
      *      named well, it's more like a_p_o_c_died.)
      *
      * XXX: however - if we get a_p_o_c handle inheritance working, and
-     *      the parent process creates other children and passes the pipes 
-     *      to our worker processes, then we have no business doing such 
+     *      the parent process creates other children and passes the pipes
+     *      to our worker processes, then we have no business doing such
      *      things in the child_main loop, but should happen in master_main.
      */
     while (1) {
@@ -1012,7 +1012,7 @@ void child_main(apr_pool_t *pconf)
         if (rv == WAIT_TIMEOUT) {
             apr_proc_other_child_refresh_all(APR_OC_REASON_RUNNING);
         }
-        else 
+        else
 #endif
             if (rv == WAIT_FAILED) {
             /* Something serious is wrong */
@@ -1039,14 +1039,14 @@ void child_main(apr_pool_t *pconf)
         }
     }
 
-    /* 
-     * Time to shutdown the child process 
+    /*
+     * Time to shutdown the child process
      */
 
  shutdown:
 
     winnt_mpm_state = AP_MPMQ_STOPPING;
-    /* Setting is_graceful will cause threads handling keep-alive connections 
+    /* Setting is_graceful will cause threads handling keep-alive connections
      * to close the connection after handling the current request.
      */
     is_graceful = 1;
@@ -1059,7 +1059,7 @@ void child_main(apr_pool_t *pconf)
         apr_socket_close(lr->sd);
     }
 
-    /* Shutdown listener threads and pending AcceptEx socksts 
+    /* Shutdown listener threads and pending AcceptEx socksts
      * but allow the worker threads to continue consuming from
      * the queue of accepted connections.
      */
@@ -1071,15 +1071,15 @@ void child_main(apr_pool_t *pconf)
     workers_may_exit = 1;
 
     /* Release the start_mutex to let the new process (in the restart
-     * scenario) a chance to begin accepting and servicing requests 
+     * scenario) a chance to begin accepting and servicing requests
      */
     rv = apr_proc_mutex_unlock(start_mutex);
     if (rv == APR_SUCCESS) {
-        ap_log_error(APLOG_MARK,APLOG_NOTICE, rv, ap_server_conf, 
+        ap_log_error(APLOG_MARK,APLOG_NOTICE, rv, ap_server_conf,
                      "Child %d: Released the start mutex", my_pid);
     }
     else {
-        ap_log_error(APLOG_MARK,APLOG_ERR, rv, ap_server_conf, 
+        ap_log_error(APLOG_MARK,APLOG_ERR, rv, ap_server_conf,
                      "Child %d: Failure releasing the start mutex", my_pid);
     }
 
@@ -1092,7 +1092,7 @@ void child_main(apr_pool_t *pconf)
     else { /* Windows NT/2000 */
         /* Post worker threads blocked on the ThreadDispatch IOCompletion port */
         while (g_blocked_threads > 0) {
-            ap_log_error(APLOG_MARK,APLOG_INFO, APR_SUCCESS, ap_server_conf, 
+            ap_log_error(APLOG_MARK,APLOG_INFO, APR_SUCCESS, ap_server_conf,
                          "Child %d: %d threads blocked on the completion port", my_pid, g_blocked_threads);
             for (i=g_blocked_threads; i > 0; i--) {
                 PostQueuedCompletionStatus(ThreadDispatchIOCP, 0, IOCP_SHUTDOWN, NULL);
@@ -1110,7 +1110,7 @@ void child_main(apr_pool_t *pconf)
     }
 
     /* Give busy worker threads a chance to service their connections */
-    ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf, 
+    ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
                  "Child %d: Waiting for %d worker threads to exit.", my_pid, threads_created);
     end_time = time(NULL) + 180;
     while (threads_created) {
@@ -1126,7 +1126,7 @@ void child_main(apr_pool_t *pconf)
 
     /* Kill remaining threads off the hard way */
     if (threads_created) {
-        ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf, 
+        ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
                      "Child %d: Terminating %d threads that failed to exit.",
                      my_pid, threads_created);
     }
@@ -1136,9 +1136,9 @@ void child_main(apr_pool_t *pconf)
         CloseHandle(child_handles[i]);
         /* Reset the scoreboard entry for the thread we just whacked */
         score_idx = apr_hash_get(ht, &child_handles[i], sizeof(HANDLE));
-        ap_update_child_status_from_indexes(0, *score_idx, SERVER_DEAD, NULL);        
+        ap_update_child_status_from_indexes(0, *score_idx, SERVER_DEAD, NULL);
     }
-    ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf, 
+    ap_log_error(APLOG_MARK,APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
                  "Child %d: All worker threads have exited.", my_pid);
 
     CloseHandle(allowed_globals.jobsemaphore);
diff --git a/server/mpm/winnt/mpm_winnt.c b/server/mpm/winnt/mpm_winnt.c
index a52ada8..3c8bc9e 100644
--- a/server/mpm/winnt/mpm_winnt.c
+++ b/server/mpm/winnt/mpm_winnt.c
@@ -16,12 +16,12 @@
 
 #ifdef WIN32
 
-#define CORE_PRIVATE 
-#include "httpd.h" 
-#include "http_main.h" 
-#include "http_log.h" 
-#include "http_config.h"	/* for read_config */ 
-#include "http_core.h"		/* for get_remote_host */ 
+#define CORE_PRIVATE
+#include "httpd.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "http_config.h"	/* for read_config */
+#include "http_core.h"		/* for get_remote_host */
 #include "http_connection.h"
 #include "apr_portable.h"
 #include "apr_thread_proc.h"
@@ -71,7 +71,7 @@ int winnt_mpm_state = AP_MPMQ_STARTING;
 ap_generation_t volatile ap_my_generation=0;
 
 
-/* shared by service.c as global, although 
+/* shared by service.c as global, although
  * perhaps it should be private.
  */
 apr_pool_t *pconf;
@@ -85,7 +85,7 @@ void child_main(apr_pool_t *pconf);
  * so they ultimately should not be shared with child.c
  */
 extern apr_proc_mutex_t *start_mutex;
-extern HANDLE exit_event;  
+extern HANDLE exit_event;
 
 
 /* Stub functions until this MPM supports the connection status API */
@@ -107,11 +107,11 @@ AP_DECLARE(apr_array_header_t *) ap_get_status_table(apr_pool_t *p)
     return NULL;
 }
 
-/* 
- * Command processors 
+/*
+ * Command processors
  */
 
-static const char *set_threads_per_child (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_threads_per_child (cmd_parms *cmd, void *dummy, char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -120,28 +120,28 @@ static const char *set_threads_per_child (cmd_parms *cmd, void *dummy, char *arg
 
     ap_threads_per_child = atoi(arg);
     if (ap_threads_per_child > thread_limit) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
-                     "value of %d threads,", ap_threads_per_child, 
+                     "value of %d threads,", ap_threads_per_child,
                      thread_limit);
         ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      " lowering ThreadsPerChild to %d. To increase, please"
                      " see the", thread_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      " ThreadLimit directive.");
         ap_threads_per_child = thread_limit;
     }
     else if (ap_threads_per_child < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ThreadsPerChild > 0, setting to 1");
         ap_threads_per_child = 1;
     }
     return NULL;
 }
-static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     int tmp_thread_limit;
-    
+
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -161,23 +161,23 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
         return NULL;
     }
     thread_limit = tmp_thread_limit;
-    
+
     if (thread_limit > MAX_THREAD_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: ThreadLimit of %d exceeds compile time limit "
                     "of %d threads,", thread_limit, MAX_THREAD_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering ThreadLimit to %d.", MAX_THREAD_LIMIT);
        thread_limit = MAX_THREAD_LIMIT;
-    } 
+    }
     else if (thread_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ThreadLimit > 0, setting to 1");
         thread_limit = 1;
     }
     return NULL;
 }
-static const char *set_disable_acceptex(cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_disable_acceptex(cmd_parms *cmd, void *dummy, char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -185,7 +185,7 @@ static const char *set_disable_acceptex(cmd_parms *cmd, void *dummy, char *arg)
     }
     if (use_acceptex) {
         use_acceptex = 0;
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, NULL,
                      "Disabled use of AcceptEx() WinSock2 API");
     }
     return NULL;
@@ -229,24 +229,24 @@ AP_INIT_NO_ARGS("Win32DisableAcceptEx", set_disable_acceptex, NULL, RSRC_CONF,
  * It can be called by any child or parent process, since it does not
  * rely on global variables.
  *
- * On entry, type gives the event to signal. 0 means shutdown, 1 means 
+ * On entry, type gives the event to signal. 0 means shutdown, 1 means
  * graceful restart.
  */
 /*
- * Initialise the signal names, in the global variables signal_name_prefix, 
+ * Initialise the signal names, in the global variables signal_name_prefix,
  * signal_restart_name and signal_shutdown_name.
  */
 #define MAX_SIGNAL_NAME 30  /* Long enough for apPID_shutdown, where PID is an int */
 char signal_name_prefix[MAX_SIGNAL_NAME];
-char signal_restart_name[MAX_SIGNAL_NAME]; 
+char signal_restart_name[MAX_SIGNAL_NAME];
 char signal_shutdown_name[MAX_SIGNAL_NAME];
 void setup_signal_names(char *prefix)
 {
-    apr_snprintf(signal_name_prefix, sizeof(signal_name_prefix), prefix);    
-    apr_snprintf(signal_shutdown_name, sizeof(signal_shutdown_name), 
-        "%s_shutdown", signal_name_prefix);    
-    apr_snprintf(signal_restart_name, sizeof(signal_restart_name), 
-        "%s_restart", signal_name_prefix);    
+    apr_snprintf(signal_name_prefix, sizeof(signal_name_prefix), prefix);
+    apr_snprintf(signal_shutdown_name, sizeof(signal_shutdown_name),
+        "%s_shutdown", signal_name_prefix);
+    apr_snprintf(signal_restart_name, sizeof(signal_restart_name),
+        "%s_restart", signal_name_prefix);
 }
 
 int volatile is_graceful = 0;
@@ -260,20 +260,20 @@ AP_DECLARE(void) ap_signal_parent(ap_signal_parent_e type)
 {
     HANDLE e;
     char *signal_name;
-    
+
     if (parent_pid == my_pid) {
         switch(type) {
-           case SIGNAL_PARENT_SHUTDOWN: 
+           case SIGNAL_PARENT_SHUTDOWN:
            {
-               SetEvent(shutdown_event); 
+               SetEvent(shutdown_event);
                break;
            }
            /* This MPM supports only graceful restarts right now */
-           case SIGNAL_PARENT_RESTART: 
+           case SIGNAL_PARENT_RESTART:
            case SIGNAL_PARENT_RESTART_GRACEFUL:
            {
                is_graceful = 1;
-               SetEvent(restart_event); 
+               SetEvent(restart_event);
                break;
            }
         }
@@ -281,20 +281,20 @@ AP_DECLARE(void) ap_signal_parent(ap_signal_parent_e type)
     }
 
     switch(type) {
-       case SIGNAL_PARENT_SHUTDOWN: 
+       case SIGNAL_PARENT_SHUTDOWN:
        {
-           signal_name = signal_shutdown_name; 
+           signal_name = signal_shutdown_name;
            break;
        }
        /* This MPM supports only graceful restarts right now */
-       case SIGNAL_PARENT_RESTART: 
+       case SIGNAL_PARENT_RESTART:
        case SIGNAL_PARENT_RESTART_GRACEFUL:
        {
-           signal_name = signal_restart_name;     
+           signal_name = signal_restart_name;
            is_graceful = 1;
            break;
        }
-       default: 
+       default:
            return;
     }
 
@@ -337,7 +337,7 @@ void get_handles_from_parent(server_rec *s, HANDLE *child_exit_event,
     DWORD BytesRead;
     void *sb_shared;
     apr_status_t rv;
-    
+
     pipe = GetStdHandle(STD_INPUT_HANDLE);
     if (!ReadFile(pipe, &ready_event, sizeof(HANDLE),
                   &BytesRead, (LPOVERLAPPED) NULL)
@@ -381,7 +381,7 @@ void get_handles_from_parent(server_rec *s, HANDLE *child_exit_event,
         exit(APEXIT_CHILDINIT);
     }
     *scoreboard_shm = NULL;
-    if ((rv = apr_os_shm_put(scoreboard_shm, &hScore, s->process->pool)) 
+    if ((rv = apr_os_shm_put(scoreboard_shm, &hScore, s->process->pool))
             != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
                      "Child %d: Unable to access the scoreboard from the parent", my_pid);
@@ -390,7 +390,7 @@ void get_handles_from_parent(server_rec *s, HANDLE *child_exit_event,
 
     rv = ap_reopen_scoreboard(s->process->pool, scoreboard_shm, 1);
     if (rv || !(sb_shared = apr_shm_baseaddr_get(*scoreboard_shm))) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                      "Child %d: Unable to reopen the scoreboard from the parent", my_pid);
         exit(APEXIT_CHILDINIT);
     }
@@ -404,12 +404,12 @@ void get_handles_from_parent(server_rec *s, HANDLE *child_exit_event,
 }
 
 
-static int send_handles_to_child(apr_pool_t *p, 
+static int send_handles_to_child(apr_pool_t *p,
                                  HANDLE child_ready_event,
-                                 HANDLE child_exit_event, 
+                                 HANDLE child_exit_event,
                                  apr_proc_mutex_t *child_start_mutex,
                                  apr_shm_t *scoreboard_shm,
-                                 HANDLE hProcess, 
+                                 HANDLE hProcess,
                                  apr_file_t *child_in)
 {
     apr_status_t rv;
@@ -484,7 +484,7 @@ static int send_handles_to_child(apr_pool_t *p,
 }
 
 
-/* 
+/*
  * get_listeners_from_parent()
  * The listen sockets are opened in the parent. This function, which runs
  * exclusively in the child process, receives them from the parent and
@@ -514,7 +514,7 @@ void get_listeners_from_parent(server_rec *s)
     pipe = GetStdHandle(STD_INPUT_HANDLE);
 
     for (lr = ap_listeners; lr; lr = lr->next, ++lcnt) {
-        if (!ReadFile(pipe, &WSAProtocolInfo, sizeof(WSAPROTOCOL_INFO), 
+        if (!ReadFile(pipe, &WSAProtocolInfo, sizeof(WSAPROTOCOL_INFO),
                       &BytesRead, (LPOVERLAPPED) NULL)) {
             ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
                          "setup_inherited_listeners: Unable to read socket data from parent");
@@ -531,15 +531,15 @@ void get_listeners_from_parent(server_rec *s)
         if (osver.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
             HANDLE hProcess = GetCurrentProcess();
             HANDLE dup;
-            if (DuplicateHandle(hProcess, (HANDLE) nsd, hProcess, &dup, 
+            if (DuplicateHandle(hProcess, (HANDLE) nsd, hProcess, &dup,
                                 0, FALSE, DUPLICATE_SAME_ACCESS)) {
                 closesocket(nsd);
                 nsd = (SOCKET) dup;
             }
         }
         else {
-            /* A different approach.  Many users report errors such as 
-             * (32538)An operation was attempted on something that is not 
+            /* A different approach.  Many users report errors such as
+             * (32538)An operation was attempted on something that is not
              * a socket.  : Parent: WSADuplicateSocket failed...
              *
              * This appears that the duplicated handle is no longer recognized
@@ -560,7 +560,7 @@ void get_listeners_from_parent(server_rec *s)
 }
 
 
-static int send_listeners_to_child(apr_pool_t *p, DWORD dwProcessId, 
+static int send_listeners_to_child(apr_pool_t *p, DWORD dwProcessId,
                                    apr_file_t *child_in)
 {
     apr_status_t rv;
@@ -569,8 +569,8 @@ static int send_listeners_to_child(apr_pool_t *p, DWORD dwProcessId,
     LPWSAPROTOCOL_INFO  lpWSAProtocolInfo;
     apr_size_t BytesWritten;
 
-    /* Run the chain of open sockets. For each socket, duplicate it 
-     * for the target process then send the WSAPROTOCOL_INFO 
+    /* Run the chain of open sockets. For each socket, duplicate it
+     * for the target process then send the WSAPROTOCOL_INFO
      * (returned by dup socket) to the child.
      */
     for (lr = ap_listeners; lr; lr = lr->next, ++lcnt) {
@@ -578,7 +578,7 @@ static int send_listeners_to_child(apr_pool_t *p, DWORD dwProcessId,
         lpWSAProtocolInfo = apr_pcalloc(p, sizeof(WSAPROTOCOL_INFO));
         apr_os_sock_get(&nsd,lr->sd);
         ap_log_error(APLOG_MARK, APLOG_INFO, APR_SUCCESS, ap_server_conf,
-                     "Parent: Duplicating socket %d and sending it to child process %d", 
+                     "Parent: Duplicating socket %d and sending it to child process %d",
                      nsd, dwProcessId);
         if (WSADuplicateSocket(nsd, dwProcessId,
                                lpWSAProtocolInfo) == SOCKET_ERROR) {
@@ -587,7 +587,7 @@ static int send_listeners_to_child(apr_pool_t *p, DWORD dwProcessId,
             return -1;
         }
 
-        if ((rv = apr_file_write_full(child_in, lpWSAProtocolInfo, 
+        if ((rv = apr_file_write_full(child_in, lpWSAProtocolInfo,
                                       sizeof(WSAPROTOCOL_INFO), &BytesWritten))
                 != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
@@ -606,10 +606,10 @@ enum waitlist_e {
     waitlist_term = 1
 };
 
-static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_event, 
+static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_event,
                           DWORD *child_pid)
 {
-    /* These NEVER change for the lifetime of this parent 
+    /* These NEVER change for the lifetime of this parent
      */
     static char **args = NULL;
     static char **env = NULL;
@@ -629,7 +629,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     apr_pool_create_ex(&ptemp, p, NULL, NULL);
 
     /* Build the command line. Should look something like this:
-     * C:/apache/bin/apache.exe -f ap_server_confname 
+     * C:/apache/bin/apache.exe -f ap_server_confname
      * First, get the path to the executable...
      */
     apr_procattr_create(&attr, ptemp);
@@ -642,20 +642,20 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     }
 
     if (!args) {
-        /* Build the args array, only once since it won't change 
+        /* Build the args array, only once since it won't change
          * for the lifetime of this parent process.
          */
         if ((rv = ap_os_proc_filepath(&cmd, ptemp))
                 != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_CRIT, ERROR_BAD_PATHNAME, ap_server_conf,
-                         "Parent: Failed to get full path of %s", 
+                         "Parent: Failed to get full path of %s",
                          ap_server_conf->process->argv[0]);
             apr_pool_destroy(ptemp);
             return -1;
         }
-        
+
         args = malloc((ap_server_conf->process->argc + 1) * sizeof (char*));
-        memcpy(args + 1, ap_server_conf->process->argv + 1, 
+        memcpy(args + 1, ap_server_conf->process->argv + 1,
                (ap_server_conf->process->argc - 1) * sizeof (char*));
         args[0] = malloc(strlen(cmd) + 1);
         strcpy(args[0], cmd);
@@ -666,7 +666,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     }
 
     /* Create a pipe to send handles to the child */
-    if ((rv = apr_procattr_io_set(attr, APR_FULL_BLOCK, 
+    if ((rv = apr_procattr_io_set(attr, APR_FULL_BLOCK,
                                   APR_NO_PIPE, APR_NO_PIPE)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
                         "Parent: Unable to create child stdin pipe.");
@@ -675,9 +675,9 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     }
 
     /* Open a null handle to soak info from the child */
-    if (((rv = apr_file_open(&child_out, "NUL", APR_READ | APR_WRITE, 
+    if (((rv = apr_file_open(&child_out, "NUL", APR_READ | APR_WRITE,
                              APR_OS_DEFAULT, ptemp)) != APR_SUCCESS)
-        || ((rv = apr_procattr_child_out_set(attr, child_out, NULL)) 
+        || ((rv = apr_procattr_child_out_set(attr, child_out, NULL))
                 != APR_SUCCESS)) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
                         "Parent: Unable to connect child stdout to NUL.");
@@ -685,7 +685,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
         return -1;
     }
 
-    /* Connect the child's initial stderr to our main server error log 
+    /* Connect the child's initial stderr to our main server error log
      * or share our own stderr handle.
      */
     if (ap_server_conf->error_log) {
@@ -723,9 +723,9 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
         return -1;
     }
 
-    if (!env) 
+    if (!env)
     {
-        /* Build the env array, only once since it won't change 
+        /* Build the env array, only once since it won't change
          * for the lifetime of this parent process.
          */
         int envc;
@@ -758,7 +758,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
                               new_child.hproc, new_child.in)) {
         /*
          * This error is fatal, mop up the child and move on
-         * We toggle the child's exit event to cause this child 
+         * We toggle the child's exit event to cause this child
          * to quit even as it is attempting to start.
          */
         SetEvent(hExitEvent);
@@ -771,7 +771,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
 
     /* Important:
      * Give the child process a chance to run before dup'ing the sockets.
-     * We have already set the listening sockets noninheritable, but if 
+     * We have already set the listening sockets noninheritable, but if
      * WSADuplicateSocket runs before the child process initializes
      * the listeners will be inherited anyway.
      */
@@ -779,7 +779,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     rv = WaitForMultipleObjects(2, waitlist, FALSE, INFINITE);
     CloseHandle(waitlist[waitlist_ready]);
     if (rv != WAIT_OBJECT_0) {
-        /* 
+        /*
          * Outch... that isn't a ready signal. It's dead, Jim!
          */
         SetEvent(hExitEvent);
@@ -792,7 +792,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     if (send_listeners_to_child(ptemp, new_child.pid, new_child.in)) {
         /*
          * This error is fatal, mop up the child and move on
-         * We toggle the child's exit event to cause this child 
+         * We toggle the child's exit event to cause this child
          * to quit even as it is attempting to start.
          */
         SetEvent(hExitEvent);
@@ -811,8 +811,8 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
 
 /***********************************************************************
  * master_main()
- * master_main() runs in the parent process.  It creates the child 
- * process which handles HTTP requests then waits on one of three 
+ * master_main() runs in the parent process.  It creates the child
+ * process which handles HTTP requests then waits on one of three
  * events:
  *
  * restart_event
@@ -821,15 +821,15 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
  * tells the old child process to exit (by setting the child_exit_event).
  * The restart event is set as a result of one of the following:
  * 1. An apache -k restart command on the command line
- * 2. A command received from Windows service manager which gets 
+ * 2. A command received from Windows service manager which gets
  *    translated into an ap_signal_parent(SIGNAL_PARENT_RESTART)
  *    call by code in service.c.
  * 3. The child process calling ap_signal_parent(SIGNAL_PARENT_RESTART)
  *    as a result of hitting MaxRequestsPerChild.
  *
- * shutdown_event 
+ * shutdown_event
  * --------------
- * The shutdown event causes master_main to tell the child process to 
+ * The shutdown event causes master_main to tell the child process to
  * exit and that the server is shutting down. The shutdown event is
  * set as a result of one of the following:
  * 1. An apache -k shutdown command on the command line
@@ -839,11 +839,11 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
  *
  * child process handle
  * --------------------
- * The child process handle will be signaled if the child process 
+ * The child process handle will be signaled if the child process
  * exits for any reason. In a normal running server, the signaling
  * of this event means that the child process has exited prematurely
  * due to a seg fault or other irrecoverable error. For server
- * robustness, master_main will restart the child process under this 
+ * robustness, master_main will restart the child process under this
  * condtion.
  *
  * master_main uses the child_exit_event to signal the child process
@@ -868,9 +868,9 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
     event_handles[RESTART_HANDLE] = restart_event;
 
     /* Create a single child process */
-    rv = create_process(pconf, &event_handles[CHILD_HANDLE], 
+    rv = create_process(pconf, &event_handles[CHILD_HANDLE],
                         &child_exit_event, &child_pid);
-    if (rv < 0) 
+    if (rv < 0)
     {
         ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), ap_server_conf,
                      "master_main: create child process failed. Exiting.");
@@ -906,7 +906,7 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
     else if (cld == SHUTDOWN_HANDLE) {
         /* shutdown_event signalled */
         shutdown_pending = 1;
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, s, 
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, s,
                      "Parent: Received shutdown signal -- Shutting down the server.");
         if (ResetEvent(shutdown_event) == 0) {
             ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s,
@@ -914,11 +914,11 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
         }
     }
     else if (cld == RESTART_HANDLE) {
-        /* Received a restart event. Prepare the restart_event to be reused 
-         * then signal the child process to exit. 
+        /* Received a restart event. Prepare the restart_event to be reused
+         * then signal the child process to exit.
          */
         restart_pending = 1;
-        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s, 
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, s,
                      "Parent: Received restart signal -- Restarting the server.");
         if (ResetEvent(restart_event) == 0) {
             ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s,
@@ -926,10 +926,10 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
         }
         if (SetEvent(child_exit_event) == 0) {
             ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_os_error(), s,
-                         "Parent: SetEvent for child process %d failed.", 
+                         "Parent: SetEvent for child process %d failed.",
                          event_handles[CHILD_HANDLE]);
         }
-        /* Don't wait to verify that the child process really exits, 
+        /* Don't wait to verify that the child process really exits,
          * just move on with the restart.
          */
         CloseHandle(event_handles[CHILD_HANDLE]);
@@ -942,17 +942,17 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
             /* HUH? We did exit, didn't we? */
             exitcode = APEXIT_CHILDFATAL;
         }
-        if (   exitcode == APEXIT_CHILDFATAL 
+        if (   exitcode == APEXIT_CHILDFATAL
             || exitcode == APEXIT_CHILDINIT
             || exitcode == APEXIT_INIT) {
-            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf, 
+            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, ap_server_conf,
                          "Parent: child process exited with status %u -- Aborting.", exitcode);
             shutdown_pending = 1;
         }
         else {
             int i;
             restart_pending = 1;
-            ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf, 
+            ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
                          "Parent: child process exited with status %u -- Restarting.", exitcode);
             for (i = 0; i < ap_threads_per_child; i++) {
                 ap_update_child_status_from_indexes(0, i, SERVER_DEAD, NULL);
@@ -966,12 +966,12 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
         ap_scoreboard_image->global->running_generation = ap_my_generation;
     }
 die_now:
-    if (shutdown_pending) 
+    if (shutdown_pending)
     {
         int timeout = 30000;  /* Timeout is milliseconds */
         winnt_mpm_state = AP_MPMQ_STOPPING;
 
-        /* This shutdown is only marginally graceful. We will give the 
+        /* This shutdown is only marginally graceful. We will give the
          * child a bit of time to exit gracefully. If the time expires,
          * the child will be wacked.
          */
@@ -1005,7 +1005,7 @@ die_now:
     return 1;      /* Tell the caller we want a restart */
 }
 
-/* service_nt_main_fn needs to append the StartService() args 
+/* service_nt_main_fn needs to append the StartService() args
  * outside of our call stack and thread as the service starts...
  */
 apr_array_header_t *mpm_new_argv;
@@ -1039,7 +1039,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
         case AP_MPMQ_MIN_SPARE_DAEMONS:
             *result = 0;
             return APR_SUCCESS;
-        case AP_MPMQ_MIN_SPARE_THREADS:    
+        case AP_MPMQ_MIN_SPARE_THREADS:
             *result = 0;
             return APR_SUCCESS;
         case AP_MPMQ_MAX_SPARE_DAEMONS:
@@ -1059,7 +1059,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
             return APR_SUCCESS;
     }
     return APR_ENOTIMPL;
-} 
+}
 
 #define SERVICE_UNSET (-1)
 static apr_status_t service_set = SERVICE_UNSET;
@@ -1067,8 +1067,8 @@ static apr_status_t service_to_start_success;
 static int inst_argc;
 static const char * const *inst_argv;
 static char *service_name = NULL;
-    
-void winnt_rewrite_args(process_rec *process) 
+
+void winnt_rewrite_args(process_rec *process)
 {
     /* Handle the following SCM aspects in this phase:
      *
@@ -1103,7 +1103,7 @@ void winnt_rewrite_args(process_rec *process)
 
     /* AP_PARENT_PID is only valid in the child */
     pid = getenv("AP_PARENT_PID");
-    if (pid) 
+    if (pid)
     {
         /* This is the child */
         my_pid = GetCurrentProcessId();
@@ -1122,19 +1122,19 @@ void winnt_rewrite_args(process_rec *process)
         signal_arg = "runchild";
         return;
     }
-    
+
     /* This is the parent, we have a long way to go :-) */
     parent_pid = my_pid = GetCurrentProcessId();
 
     /* This behavior is voided by setting real_exit_code to 0 */
     atexit(hold_console_open_on_error);
 
-    /* Rewrite process->argv[]; 
+    /* Rewrite process->argv[];
      *
      * strip out -k signal into signal_arg
      * strip out -n servicename and set the names
      * add default -d serverroot from the path of this executable
-     * 
+     *
      * The end result will look like:
      *
      * The invocation command (%0)
@@ -1144,7 +1144,7 @@ void winnt_rewrite_args(process_rec *process)
      */
     if ((rv = ap_os_proc_filepath(&binpath, process->pconf))
             != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK,APLOG_CRIT, rv, NULL, 
+        ap_log_error(APLOG_MARK,APLOG_CRIT, rv, NULL,
                      "Failed to get the full path of %s", process->argv[0]);
         exit(APEXIT_INIT);
     }
@@ -1158,12 +1158,12 @@ void winnt_rewrite_args(process_rec *process)
         if (!strcasecmp(def_server_root, "bin"))
             *(def_server_root - 1) = '\0';
     }
-    apr_filepath_merge(&def_server_root, NULL, binpath, 
+    apr_filepath_merge(&def_server_root, NULL, binpath,
                        APR_FILEPATH_TRUENAME, process->pool);
 
     /* Use process->pool so that the rewritten argv
      * lasts for the lifetime of the server process,
-     * because pconf will be destroyed after the 
+     * because pconf will be destroyed after the
      * initial pre-flight of the config parser.
      */
     mpm_new_argv = apr_array_make(process->pool, process->argc + 2,
@@ -1178,7 +1178,7 @@ void winnt_rewrite_args(process_rec *process)
     optbuf[2] = '\0';
     apr_getopt_init(&opt, process->pool, process->argc, (char**) process->argv);
     opt->errfn = NULL;
-    while ((rv = apr_getopt(opt, "wn:k:" AP_SERVER_BASEARGS, 
+    while ((rv = apr_getopt(opt, "wn:k:" AP_SERVER_BASEARGS,
                             optbuf + 1, &optarg)) == APR_SUCCESS) {
         switch (optbuf[1]) {
 
@@ -1191,7 +1191,7 @@ void winnt_rewrite_args(process_rec *process)
             break;
 
         case 'n':
-            service_set = mpm_service_set_name(process->pool, &service_name, 
+            service_set = mpm_service_set_name(process->pool, &service_name,
                                                optarg);
             break;
 
@@ -1212,7 +1212,7 @@ void winnt_rewrite_args(process_rec *process)
             break;
         }
     }
-    
+
     /* back up to capture the bad argument */
     if (rv == APR_BADCH || rv == APR_BADARG) {
         opt->ind--;
@@ -1233,10 +1233,10 @@ void winnt_rewrite_args(process_rec *process)
         running_as_service = 0;
     }
 
-    if (!strcasecmp(signal_arg, "runservice")) 
+    if (!strcasecmp(signal_arg, "runservice"))
     {
-        /* Start the NT Service _NOW_ because the WinNT SCM is 
-         * expecting us to rapidly assume control of our own 
+        /* Start the NT Service _NOW_ because the WinNT SCM is
+         * expecting us to rapidly assume control of our own
          * process, the SCM will tell us our service name, and
          * may have extra StartService() command arguments to
          * add for us.
@@ -1248,7 +1248,7 @@ void winnt_rewrite_args(process_rec *process)
          * (path to apache root, above /bin) for safety.
          */
         apr_filepath_set(def_server_root, process->pool);
-        
+
         /* Any other process has a console, so we don't to begin
          * a Win9x service until the configuration is parsed and
          * any command line errors are reported.
@@ -1256,7 +1256,7 @@ void winnt_rewrite_args(process_rec *process)
          * We hold the return value so that we can die in pre_config
          * after logging begins, and the failure can land in the log.
          */
-        if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT) 
+        if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
         {
             if (!errout) {
                 mpm_nt_eventlog_stderr_open(service_name, process->pool);
@@ -1277,7 +1277,7 @@ void winnt_rewrite_args(process_rec *process)
 
     if (!strcasecmp(signal_arg, "install")) /* -k install */
     {
-        if (service_set == APR_SUCCESS) 
+        if (service_set == APR_SUCCESS)
         {
             ap_log_error(APLOG_MARK,APLOG_ERR, 0, NULL,
                  "%s: Service is already installed.", service_name);
@@ -1286,9 +1286,9 @@ void winnt_rewrite_args(process_rec *process)
     }
     else if (running_as_service)
     {
-        if (service_set == APR_SUCCESS) 
+        if (service_set == APR_SUCCESS)
         {
-            /* Attempt to Uninstall, or stop, before 
+            /* Attempt to Uninstall, or stop, before
              * we can read the arguments or .conf files
              */
             if (!strcasecmp(signal_arg, "uninstall")) {
@@ -1296,13 +1296,13 @@ void winnt_rewrite_args(process_rec *process)
                 exit(rv);
             }
 
-            if ((!strcasecmp(signal_arg, "stop")) || 
+            if ((!strcasecmp(signal_arg, "stop")) ||
                 (!strcasecmp(signal_arg, "shutdown"))) {
                 mpm_signal_service(process->pool, 0);
                 exit(0);
             }
 
-            rv = mpm_merge_service_args(process->pool, mpm_new_argv, 
+            rv = mpm_merge_service_args(process->pool, mpm_new_argv,
                                         fixed_args);
             if (rv == APR_SUCCESS) {
                 ap_log_error(APLOG_MARK,APLOG_INFO, 0, NULL,
@@ -1322,7 +1322,7 @@ void winnt_rewrite_args(process_rec *process)
             exit(APEXIT_INIT);
         }
     }
-    if (strcasecmp(signal_arg, "install") && service_set && service_set != SERVICE_UNSET) 
+    if (strcasecmp(signal_arg, "install") && service_set && service_set != SERVICE_UNSET)
     {
         ap_log_error(APLOG_MARK,APLOG_ERR, service_set, NULL,
              "No installed service named \"%s\".", service_name);
@@ -1362,19 +1362,19 @@ void winnt_rewrite_args(process_rec *process)
                 "service can be started.\n");
     }
 
-    process->argc = mpm_new_argv->nelts; 
+    process->argc = mpm_new_argv->nelts;
     process->argv = (const char * const *) mpm_new_argv->elts;
 }
 
 
-static int winnt_pre_config(apr_pool_t *pconf_, apr_pool_t *plog, apr_pool_t *ptemp) 
+static int winnt_pre_config(apr_pool_t *pconf_, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     /* Handle the following SCM aspects in this phase:
      *
      *   -k runservice [WinNT errors logged from rewrite_args]
      */
 
-    /* Initialize shared static objects. 
+    /* Initialize shared static objects.
      * TODO: Put config related statics into an sconf structure.
      */
     pconf = pconf_;
@@ -1386,7 +1386,7 @@ static int winnt_pre_config(apr_pool_t *pconf_, apr_pool_t *plog, apr_pool_t *pt
     if (!strcasecmp(signal_arg, "runservice")
             && (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
             && (service_to_start_success != APR_SUCCESS)) {
-        ap_log_error(APLOG_MARK,APLOG_CRIT, service_to_start_success, NULL, 
+        ap_log_error(APLOG_MARK,APLOG_CRIT, service_to_start_success, NULL,
                      "%s: Unable to start the service manager.",
                      service_name);
         exit(APEXIT_INIT);
@@ -1436,7 +1436,7 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
      */
 
     if (!strcasecmp(signal_arg, "install")) {
-        /* Service install happens in the rewrite_args hooks. If we 
+        /* Service install happens in the rewrite_args hooks. If we
          * made it this far, the server configuration is clean and the
          * service will successfully start.
          */
@@ -1445,7 +1445,7 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
         exit(0);
     }
     if (!strcasecmp(signal_arg, "config")) {
-        /* Service reconfiguration happens in the rewrite_args hooks. If we 
+        /* Service reconfiguration happens in the rewrite_args hooks. If we
          * made it this far, the server configuration is clean and the
          * service will successfully start.
          */
@@ -1475,9 +1475,9 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
         exit (rv);
     }
 
-    if (parent_pid == my_pid) 
+    if (parent_pid == my_pid)
     {
-        if (restart_num++ == 1) 
+        if (restart_num++ == 1)
         {
             /* This code should be run once in the parent and not run
              * across a restart
@@ -1486,8 +1486,8 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
             setup_signal_names(apr_psprintf(pconf,"ap%d", parent_pid));
 
             ap_log_pid(pconf, ap_pid_fname);
-            
-            /* Create shutdown event, apPID_shutdown, where PID is the parent 
+
+            /* Create shutdown event, apPID_shutdown, where PID is the parent
              * Apache process ID. Shutdown is signaled by 'apache -k shutdown'.
              */
             shutdown_event = CreateEvent(sa, FALSE, FALSE, signal_shutdown_name);
@@ -1498,7 +1498,7 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
 
-            /* Create restart event, apPID_restart, where PID is the parent 
+            /* Create restart event, apPID_restart, where PID is the parent
              * Apache process ID. Restart is signaled by 'apache -k restart'.
              */
             restart_event = CreateEvent(sa, FALSE, FALSE, signal_restart_name);
@@ -1511,14 +1511,14 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
             }
             CleanNullACL((void *)sa);
 
-            /* Now that we are flying at 15000 feet... 
+            /* Now that we are flying at 15000 feet...
              * wipe out the Win95 service console,
              * signal the SCM the WinNT service started, or
              * if not a service, setup console handlers instead.
              */
             if (!strcasecmp(signal_arg, "runservice"))
             {
-                if (osver.dwPlatformId != VER_PLATFORM_WIN32_NT) 
+                if (osver.dwPlatformId != VER_PLATFORM_WIN32_NT)
                 {
                     rv = mpm_service_to_start(&service_name,
                                               s->process->pool);
@@ -1536,7 +1536,7 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
             }
 
             /* Create the start mutex, as an unnamed object for security.
-             * Ths start mutex is used during a restart to prevent more than 
+             * Ths start mutex is used during a restart to prevent more than
              * one child process from entering the accept loop at once.
              */
             rv =  apr_proc_mutex_create(&start_mutex, NULL,
@@ -1547,7 +1547,7 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
                              "%s: Unable to create the start_mutex.",
                              service_name);
                 return HTTP_INTERNAL_SERVER_ERROR;
-            }            
+            }
         }
     }
     else /* parent_pid != my_pid */
@@ -1562,7 +1562,7 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
  */
 static int winnt_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
 {
-    /* Initialize shared static objects. 
+    /* Initialize shared static objects.
      */
     ap_server_conf = s;
 
@@ -1572,16 +1572,16 @@ static int winnt_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, s
 
     /* We cannot initialize our listeners if we are restarting
      * (the parent process already has glomed on to them)
-     * nor should we do so for service reconfiguration 
+     * nor should we do so for service reconfiguration
      * (since the service may already be running.)
      */
-    if (!strcasecmp(signal_arg, "restart") 
+    if (!strcasecmp(signal_arg, "restart")
             || !strcasecmp(signal_arg, "config")) {
         return OK;
     }
 
     if (ap_setup_listeners(s) < 1) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0, 
+        ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0,
                      NULL, "no listening sockets available, shutting down");
         return DONE;
     }
@@ -1598,7 +1598,7 @@ static void winnt_child_init(apr_pool_t *pchild, struct server_rec *s)
     /* This is a child process, not in single process mode */
     if (!one_process) {
         /* Set up events and the scoreboard */
-        get_handles_from_parent(s, &exit_event, &start_mutex, 
+        get_handles_from_parent(s, &exit_event, &start_mutex,
                                 &ap_scoreboard_shm);
 
         /* Set up the listeners */
@@ -1608,7 +1608,7 @@ static void winnt_child_init(apr_pool_t *pchild, struct server_rec *s)
     }
     else {
         /* Single process mode - this lock doesn't even need to exist */
-        rv = apr_proc_mutex_create(&start_mutex, signal_name_prefix, 
+        rv = apr_proc_mutex_create(&start_mutex, signal_name_prefix,
                                    APR_LOCK_DEFAULT, s->process->pool);
         if (rv != APR_SUCCESS) {
             ap_log_error(APLOG_MARK,APLOG_ERR, rv, ap_server_conf,
@@ -1616,7 +1616,7 @@ static void winnt_child_init(apr_pool_t *pchild, struct server_rec *s)
                          service_name, my_pid);
             exit(APEXIT_CHILDINIT);
         }
-        
+
         /* Borrow the shutdown_even as our _child_ loop exit event */
         exit_event = shutdown_event;
     }
@@ -1637,10 +1637,10 @@ AP_DECLARE(int) ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
                      "during restart");
         changed_limit_at_restart = 0;
     }
-    
-    /* ### If non-graceful restarts are ever introduced - we need to rerun 
-     * the pre_mpm hook on subsequent non-graceful restarts.  But Win32 
-     * has only graceful style restarts - and we need this hook to act 
+
+    /* ### If non-graceful restarts are ever introduced - we need to rerun
+     * the pre_mpm hook on subsequent non-graceful restarts.  But Win32
+     * has only graceful style restarts - and we need this hook to act
      * the same on Win32 as on Unix.
      */
     if (!restart && ((parent_pid == my_pid) || one_process)) {
@@ -1649,10 +1649,10 @@ AP_DECLARE(int) ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
             return 1;
         }
     }
-    
-    if ((parent_pid != my_pid) || one_process) 
+
+    if ((parent_pid != my_pid) || one_process)
     {
-        /* The child process or in one_process (debug) mode 
+        /* The child process or in one_process (debug) mode
          */
         ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
                      "Child %d: Child process is running", my_pid);
@@ -1660,10 +1660,10 @@ AP_DECLARE(int) ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
         child_main(pconf);
 
         ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, ap_server_conf,
-                     "Child %d: Child process is exiting", my_pid);        
+                     "Child %d: Child process is exiting", my_pid);
         return 1;
     }
-    else 
+    else
     {
         /* A real-honest to goodness parent */
         ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
@@ -1674,7 +1674,7 @@ AP_DECLARE(int) ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
 
         restart = master_main(ap_server_conf, shutdown_event, restart_event);
 
-        if (!restart) 
+        if (!restart)
         {
             /* Shutting down. Clean up... */
             const char *pidfile = ap_server_root_relative (pconf, ap_pid_fname);
diff --git a/server/mpm/winnt/nt_eventlog.c b/server/mpm/winnt/nt_eventlog.c
index 1bfedb3..0772d54 100644
--- a/server/mpm/winnt/nt_eventlog.c
+++ b/server/mpm/winnt/nt_eventlog.c
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define CORE_PRIVATE 
+#define CORE_PRIVATE
 
 #include "httpd.h"
 #include "http_log.h"
@@ -38,7 +38,7 @@ static DWORD WINAPI service_stderr_thread(LPVOID hPipe)
     ap_regkey_t *regkey;
     apr_status_t rv;
     apr_pool_t *p;
-    
+
     apr_pool_create_ex(&p, NULL, NULL, NULL);
 
     errarg[0] = "The Apache service named";
@@ -52,21 +52,21 @@ static DWORD WINAPI service_stderr_thread(LPVOID hPipe)
     errarg[8] = NULL;
 
     /* What are we going to do in here, bail on the user?  not. */
-    if ((rv = ap_regkey_open(&regkey, AP_REGKEY_LOCAL_MACHINE, 
+    if ((rv = ap_regkey_open(&regkey, AP_REGKEY_LOCAL_MACHINE,
                              "SYSTEM\\CurrentControlSet\\Services\\"
                              "EventLog\\Application\\Apache Service",
-                             APR_READ | APR_WRITE | APR_CREATE, p)) 
+                             APR_READ | APR_WRITE | APR_CREATE, p))
             == APR_SUCCESS)
     {
-        DWORD dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
-                       EVENTLOG_INFORMATION_TYPE; 
- 
+        DWORD dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE |
+                       EVENTLOG_INFORMATION_TYPE;
+
         /* The stock message file */
-        ap_regkey_value_set(regkey, "EventMessageFile", 
-                            "%SystemRoot%\\System32\\netmsg.dll", 
+        ap_regkey_value_set(regkey, "EventMessageFile",
+                            "%SystemRoot%\\System32\\netmsg.dll",
                             AP_REGKEY_EXPAND, p);
-        
-        ap_regkey_value_raw_set(regkey, "TypesSupported", &dwData, 
+
+        ap_regkey_value_raw_set(regkey, "TypesSupported", &dwData,
                                 sizeof(dwData), REG_DWORD, p);
         ap_regkey_close(regkey);
     }
@@ -80,7 +80,7 @@ static DWORD WINAPI service_stderr_thread(LPVOID hPipe)
         if ((errmsg > errbuf) || !apr_isspace(*errmsg))
         {
             ++errmsg;
-            if ((*(errmsg - 1) == '\n') 
+            if ((*(errmsg - 1) == '\n')
                     || (errmsg >= errbuf + sizeof(errbuf) - 1))
             {
                 while ((errmsg > errbuf) && apr_isspace(*(errmsg - 1))) {
@@ -91,7 +91,7 @@ static DWORD WINAPI service_stderr_thread(LPVOID hPipe)
                 /* Generic message: '%1 %2 %3 %4 %5 %6 %7 %8 %9'
                  * The event code in netmsg.dll is 3299
                  */
-                ReportEvent(hEventSource, EVENTLOG_ERROR_TYPE, 0, 
+                ReportEvent(hEventSource, EVENTLOG_ERROR_TYPE, 0,
                             3299, NULL, 9, 0, errarg, NULL);
                 errmsg = errbuf;
             }
@@ -100,10 +100,10 @@ static DWORD WINAPI service_stderr_thread(LPVOID hPipe)
 
     if ((errres = GetLastError()) != ERROR_BROKEN_PIPE) {
         apr_snprintf(errbuf, sizeof(errbuf),
-                     "Win32 error %d reading stderr pipe stream\r\n", 
+                     "Win32 error %d reading stderr pipe stream\r\n",
                      GetLastError());
 
-        ReportEvent(hEventSource, EVENTLOG_ERROR_TYPE, 0, 
+        ReportEvent(hEventSource, EVENTLOG_ERROR_TYPE, 0,
                     3299, NULL, 9, 0, errarg, NULL);
     }
 
@@ -149,7 +149,7 @@ void mpm_nt_eventlog_stderr_open(char *argv0, apr_pool_t *p)
     sa.nLength = sizeof(sa);
     sa.lpSecurityDescriptor = NULL;
     sa.bInheritHandle = FALSE;
-    CreatePipe(&hPipeRead, &hPipeWrite, NULL, 0); 
+    CreatePipe(&hPipeRead, &hPipeWrite, NULL, 0);
     ap_assert(hPipeRead && hPipeWrite);
 
     stderr_ready = CreateEvent(NULL, FALSE, FALSE, NULL);
@@ -160,14 +160,14 @@ void mpm_nt_eventlog_stderr_open(char *argv0, apr_pool_t *p)
     WaitForSingleObject(stderr_ready, INFINITE);
 
     /* Flush stderr and unset its buffer, then commit and replace stderr.
-     * This is typically a noop for Win2K/XP since services with NULL std 
-     * handles [but valid FILE *'s, oddly enough], but is required 
+     * This is typically a noop for Win2K/XP since services with NULL std
+     * handles [but valid FILE *'s, oddly enough], but is required
      * for NT 4.0 and to use this code outside of services.
      */
     fflush(stderr);
     setvbuf(stderr, NULL, _IONBF, 0);
     _commit(2 /* stderr */);
-    fd = _open_osfhandle((long) hPipeWrite, 
+    fd = _open_osfhandle((long) hPipeWrite,
                          _O_WRONLY | _O_BINARY);
     _dup2(fd, 2);
     _close(fd);
@@ -181,7 +181,7 @@ void mpm_nt_eventlog_stderr_open(char *argv0, apr_pool_t *p)
 
     SetStdHandle(STD_ERROR_HANDLE, hPipeWrite);
 
-    /* The code above _will_ corrupt the StdHandle... 
+    /* The code above _will_ corrupt the StdHandle...
      * and we must do so anyways.  We set this up only
      * after we initialized the posix stderr API.
      */
diff --git a/server/mpm/winnt/service.c b/server/mpm/winnt/service.c
index 67902e7..bb699b0 100644
--- a/server/mpm/winnt/service.c
+++ b/server/mpm/winnt/service.c
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-/* This module ALONE requires the window message API from user.h 
+/* This module ALONE requires the window message API from user.h
  * and the default APR include of windows.h will omit it, so
  * preload the API symbols now...
  */
 
-#define CORE_PRIVATE 
+#define CORE_PRIVATE
 #define _WINUSER_
 
 #include "httpd.h"
@@ -67,19 +67,19 @@ apr_status_t ap_registry_get_server_root(apr_pool_t *p, char **buf)
     apr_status_t rv;
     ap_regkey_t *key;
 
-    if ((rv = ap_regkey_open(&key, AP_REGKEY_LOCAL_MACHINE, PRODREGKEY, 
+    if ((rv = ap_regkey_open(&key, AP_REGKEY_LOCAL_MACHINE, PRODREGKEY,
                              APR_READ, p)) == APR_SUCCESS) {
         rv = ap_regkey_value_get(buf, key, "ServerRoot", p);
         ap_regkey_close(key);
-        if (rv == APR_SUCCESS) 
+        if (rv == APR_SUCCESS)
             return rv;
     }
 
-    if ((rv = ap_regkey_open(&key, AP_REGKEY_CURRENT_USER, PRODREGKEY, 
+    if ((rv = ap_regkey_open(&key, AP_REGKEY_CURRENT_USER, PRODREGKEY,
                              APR_READ, p)) == APR_SUCCESS) {
         rv = ap_regkey_value_get(buf, key, "ServerRoot", p);
         ap_regkey_close(key);
-        if (rv == APR_SUCCESS) 
+        if (rv == APR_SUCCESS)
             return rv;
     }
 
@@ -102,7 +102,7 @@ apr_status_t ap_registry_get_server_root(apr_pool_t *p, char **buf)
  */
 
 
-/* exit() for Win32 is macro mapped (horrible, we agree) that allows us 
+/* exit() for Win32 is macro mapped (horrible, we agree) that allows us
  * to catch the non-zero conditions and inform the console process that
  * the application died, and hang on to the console a bit longer.
  *
@@ -128,7 +128,7 @@ void hold_console_open_on_error(void)
     CONSOLE_SCREEN_BUFFER_INFO coninfo;
     INPUT_RECORD in;
     char count[16];
-    
+
     if (!ap_real_exit_code)
         return;
     hConIn = GetStdHandle(STD_INPUT_HANDLE);
@@ -141,7 +141,7 @@ void hold_console_open_on_error(void)
         return;
     if (!SetConsoleMode(hConIn, ENABLE_MOUSE_INPUT | 0x80))
         return;
-        
+
     start = time(NULL);
     do
     {
@@ -149,18 +149,18 @@ void hold_console_open_on_error(void)
         {
             if (!ReadConsoleInput(hConIn, &in, 1, &result) || !result)
                 return;
-            if ((in.EventType == KEY_EVENT) && in.Event.KeyEvent.bKeyDown 
+            if ((in.EventType == KEY_EVENT) && in.Event.KeyEvent.bKeyDown
                     && (in.Event.KeyEvent.uChar.AsciiChar == 27))
                 return;
-            if (in.EventType == MOUSE_EVENT 
+            if (in.EventType == MOUSE_EVENT
                     && (in.Event.MouseEvent.dwEventFlags == DOUBLE_CLICK))
                 return;
         }
-        remains = ((start + 30) - time(NULL)); 
+        remains = ((start + 30) - time(NULL));
         sprintf (count, "%d...", remains);
         if (!SetConsoleCursorPosition(hConErr, coninfo.dwCursorPosition))
             return;
-        if (!WriteConsole(hConErr, count, (DWORD)strlen(count), &result, NULL) 
+        if (!WriteConsole(hConErr, count, (DWORD)strlen(count), &result, NULL)
                 || !result)
             return;
     }
@@ -169,7 +169,7 @@ void hold_console_open_on_error(void)
 
 static BOOL  die_on_logoff = FALSE;
 
-static LRESULT CALLBACK monitor_service_9x_proc(HWND hWnd, UINT msg, 
+static LRESULT CALLBACK monitor_service_9x_proc(HWND hWnd, UINT msg,
                                                 WPARAM wParam, LPARAM lParam)
 {
 /* This is the WndProc procedure for our invisible window.
@@ -177,7 +177,7 @@ static LRESULT CALLBACK monitor_service_9x_proc(HWND hWnd, UINT msg,
  * a signal WM_ENDSESSION. We clean up by signaling Apache
  * to shut down, and idle until Apache's primary thread quits.
  */
-    if ((msg == WM_ENDSESSION) 
+    if ((msg == WM_ENDSESSION)
             && (die_on_logoff || (lParam != ENDSESSION_LOGOFF)))
     {
         ap_signal_parent(SIGNAL_PARENT_SHUTDOWN);
@@ -192,7 +192,7 @@ static LRESULT CALLBACK monitor_service_9x_proc(HWND hWnd, UINT msg,
 static DWORD WINAPI monitor_service_9x_thread(void *service_name)
 {
     /* When running as a service under Windows 9x, there is no console
-     * window present, and no ConsoleCtrlHandler to call when the system 
+     * window present, and no ConsoleCtrlHandler to call when the system
      * is shutdown.  If the WatchWindow thread is created with a NULL
      * service_name argument, then the ...SystemMonitor window class is
      * used to create the "Apache" window to watch for logoff and shutdown.
@@ -203,11 +203,11 @@ static DWORD WINAPI monitor_service_9x_thread(void *service_name)
     WNDCLASS wc;
     HWND hwndMain;
     MSG msg;
-    
+
     wc.style         = CS_GLOBALCLASS;
-    wc.lpfnWndProc   = monitor_service_9x_proc; 
+    wc.lpfnWndProc   = monitor_service_9x_proc;
     wc.cbClsExtra    = 0;
-    wc.cbWndExtra    = 0; 
+    wc.cbWndExtra    = 0;
     wc.hInstance     = NULL;
     wc.hIcon         = NULL;
     wc.hCursor       = NULL;
@@ -217,27 +217,27 @@ static DWORD WINAPI monitor_service_9x_thread(void *service_name)
         wc.lpszClassName = "ApacheWin95ServiceMonitor";
     else
         wc.lpszClassName = "ApacheWin95SystemMonitor";
- 
+
     die_on_logoff = service_name ? FALSE : TRUE;
 
-    if (!RegisterClass(&wc)) 
+    if (!RegisterClass(&wc))
     {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), 
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(),
                      NULL, "Could not register window class for WatchWindow");
         globdat.service_thread_id = 0;
         return 0;
     }
-    
+
     /* Create an invisible window */
-    hwndMain = CreateWindow(wc.lpszClassName, 
+    hwndMain = CreateWindow(wc.lpszClassName,
                             service_name ? (char *) service_name : "Apache",
- 	                    WS_OVERLAPPEDWINDOW & ~WS_VISIBLE, 
-                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
+ 	                    WS_OVERLAPPEDWINDOW & ~WS_VISIBLE,
+                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                             CW_USEDEFAULT, NULL, NULL, NULL, NULL);
-                            
+
     if (!hwndMain)
     {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), 
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(),
                      NULL, "Could not create WatchWindow");
         globdat.service_thread_id = 0;
         return 0;
@@ -250,10 +250,10 @@ static DWORD WINAPI monitor_service_9x_thread(void *service_name)
     FreeConsole();
     SetEvent(globdat.service_init);
 
-    while (GetMessage(&msg, NULL, 0, 0)) 
+    while (GetMessage(&msg, NULL, 0, 0))
     {
         if (msg.message == WM_CLOSE)
-            DestroyWindow(hwndMain); 
+            DestroyWindow(hwndMain);
         else {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
@@ -295,7 +295,7 @@ static BOOL CALLBACK console_control_handler(DWORD ctrl_type)
             Sleep(30000);
             return TRUE;
     }
- 
+
     /* We should never get here, but this is (mostly) harmless */
     return FALSE;
 }
@@ -341,7 +341,7 @@ static BOOL CALLBACK child_control_handler(DWORD ctrl_type)
             Sleep(30000);
             return TRUE;
     }
- 
+
     /* We should never get here, but this is (mostly) harmless */
     return FALSE;
 }
@@ -374,7 +374,7 @@ static int ReportStatusToSCMgr(int currentState, int exitCode, int waitHint)
 {
     static int checkPoint = 1;
     int rv = APR_SUCCESS;
-    
+
     if (globdat.hServiceStatus)
     {
         if (currentState == SERVICE_RUNNING) {
@@ -385,7 +385,7 @@ static int ReportStatusToSCMgr(int currentState, int exitCode, int waitHint)
         else if (currentState == SERVICE_STOPPED) {
             globdat.ssStatus.dwWaitHint = 0;
             globdat.ssStatus.dwCheckPoint = 0;
-            if (!exitCode && globdat.ssStatus.dwCurrentState 
+            if (!exitCode && globdat.ssStatus.dwCurrentState
                                            != SERVICE_STOP_PENDING) {
                 /* An unexpected exit?  Better to error! */
                 exitCode = 1;
@@ -403,7 +403,7 @@ static int ReportStatusToSCMgr(int currentState, int exitCode, int waitHint)
         }
 
         globdat.ssStatus.dwCurrentState = currentState;
-        
+
         rv = SetServiceStatus(globdat.hServiceStatus, &globdat.ssStatus);
     }
     return(rv);
@@ -438,11 +438,11 @@ static void set_service_description(void)
      */
     full_description = ap_get_server_version();
 
-    if ((osver.dwPlatformId == VER_PLATFORM_WIN32_NT) 
-          && (osver.dwMajorVersion > 4) 
+    if ((osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
+          && (osver.dwMajorVersion > 4)
           && (ChangeServiceConfig2)
           && (schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT)))
-    {    
+    {
         SC_HANDLE schService = OpenService(schSCManager, mpm_service_name,
                                            SERVICE_CHANGE_CONFIG);
         if (schService) {
@@ -460,15 +460,15 @@ static void set_service_description(void)
         CloseServiceHandle(schSCManager);
     }
 
-    if (full_description) 
+    if (full_description)
     {
         char szPath[MAX_PATH];
         ap_regkey_t *svckey;
         apr_status_t rv;
 
         /* Find the Service key that Monitor Applications iterate */
-        apr_snprintf(szPath, sizeof(szPath), 
-                     "SYSTEM\\CurrentControlSet\\Services\\%s", 
+        apr_snprintf(szPath, sizeof(szPath),
+                     "SYSTEM\\CurrentControlSet\\Services\\%s",
                      mpm_service_name);
         rv = ap_regkey_open(&svckey, AP_REGKEY_LOCAL_MACHINE, szPath,
                             APR_READ | APR_WRITE, pconf);
@@ -497,8 +497,8 @@ static VOID WINAPI service_nt_ctrl(DWORD dwCtrlCode)
         ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 30000);
         return;
     }
-    
-    ReportStatusToSCMgr(globdat.ssStatus.dwCurrentState, NO_ERROR, 0);            
+
+    ReportStatusToSCMgr(globdat.ssStatus.dwCurrentState, NO_ERROR, 0);
 }
 
 
@@ -524,7 +524,7 @@ static void __stdcall service_nt_main_fn(DWORD argc, LPTSTR *argv)
     /* ###: utf-ize */
     if (!(globdat.hServiceStatus = RegisterServiceCtrlHandler(argv[0], service_nt_ctrl)))
     {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), 
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(),
                      NULL, "Failure registering service handler");
         return;
     }
@@ -532,11 +532,11 @@ static void __stdcall service_nt_main_fn(DWORD argc, LPTSTR *argv)
     /* Report status, no errors, and buy 3 more seconds */
     ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 30000);
 
-    /* We need to append all the command arguments passed via StartService() 
+    /* We need to append all the command arguments passed via StartService()
      * to our running service... which just got here via the SCM...
      * but we hvae no interest in argv[0] for the mpm_new_argv list.
      */
-    if (argc > 1) 
+    if (argc > 1)
     {
         char **cmb_data;
 
@@ -544,13 +544,13 @@ static void __stdcall service_nt_main_fn(DWORD argc, LPTSTR *argv)
         cmb_data = malloc(mpm_new_argv->nalloc * sizeof(const char *));
 
         /* mpm_new_argv remains first (of lower significance) */
-        memcpy (cmb_data, mpm_new_argv->elts, 
+        memcpy (cmb_data, mpm_new_argv->elts,
                 mpm_new_argv->elt_size * mpm_new_argv->nelts);
-        
+
         /* Service args follow from StartService() invocation */
-        memcpy (cmb_data + mpm_new_argv->nelts, argv + 1, 
+        memcpy (cmb_data + mpm_new_argv->nelts, argv + 1,
                 mpm_new_argv->elt_size * (argc - 1));
-        
+
         /* The replacement arg list is complete */
         mpm_new_argv->elts = (char *)cmb_data;
         mpm_new_argv->nelts = mpm_new_argv->nalloc;
@@ -588,15 +588,15 @@ DWORD WINAPI service_nt_dispatch_thread(LPVOID nada)
 }
 
 
-apr_status_t mpm_service_set_name(apr_pool_t *p, const char **display_name, 
+apr_status_t mpm_service_set_name(apr_pool_t *p, const char **display_name,
                                   const char *set_name)
 {
     char key_name[MAX_PATH];
     ap_regkey_t *key;
     apr_status_t rv;
 
-    /* ### Needs improvement, on Win2K the user can _easily_ 
-     * change the display name to a string that doesn't reflect 
+    /* ### Needs improvement, on Win2K the user can _easily_
+     * change the display name to a string that doesn't reflect
      * the internal service name + whitespace!
      */
     mpm_service_name = apr_palloc(p, strlen(set_name) + 1);
@@ -610,14 +610,14 @@ apr_status_t mpm_service_set_name(apr_pool_t *p, const char **display_name,
     if (rv != APR_SUCCESS) {
         /* Take the given literal name if there is no service entry */
         mpm_display_name = apr_pstrdup(p, set_name);
-    } 
+    }
     *display_name = mpm_display_name;
     return rv;
 }
 
 
-apr_status_t mpm_merge_service_args(apr_pool_t *p, 
-                                   apr_array_header_t *args, 
+apr_status_t mpm_merge_service_args(apr_pool_t *p,
+                                   apr_array_header_t *args,
                                    int fixed_args)
 {
     apr_array_header_t *svc_args = NULL;
@@ -636,12 +636,12 @@ apr_status_t mpm_merge_service_args(apr_pool_t *p,
         if (rv == ERROR_FILE_NOT_FOUND) {
             ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL,
                          "No ConfigArgs registered for %s, perhaps "
-                         "this service is not installed?", 
+                         "this service is not installed?",
                          mpm_service_name);
             return APR_SUCCESS;
         }
         else
-            return (rv);        
+            return (rv);
     }
 
     if (!svc_args || svc_args->nelts == 0) {
@@ -649,8 +649,8 @@ apr_status_t mpm_merge_service_args(apr_pool_t *p,
     }
 
     /* Now we have the mpm_service_name arg, and the mpm_runservice_nt()
-     * call appended the arguments passed by StartService(), so it's  
-     * time to _prepend_ the default arguments for the server from 
+     * call appended the arguments passed by StartService(), so it's
+     * time to _prepend_ the default arguments for the server from
      * the service's default arguments (all others override them)...
      */
     args->nalloc = args->nelts + svc_args->nelts;
@@ -658,16 +658,16 @@ apr_status_t mpm_merge_service_args(apr_pool_t *p,
 
     /* First three args (argv[0], -f, path) remain first */
     memcpy(cmb_data, args->elts, args->elt_size * fixed_args);
-    
+
     /* Service args follow from service registry array */
-    memcpy(cmb_data + fixed_args, svc_args->elts, 
+    memcpy(cmb_data + fixed_args, svc_args->elts,
            svc_args->elt_size * svc_args->nelts);
-    
+
     /* Remaining new args follow  */
     memcpy(cmb_data + fixed_args + svc_args->nelts,
-           (const char **)args->elts + fixed_args, 
+           (const char **)args->elts + fixed_args,
            args->elt_size * (args->nelts - fixed_args));
-    
+
     args->elts = (char *)cmb_data;
     args->nelts = args->nalloc;
 
@@ -720,7 +720,7 @@ apr_status_t mpm_service_to_start(const char **display_name, apr_pool_t *p)
                          0, FALSE, DUPLICATE_SAME_ACCESS)) {
         return APR_ENOTHREAD;
     }
-    
+
     if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
     {
         globdat.service_init = CreateEvent(NULL, FALSE, FALSE, NULL);
@@ -729,12 +729,12 @@ apr_status_t mpm_service_to_start(const char **display_name, apr_pool_t *p)
              return APR_EGENERAL;
         }
 
-        globdat.service_thread = CreateThread(NULL, 0, service_nt_dispatch_thread, 
+        globdat.service_thread = CreateThread(NULL, 0, service_nt_dispatch_thread,
                                               NULL, 0, &globdat.service_thread_id);
     }
     else /* osver.dwPlatformId != VER_PLATFORM_WIN32_NT */
     {
-        if (!RegisterServiceProcess(0, 1)) 
+        if (!RegisterServiceProcess(0, 1))
             return GetLastError();
 
         globdat.service_init = CreateEvent(NULL, FALSE, FALSE, NULL);
@@ -742,7 +742,7 @@ apr_status_t mpm_service_to_start(const char **display_name, apr_pool_t *p)
             return APR_EGENERAL;
         }
 
-        globdat.service_thread = CreateThread(NULL, 0, monitor_service_9x_thread, 
+        globdat.service_thread = CreateThread(NULL, 0, monitor_service_9x_thread,
                                               (LPVOID) mpm_service_name, 0,
                                               &globdat.service_thread_id);
     }
@@ -760,7 +760,7 @@ apr_status_t mpm_service_to_start(const char **display_name, apr_pool_t *p)
     }
 
     atexit(service_stopped);
-    *display_name = mpm_display_name; 
+    *display_name = mpm_display_name;
     return APR_SUCCESS;
 }
 
@@ -787,7 +787,7 @@ void mpm_service_stopping(void)
 }
 
 
-apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc, 
+apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
                                  const char * const * argv, int reconfig)
 {
     char key_name[MAX_PATH];
@@ -795,7 +795,7 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
     char *launch_cmd;
     ap_regkey_t *key;
     apr_status_t rv;
-    
+
     fprintf(stderr,reconfig ? "Reconfiguring the %s service\n"
                    : "Installing the %s service\n", mpm_display_name);
 
@@ -826,22 +826,22 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
 
         if (reconfig) {
             /* ###: utf-ize */
-            schService = OpenService(schSCManager, mpm_service_name, 
+            schService = OpenService(schSCManager, mpm_service_name,
                                      SERVICE_CHANGE_CONFIG);
             if (!schService) {
-                ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_ERR, 
+                ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_ERR,
                              apr_get_os_error(), NULL,
                              "OpenService failed");
             }
             /* ###: utf-ize */
-            else if (!ChangeServiceConfig(schService, 
+            else if (!ChangeServiceConfig(schService,
                                           SERVICE_WIN32_OWN_PROCESS,
                                           SERVICE_AUTO_START,
                                           SERVICE_ERROR_NORMAL,
-                                          launch_cmd, NULL, NULL, 
+                                          launch_cmd, NULL, NULL,
                                           "Tcpip\0Afd\0", NULL, NULL,
                                           mpm_display_name)) {
-                ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_ERR, 
+                ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_ERR,
                              apr_get_os_error(), NULL,
                              "ChangeServiceConfig failed");
                 /* !schService aborts configuration below */
@@ -850,10 +850,10 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
             }
         }
         else {
-            /* RPCSS is the Remote Procedure Call (RPC) Locator required 
-             * for DCOM communication pipes.  I am far from convinced we 
-             * should add this to the default service dependencies, but 
-             * be warned that future apache modules or ISAPI dll's may 
+            /* RPCSS is the Remote Procedure Call (RPC) Locator required
+             * for DCOM communication pipes.  I am far from convinced we
+             * should add this to the default service dependencies, but
+             * be warned that future apache modules or ISAPI dll's may
              * depend on it.
              */
             /* ###: utf-ize */
@@ -871,61 +871,61 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
                                    NULL,                 // use SYSTEM account
                                    NULL);                // no password
 
-            if (!schService) 
+            if (!schService)
             {
                 rv = apr_get_os_error();
-                ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, 
+                ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
                              "Failed to create WinNT Service Profile");
                 CloseServiceHandle(schSCManager);
                 return (rv);
             }
         }
-        
+
         CloseServiceHandle(schService);
         CloseServiceHandle(schSCManager);
     }
     else /* osver.dwPlatformId != VER_PLATFORM_WIN32_NT */
     {
         /* Store the launch command in the registry */
-        launch_cmd = apr_psprintf(ptemp, "\"%s\" -n %s -k runservice", 
+        launch_cmd = apr_psprintf(ptemp, "\"%s\" -n %s -k runservice",
                                  exe_path, mpm_service_name);
-        rv = ap_regkey_open(&key, AP_REGKEY_LOCAL_MACHINE, SERVICECONFIG9X, 
+        rv = ap_regkey_open(&key, AP_REGKEY_LOCAL_MACHINE, SERVICECONFIG9X,
                             APR_READ | APR_WRITE | APR_CREATE, pconf);
         if (rv == APR_SUCCESS) {
-            rv = ap_regkey_value_set(key, mpm_service_name, 
+            rv = ap_regkey_value_set(key, mpm_service_name,
                                      launch_cmd, 0, pconf);
             ap_regkey_close(key);
         }
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, 
-                         "%s: Failed to add the RunServices registry entry.", 
+            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+                         "%s: Failed to add the RunServices registry entry.",
                          mpm_display_name);
             return (rv);
         }
 
         apr_snprintf(key_name, sizeof(key_name), SERVICECONFIG, mpm_service_name);
-        rv = ap_regkey_open(&key, AP_REGKEY_LOCAL_MACHINE, key_name, 
+        rv = ap_regkey_open(&key, AP_REGKEY_LOCAL_MACHINE, key_name,
                             APR_READ | APR_WRITE | APR_CREATE, pconf);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, 
-                         "%s: Failed to create the registry service key.", 
+            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+                         "%s: Failed to create the registry service key.",
                          mpm_display_name);
             return (rv);
         }
         rv = ap_regkey_value_set(key, "ImagePath", launch_cmd, 0, pconf);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, 
-                         "%s: Failed to store ImagePath in the registry.", 
+            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+                         "%s: Failed to store ImagePath in the registry.",
                          mpm_display_name);
             ap_regkey_close(key);
             return (rv);
         }
-        rv = ap_regkey_value_set(key, "DisplayName", 
+        rv = ap_regkey_value_set(key, "DisplayName",
                                  mpm_display_name, 0, pconf);
         ap_regkey_close(key);
         if (rv != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, 
-                         "%s: Failed to store DisplayName in the registry.", 
+            ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+                         "%s: Failed to store DisplayName in the registry.",
                          mpm_display_name);
             return (rv);
         }
@@ -936,15 +936,15 @@ apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc,
     /* For both WinNT & Win9x store the service ConfigArgs in the registry...
      */
     apr_snprintf(key_name, sizeof(key_name), SERVICEPARAMS, mpm_service_name);
-    rv = ap_regkey_open(&key, AP_REGKEY_LOCAL_MACHINE, key_name, 
+    rv = ap_regkey_open(&key, AP_REGKEY_LOCAL_MACHINE, key_name,
                         APR_READ | APR_WRITE | APR_CREATE, pconf);
     if (rv == APR_SUCCESS) {
         rv = ap_regkey_value_array_set(key, "ConfigArgs", argc, argv, pconf);
         ap_regkey_close(key);
     }
     if (rv != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, 
-                     "%s: Failed to store the ConfigArgs in the registry.", 
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
+                     "%s: Failed to store the ConfigArgs in the registry.",
                      mpm_display_name);
         return (rv);
     }
@@ -973,7 +973,7 @@ apr_status_t mpm_service_uninstall(void)
                          "Failed to open the WinNT service manager.");
             return (rv);
         }
-        
+
         /* ###: utf-ize */
         schService = OpenService(schSCManager, mpm_service_name, DELETE);
 
@@ -983,7 +983,7 @@ apr_status_t mpm_service_uninstall(void)
                         "%s: OpenService failed", mpm_display_name);
            return (rv);
         }
-        
+
         /* assure the service is stopped before continuing
          *
          * This may be out of order... we might not be able to be
@@ -1000,8 +1000,8 @@ apr_status_t mpm_service_uninstall(void)
                          "%s: Failed to delete the service.", mpm_display_name);
             return (rv);
         }
-        
-        CloseServiceHandle(schService);        
+
+        CloseServiceHandle(schService);
         CloseServiceHandle(schSCManager);
     }
     else /* osver.dwPlatformId != VER_PLATFORM_WIN32_NT */
@@ -1012,7 +1012,7 @@ apr_status_t mpm_service_uninstall(void)
 
         /* TODO: assure the service is stopped before continuing */
 
-        rv = ap_regkey_open(&key, AP_REGKEY_LOCAL_MACHINE, SERVICECONFIG9X, 
+        rv = ap_regkey_open(&key, AP_REGKEY_LOCAL_MACHINE, SERVICECONFIG9X,
                             APR_READ | APR_WRITE | APR_CREATE, pconf);
         if (rv == APR_SUCCESS) {
             rv = ap_regkey_value_remove(key, mpm_service_name, pconf);
@@ -1023,7 +1023,7 @@ apr_status_t mpm_service_uninstall(void)
                          "%s: Failed to remove the RunServices registry "
                          "entry.", mpm_display_name);
         }
-        
+
         /* we blast Services/us, not just the Services/us/Parameters branch */
         apr_snprintf(key_name, sizeof(key_name), SERVICEPARAMS, mpm_service_name);
         rv2 = ap_regkey_remove(AP_REGKEY_LOCAL_MACHINE, key_name, pconf);
@@ -1046,31 +1046,31 @@ apr_status_t mpm_service_uninstall(void)
 
 /* signal_service_transition is a simple thunk to signal the service
  * and monitor its successful transition.  If the signal passed is 0,
- * then the caller is assumed to already have performed some service 
+ * then the caller is assumed to already have performed some service
  * operation to be monitored (such as StartService), and no actual
  * ControlService signal is sent.
  */
 
 static int signal_service_transition(SC_HANDLE schService, DWORD signal, DWORD pending, DWORD complete)
 {
-    if (signal && !ControlService(schService, signal, &globdat.ssStatus)) 
+    if (signal && !ControlService(schService, signal, &globdat.ssStatus))
         return FALSE;
-    
+
     do {
-        Sleep(1000);    
+        Sleep(1000);
         if (!QueryServiceStatus(schService, &globdat.ssStatus))
             return FALSE;
     } while (globdat.ssStatus.dwCurrentState == pending);
-        
+
     return (globdat.ssStatus.dwCurrentState == complete);
 }
 
 
-apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc, 
+apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
                                const char * const * argv)
 {
     apr_status_t rv;
-    
+
     fprintf(stderr,"Starting the %s service\n", mpm_display_name);
 
     if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
@@ -1089,7 +1089,7 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
         }
 
         /* ###: utf-ize */
-        schService = OpenService(schSCManager, mpm_service_name, 
+        schService = OpenService(schSCManager, mpm_service_name,
                                  SERVICE_START | SERVICE_QUERY_STATUS);
         if (!schService) {
             rv = apr_get_os_error();
@@ -1107,7 +1107,7 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
             CloseServiceHandle(schSCManager);
             return 0;
         }
-        
+
         start_argv = malloc((argc + 1) * sizeof(const char **));
         memcpy(start_argv, argv, argc * sizeof(const char **));
         start_argv[argc] = NULL;
@@ -1116,13 +1116,13 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
         /* ###: utf-ize */
         if (StartService(schService, argc, start_argv)
             && signal_service_transition(schService, 0, /* test only */
-                                         SERVICE_START_PENDING, 
+                                         SERVICE_START_PENDING,
                                          SERVICE_RUNNING))
                 rv = APR_SUCCESS;
 
         if (rv != APR_SUCCESS)
             rv = apr_get_os_error();
-        
+
         CloseServiceHandle(schService);
         CloseServiceHandle(schSCManager);
     }
@@ -1150,7 +1150,7 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
          * console window.
          * The config is pre-flighted, so there should be no danger of failure.
          */
-        
+
         if (GetModuleFileName(NULL, exe_path, sizeof(exe_path)) == 0)
         {
             apr_status_t rv = apr_get_os_error();
@@ -1158,27 +1158,27 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
                          "GetModuleFileName failed");
             return rv;
         }
-        
-        apr_snprintf(exe_cmd, sizeof(exe_cmd), 
-                     "\"%s\" -n %s -k runservice", 
-                     exe_path, mpm_service_name);  
+
+        apr_snprintf(exe_cmd, sizeof(exe_cmd),
+                     "\"%s\" -n %s -k runservice",
+                     exe_path, mpm_service_name);
         next_arg = strchr(exe_cmd, '\0');
         for (i = 0; i < argc; ++i) {
-            apr_snprintf(next_arg, sizeof(exe_cmd) - (next_arg - exe_cmd), 
+            apr_snprintf(next_arg, sizeof(exe_cmd) - (next_arg - exe_cmd),
                          " \"%s\"", argv[i]);
             next_arg = strchr(exe_cmd, '\0');
         }
-        
+
         memset(&si, 0, sizeof(si));
         memset(&pi, 0, sizeof(pi));
         si.cb = sizeof(si);
         si.dwFlags     = STARTF_USESHOWWINDOW;
         si.wShowWindow = SW_HIDE;   /* This might be redundant */
-        
+
         rv = APR_EINIT;
-        if (CreateProcess(NULL, exe_cmd, NULL, NULL, FALSE, 
+        if (CreateProcess(NULL, exe_cmd, NULL, NULL, FALSE,
                            DETACHED_PROCESS, /* Creation flags */
-                           NULL, NULL, &si, &pi)) 
+                           NULL, NULL, &si, &pi))
         {
             DWORD code;
             while (GetExitCodeProcess(pi.hProcess, &code) == STILL_ACTIVE) {
@@ -1189,13 +1189,13 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
                 Sleep (1000);
             }
         }
-        
+
         if (rv != APR_SUCCESS)
             rv = apr_get_os_error();
-        
+
         CloseHandle(pi.hProcess);
         CloseHandle(pi.hThread);
-    }    
+    }
 
     if (rv == APR_SUCCESS)
         fprintf(stderr,"The %s service is running.\n", mpm_display_name);
@@ -1203,7 +1203,7 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                      "%s: Failed to start the service process.",
                      mpm_display_name);
-        
+
     return rv;
 }
 
@@ -1213,15 +1213,15 @@ apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc,
 void mpm_signal_service(apr_pool_t *ptemp, int signal)
 {
     int success = FALSE;
-    
-    if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT) 
+
+    if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
     {
         SC_HANDLE   schService;
         SC_HANDLE   schSCManager;
 
         schSCManager = OpenSCManager(NULL, NULL, // default machine & database
                                      SC_MANAGER_CONNECT);
-        
+
         if (!schSCManager) {
             ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), NULL,
                          "Failed to open the NT Service Manager");
@@ -1229,8 +1229,8 @@ void mpm_signal_service(apr_pool_t *ptemp, int signal)
         }
 
         /* ###: utf-ize */
-        schService = OpenService(schSCManager, mpm_service_name, 
-                                 SERVICE_INTERROGATE | SERVICE_QUERY_STATUS | 
+        schService = OpenService(schSCManager, mpm_service_name,
+                                 SERVICE_INTERROGATE | SERVICE_QUERY_STATUS |
                                  SERVICE_USER_DEFINED_CONTROL |
                                  SERVICE_START | SERVICE_STOP);
 
@@ -1241,7 +1241,7 @@ void mpm_signal_service(apr_pool_t *ptemp, int signal)
             CloseServiceHandle(schSCManager);
             return;
         }
-        
+
         if (!QueryServiceStatus(schService, &globdat.ssStatus)) {
             ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, apr_get_os_error(), NULL,
                          "Query of Service %s failed", mpm_display_name);
@@ -1256,14 +1256,14 @@ void mpm_signal_service(apr_pool_t *ptemp, int signal)
             CloseServiceHandle(schSCManager);
             return;
         }
-        
-        fprintf(stderr,"The %s service is %s.\n", mpm_display_name, 
+
+        fprintf(stderr,"The %s service is %s.\n", mpm_display_name,
                signal ? "restarting" : "stopping");
 
         if (!signal)
-            success = signal_service_transition(schService, 
-                                                SERVICE_CONTROL_STOP, 
-                                                SERVICE_STOP_PENDING, 
+            success = signal_service_transition(schService,
+                                                SERVICE_CONTROL_STOP,
+                                                SERVICE_STOP_PENDING,
                                                 SERVICE_STOPPED);
         else if (globdat.ssStatus.dwCurrentState == SERVICE_STOPPED) {
             mpm_service_start(ptemp, 0, NULL);
@@ -1272,9 +1272,9 @@ void mpm_signal_service(apr_pool_t *ptemp, int signal)
             return;
         }
         else
-            success = signal_service_transition(schService, 
-                                                SERVICE_APACHE_RESTART, 
-                                                SERVICE_START_PENDING, 
+            success = signal_service_transition(schService,
+                                                SERVICE_APACHE_RESTART,
+                                                SERVICE_START_PENDING,
                                                 SERVICE_RUNNING);
 
         CloseServiceHandle(schService);
@@ -1300,13 +1300,13 @@ void mpm_signal_service(apr_pool_t *ptemp, int signal)
             }
         }
 
-        fprintf(stderr,"The %s service is %s.\n", mpm_display_name, 
+        fprintf(stderr,"The %s service is %s.\n", mpm_display_name,
                signal ? "restarting" : "stopping");
 
         apr_snprintf(prefix, sizeof(prefix), "ap%ld", (long)service_pid);
         setup_signal_names(prefix);
 
-        if (!signal) 
+        if (!signal)
         {
             int ticks = 60;
             ap_signal_parent(SIGNAL_PARENT_SHUTDOWN);
@@ -1320,7 +1320,7 @@ void mpm_signal_service(apr_pool_t *ptemp, int signal)
             }
         }
         else /* !stop */
-        {   
+        {
             /* TODO: Aught to add a little test to the restart logic, and
              * store the restart counter in the window's user dword.
              * Then we can hang on and report a successful restart.  But
@@ -1338,9 +1338,9 @@ void mpm_signal_service(apr_pool_t *ptemp, int signal)
     }
 
     if (success)
-        fprintf(stderr,"The %s service has %s.\n", mpm_display_name, 
+        fprintf(stderr,"The %s service has %s.\n", mpm_display_name,
                signal ? "restarted" : "stopped");
     else
-        fprintf(stderr,"Failed to %s the %s service.\n", 
+        fprintf(stderr,"Failed to %s the %s service.\n",
                signal ? "restart" : "stop", mpm_display_name);
 }
diff --git a/server/mpm/worker/fdqueue.c b/server/mpm/worker/fdqueue.c
index 155e3ec..39274dd 100644
--- a/server/mpm/worker/fdqueue.c
+++ b/server/mpm/worker/fdqueue.c
@@ -233,7 +233,7 @@ apr_status_t ap_queue_info_term(fd_queue_info_t *queue_info)
  * Callback routine that is called to destroy this
  * fd_queue_t when its pool is destroyed.
  */
-static apr_status_t ap_queue_destroy(void *data) 
+static apr_status_t ap_queue_destroy(void *data)
 {
     fd_queue_t *queue = data;
 
@@ -276,7 +276,7 @@ apr_status_t ap_queue_init(fd_queue_t *queue, int queue_capacity, apr_pool_t *a)
 }
 
 /**
- * Push a new socket onto the queue. 
+ * Push a new socket onto the queue.
  *
  * precondition: ap_queue_info_wait_for_idler has already been called
  *               to reserve an idle worker thread
@@ -340,7 +340,7 @@ apr_status_t ap_queue_pop(fd_queue_t *queue, apr_socket_t **sd, apr_pool_t **p)
                 return APR_EINTR;
             }
         }
-    } 
+    }
 
     elem = &queue->data[--queue->nelts];
     *sd = elem->sd;
@@ -357,7 +357,7 @@ apr_status_t ap_queue_pop(fd_queue_t *queue, apr_socket_t **sd, apr_pool_t **p)
 apr_status_t ap_queue_interrupt_all(fd_queue_t *queue)
 {
     apr_status_t rv;
-    
+
     if ((rv = apr_thread_mutex_lock(queue->one_big_mutex)) != APR_SUCCESS) {
         return rv;
     }
@@ -373,7 +373,7 @@ apr_status_t ap_queue_term(fd_queue_t *queue)
         return rv;
     }
     /* we must hold one_big_mutex when setting this... otherwise,
-     * we could end up setting it and waking everybody up just after a 
+     * we could end up setting it and waking everybody up just after a
      * would-be popper checks it but right before they block
      */
     queue->terminated = 1;
diff --git a/server/mpm/worker/pod.c b/server/mpm/worker/pod.c
index 5c7ccee..a6393ea 100644
--- a/server/mpm/worker/pod.c
+++ b/server/mpm/worker/pod.c
@@ -33,7 +33,7 @@ AP_DECLARE(apr_status_t) ap_mpm_pod_open(apr_pool_t *p, ap_pod_t **pod)
     apr_file_pipe_timeout_set((*pod)->pod_in, 0);
 */
     (*pod)->p = p;
-    
+
     /* close these before exec. */
     apr_file_inherit_unset((*pod)->pod_in);
     apr_file_inherit_unset((*pod)->pod_out);
diff --git a/server/mpm/worker/worker.c b/server/mpm/worker/worker.c
index e0d0830..87b910f 100644
--- a/server/mpm/worker/worker.c
+++ b/server/mpm/worker/worker.c
@@ -40,7 +40,7 @@
 #include <sys/socket.h>
 #endif
 #if APR_HAVE_SYS_WAIT_H
-#include <sys/wait.h> 
+#include <sys/wait.h>
 #endif
 #ifdef HAVE_SYS_PROCESSOR_H
 #include <sys/processor.h> /* for bindprocessor() */
@@ -50,20 +50,20 @@
 #error The Worker MPM requires APR threads, but they are unavailable.
 #endif
 
-#define CORE_PRIVATE 
- 
+#define CORE_PRIVATE
+
 #include "ap_config.h"
-#include "httpd.h" 
-#include "http_main.h" 
-#include "http_log.h" 
-#include "http_config.h"        /* for read_config */ 
-#include "http_core.h"          /* for get_remote_host */ 
+#include "httpd.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "http_config.h"        /* for read_config */
+#include "http_core.h"          /* for get_remote_host */
 #include "http_connection.h"
 #include "ap_mpm.h"
 #include "pod.h"
 #include "mpm_common.h"
 #include "ap_listen.h"
-#include "scoreboard.h" 
+#include "scoreboard.h"
 #include "fdqueue.h"
 #include "mpm_default.h"
 
@@ -100,7 +100,7 @@
  * the overhead.
  */
 #ifndef DEFAULT_THREAD_LIMIT
-#define DEFAULT_THREAD_LIMIT 64 
+#define DEFAULT_THREAD_LIMIT 64
 #endif
 
 /* Admin can't tune ThreadLimit beyond MAX_THREAD_LIMIT.  We want
@@ -143,7 +143,7 @@ typedef struct {
     int sd;
 } proc_info;
 
-/* Structure used to pass information to the thread responsible for 
+/* Structure used to pass information to the thread responsible for
  * creating the rest of the threads.
  */
 typedef struct {
@@ -157,8 +157,8 @@ typedef struct {
 
 /*
  * The max child slot ever assigned, preserved across restarts.  Necessary
- * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We 
- * use this value to optimize routines that have to scan the entire 
+ * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We
+ * use this value to optimize routines that have to scan the entire
  * scoreboard.
  */
 int ap_max_daemons_limit = -1;
@@ -191,7 +191,7 @@ int raise_sigstop_flags;
 static apr_pool_t *pconf;                 /* Pool for config stuff */
 static apr_pool_t *pchild;                /* Pool for httpd child stuff */
 
-static pid_t ap_my_pid; /* Linux getpid() doesn't work except in main 
+static pid_t ap_my_pid; /* Linux getpid() doesn't work except in main
                            thread. Use this instead */
 static pid_t parent_pid;
 static apr_os_thread_t *listener_os_thread;
@@ -205,9 +205,9 @@ static apr_proc_mutex_t *accept_mutex;
 #define SAFE_ACCEPT(stmt) (stmt)
 #endif
 
-/* The LISTENER_SIGNAL signal will be sent from the main thread to the 
- * listener thread to wake it up for graceful termination (what a child 
- * process from an old generation does when the admin does "apachectl 
+/* The LISTENER_SIGNAL signal will be sent from the main thread to the
+ * listener thread to wake it up for graceful termination (what a child
+ * process from an old generation does when the admin does "apachectl
  * graceful").  This signal will be blocked in all threads of a child
  * process except for the listener thread.
  */
@@ -227,13 +227,13 @@ static void close_worker_sockets(void)
         }
     }
 }
-  
+
 static void wakeup_listener(void)
 {
     listener_may_exit = 1;
     if (!listener_os_thread) {
         /* XXX there is an obscure path that this doesn't handle perfectly:
-         *     right after listener thread is created but before 
+         *     right after listener thread is created but before
          *     listener_os_thread is set, the first worker thread hits an
          *     error and starts graceful termination
          */
@@ -241,7 +241,7 @@ static void wakeup_listener(void)
     }
     /*
      * we should just be able to "kill(ap_my_pid, LISTENER_SIGNAL)" on all
-     * platforms and wake up the listener thread since it is the only thread 
+     * platforms and wake up the listener thread since it is the only thread
      * with SIGHUP unblocked, but that doesn't work on Linux
      */
 #ifdef HAVE_PTHREAD_KILL
@@ -306,7 +306,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
         case AP_MPMQ_MIN_SPARE_DAEMONS:
             *result = 0;
             return APR_SUCCESS;
-        case AP_MPMQ_MIN_SPARE_THREADS:    
+        case AP_MPMQ_MIN_SPARE_THREADS:
             *result = min_spare_threads;
             return APR_SUCCESS;
         case AP_MPMQ_MAX_SPARE_DAEMONS:
@@ -328,7 +328,7 @@ AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
     return APR_ENOTIMPL;
 }
 
-/* a clean exit from a child with proper cleanup */ 
+/* a clean exit from a child with proper cleanup */
 static void clean_child_exit(int code) __attribute__ ((noreturn));
 static void clean_child_exit(int code)
 {
@@ -357,8 +357,8 @@ ap_generation_t volatile ap_my_generation;
 
 /*
  * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
- * functions to initiate shutdown or restart without relying on signals. 
- * Previously this was initiated in sig_term() and restart() signal handlers, 
+ * functions to initiate shutdown or restart without relying on signals.
+ * Previously this was initiated in sig_term() and restart() signal handlers,
  * but we want to be able to start a shutdown/restart from other sources --
  * e.g. on Win32, from the service manager. Now the service manager can
  * call ap_start_shutdown() or ap_start_restart() as appropiate.  Note that
@@ -426,47 +426,47 @@ static void set_signals(void)
 
     sa.sa_handler = sig_term;
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGTERM)");
 #ifdef AP_SIG_GRACEFUL_STOP
     if (sigaction(AP_SIG_GRACEFUL_STOP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(" AP_SIG_GRACEFUL_STOP_STRING ")");
 #endif
 #ifdef SIGINT
     if (sigaction(SIGINT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGINT)");
 #endif
 #ifdef SIGXCPU
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXCPU, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGXCPU)");
 #endif
 #ifdef SIGXFSZ
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXFSZ, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGXFSZ)");
 #endif
 #ifdef SIGPIPE
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGPIPE, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGPIPE)");
 #endif
 
-    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy 
+    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy
      * processing one */
     sigaddset(&sa.sa_mask, SIGHUP);
     sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
     sa.sa_handler = restart;
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(SIGHUP)");
     if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
                      "sigaction(" AP_SIG_GRACEFUL_STRING ")");
 #else
     if (!one_process) {
@@ -544,16 +544,16 @@ static void check_infinite_requests(void)
     else {
         /* wow! if you're executing this code, you may have set a record.
          * either this child process has served over 2 billion requests, or
-         * you're running a threaded 2.0 on a 16 bit machine.  
+         * you're running a threaded 2.0 on a 16 bit machine.
          *
          * I'll buy pizza and beers at Apachecon for the first person to do
          * the former without cheating (dorking with INT_MAX, or running with
-         * uncommitted performance patches, for example).    
+         * uncommitted performance patches, for example).
          *
          * for the latter case, you probably deserve a beer too.   Greg Ames
          */
-            
-        requests_this_child = INT_MAX;      /* keep going */ 
+
+        requests_this_child = INT_MAX;      /* keep going */
     }
 }
 
@@ -640,7 +640,7 @@ static void *listener_thread(apr_thread_t *thd, void * dummy)
             }
             have_idle_worker = 1;
         }
-            
+
         /* We've already decremented the idle worker count inside
          * ap_queue_info_wait_for_idler. */
 
@@ -651,7 +651,7 @@ static void *listener_thread(apr_thread_t *thd, void * dummy)
             if (listener_may_exit) {
                 break;
             }
-            if (ap_scoreboard_image->parent[process_slot].generation != 
+            if (ap_scoreboard_image->parent[process_slot].generation !=
                 ap_scoreboard_image->global->running_generation) {
                 level = APLOG_DEBUG; /* common to get these at restart time */
             }
@@ -742,7 +742,7 @@ static void *listener_thread(apr_thread_t *thd, void * dummy)
                 if (listener_may_exit) {
                     break;
                 }
-                if (ap_scoreboard_image->parent[process_slot].generation != 
+                if (ap_scoreboard_image->parent[process_slot].generation !=
                     ap_scoreboard_image->global->running_generation) {
                     level = APLOG_DEBUG; /* common to get these at restart time */
                 }
@@ -755,7 +755,7 @@ static void *listener_thread(apr_thread_t *thd, void * dummy)
                 rv = ap_queue_push(worker_queue, csd, ptrans);
                 if (rv) {
                     /* trash the connection; we couldn't queue the connected
-                     * socket to a worker 
+                     * socket to a worker
                      */
                     apr_socket_close(csd);
                     ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ap_server_conf,
@@ -771,7 +771,7 @@ static void *listener_thread(apr_thread_t *thd, void * dummy)
                 != APR_SUCCESS) {
                 int level = APLOG_EMERG;
 
-                if (ap_scoreboard_image->parent[process_slot].generation != 
+                if (ap_scoreboard_image->parent[process_slot].generation !=
                     ap_scoreboard_image->global->running_generation) {
                     level = APLOG_DEBUG; /* common to get these at restart time */
                 }
@@ -980,14 +980,14 @@ static void * APR_THREAD_FUNC start_threads(apr_thread_t *thd, void *dummy)
             my_info->pid = my_child_num;
             my_info->tid = i;
             my_info->sd = 0;
-        
+
             /* We are creating threads right now */
             ap_update_child_status_from_indexes(my_child_num, i,
                                                 SERVER_STARTING, NULL);
             /* We let each thread update its own scoreboard entry.  This is
              * done because it lets us deal with tid better.
              */
-            rv = apr_thread_create(&threads[i], thread_attr, 
+            rv = apr_thread_create(&threads[i], thread_attr,
                                    worker_thread, my_info, pchild);
             if (rv != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,
@@ -1018,15 +1018,15 @@ static void * APR_THREAD_FUNC start_threads(apr_thread_t *thd, void *dummy)
             prev_threads_created = threads_created;
         }
     }
-    
-    /* What state should this child_main process be listed as in the 
+
+    /* What state should this child_main process be listed as in the
      * scoreboard...?
-     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING, 
+     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING,
      *                                      (request_rec *) NULL);
-     * 
+     *
      *  This state should be listed separately in the scoreboard, in some kind
-     *  of process_status, not mixed in with the worker threads' status.   
-     *  "life_status" is almost right, but it's in the worker's structure, and 
+     *  of process_status, not mixed in with the worker threads' status.
+     *  "life_status" is almost right, but it's in the worker's structure, and
      *  the name could be clearer.   gla
      */
     apr_thread_exit(thd, APR_SUCCESS);
@@ -1040,7 +1040,7 @@ static void join_workers(apr_thread_t *listener, apr_thread_t **threads)
 
     if (listener) {
         int iter;
-        
+
         /* deal with a rare timing window which affects waking up the
          * listener thread...  if the signal sent to the listener thread
          * is delivered between the time it verifies that the
@@ -1050,7 +1050,7 @@ static void join_workers(apr_thread_t *listener, apr_thread_t **threads)
          */
 
         iter = 0;
-        while (iter < 10 && 
+        while (iter < 10 &&
 #ifdef HAVE_PTHREAD_KILL
                pthread_kill(*listener_os_thread, 0)
 #else
@@ -1074,7 +1074,7 @@ static void join_workers(apr_thread_t *listener, apr_thread_t **threads)
             }
         }
     }
-    
+
     for (i = 0; i < ap_threads_per_child; i++) {
         if (threads[i]) { /* if we ever created this thread */
             rv = apr_thread_join(&thread_rv, threads[i]);
@@ -1092,8 +1092,8 @@ static void join_start_thread(apr_thread_t *start_thread_id)
 {
     apr_status_t rv, thread_rv;
 
-    start_thread_may_exit = 1; /* tell it to give up in case it is still 
-                                * trying to take over slots from a 
+    start_thread_may_exit = 1; /* tell it to give up in case it is still
+                                * trying to take over slots from a
                                 * previous generation
                                 */
     rv = apr_thread_join(&thread_rv, start_thread_id);
@@ -1156,13 +1156,13 @@ static void child_main(int child_num_arg)
         /* coding a value of zero means infinity */
         requests_this_child = INT_MAX;
     }
-    
+
     /* Setup worker threads */
 
-    /* clear the storage; we may not create all our threads immediately, 
+    /* clear the storage; we may not create all our threads immediately,
      * and we want a 0 entry to indicate a thread which was not created
      */
-    threads = (apr_thread_t **)calloc(1, 
+    threads = (apr_thread_t **)calloc(1,
                                 sizeof(apr_thread_t *) * ap_threads_per_child);
     if (threads == NULL) {
         ap_log_error(APLOG_MARK, APLOG_ALERT, errno, ap_server_conf,
@@ -1179,7 +1179,7 @@ static void child_main(int child_num_arg)
     if (ap_thread_stacksize != 0) {
         apr_threadattr_stacksize_set(thread_attr, ap_thread_stacksize);
     }
-    
+
     ts->threads = threads;
     ts->listener = NULL;
     ts->child_num_arg = child_num_arg;
@@ -1201,7 +1201,7 @@ static void child_main(int child_num_arg)
     if (one_process) {
         /* Block until we get a terminating signal. */
         apr_signal_thread(check_signal);
-        /* make sure the start thread has finished; signal_threads() 
+        /* make sure the start thread has finished; signal_threads()
          * and join_workers() depend on that
          */
         /* XXX join_start_thread() won't be awakened if one of our
@@ -1244,7 +1244,7 @@ static void child_main(int child_num_arg)
                 }
             }
             if (rv == AP_GRACEFUL || rv == AP_RESTART) {
-                /* make sure the start thread has finished; 
+                /* make sure the start thread has finished;
                  * signal_threads() and join_workers depend on that
                  */
                 join_start_thread(start_thread_id);
@@ -1268,7 +1268,7 @@ static void child_main(int child_num_arg)
     clean_child_exit(resource_shortage ? APEXIT_CHILDSICK : 0);
 }
 
-static int make_child(server_rec *s, int slot) 
+static int make_child(server_rec *s, int slot)
 {
     int pid;
 
@@ -1283,7 +1283,7 @@ static int make_child(server_rec *s, int slot)
     }
 
     if ((pid = fork()) == -1) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, 
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s,
                      "fork: Unable to fork new process");
 
         /* fork didn't succeed. Fix the scoreboard or else
@@ -1307,7 +1307,7 @@ static int make_child(server_rec *s, int slot)
         int status = bindprocessor(BINDPROCESS, (int)getpid(),
                                PROCESSOR_CLASS_ANY);
         if (status != OK)
-            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, 
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno,
                          ap_server_conf,
                          "processor unbind failed %d", status);
 #endif
@@ -1404,7 +1404,7 @@ static void perform_idle_server_maintenance(void)
             status = ws->status;
 
             /* XXX any_dying_threads is probably no longer needed    GLA */
-            any_dying_threads = any_dying_threads || 
+            any_dying_threads = any_dying_threads ||
                                 (status == SERVER_GRACEFUL);
             any_dead_threads = any_dead_threads || (status == SERVER_DEAD);
             all_dead_threads = all_dead_threads &&
@@ -1435,7 +1435,7 @@ static void perform_idle_server_maintenance(void)
                     || ps->quiescing)) {   /* or at least one is going away */
             if (all_dead_threads) {
                 /* great! we prefer these, because the new process can
-                 * start more threads sooner.  So prioritize this slot 
+                 * start more threads sooner.  So prioritize this slot
                  * by putting it ahead of any slots with active threads.
                  *
                  * first, make room by moving a slot that's potentially still
@@ -1466,7 +1466,7 @@ static void perform_idle_server_maintenance(void)
             sick_child_detected = 0;
         }
         else {
-            /* looks like a basket case.  give up.  
+            /* looks like a basket case.  give up.
              */
             shutdown_pending = 1;
             child_fatal = 1;
@@ -1478,7 +1478,7 @@ static void perform_idle_server_maintenance(void)
             return;
         }
     }
-                                                    
+
     ap_max_daemons_limit = last_non_dead + 1;
 
     if (idle_thread_count > max_spare_threads) {
@@ -1491,9 +1491,9 @@ static void perform_idle_server_maintenance(void)
         if (free_length == 0) {
             /* only report this condition once */
             static int reported = 0;
-            
+
             if (!reported) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, 0, 
+                ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                              ap_server_conf,
                              "server reached MaxClients setting, consider"
                              " raising the MaxClients setting");
@@ -1506,7 +1506,7 @@ static void perform_idle_server_maintenance(void)
                 free_length = idle_spawn_rate;
             }
             if (idle_spawn_rate >= 8) {
-                ap_log_error(APLOG_MARK, APLOG_INFO, 0, 
+                ap_log_error(APLOG_MARK, APLOG_INFO, 0,
                              ap_server_conf,
                              "server seems busy, (you may need "
                              "to increase StartServers, ThreadsPerChild "
@@ -1544,7 +1544,7 @@ static void server_main_loop(int remaining_children_to_start)
 
     while (!restart_pending && !shutdown_pending) {
         ap_wait_or_timeout(&exitwhy, &status, &pid, pconf);
-        
+
         if (pid.pid != -1) {
             processed_status = ap_process_child_status(&pid, exitwhy, status);
             if (processed_status == APEXIT_CHILDFATAL) {
@@ -1562,9 +1562,9 @@ static void server_main_loop(int remaining_children_to_start)
             child_slot = find_child_by_pid(&pid);
             if (child_slot >= 0) {
                 for (i = 0; i < ap_threads_per_child; i++)
-                    ap_update_child_status_from_indexes(child_slot, i, SERVER_DEAD, 
+                    ap_update_child_status_from_indexes(child_slot, i, SERVER_DEAD,
                                                         (request_rec *) NULL);
-                
+
                 ap_scoreboard_image->parent[child_slot].pid = 0;
                 ap_scoreboard_image->parent[child_slot].quiescing = 0;
                 if (processed_status == APEXIT_CHILDSICK) {
@@ -1638,13 +1638,13 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                      "ignored during restart");
         changed_limit_at_restart = 0;
     }
-    
+
     /* Initialize cross-process accept lock */
     ap_lock_fname = apr_psprintf(_pconf, "%s.%" APR_PID_T_FMT,
                                  ap_server_root_relative(_pconf, ap_lock_fname),
                                  ap_my_pid);
 
-    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname, 
+    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname,
                                ap_accept_lock_mech, _pconf);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1654,7 +1654,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
     }
 
 #if APR_USE_SYSVSEM_SERIALIZE
-    if (ap_accept_lock_mech == APR_LOCK_DEFAULT || 
+    if (ap_accept_lock_mech == APR_LOCK_DEFAULT ||
         ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
 #else
     if (ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
@@ -1720,7 +1720,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 #endif
     restart_pending = shutdown_pending = 0;
     mpm_state = AP_MPMQ_RUNNING;
-    
+
     server_main_loop(remaining_children_to_start);
     mpm_state = AP_MPMQ_STOPPING;
 
@@ -1740,7 +1740,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                              ap_server_conf,
                              "removed PID file %s (pid=%" APR_PID_T_FMT ")",
                              pidfile, getpid());
-    
+
             ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
                          ap_server_conf, "caught SIGTERM, shutting down");
         }
@@ -1767,7 +1767,7 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
                              ap_server_conf,
                              "removed PID file %s (pid=%" APR_PID_T_FMT ")",
                              pidfile, getpid());
-    
+
             ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
                          ap_server_conf, "caught SIGTERM, shutting down");
         }
@@ -1777,10 +1777,10 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
         do {
             /* Pause for a second */
             apr_sleep(apr_time_from_sec(1));
-                
+
             /* Relieve any children which have now exited */
             ap_relieve_child_processes();
-            
+
             active_children = 0;
             for (index = 0; index < ap_daemons_limit; ++index) {
                 if (MPM_CHILD_PID(index) != 0) {
@@ -1818,21 +1818,21 @@ int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
      */
     ++ap_my_generation;
     ap_scoreboard_image->global->running_generation = ap_my_generation;
-    
+
     if (is_graceful) {
         ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                      AP_SIG_GRACEFUL_STRING " received.  Doing graceful restart");
         /* wake up the children...time to die.  But we'll have more soon */
         ap_mpm_pod_killpg(pod, ap_daemons_limit, TRUE);
-    
+
 
         /* This is mostly for debugging... so that we know what is still
          * gracefully dealing with existing request.
          */
-        
+
     }
     else {
-        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM 
+        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM
          * and a SIGHUP, we may as well use the same signal, because some user
          * pthreads are stealing signals from us left and right.
          */
@@ -1872,7 +1872,7 @@ static int worker_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
     return OK;
 }
 
-static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog, 
+static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                              apr_pool_t *ptemp)
 {
     static int restart_num = 0;
@@ -1905,7 +1905,7 @@ static int worker_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                 pdir->args = max_clients->args;
                 pdir->filename = max_clients->filename;
                 pdir->line_num = max_clients->line_num;
-                
+
                 max_clients->directive = temp.directive;
                 max_clients->args = temp.args;
                 max_clients->filename = temp.filename;
@@ -1984,7 +1984,7 @@ static void worker_hooks(apr_pool_t *p)
 }
 
 static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy,
-                                        const char *arg) 
+                                        const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -2005,15 +2005,15 @@ static const char *set_min_spare_threads(cmd_parms *cmd, void *dummy,
 
     min_spare_threads = atoi(arg);
     if (min_spare_threads <= 0) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: detected MinSpareThreads set to non-positive.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Resetting to 1 to avoid almost certain Apache failure.");
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "Please read the documentation.");
        min_spare_threads = 1;
     }
-       
+
     return NULL;
 }
 
@@ -2030,7 +2030,7 @@ static const char *set_max_spare_threads(cmd_parms *cmd, void *dummy,
 }
 
 static const char *set_max_clients (cmd_parms *cmd, void *dummy,
-                                     const char *arg) 
+                                     const char *arg)
 {
     int max_clients;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
@@ -2042,47 +2042,47 @@ static const char *set_max_clients (cmd_parms *cmd, void *dummy,
      * sure that it gets set before MaxClients in the pre_config stage. */
     max_clients = atoi(arg);
     if (max_clients < ap_threads_per_child) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients (%d) must be at least as large",
                     max_clients);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " as ThreadsPerChild (%d). Automatically",
                     ap_threads_per_child);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " increasing MaxClients to %d.",
                     ap_threads_per_child);
        max_clients = ap_threads_per_child;
     }
     ap_daemons_limit = max_clients / ap_threads_per_child;
     if ((max_clients > 0) && (max_clients % ap_threads_per_child)) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients (%d) is not an integer multiple",
                     max_clients);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " of ThreadsPerChild (%d), lowering MaxClients to %d",
                     ap_threads_per_child,
                     ap_daemons_limit * ap_threads_per_child);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " for a maximum of %d child processes,",
                     ap_daemons_limit);
-       max_clients = ap_daemons_limit * ap_threads_per_child; 
+       max_clients = ap_daemons_limit * ap_threads_per_child;
     }
     if (ap_daemons_limit > server_limit) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: MaxClients of %d would require %d servers,",
                     max_clients, ap_daemons_limit);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " and would exceed the ServerLimit value of %d.",
                     server_limit);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " Automatically lowering MaxClients to %d.  To increase,",
                     server_limit * ap_threads_per_child);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " please see the ServerLimit directive.");
        ap_daemons_limit = server_limit;
-    } 
+    }
     else if (ap_daemons_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require MaxClients > 0, setting to 1");
         ap_daemons_limit = 1;
     }
@@ -2090,7 +2090,7 @@ static const char *set_max_clients (cmd_parms *cmd, void *dummy,
 }
 
 static const char *set_threads_per_child (cmd_parms *cmd, void *dummy,
-                                          const char *arg) 
+                                          const char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -2099,29 +2099,29 @@ static const char *set_threads_per_child (cmd_parms *cmd, void *dummy,
 
     ap_threads_per_child = atoi(arg);
     if (ap_threads_per_child > thread_limit) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
                      "value of %d", ap_threads_per_child,
                      thread_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "threads, lowering ThreadsPerChild to %d. To increase, please"
                      " see the", thread_limit);
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      " ThreadLimit directive.");
         ap_threads_per_child = thread_limit;
     }
     else if (ap_threads_per_child < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ThreadsPerChild > 0, setting to 1");
         ap_threads_per_child = 1;
     }
     return NULL;
 }
 
-static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     int tmp_server_limit;
-    
+
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -2141,27 +2141,27 @@ static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *ar
         return NULL;
     }
     server_limit = tmp_server_limit;
-    
+
     if (server_limit > MAX_SERVER_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: ServerLimit of %d exceeds compile time limit "
                     "of %d servers,", server_limit, MAX_SERVER_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering ServerLimit to %d.", MAX_SERVER_LIMIT);
        server_limit = MAX_SERVER_LIMIT;
-    } 
+    }
     else if (server_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ServerLimit > 0, setting to 1");
         server_limit = 1;
     }
     return NULL;
 }
 
-static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *arg)
 {
     int tmp_thread_limit;
-    
+
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
         return err;
@@ -2181,17 +2181,17 @@ static const char *set_thread_limit (cmd_parms *cmd, void *dummy, const char *ar
         return NULL;
     }
     thread_limit = tmp_thread_limit;
-    
+
     if (thread_limit > MAX_THREAD_LIMIT) {
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     "WARNING: ThreadLimit of %d exceeds compile time limit "
                     "of %d servers,", thread_limit, MAX_THREAD_LIMIT);
-       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                     " lowering ThreadLimit to %d.", MAX_THREAD_LIMIT);
        thread_limit = MAX_THREAD_LIMIT;
-    } 
+    }
     else if (thread_limit < 1) {
-        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
                      "WARNING: Require ThreadLimit > 0, setting to 1");
         thread_limit = 1;
     }
diff --git a/server/mpm_common.c b/server/mpm_common.c
index 163946b..b2ed87d 100644
--- a/server/mpm_common.c
+++ b/server/mpm_common.c
@@ -135,7 +135,7 @@ static int reclaim_one_pid(pid_t pid, action_t action)
     switch(action) {
     case DO_NOTHING:
         break;
-        
+
     case SEND_SIGTERM:
         /* ok, now it's being annoying */
         ap_log_error(APLOG_MARK, APLOG_WARNING,
@@ -146,7 +146,7 @@ static int reclaim_one_pid(pid_t pid, action_t action)
                      pid);
         kill(pid, SIGTERM);
         break;
-        
+
     case SEND_SIGKILL:
         ap_log_error(APLOG_MARK, APLOG_ERR,
                      0, ap_server_conf,
@@ -166,7 +166,7 @@ static int reclaim_one_pid(pid_t pid, action_t action)
         kill_thread(pid);
 #endif
         break;
-                
+
     case GIVEUP:
         /* gave it our best shot, but alas...  If this really
          * is a child we are trying to kill and it really hasn't
@@ -181,7 +181,7 @@ static int reclaim_one_pid(pid_t pid, action_t action)
                      pid);
         break;
     }
-    
+
     return 0;
 }
 
@@ -359,7 +359,7 @@ int ap_process_child_status(apr_proc_t *pid, apr_exit_why_e why, int status)
      * check for bad rc from us and exit, running any
      * appropriate cleanups.
      *
-     * If the child died due to a resource shortage, 
+     * If the child died due to a resource shortage,
      * the parent should limit the rate of forking
      */
     if (APR_PROC_CHECK_EXIT(why)) {
@@ -634,15 +634,15 @@ static apr_status_t dummy_connection(ap_pod_t *pod)
      * adminstrators can track down the cause of the odd-looking
      * requests in their logs.
      */
-    srequest = apr_pstrcat(p, "GET / HTTP/1.0\r\nUser-Agent: ", 
-                           ap_get_server_version(), 
+    srequest = apr_pstrcat(p, "GET / HTTP/1.0\r\nUser-Agent: ",
+                           ap_get_server_version(),
                            " (internal dummy connection)\r\n\r\n", NULL);
-    
-    /* Since some operating systems support buffering of data or entire 
-     * requests in the kernel, we send a simple request, to make sure 
-     * the server pops out of a blocking accept(). 
+
+    /* Since some operating systems support buffering of data or entire
+     * requests in the kernel, we send a simple request, to make sure
+     * the server pops out of a blocking accept().
      */
-    /* XXX: This is HTTP specific. We should look at the Protocol for each 
+    /* XXX: This is HTTP specific. We should look at the Protocol for each
      * listener, and send the correct type of request to trigger any Accept
      * Filters.
      */
@@ -775,7 +775,7 @@ const char *ap_mpm_set_coredumpdir(cmd_parms *cmd, void *dummy,
 
     fname = ap_server_root_relative(cmd->pool, arg);
     if (!fname) {
-        return apr_pstrcat(cmd->pool, "Invalid CoreDumpDirectory path ", 
+        return apr_pstrcat(cmd->pool, "Invalid CoreDumpDirectory path ",
                            arg, NULL);
     }
     if ((rv = apr_stat(&finfo, fname, APR_FINFO_TYPE, cmd->pool)) != APR_SUCCESS) {
@@ -902,7 +902,7 @@ int ap_signal_server(int *exit_status, apr_pool_t *pconf)
     int running = 0;
     int have_pid_file = 0;
     const char *status;
-    
+
     *exit_status = 0;
 
     rv = ap_read_pid(pconf, ap_pid_fname, &otherpid);
@@ -921,7 +921,7 @@ int ap_signal_server(int *exit_status, apr_pool_t *pconf)
         have_pid_file = 1;
         if (kill(otherpid, 0) == 0) {
             running = 1;
-            status = apr_psprintf(pconf, 
+            status = apr_psprintf(pconf,
                                   "httpd (pid %" APR_PID_T_FMT ") already "
                                   "running", otherpid);
         }
@@ -968,7 +968,7 @@ int ap_signal_server(int *exit_status, apr_pool_t *pconf)
             return 1;
         }
     }
-    
+
     if (!strcmp(dash_k_arg, "graceful-stop")) {
 #ifdef AP_MPM_WANT_SET_GRACEFUL_SHUTDOWN
         if (!running) {
@@ -1056,10 +1056,10 @@ const char *ap_mpm_set_max_mem_free(cmd_parms *cmd, void *dummy,
     if (err != NULL) {
         return err;
     }
-    
+
     value = strtol(arg, NULL, 0);
     if (value < 0 || errno == ERANGE)
-        return apr_pstrcat(cmd->pool, "Invalid MaxMemFree value: ", 
+        return apr_pstrcat(cmd->pool, "Invalid MaxMemFree value: ",
                            arg, NULL);
 
     ap_max_mem_free = (apr_uint32_t)value * 1024;
@@ -1080,10 +1080,10 @@ const char *ap_mpm_set_thread_stacksize(cmd_parms *cmd, void *dummy,
     if (err != NULL) {
         return err;
     }
-    
+
     value = strtol(arg, NULL, 0);
     if (value < 0 || errno == ERANGE)
-        return apr_pstrcat(cmd->pool, "Invalid ThreadStackSize value: ", 
+        return apr_pstrcat(cmd->pool, "Invalid ThreadStackSize value: ",
                            arg, NULL);
 
     ap_thread_stacksize = (apr_size_t)value;
@@ -1132,7 +1132,7 @@ static void run_fatal_exception_hook(int sig)
     ap_exception_info_t ei = {0};
 
     if (exception_hook_enabled &&
-        geteuid() != 0 && 
+        geteuid() != 0 &&
         my_pid != parent_pid) {
         ei.sig = sig;
         ei.pid = my_pid;
@@ -1189,7 +1189,7 @@ apr_status_t ap_fatal_signal_setup(server_rec *s, apr_pool_t *in_pconf)
     struct sigaction sa;
 
     sigemptyset(&sa.sa_mask);
-    
+
 #if defined(SA_ONESHOT)
     sa.sa_flags = SA_ONESHOT;
 #elif defined(SA_RESETHAND)
@@ -1219,7 +1219,7 @@ apr_status_t ap_fatal_signal_setup(server_rec *s, apr_pool_t *in_pconf)
 #endif
 
 #else /* NO_USE_SIGACTION */
-    
+
     apr_signal(SIGSEGV, sig_coredump);
 #ifdef SIGBUS
     apr_signal(SIGBUS, sig_coredump);
diff --git a/server/protocol.c b/server/protocol.c
index 7658ef6..f7f0a8c 100644
--- a/server/protocol.c
+++ b/server/protocol.c
@@ -224,30 +224,30 @@ AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t n,
         if (rv != APR_SUCCESS) {
             return rv;
         }
-        
+
         /* Something horribly wrong happened.  Someone didn't block! */
         if (APR_BRIGADE_EMPTY(bb)) {
             return APR_EGENERAL;
         }
-        
+
         for (e = APR_BRIGADE_FIRST(bb);
              e != APR_BRIGADE_SENTINEL(bb);
              e = APR_BUCKET_NEXT(e))
         {
             const char *str;
             apr_size_t len;
-            
+
             /* If we see an EOS, don't bother doing anything more. */
             if (APR_BUCKET_IS_EOS(e)) {
                 saw_eos = 1;
                 break;
             }
-            
+
             rv = apr_bucket_read(e, &str, &len, APR_BLOCK_READ);
             if (rv != APR_SUCCESS) {
                 return rv;
             }
-            
+
             if (len == 0) {
                 /* no use attempting a zero-byte alloc (hurts when
                  * using --with-efence --enable-pool-debug) or
@@ -255,7 +255,7 @@ AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t n,
                  */
                 continue;
             }
-            
+
             /* Would this overrun our buffer?  If so, we'll die. */
             if (n < bytes_handled + len) {
                 *read = bytes_handled;
@@ -270,7 +270,7 @@ AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t n,
                 }
                 return APR_ENOSPC;
             }
-            
+
             /* Do we have to handle the allocation ourselves? */
             if (do_alloc) {
                 /* We'll assume the common case where one bucket is enough. */
@@ -285,13 +285,13 @@ AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t n,
                     /* Increase the buffer size */
                     apr_size_t new_size = current_alloc * 2;
                     char *new_buffer;
-                    
+
                     if (bytes_handled + len > new_size) {
                         new_size = (bytes_handled + len) * 2;
                     }
-                    
+
                     new_buffer = apr_palloc(r->pool, new_size);
-                    
+
                     /* Copy what we already had. */
                     memcpy(new_buffer, *s, bytes_handled);
                     current_alloc = new_size;
@@ -303,18 +303,18 @@ AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t n,
             pos = *s + bytes_handled;
             memcpy(pos, str, len);
             last_char = pos + len - 1;
-            
+
             /* We've now processed that new data - update accordingly. */
             bytes_handled += len;
         }
-        
+
         /* If we got a full line of input, stop reading */
         if (last_char && (*last_char == APR_ASCII_LF)) {
             break;
         }
     }
 
-    /* Now NUL-terminate the string at the end of the line; 
+    /* Now NUL-terminate the string at the end of the line;
      * if the last-but-one character is a CR, terminate there */
     if (last_char > *s && last_char[-1] == APR_ASCII_CR) {
         last_char--;
@@ -331,34 +331,34 @@ AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t n,
             const char *str;
             apr_size_t len;
             char c;
-            
+
             /* Clear the temp brigade for this filter read. */
             apr_brigade_cleanup(bb);
-            
+
             /* We only care about the first byte. */
             rv = ap_get_brigade(r->input_filters, bb, AP_MODE_SPECULATIVE,
                                 APR_BLOCK_READ, 1);
             if (rv != APR_SUCCESS) {
                 return rv;
             }
-            
+
             if (APR_BRIGADE_EMPTY(bb)) {
                 break;
             }
-            
+
             e = APR_BRIGADE_FIRST(bb);
-            
+
             /* If we see an EOS, don't bother doing anything more. */
             if (APR_BUCKET_IS_EOS(e)) {
                 break;
             }
-            
+
             rv = apr_bucket_read(e, &str, &len, APR_BLOCK_READ);
             if (rv != APR_SUCCESS) {
                 apr_brigade_cleanup(bb);
                 return rv;
             }
-            
+
             /* Found one, so call ourselves again to get the next line.
              *
              * FIXME: If the folding line is completely blank, should we
@@ -381,7 +381,7 @@ AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t n,
                 else {
                     apr_size_t next_size, next_len;
                     char *tmp;
-                    
+
                     /* If we're doing the allocations for them, we have to
                      * give ourselves a NULL and copy it on return.
                      */
@@ -391,25 +391,25 @@ AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t n,
                         /* We're null terminated. */
                         tmp = last_char;
                     }
-                    
+
                     next_size = n - bytes_handled;
-                    
+
                     rv = ap_rgetline_core(&tmp, next_size,
                                           &next_len, r, 0, bb);
                     if (rv != APR_SUCCESS) {
                         return rv;
                     }
-                    
+
                     if (do_alloc && next_len > 0) {
                         char *new_buffer;
                         apr_size_t new_size = bytes_handled + next_len + 1;
-                        
+
                         /* we need to alloc an extra byte for a null */
                         new_buffer = apr_palloc(r->pool, new_size);
 
                         /* Copy what we already had. */
                         memcpy(new_buffer, *s, bytes_handled);
-                        
+
                         /* copy the new line, including the trailing null */
                         memcpy(new_buffer + bytes_handled, tmp, next_len + 1);
                         *s = new_buffer;
@@ -719,7 +719,7 @@ AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb
                      */
                     apr_table_setn(r->notes, "error-notes",
                                    apr_pstrcat(r->pool,
-                                               "Size of a request header field " 
+                                               "Size of a request header field "
                                                "after folding "
                                                "exceeds server limit.<br />\n"
                                                "<pre>\n",
@@ -765,7 +765,7 @@ AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb
                                                "</pre>\n", NULL));
                     return;
                 }
-                
+
                 tmp_field = value - 1; /* last character of field-name */
 
                 *value++ = '\0'; /* NUL-terminate at colon */
@@ -775,11 +775,11 @@ AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb
                 }
 
                 /* Strip LWS after field-name: */
-                while (tmp_field > last_field 
+                while (tmp_field > last_field
                        && (*tmp_field == ' ' || *tmp_field == '\t')) {
                     *tmp_field-- = '\0';
                 }
-                
+
                 /* Strip LWS after field-value: */
                 tmp_field = last_field + last_len - 1;
                 while (tmp_field > value
@@ -955,7 +955,7 @@ request_rec *ap_read_request(conn_rec *conn)
      */
     ap_update_vhost_from_headers(r);
 
-    /* Toggle to the Host:-based vhost's timeout mode to fetch the 
+    /* Toggle to the Host:-based vhost's timeout mode to fetch the
      * request body and send the response body, if needed.
      */
     if (cur_timeout != r->server->timeout) {
@@ -1044,7 +1044,7 @@ static void clone_headers_no_body(request_rec *rnew,
     apr_table_unset(rnew->headers_in, "Expires");
     apr_table_unset(rnew->headers_in, "Last-Modified");
     apr_table_unset(rnew->headers_in, "Transfer-Encoding");
-}        
+}
 
 /*
  * A couple of other functions which initialize some of the fields of
@@ -1307,13 +1307,13 @@ AP_CORE_DECLARE_NONSTD(apr_status_t) ap_content_length_filter(
          * by something like proxy.  the brigade only has an EOS bucket
          * in this case, making r->bytes_sent zero.
          *
-         * if r->bytes_sent > 0 we have a (temporary) body whose length may 
-         * have been changed by a filter.  the C-L header might not have been 
-         * updated so we do it here.  long term it would be cleaner to have 
-         * such filters update or remove the C-L header, and just use it 
+         * if r->bytes_sent > 0 we have a (temporary) body whose length may
+         * have been changed by a filter.  the C-L header might not have been
+         * updated so we do it here.  long term it would be cleaner to have
+         * such filters update or remove the C-L header, and just use it
          * if present.
          */
-        !(r->header_only && r->bytes_sent == 0 &&   
+        !(r->header_only && r->bytes_sent == 0 &&
             apr_table_get(r->headers_out, "Content-Length"))) {
         ap_set_content_length(r, r->bytes_sent);
     }
diff --git a/server/provider.c b/server/provider.c
index 00d6954..9bcabbb 100644
--- a/server/provider.c
+++ b/server/provider.c
@@ -55,7 +55,7 @@ AP_DECLARE(apr_status_t) ap_register_provider(apr_pool_t *pool,
         provider_group_hash = apr_hash_make(pool);
         apr_hash_set(global_providers, provider_group, APR_HASH_KEY_STRING,
                      provider_group_hash);
-        
+
     }
 
     provider_version_hash = apr_hash_get(provider_group_hash, provider_name,
@@ -65,7 +65,7 @@ AP_DECLARE(apr_status_t) ap_register_provider(apr_pool_t *pool,
         provider_version_hash = apr_hash_make(pool);
         apr_hash_set(provider_group_hash, provider_name, APR_HASH_KEY_STRING,
                      provider_version_hash);
-        
+
     }
 
     /* just set it. no biggy if it was there before. */
@@ -80,7 +80,7 @@ AP_DECLARE(apr_status_t) ap_register_provider(apr_pool_t *pool,
         provider_group_hash = apr_hash_make(pool);
         apr_hash_set(global_providers_names, provider_group, APR_HASH_KEY_STRING,
                      provider_group_hash);
-        
+
     }
 
     provider_version_hash = apr_hash_get(provider_group_hash, provider_version,
@@ -90,7 +90,7 @@ AP_DECLARE(apr_status_t) ap_register_provider(apr_pool_t *pool,
         provider_version_hash = apr_hash_make(pool);
         apr_hash_set(provider_group_hash, provider_version, APR_HASH_KEY_STRING,
                      provider_version_hash);
-        
+
     }
 
     /* just set it. no biggy if it was there before. */
diff --git a/server/request.c b/server/request.c
index e26e27e..be7c49a 100644
--- a/server/request.c
+++ b/server/request.c
@@ -356,8 +356,8 @@ static int resolve_symlink(char *d, apr_finfo_t *lfi, int opts, apr_pool_t *p)
     savename = (lfi->valid & APR_FINFO_NAME) ? lfi->name : NULL;
 
     if (opts & OPT_SYM_LINKS) {
-        if ((res = apr_stat(&fi, d, lfi->valid & ~(APR_FINFO_NAME 
-                                                 | APR_FINFO_LINK), p)) 
+        if ((res = apr_stat(&fi, d, lfi->valid & ~(APR_FINFO_NAME
+                                                 | APR_FINFO_LINK), p))
                  != APR_SUCCESS) {
             return HTTP_FORBIDDEN;
         }
@@ -377,7 +377,7 @@ static int resolve_symlink(char *d, apr_finfo_t *lfi, int opts, apr_pool_t *p)
      * owner of the symlink, then get the info of the target.
      */
     if (!(lfi->valid & APR_FINFO_OWNER)) {
-        if ((res = apr_stat(&fi, d, 
+        if ((res = apr_stat(&fi, d,
                             lfi->valid | APR_FINFO_LINK | APR_FINFO_OWNER, p))
             != APR_SUCCESS) {
             return HTTP_FORBIDDEN;
@@ -817,8 +817,8 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
 
                 ap_conf_vector_t *htaccess_conf = NULL;
 
-                /* No htaccess in an incomplete root path, 
-                 * nor if it's disabled 
+                /* No htaccess in an incomplete root path,
+                 * nor if it's disabled
                  */
                 if (seg < startseg || !opts.override) {
                     break;
@@ -939,15 +939,15 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
                 continue;
             }
 
-            /* We choose apr_stat with flag APR_FINFO_LINK here, rather that 
+            /* We choose apr_stat with flag APR_FINFO_LINK here, rather that
              * plain apr_stat, so that we capture this path object rather than
-             * its target.  We will replace the info with our target's info 
-             * below.  We especially want the name of this 'link' object, not 
-             * the name of its target, if we are fixing the filename 
+             * its target.  We will replace the info with our target's info
+             * below.  We especially want the name of this 'link' object, not
+             * the name of its target, if we are fixing the filename
              * case/resolving aliases.
              */
             rv = apr_stat(&thisinfo, r->filename,
-                          APR_FINFO_MIN | APR_FINFO_NAME | APR_FINFO_LINK, 
+                          APR_FINFO_MIN | APR_FINFO_NAME | APR_FINFO_LINK,
                           r->pool);
 
             if (APR_STATUS_IS_ENOENT(rv)) {
@@ -999,7 +999,7 @@ AP_DECLARE(int) ap_directory_walk(request_rec *r)
 
             /* Ok, we are done with the link's info, test the real target
              */
-            if (thisinfo.filetype == APR_REG || 
+            if (thisinfo.filetype == APR_REG ||
                 thisinfo.filetype == APR_NOFILE) {
                 /* That was fun, nothing left for us here
                  */
@@ -1587,7 +1587,7 @@ AP_DECLARE(request_rec *) ap_sub_req_method_uri(const char *method,
 {
     request_rec *rnew;
     /* Initialise res, to avoid a gcc warning */
-    int res = HTTP_INTERNAL_SERVER_ERROR; 
+    int res = HTTP_INTERNAL_SERVER_ERROR;
     char *udir;
 
     rnew = make_sub_request(r, next_filter);
@@ -1612,14 +1612,14 @@ AP_DECLARE(request_rec *) ap_sub_req_method_uri(const char *method,
         return rnew;
     }
 
-    /* lookup_uri 
+    /* lookup_uri
      * If the content can be served by the quick_handler, we can
      * safely bypass request_internal processing.
      *
-     * If next_filter is NULL we are expecting to be 
-     * internal_fast_redirect'ed to the subrequest, or the subrequest will 
-     * never be invoked. We need to make sure that the quickhandler is not 
-     * invoked by any lookups. Since an internal_fast_redirect will always 
+     * If next_filter is NULL we are expecting to be
+     * internal_fast_redirect'ed to the subrequest, or the subrequest will
+     * never be invoked. We need to make sure that the quickhandler is not
+     * invoked by any lookups. Since an internal_fast_redirect will always
      * occur too late for the quickhandler to handle the request.
      */
     if (next_filter) {
@@ -1630,7 +1630,7 @@ AP_DECLARE(request_rec *) ap_sub_req_method_uri(const char *method,
         if ((res = ap_process_request_internal(rnew))) {
             rnew->status = res;
         }
-    } 
+    }
 
     return rnew;
 }
@@ -1700,8 +1700,8 @@ AP_DECLARE(request_rec *) ap_sub_req_lookup_dirent(const apr_finfo_t *dirent,
         /*
          * apr_dir_read isn't very complete on this platform, so
          * we need another apr_stat (with or without APR_FINFO_LINK
-         * depending on whether we allow all symlinks here.)  If this 
-         * is an APR_LNK that resolves to an APR_DIR, then we will rerun 
+         * depending on whether we allow all symlinks here.)  If this
+         * is an APR_LNK that resolves to an APR_DIR, then we will rerun
          * everything anyways... this should be safe.
          */
         apr_status_t rv;
@@ -1714,7 +1714,7 @@ AP_DECLARE(request_rec *) ap_sub_req_lookup_dirent(const apr_finfo_t *dirent,
         }
         else {
             if (((rv = apr_stat(&rnew->finfo, rnew->filename,
-                                APR_FINFO_LINK | APR_FINFO_MIN, 
+                                APR_FINFO_LINK | APR_FINFO_MIN,
                                 rnew->pool)) != APR_SUCCESS)
                 && (rv != APR_INCOMPLETE)) {
                 rnew->finfo.filetype = 0;
@@ -1820,7 +1820,7 @@ AP_DECLARE(request_rec *) ap_sub_req_lookup_file(const char *new_file,
         }
         else {
             if (((rv = apr_stat(&rnew->finfo, rnew->filename,
-                                APR_FINFO_LINK | APR_FINFO_MIN, 
+                                APR_FINFO_LINK | APR_FINFO_MIN,
                                 rnew->pool)) != APR_SUCCESS)
                 && (rv != APR_INCOMPLETE)) {
                 rnew->finfo.filetype = 0;
@@ -1869,8 +1869,8 @@ AP_DECLARE(request_rec *) ap_sub_req_lookup_file(const char *new_file,
 AP_DECLARE(int) ap_run_sub_req(request_rec *r)
 {
     int retval = DECLINED;
-    /* Run the quick handler if the subrequest is not a dirent or file 
-     * subrequest 
+    /* Run the quick handler if the subrequest is not a dirent or file
+     * subrequest
      */
     if (!(r->filename && r->finfo.filetype)) {
         retval = ap_run_quick_handler(r, 0);
diff --git a/server/scoreboard.c b/server/scoreboard.c
index 6098837..381fb21 100644
--- a/server/scoreboard.c
+++ b/server/scoreboard.c
@@ -55,7 +55,7 @@ static /* but must be exported to mpm_winnt */
 APR_HOOK_STRUCT(
     APR_HOOK_LINK(pre_mpm)
 )
- 
+
 AP_IMPLEMENT_HOOK_RUN_ALL(int,pre_mpm,
                           (apr_pool_t *p, ap_scoreboard_e sb_type),
                           (p, sb_type),OK,DECLINED)
@@ -77,7 +77,7 @@ static apr_size_t scoreboard_size;
  * and it should handle cleaning up a scoreboard shared
  * between processes using any form of IPC (file, shared memory
  * segment, etc.). Leave it as is now because it is being used
- * by various MPMs. 
+ * by various MPMs.
  */
 static apr_status_t ap_cleanup_shared_mem(void *d)
 {
@@ -114,9 +114,9 @@ void ap_init_scoreboard(void *shared_score)
 {
     char *more_storage;
     int i;
-    
+
     ap_calc_scoreboard_size();
-    ap_scoreboard_image = 
+    ap_scoreboard_image =
         calloc(1, sizeof(scoreboard) + server_limit * sizeof(worker_score *) +
                server_limit * lb_limit * sizeof(lb_score *));
     more_storage = shared_score;
@@ -124,7 +124,7 @@ void ap_init_scoreboard(void *shared_score)
     more_storage += sizeof(global_score);
     ap_scoreboard_image->parent = (process_score *)more_storage;
     more_storage += sizeof(process_score) * server_limit;
-    ap_scoreboard_image->servers = 
+    ap_scoreboard_image->servers =
         (worker_score **)((char*)ap_scoreboard_image + sizeof(scoreboard));
     for (i = 0; i < server_limit; i++) {
         ap_scoreboard_image->servers[i] = (worker_score *)more_storage;
@@ -133,7 +133,7 @@ void ap_init_scoreboard(void *shared_score)
     if (lb_limit) {
         ap_scoreboard_image->balancers = (lb_score *)more_storage;
         more_storage += lb_limit * sizeof(lb_score);
-    }    
+    }
     ap_assert(more_storage == (char*)shared_score + scoreboard_size);
     ap_scoreboard_image->global->server_limit = server_limit;
     ap_scoreboard_image->global->thread_limit = thread_limit;
@@ -165,8 +165,8 @@ static apr_status_t create_namebased_scoreboard(apr_pool_t *pool,
     return APR_SUCCESS;
 }
 
-/* ToDo: This function should be made to handle setting up 
- * a scoreboard shared between processes using any IPC technique, 
+/* ToDo: This function should be made to handle setting up
+ * a scoreboard shared between processes using any IPC technique,
  * not just a shared memory segment
  */
 static apr_status_t open_scoreboard(apr_pool_t *pconf)
@@ -275,7 +275,7 @@ int ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
     if (ap_scoreboard_image) {
         running_gen = ap_scoreboard_image->global->running_generation;
         ap_scoreboard_image->global->restart_time = apr_time_now();
-        memset(ap_scoreboard_image->parent, 0, 
+        memset(ap_scoreboard_image->parent, 0,
                sizeof(process_score) * server_limit);
         for (i = 0; i < server_limit; i++) {
             memset(ap_scoreboard_image->servers[i], 0,
@@ -285,7 +285,7 @@ int ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
         if (lb_limit) {
             memset(ap_scoreboard_image->balancers, 0,
                    sizeof(lb_score) * lb_limit);
-        }        
+        }
         return OK;
     }
 
@@ -300,7 +300,7 @@ int ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
         memset(sb_shared, 0, scoreboard_size);
         ap_init_scoreboard(sb_shared);
     }
-    else 
+    else
 #endif
     {
         /* A simple malloc will suffice */
@@ -398,7 +398,7 @@ AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num,
     ws->status = status;
 
     ps = &ap_scoreboard_image->parent[child_num];
-    
+
     if (status == SERVER_READY
         && old_status == SERVER_STARTING) {
         ws->thread_num = child_num * thread_limit + thread_num;
@@ -438,7 +438,7 @@ AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num,
                         sizeof(ws->vhost));
         }
     }
-    
+
     return old_status;
 }
 
@@ -460,10 +460,10 @@ void ap_time_process_request(ap_sb_handle_t *sbh, int status)
     ws = &ap_scoreboard_image->servers[sbh->child_num][sbh->thread_num];
 
     if (status == START_PREQUEST) {
-        ws->start_time = apr_time_now(); 
+        ws->start_time = apr_time_now();
     }
     else if (status == STOP_PREQUEST) {
-        ws->stop_time = apr_time_now(); 
+        ws->stop_time = apr_time_now();
     }
 }
 
diff --git a/server/util.c b/server/util.c
index 989b48b..0d9acf9 100644
--- a/server/util.c
+++ b/server/util.c
@@ -16,10 +16,10 @@
 
 /*
  * util.c: string utility things
- * 
+ *
  * 3/21/93 Rob McCool
  * 1995-96 Many changes by the Apache Software Foundation
- * 
+ *
  */
 
 /* Debugging aid:
@@ -96,7 +96,7 @@ AP_DECLARE(char *) ap_field_noparam(apr_pool_t *p, const char *intype)
     semi = ap_strchr_c(intype, ';');
     if (semi == NULL) {
         return apr_pstrdup(p, intype);
-    } 
+    }
     else {
         while ((semi > intype) && apr_isspace(semi[-1])) {
             semi--;
@@ -221,11 +221,11 @@ AP_DECLARE(int) ap_strcasecmp_match(const char *str, const char *expected)
 }
 
 /* We actually compare the canonical root to this root, (but we don't
- * waste time checking the case), since every use of this function in 
+ * waste time checking the case), since every use of this function in
  * httpd-2.1 tests if the path is 'proper', meaning we've already passed
  * it through apr_filepath_merge, or we haven't.
  */
-AP_DECLARE(int) ap_os_is_path_absolute(apr_pool_t *p, const char *dir) 
+AP_DECLARE(int) ap_os_is_path_absolute(apr_pool_t *p, const char *dir)
 {
     const char *newpath;
     const char *ourdir = dir;
@@ -439,7 +439,7 @@ AP_DECLARE(void) ap_getparents(char *name)
     /* a) remove ./ path segments */
     for (next = name; *next && (*next != '.'); next++) {
     }
-    
+
     l = w = first_dot = next - name;
     while (name[l] != '\0') {
         if (name[l] == '.' && IS_SLASH(name[l + 1])
@@ -529,8 +529,8 @@ AP_DECLARE(void) ap_no2slash(char *name)
  * assumes n > 0
  * the return value is the ever useful pointer to the trailing \0 of d
  *
- * MODIFIED FOR HAVE_DRIVE_LETTERS and NETWARE environments, 
- * so that if n == 0, "/" is returned in d with n == 1 
+ * MODIFIED FOR HAVE_DRIVE_LETTERS and NETWARE environments,
+ * so that if n == 0, "/" is returned in d with n == 1
  * and s == "e:/test.html", "e:/" is returned in d
  * *** See also directory_walk in modules/http/http_request.c
 
@@ -732,7 +732,7 @@ AP_DECLARE(char *) ap_getword_conf(apr_pool_t *p, const char **line)
     if ((quote = *str) == '"' || quote == '\'') {
         strend = str + 1;
         while (*strend && *strend != quote) {
-            if (*strend == '\\' && strend[1] && 
+            if (*strend == '\\' && strend[1] &&
                 (strend[1] == quote || strend[1] == '\\')) {
                 strend += 2;
             }
@@ -851,7 +851,7 @@ AP_DECLARE(const char *) ap_resolve_env(apr_pool_t *p, const char * word)
 AP_DECLARE(int) ap_cfg_closefile(ap_configfile_t *cfp)
 {
 #ifdef DEBUG
-    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL, 
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
         "Done with config file %s", cfp->name);
 #endif
     return (cfp->close == NULL) ? 0 : cfp->close(cfp->param);
@@ -906,7 +906,7 @@ AP_DECLARE(apr_status_t) ap_pcfg_openfile(ap_configfile_t **ret_cfg,
 #ifdef DEBUG
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                 "Opening config file %s (%s)",
-                name, (status != APR_SUCCESS) ? 
+                name, (status != APR_SUCCESS) ?
                 apr_strerror(status, buf, sizeof(buf)) : "successful");
 #endif
     if (status != APR_SUCCESS)
@@ -937,14 +937,14 @@ AP_DECLARE(apr_status_t) ap_pcfg_openfile(ap_configfile_t **ret_cfg,
      * would signify utf-8 text files.
      *
      * Since MS configuration files are all protecting utf-8 encoded
-     * Unicode path, file and resource names, we already have the correct 
+     * Unicode path, file and resource names, we already have the correct
      * WinNT encoding.  But at least eat the stupid three bytes up front.
      */
     {
         unsigned char buf[4];
         apr_size_t len = 3;
         status = apr_file_read(file, buf, &len);
-        if ((status != APR_SUCCESS) || (len < 3) 
+        if ((status != APR_SUCCESS) || (len < 3)
               || memcmp(buf, "\xEF\xBB\xBF", 3) != 0) {
             apr_off_t zero = 0;
             apr_file_seek(file, APR_SET, &zero);
@@ -985,16 +985,16 @@ AP_DECLARE(ap_configfile_t *) ap_pcfg_open_custom(apr_pool_t *p,
     new_cfg->line_number = 0;
     return new_cfg;
 }
-   
+
 /* Read one character from a configfile_t */
 AP_DECLARE(int) ap_cfg_getc(ap_configfile_t *cfp)
 {
     register int ch = cfp->getch(cfp->param);
-    if (ch == LF) 
+    if (ch == LF)
         ++cfp->line_number;
     return ch;
 }
-  
+
 /* Read one line from open ap_configfile_t, strip LF, increase line number */
 /* If custom handler does not define a getstr() function, read char by char */
 AP_DECLARE(int) ap_cfg_getline(char *buf, size_t bufsize, ap_configfile_t *cfp)
@@ -1034,13 +1034,13 @@ AP_DECLARE(int) ap_cfg_getline(char *buf, size_t bufsize, ap_configfile_t *cfp)
                         continue;
                     }
                     else {
-                        /* 
+                        /*
                          * no real continuation because escaped -
                          * then just remove escape character
                          */
                         for ( ; cp < cbuf+cbufsize && *cp != '\0'; cp++)
                             cp[0] = cp[1];
-                    }   
+                    }
                 }
             }
             break;
@@ -1078,7 +1078,7 @@ AP_DECLARE(int) ap_cfg_getline(char *buf, size_t bufsize, ap_configfile_t *cfp)
 
         if (c == EOF)
             return 1;
-        
+
         if(bufsize < 2) {
             /* too small, assume caller is crazy */
             return 1;
@@ -1099,7 +1099,7 @@ AP_DECLARE(int) ap_cfg_getline(char *buf, size_t bufsize, ap_configfile_t *cfp)
                 ++cfp->line_number;
             }
             if (c == EOF || c == 0x4 || c == LF || i >= (bufsize - 2)) {
-                /* 
+                /*
                  *  check for line continuation
                  */
                 if (i > 0 && buf[i-1] == '\\') {
@@ -1497,7 +1497,7 @@ AP_DECLARE(char *) ap_escape_shell_cmd(apr_pool_t *p, const char *str)
     for (; *s; ++s) {
 
 #if defined(OS2) || defined(WIN32)
-        /* 
+        /*
          * Newlines to Win32/OS2 CreateProcess() are ill advised.
          * Convert them to spaces since they are effectively white
          * space to most applications
@@ -2016,14 +2016,14 @@ char *ap_get_local_host(apr_pool_t *a)
         }
     }
 
-    if (!server_hostname) 
+    if (!server_hostname)
         server_hostname = apr_pstrdup(a, "127.0.0.1");
 
     ap_log_perror(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0, a,
                  "%s: Could not reliably determine the server's fully qualified "
                  "domain name, using %s for ServerName",
                  ap_server_argv0, server_hostname);
-             
+
     return server_hostname;
 }
 
@@ -2041,8 +2041,8 @@ AP_DECLARE(char *) ap_pbase64decode(apr_pool_t *p, const char *bufcoded)
     return decoded;
 }
 
-AP_DECLARE(char *) ap_pbase64encode(apr_pool_t *p, char *string) 
-{ 
+AP_DECLARE(char *) ap_pbase64encode(apr_pool_t *p, char *string)
+{
     char *encoded;
     int l = strlen(string);
 
diff --git a/server/util_cfgtree.c b/server/util_cfgtree.c
index b3bff04..7409242 100644
--- a/server/util_cfgtree.c
+++ b/server/util_cfgtree.c
@@ -18,7 +18,7 @@
 #include "util_cfgtree.h"
 #include <stdlib.h>
 
-ap_directive_t *ap_add_node(ap_directive_t **parent, ap_directive_t *current, 
+ap_directive_t *ap_add_node(ap_directive_t **parent, ap_directive_t *current,
                             ap_directive_t *toadd, int child)
 {
     if (current == NULL) {
diff --git a/server/util_charset.c b/server/util_charset.c
index 3be2a39..0cf34a1 100644
--- a/server/util_charset.c
+++ b/server/util_charset.c
@@ -33,10 +33,10 @@
  * the source code.
  *
  * For an ASCII machine, these remain NULL so that when they are stored
- * in the BUFF via ap_bsetop(BO_RXLATE) it ensures that no translation is 
+ * in the BUFF via ap_bsetop(BO_RXLATE) it ensures that no translation is
  * performed.
  */
- 
+
 apr_xlate_t *ap_hdrs_to_ascii, *ap_hdrs_from_ascii;
 
 #endif /*APR_CHARSET_EBCDIC */
diff --git a/server/util_ebcdic.c b/server/util_ebcdic.c
index 4062db0..43a7a0a 100644
--- a/server/util_ebcdic.c
+++ b/server/util_ebcdic.c
@@ -49,21 +49,21 @@ apr_status_t ap_init_ebcdic(apr_pool_t *pool)
                      "apr_MD5InitEBCDIC() failed");
         return rv;
     }
-    
+
     rv = apr_base64init_ebcdic(ap_hdrs_to_ascii, ap_hdrs_from_ascii);
     if (rv) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
                      "apr_base64init_ebcdic() failed");
         return rv;
     }
-    
+
     rv = apr_SHA1InitEBCDIC(ap_hdrs_to_ascii);
     if (rv) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL,
                      "apr_SHA1InitEBCDIC() failed");
         return rv;
     }
-    
+
     return APR_SUCCESS;
 }
 
@@ -106,7 +106,7 @@ int ap_rvputs_proto_in_ascii(request_rec *r, ...)
         written += len;
     }
     va_end(va);
- 
+
     return written;
-}    
+}
 #endif /* APR_CHARSET_EBCDIC */
diff --git a/server/util_filter.c b/server/util_filter.c
index f8327aa..8d2af74a 100644
--- a/server/util_filter.c
+++ b/server/util_filter.c
@@ -231,8 +231,8 @@ static ap_filter_rec_t *register_filter(const char *name,
     frec->filter_func = filter_func;
     frec->filter_init_func = filter_init;
     frec->ftype = ftype;
-    
-    apr_pool_cleanup_register(FILTER_POOL, NULL, filter_cleanup, 
+
+    apr_pool_cleanup_register(FILTER_POOL, NULL, filter_cleanup,
                               apr_pool_cleanup_null);
     return frec;
 }
@@ -246,7 +246,7 @@ AP_DECLARE(ap_filter_rec_t *) ap_register_input_filter(const char *name,
     f.in_func = filter_func;
     return register_filter(name, f, filter_init, ftype,
                            &registered_input_filters);
-}                                                                    
+}
 
 AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter(const char *name,
                                            ap_out_filter_func filter_func,
@@ -273,8 +273,8 @@ AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter_protocol(
     return ret ;
 }
 
-static ap_filter_t *add_any_filter_handle(ap_filter_rec_t *frec, void *ctx, 
-                                          request_rec *r, conn_rec *c, 
+static ap_filter_t *add_any_filter_handle(ap_filter_rec_t *frec, void *ctx,
+                                          request_rec *r, conn_rec *c,
                                           ap_filter_t **r_filters,
                                           ap_filter_t **p_filters,
                                           ap_filter_t **c_filters)
@@ -352,10 +352,10 @@ static ap_filter_t *add_any_filter_handle(ap_filter_rec_t *frec, void *ctx,
     return f;
 }
 
-static ap_filter_t *add_any_filter(const char *name, void *ctx, 
-                                   request_rec *r, conn_rec *c, 
+static ap_filter_t *add_any_filter(const char *name, void *ctx,
+                                   request_rec *r, conn_rec *c,
                                    const filter_trie_node *reg_filter_set,
-                                   ap_filter_t **r_filters, 
+                                   ap_filter_t **r_filters,
                                    ap_filter_t **p_filters,
                                    ap_filter_t **c_filters)
 {
@@ -389,7 +389,7 @@ static ap_filter_t *add_any_filter(const char *name, void *ctx,
         }
 
         if (node && node->frec) {
-            return add_any_filter_handle(node->frec, ctx, r, c, r_filters, 
+            return add_any_filter_handle(node->frec, ctx, r, c, r_filters,
                                          p_filters, c_filters);
         }
     }
@@ -403,7 +403,7 @@ AP_DECLARE(ap_filter_t *) ap_add_input_filter(const char *name, void *ctx,
                                               request_rec *r, conn_rec *c)
 {
     return add_any_filter(name, ctx, r, c, registered_input_filters,
-                          r ? &r->input_filters : NULL, 
+                          r ? &r->input_filters : NULL,
                           r ? &r->proto_input_filters : NULL, &c->input_filters);
 }
 
@@ -413,7 +413,7 @@ AP_DECLARE(ap_filter_t *) ap_add_input_filter_handle(ap_filter_rec_t *f,
                                                      conn_rec *c)
 {
     return add_any_filter_handle(f, ctx, r, c, r ? &r->input_filters : NULL,
-                                 r ? &r->proto_input_filters : NULL, 
+                                 r ? &r->proto_input_filters : NULL,
                                  &c->input_filters);
 }
 
@@ -421,7 +421,7 @@ AP_DECLARE(ap_filter_t *) ap_add_output_filter(const char *name, void *ctx,
                                                request_rec *r, conn_rec *c)
 {
     return add_any_filter(name, ctx, r, c, registered_output_filters,
-                          r ? &r->output_filters : NULL, 
+                          r ? &r->output_filters : NULL,
                           r ? &r->proto_output_filters : NULL, &c->output_filters);
 }
 
@@ -460,33 +460,33 @@ static void remove_any_filter(ap_filter_t *f, ap_filter_t **r_filt, ap_filter_t
 
 AP_DECLARE(void) ap_remove_input_filter(ap_filter_t *f)
 {
-    remove_any_filter(f, f->r ? &f->r->input_filters : NULL, 
-                      f->r ? &f->r->proto_input_filters : NULL, 
+    remove_any_filter(f, f->r ? &f->r->input_filters : NULL,
+                      f->r ? &f->r->proto_input_filters : NULL,
                       &f->c->input_filters);
 }
 
 AP_DECLARE(void) ap_remove_output_filter(ap_filter_t *f)
 {
-    remove_any_filter(f, f->r ? &f->r->output_filters : NULL, 
-                      f->r ? &f->r->proto_output_filters : NULL, 
+    remove_any_filter(f, f->r ? &f->r->output_filters : NULL,
+                      f->r ? &f->r->proto_output_filters : NULL,
                       &f->c->output_filters);
 }
 
-/* 
- * Read data from the next filter in the filter stack.  Data should be 
+/*
+ * Read data from the next filter in the filter stack.  Data should be
  * modified in the bucket brigade that is passed in.  The core allocates the
  * bucket brigade, modules that wish to replace large chunks of data or to
  * save data off to the side should probably create their own temporary
  * brigade especially for that use.
  */
 AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *next,
-                                        apr_bucket_brigade *bb, 
+                                        apr_bucket_brigade *bb,
                                         ap_input_mode_t mode,
                                         apr_read_type_e block,
                                         apr_off_t readbytes)
 {
     if (next) {
-        return next->frec->filter_func.in_func(next, bb, mode, block, 
+        return next->frec->filter_func.in_func(next, bb, mode, block,
                                                readbytes);
     }
     return AP_NOBODY_READ;
@@ -497,7 +497,7 @@ AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *next,
  * the current filter.  At that point, we can just call the first filter in
  * the stack, or r->output_filters.
  */
-AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *next, 
+AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *next,
                                          apr_bucket_brigade *bb)
 {
     if (next) {
@@ -528,7 +528,7 @@ AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *next,
     return AP_NOBODY_WROTE;
 }
 
-AP_DECLARE(apr_status_t) ap_save_brigade(ap_filter_t *f, 
+AP_DECLARE(apr_status_t) ap_save_brigade(ap_filter_t *f,
                                          apr_bucket_brigade **saveto,
                                          apr_bucket_brigade **b, apr_pool_t *p)
 {
@@ -541,7 +541,7 @@ AP_DECLARE(apr_status_t) ap_save_brigade(ap_filter_t *f,
     if (!(*saveto)) {
         *saveto = apr_brigade_create(p, f->c->bucket_alloc);
     }
-    
+
     for (e = APR_BRIGADE_FIRST(*b);
          e != APR_BRIGADE_SENTINEL(*b);
          e = APR_BUCKET_NEXT(e))
@@ -574,7 +574,7 @@ AP_DECLARE(apr_status_t) ap_save_brigade(ap_filter_t *f,
     return srv;
 }
 
-AP_DECLARE_NONSTD(apr_status_t) ap_filter_flush(apr_bucket_brigade *bb, 
+AP_DECLARE_NONSTD(apr_status_t) ap_filter_flush(apr_bucket_brigade *bb,
                                                 void *ctx)
 {
     ap_filter_t *f = ctx;
diff --git a/server/util_md5.c b/server/util_md5.c
index fad70fa..e0ede0a 100644
--- a/server/util_md5.c
+++ b/server/util_md5.c
@@ -31,7 +31,7 @@
  *  Original Code Copyright (C) 1994, Jeff Hostetler, Spyglass, Inc.
  *  Portions of Content-MD5 code Copyright (C) 1993, 1994 by Carnegie Mellon
  *     University (see Copyright below).
- *  Portions of Content-MD5 code Copyright (C) 1991 Bell Communications 
+ *  Portions of Content-MD5 code Copyright (C) 1991 Bell Communications
  *     Research, Inc. (Bellcore) (see Copyright below).
  *  Portions extracted from mpack, John G. Myers - jgm+@cmu.edu
  *  Content-MD5 Code contributed by Martin Hamilton (martin@net.lut.ac.uk)
@@ -122,7 +122,7 @@ AP_DECLARE(char *) ap_md5(apr_pool_t *p, const unsigned char *string)
  * of an authorized representative of Bellcore.  BELLCORE
  * MAKES NO REPRESENTATIONS ABOUT THE ACCURACY OR SUITABILITY
  * OF THIS MATERIAL FOR ANY PURPOSE.  IT IS PROVIDED "AS IS",
- * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES.  
+ * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES.
  */
 
 static char basis_64[] =
diff --git a/server/util_pcre.c b/server/util_pcre.c
index bd1073c..c69c978 100644
--- a/server/util_pcre.c
+++ b/server/util_pcre.c
@@ -65,7 +65,7 @@ static const char *const pstring[] = {
   "match failed"                     /* AP_REG_NOMATCH */
 };
 
-AP_DECLARE(apr_size_t) ap_regerror(int errcode, const ap_regex_t *preg, 
+AP_DECLARE(apr_size_t) ap_regerror(int errcode, const ap_regex_t *preg,
                                    char *errbuf, apr_size_t errbuf_size)
 {
 const char *message, *addmessage;
diff --git a/server/util_script.c b/server/util_script.c
index 35973a3..66b9a95 100644
--- a/server/util_script.c
+++ b/server/util_script.c
@@ -74,7 +74,7 @@ static char *http2env(apr_pool_t *a, const char *w)
         }
     }
     *cp = 0;
- 
+
     return res;
 }
 
@@ -171,7 +171,7 @@ AP_DECLARE(void) ap_add_common_vars(request_rec *r)
          * in the environment with "ps -e".  But, if you must...
          */
 #ifndef SECURITY_HOLE_PASS_AUTHORIZATION
-        else if (!strcasecmp(hdrs[i].key, "Authorization") 
+        else if (!strcasecmp(hdrs[i].key, "Authorization")
                  || !strcasecmp(hdrs[i].key, "Proxy-Authorization")) {
             continue;
         }
@@ -188,13 +188,13 @@ AP_DECLARE(void) ap_add_common_vars(request_rec *r)
 
 #ifdef WIN32
     if (env_temp = getenv("SystemRoot")) {
-        apr_table_addn(e, "SystemRoot", env_temp);         
+        apr_table_addn(e, "SystemRoot", env_temp);
     }
     if (env_temp = getenv("COMSPEC")) {
-        apr_table_addn(e, "COMSPEC", env_temp);            
+        apr_table_addn(e, "COMSPEC", env_temp);
     }
     if (env_temp = getenv("PATHEXT")) {
-        apr_table_addn(e, "PATHEXT", env_temp);            
+        apr_table_addn(e, "PATHEXT", env_temp);
     }
     if (env_temp = getenv("WINDIR")) {
         apr_table_addn(e, "WINDIR", env_temp);
@@ -203,22 +203,22 @@ AP_DECLARE(void) ap_add_common_vars(request_rec *r)
 
 #ifdef OS2
     if ((env_temp = getenv("COMSPEC")) != NULL) {
-        apr_table_addn(e, "COMSPEC", env_temp);            
+        apr_table_addn(e, "COMSPEC", env_temp);
     }
     if ((env_temp = getenv("ETC")) != NULL) {
-        apr_table_addn(e, "ETC", env_temp);            
+        apr_table_addn(e, "ETC", env_temp);
     }
     if ((env_temp = getenv("DPATH")) != NULL) {
-        apr_table_addn(e, "DPATH", env_temp);            
+        apr_table_addn(e, "DPATH", env_temp);
     }
     if ((env_temp = getenv("PERLLIB_PREFIX")) != NULL) {
-        apr_table_addn(e, "PERLLIB_PREFIX", env_temp);            
+        apr_table_addn(e, "PERLLIB_PREFIX", env_temp);
     }
 #endif
 
 #ifdef BEOS
     if ((env_temp = getenv("LIBRARY_PATH")) != NULL) {
-        apr_table_addn(e, "LIBRARY_PATH", env_temp);            
+        apr_table_addn(e, "LIBRARY_PATH", env_temp);
     }
 #endif
 
@@ -341,7 +341,7 @@ AP_DECLARE(void) ap_add_cgi_vars(request_rec *r)
     apr_table_setn(e, "SERVER_PROTOCOL", r->protocol);
     apr_table_setn(e, "REQUEST_METHOD", r->method);
     apr_table_setn(e, "QUERY_STRING", r->args ? r->args : "");
-    apr_table_setn(e, "REQUEST_URI", original_uri(r)); 
+    apr_table_setn(e, "REQUEST_URI", original_uri(r));
 
     /* Note that the code below special-cases scripts run from includes,
      * because it "knows" that the sub_request has been hacked to have the
@@ -430,7 +430,7 @@ AP_DECLARE(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
 
         if ((*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data) == 0) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,
-                          "Premature end of script headers: %s", 
+                          "Premature end of script headers: %s",
                           apr_filepath_name_get(r->filename));
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -441,7 +441,7 @@ AP_DECLARE(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
              /* Indeed, the host's '\n':
                 '\012' for UNIX; '\015' for MacOS; '\025' for OS/390
                  -- whatever the script generates.
-             */                                  
+             */
         if (p > 0 && w[p - 1] == '\n') {
             if (p > 1 && w[p - 2] == CR) {
                 w[p - 2] = '\0';
@@ -523,7 +523,7 @@ AP_DECLARE(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
             }
 
             ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_TOCLIENT, 0, r,
-                          "%s: %s", malformed, 
+                          "%s: %s", malformed,
                           apr_filepath_name_get(r->filename));
             return HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -660,8 +660,8 @@ static int getsfunc_STRING(char *w, int len, void *pvastrs)
     struct vastrs *strs = (struct vastrs*) pvastrs;
     const char *p;
     int t;
-    
-    if (!strs->curpos || !*strs->curpos) 
+
+    if (!strs->curpos || !*strs->curpos)
         return 0;
     p = ap_strchr_c(strs->curpos, '\n');
     if (p)
@@ -679,7 +679,7 @@ static int getsfunc_STRING(char *w, int len, void *pvastrs)
     }
     else
         strs->curpos += t;
-    return t;    
+    return t;
 }
 
 /* ap_scan_script_header_err_strs() accepts additional const char* args...
@@ -687,8 +687,8 @@ static int getsfunc_STRING(char *w, int len, void *pvastrs)
  * character is returned to **arg, **data.  (The first optional arg is
  * counted as 0.)
  */
-AP_DECLARE_NONSTD(int) ap_scan_script_header_err_strs(request_rec *r, 
-                                                      char *buffer, 
+AP_DECLARE_NONSTD(int) ap_scan_script_header_err_strs(request_rec *r,
+                                                      char *buffer,
                                                       const char **termch,
                                                       int *termarg, ...)
 {
diff --git a/server/vhost.c b/server/vhost.c
index a26bfdf..41d67c3 100644
--- a/server/vhost.c
+++ b/server/vhost.c
@@ -15,7 +15,7 @@
  */
 
 /**
- * @file  vhost.c 
+ * @file  vhost.c
  * @brief functions pertaining to virtual host addresses
  *        (configuration and run-time)
  */
@@ -137,7 +137,7 @@ AP_DECLARE(void) ap_init_vhost_config(apr_pool_t *p)
  * port is the default port to assume
  */
 static const char *get_addresses(apr_pool_t *p, const char *w_,
-                                 server_addr_rec ***paddr, 
+                                 server_addr_rec ***paddr,
                                  apr_port_t default_port)
 {
     apr_sockaddr_t *my_addr;
@@ -382,7 +382,7 @@ static APR_INLINE ipaddr_chain *find_ipaddr(apr_sockaddr_t *sa)
             if (apr_sockaddr_equal(cur, sa)) {
                 return trav;
             }
-        }    
+        }
     }
     return NULL;
 }
@@ -504,7 +504,7 @@ static void remove_unused_name_vhosts(server_rec *main_s, ipaddr_chain **pic)
 {
     while (*pic) {
         ipaddr_chain *ic = *pic;
-        
+
         if (ic->server == NULL) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, 0, main_s,
                          "NameVirtualHost %s:%u has no VirtualHosts",
@@ -550,7 +550,7 @@ AP_DECLARE(void) ap_fini_vhost_config(apr_pool_t *p, server_rec *main_s)
         unsigned bucket = hash_addr(sar->host_addr);
         ipaddr_chain *ic = new_ipaddr_chain(p, NULL, sar);
 
-        if (memcmp(sar->host_addr->ipaddr_ptr, inaddr_any, 
+        if (memcmp(sar->host_addr->ipaddr_ptr, inaddr_any,
                    sar->host_addr->ipaddr_len)) { /* not IN[6]ADDR_ANY */
             *iphash_table_tail[bucket] = ic;
             iphash_table_tail[bucket] = &ic->next;
@@ -734,8 +734,8 @@ static void fix_hostname(request_rec *r)
         r->parsed_uri.port_str = apr_itoa(r->pool, (int)port);
     }
 
-    /* if the hostname is an IPv6 numeric address string, it was validated 
-     * already; otherwise, further validation is needed 
+    /* if the hostname is an IPv6 numeric address string, it was validated
+     * already; otherwise, further validation is needed
      */
     if (r->hostname[0] != '[') {
         for (dst = host; *dst; dst++) {
@@ -821,7 +821,7 @@ AP_DECLARE(int) ap_matches_request_vhost(request_rec *r, const char *host,
 
     /* search all the <VirtualHost> values */
     /* XXX: If this is a NameVirtualHost then we may not be doing the Right Thing
-     * consider: 
+     * consider:
      *
      *     NameVirtualHost 10.1.1.1
      *     <VirtualHost 10.1.1.1>
@@ -987,7 +987,7 @@ AP_DECLARE(void) ap_update_vhost_from_headers(request_rec *r)
 /**
  * For every virtual host on this connection, call func_cb.
  */
-AP_DECLARE(int) ap_vhost_iterate_given_conn(conn_rec *conn, 
+AP_DECLARE(int) ap_vhost_iterate_given_conn(conn_rec *conn,
                                             ap_vhost_iterate_conn_cb func_cb,
                                             void* baton)
 {
@@ -1004,7 +1004,7 @@ AP_DECLARE(int) ap_vhost_iterate_given_conn(conn_rec *conn,
         for (src = conn->vhost_lookup_data; src; src = src->next) {
             server_addr_rec *sar;
 
-            /* We only consider addresses on the name_chain which have a 
+            /* We only consider addresses on the name_chain which have a
              * matching port.
              */
             sar = src->sar;
diff --git a/support/ab.c b/support/ab.c
index b8c2d41..63f6c66 100644
--- a/support/ab.c
+++ b/support/ab.c
@@ -83,15 +83,15 @@
    **/
 
 /* Note: this version string should start with \d+[\d\.]* and be a valid
- * string for an HTTP Agent: header when prefixed with 'ApacheBench/'. 
- * It should reflect the version of AB - and not that of the apache server 
- * it happens to accompany. And it should be updated or changed whenever 
- * the results are no longer fundamentally comparable to the results of 
+ * string for an HTTP Agent: header when prefixed with 'ApacheBench/'.
+ * It should reflect the version of AB - and not that of the apache server
+ * it happens to accompany. And it should be updated or changed whenever
+ * the results are no longer fundamentally comparable to the results of
  * a previous version of ab. Either due to a change in the logic of
- * ab - or to due to a change in the distribution it is compiled with 
+ * ab - or to due to a change in the distribution it is compiled with
  * (such as an APR change in for example blocking).
  */
-#define AP_AB_BASEREVISION "2.0.40-dev"    
+#define AP_AB_BASEREVISION "2.0.40-dev"
 
 /*
  * BUGS:
@@ -469,14 +469,14 @@ static int ssl_print_connection_info(BIO *bio, SSL *ssl)
 {
     SSL_CIPHER *c;
     int alg_bits,bits;
-    
+
     c = SSL_get_current_cipher(ssl);
     BIO_printf(bio,"Cipher Suite Protocol   :%s\n", SSL_CIPHER_get_version(c));
     BIO_printf(bio,"Cipher Suite Name       :%s\n",SSL_CIPHER_get_name(c));
-    
+
     bits = SSL_CIPHER_get_bits(c,&alg_bits);
     BIO_printf(bio,"Cipher Suite Cipher Bits:%d (%d)\n",bits,alg_bits);
-    
+
     return(1);
 }
 
@@ -556,7 +556,7 @@ static void ssl_proceed_handshake(struct connection *c)
                 SSL_CIPHER *ci;
                 X509 *cert;
                 int sk_bits, pk_bits, swork;
-                
+
                 ci = SSL_get_current_cipher(c->ssl);
                 sk_bits = SSL_CIPHER_get_bits(ci, &swork);
                 cert = SSL_get_peer_certificate(c->ssl);
@@ -564,7 +564,7 @@ static void ssl_proceed_handshake(struct connection *c)
                     pk_bits = EVP_PKEY_bits(X509_get_pubkey(cert));
                 else
                     pk_bits = 0;  /* Anon DH */
-                
+
                 ssl_info = malloc(128);
                 apr_snprintf(ssl_info, 128, "%s,%s,%d,%d",
                              SSL_CIPHER_get_version(ci),
@@ -607,7 +607,7 @@ static void write_request(struct connection * c)
         apr_time_t tnow = apr_time_now();
         apr_size_t l = c->rwrite;
         apr_status_t e = APR_SUCCESS; /* prevent gcc warning */
-    
+
         /*
          * First time round ?
          */
@@ -624,7 +624,7 @@ static void write_request(struct connection * c)
             close_connection(c);
             return;
         }
-    
+
 #ifdef USE_SSL
         if (c->ssl) {
             apr_size_t e_ssl;
@@ -647,7 +647,7 @@ static void write_request(struct connection * c)
          */
         if (l == c->rwrite)
             break;
-    
+
         if (e != APR_SUCCESS) {
             /*
              * Let's hope this traps EWOULDBLOCK too !
@@ -727,7 +727,7 @@ static void output_results(void)
     timetakenusec = endtime - start;
     timetaken = ((float)apr_time_sec(timetakenusec)) +
         ((float)apr_time_usec(timetakenusec)) / 1000000.0F;
-    
+
     printf("\n\n");
     printf("Server Software:        %s\n", servername);
     printf("Server Hostname:        %s\n", hostname);
@@ -762,9 +762,9 @@ static void output_results(void)
 
     /* avoid divide by zero */
     if (timetaken) {
-        printf("Requests per second:    %.2f [#/sec] (mean)\n", 
+        printf("Requests per second:    %.2f [#/sec] (mean)\n",
                (float) (done / timetaken));
-        printf("Time per request:       %.3f [ms] (mean)\n", 
+        printf("Time per request:       %.3f [ms] (mean)\n",
                (float) (1000 * concurrency * timetaken / done));
         printf("Time per request:       %.3f [ms] (mean, across all concurrent requests)\n",
            (float) (1000 * timetaken / done));
@@ -783,7 +783,7 @@ static void output_results(void)
         long i;
         apr_time_t totalcon = 0, total = 0, totald = 0, totalwait = 0;
         apr_time_t meancon, meantot, meand, meanwait;
-        apr_interval_time_t mincon = AB_MAX, mintot = AB_MAX, mind = AB_MAX, 
+        apr_interval_time_t mincon = AB_MAX, mintot = AB_MAX, mind = AB_MAX,
                             minwait = AB_MAX;
         apr_interval_time_t maxcon = 0, maxtot = 0, maxd = 0, maxwait = 0;
         apr_interval_time_t mediancon = 0, mediantot = 0, mediand = 0, medianwait = 0;
@@ -795,12 +795,12 @@ static void output_results(void)
             mintot = ap_min(mintot, s.time);
             mind = ap_min(mind, s.time - s.ctime);
             minwait = ap_min(minwait, s.waittime);
-    
+
             maxcon = ap_max(maxcon, s.ctime);
             maxtot = ap_max(maxtot, s.time);
             maxd = ap_max(maxd, s.time - s.ctime);
             maxwait = ap_max(maxwait, s.waittime);
-    
+
             totalcon += s.ctime;
             total += s.time;
             totald += s.time - s.ctime;
@@ -829,7 +829,7 @@ static void output_results(void)
         sdcon = (requests > 1) ? sqrt(sdcon / (requests - 1)) : 0;
         sdd = (requests > 1) ? sqrt(sdd / (requests - 1)) : 0;
         sdwait = (requests > 1) ? sqrt(sdwait / (requests - 1)) : 0;
-    
+
         if (gnuplot) {
             FILE *out = fopen(gnuplot, "w");
             long i;
@@ -866,7 +866,7 @@ static void output_results(void)
             mediancon = (stats[requests / 2].ctime + stats[requests / 2 + 1].ctime) / 2;
         else
             mediancon = stats[requests / 2].ctime;
-    
+
         qsort(stats, requests, sizeof(struct data),
               (int (*) (const void *, const void *)) compri);
         if ((requests > 1) && (requests % 2))
@@ -874,27 +874,27 @@ static void output_results(void)
             -stats[requests / 2].ctime - stats[requests / 2 + 1].ctime) / 2;
         else
             mediand = stats[requests / 2].time - stats[requests / 2].ctime;
-    
+
         qsort(stats, requests, sizeof(struct data),
               (int (*) (const void *, const void *)) compwait);
         if ((requests > 1) && (requests % 2))
             medianwait = (stats[requests / 2].waittime + stats[requests / 2 + 1].waittime) / 2;
         else
             medianwait = stats[requests / 2].waittime;
-    
+
         qsort(stats, requests, sizeof(struct data),
               (int (*) (const void *, const void *)) comprando);
         if ((requests > 1) && (requests % 2))
             mediantot = (stats[requests / 2].time + stats[requests / 2 + 1].time) / 2;
         else
             mediantot = stats[requests / 2].time;
-    
+
         printf("\nConnection Times (ms)\n");
 
         if (confidence) {
 #define CONF_FMT_STRING "%5" APR_TIME_T_FMT " %4d %5.1f %6" APR_TIME_T_FMT " %7" APR_TIME_T_FMT "\n"
             printf("              min  mean[+/-sd] median   max\n");
-            printf("Connect:    " CONF_FMT_STRING, 
+            printf("Connect:    " CONF_FMT_STRING,
                        mincon, (int) (meancon + 0.5), sdcon, mediancon, maxcon);
             printf("Processing: " CONF_FMT_STRING,
                mind, (int) (meand + 0.5), sdd, mediand, maxd);
@@ -923,11 +923,11 @@ static void output_results(void)
         else {
             printf("              min   avg   max\n");
 #define CONF_FMT_STRING "%5" APR_TIME_T_FMT " %5" APR_TIME_T_FMT "%5" APR_TIME_T_FMT "\n"
-            printf("Connect:    " CONF_FMT_STRING, 
+            printf("Connect:    " CONF_FMT_STRING,
                 mincon, meancon, maxcon);
-            printf("Processing: " CONF_FMT_STRING, 
+            printf("Processing: " CONF_FMT_STRING,
                 mintot - mincon, meantot - meancon,  maxtot - maxcon);
-            printf("Total:      " CONF_FMT_STRING, 
+            printf("Total:      " CONF_FMT_STRING,
                 mintot, meantot, maxtot);
 #undef CONF_FMT_STRING
         }
@@ -943,7 +943,7 @@ static void output_results(void)
                     printf(" 100%%  %5" APR_TIME_T_FMT " (longest request)\n",
                            stats[requests - 1].time);
                 else
-                    printf("  %d%%  %5" APR_TIME_T_FMT "\n", percs[i], 
+                    printf("  %d%%  %5" APR_TIME_T_FMT "\n", percs[i],
                            stats[(int) (requests * percs[i] / 100)].time);
             }
         }
@@ -1051,14 +1051,14 @@ static void output_html_results(void)
                trstring, tdstring, tdstring,
                (float) (totalread + totalposted) / timetaken);
         }
-    } 
+    }
     {
         /* work out connection times */
         long i;
         apr_interval_time_t totalcon = 0, total = 0;
         apr_interval_time_t mincon = AB_MAX, mintot = AB_MAX;
         apr_interval_time_t maxcon = 0, maxtot = 0;
-    
+
         for (i = 0; i < requests; i++) {
             struct data s = stats[i];
             mincon = ap_min(mincon, s.ctime);
@@ -1068,7 +1068,7 @@ static void output_html_results(void)
             totalcon += s.ctime;
             total += s.time;
         }
-    
+
         if (requests > 0) { /* avoid division by zero (if 0 requests) */
             printf("<tr %s><th %s colspan=4>Connnection Times (ms)</th></tr>\n",
                trstring, tdstring);
@@ -1268,12 +1268,12 @@ static void read_connection(struct connection * c)
         status = SSL_read(c->ssl, buffer, r);
         if (status <= 0) {
             int scode = SSL_get_error(c->ssl, status);
-            
+
             if (scode == SSL_ERROR_ZERO_RETURN) {
                 /* connection closed cleanly: */
                 good++;
                 close_connection(c);
-            } 
+            }
             else if (scode != SSL_ERROR_WANT_WRITE
                      && scode != SSL_ERROR_WANT_READ) {
                 /* some fatal error: */
@@ -1286,7 +1286,7 @@ static void read_connection(struct connection * c)
         }
         r = status;
     }
-    else 
+    else
 #endif
     {
         status = apr_socket_recv(c->aprsock, buffer, &r);
@@ -1320,7 +1320,7 @@ static void read_connection(struct connection * c)
         int tocopy = (space < r) ? space : r;
 #ifdef NOT_ASCII
         apr_size_t inbytes_left = space, outbytes_left = space;
-    
+
         status = apr_xlate_conv_buffer(from_ascii, buffer, &inbytes_left,
                            c->cbuff + c->cbx, &outbytes_left);
         if (status || inbytes_left || outbytes_left) {
@@ -1388,7 +1388,7 @@ static void read_connection(struct connection * c)
              * needs to be extended to handle whatever servers folks want to
              * test against. -djg
              */
-    
+
             /* check response code */
             part = strstr(c->cbuff, "HTTP");    /* really HTTP/1.x_ */
             if (part && strlen(part) > strlen("HTTP/1.x_")) {
@@ -1398,7 +1398,7 @@ static void read_connection(struct connection * c)
             else {
                 strcpy(respcode, "500");
             }
-    
+
             if (respcode[0] != '2') {
                 err_response++;
                 if (verbosity >= 2)
@@ -1505,7 +1505,7 @@ static void test(void)
     now = apr_time_now();
 
     con = calloc(concurrency, sizeof(struct connection));
-    
+
     stats = calloc(requests, sizeof(struct data));
 
     if ((status = apr_pollset_create(&readbits, concurrency, cntxt, 0)) != APR_SUCCESS) {
@@ -1514,7 +1514,7 @@ static void test(void)
 
     /* setup request */
     if (posting <= 0) {
-        snprintf_res = apr_snprintf(request, sizeof(_request), 
+        snprintf_res = apr_snprintf(request, sizeof(_request),
             "%s %s HTTP/1.0\r\n"
             "User-Agent: ApacheBench/%s\r\n"
             "%s" "%s" "%s"
@@ -1601,7 +1601,7 @@ static void test(void)
         apr_int32_t n;
         apr_int32_t timed;
             const apr_pollfd_t *pollresults;
-    
+
         /* check for time limit expiry */
         now = apr_time_now();
         timed = (apr_int32_t)apr_time_sec(now - start);
@@ -1609,20 +1609,20 @@ static void test(void)
             requests = done;    /* so stats are correct */
             break;      /* no need to do another round */
         }
-    
+
         n = concurrency;
         status = apr_pollset_poll(readbits, aprtimeout, &n, &pollresults);
         if (status != APR_SUCCESS)
             apr_err("apr_poll", status);
-    
+
         if (!n) {
             err("\nServer timed out\n\n");
         }
-    
+
         for (i = 0; i < n; i++) {
             const apr_pollfd_t *next_fd = &(pollresults[i]);
             struct connection *c;
-                
+
                 c = next_fd->client_data;
 
             /*
@@ -1630,7 +1630,7 @@ static void test(void)
              */
             if (c->state == STATE_UNCONNECTED)
                 continue;
-    
+
             rv = next_fd->rtnevents;
 
 #ifdef USE_SSL
@@ -1694,7 +1694,7 @@ static void test(void)
                     write_request(c);
                 }
             }
-    
+
             /*
              * When using a select based poll every time we check the bits
              * are reset. In 1.3's ab we copied the FD_SET's each time
@@ -2014,7 +2014,7 @@ int main(int argc, const char * const argv[])
                 }
                 l = apr_base64_encode(tmp, optarg, strlen(optarg));
                 tmp[l] = '\0';
-        
+
                 auth = apr_pstrcat(cntxt, auth, "Authorization: Basic ", tmp,
                                        "\r\n", NULL);
                 break;
@@ -2029,7 +2029,7 @@ int main(int argc, const char * const argv[])
                 }
                 l = apr_base64_encode(tmp, optarg, strlen(optarg));
                 tmp[l] = '\0';
-        
+
                 auth = apr_pstrcat(cntxt, auth, "Proxy-Authorization: Basic ",
                                        tmp, "\r\n", NULL);
                 break;
diff --git a/support/htcacheclean.c b/support/htcacheclean.c
index 6e3eb8a..26cbf19 100644
--- a/support/htcacheclean.c
+++ b/support/htcacheclean.c
@@ -450,10 +450,10 @@ static int process_dir(char *path, apr_pool_t *pool)
         case HEADERDATA:
             nextpath = apr_pstrcat(p, path, "/", d->basename,
                                    CACHE_HEADER_SUFFIX, NULL);
-            if (apr_file_open(&fd, nextpath, APR_FOPEN_READ | APR_FOPEN_BINARY, 
+            if (apr_file_open(&fd, nextpath, APR_FOPEN_READ | APR_FOPEN_BINARY,
                               APR_OS_DEFAULT, p) == APR_SUCCESS) {
                 len = sizeof(format);
-                if (apr_file_read_full(fd, &format, len, 
+                if (apr_file_read_full(fd, &format, len,
                                        &len) == APR_SUCCESS) {
                     if (format == DISK_FORMAT_VERSION) {
                         apr_off_t offset = 0;
@@ -483,11 +483,11 @@ static int process_dir(char *path, apr_pool_t *pool)
                         }
                     }
                     else if (format == VARY_FORMAT_VERSION) {
-                        /* This must be a URL that added Vary headers later, 
+                        /* This must be a URL that added Vary headers later,
                          * so kill the orphaned .data file
                          */
                         apr_file_close(fd);
-                        apr_file_remove(apr_pstrcat(p, path, "/", d->basename, 
+                        apr_file_remove(apr_pstrcat(p, path, "/", d->basename,
                                                     CACHE_DATA_SUFFIX, NULL),
                                         p);
                     }
@@ -526,7 +526,7 @@ static int process_dir(char *path, apr_pool_t *pool)
             if (apr_file_open(&fd, nextpath, APR_FOPEN_READ | APR_FOPEN_BINARY,
                               APR_OS_DEFAULT, p) == APR_SUCCESS) {
                 len = sizeof(format);
-                if (apr_file_read_full(fd, &format, len, 
+                if (apr_file_read_full(fd, &format, len,
                                        &len) == APR_SUCCESS) {
                     if (format == VARY_FORMAT_VERSION) {
                         apr_time_t expires;
@@ -824,7 +824,7 @@ int main(int argc, const char * const argv[])
                 }
                 benice = 1;
                 break;
-                
+
             case 't':
                 if (deldirs) {
                     usage();
diff --git a/support/htdbm.c b/support/htdbm.c
index 9af6dad..5ad14c0 100644
--- a/support/htdbm.c
+++ b/support/htdbm.c
@@ -65,7 +65,7 @@
 #define ALG_PLAIN 0
 #define ALG_APMD5 1
 #define ALG_APSHA 2
- 
+
 #if APR_HAVE_CRYPT_H
 #define ALG_CRYPT 3
 #endif
@@ -114,7 +114,7 @@ static void terminate(void)
 #endif
 }
 
-static void htdbm_terminate(htdbm_t *htdbm) 
+static void htdbm_terminate(htdbm_t *htdbm)
 {
     if (htdbm->dbm)
         apr_dbm_close(htdbm->dbm);
@@ -122,15 +122,15 @@ static void htdbm_terminate(htdbm_t *htdbm)
 }
 
 static htdbm_t *h;
-  
-static void htdbm_interrupted(void) 
+
+static void htdbm_interrupted(void)
 {
     htdbm_terminate(h);
     fprintf(stderr, "htdbm Interrupted !\n");
     exit(ERR_INTERRUPTED);
 }
 
-static apr_status_t htdbm_init(apr_pool_t **pool, htdbm_t **hdbm) 
+static apr_status_t htdbm_init(apr_pool_t **pool, htdbm_t **hdbm)
 {
 
 #if APR_CHARSET_EBCDIC
@@ -167,18 +167,18 @@ static apr_status_t htdbm_init(apr_pool_t **pool, htdbm_t **hdbm)
     return APR_SUCCESS;
 }
 
-static apr_status_t htdbm_open(htdbm_t *htdbm) 
+static apr_status_t htdbm_open(htdbm_t *htdbm)
 {
     if (htdbm->create)
-        return apr_dbm_open_ex(&htdbm->dbm, htdbm->type, htdbm->filename, APR_DBM_RWCREATE, 
+        return apr_dbm_open_ex(&htdbm->dbm, htdbm->type, htdbm->filename, APR_DBM_RWCREATE,
                             APR_OS_DEFAULT, htdbm->pool);
     else
-        return apr_dbm_open_ex(&htdbm->dbm, htdbm->type, htdbm->filename, 
-                            htdbm->rdonly ? APR_DBM_READONLY : APR_DBM_READWRITE, 
+        return apr_dbm_open_ex(&htdbm->dbm, htdbm->type, htdbm->filename,
+                            htdbm->rdonly ? APR_DBM_READONLY : APR_DBM_READWRITE,
                             APR_OS_DEFAULT, htdbm->pool);
 }
 
-static apr_status_t htdbm_save(htdbm_t *htdbm, int *changed) 
+static apr_status_t htdbm_save(htdbm_t *htdbm, int *changed)
 {
     apr_datum_t key, val;
 
@@ -201,7 +201,7 @@ static apr_status_t htdbm_save(htdbm_t *htdbm, int *changed)
     return apr_dbm_store(htdbm->dbm, key, val);
 }
 
-static apr_status_t htdbm_del(htdbm_t *htdbm) 
+static apr_status_t htdbm_del(htdbm_t *htdbm)
 {
     apr_datum_t key;
 
@@ -213,7 +213,7 @@ static apr_status_t htdbm_del(htdbm_t *htdbm)
     return apr_dbm_delete(htdbm->dbm, key);
 }
 
-static apr_status_t htdbm_verify(htdbm_t *htdbm) 
+static apr_status_t htdbm_verify(htdbm_t *htdbm)
 {
     apr_datum_t key, val;
     char pwd[MAX_STRING_LEN] = {0};
@@ -222,7 +222,7 @@ static apr_status_t htdbm_verify(htdbm_t *htdbm)
     key.dptr = htdbm->username;
     key.dsize = strlen(htdbm->username);
     if (!apr_dbm_exists(htdbm->dbm, key))
-        return APR_ENOENT;    
+        return APR_ENOENT;
     if (apr_dbm_fetch(htdbm->dbm, key, &val) != APR_SUCCESS)
         return APR_ENOENT;
     rec = apr_pstrndup(htdbm->pool, val.dptr, val.dsize);
@@ -234,7 +234,7 @@ static apr_status_t htdbm_verify(htdbm_t *htdbm)
     return apr_password_validate(htdbm->userpass, pwd);
 }
 
-static apr_status_t htdbm_list(htdbm_t *htdbm) 
+static apr_status_t htdbm_list(htdbm_t *htdbm)
 {
     apr_status_t rv;
     apr_datum_t key, val;
@@ -244,13 +244,13 @@ static apr_status_t htdbm_list(htdbm_t *htdbm)
 
     rv = apr_dbm_firstkey(htdbm->dbm, &key);
     if (rv != APR_SUCCESS) {
-        fprintf(stderr, "Empty database -- %s\n", htdbm->filename); 
+        fprintf(stderr, "Empty database -- %s\n", htdbm->filename);
         return APR_ENOENT;
     }
     rec = apr_pcalloc(htdbm->pool, HUGE_STRING_LEN);
 
-    fprintf(stderr, "Dumping records from database -- %s\n", htdbm->filename); 
-    fprintf(stderr, "    %-32sComment\n", "Username");    
+    fprintf(stderr, "Dumping records from database -- %s\n", htdbm->filename);
+    fprintf(stderr, "    %-32sComment\n", "Username");
     while (key.dptr != NULL) {
         rv = apr_dbm_fetch(htdbm->dbm, key, &val);
         if (rv != APR_SUCCESS) {
@@ -287,7 +287,7 @@ static void to64(char *s, unsigned long v, int n)
     }
 }
 
-static apr_status_t htdbm_make(htdbm_t *htdbm) 
+static apr_status_t htdbm_make(htdbm_t *htdbm)
 {
     char cpw[MAX_STRING_LEN];
     char salt[9];
@@ -298,7 +298,7 @@ static apr_status_t htdbm_make(htdbm_t *htdbm)
             apr_sha1_base64(htdbm->userpass,strlen(htdbm->userpass),cpw);
         break;
 
-        case ALG_APMD5: 
+        case ALG_APMD5:
             (void) srand((int) time((time_t *) NULL));
             to64(&salt[0], rand(), 8);
             salt[8] = '\0';
@@ -404,7 +404,7 @@ int main(int argc, const char * const argv[])
     }
     /*
      * Preliminary check to make sure they provided at least
-     * three arguments, we'll do better argument checking as 
+     * three arguments, we'll do better argument checking as
      * we parse the command line.
      */
     if (argc < 3)
@@ -417,7 +417,7 @@ int main(int argc, const char * const argv[])
         arg = argv[i];
         if (*arg != '-')
             break;
-        
+
         while (*++arg != '\0') {
             switch (*arg) {
             case 'b':
@@ -520,7 +520,7 @@ int main(int argc, const char * const argv[])
             fprintf(stderr, "Password verification error\n");
             exit(ERR_PWMISMATCH);
         }
-            
+
         h->userpass = apr_pstrdup(pool,  pwi);
     }
     if (need_cmnt && pwd_supplied)
@@ -558,13 +558,13 @@ int main(int argc, const char * const argv[])
             htdbm_make(h);
             break;
 
-    }    
+    }
     if (need_file && !h->rdonly) {
         if ((rv = htdbm_save(h, &changed)) != APR_SUCCESS) {
             apr_strerror(rv, errbuf, sizeof(errbuf));
             exit(ERR_FILEPERM);
         }
-        fprintf(stdout, "Database %s %s.\n", h->filename, 
+        fprintf(stdout, "Database %s %s.\n", h->filename,
                 h->create ? "created" : (changed ? "modified" : "updated"));
     }
     if (cmd == HTDBM_NOFILE) {
@@ -577,6 +577,6 @@ int main(int argc, const char * const argv[])
         }
     }
     htdbm_terminate(h);
-    
+
     return 0; /* Suppress compiler warning. */
 }
diff --git a/support/htdigest.c b/support/htdigest.c
index f90a672..d84d573 100644
--- a/support/htdigest.c
+++ b/support/htdigest.c
@@ -96,7 +96,7 @@ static int get_line(char *s, int n, apr_file_t *f)
     char ch;
     apr_status_t rv = APR_EINVAL;
 
-    while (i < (n - 1) && 
+    while (i < (n - 1) &&
            ((rv = apr_file_getc(&ch, f)) == APR_SUCCESS) && (ch != '\n')) {
         s[i++] = ch;
     }
@@ -104,7 +104,7 @@ static int get_line(char *s, int n, apr_file_t *f)
         s[i++] = ch;
     s[i] = '\0';
 
-    if (rv != APR_SUCCESS) 
+    if (rv != APR_SUCCESS)
         return 1;
 
     return 0;
@@ -193,9 +193,9 @@ int main(int argc, const char * const argv[])
     char w[MAX_STRING_LEN];
     char x[MAX_STRING_LEN];
     int found;
-   
+
     apr_app_initialize(&argc, &argv, NULL);
-    atexit(terminate); 
+    atexit(terminate);
     apr_pool_create(&cntxt, NULL);
     apr_file_open_stderr(&errfile, cntxt);
 
@@ -207,7 +207,7 @@ int main(int argc, const char * const argv[])
         exit(1);
     }
 #endif
-    
+
     apr_signal(SIGINT, (void (*)(int)) interrupted);
     if (argc == 5) {
         if (strcmp(argv[1], "-c"))
@@ -222,7 +222,7 @@ int main(int argc, const char * const argv[])
                     apr_strerror(rv, errmsg, sizeof errmsg));
             exit(1);
         }
-        apr_file_printf(errfile, "Adding password for %s in realm %s.\n", 
+        apr_file_printf(errfile, "Adding password for %s in realm %s.\n",
                     argv[4], argv[3]);
         add_password(argv[4], argv[3], f);
         apr_file_close(f);
@@ -266,7 +266,7 @@ int main(int argc, const char * const argv[])
             continue;
         }
         else {
-            apr_file_printf(errfile, "Changing password for user %s in realm %s\n", 
+            apr_file_printf(errfile, "Changing password for user %s in realm %s\n",
                     user, realm);
             add_password(user, realm, tfp);
             found = 1;
@@ -282,7 +282,7 @@ int main(int argc, const char * const argv[])
      */
     if (apr_file_copy(dirname, argv[1], APR_FILE_SOURCE_PERMS, cntxt) !=
                 APR_SUCCESS) {
-        apr_file_printf(errfile, "%s: unable to update file %s\n", 
+        apr_file_printf(errfile, "%s: unable to update file %s\n",
                         argv[0], argv[1]);
     }
     apr_file_close(tfp);
diff --git a/support/htpasswd.c b/support/htpasswd.c
index 2076463..588c892 100644
--- a/support/htpasswd.c
+++ b/support/htpasswd.c
@@ -23,7 +23,7 @@
 /*
  * htpasswd.c: simple program for manipulating password file for
  * the Apache HTTP server
- * 
+ *
  * Originally by Rob McCool
  *
  * Exit values:
@@ -84,7 +84,7 @@
 #define ALG_PLAIN 0
 #define ALG_CRYPT 1
 #define ALG_APMD5 2
-#define ALG_APSHA 3 
+#define ALG_APSHA 3
 
 #define ERR_FILEPERM 1
 #define ERR_SYNTAX 2
@@ -141,7 +141,7 @@ static int mkrecord(char *user, char *record, apr_size_t rlen, char *passwd,
     else {
         bufsize = sizeof(pwin);
         if (apr_password_get("New password: ", pwin, &bufsize) != 0) {
-            apr_snprintf(record, (rlen - 1), "password too long (>%" 
+            apr_snprintf(record, (rlen - 1), "password too long (>%"
                          APR_SIZE_T_FMT ")", sizeof(pwin) - 1);
             return ERR_OVERFLOW;
         }
@@ -161,7 +161,7 @@ static int mkrecord(char *user, char *record, apr_size_t rlen, char *passwd,
         apr_sha1_base64(pw,strlen(pw),cpw);
         break;
 
-    case ALG_APMD5: 
+    case ALG_APMD5:
         (void) srand((int) time((time_t *) NULL));
         to64(&salt[0], rand(), 8);
         salt[8] = '\0';
@@ -272,8 +272,8 @@ static void terminate(void)
 #endif
 }
 
-static void check_args(apr_pool_t *pool, int argc, const char *const argv[], 
-                       int *alg, int *mask, char **user, char **pwfilename, 
+static void check_args(apr_pool_t *pool, int argc, const char *const argv[],
+                       int *alg, int *mask, char **user, char **pwfilename,
                        char **password)
 {
     const char *arg;
@@ -282,7 +282,7 @@ static void check_args(apr_pool_t *pool, int argc, const char *const argv[],
 
     /*
      * Preliminary check to make sure they provided at least
-     * three arguments, we'll do better argument checking as 
+     * three arguments, we'll do better argument checking as
      * we parse the command line.
      */
     if (argc < 3) {
@@ -517,7 +517,7 @@ int main(int argc, const char * const argv[])
     dirname = apr_psprintf(pool, "%s/%s", dirname, tn);
 
     if (apr_file_mktemp(&ftemp, dirname, 0, pool) != APR_SUCCESS) {
-        apr_file_printf(errfile, "%s: unable to create temporary file %s" NL, 
+        apr_file_printf(errfile, "%s: unable to create temporary file %s" NL,
                         argv[0], dirname);
         exit(ERR_FILEPERM);
     }
@@ -529,7 +529,7 @@ int main(int argc, const char * const argv[])
     if (existing_file && !(mask & APHTP_NEWFILE)) {
         if (apr_file_open(&fpw, pwfilename, APR_READ | APR_BUFFERED,
                           APR_OS_DEFAULT, pool) != APR_SUCCESS) {
-            apr_file_printf(errfile, "%s: unable to read file %s" NL, 
+            apr_file_printf(errfile, "%s: unable to read file %s" NL,
                             argv[0], pwfilename);
             exit(ERR_FILEPERM);
         }
@@ -555,7 +555,7 @@ int main(int argc, const char * const argv[])
             }
             else {
                 /*
-                 * If we've not got a colon on the line, this could well 
+                 * If we've not got a colon on the line, this could well
                  * not be a valid htpasswd file.
                  * We should bail at this point.
                  */
@@ -603,7 +603,7 @@ int main(int argc, const char * const argv[])
      */
     if (apr_file_copy(dirname, pwfilename, APR_FILE_SOURCE_PERMS, pool) !=
         APR_SUCCESS) {
-        apr_file_printf(errfile, "%s: unable to update file %s" NL, 
+        apr_file_printf(errfile, "%s: unable to update file %s" NL,
                         argv[0], pwfilename);
         exit(ERR_FILEPERM);
     }
diff --git a/support/httxt2dbm.c b/support/httxt2dbm.c
index 023f02d..b45a0a7 100644
--- a/support/httxt2dbm.c
+++ b/support/httxt2dbm.c
@@ -157,7 +157,7 @@ static apr_status_t to_dbm(apr_dbm_t *dbm, apr_file_t *fp, apr_pool_t *pool)
         dbmval.dsize = (c - line);
 
         if (verbose) {
-            apr_file_printf(errfile, "    '%s' -> '%s'"NL, 
+            apr_file_printf(errfile, "    '%s' -> '%s'"NL,
                             dbmkey.dptr, dbmval.dptr);
         }
 
@@ -173,7 +173,7 @@ static apr_status_t to_dbm(apr_dbm_t *dbm, apr_file_t *fp, apr_pool_t *pool)
     return rv;
 }
 
-int main(int argc, const char *const argv[]) 
+int main(int argc, const char *const argv[])
 {
     apr_pool_t *pool;
     apr_status_t rv = APR_SUCCESS;
@@ -280,12 +280,12 @@ int main(int argc, const char *const argv[])
         rv = apr_file_open_stdin(&infile, pool);
     }
     else {
-        rv = apr_file_open(&infile, input, APR_READ|APR_BUFFERED, 
+        rv = apr_file_open(&infile, input, APR_READ|APR_BUFFERED,
                            APR_OS_DEFAULT, pool);
     }
 
     if (rv != APR_SUCCESS) {
-        apr_file_printf(errfile, 
+        apr_file_printf(errfile,
                         "Error: Cannot open input file '%s': (%d) %s" NL NL,
                          input, rv, apr_strerror(rv, errbuf, sizeof(errbuf)));
         return 1;
@@ -295,18 +295,18 @@ int main(int argc, const char *const argv[])
         apr_file_printf(errfile, "Input File: %s"NL, input);
     }
 
-    rv = apr_dbm_open_ex(&outdbm, format, output, APR_DBM_RWCREATE, 
+    rv = apr_dbm_open_ex(&outdbm, format, output, APR_DBM_RWCREATE,
                     APR_OS_DEFAULT, pool);
 
     if (APR_STATUS_IS_ENOTIMPL(rv)) {
-        apr_file_printf(errfile, 
+        apr_file_printf(errfile,
                         "Error: The requested DBM Format '%s' is not available." NL NL,
                          format);
         return 1;
     }
 
     if (rv != APR_SUCCESS) {
-        apr_file_printf(errfile, 
+        apr_file_printf(errfile,
                         "Error: Cannot open output DBM '%s': (%d) %s" NL NL,
                          output, rv, apr_strerror(rv, errbuf, sizeof(errbuf)));
         return 1;
@@ -319,7 +319,7 @@ int main(int argc, const char *const argv[])
     rv = to_dbm(outdbm, infile, pool);
 
     if (rv != APR_SUCCESS) {
-        apr_file_printf(errfile, 
+        apr_file_printf(errfile,
                         "Error: Converting to DBM: (%d) %s" NL NL,
                          rv, apr_strerror(rv, errbuf, sizeof(errbuf)));
         return 1;
diff --git a/support/logresolve.c b/support/logresolve.c
index f490745..a17259b 100644
--- a/support/logresolve.c
+++ b/support/logresolve.c
@@ -91,14 +91,14 @@ static void print_statistics (apr_file_t *output)
     apr_file_printf(output, "Entries: %d" NL, entries);
     apr_file_printf(output, "    With name   : %d" NL, withname);
     apr_file_printf(output, "    Resolves    : %d" NL, resolves);
-    
+
     if (noreverse) {
-    	apr_file_printf(output, "    - No reverse : %d" NL, 
+    	apr_file_printf(output, "    - No reverse : %d" NL,
                         noreverse);
     }
-    
+
     if (doublefailed) {
-    	apr_file_printf(output, "    - Double lookup failed : %d" NL, 
+    	apr_file_printf(output, "    - Double lookup failed : %d" NL,
                         doublefailed);
     }
 
@@ -123,7 +123,7 @@ static void usage(void)
     exit(1);
 }
 #undef NL
- 
+
 int main(int argc, const char * const argv[])
 {
     apr_file_t * outfile;
@@ -139,18 +139,18 @@ int main(int argc, const char * const argv[])
     char * stats = NULL;
     char * space;
     char * hostname;
-#if APR_MAJOR_VERSION > 1 || (APR_MAJOR_VERSION == 1 && APR_MINOR_VERSION >= 3) 
+#if APR_MAJOR_VERSION > 1 || (APR_MAJOR_VERSION == 1 && APR_MINOR_VERSION >= 3)
     char * inbuffer;
     char * outbuffer;
 #endif
     char line[2048];
     int doublelookups = 0;
-    
+
     if (apr_app_initialize(&argc, &argv, NULL) != APR_SUCCESS) {
         return 1;
     }
     atexit(apr_terminate);
- 
+
     if (argc) {
         shortname = apr_filepath_name_get(argv[0]);
     }
@@ -160,7 +160,7 @@ int main(int argc, const char * const argv[])
     }
     apr_file_open_stderr(&errfile, pool);
     apr_getopt_init(&o, pool, argc, argv);
- 
+
     while (1) {
         status = apr_getopt(o, "s:c", &opt, &arg);
         if (status == APR_EOF) {
@@ -186,22 +186,22 @@ int main(int argc, const char * const argv[])
             } /* switch */
         } /* else */
     } /* while */
- 
+
     apr_file_open_stdout(&outfile, pool);
     apr_file_open_stdin(&infile, pool);
 
-#if APR_MAJOR_VERSION > 1 || (APR_MAJOR_VERSION == 1 && APR_MINOR_VERSION >= 3) 
+#if APR_MAJOR_VERSION > 1 || (APR_MAJOR_VERSION == 1 && APR_MINOR_VERSION >= 3)
     /* Allocate two new 10k file buffers */
     if ((outbuffer = apr_palloc(pool, 10240)) == NULL ||
         (inbuffer = apr_palloc(pool, 10240)) == NULL) {
         return 1;
     }
-    
+
     /* Set the buffers */
     apr_file_buffer_set(infile, inbuffer, 10240);
     apr_file_buffer_set(outfile, outbuffer, 10240);
 #endif
-    
+
     cache = apr_hash_make(pool);
 
     while (apr_file_gets(line, 2048, infile) == APR_SUCCESS) {
@@ -216,9 +216,9 @@ int main(int argc, const char * const argv[])
         if (!apr_isxdigit(line[0]) && line[0] != ':') {
                 withname++;
             apr_file_puts(line, outfile);
-            continue;    
+            continue;
         }
-        
+
         /* Terminate the line at the next space */
         if ((space = strchr(line, ' ')) != NULL) {
             *space = '\0';
@@ -241,18 +241,18 @@ int main(int argc, const char * const argv[])
             apr_file_puts(line, outfile);
             continue;
         }
-        
+
         /* This does not make much sense, but historically "resolves" means
          * "parsed as an IP address". It does not mean we actually resolved
          * the IP address into a hostname.
-         */ 
+         */
             resolves++;
-        
+
         /* From here on our we cache each result, even if it was not
-         * succesful 
+         * succesful
          */
         cachesize++;
-        
+
         /* Try and perform a reverse lookup */
         status = apr_getnameinfo(&hostname, ip, 0) != APR_SUCCESS;
         if (status || hostname == NULL) {
@@ -263,7 +263,7 @@ int main(int argc, const char * const argv[])
 
             /* Add to cache */
             *space = '\0';
-            apr_hash_set(cache, line, APR_HASH_KEY_STRING, 
+            apr_hash_set(cache, line, APR_HASH_KEY_STRING,
                          apr_pstrdup(pool, line));
             continue;
         }
@@ -273,9 +273,9 @@ int main(int argc, const char * const argv[])
             /* Do a forward lookup on our hostname, and see if that matches our
              * original IP address.
              */
-            status = apr_sockaddr_info_get(&ipdouble, hostname, ip->family, 0, 
+            status = apr_sockaddr_info_get(&ipdouble, hostname, ip->family, 0,
                                            0, pool);
-            if (status == APR_SUCCESS || 
+            if (status == APR_SUCCESS ||
                 memcmp(ipdouble->ipaddr_ptr, ip->ipaddr_ptr, ip->ipaddr_len)) {
                 /* Double-lookup failed  */
                 *space = ' ';
@@ -284,7 +284,7 @@ int main(int argc, const char * const argv[])
 
                 /* Add to cache */
                 *space = '\0';
-                apr_hash_set(cache, line, APR_HASH_KEY_STRING, 
+                apr_hash_set(cache, line, APR_HASH_KEY_STRING,
                              apr_pstrdup(pool, line));
                 continue;
             }
@@ -294,18 +294,18 @@ int main(int argc, const char * const argv[])
         apr_file_printf(outfile, "%s %s", hostname, space + 1);
 
         /* Store it in the cache */
-        apr_hash_set(cache, line, APR_HASH_KEY_STRING, 
+        apr_hash_set(cache, line, APR_HASH_KEY_STRING,
                      apr_pstrdup(pool, hostname));
     }
 
     /* Flush any remaining output */
     apr_file_flush(outfile);
-    
+
     if (stats) {
-        if (apr_file_open(&statsfile, stats, 
-                       APR_FOPEN_WRITE | APR_FOPEN_CREATE | APR_FOPEN_TRUNCATE, 
+        if (apr_file_open(&statsfile, stats,
+                       APR_FOPEN_WRITE | APR_FOPEN_CREATE | APR_FOPEN_TRUNCATE,
                           APR_OS_DEFAULT, pool) != APR_SUCCESS) {
-            apr_file_printf(errfile, "%s: Could not open %s for writing.", 
+            apr_file_printf(errfile, "%s: Could not open %s for writing.",
                             shortname, stats);
             return 1;
         }
diff --git a/support/rotatelogs.c b/support/rotatelogs.c
index 14a56e8..1b4226d 100644
--- a/support/rotatelogs.c
+++ b/support/rotatelogs.c
@@ -171,7 +171,7 @@ int main (int argc, const char * const argv[])
             apr_finfo_t finfo;
             apr_off_t current_size = -1;
 
-            if ((nLogFD != NULL) && 
+            if ((nLogFD != NULL) &&
                 (apr_file_info_get(&finfo, APR_FINFO_SIZE, nLogFD) == APR_SUCCESS)) {
                 current_size = finfo.size;
             }
@@ -188,7 +188,7 @@ int main (int argc, const char * const argv[])
 
         if (nLogFD == NULL) {
             int tLogStart;
-                
+
             if (tRotation) {
                 tLogStart = (now / tRotation) * tRotation;
             }
diff --git a/support/suexec.c b/support/suexec.c
index ed69226..8ee7485 100644
--- a/support/suexec.c
+++ b/support/suexec.c
@@ -20,8 +20,8 @@
  ***********************************************************************
  *
  * NOTE! : DO NOT edit this code!!!  Unless you know what you are doing,
- *         editing this code might open up your system in unexpected 
- *         ways to would-be crackers.  Every precaution has been taken 
+ *         editing this code might open up your system in unexpected
+ *         ways to would-be crackers.  Every precaution has been taken
  *         to make this code as safe as possible; alter it at your own
  *         risk.
  *
@@ -217,9 +217,9 @@ static void clean_env(void)
      */
     char **envp = environ;
     char *empty_ptr = NULL;
- 
+
     environ = &empty_ptr; /* VERY safe environment */
-    
+
     if ((cleanenv = (char **) calloc(AP_ENVBUF, sizeof(char *))) == NULL) {
         log_err("failed to malloc memory for environment\n");
         exit(120);
@@ -429,7 +429,7 @@ int main(int argc, char *argv[])
         }
     }
 #endif /*_OSD_POSIX*/
-    
+
     /*
      * Save these for later since initgroups will hose the struct
      */
@@ -438,7 +438,7 @@ int main(int argc, char *argv[])
     target_homedir = strdup(pw->pw_dir);
 
     /*
-     * Log the transaction here to be sure we have an open log 
+     * Log the transaction here to be sure we have an open log
      * before we setuid().
      */
     log_no_err("uid: (%s/%s) gid: (%s/%s) cmd: %s\n",
@@ -595,9 +595,9 @@ int main(int argc, char *argv[])
     umask(AP_SUEXEC_UMASK);
 #endif /* AP_SUEXEC_UMASK */
 
-    /* 
+    /*
      * Be sure to close the log file so the CGI can't
-     * mess with it.  If the exec fails, it will be reopened 
+     * mess with it.  If the exec fails, it will be reopened
      * automatically when log_err is called.  Note that the log
      * might not actually be open if AP_LOG_EXEC isn't defined.
      * However, the "log" cell isn't ifdef'd so let's be defensive
diff --git a/support/win32/ApacheMonitor.c b/support/win32/ApacheMonitor.c
index a35313b..8f396d3 100644
--- a/support/win32/ApacheMonitor.c
+++ b/support/win32/ApacheMonitor.c
@@ -20,7 +20,7 @@
  * Contributed by Mladen Turk <mturk mappingsoft.com>
  *
  * 05 Aug 2001
- * ==================================================================== 
+ * ====================================================================
  */
 
 #define _WIN32_WINNT 0x0400
@@ -89,8 +89,8 @@ BOOL              g_bConsoleRun = FALSE;
 ST_APACHE_SERVICE g_stServices[MAX_APACHE_SERVICES];
 ST_MONITORED_COMP g_stComputers[MAX_APACHE_COMPUTERS];
 
-HBITMAP           g_hBmpStart, g_hBmpStop; 
-HBITMAP           g_hBmpPicture, g_hBmpOld; 
+HBITMAP           g_hBmpStart, g_hBmpStop;
+HBITMAP           g_hBmpPicture, g_hBmpOld;
 BOOL              g_bRescanServices;
 HWND              g_hwndServiceDlg;
 HWND              g_hwndMain;
@@ -116,7 +116,7 @@ static CHAR *g_lpMsg[IDS_MSG_LAST - IDS_MSG_FIRST + 1];
 void am_ClearServicesSt()
 {
     int i;
-    for (i = 0; i < MAX_APACHE_SERVICES; i++) 
+    for (i = 0; i < MAX_APACHE_SERVICES; i++)
     {
         if (g_stServices[i].szServiceName) {
             free(g_stServices[i].szServiceName);
@@ -187,7 +187,7 @@ void am_DisconnectComputer(LPSTR szComputerName)
             g_stComputers[i].szComputerName = NULL;
             g_stComputers[i].hRegistry = NULL;
         }
-    } 
+    }
 
 }
 
@@ -205,7 +205,7 @@ void ErrorMessage(LPCSTR szError, BOOL bFatal)
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                       NULL, GetLastError(), g_LangID,
                       (LPSTR) &lpMsgBuf, 0, NULL);
-        MessageBox(NULL, (LPCSTR)lpMsgBuf, 
+        MessageBox(NULL, (LPCSTR)lpMsgBuf,
                    g_lpMsg[IDS_MSG_ERROR - IDS_MSG_FIRST],
                    MB_OK | (bFatal ? MB_ICONERROR : MB_ICONEXCLAMATION));
         LocalFree(lpMsgBuf);
@@ -231,9 +231,9 @@ BOOL am_ConnectComputer(LPSTR szComputerName)
     if (i > MAX_APACHE_COMPUTERS - 1) {
         return FALSE;
     }
-    if (RegConnectRegistry(szComputerName, HKEY_LOCAL_MACHINE, &hKeyRemote) 
+    if (RegConnectRegistry(szComputerName, HKEY_LOCAL_MACHINE, &hKeyRemote)
             != ERROR_SUCCESS) {
-        sprintf(szTmp, g_lpMsg[IDS_MSG_ECONNECT - IDS_MSG_FIRST], 
+        sprintf(szTmp, g_lpMsg[IDS_MSG_ECONNECT - IDS_MSG_FIRST],
                 szComputerName);
         ErrorMessage(szTmp, FALSE);
         return FALSE;
@@ -243,7 +243,7 @@ BOOL am_ConnectComputer(LPSTR szComputerName)
         g_stComputers[i].hRegistry = hKeyRemote;
         return TRUE;
     }
-} 
+}
 
 
 LPSTR GetStringRes(int id)
@@ -259,7 +259,7 @@ LPSTR GetStringRes(int id)
 BOOL GetSystemOSVersion(LPDWORD dwVersion)
 {
     OSVERSIONINFO osvi;
-    /* 
+    /*
     Try calling GetVersionEx using the OSVERSIONINFOEX structure.
     If that fails, try using the OSVERSIONINFO structure.
     */
@@ -293,7 +293,7 @@ BOOL GetSystemOSVersion(LPDWORD dwVersion)
         *dwVersion = 0;
         return FALSE;
     }
-    return TRUE; 
+    return TRUE;
 }
 
 
@@ -344,7 +344,7 @@ static VOID ShowNotifyIcon(HWND hWnd, DWORD dwMessage)
 }
 
 
-void appendMenuItem(HMENU hMenu, UINT uMenuId, LPSTR szName, 
+void appendMenuItem(HMENU hMenu, UINT uMenuId, LPSTR szName,
                     BOOL fDefault, BOOL fEnabled)
 {
     MENUITEMINFO mii;
@@ -371,7 +371,7 @@ void appendMenuItem(HMENU hMenu, UINT uMenuId, LPSTR szName,
 }
 
 
-void appendServiceMenu(HMENU hMenu, UINT uMenuId, 
+void appendServiceMenu(HMENU hMenu, UINT uMenuId,
                        LPSTR szServiceName, BOOL fRunning)
 {
     MENUITEMINFO mii;
@@ -379,16 +379,16 @@ void appendServiceMenu(HMENU hMenu, UINT uMenuId,
 
     smh = CreatePopupMenu();
 
-    appendMenuItem(smh, IDM_SM_START + uMenuId, 
+    appendMenuItem(smh, IDM_SM_START + uMenuId,
                    g_lpMsg[IDS_MSG_SSTART - IDS_MSG_FIRST], FALSE, !fRunning);
-    appendMenuItem(smh, IDM_SM_STOP + uMenuId, 
+    appendMenuItem(smh, IDM_SM_STOP + uMenuId,
                    g_lpMsg[IDS_MSG_SSTOP - IDS_MSG_FIRST], FALSE, fRunning);
-    appendMenuItem(smh, IDM_SM_RESTART + uMenuId, 
+    appendMenuItem(smh, IDM_SM_RESTART + uMenuId,
                    g_lpMsg[IDS_MSG_SRESTART - IDS_MSG_FIRST], FALSE, fRunning);
 
     memset(&mii, 0, sizeof(MENUITEMINFO));
     mii.cbSize = sizeof(MENUITEMINFO);
-    mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE | MIIM_SUBMENU 
+    mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE | MIIM_SUBMENU
               | MIIM_CHECKMARKS;
     mii.fType = MFT_STRING;
     mii.wID = uMenuId;
@@ -409,16 +409,16 @@ void ShowTryPopupMenu(HWND hWnd)
 
     if (hMenu)
     {
-        appendMenuItem(hMenu, IDM_RESTORE, 
-                       g_lpMsg[IDS_MSG_MNUSHOW - IDS_MSG_FIRST], 
+        appendMenuItem(hMenu, IDM_RESTORE,
+                       g_lpMsg[IDS_MSG_MNUSHOW - IDS_MSG_FIRST],
                        TRUE, TRUE);
         if (g_dwOSVersion >= OS_VERSION_WINNT) {
-            appendMenuItem(hMenu, IDC_SMANAGER, 
-                           g_lpMsg[IDS_MSG_MNUSERVICES - IDS_MSG_FIRST], 
+            appendMenuItem(hMenu, IDC_SMANAGER,
+                           g_lpMsg[IDS_MSG_MNUSERVICES - IDS_MSG_FIRST],
                            FALSE, TRUE);
         }
         appendMenuItem(hMenu, 0, "", FALSE, TRUE);
-        appendMenuItem(hMenu, IDM_EXIT, 
+        appendMenuItem(hMenu, IDM_EXIT,
                        g_lpMsg[IDS_MSG_MNUEXIT - IDS_MSG_FIRST],
                        FALSE, TRUE);
 
@@ -426,7 +426,7 @@ void ShowTryPopupMenu(HWND hWnd)
             SetForegroundWindow(NULL);
         }
         GetCursorPos(&pt);
-        TrackPopupMenu(hMenu, TPM_LEFTALIGN|TPM_RIGHTBUTTON, 
+        TrackPopupMenu(hMenu, TPM_LEFTALIGN|TPM_RIGHTBUTTON,
                        pt.x, pt.y, 0, hWnd, NULL);
         DestroyMenu(hMenu);
     }
@@ -454,7 +454,7 @@ void ShowTryServicesMenu(HWND hWnd)
                 SetForegroundWindow(NULL);
             }
             GetCursorPos(&pt);
-            TrackPopupMenu(hMenu, TPM_LEFTALIGN|TPM_RIGHTBUTTON, 
+            TrackPopupMenu(hMenu, TPM_LEFTALIGN|TPM_RIGHTBUTTON,
                            pt.x, pt.y, 0, hWnd, NULL);
             DestroyMenu(hMenu);
         }
@@ -486,18 +486,18 @@ BOOL CenterWindow(HWND hwndChild)
    /* Calculate new X and Y position*/
    xNew = (rWorkArea.right - wChild) / 2;
    yNew = (rWorkArea.bottom - hChild) / 2;
-   return SetWindowPos(hwndChild, HWND_TOP, xNew, yNew, 0, 0, 
+   return SetWindowPos(hwndChild, HWND_TOP, xNew, yNew, 0, 0,
                        SWP_NOSIZE | SWP_SHOWWINDOW);
 }
 
 
-static void addListBoxItem(HWND hDlg, LPSTR lpStr, HBITMAP hBmp) 
-{ 
-    LRESULT nItem; 
- 
-    nItem = SendMessage(hDlg, LB_ADDSTRING, 0, (LPARAM)lpStr); 
-    SendMessage(hDlg, LB_SETITEMDATA, nItem, (LPARAM)hBmp); 
-} 
+static void addListBoxItem(HWND hDlg, LPSTR lpStr, HBITMAP hBmp)
+{
+    LRESULT nItem;
+
+    nItem = SendMessage(hDlg, LB_ADDSTRING, 0, (LPARAM)lpStr);
+    SendMessage(hDlg, LB_SETITEMDATA, nItem, (LPARAM)hBmp);
+}
 
 
 static void addListBoxString(HWND hListBox, LPSTR lpStr)
@@ -507,9 +507,9 @@ static void addListBoxString(HWND hListBox, LPSTR lpStr)
         return;
     }
     ++nItems;
-    if (nItems > MAX_LOADSTRING) 
+    if (nItems > MAX_LOADSTRING)
     {
-        SendMessage(hListBox, LB_RESETCONTENT, 0, 0); 
+        SendMessage(hListBox, LB_RESETCONTENT, 0, 0);
         nItems = 1;
     }
     ListBox_SetCurSel(hListBox,
@@ -525,17 +525,17 @@ static DWORD WINAPI ConsoleOutputThread(LPVOID lpThreadParameter)
     BYTE ch;
     DWORD dwReaded;
 
-    while (ReadFile(g_hpipeOutRead, &ch, 1, &dwReaded, NULL) == TRUE) 
+    while (ReadFile(g_hpipeOutRead, &ch, 1, &dwReaded, NULL) == TRUE)
     {
-        if (dwReaded > 0) 
+        if (dwReaded > 0)
         {
-            if (ch == '\n' || nPtr >= MAX_PATH) 
+            if (ch == '\n' || nPtr >= MAX_PATH)
             {
                 lpBuffer[nPtr] = '\0';
                 addListBoxString(g_hwndStdoutList, lpBuffer);
                 nPtr = 0;
-            } 
-            else if (ch == '\t' && nPtr < (MAX_PATH - 4)) 
+            }
+            else if (ch == '\t' && nPtr < (MAX_PATH - 4))
             {
                 int i;
                 for (i = 0; i < 4; ++i) {
@@ -585,11 +585,11 @@ BOOL RunRedirectedConsole(LPSTR szCmdLine)
     if (!CreatePipe(&g_hpipeOutRead, &g_hpipeOutWrite, NULL, MAX_PATH*8)) {
         ErrorMessage(NULL, TRUE);
     }
-    DuplicateHandle(hProc, g_hpipeInRead, hProc, &g_hpipeInRead, 0, TRUE, 
+    DuplicateHandle(hProc, g_hpipeInRead, hProc, &g_hpipeInRead, 0, TRUE,
                     DUPLICATE_CLOSE_SOURCE|DUPLICATE_SAME_ACCESS);
-    DuplicateHandle(hProc, g_hpipeOutWrite, hProc, &g_hpipeOutWrite, 0, TRUE, 
+    DuplicateHandle(hProc, g_hpipeOutWrite, hProc, &g_hpipeOutWrite, 0, TRUE,
                     DUPLICATE_CLOSE_SOURCE|DUPLICATE_SAME_ACCESS);
-    DuplicateHandle(hProc, g_hpipeOutWrite, hProc, &g_hpipeStdError, 0, TRUE, 
+    DuplicateHandle(hProc, g_hpipeOutWrite, hProc, &g_hpipeStdError, 0, TRUE,
                     DUPLICATE_SAME_ACCESS);
     if (!g_hpipeInRead && !g_hpipeOutWrite && !g_hpipeStdError) {
         ErrorMessage(NULL, TRUE);
@@ -622,7 +622,7 @@ BOOL RunRedirectedConsole(LPSTR szCmdLine)
         return FALSE;
     }
 
-    CloseHandle(CreateThread(NULL, 0, ConsoleOutputThread, 
+    CloseHandle(CreateThread(NULL, 0, ConsoleOutputThread,
                              0, 0, &dwThreadId));
     ResumeThread(g_lpRedirectProc.hThread);
     CloseHandle(CreateThread(NULL, 0, ConsoleWaitingThread,
@@ -671,7 +671,7 @@ BOOL RunAndForgetConsole(LPSTR szCmdLine, BOOL bRedirectConsole)
 }
 
 
-BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath, 
+BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
                          LPSTR szComputerName, DWORD dwCommand)
 {
     CHAR szBuf[MAX_PATH];
@@ -697,7 +697,7 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
                 break;
 
             case SERVICE_CONTROL_CONTINUE:
-                sprintf(szMsg, g_lpMsg[IDS_MSG_SRVSTART - IDS_MSG_FIRST], 
+                sprintf(szMsg, g_lpMsg[IDS_MSG_SRVSTART - IDS_MSG_FIRST],
                         szServiceName);
                 addListBoxString(g_hwndStdoutList, szMsg);
                 lstrcat(szBuf, " -k start -n ");
@@ -727,7 +727,7 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
         }
         else if (!serviceFlag)
         {
-            sprintf(szMsg, g_lpMsg[IDS_MSG_SRVSTARTED - IDS_MSG_FIRST], 
+            sprintf(szMsg, g_lpMsg[IDS_MSG_SRVSTARTED - IDS_MSG_FIRST],
                     szServiceName);
             addListBoxString(g_hwndStdoutList, szMsg);
             g_bConsoleRun = FALSE;
@@ -743,8 +743,8 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
             return FALSE;
         }
 
-        schService = OpenService(schSCManager, szServiceName, 
-                                 SERVICE_QUERY_STATUS | SERVICE_START | 
+        schService = OpenService(schSCManager, szServiceName,
+                                 SERVICE_QUERY_STATUS | SERVICE_START |
                                  SERVICE_STOP | SERVICE_USER_DEFINED_CONTROL);
         if (schService != NULL)
         {
@@ -754,13 +754,13 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
             switch (dwCommand)
             {
             case SERVICE_CONTROL_STOP:
-                sprintf(szMsg, g_lpMsg[IDS_MSG_SRVSTOP - IDS_MSG_FIRST], 
+                sprintf(szMsg, g_lpMsg[IDS_MSG_SRVSTOP - IDS_MSG_FIRST],
                         szServiceName);
                 addListBoxString(g_hwndStdoutList, szMsg);
-                if (ControlService(schService, SERVICE_CONTROL_STOP, 
+                if (ControlService(schService, SERVICE_CONTROL_STOP,
                                    &schSStatus)) {
                     Sleep(1000);
-                    while (QueryServiceStatus(schService, &schSStatus)) 
+                    while (QueryServiceStatus(schService, &schSStatus))
                     {
                         if (schSStatus.dwCurrentState == SERVICE_STOP_PENDING)
                         {
@@ -776,8 +776,8 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
                     if (schSStatus.dwCurrentState == SERVICE_STOPPED)
                     {
                         retValue = TRUE;
-                        sprintf(szMsg, 
-                                g_lpMsg[IDS_MSG_SRVSTOPPED - IDS_MSG_FIRST], 
+                        sprintf(szMsg,
+                                g_lpMsg[IDS_MSG_SRVSTOPPED - IDS_MSG_FIRST],
                                 szServiceName);
                         addListBoxString(g_hwndStdoutList, szMsg);
                     }
@@ -789,10 +789,10 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
                         szServiceName);
                 addListBoxString(g_hwndStdoutList, szMsg);
 
-                if (StartService(schService, 0, NULL)) 
+                if (StartService(schService, 0, NULL))
                 {
                     Sleep(1000);
-                    while (QueryServiceStatus(schService, &schSStatus)) 
+                    while (QueryServiceStatus(schService, &schSStatus))
                     {
                         if (schSStatus.dwCurrentState == SERVICE_START_PENDING)
                         {
@@ -808,7 +808,7 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
                     if (schSStatus.dwCurrentState == SERVICE_RUNNING)
                     {
                         retValue = TRUE;
-                        sprintf(szMsg, 
+                        sprintf(szMsg,
                                 g_lpMsg[IDS_MSG_SRVSTARTED - IDS_MSG_FIRST],
                                 szServiceName);
                         addListBoxString(g_hwndStdoutList, szMsg);
@@ -821,7 +821,7 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
                         szServiceName);
                 addListBoxString(g_hwndStdoutList, szMsg);
                 if (ControlService(schService, SERVICE_APACHE_RESTART,
-                                   &schSStatus)) 
+                                   &schSStatus))
                 {
                     ticks = 60;
                     while (schSStatus.dwCurrentState == SERVICE_START_PENDING)
@@ -843,7 +843,7 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
                 if (schSStatus.dwCurrentState == SERVICE_RUNNING)
                 {
                     retValue = TRUE;
-                    sprintf(szMsg, 
+                    sprintf(szMsg,
                             g_lpMsg[IDS_MSG_SRVRESTARTED - IDS_MSG_FIRST],
                             szServiceName);
                     addListBoxString(g_hwndStdoutList, szMsg);
@@ -853,7 +853,7 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
             CloseServiceHandle(schService);
             CloseServiceHandle(schSCManager);
             if (!retValue) {
-                ErrorMessage(g_lpMsg[IDS_MSG_SRVFAILED - IDS_MSG_FIRST], 
+                ErrorMessage(g_lpMsg[IDS_MSG_SRVFAILED - IDS_MSG_FIRST],
                              FALSE);
             }
             g_bConsoleRun = FALSE;
@@ -871,7 +871,7 @@ BOOL ApacheManageService(LPCSTR szServiceName, LPCSTR szImagePath,
 }
 
 
-BOOL IsServiceRunning(LPCSTR szServiceName, LPCSTR szComputerName, 
+BOOL IsServiceRunning(LPCSTR szServiceName, LPCSTR szComputerName,
                       LPDWORD lpdwPid)
 {
     DWORD dwPid;
@@ -883,7 +883,7 @@ BOOL IsServiceRunning(LPCSTR szServiceName, LPCSTR szComputerName,
     if (g_dwOSVersion == OS_VERSION_WIN9X)
     {
         hWnd = FindWindow("ApacheWin95ServiceMonitor", szServiceName);
-        if (hWnd && GetWindowThreadProcessId(hWnd, &dwPid)) 
+        if (hWnd && GetWindowThreadProcessId(hWnd, &dwPid))
         {
             *lpdwPid = 1;
             return TRUE;
@@ -901,7 +901,7 @@ BOOL IsServiceRunning(LPCSTR szServiceName, LPCSTR szComputerName,
             return FALSE;
         }
 
-        schService = OpenService(schSCManager, szServiceName, 
+        schService = OpenService(schSCManager, szServiceName,
                                  SERVICE_QUERY_STATUS);
         if (schService != NULL)
         {
@@ -935,7 +935,7 @@ BOOL FindRunningServices(void)
     BOOL rv = FALSE;
     while (g_stServices[i].szServiceName != NULL)
     {
-        if (!IsServiceRunning(g_stServices[i].szServiceName, 
+        if (!IsServiceRunning(g_stServices[i].szServiceName,
                               g_stServices[i].szComputerName, &dwPid)) {
             dwPid = 0;
         }
@@ -983,7 +983,7 @@ BOOL GetApacheServicesStatus()
                 lstrcpy(szKey, "System\\CurrentControlSet\\Services\\");
                 lstrcat(szKey, achKey);
 
-                if (RegOpenKeyEx(hKeyRemote, szKey, 0, 
+                if (RegOpenKeyEx(hKeyRemote, szKey, 0,
                                  KEY_QUERY_VALUE, &hSubKey) == ERROR_SUCCESS)
                 {
                     dwBufLen = MAX_PATH;
@@ -991,7 +991,7 @@ BOOL GetApacheServicesStatus()
                                          &dwKeyType, szImagePath, &dwBufLen);
 
                     if (rv == ERROR_SUCCESS
-                            && (dwKeyType == REG_SZ 
+                            && (dwKeyType == REG_SZ
                              || dwKeyType == REG_EXPAND_SZ)
                             && dwBufLen)
                     {
@@ -1000,30 +1000,30 @@ BOOL GetApacheServicesStatus()
                         /* the service name could be httpd*.exe or Apache*.exe */
                         if (((strstr(szBuf, "\\apache") != NULL)
                              || (strstr(szBuf, "\\httpd") != NULL))
-                                && strstr(szBuf, ".exe") 
-                                && (strstr(szBuf, "--ntservice") != NULL 
+                                && strstr(szBuf, ".exe")
+                                && (strstr(szBuf, "--ntservice") != NULL
                                        || strstr(szBuf, "-k ") != NULL))
                         {
                             g_stServices[stPos].szServiceName = strdup(achKey);
-                            g_stServices[stPos].szImagePath = 
+                            g_stServices[stPos].szImagePath =
                                                            strdup(szImagePath);
-                            g_stServices[stPos].szComputerName = 
+                            g_stServices[stPos].szComputerName =
                                strdup(g_stComputers[computers].szComputerName);
                             dwBufLen = MAX_PATH;
                             if (RegQueryValueEx(hSubKey, "Description", NULL,
-                                                &dwKeyType, szBuf, &dwBufLen) 
+                                                &dwKeyType, szBuf, &dwBufLen)
                                     == ERROR_SUCCESS) {
-                                g_stServices[stPos].szDescription = 
+                                g_stServices[stPos].szDescription =
                                                                  strdup(szBuf);
                             }
                             dwBufLen = MAX_PATH;
                             if (RegQueryValueEx(hSubKey, "DisplayName", NULL,
-                                                &dwKeyType, szBuf, &dwBufLen) 
-                                    == ERROR_SUCCESS) 
+                                                &dwKeyType, szBuf, &dwBufLen)
+                                    == ERROR_SUCCESS)
                             {
                                 if (strcmp(g_stComputers[computers]
-                                        .szComputerName, g_szLocalHost) != 0) 
-                                { 
+                                        .szComputerName, g_szLocalHost) != 0)
+                                {
                                     strcpy(szTmp, g_stComputers[computers]
                                                       .szComputerName + 2);
                                     strcat(szTmp, "@");
@@ -1032,7 +1032,7 @@ BOOL GetApacheServicesStatus()
                                 else {
                                     strcpy(szTmp, szBuf);
                                 }
-                                g_stServices[stPos].szDisplayName 
+                                g_stServices[stPos].szDisplayName
                                                         = strdup(szTmp);
 
                             }
@@ -1054,13 +1054,13 @@ BOOL GetApacheServicesStatus()
 }
 
 
-LRESULT CALLBACK ConnectDlgProc(HWND hDlg, UINT message, 
+LRESULT CALLBACK ConnectDlgProc(HWND hDlg, UINT message,
                                 WPARAM wParam, LPARAM lParam)
 {
     CHAR szCmp[MAX_COMPUTERNAME_LENGTH+4];
-    switch (message) 
-    { 
-    case WM_INITDIALOG: 
+    switch (message)
+    {
+    case WM_INITDIALOG:
         ShowWindow(hDlg, SW_HIDE);
         g_hwndConnectDlg = hDlg;
         CenterWindow(hDlg);
@@ -1068,27 +1068,27 @@ LRESULT CALLBACK ConnectDlgProc(HWND hDlg, UINT message,
         SetFocus(GetDlgItem(hDlg, IDC_COMPUTER));
         return TRUE;
 
-    case WM_COMMAND: 
-        switch (LOWORD(wParam)) 
-        { 
-        case IDOK: 
+    case WM_COMMAND:
+        switch (LOWORD(wParam))
+        {
+        case IDOK:
             memset(szCmp, 0, MAX_COMPUTERNAME_LENGTH+4);
             strcpy(szCmp, "\\\\");
-            SendMessage(GetDlgItem(hDlg, IDC_COMPUTER), WM_GETTEXT, 
-                        (WPARAM) MAX_COMPUTERNAME_LENGTH, 
-                        (LPARAM) szCmp+2); 
+            SendMessage(GetDlgItem(hDlg, IDC_COMPUTER), WM_GETTEXT,
+                        (WPARAM) MAX_COMPUTERNAME_LENGTH,
+                        (LPARAM) szCmp+2);
 
             strupr(szCmp);
             if (strlen(szCmp) < 3) {
-                EndDialog(hDlg, TRUE); 
+                EndDialog(hDlg, TRUE);
                 return TRUE;
             }
             am_ConnectComputer(szCmp);
             SendMessage(g_hwndMain, WM_TIMER, WM_TIMER_RESCAN, 0);
 
         case IDCANCEL:
-            EndDialog(hDlg, TRUE); 
-            return TRUE; 
+            EndDialog(hDlg, TRUE);
+            return TRUE;
 
         case IDC_LBROWSE:
         {
@@ -1108,9 +1108,9 @@ LRESULT CALLBACK ConnectDlgProc(HWND hDlg, UINT message,
             bi.pidlRoot =       il;
 
             if (SHBrowseForFolder(&bi) != NULL) {
-                SendMessage(GetDlgItem(hDlg, IDC_COMPUTER), 
-                            WM_SETTEXT, 
-                            (WPARAM) NULL, (LPARAM) szCmp); 
+                SendMessage(GetDlgItem(hDlg, IDC_COMPUTER),
+                            WM_SETTEXT,
+                            (WPARAM) NULL, (LPARAM) szCmp);
             }
             if (SHGetMalloc(&pMalloc)) {
                 pMalloc->lpVtbl->Free(pMalloc, il);
@@ -1122,7 +1122,7 @@ LRESULT CALLBACK ConnectDlgProc(HWND hDlg, UINT message,
         break;
 
     case WM_QUIT:
-    case WM_CLOSE: 
+    case WM_CLOSE:
         EndDialog(hDlg, TRUE);
         return TRUE;
 
@@ -1134,24 +1134,24 @@ LRESULT CALLBACK ConnectDlgProc(HWND hDlg, UINT message,
 }
 
 
-LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message, 
+LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
                                 WPARAM wParam, LPARAM lParam)
 {
-    CHAR szBuf[MAX_PATH]; 
+    CHAR szBuf[MAX_PATH];
     HWND hListBox;
-    static HWND hStatusBar; 
-    TEXTMETRIC tm; 
-    int i, y; 
-    HDC hdcMem; 
-    RECT rcBitmap; 
+    static HWND hStatusBar;
+    TEXTMETRIC tm;
+    int i, y;
+    HDC hdcMem;
+    RECT rcBitmap;
     LRESULT nItem;
-    LPMEASUREITEMSTRUCT lpmis; 
-    LPDRAWITEMSTRUCT lpdis; 
+    LPMEASUREITEMSTRUCT lpmis;
+    LPDRAWITEMSTRUCT lpdis;
 
     memset(szBuf, 0, MAX_PATH);
-    switch (message) 
+    switch (message)
     {
-    case WM_INITDIALOG: 
+    case WM_INITDIALOG:
         ShowWindow(hDlg, SW_HIDE);
         g_hwndServiceDlg = hDlg;
         SetWindowText(hDlg, g_szTitle);
@@ -1159,17 +1159,17 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
         Button_Enable(GetDlgItem(hDlg, IDC_SSTOP), FALSE);
         Button_Enable(GetDlgItem(hDlg, IDC_SRESTART), FALSE);
         Button_Enable(GetDlgItem(hDlg, IDC_SDISCONN), FALSE);
-        SetWindowText(GetDlgItem(hDlg, IDC_SSTART), 
+        SetWindowText(GetDlgItem(hDlg, IDC_SSTART),
                       g_lpMsg[IDS_MSG_SSTART - IDS_MSG_FIRST]);
-        SetWindowText(GetDlgItem(hDlg, IDC_SSTOP), 
+        SetWindowText(GetDlgItem(hDlg, IDC_SSTOP),
                       g_lpMsg[IDS_MSG_SSTOP - IDS_MSG_FIRST]);
-        SetWindowText(GetDlgItem(hDlg, IDC_SRESTART), 
+        SetWindowText(GetDlgItem(hDlg, IDC_SRESTART),
                       g_lpMsg[IDS_MSG_SRESTART - IDS_MSG_FIRST]);
-        SetWindowText(GetDlgItem(hDlg, IDC_SMANAGER), 
+        SetWindowText(GetDlgItem(hDlg, IDC_SMANAGER),
                       g_lpMsg[IDS_MSG_SERVICES - IDS_MSG_FIRST]);
-        SetWindowText(GetDlgItem(hDlg, IDC_SCONNECT), 
+        SetWindowText(GetDlgItem(hDlg, IDC_SCONNECT),
                       g_lpMsg[IDS_MSG_CONNECT - IDS_MSG_FIRST]);
-        SetWindowText(GetDlgItem(hDlg, IDC_SEXIT), 
+        SetWindowText(GetDlgItem(hDlg, IDC_SEXIT),
                       g_lpMsg[IDS_MSG_MNUEXIT - IDS_MSG_FIRST]);
         if (g_dwOSVersion < OS_VERSION_WINNT)
         {
@@ -1177,7 +1177,7 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
             ShowWindow(GetDlgItem(hDlg, IDC_SCONNECT), SW_HIDE);
             ShowWindow(GetDlgItem(hDlg, IDC_SDISCONN), SW_HIDE);
         }
-        hListBox = GetDlgItem(hDlg, IDL_SERVICES); 
+        hListBox = GetDlgItem(hDlg, IDL_SERVICES);
         g_hwndStdoutList = GetDlgItem(hDlg, IDL_STDOUT);
         hStatusBar = CreateStatusWindow(0x0800 /* SBT_TOOLTIPS */
                                       | WS_CHILD | WS_VISIBLE,
@@ -1188,15 +1188,15 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
             while (g_stServices[i].szServiceName != NULL)
             {
                 addListBoxItem(hListBox, g_stServices[i].szDisplayName,
-                               g_stServices[i].dwPid == 0 ? g_hBmpStop 
+                               g_stServices[i].dwPid == 0 ? g_hBmpStop
                                                           : g_hBmpStart);
                 ++i;
             }
         }
         CenterWindow(hDlg);
         ShowWindow(hDlg, SW_SHOW);
-        SetFocus(hListBox); 
-        SendMessage(hListBox, LB_SETCURSEL, 0, 0); 
+        SetFocus(hListBox);
+        SendMessage(hListBox, LB_SETCURSEL, 0, 0);
         return TRUE;
         break;
 
@@ -1210,8 +1210,8 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
         break;
 
     case WM_UPDATEMESSAGE:
-        hListBox = GetDlgItem(hDlg, IDL_SERVICES); 
-        SendMessage(hListBox, LB_RESETCONTENT, 0, 0); 
+        hListBox = GetDlgItem(hDlg, IDL_SERVICES);
+        SendMessage(hListBox, LB_RESETCONTENT, 0, 0);
         SendMessage(hStatusBar, SB_SETTEXT, 0, (LPARAM)"");
         Button_Enable(GetDlgItem(hDlg, IDC_SSTART), FALSE);
         Button_Enable(GetDlgItem(hDlg, IDC_SSTOP), FALSE);
@@ -1220,24 +1220,24 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
         i = 0;
         while (g_stServices[i].szServiceName != NULL)
         {
-            addListBoxItem(hListBox, g_stServices[i].szDisplayName, 
+            addListBoxItem(hListBox, g_stServices[i].szDisplayName,
                 g_stServices[i].dwPid == 0 ? g_hBmpStop : g_hBmpStart);
             ++i;
         }
-        SendMessage(hListBox, LB_SETCURSEL, 0, 0); 
+        SendMessage(hListBox, LB_SETCURSEL, 0, 0);
         /* Dirty hack to bring the window to the foreground */
         SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0,
                                 SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW);
         SetWindowPos(hDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
                                 SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW);
-        SetFocus(hListBox); 
+        SetFocus(hListBox);
         return TRUE;
         break;
 
-    case WM_MEASUREITEM: 
-        lpmis = (LPMEASUREITEMSTRUCT) lParam; 
-        lpmis->itemHeight = YBITMAP; 
-        return TRUE; 
+    case WM_MEASUREITEM:
+        lpmis = (LPMEASUREITEMSTRUCT) lParam;
+        lpmis->itemHeight = YBITMAP;
+        return TRUE;
 
     case WM_SETCURSOR:
         if (g_bConsoleRun) {
@@ -1248,49 +1248,49 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
         }
         return TRUE;
 
-    case WM_DRAWITEM: 
-        lpdis = (LPDRAWITEMSTRUCT) lParam; 
-        if (lpdis->itemID == -1) { 
-            break; 
-        } 
-        switch (lpdis->itemAction) 
-        { 
-        case ODA_SELECT: 
-        case ODA_DRAWENTIRE: 
-            g_hBmpPicture = (HBITMAP)SendMessage(lpdis->hwndItem, 
+    case WM_DRAWITEM:
+        lpdis = (LPDRAWITEMSTRUCT) lParam;
+        if (lpdis->itemID == -1) {
+            break;
+        }
+        switch (lpdis->itemAction)
+        {
+        case ODA_SELECT:
+        case ODA_DRAWENTIRE:
+            g_hBmpPicture = (HBITMAP)SendMessage(lpdis->hwndItem,
                                                  LB_GETITEMDATA,
                                                  lpdis->itemID, (LPARAM) 0);
 
-            hdcMem = CreateCompatibleDC(lpdis->hDC); 
-            g_hBmpOld = SelectObject(hdcMem, g_hBmpPicture); 
+            hdcMem = CreateCompatibleDC(lpdis->hDC);
+            g_hBmpOld = SelectObject(hdcMem, g_hBmpPicture);
 
             BitBlt(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top,
                    lpdis->rcItem.right - lpdis->rcItem.left,
                    lpdis->rcItem.bottom - lpdis->rcItem.top,
                    hdcMem, 0, 0, SRCCOPY);
-            SendMessage(lpdis->hwndItem, LB_GETTEXT, 
-                        lpdis->itemID, (LPARAM) szBuf); 
+            SendMessage(lpdis->hwndItem, LB_GETTEXT,
+                        lpdis->itemID, (LPARAM) szBuf);
 
             GetTextMetrics(lpdis->hDC, &tm);
             y = (lpdis->rcItem.bottom + lpdis->rcItem.top - tm.tmHeight) / 2;
 
-            SelectObject(hdcMem, g_hBmpOld); 
-            DeleteDC(hdcMem); 
+            SelectObject(hdcMem, g_hBmpOld);
+            DeleteDC(hdcMem);
 
-            rcBitmap.left = lpdis->rcItem.left + XBITMAP + 2; 
-            rcBitmap.top = lpdis->rcItem.top; 
-            rcBitmap.right = lpdis->rcItem.right; 
-            rcBitmap.bottom = lpdis->rcItem.top + YBITMAP; 
+            rcBitmap.left = lpdis->rcItem.left + XBITMAP + 2;
+            rcBitmap.top = lpdis->rcItem.top;
+            rcBitmap.right = lpdis->rcItem.right;
+            rcBitmap.bottom = lpdis->rcItem.top + YBITMAP;
 
-            if (lpdis->itemState & ODS_SELECTED) 
-            { 
+            if (lpdis->itemState & ODS_SELECTED)
+            {
                 if (g_hBmpPicture == g_hBmpStop)
                 {
                     Button_Enable(GetDlgItem(hDlg, IDC_SSTART), TRUE);
                     Button_Enable(GetDlgItem(hDlg, IDC_SSTOP), FALSE);
                     Button_Enable(GetDlgItem(hDlg, IDC_SRESTART), FALSE);
                 }
-                else if (g_hBmpPicture == g_hBmpStart) 
+                else if (g_hBmpPicture == g_hBmpStart)
                 {
                     Button_Enable(GetDlgItem(hDlg, IDC_SSTART), FALSE);
                     Button_Enable(GetDlgItem(hDlg, IDC_SSTOP), TRUE);
@@ -1301,7 +1301,7 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
                     Button_Enable(GetDlgItem(hDlg, IDC_SSTOP), FALSE);
                     Button_Enable(GetDlgItem(hDlg, IDC_SRESTART), FALSE);
                 }
-                if (strcmp(g_stServices[lpdis->itemID].szComputerName, 
+                if (strcmp(g_stServices[lpdis->itemID].szComputerName,
                            g_szLocalHost) == 0) {
                     Button_Enable(GetDlgItem(hDlg, IDC_SDISCONN), FALSE);
                 }
@@ -1310,50 +1310,50 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
                 }
 
                 if (g_stServices[lpdis->itemID].szDescription) {
-                    SendMessage(hStatusBar, SB_SETTEXT, 0, 
+                    SendMessage(hStatusBar, SB_SETTEXT, 0,
                             (LPARAM)g_stServices[lpdis->itemID].szDescription);
                 }
                 else {
                     SendMessage(hStatusBar, SB_SETTEXT, 0, (LPARAM)"");
                 }
-                SetTextColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT)); 
-                SetBkColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT)); 
+                SetTextColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
+                SetBkColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
                 FillRect(lpdis->hDC, &rcBitmap, (HBRUSH)(COLOR_HIGHLIGHTTEXT));
-            } 
+            }
             else
             {
-               SetTextColor(lpdis->hDC, GetSysColor(COLOR_MENUTEXT)); 
-               SetBkColor(lpdis->hDC, GetSysColor(COLOR_WINDOW)); 
-               FillRect(lpdis->hDC, &rcBitmap, (HBRUSH)(COLOR_WINDOW+1)); 
+               SetTextColor(lpdis->hDC, GetSysColor(COLOR_MENUTEXT));
+               SetBkColor(lpdis->hDC, GetSysColor(COLOR_WINDOW));
+               FillRect(lpdis->hDC, &rcBitmap, (HBRUSH)(COLOR_WINDOW+1));
             }
-            TextOut(lpdis->hDC, XBITMAP + 6, y, szBuf, (int)strlen(szBuf)); 
-            break; 
+            TextOut(lpdis->hDC, XBITMAP + 6, y, szBuf, (int)strlen(szBuf));
+            break;
 
-        case ODA_FOCUS: 
-            break; 
-        } 
+        case ODA_FOCUS:
+            break;
+        }
         return TRUE;
-    case WM_COMMAND: 
-        switch (LOWORD(wParam)) 
-        { 
+    case WM_COMMAND:
+        switch (LOWORD(wParam))
+        {
         case IDL_SERVICES:
             switch (HIWORD(wParam))
             {
             case LBN_DBLCLK:
                 /* if started then stop, if stopped then start */
-                hListBox = GetDlgItem(hDlg, IDL_SERVICES); 
+                hListBox = GetDlgItem(hDlg, IDL_SERVICES);
                 nItem = SendMessage(hListBox, LB_GETCURSEL, 0, 0);
                 if (nItem != LB_ERR)
                 {
-                    g_hBmpPicture = (HBITMAP)SendMessage(hListBox, 
+                    g_hBmpPicture = (HBITMAP)SendMessage(hListBox,
                                                          LB_GETITEMDATA,
                                                          nItem, (LPARAM) 0);
                     if (g_hBmpPicture == g_hBmpStop) {
-                        SendMessage(hDlg, WM_MANAGEMESSAGE, nItem, 
+                        SendMessage(hDlg, WM_MANAGEMESSAGE, nItem,
                                     SERVICE_CONTROL_CONTINUE);
                     }
                     else {
-                        SendMessage(hDlg, WM_MANAGEMESSAGE, nItem, 
+                        SendMessage(hDlg, WM_MANAGEMESSAGE, nItem,
                                     SERVICE_CONTROL_STOP);
                     }
 
@@ -1362,44 +1362,44 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
             }
             break;
 
-        case IDOK: 
-            EndDialog(hDlg, TRUE); 
-            return TRUE; 
+        case IDOK:
+            EndDialog(hDlg, TRUE);
+            return TRUE;
 
-        case IDC_SSTART: 
+        case IDC_SSTART:
             Button_Enable(GetDlgItem(hDlg, IDC_SSTART), FALSE);
-            hListBox = GetDlgItem(hDlg, IDL_SERVICES); 
-            nItem = SendMessage(hListBox, LB_GETCURSEL, 0, 0); 
+            hListBox = GetDlgItem(hDlg, IDL_SERVICES);
+            nItem = SendMessage(hListBox, LB_GETCURSEL, 0, 0);
             if (nItem != LB_ERR) {
-                SendMessage(hDlg, WM_MANAGEMESSAGE, nItem, 
+                SendMessage(hDlg, WM_MANAGEMESSAGE, nItem,
                             SERVICE_CONTROL_CONTINUE);
             }
             Button_Enable(GetDlgItem(hDlg, IDC_SSTART), TRUE);
             return TRUE;
 
-        case IDC_SSTOP: 
+        case IDC_SSTOP:
             Button_Enable(GetDlgItem(hDlg, IDC_SSTOP), FALSE);
-            hListBox = GetDlgItem(hDlg, IDL_SERVICES); 
-            nItem = SendMessage(hListBox, LB_GETCURSEL, 0, 0); 
+            hListBox = GetDlgItem(hDlg, IDL_SERVICES);
+            nItem = SendMessage(hListBox, LB_GETCURSEL, 0, 0);
             if (nItem != LB_ERR) {
-                SendMessage(hDlg, WM_MANAGEMESSAGE, nItem, 
+                SendMessage(hDlg, WM_MANAGEMESSAGE, nItem,
                             SERVICE_CONTROL_STOP);
             }
             Button_Enable(GetDlgItem(hDlg, IDC_SSTOP), TRUE);
             return TRUE;
 
-        case IDC_SRESTART: 
+        case IDC_SRESTART:
             Button_Enable(GetDlgItem(hDlg, IDC_SRESTART), FALSE);
-            hListBox = GetDlgItem(hDlg, IDL_SERVICES); 
-            nItem = SendMessage(hListBox, LB_GETCURSEL, 0, 0); 
+            hListBox = GetDlgItem(hDlg, IDL_SERVICES);
+            nItem = SendMessage(hListBox, LB_GETCURSEL, 0, 0);
             if (nItem != LB_ERR) {
-                SendMessage(hDlg, WM_MANAGEMESSAGE, nItem, 
+                SendMessage(hDlg, WM_MANAGEMESSAGE, nItem,
                             SERVICE_APACHE_RESTART);
             }
             Button_Enable(GetDlgItem(hDlg, IDC_SRESTART), TRUE);
             return TRUE;
 
-        case IDC_SMANAGER: 
+        case IDC_SMANAGER:
             if (g_dwOSVersion >= OS_VERSION_WIN2K) {
                 ShellExecute(hDlg, "open", "services.msc", "/s",
                              NULL, SW_NORMAL);
@@ -1409,19 +1409,19 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
             }
             return TRUE;
 
-        case IDC_SEXIT: 
+        case IDC_SEXIT:
             EndDialog(hDlg, TRUE);
             SendMessage(g_hwndMain, WM_COMMAND, (WPARAM)IDM_EXIT, 0);
             return TRUE;
 
-        case IDC_SCONNECT: 
+        case IDC_SCONNECT:
             DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DLGCONNECT),
                       hDlg, (DLGPROC)ConnectDlgProc);
             return TRUE;
 
-        case IDC_SDISCONN: 
-            hListBox = GetDlgItem(hDlg, IDL_SERVICES); 
-            nItem = SendMessage(hListBox, LB_GETCURSEL, 0, 0); 
+        case IDC_SDISCONN:
+            hListBox = GetDlgItem(hDlg, IDL_SERVICES);
+            nItem = SendMessage(hListBox, LB_GETCURSEL, 0, 0);
             if (nItem != LB_ERR) {
                 am_DisconnectComputer(g_stServices[nItem].szComputerName);
                 SendMessage(g_hwndMain, WM_TIMER, WM_TIMER_RESCAN, 0);
@@ -1431,17 +1431,17 @@ LRESULT CALLBACK ServiceDlgProc(HWND hDlg, UINT message,
         break;
 
     case WM_SIZE:
-        switch (LOWORD(wParam)) 
-        { 
+        switch (LOWORD(wParam))
+        {
         case SIZE_MINIMIZED:
-            EndDialog(hDlg, TRUE); 
-            return TRUE; 
+            EndDialog(hDlg, TRUE);
+            return TRUE;
             break;
         }
         break;
 
     case WM_QUIT:
-    case WM_CLOSE: 
+    case WM_CLOSE:
         EndDialog(hDlg, TRUE);
         return TRUE;
 
@@ -1461,7 +1461,7 @@ LRESULT CALLBACK WndProc(HWND hWnd, UINT message,
         ShowNotifyIcon(hWnd, NIM_ADD);
         return DefWindowProc(hWnd, message, wParam, lParam);
     }
-    switch (message) 
+    switch (message)
     {
     case WM_CREATE:
         GetApacheServicesStatus();
@@ -1565,33 +1565,33 @@ LRESULT CALLBACK WndProc(HWND hWnd, UINT message,
     case WM_COMMAND:
         if ((LOWORD(wParam) & IDM_SM_START) == IDM_SM_START)
         {
-            ApacheManageService(g_stServices[LOWORD(wParam) 
+            ApacheManageService(g_stServices[LOWORD(wParam)
                                            - IDM_SM_START].szServiceName,
-                                g_stServices[LOWORD(wParam) 
+                                g_stServices[LOWORD(wParam)
                                            - IDM_SM_START].szImagePath,
-                                g_stServices[LOWORD(wParam) 
+                                g_stServices[LOWORD(wParam)
                                            - IDM_SM_START].szComputerName,
                                 SERVICE_CONTROL_CONTINUE);
             return TRUE;
         }
         else if ((LOWORD(wParam) & IDM_SM_STOP) == IDM_SM_STOP)
         {
-            ApacheManageService(g_stServices[LOWORD(wParam) 
+            ApacheManageService(g_stServices[LOWORD(wParam)
                                            - IDM_SM_STOP].szServiceName,
-                                g_stServices[LOWORD(wParam) 
+                                g_stServices[LOWORD(wParam)
                                            - IDM_SM_STOP].szImagePath,
-                                g_stServices[LOWORD(wParam) 
+                                g_stServices[LOWORD(wParam)
                                            - IDM_SM_STOP].szComputerName,
                                 SERVICE_CONTROL_STOP);
             return TRUE;
         }
         else if ((LOWORD(wParam) & IDM_SM_RESTART) == IDM_SM_RESTART)
         {
-            ApacheManageService(g_stServices[LOWORD(wParam) 
+            ApacheManageService(g_stServices[LOWORD(wParam)
                                            - IDM_SM_RESTART].szServiceName,
-                                g_stServices[LOWORD(wParam) 
+                                g_stServices[LOWORD(wParam)
                                            - IDM_SM_RESTART].szImagePath,
-                                g_stServices[LOWORD(wParam) 
+                                g_stServices[LOWORD(wParam)
                                            - IDM_SM_RESTART].szComputerName,
                                 SERVICE_APACHE_RESTART);
             return TRUE;
@@ -1612,7 +1612,7 @@ LRESULT CALLBACK WndProc(HWND hWnd, UINT message,
             }
             break;
 
-        case IDC_SMANAGER: 
+        case IDC_SMANAGER:
             if (g_dwOSVersion >= OS_VERSION_WIN2K) {
                 ShellExecute(NULL, "open", "services.msc", "/s",
                              NULL, SW_NORMAL);
@@ -1648,7 +1648,7 @@ HWND CreateMainWindow(HINSTANCE hInstance)
         return hWnd;
     }
 
-    wcex.cbSize = sizeof(WNDCLASSEX); 
+    wcex.cbSize = sizeof(WNDCLASSEX);
 
     wcex.style          = CS_HREDRAW | CS_VREDRAW;
     wcex.lpfnWndProc    = (WNDPROC)WndProc;
@@ -1711,17 +1711,17 @@ int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                                    IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
     g_icoRun           = LoadImage(hInstance, MAKEINTRESOURCE(IDI_ICORUN),
                                    IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
-    g_hCursorHourglass = LoadImage(NULL, MAKEINTRESOURCE(OCR_WAIT), 
-                                   IMAGE_CURSOR, LR_DEFAULTSIZE, 
+    g_hCursorHourglass = LoadImage(NULL, MAKEINTRESOURCE(OCR_WAIT),
+                                   IMAGE_CURSOR, LR_DEFAULTSIZE,
                                    LR_DEFAULTSIZE, LR_SHARED);
-    g_hCursorArrow     = LoadImage(NULL, MAKEINTRESOURCE(OCR_NORMAL), 
-                                   IMAGE_CURSOR, LR_DEFAULTSIZE, 
+    g_hCursorArrow     = LoadImage(NULL, MAKEINTRESOURCE(OCR_NORMAL),
+                                   IMAGE_CURSOR, LR_DEFAULTSIZE,
                                    LR_DEFAULTSIZE, LR_SHARED);
     g_hBmpStart        = LoadImage(hInstance, MAKEINTRESOURCE(IDB_BMPRUN),
-                                   IMAGE_BITMAP, XBITMAP, YBITMAP, 
+                                   IMAGE_BITMAP, XBITMAP, YBITMAP,
                                    LR_DEFAULTCOLOR);
     g_hBmpStop         = LoadImage(hInstance, MAKEINTRESOURCE(IDB_BMPSTOP),
-                                   IMAGE_BITMAP, XBITMAP, YBITMAP, 
+                                   IMAGE_BITMAP, XBITMAP, YBITMAP,
                                    LR_DEFAULTCOLOR);
 
     hMutex = CreateMutex(NULL, FALSE, "APSRVMON_MUTEX");
@@ -1744,7 +1744,7 @@ int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
     g_hwndServiceDlg = NULL;
     if (g_hwndMain != NULL)
     {
-        while (GetMessage(&msg, NULL, 0, 0) == TRUE) 
+        while (GetMessage(&msg, NULL, 0, 0) == TRUE)
         {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
@@ -1758,8 +1758,8 @@ int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
     DestroyIcon(g_icoRun);
     DestroyCursor(g_hCursorHourglass);
     DestroyCursor(g_hCursorArrow);
-    DeleteObject(g_hBmpStart); 
-    DeleteObject(g_hBmpStop); 
+    DeleteObject(g_hBmpStart);
+    DeleteObject(g_hBmpStop);
     CoUninitialize();
     return 0;
 }
diff --git a/support/win32/wintty.c b/support/win32/wintty.c
index bb66ebd..25156c4 100644
--- a/support/win32/wintty.c
+++ b/support/win32/wintty.c
@@ -16,7 +16,7 @@
 
 /* --------------------------------------------------------------------
  *
- * wintty : a Apache/WinNT support utility for monitoring and 
+ * wintty : a Apache/WinNT support utility for monitoring and
  *          reflecting user feedback from the Apache process via
  *          stdin/stdout, even as running within the service context.
  *
@@ -30,7 +30,7 @@
  *
  * Also note the isservice detection semantics, which far exceed any
  * mechanism we have discovered thus far.
- * 
+ *
  * --------------------------------------------------------------------
  */
 
@@ -39,7 +39,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-const char *options = 
+const char *options =
 "\nwintty: a utility for echoing the stdin stream to a new console window,\n"
 "\teven when invoked from within a service (such as the Apache server.)\n"
 "\tAlso reflects the console input back to the stdout stream, allowing\n"
@@ -56,7 +56,7 @@ const char *options =
 
 BOOL verbose = FALSE;
 
-void printerr(char *fmt, ...) 
+void printerr(char *fmt, ...)
 {
     char str[1024];
     va_list args;
@@ -124,7 +124,7 @@ int main(int argc, char** argv)
                     }
                     else {
                         timeout = 0;
-                    }	
+                    }
                     break;
                 case 'v':
                     verbose = TRUE;
@@ -163,46 +163,46 @@ int main(int argc, char** argv)
 
     hstdin = GetStdHandle(STD_INPUT_HANDLE);
     if (!hstdin || hstdin == INVALID_HANDLE_VALUE) {
-        printerr("GetStdHandle(STD_INPUT_HANDLE) failed (%d)\n", 
+        printerr("GetStdHandle(STD_INPUT_HANDLE) failed (%d)\n",
                  GetLastError());
     }
-    else if (DuplicateHandle(hproc, hstdin, hproc, &hdup, 0, 
+    else if (DuplicateHandle(hproc, hstdin, hproc, &hdup, 0,
                              isservice, DUPLICATE_SAME_ACCESS)) {
         CloseHandle(hstdin);
         hstdin = hdup;
     }
     else {
-        printerr("DupHandle(stdin [%x]) failed (%d)\n", 
+        printerr("DupHandle(stdin [%x]) failed (%d)\n",
                  hstdin, GetLastError());
     }
 
     hstdout = GetStdHandle(STD_OUTPUT_HANDLE);
     if (!hstdout || hstdout == INVALID_HANDLE_VALUE) {
-        printerr("GetStdHandle(STD_OUTPUT_HANDLE) failed (%d)\n", 
+        printerr("GetStdHandle(STD_OUTPUT_HANDLE) failed (%d)\n",
                  GetLastError());
     }
-    else if (DuplicateHandle(hproc, hstdout, hproc, &hdup, 0, 
+    else if (DuplicateHandle(hproc, hstdout, hproc, &hdup, 0,
                              isservice, DUPLICATE_SAME_ACCESS)) {
         CloseHandle(hstdout);
         hstdout = hdup;
     }
     else {
-        printerr("DupHandle(stdout [%x]) failed (%d)\n", 
+        printerr("DupHandle(stdout [%x]) failed (%d)\n",
                  hstdout, GetLastError());
     }
 
     hstderr = GetStdHandle(STD_ERROR_HANDLE);
     if (!hstderr || hstderr == INVALID_HANDLE_VALUE) {
-        printerr("GetStdHandle(STD_ERROR_HANDLE) failed (%d)\n", 
+        printerr("GetStdHandle(STD_ERROR_HANDLE) failed (%d)\n",
                  GetLastError());
     }
-    else if (DuplicateHandle(hproc, hstderr, hproc, &hdup, 0, 
+    else if (DuplicateHandle(hproc, hstderr, hproc, &hdup, 0,
                              isservice, DUPLICATE_SAME_ACCESS)) {
         CloseHandle(hstderr);
         hstderr = hdup;
     }
     else {
-        printerr("DupHandle(stderr [%x]) failed (%d)\n", 
+        printerr("DupHandle(stderr [%x]) failed (%d)\n",
                  hstderr, GetLastError());
     }
 
@@ -211,7 +211,7 @@ int main(int argc, char** argv)
      */
     if (!FreeConsole())
         printerr("FreeConsole() failed (%d)\n", GetLastError());
-        
+
     if (isservice) {
 #ifdef WE_EVER_FIGURE_OUT_WHY_THIS_DOESNT_WORK
         hsavedesk = GetThreadDesktop(GetCurrentThreadId());
@@ -229,7 +229,7 @@ int main(int argc, char** argv)
         hdesk = OpenDesktop("Default", 0, TRUE, MAXIMUM_ALLOWED);
         if (!hdesk || hdesk == INVALID_HANDLE_VALUE) {
             printerr("OpenDesktop(Default) failed (%d)\n", GetLastError());
-        } 
+        }
         else if (!SetThreadDesktop(hdesk)) {
             printerr("SetThreadDesktop(Default) failed (%d)\n", GetLastError());
         }
@@ -240,11 +240,11 @@ int main(int argc, char** argv)
         char appbuff[MAX_PATH];
         char *appname = NULL;
         char *cmdline = GetCommandLine();
-        
+
         if (!GetModuleFileName(NULL, appbuff, sizeof(appbuff))) {
             appname = appbuff;
         }
-        
+
         memset(&si, 0, sizeof(si));
         si.cb = sizeof(si);
         si.dwFlags     = STARTF_USESHOWWINDOW
@@ -262,7 +262,7 @@ int main(int argc, char** argv)
          * receive their EOF notification.
          */
         if (CreateProcess(appname, cmdline, NULL, NULL, TRUE,
-                          CREATE_SUSPENDED | CREATE_NEW_CONSOLE, 
+                          CREATE_SUSPENDED | CREATE_NEW_CONSOLE,
                           NULL, NULL, &si, &pi)) {
             CloseHandle(si.hStdInput);
             CloseHandle(si.hStdOutput);
@@ -286,8 +286,8 @@ int main(int argc, char** argv)
         printerr("SetConsoleTitle() failed (%d)\n", GetLastError());
     }
 
-    conout = CreateFile("CONOUT$", GENERIC_READ | GENERIC_WRITE, 
-                        FILE_SHARE_READ | FILE_SHARE_WRITE, 
+    conout = CreateFile("CONOUT$", GENERIC_READ | GENERIC_WRITE,
+                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FALSE, OPEN_EXISTING, 0, NULL);
     if (!conout || conout == INVALID_HANDLE_VALUE) {
         printerr("CreateFile(CONOUT$) failed (%d)\n", GetLastError());
@@ -297,12 +297,12 @@ int main(int argc, char** argv)
     }
     else if (!SetConsoleMode(conout, conmode = ((conmode | newoutmode)
                                                          & ~notoutmode))) {
-        printerr("SetConsoleMode(CONOUT, 0x%x) failed (%d)\n", 
+        printerr("SetConsoleMode(CONOUT, 0x%x) failed (%d)\n",
                  conmode, GetLastError());
     }
 
-    conin = CreateFile("CONIN$", GENERIC_READ | GENERIC_WRITE, 
-                       FILE_SHARE_READ | FILE_SHARE_WRITE, 
+    conin = CreateFile("CONIN$", GENERIC_READ | GENERIC_WRITE,
+                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FALSE, OPEN_EXISTING, 0, NULL);
     if (!conin || conin == INVALID_HANDLE_VALUE) {
         printerr("CreateFile(CONIN$) failed (%d)\n", GetLastError());
@@ -310,9 +310,9 @@ int main(int argc, char** argv)
     else if (!GetConsoleMode(conin, &conmode)) {
         printerr("GetConsoleMode(CONIN) failed (%d)\n", GetLastError());
     }
-    else if (!SetConsoleMode(conin, conmode = ((conmode | newinmode) 
+    else if (!SetConsoleMode(conin, conmode = ((conmode | newinmode)
                                                         & ~notinmode))) {
-        printerr("SetConsoleMode(CONIN, 0x%x) failed (%d)\n", 
+        printerr("SetConsoleMode(CONIN, 0x%x) failed (%d)\n",
                  conmode, GetLastError());
     }
 
diff --git a/test/cls.c b/test/cls.c
index 1311a88..d11e2a4 100644
--- a/test/cls.c
+++ b/test/cls.c
@@ -27,7 +27,7 @@
  *   # - lowercase letter
  *   & - hex digit
  *   # - digit
- *   * - swallow remaining characters 
+ *   * - swallow remaining characters
  *  <x> - exact match for any other character
  */
 static int checkmask(const char *data, const char *mask)
diff --git a/test/test_find.c b/test/test_find.c
index 1c4346d..30be627 100644
--- a/test/test_find.c
+++ b/test/test_find.c
@@ -23,7 +23,7 @@
             -DSOLARIS2=250 -Wall -DALLOC_DEBUG -DPOOL_DEBUG \
             ../main/alloc.o ../main/buff.o ../main/util.o \
             ../ap/libap.a -lsocket -lnsl test_find.c
- * 
+ *
  * Roy Fielding, 1999
  */
 #include <stdio.h>
@@ -73,6 +73,6 @@ int main (void)
                                   ? "Yes" : "No");
         printf("Enter search item:\n");
     }
-    
+
     exit(0);
 }
diff --git a/test/test_limits.c b/test/test_limits.c
index 8dca825..aa51d53 100644
--- a/test/test_limits.c
+++ b/test/test_limits.c
@@ -8,17 +8,17 @@
  *
  * FreeBSD 2.2.x, FreeBSD 3.0, IRIX 5.3, IRIX 6.2:
  *   gcc -o test_limits test_limits.c
- * 
+ *
  * Solaris 2.5.1:
  *   gcc -o test_limits test_limits.c -lsocket -lnsl
- * 
+ *
  *
  * Message-ID: <861zqspvtw.fsf@niobe.ewox.org>
  * Date: 	Fri, 7 Aug 1998 19:04:27 +0200
  * Sender: Bugtraq List <BUGTRAQ@netspace.org>
  * From: Dag-Erling Coidan =?ISO-8859-1?Q?Sm=F8rgrav?= <finrod@EWOX.ORG>
  * Subject:      YA Apache DoS attack
- * 
+ *
  * Copyright (c) 1998 Dag-Erling Codan Smrgrav
  * All rights reserved.
  *
diff --git a/test/test_parser.c b/test/test_parser.c
index a7a4a74..a566858 100644
--- a/test/test_parser.c
+++ b/test/test_parser.c
@@ -23,7 +23,7 @@
             -DSOLARIS2=250 -Wall -DALLOC_DEBUG -DPOOL_DEBUG \
             ../main/alloc.o ../main/buff.o ../main/util.o \
             ../ap/libap.a -lsocket -lnsl test_parser.c
- * 
+ *
  * Roy Fielding, 1999
  */
 #include <stdio.h>
@@ -70,6 +70,6 @@ int main (void)
         while ((newstr = ap_get_list_item(p, &field)) != NULL)
             printf("  <%s> ..\n", newstr);
     }
-    
+
     exit(0);
 }
diff --git a/test/time-sem.c b/test/time-sem.c
index 792caec..2b7f957 100644
--- a/test/time-sem.c
+++ b/test/time-sem.c
@@ -111,7 +111,7 @@ accept_mutex_init(void)
 void accept_mutex_on(void)
 {
     int ret;
-    
+
     while ((ret = fcntl(fcntl_fd, F_SETLKW, &lock_it)) < 0 && errno == EINTR)
         continue;
 
@@ -172,7 +172,7 @@ void accept_mutex_cleanup(void)
 void accept_mutex_on(void)
 {
     int ret;
-    
+
     while ((ret = flock(flock_fd, LOCK_EX)) < 0 && errno == EINTR)
         continue;
 
diff --git a/test/zb.c b/test/zb.c
index a85fa7a..8d76e3f 100644
--- a/test/zb.c
+++ b/test/zb.c
@@ -7,21 +7,21 @@ This program is Copyright (C) Zeus Technology Limited 1996.
 This program may be used and copied freely providing this copyright notice
 is not removed.
 
-This software is provided "as is" and any express or implied waranties, 
+This software is provided "as is" and any express or implied waranties,
 including but not limited to, the implied warranties of merchantability and
-fitness for a particular purpose are disclaimed.  In no event shall 
-Zeus Technology Ltd. be liable for any direct, indirect, incidental, special, 
-exemplary, or consequential damaged (including, but not limited to, 
+fitness for a particular purpose are disclaimed.  In no event shall
+Zeus Technology Ltd. be liable for any direct, indirect, incidental, special,
+exemplary, or consequential damaged (including, but not limited to,
 procurement of substitute good or services; loss of use, data, or profits;
 or business interruption) however caused and on theory of liability.  Whether
-in contract, strict liability or tort (including negligence or otherwise) 
+in contract, strict liability or tort (including negligence or otherwise)
 arising in any way out of the use of this software, even if advised of the
 possibility of such damage.
 
      Written by Adam Twiss (adam@zeus.co.uk).  March 1996
 
 Thanks to the following people for their input:
-  Mike Belshe (mbelshe@netscape.com) 
+  Mike Belshe (mbelshe@netscape.com)
   Michael Campanella (campanella@stevms.enet.dec.com)
 
 */
@@ -33,12 +33,12 @@ IRIX, Solaris, AIX and Digital Unix (OSF).  On Solaris 2.x you will
 need to compile with "-lnsl -lsocket" options.  If you have any
 difficulties compiling then let me know.
 
-On SunOS 4.x.x you may need to compile with -DSUNOS4 to add the following 
+On SunOS 4.x.x you may need to compile with -DSUNOS4 to add the following
 two lines of code which appear not to exist in my SunOS headers */
 
 #ifdef SUNOS4
-extern char *optarg; 
-extern int optind, opterr, optopt;   
+extern char *optarg;
+extern int optind, opterr, optopt;
 #endif
 
 /*  -------------------------------------------------------------------- */
@@ -46,7 +46,7 @@ extern int optind, opterr, optopt;
 /* affects include files on Solaris */
 #define BSD_COMP
 
-#include <sys/time.h> 
+#include <sys/time.h>
 #include <sys/ioctl.h>
 #include <unistd.h>
 #include <stdlib.h>
@@ -54,7 +54,7 @@ extern int optind, opterr, optopt;
 #include <fcntl.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
-#include <netdb.h> 
+#include <netdb.h>
 #include <errno.h>
 #include <sys/ioctl.h>
 #include <string.h>
@@ -62,7 +62,7 @@ extern int optind, opterr, optopt;
 /* ------------------- DEFINITIONS -------------------------- */
 
 /* maximum number of requests on a time limited test */
-#define MAX_REQUESTS 50000 
+#define MAX_REQUESTS 50000
 
 /* good old state machine */
 #define STATE_UNCONNECTED 0
@@ -71,7 +71,7 @@ extern int optind, opterr, optopt;
 
 #define CBUFFSIZE       512
 
-struct connection 
+struct connection
 {
   int fd;
   int state;
@@ -82,10 +82,10 @@ struct connection
   int cbx;                /* offset in cbuffer */
   int keepalive;          /* non-zero if a keep-alive request */
   int gotheader;          /* non-zero if we have the entire header in cbuff */
-  struct timeval start, connect, done; 
+  struct timeval start, connect, done;
 };
 
-struct data 
+struct data
 {
   int read;      /* number of bytes read */
   int ctime;     /* time in ms to connect */
@@ -135,7 +135,7 @@ struct sockaddr_in server;   /* server addr structure */
 
 /* simple little function to perror and exit */
 
-static void err(char *s) 
+static void err(char *s)
 {
   perror(s);
   exit(errno);
@@ -143,13 +143,13 @@ static void err(char *s)
 
 /* --------------------------------------------------------- */
 
-/* write out request to a connection - assumes we can write 
+/* write out request to a connection - assumes we can write
    (small) request out in one go into our new socket buffer  */
 
 void write_request(struct connection *c)
 {
   gettimeofday(&c->connect,0);
-  write(c->fd,request, reqlen);  
+  write(c->fd,request, reqlen);
   c->state = STATE_READ;
   FD_SET(c->fd, &readbits);
   FD_CLR(c->fd, &writebits);
@@ -159,7 +159,7 @@ void write_request(struct connection *c)
 
 /* make an fd non blocking */
 
-void nonblock(int fd) 
+void nonblock(int fd)
 {
   int i=1;
   ioctl(fd, FIONBIO, &i);
@@ -187,15 +187,15 @@ int timedif(struct timeval a, struct timeval b)
 void output_results()
 {
   int timetaken;
-  
+
   gettimeofday(&endtime,0);
   timetaken = timedif(endtime, start);
-  
+
   printf("\n---\n");
   printf("Server:                 %s\n", server_name);
-  printf("Document Length:        %d\n", doclen);  
+  printf("Document Length:        %d\n", doclen);
   printf("Concurency Level:       %d\n", concurrency);
-  printf("Time taken for tests:   %d.%03d seconds\n", 
+  printf("Time taken for tests:   %d.%03d seconds\n",
          timetaken/1000, timetaken%1000);
   printf("Complete requests:      %d\n", done);
   printf("Failed requests:        %d\n", bad);
@@ -204,11 +204,11 @@ void output_results()
   if(keepalive) printf("Keep-Alive requests:    %d\n", doneka);
   printf("Bytes transferred:      %d\n", totalread);
   printf("HTML transferred:       %d\n", totalbread);
-  
+
   /* avoid divide by zero */
   if(timetaken) {
     printf("Requests per seconds:   %.2f\n", 1000*(float)(done)/timetaken);
-    printf("Transfer rate:          %.2f kb/s\n", 
+    printf("Transfer rate:          %.2f kb/s\n",
            (float)(totalread)/timetaken);
   }
 
@@ -247,7 +247,7 @@ void start_connect(struct connection *c)
   c->read = 0;
   c->bread = 0;
   c->keepalive = 0;
-  c->cbx = 0; 
+  c->cbx = 0;
   c->gotheader = 0;
 
   c->fd = socket(AF_INET, SOCK_STREAM, 0);
@@ -268,11 +268,11 @@ void start_connect(struct connection *c)
       if(bad++>10) {
         printf("\nTest aborted after 10 failures\n\n");
         exit(1);
-      } 
+      }
       start_connect(c);
-    }      
+    }
   }
-  
+
   /* connected first time */
   write_request(c);
 }
@@ -286,16 +286,16 @@ void close_connection(struct connection *c)
   if(c->read == 0 && c->keepalive) {
     /* server has legitiamately shut down an idle keep alive request */
     good--;  /* connection never happend */
-  } 
+  }
   else {
     if(good==1) {
       /* first time here */
       doclen = c->bread;
-    } else if (c->bread!=doclen) { 
-      bad++; 
-      err_length++; 
+    } else if (c->bread!=doclen) {
+      bad++;
+      err_length++;
     }
-    
+
     /* save out time */
     if(done < requests) {
       struct data s;
@@ -312,7 +312,7 @@ void close_connection(struct connection *c)
   FD_CLR(c->fd, &writebits);
 
   /* connect again */
-  start_connect(c); 
+  start_connect(c);
   return;
 }
 
@@ -323,19 +323,19 @@ void close_connection(struct connection *c)
 void read_connection(struct connection *c)
 {
   int r;
-  
+
   r=read(c->fd,buffer,sizeof(buffer));
   if(r==0 || (r<0 && errno!=EAGAIN)) {
     good++;
     close_connection(c);
     return;
-  } 
-  
+  }
+
   if(r<0 && errno==EAGAIN) return;
 
   c->read += r;
   totalread += r;
-  
+
   if(!c->gotheader) {
     char *s;
     int l=4;
@@ -345,13 +345,13 @@ void read_connection(struct connection *c)
     c->cbx += tocopy; space -= tocopy;
     c->cbuff[c->cbx] = 0; /* terminate for benefit of strstr */
     s = strstr(c->cbuff, "\r\n\r\n");
-    /* this next line is so that we talk to NCSA 1.5 which blatantly breaks 
+    /* this next line is so that we talk to NCSA 1.5 which blatantly breaks
        the http specifaction */
     if(!s) { s = strstr(c->cbuff,"\n\n"); l=2; }
 
     if(!s) {
        /* read rest next time */
-      if(space) 
+      if(space)
         return;
       else {
         /* header is in invalid or too big - close connection */
@@ -359,10 +359,10 @@ void read_connection(struct connection *c)
         if(bad++>10) {
           printf("\nTest aborted after 10 failures\n\n");
           exit(1);
-        } 
+        }
         FD_CLR(c->fd, &writebits);
         start_connect(c);
-      }	
+      }
     }
     else {
       /* have full header */
@@ -374,16 +374,16 @@ void read_connection(struct connection *c)
         if(p) { p+=8; while(*p>32) *q++ = *p++; }
         *q = 0;
       }
-        
+
       c->gotheader = 1;
       *s = 0; /* terminate at end of header */
-      if(keepalive && 
-         (strstr(c->cbuff, "Keep-Alive") 
+      if(keepalive &&
+         (strstr(c->cbuff, "Keep-Alive")
           || strstr(c->cbuff, "keep-alive")))  /* for benefit of MSIIS */
         {
         char *cl;
         cl = strstr(c->cbuff, "Content-Length:");
-        /* for cacky servers like NCSA which break the spec and send a 
+        /* for cacky servers like NCSA which break the spec and send a
            lower case 'l' */
         if(!cl) cl = strstr(c->cbuff, "Content-length:");
         if(cl) {
@@ -394,7 +394,7 @@ void read_connection(struct connection *c)
       c->bread += c->cbx - (s+l-c->cbuff) + r-tocopy;
       totalbread += c->bread;
     }
-  }  
+  }
   else {
     /* outside header, everything we have read is entity body */
     c->bread += r;
@@ -428,12 +428,12 @@ void read_connection(struct connection *c)
 
 /* run the tests */
 
-int test() 
+int test()
 {
   struct timeval timeout, now;
   fd_set sel_read, sel_except, sel_write;
   int i;
-  
+
   {
     /* get server information */
     struct hostent *he;
@@ -446,7 +446,7 @@ int test()
 
   con = malloc(concurrency*sizeof(struct connection));
   memset(con,0,concurrency*sizeof(struct connection));
-  
+
   stats = malloc(requests * sizeof(struct data));
 
   FD_ZERO(&readbits);
@@ -454,9 +454,9 @@ int test()
 
   /* setup request */
   sprintf(request,"GET %s HTTP/1.0\r\nUser-Agent: ZeusBench/1.0\r\n"
-          "%sHost: %s\r\nAccept: */*\r\n\r\n", file, 
+          "%sHost: %s\r\nAccept: */*\r\n\r\n", file,
           keepalive?"Connection: Keep-Alive\r\n":"", machine );
-    
+
   reqlen = strlen(request);
 
   /* ok - lets start */
@@ -491,7 +491,7 @@ int test()
     for(i=0; i<concurrency; i++) {
       int s = con[i].fd;
       if(FD_ISSET(s, &sel_except)) {
-        bad++; 
+        bad++;
         err_except++;
         start_connect(&con[i]);
         continue;
@@ -523,15 +523,15 @@ void usage(char *progname) {
 int main(int argc, char **argv) {
   int c;
   if (argc < 3) usage(argv[0]);
-  
-  machine = argv[1]; 
+
+  machine = argv[1];
   file = argv[2];
   optind = 3;
   while ((c = getopt(argc,argv,"p:n:c:d:t:d:k"))>0) {
     switch(c) {
     case 'd':
       break;
-    case 'n': 
+    case 'n':
       requests = atoi(optarg);
       if(!requests) {
         printf("Invalid number of requests\n");
@@ -555,7 +555,7 @@ int main(int argc, char **argv) {
       usage(argv[0]);
       break;
     }
-  }   
+  }
   test();
   return 0;
 }
