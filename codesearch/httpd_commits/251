commit a83b21763cd2fbfd97bf5cbb5f01ea4d7e7ac3c3
Author: Doug MacEachern <dougm@apache.org>
Date:   Wed Aug 2 05:27:38 2000 +0000

    prefix libapr functions and types with apr_
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@85976 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/include/ap_listen.h b/include/ap_listen.h
index 4f77721..3cae0bd 100644
--- a/include/ap_listen.h
+++ b/include/ap_listen.h
@@ -77,7 +77,7 @@ struct ap_listen_rec {
     /**
      * The actual socket 
      */
-    ap_socket_t *sd;
+    apr_socket_t *sd;
     /**
      * Is this socket currently active 
      */
diff --git a/include/ap_mmn.h b/include/ap_mmn.h
index 8ef55c4..8b9dbc9 100644
--- a/include/ap_mmn.h
+++ b/include/ap_mmn.h
@@ -104,7 +104,7 @@
  *			  short_score split into parent and child pieces
  *			  os_is_absolute_path
  * 19971026 (1.3b3-dev)	- custom config hooks in place
- * 19980126 (1.3b4-dev)	- ap_cpystrn(), table_addn(), table_setn(),
+ * 19980126 (1.3b4-dev)	- apr_cpystrn(), table_addn(), table_setn(),
  *			  table_mergen()
  * 19980201 (1.3b4-dev)	- construct_url()
  *			  prototype server_rec * -> request_rec *
@@ -132,7 +132,7 @@
  * 19980324 (1.3b6-dev)	- API_EXPORT(index_of_response)
  * 19980413 (1.3b6-dev)	- The BIG SYMBOL RENAMING: general ap_ prefix
  *			  (see src/include/compat.h for more details)
- *			  ap_vformatter() API, see src/include/ap.h
+ *			  apr_vformatter() API, see src/include/ap.h
  * 19980507 (1.3b7-dev)	- addition of ap_add_version_component() and
  *			  discontinuation of -DSERVER_SUBVERSION support
  * 19980519 (1.3b7-dev)	- add child_info * to spawn function (as passed to
@@ -168,7 +168,7 @@
  *			  added limit_req_body to core_dir_config and
  *			  ap_get_limit_req_body() to get its value.
  * 19980812 (1.3.2-dev)	- split off MODULE_MAGIC_NUMBER
- * 19980812.2           - add ap_overlap_tables()
+ * 19980812.2           - add apr_overlap_tables()
  * 19980816 (1.3.2-dev)	- change proxy to use tables for headers, change
  *                        struct cache_req to typedef cache_req.
  *                        Delete ap_proxy_get_header(), ap_proxy_add_header(),
@@ -195,7 +195,7 @@
  *                        and added vlist_validator to request_rec.
  * 19990101             - renamed macro escape_uri() to ap_escape_uri()
  *                      - added MODULE_MAGIC_COOKIE to identify module structs
- * 19990103 (1.3.4-dev) - added ap_array_pstrcat()
+ * 19990103 (1.3.4-dev) - added apr_array_pstrcat()
  * 19990105 (1.3.4-dev) - added ap_os_is_filename_valid()
  * 19990106 (1.3.4-dev) - Move MODULE_MAGIC_COOKIE to the end of the
  *                        STANDARD_MODULE_STUFF macro so the version
@@ -205,8 +205,8 @@
  *                      - reordered entries in request_rec that were waiting
  *                        for a non-binary-compatible release.
  *          (1.3.5-dev)
- * 19990108.1           - add ap_MD5Encode() for MD5 password handling.
- * 19990108.2           - add ap_validate_password() and change ap_MD5Encode()
+ * 19990108.1           - add apr_MD5Encode() for MD5 password handling.
+ * 19990108.2           - add apr_validate_password() and change apr_MD5Encode()
  *                        to use a stronger algorithm.
  * 19990108.4           - add ap_size_list_item(), ap_get_list_item(), and
  *                        ap_find_list_item()
@@ -242,13 +242,13 @@
  * specified value.
  * <PRE>
  * Useful for testing for features.
- * For example, suppose you wish to use the ap_overlap_tables
+ * For example, suppose you wish to use the apr_overlap_tables
  *    function.  You can do this:
  * 
  * #if MODULE_MAGIC_AT_LEAST(19980812,2)
- *     ... use ap_overlap_tables()
+ *     ... use apr_overlap_tables()
  * #else
- *     ... alternative code which doesn't use ap_overlap_tables()
+ *     ... alternative code which doesn't use apr_overlap_tables()
  * #endif
  * </PRE>
  * @param major The major module magic number
diff --git a/include/ap_mpm.h b/include/ap_mpm.h
index d4ac786..95a9d90 100644
--- a/include/ap_mpm.h
+++ b/include/ap_mpm.h
@@ -89,7 +89,7 @@
     However the MPM may choose to terminate processes when the user
     requests a non-graceful restart/stop.  When this occurs, the MPM kills
     all threads with extreme prejudice, and destroys the pchild pool.
-    User cleanups registered in the pchild ap_pool_t will be invoked at
+    User cleanups registered in the pchild apr_pool_t will be invoked at
     this point.  (This can pose some complications, the user cleanups
     are asynchronous behaviour not unlike longjmp/signal... but if the
     admin is asking for a non-graceful shutdown, how much effort should
@@ -113,9 +113,9 @@
  * @param plog the log pool, reset after the config file is read
  * @param server_conf the global server config.
  * @return 1 for shutdown 0 otherwise.
- * @deffunc int ap_mpm_run(ap_pool_t *pconf, ap_pool_t *plog, server_rec *server_conf)
+ * @deffunc int ap_mpm_run(apr_pool_t *pconf, apr_pool_t *plog, server_rec *server_conf)
  */
-API_EXPORT(int) ap_mpm_run(ap_pool_t *pconf, ap_pool_t *plog, server_rec *server_conf);
+API_EXPORT(int) ap_mpm_run(apr_pool_t *pconf, apr_pool_t *plog, server_rec *server_conf);
 
 /**
  * predicate indicating if a graceful stop has been requested ...
diff --git a/include/http_config.h b/include/http_config.h
index b7a3930..41be895 100644
--- a/include/http_config.h
+++ b/include/http_config.h
@@ -294,10 +294,10 @@ struct cmd_parms_struct
     ap_directive_t *directive;
 
     /** Pool to allocate new storage in */
-    ap_pool_t *pool;
+    apr_pool_t *pool;
     /** Pool for scratch memory; persists during configuration, but 
      *  wiped before the first request is served...  */
-    ap_pool_t *temp_pool;
+    apr_pool_t *temp_pool;
     /** Server_rec being configured for */
     server_rec *server;
     /** If configuring for a directory, pathname of that directory.  
@@ -371,35 +371,35 @@ struct module_struct {
      *  @param p The pool to use for all allocations.
      *  @param dir The directory currently being processed.
      *  @return The per-directory structure created
-     *  @deffunc void *create_dir_config(ap_pool_t *p, char *dir)
+     *  @deffunc void *create_dir_config(apr_pool_t *p, char *dir)
      */
-    void *(*create_dir_config) (ap_pool_t *p, char *dir);
+    void *(*create_dir_config) (apr_pool_t *p, char *dir);
     /** Function to allow all modules to merge the per directory configuration
      *  structures for two directories.
      *  @param p The pool to use for all allocations.
      *  @param base_conf The directory structure created for the parent directory.
      *  @param new_conf The directory structure currently being processed.
      *  @return The new per-directory structure created
-     *  @deffunc void *merge_dir_config(ap_pool_t *p, void *base_conf, void *new_conf)
+     *  @deffunc void *merge_dir_config(apr_pool_t *p, void *base_conf, void *new_conf)
      */
-    void *(*merge_dir_config) (ap_pool_t *p, void *base_conf, void *new_conf);
+    void *(*merge_dir_config) (apr_pool_t *p, void *base_conf, void *new_conf);
     /** Function to allow all modules to create per server configuration
      *  structures.
      *  @param p The pool to use for all allocations.
      *  @param s The server currently being processed.
      *  @return The per-server structure created
-     *  @deffunc void *create_server_config(ap_pool_t *p, server_rec *dir)
+     *  @deffunc void *create_server_config(apr_pool_t *p, server_rec *dir)
      */
-    void *(*create_server_config) (ap_pool_t *p, server_rec *s);
+    void *(*create_server_config) (apr_pool_t *p, server_rec *s);
     /** Function to allow all modules to merge the per server configuration
      *  structures for two servers.
      *  @param p The pool to use for all allocations.
      *  @param base_conf The directory structure created for the parent directory.
      *  @param new_conf The directory structure currently being processed.
      *  @return The new per-directory structure created
-     *  @deffunc void *merge_dir_config(ap_pool_t *p, void *base_conf, void *new_conf)
+     *  @deffunc void *merge_dir_config(apr_pool_t *p, void *base_conf, void *new_conf)
      */
-    void *(*merge_server_config) (ap_pool_t *p, void *base_conf, void *new_conf);
+    void *(*merge_server_config) (apr_pool_t *p, void *base_conf, void *new_conf);
 
     /** A command_rec table that describes all of the directives this module
      * defines. */
@@ -518,9 +518,9 @@ API_EXPORT_NONSTD(const char *) ap_set_file_slot(cmd_parms *, char *, const char
  * it relativizes it wrt server_root.
  * @param p pool to allocate data out of
  * @param fname The file name
- * @deffunc const char *ap_server_root_relative(ap_pool_t *p, const char *fname)
+ * @deffunc const char *ap_server_root_relative(apr_pool_t *p, const char *fname)
  */
-API_EXPORT(const char *) ap_server_root_relative(ap_pool_t *p, const char *fname);
+API_EXPORT(const char *) ap_server_root_relative(apr_pool_t *p, const char *fname);
 
 /* Finally, the hook for dynamically loading modules in... */
 
@@ -581,13 +581,13 @@ API_EXPORT(const char *) ap_find_module_name(module *m);
 API_EXPORT(module *) ap_find_linked_module(const char *name);
 
 /**
- * Open a configfile_t as ap_file_t
+ * Open a configfile_t as apr_file_t
  * @param ret_cfg open configfile_t struct pointer
  * @param p The pool to allocate the structure out of
  * @param name the name of the file to open
- * @deffunc ap_status_t ap_pcfg_openfile(configfile_t **ret_cfg, ap_pool_t *p, const char *name)
+ * @deffunc apr_status_t ap_pcfg_openfile(configfile_t **ret_cfg, apr_pool_t *p, const char *name)
  */
-API_EXPORT(ap_status_t) ap_pcfg_openfile(configfile_t **, ap_pool_t *p, const char *name);
+API_EXPORT(apr_status_t) ap_pcfg_openfile(configfile_t **, apr_pool_t *p, const char *name);
 
 /**
  * Allocate a configfile_t handle with user defined functions and params 
@@ -597,9 +597,9 @@ API_EXPORT(ap_status_t) ap_pcfg_openfile(configfile_t **, ap_pool_t *p, const ch
  * @param getc_func The getch function
  * @param gets_func The getstr function
  * @param close_func The close function
- * @deffunc configfile_t *ap_pcfg_open_custom(ap_pool_t *p, const char *descr, void *param, int(*getc_func)(void*), void *(*gets_func) (void *buf, size_t bufsiz, void *param), int(*close_func)(void *param))
+ * @deffunc configfile_t *ap_pcfg_open_custom(apr_pool_t *p, const char *descr, void *param, int(*getc_func)(void*), void *(*gets_func) (void *buf, size_t bufsiz, void *param), int(*close_func)(void *param))
  */
-API_EXPORT(configfile_t *) ap_pcfg_open_custom(ap_pool_t *p, const char *descr,
+API_EXPORT(configfile_t *) ap_pcfg_open_custom(apr_pool_t *p, const char *descr,
     void *param,
     int(*getc_func)(void*),
     void *(*gets_func) (void *buf, size_t bufsiz, void *param),
@@ -651,9 +651,9 @@ API_EXPORT(const char *) ap_soak_end_container(cmd_parms *cmd, char *directive);
  * @param curr_parent The current parent node
  * @param orig_directive The directive to read until hit.
  * @return Error string on failure, NULL on success
- * @deffunc char *ap_build_cont_config(ap_pool_t *p, ap_pool_t *temp_pool, cmd_parms *parms, ap_directive_t **current, ap_directive_t **curr_parent, char *orig_directive)
+ * @deffunc char *ap_build_cont_config(apr_pool_t *p, apr_pool_t *temp_pool, cmd_parms *parms, ap_directive_t **current, ap_directive_t **curr_parent, char *orig_directive)
 */
-const char * ap_build_cont_config(ap_pool_t *p, ap_pool_t *temp_pool,
+const char * ap_build_cont_config(apr_pool_t *p, apr_pool_t *temp_pool,
                                         cmd_parms *parms,
                                         ap_directive_t **current,
                                         ap_directive_t **curr_parent,
@@ -666,11 +666,11 @@ const char * ap_build_cont_config(ap_pool_t *p, ap_pool_t *temp_pool,
  * @param temp_pool The temporary pool
  * @param conftree Place to store the root node of the config tree
  * @return Error string on erro, NULL otherwise
- * @deffunc const char *ap_build_config(cmd_parms *parms, ap_pool_t *conf_pool, ap_pool_t *temp_pool, ap_directive_t **conftree)
+ * @deffunc const char *ap_build_config(cmd_parms *parms, apr_pool_t *conf_pool, apr_pool_t *temp_pool, ap_directive_t **conftree)
  */
 API_EXPORT(const char *) ap_build_config(cmd_parms *parms,
-					 ap_pool_t *conf_pool,
-					 ap_pool_t *temp_pool,
+					 apr_pool_t *conf_pool,
+					 apr_pool_t *temp_pool,
 					 ap_directive_t **conftree);
 
 /**
@@ -742,7 +742,7 @@ extern API_VAR_EXPORT module **ap_loaded_modules;
  *  @param s The server to configure for.
  *  @param m The module to configure
  */
-void ap_single_module_configure(ap_pool_t *p, server_rec *s, module *m);
+void ap_single_module_configure(apr_pool_t *p, server_rec *s, module *m);
 
 /* For http_main.c... */
 /**
@@ -773,9 +773,9 @@ API_EXPORT(void) ap_show_modules(void);
  * @param config_name The name of the config file
  * @param conftree Place to store the root of the config tree
  * @return The setup server_rec list.
- * @deffunc server_rec *ap_read_config(process_rec *process, ap_pool_t *temp_pool, const char *config_name, ap_directive_t **conftree)
+ * @deffunc server_rec *ap_read_config(process_rec *process, apr_pool_t *temp_pool, const char *config_name, ap_directive_t **conftree)
  */
-API_EXPORT(server_rec*) ap_read_config(process_rec *process, ap_pool_t *temp_pool, const char *config_name, ap_directive_t **conftree);
+API_EXPORT(server_rec*) ap_read_config(process_rec *process, apr_pool_t *temp_pool, const char *config_name, ap_directive_t **conftree);
 
 /**
  * Run all post config hooks for loaded modules.
@@ -783,9 +783,9 @@ API_EXPORT(server_rec*) ap_read_config(process_rec *process, ap_pool_t *temp_poo
  * @param plog The logging pool
  * @param ptemp The temporary pool
  * @param s The list of server_rec structures
- * @deffunc void ap_post_config_hook(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *s)
+ * @deffunc void ap_post_config_hook(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
  */
-API_EXPORT(void) ap_post_config_hook(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *s);
+API_EXPORT(void) ap_post_config_hook(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s);
 
 /**
  * Run all rewrite args hooks for loaded modules
@@ -805,9 +805,9 @@ API_EXPORT(void) ap_register_hooks(module *m);
  * Setup all virtual hosts
  * @param p The pool to allocate out of
  * @param main_server The head of the server_rec list
- * @deffunc void ap_fixup_virtual_hosts(ap_pool_t *p, server_rec *main_server)
+ * @deffunc void ap_fixup_virtual_hosts(apr_pool_t *p, server_rec *main_server)
  */
-API_EXPORT(void) ap_fixup_virtual_hosts(ap_pool_t *p, server_rec *main_server);
+API_EXPORT(void) ap_fixup_virtual_hosts(apr_pool_t *p, server_rec *main_server);
 
 /* For http_request.c... */
 
@@ -816,15 +816,15 @@ API_EXPORT(void) ap_fixup_virtual_hosts(ap_pool_t *p, server_rec *main_server);
  * @param p The pool to allocate the config vector out of
  * @return The config vector
  */
-void *ap_create_request_config(ap_pool_t *p);
+void *ap_create_request_config(apr_pool_t *p);
 
 /**
  * Setup the config vector for per dir module configs
  * @param p The pool to allocate the config vector out of
  * @return The config vector
- * @deffunc void *ap_create_per_dir_config(ap_pool_t *p)
+ * @deffunc void *ap_create_per_dir_config(apr_pool_t *p)
  */
-CORE_EXPORT(void *) ap_create_per_dir_config(ap_pool_t *p);
+CORE_EXPORT(void *) ap_create_per_dir_config(apr_pool_t *p);
 
 /**
  * Run all of the modules merge per dir config functions
@@ -832,7 +832,7 @@ CORE_EXPORT(void *) ap_create_per_dir_config(ap_pool_t *p);
  * @param base The base directory config structure
  * @param new The new directory config structure
  */
-void *ap_merge_per_dir_configs(ap_pool_t *p, void *base, void *new);
+void *ap_merge_per_dir_configs(apr_pool_t *p, void *base, void *new);
 
 /* For http_connection.c... */
 /**
@@ -840,7 +840,7 @@ void *ap_merge_per_dir_configs(ap_pool_t *p, void *base, void *new);
  * @param p The pool to allocate the config vector out of
  * @return The config vector
  */
-void *ap_create_conn_config(ap_pool_t *p);
+void *ap_create_conn_config(apr_pool_t *p);
 
 /* For http_core.c... (<Directory> command and virtual hosts) */
 
@@ -863,9 +863,9 @@ int ap_parse_htaccess(void **result, request_rec *r, int override,
  * @param main_server The main server for this Apache configuration
  * @param ps Place to store the new server_rec
  * return Error string on error, NULL on success
- * @deffunc const char *ap_init_virtual_host(ap_pool_t *p, const char *hostname, server_rec *main_server, server_rec **ps)
+ * @deffunc const char *ap_init_virtual_host(apr_pool_t *p, const char *hostname, server_rec *main_server, server_rec **ps)
  */
-CORE_EXPORT(const char *) ap_init_virtual_host(ap_pool_t *p, const char *hostname,
+CORE_EXPORT(const char *) ap_init_virtual_host(apr_pool_t *p, const char *hostname,
 				server_rec *main_server, server_rec **);
 
 /**
@@ -877,7 +877,7 @@ CORE_EXPORT(const char *) ap_init_virtual_host(ap_pool_t *p, const char *hostnam
  * @param ptem Pool for temporary allocation
  */
 void ap_process_resource_config(server_rec *s, const char *fname, 
-                 ap_directive_t **conftree, ap_pool_t *p, ap_pool_t *ptemp);
+                 ap_directive_t **conftree, apr_pool_t *p, apr_pool_t *ptemp);
 
 /**
  * Process all directives in the config tree
@@ -887,7 +887,7 @@ void ap_process_resource_config(server_rec *s, const char *fname,
  * @param ptemp The pool for temporary allocations
  */
 API_EXPORT(void) ap_process_config_tree(server_rec *s, ap_directive_t *conftree,
-                                        ap_pool_t *p, ap_pool_t *ptemp);
+                                        apr_pool_t *p, apr_pool_t *ptemp);
 
 
 /* For individual MPMs... */
@@ -896,7 +896,7 @@ API_EXPORT(void) ap_process_config_tree(server_rec *s, ap_directive_t *conftree,
  * @param pchild The pool for child process allocations
  * @param s The list of all server_recs
  */
-void ap_child_init_hook(ap_pool_t *pchild, server_rec *s);
+void ap_child_init_hook(apr_pool_t *pchild, server_rec *s);
 
 /* Module-method dispatchers, also for http_request.c */
 /**
@@ -954,10 +954,10 @@ AP_DECLARE_HOOK(int,header_parser,(request_rec *))
  * @param pconf The config pool
  * @param plog The logging streams pool
  * @param ptemp The temporary pool
- * @deffunc void ap_run_pre_config(ap_pool_t *pconf,ap_pool_t *plog,ap_pool_t *ptemp)
+ * @deffunc void ap_run_pre_config(apr_pool_t *pconf,apr_pool_t *plog,apr_pool_t *ptemp)
  */
 AP_DECLARE_HOOK(void,pre_config,
-	     (ap_pool_t *pconf,ap_pool_t *plog,ap_pool_t *ptemp))
+	     (apr_pool_t *pconf,apr_pool_t *plog,apr_pool_t *ptemp))
 
 /**
  * Run the post_config function for each module
@@ -965,10 +965,10 @@ AP_DECLARE_HOOK(void,pre_config,
  * @param plog The logging streams pool
  * @param ptemp The temporary pool
  * @param s The list of server_recs
- * @deffunc void ap_run_post_config(ap_pool_t *pconf,ap_pool_t *plog,ap_pool_t *ptemp, server_rec *s)
+ * @deffunc void ap_run_post_config(apr_pool_t *pconf,apr_pool_t *plog,apr_pool_t *ptemp, server_rec *s)
  */
 AP_DECLARE_HOOK(void,post_config,
-	     (ap_pool_t *pconf,ap_pool_t *plog,ap_pool_t *ptemp,server_rec *s))
+	     (apr_pool_t *pconf,apr_pool_t *plog,apr_pool_t *ptemp,server_rec *s))
 
 /**
  * Run the open_logs functions for each module
@@ -976,18 +976,18 @@ AP_DECLARE_HOOK(void,post_config,
  * @param plog The logging streams pool
  * @param ptemp The temporary pool
  * @param s The list of server_recs
- * @deffunc void ap_run_open_logs(ap_pool_t *pconf,ap_pool_t *plog,ap_pool_t *ptemp, server_rec *s)
+ * @deffunc void ap_run_open_logs(apr_pool_t *pconf,apr_pool_t *plog,apr_pool_t *ptemp, server_rec *s)
  */
 AP_DECLARE_HOOK(void,open_logs,
-	     (ap_pool_t *pconf,ap_pool_t *plog,ap_pool_t *ptemp,server_rec *s))
+	     (apr_pool_t *pconf,apr_pool_t *plog,apr_pool_t *ptemp,server_rec *s))
 
 /**
  * Run the child_init functions for each module
  * @param pchild The child pool
  * @param s The list of server_recs in this server 
- * @deffunc void ap_run_child_init(ap_pool_t *pchild, server_rec *s)
+ * @deffunc void ap_run_child_init(apr_pool_t *pchild, server_rec *s)
  */
-AP_DECLARE_HOOK(void,child_init,(ap_pool_t *pchild, server_rec *s))
+AP_DECLARE_HOOK(void,child_init,(apr_pool_t *pchild, server_rec *s))
 
 #ifdef __cplusplus
 }
diff --git a/include/http_connection.h b/include/http_connection.h
index 0fb6000..2b204bd 100644
--- a/include/http_connection.h
+++ b/include/http_connection.h
@@ -76,7 +76,7 @@ extern "C" {
  * @param addr The server's local address
  * @param id ID of this connection; unique at any point in time.
  */
-conn_rec *ap_new_connection(ap_pool_t *p, server_rec *server, BUFF *inout,
+conn_rec *ap_new_connection(apr_pool_t *p, server_rec *server, BUFF *inout,
 			    const struct sockaddr_in *remaddr,
 			    const struct sockaddr_in *saddr, long id);
 
@@ -89,8 +89,8 @@ conn_rec *ap_new_connection(ap_pool_t *p, server_rec *server, BUFF *inout,
  * @param conn_socket The socket we are creating the connection on.
  * @param id ID of this connection; unique at any point in time.
  */
-conn_rec *ap_new_apr_connection(ap_pool_t *p, server_rec *server, BUFF *inout,
-                                ap_socket_t *conn_socket, long id);
+conn_rec *ap_new_apr_connection(apr_pool_t *p, server_rec *server, BUFF *inout,
+                                apr_socket_t *conn_socket, long id);
 
 /**
  * This is the protocol module driver.  This calls all of the
diff --git a/include/http_core.h b/include/http_core.h
index 8b30c236..19d1813 100644
--- a/include/http_core.h
+++ b/include/http_core.h
@@ -131,7 +131,7 @@ API_EXPORT(const char *) ap_get_remote_logname(request_rec *r);
 /* Used for constructing self-referencing URLs, and things like SERVER_PORT,
  * and SERVER_NAME.
  */
-API_EXPORT(char *) ap_construct_url(ap_pool_t *p, const char *uri, request_rec *r);
+API_EXPORT(char *) ap_construct_url(apr_pool_t *p, const char *uri, request_rec *r);
 API_EXPORT(const char *) ap_get_server_name(request_rec *r);
 API_EXPORT(unsigned) ap_get_server_port(const request_rec *r);
 API_EXPORT(unsigned long) ap_get_limit_req_body(const request_rec *r);
@@ -155,7 +155,7 @@ typedef struct {
 API_EXPORT(const char *) ap_auth_type (request_rec *);
 API_EXPORT(const char *) ap_auth_name (request_rec *);     
 API_EXPORT(int) ap_satisfies (request_rec *r);
-API_EXPORT(const ap_array_header_t *) ap_requires (request_rec *);    
+API_EXPORT(const apr_array_header_t *) ap_requires (request_rec *);    
 
 #ifdef WIN32
 /* 
@@ -218,7 +218,7 @@ typedef struct {
     int satisfy;
     char *ap_auth_type;
     char *ap_auth_name;
-    ap_array_header_t *ap_requires;
+    apr_array_header_t *ap_requires;
 
     /* Custom response config. These can contain text or a URL to redirect to.
      * if response_code_strings is NULL then there are none in the config,
@@ -279,7 +279,7 @@ typedef struct {
     int loglevel;
     
     /* Access control */
-    ap_array_header_t *sec;
+    apr_array_header_t *sec;
     regex_t *r;
 
 #ifdef WIN32
@@ -306,12 +306,12 @@ typedef struct {
     /* Access control */
 
     char *access_name;
-    ap_array_header_t *sec;
-    ap_array_header_t *sec_url;
+    apr_array_header_t *sec;
+    apr_array_header_t *sec_url;
 } core_server_config;
 
 /* for http_config.c */
-void ap_core_reorder_directories(ap_pool_t *, server_rec *);
+void ap_core_reorder_directories(apr_pool_t *, server_rec *);
 
 /* for mod_perl */
 CORE_EXPORT(void) ap_add_per_dir_conf (server_rec *s, void *dir_config);
diff --git a/include/http_log.h b/include/http_log.h
index fb3cb66..b8f0cc5 100644
--- a/include/http_log.h
+++ b/include/http_log.h
@@ -118,7 +118,7 @@ extern "C" {
  * @param s_main The main server
  * @param p The pool to allocate out of
  */
-void ap_open_logs (server_rec *s_main, ap_pool_t *p);
+void ap_open_logs (server_rec *s_main, apr_pool_t *p);
 
 /* 
  * The three primary logging functions, ap_log_error, ap_log_rerror, and 
@@ -147,10 +147,10 @@ void ap_open_logs (server_rec *s_main, ap_pool_t *p);
  * denial-of-service attack and other messy behavior.  Instead, use a 
  * simple format string like "%s", followed by the string containing the 
  * untrusted data.
- * @deffunc void ap_log_error(const char *file, int line, int level, ap_status_t status, const server_rec *s, const char *fmt, ...) 
+ * @deffunc void ap_log_error(const char *file, int line, int level, apr_status_t status, const server_rec *s, const char *fmt, ...) 
  */
 API_EXPORT(void) ap_log_error(const char *file, int line, int level, 
-                             ap_status_t status, const server_rec *s, 
+                             apr_status_t status, const server_rec *s, 
                              const char *fmt, ...)
 			    __attribute__((format(printf,6,7)));
 
@@ -171,10 +171,10 @@ API_EXPORT(void) ap_log_error(const char *file, int line, int level,
  * denial-of-service attack and other messy behavior.  Instead, use a 
  * simple format string like "%s", followed by the string containing the 
  * untrusted data.
- * @deffunc void ap_log_error(const char *file, int line, int level, ap_status_t status, ap_pool_t *p, const char *fmt, ...) 
+ * @deffunc void ap_log_error(const char *file, int line, int level, apr_status_t status, apr_pool_t *p, const char *fmt, ...) 
  */
 API_EXPORT(void) ap_log_perror(const char *file, int line, int level, 
-                             ap_status_t status, ap_pool_t *p, 
+                             apr_status_t status, apr_pool_t *p, 
                              const char *fmt, ...)
 			    __attribute__((format(printf,6,7)));
 
@@ -195,10 +195,10 @@ API_EXPORT(void) ap_log_perror(const char *file, int line, int level,
  * denial-of-service attack and other messy behavior.  Instead, use a 
  * simple format string like "%s", followed by the string containing the 
  * untrusted data.
- * @deffunc void ap_log_error(const char *file, int line, int level, ap_status_t status, request_rec *s, const char *fmt, ...) 
+ * @deffunc void ap_log_error(const char *file, int line, int level, apr_status_t status, request_rec *s, const char *fmt, ...) 
  */
 API_EXPORT(void) ap_log_rerror(const char *file, int line, int level, 
-                               ap_status_t status, const request_rec *s, 
+                               apr_status_t status, const request_rec *s, 
                                const char *fmt, ...)
 			    __attribute__((format(printf,6,7)));
 
@@ -214,7 +214,7 @@ API_EXPORT(void) ap_error_log2stderr (server_rec *);
  * @param p The pool to use for logging
  * @param fname The name of the file to log to
  */
-void ap_log_pid (ap_pool_t *p, const char *fname);
+void ap_log_pid (apr_pool_t *p, const char *fname);
 /* These are for legacy code, new code should use ap_log_error,
  * or ap_log_rerror.
  */
@@ -234,16 +234,16 @@ typedef struct piped_log piped_log;
  */
 struct piped_log {
     /** The pool to use for the piped log */
-    ap_pool_t *p;
+    apr_pool_t *p;
     /** The pipe between the server and the logging process */
-    ap_file_t *fds[2];
+    apr_file_t *fds[2];
     /* XXX - an #ifdef that needs to be eliminated from public view. Shouldn't
      * be hard */
 #ifdef HAVE_RELIABLE_PIPED_LOGS
     /** The name of the program the logging process is running */
     char *program;
     /** The pid of the logging process */
-    ap_proc_t *pid;
+    apr_proc_t *pid;
 #endif
 };
 
@@ -252,9 +252,9 @@ struct piped_log {
  * @param p The pool to allocate out of
  * @param program The program to run in the logging process
  * @return The piped log structure
- * @deffunc piped_log *ap_open_piped_log(ap_pool_t *p, const char *program)
+ * @deffunc piped_log *ap_open_piped_log(apr_pool_t *p, const char *program)
  */
-API_EXPORT(piped_log *) ap_open_piped_log (ap_pool_t *p, const char *program);
+API_EXPORT(piped_log *) ap_open_piped_log (apr_pool_t *p, const char *program);
 
 /**
  * Close the piped log and kill the logging process
diff --git a/include/http_main.h b/include/http_main.h
index f23675b..2ab7577 100644
--- a/include/http_main.h
+++ b/include/http_main.h
@@ -60,7 +60,7 @@
 #define APACHE_HTTP_MAIN_H
 
 /* AP_SERVER_BASEARGS is the command argument list parsed by http_main.c
- * in ap_getopt() format.  Use this for default'ing args that the MPM
+ * in apr_getopt() format.  Use this for default'ing args that the MPM
  * can safely ignore and pass on from its rewrite_args() handler.
  */
 #define AP_SERVER_BASEARGS "C:c:D:d:f:vVlLth?"
@@ -73,9 +73,9 @@ extern API_VAR_EXPORT const char *ap_server_argv0;
 extern API_VAR_EXPORT const char *ap_server_root;
 
 /* for -C, -c and -D switches */
-extern API_VAR_EXPORT ap_array_header_t *ap_server_pre_read_config;
-extern API_VAR_EXPORT ap_array_header_t *ap_server_post_read_config;
-extern API_VAR_EXPORT ap_array_header_t *ap_server_config_defines;
+extern API_VAR_EXPORT apr_array_header_t *ap_server_pre_read_config;
+extern API_VAR_EXPORT apr_array_header_t *ap_server_post_read_config;
+extern API_VAR_EXPORT apr_array_header_t *ap_server_config_defines;
 
 #ifdef __cplusplus
 }
diff --git a/include/http_protocol.h b/include/http_protocol.h
index 5759487..37e40f4 100644
--- a/include/http_protocol.h
+++ b/include/http_protocol.h
@@ -119,7 +119,7 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error);
 
 API_EXPORT(int) ap_set_content_length(request_rec *r, long length);
 API_EXPORT(int) ap_set_keepalive(request_rec *r);
-API_EXPORT(ap_time_t) ap_rationalize_mtime(request_rec *r, ap_time_t mtime);
+API_EXPORT(apr_time_t) ap_rationalize_mtime(request_rec *r, apr_time_t mtime);
 API_EXPORT(char *) ap_make_etag(request_rec *r, int force_weak);
 API_EXPORT(void) ap_set_etag(request_rec *r);
 API_EXPORT(void) ap_set_last_modified(request_rec *r);
@@ -136,13 +136,13 @@ API_EXPORT(int) ap_meets_conditions(request_rec *r);
  * (Ditto the send_header stuff).
  */
 
-API_EXPORT(ap_status_t) ap_send_fd(ap_file_t *fd, request_rec *r, ap_off_t offset, 
-                                   ap_size_t length, ap_size_t *nbytes);
+API_EXPORT(apr_status_t) ap_send_fd(apr_file_t *fd, request_rec *r, apr_off_t offset, 
+                                   apr_size_t length, apr_size_t *nbytes);
 
 API_EXPORT(long) ap_send_fb(BUFF *f, request_rec *r);
 API_EXPORT(long) ap_send_fb_length(BUFF *f, request_rec *r, long length);
 
-API_EXPORT(size_t) ap_send_mmap(ap_mmap_t *mm, request_rec *r, size_t offset,
+API_EXPORT(size_t) ap_send_mmap(apr_mmap_t *mm, request_rec *r, size_t offset,
                              size_t length);
 
 /* Hmmm... could macrofy these for now, and maybe forever, though the
@@ -182,8 +182,8 @@ API_EXPORT(int) ap_discard_request_body(request_rec *r);
 /* Sending a byterange */
 
 API_EXPORT(int) ap_set_byterange(request_rec *r);
-API_EXPORT(int) ap_each_byterange(request_rec *r, ap_off_t *offset,
-				  ap_size_t *length);
+API_EXPORT(int) ap_each_byterange(request_rec *r, apr_off_t *offset,
+				  apr_size_t *length);
 
 /* Support for the Basic authentication protocol.  Note that there's
  * nothing that prevents these from being in mod_auth.c, except that other
diff --git a/include/http_request.h b/include/http_request.h
index 2071f7c..7d5bed2 100644
--- a/include/http_request.h
+++ b/include/http_request.h
@@ -82,7 +82,7 @@ extern "C" {
  * (e.g., for includes), a module may call for the request to be run
  * by calling run_sub_req.  The space allocated to create sub_reqs can be
  * reclaimed by calling destroy_sub_req --- be sure to copy anything you care
- * about which was allocated in its ap_pool_t elsewhere before doing this.
+ * about which was allocated in its apr_pool_t elsewhere before doing this.
  */
 
 API_EXPORT(request_rec *) ap_sub_req_lookup_uri(const char *new_file,
@@ -105,7 +105,7 @@ API_EXPORT(void) ap_internal_redirect(const char *new_uri, request_rec *);
 API_EXPORT(void) ap_internal_redirect_handler(const char *new_uri, request_rec *);
 API_EXPORT(int) ap_some_auth_required(request_rec *r);
 API_EXPORT(int) ap_is_initial_req(request_rec *r);
-API_EXPORT(void) ap_update_mtime(request_rec *r, ap_time_t dependency_mtime);
+API_EXPORT(void) ap_update_mtime(request_rec *r, apr_time_t dependency_mtime);
 
 #ifdef CORE_PRIVATE
 /* Function called by main.c to handle first-level request */
diff --git a/include/http_vhost.h b/include/http_vhost.h
index 256609d..b131273 100644
--- a/include/http_vhost.h
+++ b/include/http_vhost.h
@@ -60,13 +60,13 @@ extern "C" {
 #endif
 
 /* called before any config is read */
-void ap_init_vhost_config(ap_pool_t *p);
+void ap_init_vhost_config(apr_pool_t *p);
 
 /* called after the config has been read */
-void ap_fini_vhost_config(ap_pool_t *p, server_rec *main_server);
+void ap_fini_vhost_config(apr_pool_t *p, server_rec *main_server);
 
 /* handle addresses in <VirtualHost> statement */
-const char *ap_parse_vhost_addrs(ap_pool_t *p, const char *hostname, server_rec *s);
+const char *ap_parse_vhost_addrs(apr_pool_t *p, const char *hostname, server_rec *s);
 
 /* handle NameVirtualHost directive */
 const char *ap_set_name_virtual_host (cmd_parms *cmd, void *dummy,
diff --git a/include/httpd.h b/include/httpd.h
index 763619b..420a3a1 100644
--- a/include/httpd.h
+++ b/include/httpd.h
@@ -366,7 +366,7 @@ extern "C" {
 #define APEXIT_CHILDFATAL	0xf
 
 API_EXPORT(const char *) ap_get_server_version(void);
-API_EXPORT(void) ap_add_version_component(ap_pool_t *pconf, const char *component);
+API_EXPORT(void) ap_add_version_component(apr_pool_t *pconf, const char *component);
 API_EXPORT(const char *) ap_get_server_built(void);
 
 /* Numeric release version identifier: MMNNFFRBB: major minor fix final beta
@@ -386,7 +386,7 @@ API_EXPORT(const char *) ap_get_server_built(void);
 
 /* The size of the static array in http_protocol.c for storing
  * all of the potential response status-lines (a sparse table).
- * A future version should dynamically generate the ap_table_t at startup.
+ * A future version should dynamically generate the apr_table_t at startup.
  */
 #define RESPONSE_CODES 55
 
@@ -558,15 +558,15 @@ typedef struct request_rec request_rec;
 
 struct ap_rr_xlate {
     /* contents are experimental! expect it to change! */
-    ap_xlate_t *to_net;
+    apr_xlate_t *to_net;
     int to_net_sb; /* whether or not write translation is single-byte-only */
-    ap_xlate_t *from_net;
+    apr_xlate_t *from_net;
 };
 #endif /*APACHE_XLATE*/
 
 struct process_rec {
-    ap_pool_t *pool;  /* Global pool. Please try to cleared on _all_ exits */
-    ap_pool_t *pconf; /* aka configuration pool, cleared on restarts */
+    apr_pool_t *pool;  /* Global pool. Please try to cleared on _all_ exits */
+    apr_pool_t *pconf; /* aka configuration pool, cleared on restarts */
     int argc;
     char *const *argv;
     const char *short_name;
@@ -574,7 +574,7 @@ struct process_rec {
 
 struct request_rec {
 
-    ap_pool_t *pool;
+    apr_pool_t *pool;
     conn_rec *connection;
     server_rec *server;
 
@@ -602,7 +602,7 @@ struct request_rec {
     int proto_num;		/* Number version of protocol; 1.1 = 1001 */
     const char *hostname;	/* Host, as set by full URI or Host: */
 
-    ap_time_t request_time;	/* When the request started */
+    apr_time_t request_time;	/* When the request started */
 
     const char *status_line;	/* Status line, if set by script */
     int status;			/* In any case */
@@ -638,7 +638,7 @@ struct request_rec {
 
     int sent_bodyct;		/* byte count in stream is for body */
     long bytes_sent;		/* body byte count, for easy access */
-    ap_time_t mtime;		/* Time the resource was last modified */
+    apr_time_t mtime;		/* Time the resource was last modified */
 
     /* HTTP/1.1 connection-level features */
 
@@ -662,15 +662,15 @@ struct request_rec {
      * latter are printed even on error, and persist across internal redirects
      * (so the headers printed for ErrorDocument handlers will have them).
      *
-     * The 'notes' ap_table_t is for notes from one module to another, with no
+     * The 'notes' apr_table_t is for notes from one module to another, with no
      * other set purpose in mind...
      */
 
-    ap_table_t *headers_in;
-    ap_table_t *headers_out;
-    ap_table_t *err_headers_out;
-    ap_table_t *subprocess_env;
-    ap_table_t *notes;
+    apr_table_t *headers_in;
+    apr_table_t *headers_out;
+    apr_table_t *err_headers_out;
+    apr_table_t *subprocess_env;
+    apr_table_t *notes;
 
     /* content_type, handler, content_encoding, content_language, and all
      * content_languages MUST be lowercased strings.  They may be pointers
@@ -681,7 +681,7 @@ struct request_rec {
 
     const char *content_encoding;
     const char *content_language;	/* for back-compat. only -- do not use */
-    ap_array_header_t *content_languages;	/* array of (char*) */
+    apr_array_header_t *content_languages;	/* array of (char*) */
 
     char *vlist_validator;      /* variant list validator (if negotiated) */
     
@@ -702,7 +702,7 @@ struct request_rec {
     char *filename;
     char *path_info;
     char *args;			/* QUERY_ARGS, if any */
-    ap_finfo_t finfo;		/* ST_MODE set to zero if no such file */
+    apr_finfo_t finfo;		/* ST_MODE set to zero if no such file */
     uri_components parsed_uri;	/* components of uri, dismantled */
 
     /* Various other config info which may change with .htaccess files
@@ -725,7 +725,7 @@ struct request_rec {
     struct ap_rr_xlate *rrx;
 #endif /*APACHE_XLATE*/
 
-    struct ap_filter_t *filters;
+    struct apr_filter_t *filters;
 
 /* Things placed at the end of the record to avoid breaking binary
  * compatibility.  It would be nice to remember to reorder the entire
@@ -740,7 +740,7 @@ struct request_rec {
 
 struct conn_rec {
 
-    ap_pool_t *pool;
+    apr_pool_t *pool;
     server_rec *base_server;	/* Physical vhost this conn come in on */
     void *vhost_lookup_data;	/* used by http_vhost.c */
 
@@ -776,7 +776,7 @@ struct conn_rec {
     long id;                    /* ID of this connection; unique at any
                                  * point in time */
     void *conn_config;		/* Notes on *this* connection */
-    ap_table_t *notes;  /* send note from one module to another, must
+    apr_table_t *notes;  /* send note from one module to another, must
                          * remain valid for all requests on this conn */
 };
 
@@ -790,7 +790,7 @@ struct conn_rec {
 typedef struct server_addr_rec server_addr_rec;
 struct server_addr_rec {
     server_addr_rec *next;
-    ap_in_addr host_addr;	/* The bound address, for this server */
+    apr_in_addr host_addr;	/* The bound address, for this server */
     unsigned short host_port;	/* The bound port, for this server */
     char *virthost;		/* The name given in <VirtualHost> */
 };
@@ -812,7 +812,7 @@ struct server_rec {
     /* Log files --- note that transfer log is now in the modules... */
 
     char *error_fname;
-    ap_file_t *error_log;
+    apr_file_t *error_log;
     int loglevel;
 
     /* Module-specific configuration for server, and defaults... */
@@ -835,8 +835,8 @@ struct server_rec {
     const char *path;		/* Pathname for ServerPath */
     int pathlen;		/* Length of path */
 
-    ap_array_header_t *names;	/* Normal names for ServerAlias servers */
-    ap_array_header_t *wild_names;	/* Wildcarded names for ServerAlias servers */
+    apr_array_header_t *names;	/* Normal names for ServerAlias servers */
+    apr_array_header_t *wild_names;	/* Wildcarded names for ServerAlias servers */
 
     uid_t server_uid;        /* effective user id when calling exec wrapper */
     gid_t server_gid;        /* effective group id when calling exec wrapper */
@@ -894,69 +894,69 @@ struct server_rec {
 
 /* Time */
 
-API_EXPORT(char *) ap_field_noparam(ap_pool_t *p, const char *intype);
-API_EXPORT(char *) ap_ht_time(ap_pool_t *p, ap_time_t t, const char *fmt, int gmt);
+API_EXPORT(char *) ap_field_noparam(apr_pool_t *p, const char *intype);
+API_EXPORT(char *) ap_ht_time(apr_pool_t *p, apr_time_t t, const char *fmt, int gmt);
 
 /* String handling. The *_nc variants allow you to use non-const char **s as
    arguments (unfortunately C won't automatically convert a char ** to a const
    char **) */
 
-API_EXPORT(char *) ap_getword(ap_pool_t *p, const char **line, char stop);
-API_EXPORT(char *) ap_getword_nc(ap_pool_t *p, char **line, char stop);
-API_EXPORT(char *) ap_getword_white(ap_pool_t *p, const char **line);
-API_EXPORT(char *) ap_getword_white_nc(ap_pool_t *p, char **line);
-API_EXPORT(char *) ap_getword_nulls(ap_pool_t *p, const char **line, char stop);
-API_EXPORT(char *) ap_getword_nulls_nc(ap_pool_t *p, char **line, char stop);
-API_EXPORT(char *) ap_getword_conf(ap_pool_t *p, const char **line);
-API_EXPORT(char *) ap_getword_conf_nc(ap_pool_t *p, char **line);
-API_EXPORT(const char *) ap_resolve_env(ap_pool_t *p, const char * word); 
+API_EXPORT(char *) ap_getword(apr_pool_t *p, const char **line, char stop);
+API_EXPORT(char *) ap_getword_nc(apr_pool_t *p, char **line, char stop);
+API_EXPORT(char *) ap_getword_white(apr_pool_t *p, const char **line);
+API_EXPORT(char *) ap_getword_white_nc(apr_pool_t *p, char **line);
+API_EXPORT(char *) ap_getword_nulls(apr_pool_t *p, const char **line, char stop);
+API_EXPORT(char *) ap_getword_nulls_nc(apr_pool_t *p, char **line, char stop);
+API_EXPORT(char *) ap_getword_conf(apr_pool_t *p, const char **line);
+API_EXPORT(char *) ap_getword_conf_nc(apr_pool_t *p, char **line);
+API_EXPORT(const char *) ap_resolve_env(apr_pool_t *p, const char * word); 
 
 API_EXPORT(const char *) ap_size_list_item(const char **field, int *len);
-API_EXPORT(char *) ap_get_list_item(ap_pool_t *p, const char **field);
-API_EXPORT(int) ap_find_list_item(ap_pool_t *p, const char *line, const char *tok);
+API_EXPORT(char *) ap_get_list_item(apr_pool_t *p, const char **field);
+API_EXPORT(int) ap_find_list_item(apr_pool_t *p, const char *line, const char *tok);
 
-API_EXPORT(char *) ap_get_token(ap_pool_t *p, const char **accept_line, int accept_white);
-API_EXPORT(int) ap_find_token(ap_pool_t *p, const char *line, const char *tok);
-API_EXPORT(int) ap_find_last_token(ap_pool_t *p, const char *line, const char *tok);
+API_EXPORT(char *) ap_get_token(apr_pool_t *p, const char **accept_line, int accept_white);
+API_EXPORT(int) ap_find_token(apr_pool_t *p, const char *line, const char *tok);
+API_EXPORT(int) ap_find_last_token(apr_pool_t *p, const char *line, const char *tok);
 
 API_EXPORT(int) ap_is_url(const char *u);
 API_EXPORT(int) ap_unescape_url(char *url);
 API_EXPORT(void) ap_no2slash(char *name);
 API_EXPORT(void) ap_getparents(char *name);
-API_EXPORT(char *) ap_escape_path_segment(ap_pool_t *p, const char *s);
-API_EXPORT(char *) ap_os_escape_path(ap_pool_t *p, const char *path, int partial);
+API_EXPORT(char *) ap_escape_path_segment(apr_pool_t *p, const char *s);
+API_EXPORT(char *) ap_os_escape_path(apr_pool_t *p, const char *path, int partial);
 #define ap_escape_uri(ppool,path) ap_os_escape_path(ppool,path,1)
-API_EXPORT(char *) ap_escape_html(ap_pool_t *p, const char *s);
-API_EXPORT(char *) ap_construct_server(ap_pool_t *p, const char *hostname,
+API_EXPORT(char *) ap_escape_html(apr_pool_t *p, const char *s);
+API_EXPORT(char *) ap_construct_server(apr_pool_t *p, const char *hostname,
 				    unsigned port, const request_rec *r);
-API_EXPORT(char *) ap_escape_shell_cmd(ap_pool_t *p, const char *s);
+API_EXPORT(char *) ap_escape_shell_cmd(apr_pool_t *p, const char *s);
 
 API_EXPORT(int) ap_count_dirs(const char *path);
 API_EXPORT(char *) ap_make_dirstr_prefix(char *d, const char *s, int n);
-API_EXPORT(char *) ap_make_dirstr_parent(ap_pool_t *p, const char *s);
+API_EXPORT(char *) ap_make_dirstr_parent(apr_pool_t *p, const char *s);
 /* deprecated.  The previous two routines are preferred. */
-API_EXPORT(char *) ap_make_dirstr(ap_pool_t *a, const char *s, int n);
-API_EXPORT(char *) ap_make_full_path(ap_pool_t *a, const char *dir, const char *f);
+API_EXPORT(char *) ap_make_dirstr(apr_pool_t *a, const char *s, int n);
+API_EXPORT(char *) ap_make_full_path(apr_pool_t *a, const char *dir, const char *f);
 
 API_EXPORT(int) ap_is_matchexp(const char *str);
 API_EXPORT(int) ap_strcmp_match(const char *str, const char *exp);
 API_EXPORT(int) ap_strcasecmp_match(const char *str, const char *exp);
 API_EXPORT(char *) ap_strcasestr(const char *s1, const char *s2);
-API_EXPORT(char *) ap_pbase64decode(ap_pool_t *p, const char *bufcoded);
-API_EXPORT(char *) ap_pbase64encode(ap_pool_t *p, char *string); 
-API_EXPORT(char *) ap_uudecode(ap_pool_t *p, const char *bufcoded);
-API_EXPORT(char *) ap_uuencode(ap_pool_t *p, char *string); 
+API_EXPORT(char *) ap_pbase64decode(apr_pool_t *p, const char *bufcoded);
+API_EXPORT(char *) ap_pbase64encode(apr_pool_t *p, char *string); 
+API_EXPORT(char *) ap_uudecode(apr_pool_t *p, const char *bufcoded);
+API_EXPORT(char *) ap_uuencode(apr_pool_t *p, char *string); 
 
 #include "pcreposix.h"
 
-API_EXPORT(regex_t *) ap_pregcomp(ap_pool_t *p, const char *pattern,
+API_EXPORT(regex_t *) ap_pregcomp(apr_pool_t *p, const char *pattern,
 				   int cflags);
-API_EXPORT(void) ap_pregfree(ap_pool_t *p, regex_t *reg);
+API_EXPORT(void) ap_pregfree(apr_pool_t *p, regex_t *reg);
 API_EXPORT(int)    ap_regexec(regex_t *preg, const char *string,
                               size_t nmatch, regmatch_t pmatch[], int eflags);
 API_EXPORT(size_t) ap_regerror(int errcode, const regex_t *preg, 
                                char *errbuf, size_t errbuf_size);
-API_EXPORT(char *) ap_pregsub(ap_pool_t *p, const char *input, const char *source,
+API_EXPORT(char *) ap_pregsub(apr_pool_t *p, const char *input, const char *source,
                               size_t nmatch, regmatch_t pmatch[]);
 
 API_EXPORT(void) ap_content_type_tolower(char *);
@@ -964,7 +964,7 @@ API_EXPORT(void) ap_str_tolower(char *);
 API_EXPORT(int) ap_ind(const char *, char);	/* Sigh... */
 API_EXPORT(int) ap_rind(const char *, char);
 
-API_EXPORT(char *) ap_escape_quotes (ap_pool_t *p, const char *instring);
+API_EXPORT(char *) ap_escape_quotes (apr_pool_t *p, const char *instring);
 
 /* Misc system hackery */
 
@@ -975,14 +975,14 @@ API_EXPORT(void) ap_chdir_file(const char *file);
 API_EXPORT(int) ap_get_max_daemons(void);
 
 #ifdef _OSD_POSIX
-extern const char *os_set_account(ap_pool_t *p, const char *account);
+extern const char *os_set_account(apr_pool_t *p, const char *account);
 extern int os_init_job_environment(server_rec *s, const char *user_name, int one_process);
 #endif /* _OSD_POSIX */
 
-char *ap_get_local_host(ap_pool_t *);
+char *ap_get_local_host(apr_pool_t *);
 unsigned long ap_get_virthost_addr(char *hostname, unsigned short *port);
 
-API_EXPORT(char *) ap_escape_quotes(ap_pool_t *p, const char *instr);
+API_EXPORT(char *) ap_escape_quotes(apr_pool_t *p, const char *instr);
 
 /*
  * Redefine assert() to something more useful for an Apache...
diff --git a/include/mpm_common.h b/include/mpm_common.h
index 3a7131e..af66bb4 100644
--- a/include/mpm_common.h
+++ b/include/mpm_common.h
@@ -79,8 +79,8 @@ extern "C" {
 #endif
         
 void ap_reclaim_child_processes(int terminate);
-void ap_wait_or_timeout(ap_wait_t *status, ap_proc_t *ret, ap_pool_t *p);
-void ap_process_child_status(ap_proc_t *pid, ap_wait_t status);
+void ap_wait_or_timeout(ap_wait_t *status, apr_proc_t *ret, apr_pool_t *p);
+void ap_process_child_status(apr_proc_t *pid, ap_wait_t status);
 #if defined(TCP_NODELAY) && !defined(MPE) && !defined(TPF)
 void ap_sock_disable_nagle(int s);
 #else
diff --git a/include/mpm_status.h b/include/mpm_status.h
index 901fe9e..e02961a 100644
--- a/include/mpm_status.h
+++ b/include/mpm_status.h
@@ -64,7 +64,7 @@
 
 typedef struct {
     long conn_id;
-    ap_table_t *data;
+    apr_table_t *data;
 } ap_status_table_row_t;
 
 /**
@@ -81,7 +81,7 @@ API_EXPORT(const char *) ap_get_connection_status(long conn_id, const char *key)
  * Get an array of current connection IDs.
  *
  */
-API_EXPORT(ap_array_header_t *) ap_get_connections(ap_pool_t *p);
+API_EXPORT(apr_array_header_t *) ap_get_connections(apr_pool_t *p);
 
 /**
  * Get an array of keys from a given connection.
@@ -89,7 +89,7 @@ API_EXPORT(ap_array_header_t *) ap_get_connections(ap_pool_t *p);
  * conn_id = Connection ID
  *
  */
-API_EXPORT(ap_array_header_t *) ap_get_connection_keys(ap_pool_t *p,
+API_EXPORT(apr_array_header_t *) ap_get_connection_keys(apr_pool_t *p,
                                                        long conn_id);
 
 /**
@@ -122,7 +122,7 @@ API_EXPORT(void) ap_reset_connection_status(long conn_id);
  * p = context, generally of the request
  *
  */
-API_EXPORT(ap_array_header_t *) ap_get_status_table(ap_pool_t *p);
+API_EXPORT(apr_array_header_t *) ap_get_status_table(apr_pool_t *p);
 
 #endif /* APACHE_SERVER_STATS_H */
 
diff --git a/include/util_charset.h b/include/util_charset.h
index 663ea66..aae24b0 100644
--- a/include/util_charset.h
+++ b/include/util_charset.h
@@ -67,8 +67,8 @@ extern "C" {
 
 #include "apr_xlate.h"
 
-extern ap_xlate_t *ap_hdrs_to_ascii, *ap_hdrs_from_ascii;
-extern ap_xlate_t *ap_locale_to_ascii, *ap_locale_from_ascii;
+extern apr_xlate_t *ap_hdrs_to_ascii, *ap_hdrs_from_ascii;
+extern apr_xlate_t *ap_locale_to_ascii, *ap_locale_from_ascii;
 
 /* Save & Restore the current conversion settings
  *
@@ -85,7 +85,7 @@ extern ap_xlate_t *ap_locale_to_ascii, *ap_locale_from_ascii;
  */
 
 #define AP_PUSH_INPUTCONVERSION_STATE(_buff, _newx) \
-        ap_xlate_t *saved_input_xlate; \
+        apr_xlate_t *saved_input_xlate; \
         ap_bgetopt(_buff, BO_RXLATE, &saved_input_xlate); \
         ap_bsetopt(_buff, BO_RXLATE, &(_newx))
 
@@ -93,7 +93,7 @@ extern ap_xlate_t *ap_locale_to_ascii, *ap_locale_from_ascii;
         ap_bsetopt(_buff, BO_RXLATE, &saved_input_xlate)
 
 #define AP_PUSH_OUTPUTCONVERSION_STATE(_buff, _newx) \
-        ap_xlate_t *saved_output_xlate; \
+        apr_xlate_t *saved_output_xlate; \
         ap_bgetopt(_buff, BO_WXLATE, &saved_output_xlate); \
         ap_bsetopt(_buff, BO_WXLATE, &(_newx))
 
@@ -103,8 +103,8 @@ extern ap_xlate_t *ap_locale_to_ascii, *ap_locale_from_ascii;
 /* ap_set_content_xlate() is called by Apache core or a module to set
  * up character set translation (a.k.a. recoding) for content.
  */
-API_EXPORT(ap_status_t) ap_set_content_xlate(request_rec *r, int output,
-                                             ap_xlate_t *xlate);
+API_EXPORT(apr_status_t) ap_set_content_xlate(request_rec *r, int output,
+                                             apr_xlate_t *xlate);
 
 #ifdef __cplusplus
 }
diff --git a/include/util_date.h b/include/util_date.h
index 4669695..39bd0a3 100644
--- a/include/util_date.h
+++ b/include/util_date.h
@@ -69,10 +69,10 @@ extern "C" {
 
 #include "apr_time.h"
 
-#define BAD_DATE (ap_time_t)0
+#define BAD_DATE (apr_time_t)0
 
 API_EXPORT(int) ap_checkmask(const char *data, const char *mask);
-API_EXPORT(ap_time_t) ap_parseHTTPdate(const char *date);
+API_EXPORT(apr_time_t) ap_parseHTTPdate(const char *date);
 
 #ifdef __cplusplus
 }
diff --git a/include/util_ebcdic.h b/include/util_ebcdic.h
index 747da4e..71589c5 100644
--- a/include/util_ebcdic.h
+++ b/include/util_ebcdic.h
@@ -68,9 +68,9 @@ extern "C" {
 #include "apr_xlate.h"
 #include "util_charset.h"
 
-ap_status_t ap_init_ebcdic(ap_pool_t *);
+apr_status_t ap_init_ebcdic(apr_pool_t *);
 
-ap_xlate_t *ap_checkconv(struct request_rec *);
+apr_xlate_t *ap_checkconv(struct request_rec *);
 
 #ifdef __cplusplus
 }
diff --git a/include/util_filter.h b/include/util_filter.h
index f2f564a..1c523ab 100644
--- a/include/util_filter.h
+++ b/include/util_filter.h
@@ -92,10 +92,10 @@ extern "C" {
  */
 
 /* forward declare the filter type */
-typedef struct ap_filter_t ap_filter_t;
+typedef struct apr_filter_t apr_filter_t;
 
 /*
- * ap_filter_func:
+ * apr_filter_func:
  *
  * This function type is used for filter callbacks. It will be passed a
  * pointer to "this" filter, and a "bucket" containing the content to be
@@ -114,7 +114,7 @@ typedef struct ap_filter_t ap_filter_t;
  * next/prev to insert/remove/replace elements in the bucket list, but
  * the types and values of the individual buckets should not be altered.
  */
-typedef ap_status_t (*ap_filter_func)();
+typedef apr_status_t (*apr_filter_func)();
 
 /*
  * ap_filter_type:
@@ -146,7 +146,7 @@ typedef enum {
 } ap_filter_type;
 
 /*
- * ap_filter_t:
+ * apr_filter_t:
  *
  * This is the request-time context structure for an installed filter (in
  * the output filter chain). It provides the callback to use for filtering,
@@ -159,13 +159,13 @@ typedef enum {
  * the state directly with the request. A callback should not change any of
  * the other fields.
  */
-struct ap_filter_t {
-    ap_filter_func filter_func;
+struct apr_filter_t {
+    apr_filter_func filter_func;
 
     void *ctx;
 
     ap_filter_type ftype;
-    ap_filter_t *next;
+    apr_filter_t *next;
 };
 
 /*
@@ -178,7 +178,7 @@ struct ap_filter_t {
  * The filter's callback and type should be passed.
  */
 API_EXPORT(void) ap_register_filter(const char *name,
-                                    ap_filter_func filter_func,
+                                    apr_filter_func filter_func,
                                     ap_filter_type ftype);
 
 /*
@@ -198,9 +198,9 @@ API_EXPORT(void) ap_add_filter(const char *name, void *ctx, request_rec *r);
 
 /*
  * Things to do later:
- * Add parameters to ap_filter_func type.  Those parameters will be something
+ * Add parameters to apr_filter_func type.  Those parameters will be something
  *     like:
- *         (request_rec *r, ap_filter_t *filter, ap_data_list *the_data)
+ *         (request_rec *r, apr_filter_t *filter, ap_data_list *the_data)
  *      obviously, the request_rec is the current request, and the filter
  *      is the current filter stack.  The data_list is a bucket list or
  *      bucket_brigade, but I am trying to keep this patch neutral.  (If this
diff --git a/include/util_md5.h b/include/util_md5.h
index e185e35..7d2896d 100644
--- a/include/util_md5.h
+++ b/include/util_md5.h
@@ -65,14 +65,14 @@ extern "C" {
 
 #include "apr_md5.h"
 
-API_EXPORT(char *) ap_md5(ap_pool_t *a, const unsigned char *string);
-API_EXPORT(char *) ap_md5_binary(ap_pool_t *a, const unsigned char *buf, int len);
-API_EXPORT(char *) ap_md5contextTo64(ap_pool_t *p, ap_md5_ctx_t *context);
+API_EXPORT(char *) ap_md5(apr_pool_t *a, const unsigned char *string);
+API_EXPORT(char *) ap_md5_binary(apr_pool_t *a, const unsigned char *buf, int len);
+API_EXPORT(char *) ap_md5contextTo64(apr_pool_t *p, ap_md5_ctx_t *context);
 #ifdef APACHE_XLATE
-API_EXPORT(char *) ap_md5digest(ap_pool_t *p, ap_file_t *infile,
-                                ap_xlate_t *xlate);
+API_EXPORT(char *) ap_md5digest(apr_pool_t *p, apr_file_t *infile,
+                                apr_xlate_t *xlate);
 #else
-API_EXPORT(char *) ap_md5digest(ap_pool_t *p, ap_file_t *infile);
+API_EXPORT(char *) ap_md5digest(apr_pool_t *p, apr_file_t *infile);
 #endif
 
 #ifdef __cplusplus
diff --git a/include/util_script.h b/include/util_script.h
index b723fe3..2f24a55 100644
--- a/include/util_script.h
+++ b/include/util_script.h
@@ -71,17 +71,17 @@ extern "C" {
 #endif
 #endif
 
-API_EXPORT(char **) ap_create_environment(ap_pool_t *p, ap_table_t *t);
+API_EXPORT(char **) ap_create_environment(apr_pool_t *p, apr_table_t *t);
 API_EXPORT(int) ap_find_path_info(const char *uri, const char *path_info);
 API_EXPORT(void) ap_add_cgi_vars(request_rec *r);
 API_EXPORT(void) ap_add_common_vars(request_rec *r);
-API_EXPORT(int) ap_scan_script_header_err(request_rec *r, ap_file_t *f, char *buffer);
+API_EXPORT(int) ap_scan_script_header_err(request_rec *r, apr_file_t *f, char *buffer);
 API_EXPORT(int) ap_scan_script_header_err_buff(request_rec *r, BUFF *f,
                                                char *buffer);
 API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
 				       int (*getsfunc) (char *, int, void *),
 				       void *getsfunc_data);
-API_EXPORT(void) ap_send_size(ap_ssize_t size, request_rec *r);
+API_EXPORT(void) ap_send_size(apr_ssize_t size, request_rec *r);
 
 #ifdef __cplusplus
 }
diff --git a/include/util_uri.h b/include/util_uri.h
index 86e1097..bf1c63f 100644
--- a/include/util_uri.h
+++ b/include/util_uri.h
@@ -114,12 +114,12 @@ typedef struct {
 /* util_uri.c */
 API_EXPORT(unsigned short) ap_default_port_for_scheme(const char *scheme_str);
 API_EXPORT(unsigned short) ap_default_port_for_request(const request_rec *r);
-API_EXPORT(struct hostent *) ap_pduphostent(ap_pool_t *p, const struct hostent *hp);
-API_EXPORT(struct hostent *) ap_pgethostbyname(ap_pool_t *p, const char *hostname);
-API_EXPORT(char *) ap_unparse_uri_components(ap_pool_t *p, const uri_components *uptr,
+API_EXPORT(struct hostent *) ap_pduphostent(apr_pool_t *p, const struct hostent *hp);
+API_EXPORT(struct hostent *) ap_pgethostbyname(apr_pool_t *p, const char *hostname);
+API_EXPORT(char *) ap_unparse_uri_components(apr_pool_t *p, const uri_components *uptr,
     unsigned flags);
-API_EXPORT(int) ap_parse_uri_components(ap_pool_t *p, const char *uri, uri_components *uptr);
-API_EXPORT(int) ap_parse_hostinfo_components(ap_pool_t *p, const char *hostinfo, uri_components *uptr);
+API_EXPORT(int) ap_parse_uri_components(apr_pool_t *p, const char *uri, uri_components *uptr);
+API_EXPORT(int) ap_parse_hostinfo_components(apr_pool_t *p, const char *hostinfo, uri_components *uptr);
 /* called by the core in main() */
 API_EXPORT(void) ap_util_uri_init(void);
 
diff --git a/include/util_xml.h b/include/util_xml.h
index f7e45d4..7d30236 100644
--- a/include/util_xml.h
+++ b/include/util_xml.h
@@ -80,7 +80,7 @@ typedef struct
     ap_text *last;
 } ap_text_header;
 
-API_EXPORT(void) ap_text_append(ap_pool_t *p, ap_text_header *hdr,
+API_EXPORT(void) ap_text_append(apr_pool_t *p, ap_text_header *hdr,
                                 const char *text);
 
 
@@ -186,15 +186,15 @@ typedef struct ap_xml_elem
 typedef struct ap_xml_doc
 {
     ap_xml_elem *root;		/* root element */
-    ap_array_header_t *namespaces;	/* array of namespaces used */
+    apr_array_header_t *namespaces;	/* array of namespaces used */
 } ap_xml_doc;
 
 API_EXPORT(int) ap_xml_parse_input(request_rec *r, ap_xml_doc **pdoc);
 
 
 /* Converts an XML element tree to flat text */
-API_EXPORT(void) ap_xml_to_text(ap_pool_t *p, const ap_xml_elem *elem,
-				int style, ap_array_header_t *namespaces,
+API_EXPORT(void) ap_xml_to_text(apr_pool_t *p, const ap_xml_elem *elem,
+				int style, apr_array_header_t *namespaces,
 				int *ns_map, const char **pbuf, size_t *psize);
 
 /* style argument values: */
@@ -203,17 +203,17 @@ API_EXPORT(void) ap_xml_to_text(ap_pool_t *p, const ap_xml_elem *elem,
 #define AP_XML_X2T_LANG_INNER	2	/* xml:lang + inner contents */
 #define AP_XML_X2T_FULL_NS_LANG	3	/* FULL + ns defns + xml:lang */
 
-API_EXPORT(const char *) ap_xml_empty_elem(ap_pool_t *p,
+API_EXPORT(const char *) ap_xml_empty_elem(apr_pool_t *p,
                                            const ap_xml_elem *elem);
 
-API_EXPORT(const char *) ap_xml_quote_string(ap_pool_t *p, const char *s,
+API_EXPORT(const char *) ap_xml_quote_string(apr_pool_t *p, const char *s,
                                              int quotes);
-API_EXPORT(void) ap_xml_quote_elem(ap_pool_t *p, ap_xml_elem *elem);
+API_EXPORT(void) ap_xml_quote_elem(apr_pool_t *p, ap_xml_elem *elem);
 
 /* manage an array of unique URIs: ap_xml_insert_uri() and AP_XML_URI_ITEM() */
 
 /* return the URI's (existing) index, or insert it and return a new index */
-API_EXPORT(int) ap_xml_insert_uri(ap_array_header_t *uri_array,
+API_EXPORT(int) ap_xml_insert_uri(apr_array_header_t *uri_array,
                                   const char *uri);
 #define AP_XML_GET_URI_ITEM(ary, i)    (((const char * const *)(ary)->elts)[i])
 
diff --git a/modules/aaa/mod_access.c b/modules/aaa/mod_access.c
index 592d926..c299b4f 100644
--- a/modules/aaa/mod_access.c
+++ b/modules/aaa/mod_access.c
@@ -113,22 +113,22 @@ typedef struct {
 
 typedef struct {
     int order[METHODS];
-    ap_array_header_t *allows;
-    ap_array_header_t *denys;
+    apr_array_header_t *allows;
+    apr_array_header_t *denys;
 } access_dir_conf;
 
 module MODULE_VAR_EXPORT access_module;
 
-static void *create_access_dir_config(ap_pool_t *p, char *dummy)
+static void *create_access_dir_config(apr_pool_t *p, char *dummy)
 {
     access_dir_conf *conf =
-    (access_dir_conf *) ap_pcalloc(p, sizeof(access_dir_conf));
+    (access_dir_conf *) apr_pcalloc(p, sizeof(access_dir_conf));
     int i;
 
     for (i = 0; i < METHODS; ++i)
 	conf->order[i] = DENY_THEN_ALLOW;
-    conf->allows = ap_make_array(p, 1, sizeof(allowdeny));
-    conf->denys = ap_make_array(p, 1, sizeof(allowdeny));
+    conf->allows = apr_make_array(p, 1, sizeof(allowdeny));
+    conf->denys = apr_make_array(p, 1, sizeof(allowdeny));
 
     return (void *) conf;
 }
@@ -167,12 +167,12 @@ static const char *allow_cmd(cmd_parms *cmd, void *dv, const char *from,
     access_dir_conf *d = (access_dir_conf *) dv;
     allowdeny *a;
     char *s;
-    char *where = ap_pstrdup(cmd->pool, where_c);
+    char *where = apr_pstrdup(cmd->pool, where_c);
 
     if (strcasecmp(from, "from"))
 	return "allow and deny must be followed by 'from'";
 
-    a = (allowdeny *) ap_push_array(cmd->info ? d->allows : d->denys);
+    a = (allowdeny *) apr_push_array(cmd->info ? d->allows : d->denys);
     a->x.from = where;
     a->limited = cmd->limited;
 
@@ -311,7 +311,7 @@ static int in_domain(const char *domain, const char *what)
 	return 0;
 }
 
-static int find_allowdeny(request_rec *r, ap_array_header_t *a, int method)
+static int find_allowdeny(request_rec *r, apr_array_header_t *a, int method)
 {
     allowdeny *ap = (allowdeny *) a->elts;
     int mmask = (1 << method);
@@ -325,7 +325,7 @@ static int find_allowdeny(request_rec *r, ap_array_header_t *a, int method)
 
 	switch (ap[i].type) {
 	case T_ENV:
-	    if (ap_table_get(r->subprocess_env, ap[i].x.from)) {
+	    if (apr_table_get(r->subprocess_env, ap[i].x.from)) {
 		return 1;
 	    }
 	    break;
diff --git a/modules/aaa/mod_auth.c b/modules/aaa/mod_auth.c
index e09ea87..e2e84ab 100644
--- a/modules/aaa/mod_auth.c
+++ b/modules/aaa/mod_auth.c
@@ -86,10 +86,10 @@ typedef struct auth_config_struct {
     int auth_authoritative;
 } auth_config_rec;
 
-static void *create_auth_dir_config(ap_pool_t *p, char *d)
+static void *create_auth_dir_config(apr_pool_t *p, char *d)
 {
     auth_config_rec *sec =
-    (auth_config_rec *) ap_pcalloc(p, sizeof(auth_config_rec));
+    (auth_config_rec *) apr_pcalloc(p, sizeof(auth_config_rec));
     sec->auth_pwfile = NULL;	/* just to illustrate the default really */
     sec->auth_grpfile = NULL;	/* unless you have a broken HP cc */
     sec->auth_authoritative = 1;	/* keep the fortress secure by default */
@@ -100,7 +100,7 @@ static const char *set_auth_slot(cmd_parms *cmd, void *offset, const char *f,
                                  const char *t)
 {
     if (t && strcmp(t, "standard"))
-	return ap_pstrcat(cmd->pool, "Invalid auth file type: ", t, NULL);
+	return apr_pstrcat(cmd->pool, "Invalid auth file type: ", t, NULL);
 
     return ap_set_file_slot(cmd, offset, f);
 }
@@ -128,7 +128,7 @@ static char *get_pw(request_rec *r, char *user, char *auth_pwfile)
     configfile_t *f;
     char l[MAX_STRING_LEN];
     const char *rpw, *w;
-    ap_status_t status;
+    apr_status_t status;
 
     if ((status = ap_pcfg_openfile(&f, r->pool, auth_pwfile)) != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
@@ -150,14 +150,14 @@ static char *get_pw(request_rec *r, char *user, char *auth_pwfile)
     return NULL;
 }
 
-static ap_table_t *groups_for_user(ap_pool_t *p, char *user, char *grpfile)
+static apr_table_t *groups_for_user(apr_pool_t *p, char *user, char *grpfile)
 {
     configfile_t *f;
-    ap_table_t *grps = ap_make_table(p, 15);
-    ap_pool_t *sp;
+    apr_table_t *grps = apr_make_table(p, 15);
+    apr_pool_t *sp;
     char l[MAX_STRING_LEN];
     const char *group_name, *ll, *w;
-    ap_status_t status;
+    apr_status_t status;
 
     if ((status = ap_pcfg_openfile(&f, p, grpfile)) != APR_SUCCESS) {
 /*add?	aplog_error(APLOG_MARK, APLOG_ERR, NULL,
@@ -165,26 +165,26 @@ static ap_table_t *groups_for_user(ap_pool_t *p, char *user, char *grpfile)
 	return NULL;
     }
 
-    ap_create_pool(&sp, p);
+    apr_create_pool(&sp, p);
 
     while (!(ap_cfg_getline(l, MAX_STRING_LEN, f))) {
 	if ((l[0] == '#') || (!l[0]))
 	    continue;
 	ll = l;
-	ap_clear_pool(sp);
+	apr_clear_pool(sp);
 
 	group_name = ap_getword(sp, &ll, ':');
 
 	while (ll[0]) {
 	    w = ap_getword_conf(sp, &ll);
 	    if (!strcmp(w, user)) {
-		ap_table_setn(grps, ap_pstrdup(p, group_name), "in");
+		apr_table_setn(grps, apr_pstrdup(p, group_name), "in");
 		break;
 	    }
 	}
     }
     ap_cfg_closefile(f);
-    ap_destroy_pool(sp);
+    apr_destroy_pool(sp);
     return grps;
 }
 
@@ -208,7 +208,7 @@ static int authenticate_basic_user(request_rec *r)
     (auth_config_rec *) ap_get_module_config(r->per_dir_config, &auth_module);
     const char *sent_pw;
     char *real_pw;
-    ap_status_t invalid_pw;
+    apr_status_t invalid_pw;
     int res;
 
     if ((res = ap_get_basic_auth_pw(r, &sent_pw)))
@@ -225,7 +225,7 @@ static int authenticate_basic_user(request_rec *r)
 	ap_note_basic_auth_failure(r);
 	return HTTP_UNAUTHORIZED;
     }
-    invalid_pw = ap_validate_password(sent_pw, real_pw);
+    invalid_pw = apr_validate_password(sent_pw, real_pw);
     if (invalid_pw != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		      "user %s: authentication failure for \"%s\": "
@@ -248,8 +248,8 @@ static int check_user_access(request_rec *r)
     int method_restricted = 0;
     register int x;
     const char *t, *w;
-    ap_table_t *grpstatus;
-    const ap_array_header_t *reqs_arr = ap_requires(r);
+    apr_table_t *grpstatus;
+    const apr_array_header_t *reqs_arr = ap_requires(r);
     require_line *reqs;
 
     /* BUG FIX: tadc, 11-Nov-1995.  If there is no "requires" directive, 
@@ -288,7 +288,7 @@ static int check_user_access(request_rec *r)
 
 	    while (t[0]) {
 		w = ap_getword_conf(r->pool, &t);
-		if (ap_table_get(grpstatus, w))
+		if (apr_table_get(grpstatus, w))
 		    return OK;
 	    }
 	} else if (sec->auth_authoritative) {
@@ -331,7 +331,7 @@ module MODULE_VAR_EXPORT auth_module =
     NULL,			/* dir merger --- default is to override */
     NULL,			/* server config */
     NULL,			/* merge server config */
-    auth_cmds,			/* command ap_table_t */
+    auth_cmds,			/* command apr_table_t */
     NULL,			/* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/aaa/mod_auth_anon.c b/modules/aaa/mod_auth_anon.c
index a0397ad..22af526 100644
--- a/modules/aaa/mod_auth_anon.c
+++ b/modules/aaa/mod_auth_anon.c
@@ -117,10 +117,10 @@ typedef struct {
 
 } anon_auth_config_rec;
 
-static void *create_anon_auth_dir_config(ap_pool_t *p, char *d)
+static void *create_anon_auth_dir_config(apr_pool_t *p, char *d)
 {
     anon_auth_config_rec *sec = (anon_auth_config_rec *)
-    ap_pcalloc(p, sizeof(anon_auth_config_rec));
+    apr_pcalloc(p, sizeof(anon_auth_config_rec));
 
     if (!sec)
 	return NULL;		/* no memory... */
@@ -181,7 +181,7 @@ static const char *anon_set_string_slots(cmd_parms *cmd,
     first = sec->auth_anon_passwords;
 
     if (
-	   (!(sec->auth_anon_passwords = (auth_anon *) ap_palloc(cmd->pool, sizeof(auth_anon)))) ||
+	   (!(sec->auth_anon_passwords = (auth_anon *) apr_palloc(cmd->pool, sizeof(auth_anon)))) ||
            (!(sec->auth_anon_passwords->password = arg))
     )
 	     return "Failed to claim memory for an anonymous password...";
@@ -302,7 +302,7 @@ module MODULE_VAR_EXPORT auth_anon_module =
     NULL,			/* dir merger ensure strictness */
     NULL,			/* server config */
     NULL,			/* merge server config */
-    anon_auth_cmds,		/* command ap_table_t */
+    anon_auth_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/aaa/mod_auth_db.c b/modules/aaa/mod_auth_db.c
index d8ff16a..1b2f71c 100644
--- a/modules/aaa/mod_auth_db.c
+++ b/modules/aaa/mod_auth_db.c
@@ -119,10 +119,10 @@ typedef struct {
     int auth_dbauthoritative;
 } db_auth_config_rec;
 
-static void *create_db_auth_dir_config(ap_pool_t *p, char *d)
+static void *create_db_auth_dir_config(apr_pool_t *p, char *d)
 {
     db_auth_config_rec *sec
-    = (db_auth_config_rec *) ap_pcalloc(p, sizeof(db_auth_config_rec));
+    = (db_auth_config_rec *) apr_pcalloc(p, sizeof(db_auth_config_rec));
     sec->auth_dbpwfile = NULL;
     sec->auth_dbgrpfile = NULL;
     sec->auth_dbauthoritative = 1;	/* fortress is secure by default */
@@ -242,7 +242,7 @@ static char *get_db_pw(request_rec *r, char *user, const char *auth_dbpwfile)
 #else
     if (!((f->get) (f, &q, &d, 0))) {
 #endif
-	pw = ap_palloc(r->pool, d.size + 1);
+	pw = apr_palloc(r->pool, d.size + 1);
 	strncpy(pw, d.data, d.size);
 	pw[d.size] = '\0';	/* Terminate the string */
     }
@@ -291,7 +291,7 @@ static int db_authenticate_basic_user(request_rec *r)
 						&auth_db_module);
     const char *sent_pw;
     char *real_pw, *colon_pw;
-    ap_status_t invalid_pw;
+    apr_status_t invalid_pw;
     int res;
 
     if ((res = ap_get_basic_auth_pw(r, &sent_pw)))
@@ -317,7 +317,7 @@ static int db_authenticate_basic_user(request_rec *r)
 	*colon_pw = '\0';
     }
 
-    invalid_pw = ap_validate_password(sent_pw, real_pw);
+    invalid_pw = apr_validate_password(sent_pw, real_pw);
 
     if (invalid_pw != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
@@ -340,7 +340,7 @@ static int db_check_auth(request_rec *r)
     char *user = r->user;
     int m = r->method_number;
 
-    const ap_array_header_t *reqs_arr = ap_requires(r);
+    const apr_array_header_t *reqs_arr = ap_requires(r);
     require_line *reqs = reqs_arr ? (require_line *) reqs_arr->elts : NULL;
 
     register int x;
@@ -406,7 +406,7 @@ module auth_db_module =
     NULL,			/* dir merger --- default is to override */
     NULL,			/* server config */
     NULL,			/* merge server config */
-    db_auth_cmds,		/* command ap_table_t */
+    db_auth_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/aaa/mod_auth_dbm.c b/modules/aaa/mod_auth_dbm.c
index 215bde7..253b7e3 100644
--- a/modules/aaa/mod_auth_dbm.c
+++ b/modules/aaa/mod_auth_dbm.c
@@ -105,10 +105,10 @@ typedef struct {
 
 } dbm_auth_config_rec;
 
-static void *create_dbm_auth_dir_config(ap_pool_t *p, char *d)
+static void *create_dbm_auth_dir_config(apr_pool_t *p, char *d)
 {
     dbm_auth_config_rec *sec
-    = (dbm_auth_config_rec *) ap_pcalloc(p, sizeof(dbm_auth_config_rec));
+    = (dbm_auth_config_rec *) apr_pcalloc(p, sizeof(dbm_auth_config_rec));
 
     sec->auth_dbmpwfile = NULL;
     sec->auth_dbmgrpfile = NULL;
@@ -170,7 +170,7 @@ static char *get_dbm_pw(request_rec *r, char *user, char *auth_dbmpwfile)
     d = dbm_fetch(f, q);
 
     if (d.dptr) {
-	pw = ap_palloc(r->pool, d.dsize + 1);
+	pw = apr_palloc(r->pool, d.dsize + 1);
 	strncpy(pw, d.dptr, d.dsize);
 	pw[d.dsize] = '\0';	/* Terminate the string */
     }
@@ -215,7 +215,7 @@ static int dbm_authenticate_basic_user(request_rec *r)
 					      &auth_dbm_module);
     const char *sent_pw;
     char *real_pw, *colon_pw;
-    ap_status_t invalid_pw;
+    apr_status_t invalid_pw;
     int res;
 
     if ((res = ap_get_basic_auth_pw(r, &sent_pw)))
@@ -237,7 +237,7 @@ static int dbm_authenticate_basic_user(request_rec *r)
     if (colon_pw) {
 	*colon_pw = '\0';
     }
-    invalid_pw = ap_validate_password(sent_pw, real_pw);
+    invalid_pw = apr_validate_password(sent_pw, real_pw);
     if (invalid_pw != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		      "DBM user %s: authentication failure for \"%s\": "
@@ -259,7 +259,7 @@ static int dbm_check_auth(request_rec *r)
     char *user = r->user;
     int m = r->method_number;
 
-    const ap_array_header_t *reqs_arr = ap_requires(r);
+    const apr_array_header_t *reqs_arr = ap_requires(r);
     require_line *reqs = reqs_arr ? (require_line *) reqs_arr->elts : NULL;
 
     register int x;
@@ -326,7 +326,7 @@ module auth_dbm_module =
     NULL,			/* dir merger --- default is to override */
     NULL,			/* server config */
     NULL,			/* merge server config */
-    dbm_auth_cmds,		/* command ap_table_t */
+    dbm_auth_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     register_hooks              /* register hooks */
 };
diff --git a/modules/aaa/mod_auth_digest.c b/modules/aaa/mod_auth_digest.c
index ca7d310..f261ec9 100644
--- a/modules/aaa/mod_auth_digest.c
+++ b/modules/aaa/mod_auth_digest.c
@@ -121,34 +121,34 @@
 #include "apr_shmem.h"
 #else
 /* just provide dummies - the code does run-time checks anyway */
-typedef   void ap_shmem_t;
-typedef   void ap_shm_name_t;
+typedef   void apr_shmem_t;
+typedef   void apr_shm_name_t;
 
-ap_status_t ap_shm_init(ap_shmem_t **m, ap_size_t reqsize, const char *file, ap_pool_t *cont) {
+apr_status_t apr_shm_init(apr_shmem_t **m, apr_size_t reqsize, const char *file, apr_pool_t *cont) {
     return APR_ENOTIMPL;
 }
-ap_status_t ap_shm_destroy(ap_shmem_t *m) {
+apr_status_t apr_shm_destroy(apr_shmem_t *m) {
     return APR_ENOTIMPL;
 }
-void *ap_shm_malloc(ap_shmem_t *c, ap_size_t reqsize) {
+void *apr_shm_malloc(apr_shmem_t *c, apr_size_t reqsize) {
     return NULL;
 }
-void *ap_shm_calloc(ap_shmem_t *shared, ap_size_t size) {
+void *apr_shm_calloc(apr_shmem_t *shared, apr_size_t size) {
     return NULL;
 }
-ap_status_t ap_shm_free(ap_shmem_t *shared, void *free) {
+apr_status_t apr_shm_free(apr_shmem_t *shared, void *free) {
     return APR_ENOTIMPL;
 }
-ap_status_t ap_get_shm_name(ap_shmem_t *c, ap_shm_name_t **name) {
+apr_status_t apr_get_shm_name(apr_shmem_t *c, apr_shm_name_t **name) {
     return APR_ENOTIMPL;
 }
-ap_status_t ap_set_shm_name(ap_shmem_t *c, ap_shm_name_t *name) {
+apr_status_t apr_set_shm_name(apr_shmem_t *c, apr_shm_name_t *name) {
     return APR_ENOTIMPL;
 }
-ap_status_t ap_open_shmem(ap_shmem_t *c) {
+apr_status_t apr_open_shmem(apr_shmem_t *c) {
     return APR_ENOTIMPL;
 }
-ap_status_t ap_shm_avail(ap_shmem_t *c, ap_size_t *avail) {
+apr_status_t apr_shm_avail(apr_shmem_t *c, apr_size_t *avail) {
     return APR_ENOTIMPL;
 }
 #endif
@@ -163,7 +163,7 @@ typedef struct digest_config_struct {
     const char  *realm;
     const char **qop_list;
     AP_SHA1_CTX  nonce_ctx;
-    ap_time_t    nonce_lifetime;
+    apr_time_t    nonce_lifetime;
     const char  *nonce_format;
     int          check_nc;
     const char  *algorithm;
@@ -178,7 +178,7 @@ typedef struct digest_config_struct {
 #define NEXTNONCE_DELTA	(30*AP_USEC_PER_SEC)
 
 
-#define NONCE_TIME_LEN	(((sizeof(ap_time_t)+2)/3)*4)
+#define NONCE_TIME_LEN	(((sizeof(apr_time_t)+2)/3)*4)
 #define NONCE_HASH_LEN	(2*SHA_DIGESTSIZE)
 #define NONCE_LEN	(NONCE_TIME_LEN + NONCE_HASH_LEN)
 
@@ -223,7 +223,7 @@ typedef struct digest_header_struct {
     const char           *message_qop;
     const char           *nonce_count;
     /* the following fields are not (directly) from the header */
-    ap_time_t             nonce_time;
+    apr_time_t             nonce_time;
     enum hdr_sts          auth_hdr_sts;
     const char           *raw_request_uri;
     uri_components       *psd_request_uri;
@@ -235,8 +235,8 @@ typedef struct digest_header_struct {
 /* (mostly) nonce stuff */
 
 typedef union time_union {
-    ap_time_t	  time;
-    unsigned char arr[sizeof(ap_time_t)];
+    apr_time_t	  time;
+    unsigned char arr[sizeof(apr_time_t)];
 } time_rec;
 
 
@@ -246,11 +246,11 @@ static int call_cnt = 0;
 
 /* client-list, opaque, and one-time-nonce stuff */
 
-static ap_shmem_t    *client_shm = NULL;
+static apr_shmem_t    *client_shm = NULL;
 static unsigned long *opaque_cntr;
-static ap_time_t     *otn_counter;	/* one-time-nonce counter */
-static ap_lock_t     *client_lock = NULL;
-static ap_lock_t     *opaque_lock = NULL;
+static apr_time_t     *otn_counter;	/* one-time-nonce counter */
+static apr_lock_t     *client_lock = NULL;
+static apr_lock_t     *opaque_lock = NULL;
 static char           client_lock_name[L_tmpnam];
 static char           opaque_lock_name[L_tmpnam];
 
@@ -268,24 +268,24 @@ module MODULE_VAR_EXPORT auth_digest_module;
  * initialization code
  */
 
-static ap_status_t cleanup_tables(void *not_used)
+static apr_status_t cleanup_tables(void *not_used)
 {
     ap_log_rerror(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
                  "Digest: cleaning up shared memory");
     fflush(stderr);
 
     if (client_shm) {
-	ap_shm_destroy(client_shm);
+	apr_shm_destroy(client_shm);
 	client_shm = NULL;
     }
 
     if (client_lock) {
-	ap_destroy_lock(client_lock);
+	apr_destroy_lock(client_lock);
 	client_lock = NULL;
     }
 
     if (opaque_lock) {
-	ap_destroy_lock(opaque_lock);
+	apr_destroy_lock(opaque_lock);
 	opaque_lock = NULL;
     }
 
@@ -294,26 +294,26 @@ static ap_status_t cleanup_tables(void *not_used)
 
 static void initialize_secret(server_rec *s)
 {
-    ap_status_t status;
+    apr_status_t status;
 
     ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, s,
 		 "Digest: generating secret for digest authentication ...");
 
     /* TODO - make sure this func works (compiles?) on win32 */
-    status = ap_generate_random_bytes(secret, sizeof(secret));
+    status = apr_generate_random_bytes(secret, sizeof(secret));
 
     if(!(status == APR_SUCCESS)) {
         char buf[120];
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_CRIT, 0, s,
 		     "Digest: error generating secret: %s", 
-		     ap_strerror(status, buf, sizeof(buf)));
+		     apr_strerror(status, buf, sizeof(buf)));
 	exit(1);
     }
 
     ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, s, "Digest: done");
 }
 
-static void log_error_and_cleanup(char *msg, ap_status_t sts, server_rec *s)
+static void log_error_and_cleanup(char *msg, apr_status_t sts, server_rec *s)
 {
     ap_log_error(APLOG_MARK, APLOG_ERR, sts, s,
 		 "Digest: %s - all nonce-count checking, one-time nonces, and "
@@ -322,20 +322,20 @@ static void log_error_and_cleanup(char *msg, ap_status_t sts, server_rec *s)
     cleanup_tables(NULL);
 }
 
-static void initialize_tables(server_rec *s, ap_pool_t *ctx)
+static void initialize_tables(server_rec *s, apr_pool_t *ctx)
 {
     unsigned long idx;
-    ap_status_t   sts;
+    apr_status_t   sts;
 
     /* set up client list */
 
-    sts = ap_shm_init(&client_shm, shmem_size, tmpnam(NULL), ctx);
+    sts = apr_shm_init(&client_shm, shmem_size, tmpnam(NULL), ctx);
     if (sts != APR_SUCCESS) {
 	log_error_and_cleanup("failed to create shared memory segments", sts, s);
 	return;
     }
 
-    client_list = ap_shm_malloc(client_shm, sizeof(*client_list) +
+    client_list = apr_shm_malloc(client_shm, sizeof(*client_list) +
 					    sizeof(client_entry*)*num_buckets);
     if (!client_list) {
 	log_error_and_cleanup("failed to allocate shared memory", -1, s);
@@ -348,7 +348,7 @@ static void initialize_tables(server_rec *s, ap_pool_t *ctx)
     client_list->num_entries = 0;
 
     tmpnam(client_lock_name);
-    sts = ap_create_lock(&client_lock, APR_READWRITE, APR_LOCKALL,
+    sts = apr_create_lock(&client_lock, APR_READWRITE, APR_LOCKALL,
 			 client_lock_name, ctx);
     if (sts != APR_SUCCESS) {
 	log_error_and_cleanup("failed to create lock", sts, s);
@@ -358,7 +358,7 @@ static void initialize_tables(server_rec *s, ap_pool_t *ctx)
 
     /* setup opaque */
 
-    opaque_cntr = ap_shm_malloc(client_shm, sizeof(*opaque_cntr));
+    opaque_cntr = apr_shm_malloc(client_shm, sizeof(*opaque_cntr));
     if (opaque_cntr == NULL) {
 	log_error_and_cleanup("failed to allocate shared memory", -1, s);
 	return;
@@ -366,7 +366,7 @@ static void initialize_tables(server_rec *s, ap_pool_t *ctx)
     *opaque_cntr = 1UL;
 
     tmpnam(opaque_lock_name);
-    sts = ap_create_lock(&opaque_lock, APR_MUTEX, APR_LOCKALL,
+    sts = apr_create_lock(&opaque_lock, APR_MUTEX, APR_LOCKALL,
 			 opaque_lock_name, ctx);
     if (sts != APR_SUCCESS) {
 	log_error_and_cleanup("failed to create lock", sts, s);
@@ -376,7 +376,7 @@ static void initialize_tables(server_rec *s, ap_pool_t *ctx)
 
     /* setup one-time-nonce counter */
 
-    otn_counter = ap_shm_malloc(client_shm, sizeof(*otn_counter));
+    otn_counter = apr_shm_malloc(client_shm, sizeof(*otn_counter));
     if (otn_counter == NULL) {
 	log_error_and_cleanup("failed to allocate shared memory", -1, s);
 	return;
@@ -389,8 +389,8 @@ static void initialize_tables(server_rec *s, ap_pool_t *ctx)
     return;
 }
 
-static void initialize_module(ap_pool_t *p, ap_pool_t *plog,
-			      ap_pool_t *ptemp, server_rec *s)
+static void initialize_module(apr_pool_t *p, apr_pool_t *plog,
+			      apr_pool_t *ptemp, server_rec *s)
 {
     /* keep from doing the init more than once at startup, and delay
      * the init until the second round
@@ -411,26 +411,26 @@ static void initialize_module(ap_pool_t *p, ap_pool_t *plog,
      * configuration changes are ignored, and B) certain optimizations,
      * such as only allocating the smallest necessary entry for each
      * client, can't be done. However, the alternative is a nightmare:
-     * we can't call ap_shm_destroy on a graceful restart because there
+     * we can't call apr_shm_destroy on a graceful restart because there
      * will be children using the tables, and we also don't know when the
      * last child dies. Therefore we can never clean up the old stuff,
      * creating a creeping memory leak.
      */
     initialize_tables(s, p);
-    ap_register_cleanup(p, NULL, cleanup_tables, ap_null_cleanup);
+    apr_register_cleanup(p, NULL, cleanup_tables, apr_null_cleanup);
 #endif	/* APR_HAS_SHARED_MEMORY */
 }
 
-static void initialize_child(ap_pool_t *p, server_rec *s)
+static void initialize_child(apr_pool_t *p, server_rec *s)
 {
-    ap_status_t sts;
+    apr_status_t sts;
 
     if (!client_shm)
 	return;
 
-    if ((sts = ap_child_init_lock(&client_lock, client_lock_name, p))
+    if ((sts = apr_child_init_lock(&client_lock, client_lock_name, p))
 	    != APR_SUCCESS
-	||  (sts = ap_child_init_lock(&opaque_lock, opaque_lock_name, p))
+	||  (sts = apr_child_init_lock(&opaque_lock, opaque_lock_name, p))
 	    != APR_SUCCESS) {
 	log_error_and_cleanup("failed to create lock", sts, s);
 	return;
@@ -441,18 +441,18 @@ static void initialize_child(ap_pool_t *p, server_rec *s)
  * configuration code
  */
 
-static void *create_digest_dir_config(ap_pool_t *p, char *dir)
+static void *create_digest_dir_config(apr_pool_t *p, char *dir)
 {
     digest_config_rec *conf;
 
     if (dir == NULL)  return NULL;
 
-    conf = (digest_config_rec *) ap_pcalloc(p, sizeof(digest_config_rec));
+    conf = (digest_config_rec *) apr_pcalloc(p, sizeof(digest_config_rec));
     if (conf) {
-	conf->qop_list       = ap_palloc(p, sizeof(char*));
+	conf->qop_list       = apr_palloc(p, sizeof(char*));
 	conf->qop_list[0]    = NULL;
 	conf->nonce_lifetime = DFLT_NONCE_LIFE;
-	conf->dir_name       = ap_pstrdup(p, dir);
+	conf->dir_name       = apr_pstrdup(p, dir);
 	conf->algorithm      = DFLT_ALGORITHM;
     }
 
@@ -504,7 +504,7 @@ static const char *set_qop(cmd_parms *cmd, void *config, const char *op)
 
     if (!strcasecmp(op, "none")) {
 	if (conf->qop_list[0] == NULL) {
-	    conf->qop_list = ap_palloc(cmd->pool, 2 * sizeof(char*));
+	    conf->qop_list = apr_palloc(cmd->pool, 2 * sizeof(char*));
 	    conf->qop_list[1] = NULL;
 	}
 	conf->qop_list[0] = "none";
@@ -516,13 +516,13 @@ static const char *set_qop(cmd_parms *cmd, void *config, const char *op)
 		     "Digest: WARNING: qop `auth-int' currently only works "
 		     "correctly for responses with no entity");
     else if (strcasecmp(op, "auth"))
-	return ap_pstrcat(cmd->pool, "Unrecognized qop: ", op, NULL);
+	return apr_pstrcat(cmd->pool, "Unrecognized qop: ", op, NULL);
 
     for (cnt=0; conf->qop_list[cnt] != NULL; cnt++)
 	;
-    tmp = ap_palloc(cmd->pool, (cnt+2)*sizeof(char*));
+    tmp = apr_palloc(cmd->pool, (cnt+2)*sizeof(char*));
     memcpy(tmp, conf->qop_list, cnt*sizeof(char*));
-    tmp[cnt]   = ap_pstrdup(cmd->pool, op);
+    tmp[cnt]   = apr_pstrdup(cmd->pool, op);
     tmp[cnt+1] = NULL;
     conf->qop_list = tmp;
 
@@ -537,7 +537,7 @@ static const char *set_nonce_lifetime(cmd_parms *cmd, void *config,
 
     lifetime = strtol(t, &endptr, 10); 
     if (endptr < (t+strlen(t)) && !ap_isspace(*endptr))
-	return ap_pstrcat(cmd->pool, "Invalid time in AuthDigestNonceLifetime: ", t, NULL);
+	return apr_pstrcat(cmd->pool, "Invalid time in AuthDigestNonceLifetime: ", t, NULL);
 
     ((digest_config_rec *) config)->nonce_lifetime = lifetime * AP_USEC_PER_SEC;
     return NULL;
@@ -574,7 +574,7 @@ static const char *set_algorithm(cmd_parms *cmd, void *config, const char *alg)
 	}
     }
     else if (strcasecmp(alg, "MD5"))
-	return ap_pstrcat(cmd->pool, "Invalid algorithm in AuthDigestAlgorithm: ", alg, NULL);
+	return apr_pstrcat(cmd->pool, "Invalid algorithm in AuthDigestAlgorithm: ", alg, NULL);
 
     ((digest_config_rec *) config)->algorithm = alg;
     return NULL;
@@ -585,10 +585,10 @@ static const char *set_uri_list(cmd_parms *cmd, void *config, const char *uri)
     digest_config_rec *c = (digest_config_rec *) config;
     if (c->uri_list) {
 	c->uri_list[strlen(c->uri_list)-1] = '\0';
-	c->uri_list = ap_pstrcat(cmd->pool, c->uri_list, " ", uri, "\"", NULL);
+	c->uri_list = apr_pstrcat(cmd->pool, c->uri_list, " ", uri, "\"", NULL);
     }
     else
-	c->uri_list = ap_pstrcat(cmd->pool, ", domain=\"", uri, "\"", NULL);
+	c->uri_list = apr_pstrcat(cmd->pool, ", domain=\"", uri, "\"", NULL);
     return NULL;
 }
 
@@ -607,12 +607,12 @@ static const char *set_shmem_size(cmd_parms *cmd, void *config,
     else if (*endptr == 'm' || *endptr == 'M')
 	size *= 1048576;
     else
-	return ap_pstrcat(cmd->pool, "Invalid size in AuthDigestShmemSize: ",
+	return apr_pstrcat(cmd->pool, "Invalid size in AuthDigestShmemSize: ",
 			  size_str, NULL);
 
     min = sizeof(*client_list) + sizeof(client_entry*) + sizeof(client_entry);
     if (size < min)
-	return ap_psprintf(cmd->pool, "size in AuthDigestShmemSize too small: "
+	return apr_psprintf(cmd->pool, "size in AuthDigestShmemSize too small: "
 			   "%ld < %ld", size, min, NULL);
 
     shmem_size  = size;
@@ -720,7 +720,7 @@ static client_entry *get_client(unsigned long key, const request_rec *r)
     bucket = key % client_list->tbl_len;
     entry  = client_list->table[bucket];
 
-    ap_lock(client_lock /*, MM_LOCK_RD */);
+    apr_lock(client_lock /*, MM_LOCK_RD */);
 
     while(entry && key != entry->key) {
 	prev  = entry;
@@ -733,7 +733,7 @@ static client_entry *get_client(unsigned long key, const request_rec *r)
 	client_list->table[bucket] = entry;
     }
 
-    ap_unlock(client_lock);
+    apr_unlock(client_lock);
 
     if (entry)
 	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, 0, r,
@@ -767,7 +767,7 @@ static long gc(void)
 	if (prev)  prev->next = NULL;	/* cut list */
 	else       client_list->table[idx] = NULL;
 	if (entry) {			/* remove entry */
-	    ap_shm_free(client_shm, entry);
+	    apr_shm_free(client_shm, entry);
 	    num_removed++;
 	}
     }
@@ -797,11 +797,11 @@ static client_entry *add_client(unsigned long key, client_entry *info,
     bucket = key % client_list->tbl_len;
     entry  = client_list->table[bucket];
 
-    ap_lock(client_lock /*, MM_LOCK_RW */);
+    apr_lock(client_lock /*, MM_LOCK_RW */);
 
     /* try to allocate a new entry */
 
-    entry = ap_shm_malloc(client_shm, sizeof(client_entry));
+    entry = apr_shm_malloc(client_shm, sizeof(client_entry));
     if (!entry) {
 	long num_removed = gc();
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, s,
@@ -810,7 +810,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
 		     "%ld", num_removed,
 		     client_list->num_created - client_list->num_renewed,
 		     client_list->num_removed, client_list->num_renewed);
-	entry = ap_shm_malloc(client_shm, sizeof(client_entry));
+	entry = apr_shm_malloc(client_shm, sizeof(client_entry));
 	if (!entry)  return NULL;	/* give up */
     }
 
@@ -823,7 +823,7 @@ static client_entry *add_client(unsigned long key, client_entry *info,
     client_list->num_created++;
     client_list->num_entries++;
 
-    ap_unlock(client_lock);
+    apr_unlock(client_lock);
 
     ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, 0, s,
 		 "allocated new client %lu", key);
@@ -844,7 +844,7 @@ static int get_digest_rec(request_rec *r, digest_header_rec *resp)
     int vk = 0, vv = 0;
     char *key, *value;
 
-    auth_line = ap_table_get(r->headers_in,
+    auth_line = apr_table_get(r->headers_in,
 			     r->proxyreq ? "Proxy-Authorization"
 					 : "Authorization");
     if (!auth_line) {
@@ -860,8 +860,8 @@ static int get_digest_rec(request_rec *r, digest_header_rec *resp)
 
     l = strlen(auth_line);
 
-    key   = ap_palloc(r->pool, l+1);
-    value = ap_palloc(r->pool, l+1);
+    key   = apr_palloc(r->pool, l+1);
+    value = apr_palloc(r->pool, l+1);
 
     while (auth_line[0] != '\0') {
 
@@ -903,25 +903,25 @@ static int get_digest_rec(request_rec *r, digest_header_rec *resp)
 	if (auth_line[0] != '\0') auth_line++;
 
 	if (!strcasecmp(key, "username"))
-	    resp->username = ap_pstrdup(r->pool, value);
+	    resp->username = apr_pstrdup(r->pool, value);
 	else if (!strcasecmp(key, "realm"))
-	    resp->realm = ap_pstrdup(r->pool, value);
+	    resp->realm = apr_pstrdup(r->pool, value);
 	else if (!strcasecmp(key, "nonce"))
-	    resp->nonce = ap_pstrdup(r->pool, value);
+	    resp->nonce = apr_pstrdup(r->pool, value);
 	else if (!strcasecmp(key, "uri"))
-	    resp->uri = ap_pstrdup(r->pool, value);
+	    resp->uri = apr_pstrdup(r->pool, value);
 	else if (!strcasecmp(key, "response"))
-	    resp->digest = ap_pstrdup(r->pool, value);
+	    resp->digest = apr_pstrdup(r->pool, value);
 	else if (!strcasecmp(key, "algorithm"))
-	    resp->algorithm = ap_pstrdup(r->pool, value);
+	    resp->algorithm = apr_pstrdup(r->pool, value);
 	else if (!strcasecmp(key, "cnonce"))
-	    resp->cnonce = ap_pstrdup(r->pool, value);
+	    resp->cnonce = apr_pstrdup(r->pool, value);
 	else if (!strcasecmp(key, "opaque"))
-	    resp->opaque = ap_pstrdup(r->pool, value);
+	    resp->opaque = apr_pstrdup(r->pool, value);
 	else if (!strcasecmp(key, "qop"))
-	    resp->message_qop = ap_pstrdup(r->pool, value);
+	    resp->message_qop = apr_pstrdup(r->pool, value);
 	else if (!strcasecmp(key, "nc"))
-	    resp->nonce_count = ap_pstrdup(r->pool, value);
+	    resp->nonce_count = apr_pstrdup(r->pool, value);
     }
 
     if (!resp->username || !resp->realm || !resp->nonce || !resp->uri
@@ -958,7 +958,7 @@ static int parse_hdr_and_update_nc(request_rec *r)
     if (!ap_is_initial_req(r))
 	return DECLINED;
 
-    resp = ap_pcalloc(r->pool, sizeof(digest_header_rec));
+    resp = apr_pcalloc(r->pool, sizeof(digest_header_rec));
     resp->raw_request_uri = r->unparsed_uri;
     resp->psd_request_uri = &r->parsed_uri;
     resp->needed_auth = 0;
@@ -1013,11 +1013,11 @@ static void gen_nonce_hash(char *hash, const char *timestr, const char *opaque,
 
 /* The nonce has the format b64(time)+hash .
  */
-static const char *gen_nonce(ap_pool_t *p, ap_time_t now, const char *opaque,
+static const char *gen_nonce(apr_pool_t *p, apr_time_t now, const char *opaque,
 			     const server_rec *server,
 			     const digest_config_rec *conf)
 {
-    char *nonce = ap_palloc(p, NONCE_LEN+1);
+    char *nonce = apr_palloc(p, NONCE_LEN+1);
     int len;
     time_rec t;
 
@@ -1052,9 +1052,9 @@ static client_entry *gen_client(const request_rec *r)
 
     if (!opaque_cntr)  return NULL;
 
-    ap_lock(opaque_lock /*, MM_LOCK_RW */);
+    apr_lock(opaque_lock /*, MM_LOCK_RW */);
     op = (*opaque_cntr)++;
-    ap_unlock(opaque_lock);
+    apr_unlock(opaque_lock);
 
     if (!(entry = add_client(op, &new_entry, r->server))) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
@@ -1081,9 +1081,9 @@ static client_entry *gen_client(const request_rec *r)
  * generated and is expected to return the equivalent of
  *
  * h_urp = ap_md5(r->pool,
- *         ap_pstrcat(r->pool, username, ":", ap_auth_name(r), ":", passwd))
+ *         apr_pstrcat(r->pool, username, ":", ap_auth_name(r), ":", passwd))
  * ap_md5(r->pool,
- *         (unsigned char *) ap_pstrcat(r->pool, h_urp, ":", resp->nonce, ":",
+ *         (unsigned char *) apr_pstrcat(r->pool, h_urp, ":", resp->nonce, ":",
  *                                      resp->cnonce, NULL));
  *
  * or put differently, it must return
@@ -1105,7 +1105,7 @@ static const char *get_userpw_hash(const request_rec *r,
 				   const digest_config_rec *conf)
 {
     return ap_md5(r->pool,
-	     (unsigned char *) ap_pstrcat(r->pool, conf->ha1, ":", resp->nonce,
+	     (unsigned char *) apr_pstrcat(r->pool, conf->ha1, ":", resp->nonce,
 					  ":", resp->cnonce, NULL));
 }
 
@@ -1153,7 +1153,7 @@ static void clear_session(const digest_header_rec *resp)
  * Authorization challenge generation code (for WWW-Authenticate)
  */
 
-static const char *guess_domain(ap_pool_t *p, const char *uri,
+static const char *guess_domain(apr_pool_t *p, const char *uri,
 				const char *filename, const char *dir)
 {
     size_t u_len = strlen(uri), f_len = strlen(filename), d_len = strlen(dir);
@@ -1209,7 +1209,7 @@ static const char *guess_domain(ap_pool_t *p, const char *uri,
      * take the uri with the same reach.
      */
     if ((unsigned long) (f-filename) < d_len) {
-	char *tmp = ap_pstrdup(p, uri);
+	char *tmp = apr_pstrdup(p, uri);
 	tmp[(u-uri)+(d_len-(f-filename))] = '\0';
 	return tmp;
     }
@@ -1218,10 +1218,10 @@ static const char *guess_domain(ap_pool_t *p, const char *uri,
 }
 
 
-static const char *ltox(ap_pool_t *p, unsigned long num)
+static const char *ltox(apr_pool_t *p, unsigned long num)
 {
     if (num != 0)
-	return ap_psprintf(p, "%lx", num);
+	return apr_psprintf(p, "%lx", num);
     else
 	return "";
 }
@@ -1240,10 +1240,10 @@ static void note_digest_auth_failure(request_rec *r,
     } else if (!strcasecmp(conf->qop_list[0], "none")) {
 	qop = "";
     } else {
-	qop = ap_pstrcat(r->pool, ", qop=\"", conf->qop_list[0], NULL);
+	qop = apr_pstrcat(r->pool, ", qop=\"", conf->qop_list[0], NULL);
 	for (cnt=1; conf->qop_list[cnt] != NULL; cnt++)
-	    qop = ap_pstrcat(r->pool, qop, ",", conf->qop_list[cnt], NULL);
-	qop = ap_pstrcat(r->pool, qop, "\"", NULL);
+	    qop = apr_pstrcat(r->pool, qop, ",", conf->qop_list[cnt], NULL);
+	qop = apr_pstrcat(r->pool, qop, "\"", NULL);
     }
 
     /* Setup opaque */
@@ -1275,7 +1275,7 @@ static void note_digest_auth_failure(request_rec *r,
     }
 
     if (opaque[0])
-	opaque_param = ap_pstrcat(r->pool, ", opaque=\"", opaque, "\"", NULL);
+	opaque_param = apr_pstrcat(r->pool, ", opaque=\"", opaque, "\"", NULL);
     else
 	opaque_param = NULL;
 
@@ -1309,12 +1309,12 @@ static void note_digest_auth_failure(request_rec *r,
 	if (domain[0] == '/' && domain[1] == '\0')
 	    domain = NULL;	/* "/" is the default, so no need to send it */
 	else
-	    domain = ap_pstrcat(r->pool, ", domain=\"", domain, "\"", NULL);
+	    domain = apr_pstrcat(r->pool, ", domain=\"", domain, "\"", NULL);
     }
 
-    ap_table_mergen(r->err_headers_out,
+    apr_table_mergen(r->err_headers_out,
 		    r->proxyreq ? "Proxy-Authenticate" : "WWW-Authenticate",
-		    ap_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%s\", "
+		    apr_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%s\", "
 					 "algorithm=%s%s%s%s%s",
 				ap_auth_name(r), nonce, conf->algorithm,
 				opaque_param ? opaque_param : "",
@@ -1335,7 +1335,7 @@ static const char *get_hash(request_rec *r, const char *user,
     char l[MAX_STRING_LEN];
     const char *rpw;
     char *w, *x;
-    ap_status_t sts;
+    apr_status_t sts;
 
     if ((sts = ap_pcfg_openfile(&f, r->pool, auth_pwfile)) != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
@@ -1351,7 +1351,7 @@ static const char *get_hash(request_rec *r, const char *user,
 
 	if (x && w && !strcmp(user, w) && !strcmp(realm, x)) {
 	    ap_cfg_closefile(f);
-	    return ap_pstrdup(r->pool, rpw);
+	    return apr_pstrdup(r->pool, rpw);
 	}
     }
     ap_cfg_closefile(f);
@@ -1461,10 +1461,10 @@ static const char *old_digest(const request_rec *r,
 {
     const char *ha2;
 
-    ha2 = ap_md5(r->pool, (unsigned char *)ap_pstrcat(r->pool, r->method, ":",
+    ha2 = ap_md5(r->pool, (unsigned char *)apr_pstrcat(r->pool, r->method, ":",
 						      resp->uri, NULL));
     return ap_md5(r->pool,
-		  (unsigned char *)ap_pstrcat(r->pool, ha1, ":", resp->nonce,
+		  (unsigned char *)apr_pstrcat(r->pool, ha1, ":", resp->nonce,
 					      ":", ha2, NULL));
 }
 
@@ -1484,14 +1484,14 @@ static const char *new_digest(const request_rec *r,
 	ha1 = conf->ha1;
 
     if (resp->message_qop && !strcasecmp(resp->message_qop, "auth-int"))
-	a2 = ap_pstrcat(r->pool, r->method, ":", resp->uri, ":",
+	a2 = apr_pstrcat(r->pool, r->method, ":", resp->uri, ":",
 			ap_md5(r->pool, (const unsigned char*) ""), NULL); /* TBD */
     else
-	a2 = ap_pstrcat(r->pool, r->method, ":", resp->uri, NULL);
+	a2 = apr_pstrcat(r->pool, r->method, ":", resp->uri, NULL);
     ha2 = ap_md5(r->pool, (const unsigned char *)a2);
 
     return ap_md5(r->pool,
-		  (unsigned char *)ap_pstrcat(r->pool, ha1, ":", resp->nonce,
+		  (unsigned char *)apr_pstrcat(r->pool, ha1, ":", resp->nonce,
 					      ":", resp->nonce_count, ":",
 					      resp->cnonce, ":",
 					      resp->message_qop, ":", ha2,
@@ -1507,7 +1507,7 @@ static void copy_uri_components(uri_components *dst, uri_components *src,
 	dst->scheme = (char *) "http";
 
     if (src->hostname && src->hostname[0] != '\0') {
-	dst->hostname = ap_pstrdup(r->pool, src->hostname);
+	dst->hostname = apr_pstrdup(r->pool, src->hostname);
 	ap_unescape_url(dst->hostname);
     }
     else
@@ -1519,14 +1519,14 @@ static void copy_uri_components(uri_components *dst, uri_components *src,
 	dst->port = ap_get_server_port(r);
 
     if (src->path && src->path[0] != '\0') {
-	dst->path = ap_pstrdup(r->pool, src->path);
+	dst->path = apr_pstrdup(r->pool, src->path);
 	ap_unescape_url(dst->path);
     }
     else
 	dst->path = src->path;
 
     if (src->query && src->query[0] != '\0') {
-	dst->query = ap_pstrdup(r->pool, src->query);
+	dst->query = apr_pstrdup(r->pool, src->query);
 	ap_unescape_url(dst->query);
     }
     else
@@ -1763,15 +1763,15 @@ static int authenticate_digest_user(request_rec *r)
  * Checking ID
  */
 
-static ap_table_t *groups_for_user(request_rec *r, const char *user,
+static apr_table_t *groups_for_user(request_rec *r, const char *user,
 			      const char *grpfile)
 {
     configfile_t *f;
-    ap_table_t *grps = ap_make_table(r->pool, 15);
-    ap_pool_t *sp;
+    apr_table_t *grps = apr_make_table(r->pool, 15);
+    apr_pool_t *sp;
     char l[MAX_STRING_LEN];
     const char *group_name, *ll, *w;
-    ap_status_t sts;
+    apr_status_t sts;
 
     if ((sts = ap_pcfg_openfile(&f, r->pool, grpfile)) != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
@@ -1779,28 +1779,28 @@ static ap_table_t *groups_for_user(request_rec *r, const char *user,
 	return NULL;
     }
 
-    if (ap_create_pool(&sp, r->pool) != APR_SUCCESS)
+    if (apr_create_pool(&sp, r->pool) != APR_SUCCESS)
 		return NULL;
 
     while (!(ap_cfg_getline(l, MAX_STRING_LEN, f))) {
 	if ((l[0] == '#') || (!l[0]))
 	    continue;
 	ll = l;
-	ap_clear_pool(sp);
+	apr_clear_pool(sp);
 
 	group_name = ap_getword(sp, &ll, ':');
 
 	while (ll[0]) {
 	    w = ap_getword_conf(sp, &ll);
 	    if (!strcmp(w, user)) {
-		ap_table_setn(grps, ap_pstrdup(r->pool, group_name), "in");
+		apr_table_setn(grps, apr_pstrdup(r->pool, group_name), "in");
 		break;
 	    }
 	}
     }
 
     ap_cfg_closefile(f);
-    ap_destroy_pool(sp);
+    apr_destroy_pool(sp);
     return grps;
 }
 
@@ -1815,8 +1815,8 @@ static int digest_check_auth(request_rec *r)
     int method_restricted = 0;
     register int x;
     const char *t, *w;
-    ap_table_t *grpstatus;
-    const ap_array_header_t *reqs_arr;
+    apr_table_t *grpstatus;
+    const apr_array_header_t *reqs_arr;
     require_line *reqs;
 
     if (!(t = ap_auth_type(r)) || strcasecmp(t, "Digest"))
@@ -1858,7 +1858,7 @@ static int digest_check_auth(request_rec *r)
 
 	    while (t[0]) {
 		w = ap_getword_conf(r->pool, &t);
-		if (ap_table_get(grpstatus, w))
+		if (apr_table_get(grpstatus, w))
 		    return OK;
 	    }
 	}
@@ -1890,9 +1890,9 @@ static int digest_check_auth(request_rec *r)
  */
 
 #ifdef SEND_DIGEST
-static const char *hdr(const ap_table_t *tbl, const char *name)
+static const char *hdr(const apr_table_t *tbl, const char *name)
 {
-    const char *val = ap_table_get(tbl, name);
+    const char *val = apr_table_get(tbl, name);
     if (val)
 	return val;
     else
@@ -1929,22 +1929,22 @@ static int add_auth_info(request_rec *r)
 	 * calc the entity hash) it's best to just leave this #def'd out.
 	 */
 	char date[AP_RFC822_DATE_LEN];
-	ap_rfc822_date(date, r->request_time);
+	apr_rfc822_date(date, r->request_time);
 	char *entity_info =
 	    ap_md5(r->pool,
-		   (unsigned char *) ap_pstrcat(r->pool, resp->raw_request_uri,
+		   (unsigned char *) apr_pstrcat(r->pool, resp->raw_request_uri,
 		       ":",
 		       r->content_type ? r->content_type : ap_default_type(r), ":",
 		       hdr(r->headers_out, "Content-Length"), ":",
 		       r->content_encoding ? r->content_encoding : "", ":",
 		       hdr(r->headers_out, "Last-Modified"), ":",
-		       r->no_cache && !ap_table_get(r->headers_out, "Expires") ?
+		       r->no_cache && !apr_table_get(r->headers_out, "Expires") ?
 			    date :
 			    hdr(r->headers_out, "Expires"),
 		       NULL));
 	digest =
 	    ap_md5(r->pool,
-		   (unsigned char *)ap_pstrcat(r->pool, conf->ha1, ":",
+		   (unsigned char *)apr_pstrcat(r->pool, conf->ha1, ":",
 					       resp->nonce, ":",
 					       r->method, ":",
 					       date, ":",
@@ -1960,7 +1960,7 @@ static int add_auth_info(request_rec *r)
     if (conf->nonce_lifetime > 0) {
 	/* send nextnonce if current nonce will expire in less than 30 secs */
 	if ((r->request_time - resp->nonce_time) > (conf->nonce_lifetime-NEXTNONCE_DELTA)) {
-	    nextnonce = ap_pstrcat(r->pool, ", nextnonce=\"",
+	    nextnonce = apr_pstrcat(r->pool, ", nextnonce=\"",
 				   gen_nonce(r->pool, r->request_time,
 					     resp->opaque, r->server, conf),
 				   "\"", NULL);
@@ -1971,7 +1971,7 @@ static int add_auth_info(request_rec *r)
     else if (conf->nonce_lifetime == 0 && resp->client) {
         const char *nonce = gen_nonce(r->pool, 0, resp->opaque, r->server,
 				      conf);
-	nextnonce = ap_pstrcat(r->pool, ", nextnonce=\"", nonce, "\"", NULL);
+	nextnonce = apr_pstrcat(r->pool, ", nextnonce=\"", nonce, "\"", NULL);
 	memcpy(resp->client->last_nonce, nonce, NONCE_LEN+1);
     }
     /* else nonce never expires, hence no nextnonce */
@@ -1983,7 +1983,7 @@ static int add_auth_info(request_rec *r)
 	&& resp->message_qop == NULL) {
 	/* use only RFC-2069 format */
 	if (digest)
-	    ai = ap_pstrcat(r->pool, "digest=\"", digest, "\"", nextnonce,NULL);
+	    ai = apr_pstrcat(r->pool, "digest=\"", digest, "\"", nextnonce,NULL);
 	else
 	    ai = nextnonce;
     }
@@ -2005,14 +2005,14 @@ static int add_auth_info(request_rec *r)
 	    ha1 = conf->ha1;
 
 	if (resp->message_qop && !strcasecmp(resp->message_qop, "auth-int"))
-	    a2 = ap_pstrcat(r->pool, ":", resp->uri, ":",
+	    a2 = apr_pstrcat(r->pool, ":", resp->uri, ":",
 			    ap_md5(r->pool, (const unsigned char *) ""), NULL); /* TBD */
 	else
-	    a2 = ap_pstrcat(r->pool, ":", resp->uri, NULL);
+	    a2 = apr_pstrcat(r->pool, ":", resp->uri, NULL);
 	ha2 = ap_md5(r->pool, (const unsigned char *)a2);
 
 	resp_dig = ap_md5(r->pool,
-		         (unsigned char *)ap_pstrcat(r->pool, ha1, ":",
+		         (unsigned char *)apr_pstrcat(r->pool, ha1, ":",
 						     resp->nonce, ":",
 						     resp->nonce_count, ":",
 						     resp->cnonce, ":",
@@ -2022,7 +2022,7 @@ static int add_auth_info(request_rec *r)
 
 	/* assemble Authentication-Info header
 	 */
-	ai = ap_pstrcat(r->pool,
+	ai = apr_pstrcat(r->pool,
 			"rspauth=\"", resp_dig, "\"",
 			nextnonce,
 		        resp->cnonce ? ", cnonce=\"" : "",
@@ -2040,7 +2040,7 @@ static int add_auth_info(request_rec *r)
     }
 
     if (ai && ai[0])
-	ap_table_mergen(r->headers_out,
+	apr_table_mergen(r->headers_out,
 			r->proxyreq ? "Proxy-Authentication-Info"
 				    : "Authentication-Info",
 			ai);
diff --git a/modules/arch/win32/mod_isapi.c b/modules/arch/win32/mod_isapi.c
index 592643c..e61cb47 100644
--- a/modules/arch/win32/mod_isapi.c
+++ b/modules/arch/win32/mod_isapi.c
@@ -144,12 +144,12 @@ typedef struct {
     PFN_HSE_IO_COMPLETION completion;
     PVOID  completion_arg;
     HANDLE complete;
-    ap_status_t retval;
+    apr_status_t retval;
 } isapi_cid;
 
-ap_status_t isapi_handler (request_rec *r)
+apr_status_t isapi_handler (request_rec *r)
 {
-    ap_table_t *e = r->subprocess_env;
+    apr_table_t *e = r->subprocess_env;
     isapi_loaded *isa;
     isapi_cid *cid;
 
@@ -177,8 +177,8 @@ ap_status_t isapi_handler (request_rec *r)
      * should only be performed on the first isapi dll invocation, 
      * not with every HttpExtensionProc()
      */
-    isa = ap_pcalloc(r->pool, sizeof(isapi_module));
-    isa->pVer = ap_pcalloc(r->pool, sizeof(HSE_VERSION_INFO));
+    isa = apr_pcalloc(r->pool, sizeof(isapi_module));
+    isa->pVer = apr_pcalloc(r->pool, sizeof(HSE_VERSION_INFO));
     isa->refcount = 0;
 
     /* TODO: These may need to become overrideable, so that we
@@ -239,8 +239,8 @@ ap_status_t isapi_handler (request_rec *r)
     ap_add_cgi_vars(r);
 
     /* Set up connection structure and ecb */
-    cid = ap_pcalloc(r->pool, sizeof(isapi_cid));
-    cid->ecb = ap_pcalloc(r->pool, sizeof(struct _EXTENSION_CONTROL_BLOCK));
+    cid = apr_pcalloc(r->pool, sizeof(isapi_cid));
+    cid->ecb = apr_pcalloc(r->pool, sizeof(struct _EXTENSION_CONTROL_BLOCK));
     cid->ecb->ConnID = (HCONN)cid;
     /* TODO: Critical section */
     ++isa->refcount;
@@ -256,15 +256,15 @@ ap_status_t isapi_handler (request_rec *r)
     cid->ecb->dwHttpStatusCode = 0;
     strcpy(cid->ecb->lpszLogData, "");
     // TODO: are copies really needed here?
-    cid->ecb->lpszMethod = ap_pstrdup(r->pool, (char*) r->method);
-    cid->ecb->lpszQueryString = ap_pstrdup(r->pool, 
-                                (char*) ap_table_get(e, "QUERY_STRING"));
-    cid->ecb->lpszPathInfo = ap_pstrdup(r->pool, 
-                             (char*) ap_table_get(e, "PATH_INFO"));
-    cid->ecb->lpszPathTranslated = ap_pstrdup(r->pool, 
-                                   (char*) ap_table_get(e, "PATH_TRANSLATED"));
-    cid->ecb->lpszContentType = ap_pstrdup(r->pool, 
-                                (char*) ap_table_get(e, "CONTENT_TYPE"));
+    cid->ecb->lpszMethod = apr_pstrdup(r->pool, (char*) r->method);
+    cid->ecb->lpszQueryString = apr_pstrdup(r->pool, 
+                                (char*) apr_table_get(e, "QUERY_STRING"));
+    cid->ecb->lpszPathInfo = apr_pstrdup(r->pool, 
+                             (char*) apr_table_get(e, "PATH_INFO"));
+    cid->ecb->lpszPathTranslated = apr_pstrdup(r->pool, 
+                                   (char*) apr_table_get(e, "PATH_TRANSLATED"));
+    cid->ecb->lpszContentType = apr_pstrdup(r->pool, 
+                                (char*) apr_table_get(e, "CONTENT_TYPE"));
     /* Set up the callbacks */
     cid->ecb->GetServerVariable = &GetServerVariable;
     cid->ecb->WriteClient = &WriteClient;
@@ -291,7 +291,7 @@ ap_status_t isapi_handler (request_rec *r)
          * But we can be smarter and read up to our 48k and then allow
          * the ISAPI app to read further blocks as desired.
          */
-        long to_read = atol(ap_table_get(e, "CONTENT_LENGTH"));
+        long to_read = atol(apr_table_get(e, "CONTENT_LENGTH"));
         long read;
 
         /* Actually, let's cap it at 48k, until we figure out what
@@ -306,7 +306,7 @@ ap_status_t isapi_handler (request_rec *r)
             return HTTP_REQUEST_ENTITY_TOO_LARGE;
         }
 
-        cid->ecb->lpbData = ap_pcalloc(r->pool, 1 + to_read);
+        cid->ecb->lpbData = apr_pcalloc(r->pool, 1 + to_read);
 
         if ((read = ap_get_client_block(r, cid->ecb->lpbData, to_read)) < 0) {
             if (isa->TerminateExtension) 
@@ -417,7 +417,7 @@ BOOL WINAPI GetServerVariable (HCONN hConn, LPSTR lpszVariableName,
                                LPVOID lpvBuffer, LPDWORD lpdwSizeofBuffer)
 {
     request_rec *r = ((isapi_cid *)hConn)->r;
-    ap_table_t *e = r->subprocess_env;
+    apr_table_t *e = r->subprocess_env;
     const char *result;
 
     /* Mostly, we just grab it from the environment, but there are
@@ -428,7 +428,7 @@ BOOL WINAPI GetServerVariable (HCONN hConn, LPSTR lpszVariableName,
         /* We don't support NT users, so this is always the same as
          * REMOTE_USER
          */
-        result = ap_table_get(e, "REMOTE_USER");
+        result = apr_table_get(e, "REMOTE_USER");
     }
     else if (!strcasecmp(lpszVariableName, "SERVER_PORT_SECURE")) {
         /* Apache doesn't support secure requests inherently, so
@@ -441,7 +441,7 @@ BOOL WINAPI GetServerVariable (HCONN hConn, LPSTR lpszVariableName,
         result = r->uri;
     }
     else {
-        result = ap_table_get(e, lpszVariableName);
+        result = apr_table_get(e, lpszVariableName);
     }
 
     if (result) {
@@ -549,21 +549,21 @@ static char* ComposeHeaders(request_rec *r, char* data)
             while (endp > value && ap_isspace(*endp)) 
                 *endp-- = '\0';
 
-            tmp = ap_pstrdup (r->pool, value);
+            tmp = apr_pstrdup (r->pool, value);
             ap_str_tolower(tmp);
             r->content_type = tmp;
         }
         else if (!strcasecmp(data, "Content-Length")) {
-            ap_table_set(r->headers_out, data, value);
+            apr_table_set(r->headers_out, data, value);
         }
         else if (!strcasecmp(data, "Transfer-Encoding")) {
-            ap_table_set(r->headers_out, data, value);
+            apr_table_set(r->headers_out, data, value);
         }
         else if (!strcasecmp(data, "Set-Cookie")) {
-            ap_table_add(r->err_headers_out, data, value);
+            apr_table_add(r->err_headers_out, data, value);
         }
         else {
-            ap_table_merge(r->err_headers_out, data, value);
+            apr_table_merge(r->err_headers_out, data, value);
         }
 
         /* Reset data */
@@ -594,7 +594,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
             /* Set the status to be returned when the HttpExtensionProc()
              * is done.
              */
-            ap_table_set (r->headers_out, "Location", lpvBuffer);
+            apr_table_set (r->headers_out, "Location", lpvBuffer);
             cid->r->status = cid->ecb->dwHttpStatusCode 
                                                    = HTTP_MOVED_TEMPORARILY;
             return TRUE;
@@ -609,17 +609,17 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
             }
 
             /* Reset the method to GET */
-            r->method = ap_pstrdup(r->pool, "GET");
+            r->method = apr_pstrdup(r->pool, "GET");
             r->method_number = M_GET;
 
             /* Don't let anyone think there's still data */
-            ap_table_unset(r->headers_in, "Content-Length");
+            apr_table_unset(r->headers_in, "Content-Length");
 
             ap_internal_redirect((char *)lpvBuffer, r);
             return TRUE;
 
         case HSE_REQ_SEND_RESPONSE_HEADER:
-            r->status_line = lpvBuffer ? lpvBuffer : ap_pstrdup(r->pool, "200 OK");
+            r->status_line = lpvBuffer ? lpvBuffer : apr_pstrdup(r->pool, "200 OK");
             sscanf(r->status_line, "%d", &r->status);
             cid->ecb->dwHttpStatusCode = r->status;
 
@@ -636,7 +636,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
             }
                         
             /* Make a copy - don't disturb the original */
-            data = ap_pstrdup(r->pool, (char *)lpdwDataType);
+            data = apr_pstrdup(r->pool, (char *)lpdwDataType);
             
             /* Parse them out, or die trying */
             data = ComposeHeaders(r, data);
@@ -661,7 +661,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
 
         case HSE_REQ_MAP_URL_TO_PATH:
             /* Map a URL to a filename */
-            subreq = ap_sub_req_lookup_uri(ap_pstrndup(r->pool, (char *)lpvBuffer,
+            subreq = ap_sub_req_lookup_uri(apr_pstrndup(r->pool, (char *)lpvBuffer,
                                            *lpdwSize), r);
 
             GetFullPathName(subreq->filename, *lpdwSize - 1, (char *)lpvBuffer, NULL);
@@ -738,7 +738,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
             /* TODO: Not quite ready for prime time yet */
 
             /* Map a URL to a filename */
-            subreq = ap_sub_req_lookup_uri(ap_pstrndup(r->pool, (char *)lpvBuffer,
+            subreq = ap_sub_req_lookup_uri(apr_pstrndup(r->pool, (char *)lpvBuffer,
                                            *lpdwSize), r);
 
             GetFullPathName(subreq->filename, *lpdwSize - 1, (char *)lpvBuffer, NULL);
@@ -752,7 +752,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
                 ((char *)lpvBuffer)[l + 1] = '\0';
             }
 
-            lpdwDataType = (LPDWORD) ap_palloc(r->pool, sizeof(HSE_URL_MAPEX_INFO));
+            lpdwDataType = (LPDWORD) apr_palloc(r->pool, sizeof(HSE_URL_MAPEX_INFO));
             strncpy(((LPHSE_URL_MAPEX_INFO)lpdwDataType)->lpszPath,
                     (char *) lpvBuffer, MAX_PATH);
             ((LPHSE_URL_MAPEX_INFO)lpdwDataType)->dwFlags = 0;
@@ -790,12 +790,12 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
 
             if (((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->pszStatus
                 && ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->cchStatus) {
-                r->status_line = ap_pstrndup(r->pool, 
+                r->status_line = apr_pstrndup(r->pool, 
                            ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->pszStatus,
                            ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->cchStatus);
             }
             else {
-                r->status_line = ap_pstrdup(r->pool, "200 OK");
+                r->status_line = apr_pstrdup(r->pool, "200 OK");
             }
             sscanf(r->status_line, "%d", &r->status);
             cid->ecb->dwHttpStatusCode = r->status;
@@ -804,7 +804,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
                 && ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->cchHeader)
             {
                 /* Make a copy - don't disturb the original */
-                data = ap_pstrndup(r->pool, 
+                data = apr_pstrndup(r->pool, 
                            ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->pszHeader,
                            ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->cchHeader);
                 
@@ -864,7 +864,7 @@ module isapi_module = {
    NULL,                        /* merge per-dir config */
    NULL,                        /* server config */
    NULL,                        /* merge server config */
-   NULL,                        /* command ap_table_t */
+   NULL,                        /* command apr_table_t */
    isapi_handlers,              /* handlers */
    NULL                         /* register hooks */
 };
diff --git a/modules/cache/mod_file_cache.c b/modules/cache/mod_file_cache.c
index 08cf6dd..aec0aff 100644
--- a/modules/cache/mod_file_cache.c
+++ b/modules/cache/mod_file_cache.c
@@ -135,33 +135,33 @@ static int once_through = 0;
 
 typedef struct {
 #if APR_HAS_SENDFILE
-    ap_file_t *file;
+    apr_file_t *file;
 #endif
     char *filename;
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     int is_mmapped;
 #if APR_HAS_MMAP
-    ap_mmap_t *mm;
+    apr_mmap_t *mm;
 #endif
 } a_file;
 
 typedef struct {
-    ap_array_header_t *files;
+    apr_array_header_t *files;
 } a_server_config;
 
 
-static void *create_server_config(ap_pool_t *p, server_rec *s)
+static void *create_server_config(apr_pool_t *p, server_rec *s)
 {
-    a_server_config *sconf = ap_palloc(p, sizeof(*sconf));
+    a_server_config *sconf = apr_palloc(p, sizeof(*sconf));
 
-    sconf->files = ap_make_array(p, 20, sizeof(a_file));
+    sconf->files = apr_make_array(p, 20, sizeof(a_file));
     return sconf;
 }
 
-static ap_status_t open_file(ap_file_t **file, const char *filename, int flg1, int flg2, 
-                             ap_pool_t *p)
+static apr_status_t open_file(apr_file_t **file, const char *filename, int flg1, int flg2, 
+                             apr_pool_t *p)
 {
-    ap_status_t rv;
+    apr_status_t rv;
 #ifdef WIN32
     /* The Windows file needs to be opened for overlapped i/o, which APR doesn't
      * support.
@@ -175,20 +175,20 @@ static ap_status_t open_file(ap_file_t **file, const char *filename, int flg1, i
                        FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN, /* file attributes */
                        NULL);            /* handle to file with attributes to copy */
     if (hFile != INVALID_HANDLE_VALUE) {
-        rv = ap_put_os_file(file, &hFile, p);
+        rv = apr_put_os_file(file, &hFile, p);
     }
     else {
         rv = GetLastError();
         *file = NULL;
     }
 #else
-    rv = ap_open(file, filename, flg1, flg2, p);
+    rv = apr_open(file, filename, flg1, flg2, p);
 #endif
 
     return rv;
 }
 
-static ap_status_t cleanup_file_cache(void *sconfv)
+static apr_status_t cleanup_file_cache(void *sconfv)
 {
     a_server_config *sconf = sconfv;
     size_t n;
@@ -199,12 +199,12 @@ static ap_status_t cleanup_file_cache(void *sconfv)
     while(n) {
 #if APR_HAS_MMAP
         if (file->is_mmapped) { 
-	    ap_mmap_delete(file->mm);
+	    apr_mmap_delete(file->mm);
         } 
         else 
 #endif 
 #if APR_HAS_SENDFILE
-            ap_close(file->file); 
+            apr_close(file->file); 
 #endif
 	    ++file;
 	    --n;
@@ -219,12 +219,12 @@ static const char *cachefile(cmd_parms *cmd, void *dummy, const char *filename)
     a_server_config *sconf;
     a_file *new_file;
     a_file tmp;
-    ap_file_t *fd = NULL;
-    ap_status_t rc;
+    apr_file_t *fd = NULL;
+    apr_status_t rc;
 
     /* canonicalize the file name? */
     /* os_canonical... */
-    if (ap_stat(&tmp.finfo, filename, cmd->temp_pool) != APR_SUCCESS) { 
+    if (apr_stat(&tmp.finfo, filename, cmd->temp_pool) != APR_SUCCESS) { 
 	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, cmd->server,
 	    "file_cache: unable to stat(%s), skipping", filename);
 	return NULL;
@@ -235,7 +235,7 @@ static const char *cachefile(cmd_parms *cmd, void *dummy, const char *filename)
 	return NULL;
     }
 
-    /* Note: open_file should call ap_open for Unix and CreateFile for Windows.
+    /* Note: open_file should call apr_open for Unix and CreateFile for Windows.
      * The Windows file needs to be opened for async I/O to allow multiple threads
      * to serve it up at once.
      */
@@ -246,13 +246,13 @@ static const char *cachefile(cmd_parms *cmd, void *dummy, const char *filename)
 	return NULL;
     }
     tmp.file = fd;
-    tmp.filename = ap_pstrdup(cmd->pool, filename);
+    tmp.filename = apr_pstrdup(cmd->pool, filename);
     sconf = ap_get_module_config(cmd->server->module_config, &file_cache_module);
-    new_file = ap_push_array(sconf->files);
+    new_file = apr_push_array(sconf->files);
     *new_file = tmp;
     if (sconf->files->nelts == 1) {
 	/* first one, register the cleanup */
-	ap_register_cleanup(cmd->pool, sconf, cleanup_file_cache, ap_null_cleanup);
+	apr_register_cleanup(cmd->pool, sconf, cleanup_file_cache, apr_null_cleanup);
     }
 
     new_file->is_mmapped = FALSE;
@@ -272,9 +272,9 @@ static const char *mmapfile(cmd_parms *cmd, void *dummy, const char *filename)
     a_server_config *sconf;
     a_file *new_file;
     a_file tmp;
-    ap_file_t *fd = NULL;
+    apr_file_t *fd = NULL;
 
-    if (ap_stat(&tmp.finfo, filename, cmd->temp_pool) != APR_SUCCESS) { 
+    if (apr_stat(&tmp.finfo, filename, cmd->temp_pool) != APR_SUCCESS) { 
 	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, cmd->server,
 	    "mod_file_cache: unable to stat(%s), skipping", filename);
 	return NULL;
@@ -284,28 +284,28 @@ static const char *mmapfile(cmd_parms *cmd, void *dummy, const char *filename)
 	    "mod_file_cache: %s isn't a regular file, skipping", filename);
 	return NULL;
     }
-    if (ap_open(&fd, filename, APR_READ, APR_OS_DEFAULT, cmd->temp_pool) 
+    if (apr_open(&fd, filename, APR_READ, APR_OS_DEFAULT, cmd->temp_pool) 
                 != APR_SUCCESS) { 
 	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, cmd->server,
 	    "mod_file_cache: unable to open(%s, O_RDONLY), skipping", filename);
 	return NULL;
     }
-    if (ap_mmap_create(&tmp.mm, fd, 0, tmp.finfo.size, cmd->pool) != APR_SUCCESS) { 
+    if (apr_mmap_create(&tmp.mm, fd, 0, tmp.finfo.size, cmd->pool) != APR_SUCCESS) { 
 	int save_errno = errno;
-	ap_close(fd);
+	apr_close(fd);
 	errno = save_errno;
 	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, cmd->server,
 	    "mod_file_cache: unable to mmap %s, skipping", filename);
 	return NULL;
     }
-    ap_close(fd);
-    tmp.filename = ap_pstrdup(cmd->pool, filename);
+    apr_close(fd);
+    tmp.filename = apr_pstrdup(cmd->pool, filename);
     sconf = ap_get_module_config(cmd->server->module_config, &file_cache_module);
-    new_file = ap_push_array(sconf->files);
+    new_file = apr_push_array(sconf->files);
     *new_file = tmp;
     if (sconf->files->nelts == 1) {
 	/* first one, register the cleanup */
-       ap_register_cleanup(cmd->pool, sconf, cleanup_file_cache, ap_null_cleanup); 
+       apr_register_cleanup(cmd->pool, sconf, cleanup_file_cache, apr_null_cleanup); 
     }
 
     new_file->is_mmapped = TRUE;
@@ -326,8 +326,8 @@ static int file_compare(const void *av, const void *bv)
     return strcmp(a->filename, b->filename);
 }
 
-static void file_cache_post_config(ap_pool_t *p, ap_pool_t *plog,
-                                   ap_pool_t *ptemp, server_rec *s)
+static void file_cache_post_config(apr_pool_t *p, apr_pool_t *plog,
+                                   apr_pool_t *ptemp, server_rec *s)
 {
     a_server_config *sconf;
     a_file *elts;
@@ -391,8 +391,8 @@ static int mmap_handler(request_rec *r, a_file *file, int rangestatus)
         ap_send_mmap (file->mm, r, 0, file->finfo.size);
     }
     else {
-        ap_size_t length;
-        ap_off_t offset;
+        apr_size_t length;
+        apr_off_t offset;
         while (ap_each_byterange(r, &offset, &length)) {
             ap_send_mmap(file->mm, r, offset, length);
         }
@@ -404,9 +404,9 @@ static int mmap_handler(request_rec *r, a_file *file, int rangestatus)
 static int sendfile_handler(request_rec *r, a_file *file, int rangestatus)
 {
 #if APR_HAS_SENDFILE
-    ap_size_t length, nbytes;
-    ap_off_t offset = 0;
-    ap_status_t rv = APR_EINIT;
+    apr_size_t length, nbytes;
+    apr_off_t offset = 0;
+    apr_status_t rv = APR_EINIT;
 
     if (!rangestatus) {
         rv = ap_send_fd(file->file, r, 0, file->finfo.size, &nbytes);
@@ -430,12 +430,12 @@ static int sendfile_handler(request_rec *r, a_file *file, int rangestatus)
 {
 #if APR_HAS_SENDFILE
     long length;
-    ap_off_t offset = 0;
+    apr_off_t offset = 0;
     struct iovec iov;
-    ap_hdtr_t hdtr;
-    ap_hdtr_t *phdtr = &hdtr;
-    ap_status_t rv; 
-    ap_int32_t flags = 0;
+    apr_hdtr_t hdtr;
+    apr_hdtr_t *phdtr = &hdtr;
+    apr_status_t rv; 
+    apr_int32_t flags = 0;
 
     /* 
      * We want to send any data held in the client buffer on the
@@ -448,7 +448,7 @@ static int sendfile_handler(request_rec *r, a_file *file, int rangestatus)
     iov.iov_len =  r->connection->client->outcnt;
     r->connection->client->outcnt = 0;
 
-    /* initialize the ap_hdtr_t struct */
+    /* initialize the apr_hdtr_t struct */
     phdtr->headers = &iov;
     phdtr->numheaders = 1;
     phdtr->trailers = NULL;
diff --git a/modules/dav/fs/dbm.c b/modules/dav/fs/dbm.c
index 7be9f53..99755ad 100644
--- a/modules/dav/fs/dbm.c
+++ b/modules/dav/fs/dbm.c
@@ -73,14 +73,14 @@
 #include "repos.h"
 
 struct dav_db {
-    ap_pool_t *pool;
+    apr_pool_t *pool;
     SDBM *file;
 };
 
 #define D2G(d)	(*(sdbm_datum*)&(d))
 
 
-void dav_dbm_get_statefiles(ap_pool_t *p, const char *fname,
+void dav_dbm_get_statefiles(apr_pool_t *p, const char *fname,
 			    const char **state1, const char **state2)
 {
     char *work;
@@ -89,11 +89,11 @@ void dav_dbm_get_statefiles(ap_pool_t *p, const char *fname,
     if (fname == NULL)
 	fname = DAV_FS_STATE_FILE_FOR_DIR;
 
-    fname = ap_pstrcat(p, fname, SDBM_DIRFEXT, NULL);
+    fname = apr_pstrcat(p, fname, SDBM_DIRFEXT, NULL);
 
     *state1 = fname;
 
-    work = ap_pstrdup(p, fname);
+    work = apr_pstrdup(p, fname);
 
     /* we know the extension is 4 characters -- len(DIRFEXT) */
     extension = strlen(work) - 4;
@@ -102,7 +102,7 @@ void dav_dbm_get_statefiles(ap_pool_t *p, const char *fname,
 
 }
 
-static dav_error * dav_fs_dbm_error(dav_db *db, ap_pool_t *p)
+static dav_error * dav_fs_dbm_error(dav_db *db, apr_pool_t *p)
 {
     int save_errno = errno;
     int errcode;
@@ -125,20 +125,20 @@ static dav_error * dav_fs_dbm_error(dav_db *db, ap_pool_t *p)
 
 /* ensure that our state subdirectory is present */
 /* ### does this belong here or in dav_fs_repos.c ?? */
-void dav_fs_ensure_state_dir(ap_pool_t * p, const char *dirname)
+void dav_fs_ensure_state_dir(apr_pool_t * p, const char *dirname)
 {
-    const char *pathname = ap_pstrcat(p, dirname, "/" DAV_FS_STATE_DIR, NULL);
+    const char *pathname = apr_pstrcat(p, dirname, "/" DAV_FS_STATE_DIR, NULL);
 
     /* ### do we need to deal with the umask? */
 
     /* just try to make it, ignoring any resulting errors */
-    (void) ap_make_dir(pathname, APR_OS_DEFAULT, p);
+    (void) apr_make_dir(pathname, APR_OS_DEFAULT, p);
 }
 
 /* dav_dbm_open_direct:  Opens a *dbm database specified by path.
  *    ro = boolean read-only flag.
  */
-dav_error * dav_dbm_open_direct(ap_pool_t *p, const char *pathname, int ro,
+dav_error * dav_dbm_open_direct(apr_pool_t *p, const char *pathname, int ro,
 				dav_db **pdb)
 {
     SDBM *file;
@@ -157,7 +157,7 @@ dav_error * dav_dbm_open_direct(ap_pool_t *p, const char *pathname, int ro,
     /* may be NULL if we tried to open a non-existent db as read-only */
     if (file != NULL) {
 	/* we have an open database... return it */
-	*pdb = ap_pcalloc(p, sizeof(**pdb));
+	*pdb = apr_pcalloc(p, sizeof(**pdb));
 	(*pdb)->pool = p;
 	(*pdb)->file = file;
     }
@@ -165,7 +165,7 @@ dav_error * dav_dbm_open_direct(ap_pool_t *p, const char *pathname, int ro,
     return NULL;
 }
 
-static dav_error * dav_dbm_open(ap_pool_t * p, const dav_resource *resource,
+static dav_error * dav_dbm_open(apr_pool_t * p, const dav_resource *resource,
                                 int ro, dav_db **pdb)
 {
     const char *dirpath;
@@ -181,7 +181,7 @@ static dav_error * dav_dbm_open(ap_pool_t * p, const dav_resource *resource,
         dav_fs_ensure_state_dir(p, dirpath);
     }
 
-    pathname = ap_pstrcat(p,
+    pathname = apr_pstrcat(p,
 			  dirpath,
 			  "/" DAV_FS_STATE_DIR "/",
 			  fname ? fname : DAV_FS_STATE_FILE_FOR_DIR,
@@ -212,7 +212,7 @@ static dav_error * dav_dbm_fetch(dav_db *db, dav_datum key, dav_datum *pvalue)
 
 static dav_error * dav_dbm_store(dav_db *db, dav_datum key, dav_datum value)
 {
-    ap_status_t status;
+    apr_status_t status;
 
     status = sdbm_store(db->file, D2G(key), D2G(value), SDBM_REPLACE);
 
diff --git a/modules/dav/fs/lock.c b/modules/dav/fs/lock.c
index 1d2837f..7d2f83c 100644
--- a/modules/dav/fs/lock.c
+++ b/modules/dav/fs/lock.c
@@ -119,7 +119,7 @@
 
 
 /* ack. forward declare. */
-static dav_error * dav_fs_remove_locknull_member(ap_pool_t *p,
+static dav_error * dav_fs_remove_locknull_member(apr_pool_t *p,
 						 const char *filename,
 						 dav_buffer *pbuf);
 
@@ -208,7 +208,7 @@ typedef struct dav_lock_indirect
 struct dav_lockdb_private
 {
     request_rec *r;			/* for accessing the uuid state */
-    ap_pool_t *pool;			/* a pool to use */
+    apr_pool_t *pool;			/* a pool to use */
     const char *lockdb_path;		/* where is the lock database? */
 
     int opened;				/* we opened the database */
@@ -246,7 +246,7 @@ static dav_lock *dav_fs_alloc_lock(dav_lockdb *lockdb, dav_datum key,
 {
     dav_lock_combined *comb;
 
-    comb = ap_pcalloc(lockdb->info->pool, sizeof(*comb));
+    comb = apr_pcalloc(lockdb->info->pool, sizeof(*comb));
     comb->pub.rectype = DAV_LOCKREC_DIRECT;
     comb->pub.info = &comb->priv;
     comb->priv.key = key;
@@ -269,7 +269,7 @@ static dav_lock *dav_fs_alloc_lock(dav_lockdb *lockdb, dav_datum key,
 ** Parse an opaquelocktoken URI into a locktoken.
 */
 static dav_error * dav_fs_parse_locktoken(
-    ap_pool_t *p,
+    apr_pool_t *p,
     const char *char_token,
     dav_locktoken **locktoken_p)
 {
@@ -283,7 +283,7 @@ static dav_error * dav_fs_parse_locktoken(
     }
     char_token += 16;
 
-    locktoken = ap_pcalloc(p, sizeof(*locktoken));
+    locktoken = apr_pcalloc(p, sizeof(*locktoken));
     if (dav_parse_opaquelocktoken(char_token, &locktoken->uuid)) {
 	return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN,
 			     "The opaquelocktoken has an incorrect format "
@@ -300,11 +300,11 @@ static dav_error * dav_fs_parse_locktoken(
 ** Generate the URI for a locktoken
 */
 static const char *dav_fs_format_locktoken(
-    ap_pool_t *p,
+    apr_pool_t *p,
     const dav_locktoken *locktoken)
 {
     const char *uuid_token = dav_format_opaquelocktoken(p, &locktoken->uuid);
-    return ap_pstrcat(p, "opaquelocktoken:", uuid_token, NULL);
+    return apr_pstrcat(p, "opaquelocktoken:", uuid_token, NULL);
 }
 
 /*
@@ -362,7 +362,7 @@ static dav_error * dav_fs_open_lockdb(request_rec *r, int ro, int force,
 {
     dav_lockdb_combined *comb;
 
-    comb = ap_pcalloc(r->pool, sizeof(*comb));
+    comb = apr_pcalloc(r->pool, sizeof(*comb));
     comb->pub.hooks = &dav_hooks_locks_fs;
     comb->pub.ro = ro;
     comb->pub.info = &comb->priv;
@@ -405,7 +405,7 @@ static void dav_fs_close_lockdb(dav_lockdb *lockdb)
 **
 ** Given a pathname, build a DAV_TYPE_FNAME lock database key.
 */
-static dav_datum dav_fs_build_fname_key(ap_pool_t *p, const char *pathname)
+static dav_datum dav_fs_build_fname_key(apr_pool_t *p, const char *pathname)
 {
     dav_datum key;
 
@@ -414,7 +414,7 @@ static dav_datum dav_fs_build_fname_key(ap_pool_t *p, const char *pathname)
 
     /* size is TYPE + pathname + null */
     key.dsize = strlen(pathname) + 2;
-    key.dptr = ap_palloc(p, key.dsize);
+    key.dptr = apr_palloc(p, key.dsize);
     *key.dptr = DAV_TYPE_FNAME;
     memcpy(key.dptr + 1, pathname, key.dsize - 1);
     if (key.dptr[key.dsize - 2] == '/')
@@ -432,19 +432,19 @@ static dav_datum dav_fs_build_fname_key(ap_pool_t *p, const char *pathname)
 **    (non-Win32 and file exists ):
 **       dav_datum->dvalue = inode, dev_major, dev_minor
 */
-static dav_datum dav_fs_build_key(ap_pool_t *p, const dav_resource *resource)
+static dav_datum dav_fs_build_key(apr_pool_t *p, const dav_resource *resource)
 {
     const char *file = dav_fs_pathname(resource);
 #ifndef WIN32
     dav_datum key;
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
 
     /* ### use lstat() ?? */
-    if (ap_stat(&finfo, file, p) == 0) {
+    if (apr_stat(&finfo, file, p) == 0) {
 
 	/* ### can we use a buffer for this? */
 	key.dsize = 1 + sizeof(finfo.inode) + sizeof(finfo.device);
-	key.dptr = ap_palloc(p, key.dsize);
+	key.dptr = apr_palloc(p, key.dsize);
 	*key.dptr = DAV_TYPE_INODE;
 	memcpy(key.dptr + 1, &finfo.inode, sizeof(finfo.inode));
 	memcpy(key.dptr + 1 + sizeof(finfo.inode), &finfo.device,
@@ -514,9 +514,9 @@ static dav_error * dav_fs_save_lock_record(dav_lockdb *lockdb, dav_datum key,
 	ip = ip->next;
     }
 
-    /* ### can this be ap_palloc() ? */
+    /* ### can this be apr_palloc() ? */
     /* ### hmmm.... investigate the use of a buffer here */
-    ptr = val.dptr = ap_pcalloc(lockdb->info->pool, val.dsize);
+    ptr = val.dptr = apr_pcalloc(lockdb->info->pool, val.dsize);
     dp  = direct;
     ip  = indirect;
 
@@ -585,7 +585,7 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, dav_datum key,
 					   dav_lock_discovery **direct,
 					   dav_lock_indirect **indirect)
 {
-    ap_pool_t *p = lockdb->info->pool;
+    apr_pool_t *p = lockdb->info->pool;
     dav_error *err;
     size_t offset = 0;
     int need_save = DAV_FALSE;
@@ -622,17 +622,17 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, dav_datum key,
 	case DAV_LOCK_DIRECT:
 	    /* Create and fill a dav_lock_discovery structure */
 
-	    dp = ap_pcalloc(p, sizeof(*dp));
+	    dp = apr_pcalloc(p, sizeof(*dp));
 	    memcpy(dp, val.dptr + offset, sizeof(dp->f));
 	    offset += sizeof(dp->f);
-            dp->locktoken = ap_palloc(p, sizeof(*dp->locktoken));
+            dp->locktoken = apr_palloc(p, sizeof(*dp->locktoken));
             memcpy(dp->locktoken, val.dptr + offset, sizeof(*dp->locktoken));
             offset += sizeof(*dp->locktoken);
 	    if (*(val.dptr + offset) == '\0') {
 		++offset;
 	    }
 	    else {
-		dp->owner = ap_pstrdup(p, val.dptr + offset);
+		dp->owner = apr_pstrdup(p, val.dptr + offset);
 		offset += strlen(dp->owner) + 1;
 	    }
 
@@ -640,7 +640,7 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, dav_datum key,
                 ++offset;
             } 
             else {
-                dp->auth_user = ap_pstrdup(p, val.dptr + offset);
+                dp->auth_user = apr_pstrdup(p, val.dptr + offset);
                 offset += strlen(dp->auth_user) + 1;
             }
 
@@ -654,10 +654,10 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, dav_datum key,
 		/* Remove timed-out locknull fm .locknull list */
 		if (*key.dptr == DAV_TYPE_FNAME) {
 		    const char *fname = key.dptr + 1;
-		    ap_finfo_t finfo;
+		    apr_finfo_t finfo;
 
 		    /* if we don't see the file, then it's a locknull */
-		    if (ap_lstat(&finfo, fname, p) != 0) {
+		    if (apr_lstat(&finfo, fname, p) != 0) {
 			if ((err = dav_fs_remove_locknull_member(p, fname, &buf)) != NULL) {
                             /* ### push a higher-level description? */
                             return err;
@@ -670,15 +670,15 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, dav_datum key,
 	case DAV_LOCK_INDIRECT:
 	    /* Create and fill a dav_lock_indirect structure */
 
-	    ip = ap_pcalloc(p, sizeof(*ip));
-            ip->locktoken = ap_palloc(p, sizeof(*ip->locktoken));
+	    ip = apr_pcalloc(p, sizeof(*ip));
+            ip->locktoken = apr_palloc(p, sizeof(*ip->locktoken));
 	    memcpy(ip->locktoken, val.dptr + offset, sizeof(*ip->locktoken));
 	    offset += sizeof(*ip->locktoken);
 	    memcpy(&ip->timeout, val.dptr + offset, sizeof(ip->timeout));
 	    offset += sizeof(ip->timeout);
 	    ip->key.dsize = *((int *) (val.dptr + offset));	/* length of datum */
 	    offset += sizeof(ip->key.dsize);
-	    ip->key.dptr = ap_palloc(p, ip->key.dsize); 
+	    ip->key.dptr = apr_palloc(p, ip->key.dsize); 
 	    memcpy(ip->key.dptr, val.dptr + offset, ip->key.dsize);
 	    offset += ip->key.dsize;
 
@@ -701,7 +701,7 @@ static dav_error * dav_fs_load_lock_record(dav_lockdb *lockdb, dav_datum key,
 	    return dav_new_error(p,
 				 HTTP_INTERNAL_SERVER_ERROR,
 				 DAV_ERR_LOCK_CORRUPT_DB,
-				 ap_psprintf(p,
+				 apr_psprintf(p,
 					     "The lock database was found to "
 					     "be corrupt. offset %i, c=%02x",
 					     offset, val.dptr[offset]));
@@ -805,13 +805,13 @@ static const char *dav_fs_get_supportedlock(void)
 ** dav_fs_load_locknull_list:  Returns a dav_buffer dump of the locknull file
 **    for the given directory.
 */
-static dav_error * dav_fs_load_locknull_list(ap_pool_t *p, const char *dirpath,
+static dav_error * dav_fs_load_locknull_list(apr_pool_t *p, const char *dirpath,
 					     dav_buffer *pbuf) 
 {
-    ap_finfo_t finfo;
-    ap_file_t *file = NULL;
+    apr_finfo_t finfo;
+    apr_file_t *file = NULL;
     dav_error *err = NULL;
-    ap_ssize_t amt;
+    apr_ssize_t amt;
 
     dav_buffer_init(p, pbuf, dirpath);
 
@@ -823,14 +823,14 @@ static dav_error * dav_fs_load_locknull_list(ap_pool_t *p, const char *dirpath,
     /* reset this in case we leave w/o reading into the buffer */
     pbuf->cur_len = 0;
 
-    if (ap_open(&file, pbuf->buf, APR_READ | APR_BINARY, APR_OS_DEFAULT,
+    if (apr_open(&file, pbuf->buf, APR_READ | APR_BINARY, APR_OS_DEFAULT,
                 p) != APR_SUCCESS) {
 	return NULL;
     }
 
-    if (ap_getfileinfo(&finfo, file) != APR_SUCCESS) {
+    if (apr_getfileinfo(&finfo, file) != APR_SUCCESS) {
 	err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			    ap_psprintf(p,
+			    apr_psprintf(p,
 					"Opened but could not stat file %s",
 					pbuf->buf));
 	goto loaderror;
@@ -838,10 +838,10 @@ static dav_error * dav_fs_load_locknull_list(ap_pool_t *p, const char *dirpath,
 
     dav_set_bufsize(p, pbuf, finfo.size);
     amt = finfo.size;
-    if (ap_read(file, pbuf->buf, &amt) != APR_SUCCESS
+    if (apr_read(file, pbuf->buf, &amt) != APR_SUCCESS
         || amt != finfo.size) {
 	err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			    ap_psprintf(p,
+			    apr_psprintf(p,
 					"Failure reading locknull file "
 					"for %s", dirpath));
 
@@ -851,7 +851,7 @@ static dav_error * dav_fs_load_locknull_list(ap_pool_t *p, const char *dirpath,
     }
 
   loaderror:
-    ap_close(file);
+    apr_close(file);
     return err;
 }
 
@@ -859,19 +859,19 @@ static dav_error * dav_fs_load_locknull_list(ap_pool_t *p, const char *dirpath,
 ** dav_fs_save_locknull_list:  Saves contents of pbuf into the
 **    locknull file for dirpath.
 */
-static dav_error * dav_fs_save_locknull_list(ap_pool_t *p, const char *dirpath,
+static dav_error * dav_fs_save_locknull_list(apr_pool_t *p, const char *dirpath,
 					     dav_buffer *pbuf)
 {
     const char *pathname;
-    ap_file_t *file = NULL;
+    apr_file_t *file = NULL;
     dav_error *err = NULL;
-    ap_ssize_t amt;
+    apr_ssize_t amt;
 
     if (pbuf->buf == NULL)
 	return NULL;
 
     dav_fs_ensure_state_dir(p, dirpath);
-    pathname = ap_pstrcat(p,
+    pathname = apr_pstrcat(p,
 			  dirpath,
 			  dirpath[strlen(dirpath) - 1] == '/' ? "" : "/",
 			  DAV_FS_STATE_DIR "/" DAV_FS_LOCK_NULL_FILE,
@@ -881,31 +881,31 @@ static dav_error * dav_fs_save_locknull_list(ap_pool_t *p, const char *dirpath,
 	/* delete the file if cur_len == 0 */
 	if (remove(pathname) != 0) {
 	    return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-				 ap_psprintf(p,
+				 apr_psprintf(p,
 					     "Error removing %s", pathname));
 	}
 	return NULL;
     }
 
-    if (ap_open(&file, pathname,
+    if (apr_open(&file, pathname,
                 APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
                 APR_OS_DEFAULT, p) != APR_SUCCESS) {
 	return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			     ap_psprintf(p,
+			     apr_psprintf(p,
 					 "Error opening %s for writing",
 					 pathname));
     }
 
     amt = pbuf->cur_len;
-    if (ap_write(file, pbuf->buf, &amt) != APR_SUCCESS
+    if (apr_write(file, pbuf->buf, &amt) != APR_SUCCESS
         || amt != pbuf->cur_len) {
 	err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
-			    ap_psprintf(p,
+			    apr_psprintf(p,
 					"Error writing %i bytes to %s",
 					pbuf->cur_len, pathname));
     }
 
-    ap_close(file);
+    apr_close(file);
     return err;
 }
 
@@ -913,7 +913,7 @@ static dav_error * dav_fs_save_locknull_list(ap_pool_t *p, const char *dirpath,
 ** dav_fs_remove_locknull_member:  Removes filename from the locknull list
 **    for directory path.
 */
-static dav_error * dav_fs_remove_locknull_member(ap_pool_t *p,
+static dav_error * dav_fs_remove_locknull_member(apr_pool_t *p,
                                                  const char *filename,
 						 dav_buffer *pbuf)
 {
@@ -922,7 +922,7 @@ static dav_error * dav_fs_remove_locknull_member(ap_pool_t *p,
     size_t scanlen;
     char *scan;
     const char *scanend;
-    char *dirpath = ap_pstrdup(p, filename);
+    char *dirpath = apr_pstrdup(p, filename);
     char *fname = strrchr(dirpath, '/');
     int dirty = 0;
 
@@ -977,7 +977,7 @@ static dav_error * dav_fs_add_locknull_state(
     const dav_resource *resource)
 {
     dav_buffer buf = { 0 };
-    ap_pool_t *p = lockdb->info->pool;
+    apr_pool_t *p = lockdb->info->pool;
     const char *dirpath;
     const char *fname;
     dav_error *err;
@@ -1016,7 +1016,7 @@ static dav_error * dav_fs_remove_locknull_state(
 {
     dav_buffer buf = { 0 };
     dav_error *err;
-    ap_pool_t *p = lockdb->info->pool;
+    apr_pool_t *p = lockdb->info->pool;
     const char *pathname = dav_fs_pathname(resource);
 
     if ((err = dav_fs_remove_locknull_member(p, pathname, &buf)) != NULL) {
@@ -1080,7 +1080,7 @@ static dav_error * dav_fs_get_locks(dav_lockdb *lockdb,
 				    int calltype,
 				    dav_lock **locks)
 {
-    ap_pool_t *p = lockdb->info->pool;
+    apr_pool_t *p = lockdb->info->pool;
     dav_datum key;
     dav_error *err;
     dav_lock *lock = NULL;
@@ -1251,7 +1251,7 @@ static dav_error * dav_fs_append_locks(dav_lockdb *lockdb,
 				       int make_indirect,
 				       const dav_lock *lock)
 {
-    ap_pool_t *p = lockdb->info->pool;
+    apr_pool_t *p = lockdb->info->pool;
     dav_error *err;
     dav_lock_indirect *ip;
     dav_lock_discovery *dp;
@@ -1272,7 +1272,7 @@ static dav_error * dav_fs_append_locks(dav_lockdb *lockdb,
 	for (; lock != NULL; lock = lock->next) {
 
 	    /* ### this works for any <lock> rectype */
-	    dav_lock_indirect *newi = ap_pcalloc(p, sizeof(*newi));
+	    dav_lock_indirect *newi = apr_pcalloc(p, sizeof(*newi));
 
 	    /* ### shut off the const warning for now */
 	    newi->locktoken = (dav_locktoken *)lock->locktoken;
@@ -1287,7 +1287,7 @@ static dav_error * dav_fs_append_locks(dav_lockdb *lockdb,
 	    /* create and link in the right kind of lock */
 
 	    if (lock->rectype == DAV_LOCKREC_DIRECT) {
-		dav_lock_discovery *newd = ap_pcalloc(p, sizeof(*newd));
+		dav_lock_discovery *newd = apr_pcalloc(p, sizeof(*newd));
 
 		newd->f.scope = lock->scope;
 		newd->f.type = lock->type;
@@ -1303,7 +1303,7 @@ static dav_error * dav_fs_append_locks(dav_lockdb *lockdb,
 	    else {
 		/* DAV_LOCKREC_INDIRECT(_PARTIAL) */
 
-		dav_lock_indirect *newi = ap_pcalloc(p, sizeof(*newi));
+		dav_lock_indirect *newi = apr_pcalloc(p, sizeof(*newi));
 
 		/* ### shut off the const warning for now */
 		newi->locktoken = (dav_locktoken *)lock->locktoken;
diff --git a/modules/dav/fs/mod_dav_fs.c b/modules/dav/fs/mod_dav_fs.c
index 3c89853..6a4f5eb 100644
--- a/modules/dav/fs/mod_dav_fs.c
+++ b/modules/dav/fs/mod_dav_fs.c
@@ -74,19 +74,19 @@ const char *dav_get_lockdb_path(const request_rec *r)
     return conf->lockdb_path;
 }
 
-static void *dav_fs_create_server_config(ap_pool_t *p, server_rec *s)
+static void *dav_fs_create_server_config(apr_pool_t *p, server_rec *s)
 {
-    return ap_pcalloc(p, sizeof(dav_fs_server_conf));
+    return apr_pcalloc(p, sizeof(dav_fs_server_conf));
 }
 
-static void *dav_fs_merge_server_config(ap_pool_t *p,
+static void *dav_fs_merge_server_config(apr_pool_t *p,
                                         void *base, void *overrides)
 {
     dav_fs_server_conf *parent = base;
     dav_fs_server_conf *child = overrides;
     dav_fs_server_conf *newconf;
 
-    newconf = ap_pcalloc(p, sizeof(*newconf));
+    newconf = apr_pcalloc(p, sizeof(*newconf));
 
     newconf->lockdb_path =
         child->lockdb_path ? child->lockdb_path : parent->lockdb_path;
diff --git a/modules/dav/fs/repos.c b/modules/dav/fs/repos.c
index d0647bb..9101034 100644
--- a/modules/dav/fs/repos.c
+++ b/modules/dav/fs/repos.c
@@ -77,9 +77,9 @@
 
 /* context needed to identify a resource */
 struct dav_resource_private {
-    ap_pool_t *pool;        /* memory storage pool associated with request */
+    apr_pool_t *pool;        /* memory storage pool associated with request */
     const char *pathname;   /* full pathname to resource */
-    ap_finfo_t finfo;       /* filesystem info */
+    apr_finfo_t finfo;       /* filesystem info */
 };
 
 /* private context for doing a filesystem walk */
@@ -174,8 +174,8 @@ static const dav_fs_liveprop_name dav_fs_props[] =
 
 /* define the dav_stream structure for our use */
 struct dav_stream {
-    ap_pool_t *p;
-    ap_file_t *f;
+    apr_pool_t *p;
+    apr_file_t *f;
     const char *pathname;	/* we may need to remove it at close time */
 };
 
@@ -186,7 +186,7 @@ static dav_error * dav_fs_walk(dav_walker_ctx *wctx, int depth);
 **
 ** PRIVATE REPOSITORY FUNCTIONS
 */
-ap_pool_t *dav_fs_pool(const dav_resource *resource)
+apr_pool_t *dav_fs_pool(const dav_resource *resource)
 {
     return resource->info->pool;
 }
@@ -226,12 +226,12 @@ void dav_fs_dir_file_name(
 
 /* Note: picked up from ap_gm_timestr_822() */
 /* NOTE: buf must be at least DAV_TIMEBUF_SIZE chars in size */
-static void dav_format_time(int style, ap_time_t sec, char *buf)
+static void dav_format_time(int style, apr_time_t sec, char *buf)
 {
     ap_exploded_time_t tms;
     
     /* ### what to do if fails? */
-    (void) ap_explode_gmt(&tms, sec);
+    (void) apr_explode_gmt(&tms, sec);
 
     if (style == DAV_STYLE_ISO8601) {
 	/* ### should we use "-00:00" instead of "Z" ?? */
@@ -256,21 +256,21 @@ static void dav_format_time(int style, ap_time_t sec, char *buf)
 
 static dav_error * dav_fs_copymove_file(
     int is_move,
-    ap_pool_t * p,
+    apr_pool_t * p,
     const char *src,
     const char *dst,
     dav_buffer *pbuf)
 {
     dav_buffer work_buf = { 0 };
-    ap_file_t *inf = NULL;
-    ap_file_t *outf = NULL;
+    apr_file_t *inf = NULL;
+    apr_file_t *outf = NULL;
 
     if (pbuf == NULL)
 	pbuf = &work_buf;
 
     dav_set_bufsize(p, pbuf, DAV_FS_COPY_BLOCKSIZE);
 
-    if ((ap_open(&inf, src, APR_READ | APR_BINARY, APR_OS_DEFAULT, p)) 
+    if ((apr_open(&inf, src, APR_READ | APR_BINARY, APR_OS_DEFAULT, p)) 
 	!= APR_SUCCESS) {
 	/* ### use something besides 500? */
 	return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -278,9 +278,9 @@ static dav_error * dav_fs_copymove_file(
     }
 
     /* ### do we need to deal with the umask? */
-    if ((ap_open(&outf, dst, APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
+    if ((apr_open(&outf, dst, APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
 		 APR_OS_DEFAULT, p)) != APR_SUCCESS) {
-	ap_close(inf);
+	apr_close(inf);
 
 	/* ### use something besides 500? */
 	return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -288,15 +288,15 @@ static dav_error * dav_fs_copymove_file(
     }
 
     while (1) {
-	ap_ssize_t len = DAV_FS_COPY_BLOCKSIZE;
-	ap_status_t status;
+	apr_ssize_t len = DAV_FS_COPY_BLOCKSIZE;
+	apr_status_t status;
 
-	status = ap_read(inf, pbuf->buf, &len);
+	status = apr_read(inf, pbuf->buf, &len);
 	if (status != APR_SUCCESS && status != APR_EOF) {
-	    ap_close(inf);
-	    ap_close(outf);
+	    apr_close(inf);
+	    apr_close(outf);
 	    
-	    if (ap_remove_file(dst, p) != APR_SUCCESS) {
+	    if (apr_remove_file(dst, p) != APR_SUCCESS) {
 		/* ### ACK! Inconsistent state... */
 
 		/* ### use something besides 500? */
@@ -312,11 +312,11 @@ static dav_error * dav_fs_copymove_file(
 	}
 
         /* write any bytes that were read (applies to APR_EOF, too) */
-        if (ap_full_write(outf, pbuf->buf, len, NULL) != APR_SUCCESS) {
+        if (apr_full_write(outf, pbuf->buf, len, NULL) != APR_SUCCESS) {
             int save_errno = errno;
 
-	    ap_close(inf);
-	    ap_close(outf);
+	    apr_close(inf);
+	    apr_close(outf);
 
 	    if (remove(dst) != 0) {
 		/* ### ACK! Inconsistent state... */
@@ -343,8 +343,8 @@ static dav_error * dav_fs_copymove_file(
             break;
     }
 
-    ap_close(inf);
-    ap_close(outf);
+    apr_close(inf);
+    apr_close(outf);
 
     if (is_move && remove(src) != 0) {
 	dav_error *err;
@@ -376,31 +376,31 @@ static dav_error * dav_fs_copymove_file(
 /* ### need more buffers to replace the pool argument */
 static dav_error * dav_fs_copymove_state(
     int is_move,
-    ap_pool_t * p,
+    apr_pool_t * p,
     const char *src_dir, const char *src_file,
     const char *dst_dir, const char *dst_file,
     dav_buffer *pbuf)
 {
-    ap_finfo_t src_finfo;	/* finfo for source file */
-    ap_finfo_t dst_state_finfo;	/* finfo for STATE directory */
+    apr_finfo_t src_finfo;	/* finfo for source file */
+    apr_finfo_t dst_state_finfo;	/* finfo for STATE directory */
     const char *src;
     const char *dst;
 
     /* build the propset pathname for the source file */
-    src = ap_pstrcat(p, src_dir, "/" DAV_FS_STATE_DIR "/", src_file, NULL);
+    src = apr_pstrcat(p, src_dir, "/" DAV_FS_STATE_DIR "/", src_file, NULL);
 
     /* the source file doesn't exist */
-    if (ap_stat(&src_finfo, src, p) != 0) {
+    if (apr_stat(&src_finfo, src, p) != 0) {
 	return NULL;
     }
 
     /* build the pathname for the destination state dir */
-    dst = ap_pstrcat(p, dst_dir, "/" DAV_FS_STATE_DIR, NULL);
+    dst = apr_pstrcat(p, dst_dir, "/" DAV_FS_STATE_DIR, NULL);
 
     /* ### do we need to deal with the umask? */
 
     /* ensure that it exists */
-    if (ap_make_dir(dst, APR_OS_DEFAULT, p) != 0) {
+    if (apr_make_dir(dst, APR_OS_DEFAULT, p) != 0) {
 	if (errno != EEXIST) {
 	    /* ### use something besides 500? */
 	    return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -409,7 +409,7 @@ static dav_error * dav_fs_copymove_state(
     }
 
     /* get info about the state directory */
-    if (ap_stat(&dst_state_finfo, dst, p) != 0) {
+    if (apr_stat(&dst_state_finfo, dst, p) != 0) {
 	/* Ack! Where'd it go? */
 	/* ### use something besides 500? */
 	return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -425,12 +425,12 @@ static dav_error * dav_fs_copymove_state(
     }
 
     /* append the target file to the state directory pathname */
-    dst = ap_pstrcat(p, dst, "/", dst_file, NULL);
+    dst = apr_pstrcat(p, dst, "/", dst_file, NULL);
 
     /* copy/move the file now */
     if (is_move && src_finfo.device == dst_state_finfo.device) {
 	/* simple rename is possible since it is on the same device */
-	if (ap_rename_file(src, dst, p) != APR_SUCCESS) {
+	if (apr_rename_file(src, dst, p) != APR_SUCCESS) {
 	    /* ### use something besides 500? */
 	    return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
 				 "Could not move state file.");
@@ -445,7 +445,7 @@ static dav_error * dav_fs_copymove_state(
     return NULL;
 }
 
-static dav_error *dav_fs_copymoveset(int is_move, ap_pool_t *p,
+static dav_error *dav_fs_copymoveset(int is_move, apr_pool_t *p,
 				     const dav_resource *src,
 				     const dav_resource *dst,
 				     dav_buffer *pbuf)
@@ -503,7 +503,7 @@ static dav_error *dav_fs_copymoveset(int is_move, ap_pool_t *p,
     return err;
 }
 
-static dav_error *dav_fs_deleteset(ap_pool_t *p, const dav_resource *resource)
+static dav_error *dav_fs_deleteset(apr_pool_t *p, const dav_resource *resource)
 {
     const char *dirpath;
     const char *fname;
@@ -516,7 +516,7 @@ static dav_error *dav_fs_deleteset(ap_pool_t *p, const dav_resource *resource)
     dav_dbm_get_statefiles(p, fname, &state1, &state2);
 
     /* build the propset pathname for the file */
-    pathname = ap_pstrcat(p,
+    pathname = apr_pstrcat(p,
 			  dirpath,
 			  "/" DAV_FS_STATE_DIR "/",
 			  state1,
@@ -530,7 +530,7 @@ static dav_error *dav_fs_deleteset(ap_pool_t *p, const dav_resource *resource)
 
     if (state2 != NULL) {
 	/* build the propset pathname for the file */
-	pathname = ap_pstrcat(p,
+	pathname = apr_pstrcat(p,
 			      dirpath,
 			      "/" DAV_FS_STATE_DIR "/",
 			      state2,
@@ -567,7 +567,7 @@ static dav_resource * dav_fs_get_resource(
     /* ### optimize this into a single allocation! */
 
     /* Create private resource context descriptor */
-    ctx = ap_pcalloc(r->pool, sizeof(*ctx));
+    ctx = apr_pcalloc(r->pool, sizeof(*ctx));
     ctx->pool = r->pool;
     ctx->finfo = r->finfo;
 
@@ -585,7 +585,7 @@ static dav_resource * dav_fs_get_resource(
     ** it onto the filename so that we get a "valid" pathname for null
     ** resources.
     */
-    s = ap_pstrcat(r->pool, filename, r->path_info, NULL);
+    s = apr_pstrcat(r->pool, filename, r->path_info, NULL);
 
     /* make sure the pathname does not have a trailing "/" */
     len = strlen(s);
@@ -595,7 +595,7 @@ static dav_resource * dav_fs_get_resource(
     ctx->pathname = s;
 
     /* Create resource descriptor */
-    resource = ap_pcalloc(r->pool, sizeof(*resource));
+    resource = apr_pcalloc(r->pool, sizeof(*resource));
     resource->type = DAV_RESOURCE_TYPE_REGULAR;
     resource->info = ctx;
     resource->hooks = &dav_hooks_repository_fs;
@@ -603,7 +603,7 @@ static dav_resource * dav_fs_get_resource(
     /* make sure the URI does not have a trailing "/" */
     len = strlen(r->uri);
     if (len > 1 && r->uri[len - 1] == '/') {
-	s = ap_pstrdup(r->pool, r->uri);
+	s = apr_pstrdup(r->pool, r->uri);
 	s[len - 1] = '\0';
 	resource->uri = s;
     }
@@ -670,7 +670,7 @@ static dav_resource * dav_fs_get_parent_resource(const dav_resource *resource)
     /* ### optimize this into a single allocation! */
 
     /* Create private resource context descriptor */
-    parent_ctx = ap_pcalloc(ctx->pool, sizeof(*parent_ctx));
+    parent_ctx = apr_pcalloc(ctx->pool, sizeof(*parent_ctx));
     parent_ctx->pool = ctx->pool;
 
     dirpath = ap_make_dirstr_parent(ctx->pool, ctx->pathname);
@@ -678,7 +678,7 @@ static dav_resource * dav_fs_get_parent_resource(const dav_resource *resource)
         dirpath[strlen(dirpath) - 1] = '\0';
     parent_ctx->pathname = dirpath;
 
-    parent_resource = ap_pcalloc(ctx->pool, sizeof(*parent_resource));
+    parent_resource = apr_pcalloc(ctx->pool, sizeof(*parent_resource));
     parent_resource->info = parent_ctx;
     parent_resource->collection = 1;
     parent_resource->hooks = &dav_hooks_repository_fs;
@@ -690,7 +690,7 @@ static dav_resource * dav_fs_get_parent_resource(const dav_resource *resource)
 	parent_resource->uri = uri;
     }
 
-    if (ap_stat(&parent_ctx->finfo, parent_ctx->pathname, ctx->pool) == 0) {
+    if (apr_stat(&parent_ctx->finfo, parent_ctx->pathname, ctx->pool) == 0) {
         parent_resource->exists = 1;
     }
 
@@ -741,9 +741,9 @@ static dav_error * dav_fs_open_stream(const dav_resource *resource,
 				      dav_stream_mode mode,
 				      dav_stream **stream)
 {
-    ap_pool_t *p = resource->info->pool;
-    dav_stream *ds = ap_pcalloc(p, sizeof(*ds));
-    ap_int32_t flags;
+    apr_pool_t *p = resource->info->pool;
+    dav_stream *ds = apr_pcalloc(p, sizeof(*ds));
+    apr_int32_t flags;
 
     switch (mode) {
     case DAV_MODE_READ:
@@ -762,7 +762,7 @@ static dav_error * dav_fs_open_stream(const dav_resource *resource,
 
     ds->p = p;
     ds->pathname = resource->info->pathname;
-    if (ap_open(&ds->f, ds->pathname, flags, APR_OS_DEFAULT, 
+    if (apr_open(&ds->f, ds->pathname, flags, APR_OS_DEFAULT, 
 		ds->p) != APR_SUCCESS) {
 	/* ### use something besides 500? */
 	return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -777,10 +777,10 @@ static dav_error * dav_fs_open_stream(const dav_resource *resource,
 
 static dav_error * dav_fs_close_stream(dav_stream *stream, int commit)
 {
-    ap_close(stream->f);
+    apr_close(stream->f);
 
     if (!commit) {
-	if (ap_remove_file(stream->pathname, stream->p) != 0) {
+	if (apr_remove_file(stream->pathname, stream->p) != 0) {
 	    /* ### use a better description? */
             return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
 				 "There was a problem removing (rolling "
@@ -793,9 +793,9 @@ static dav_error * dav_fs_close_stream(dav_stream *stream, int commit)
 }
 
 static dav_error * dav_fs_read_stream(dav_stream *stream,
-				      void *buf, ap_size_t *bufsize)
+				      void *buf, apr_size_t *bufsize)
 {
-    if (ap_read(stream->f, buf, (ap_ssize_t *)bufsize) != APR_SUCCESS) {
+    if (apr_read(stream->f, buf, (apr_ssize_t *)bufsize) != APR_SUCCESS) {
 	/* ### use something besides 500? */
 	return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
 			     "An error occurred while reading from a "
@@ -805,11 +805,11 @@ static dav_error * dav_fs_read_stream(dav_stream *stream,
 }
 
 static dav_error * dav_fs_write_stream(dav_stream *stream,
-				       const void *buf, ap_size_t bufsize)
+				       const void *buf, apr_size_t bufsize)
 {
-    ap_status_t status;
+    apr_status_t status;
 
-    status = ap_full_write(stream->f, buf, bufsize, NULL);
+    status = apr_full_write(stream->f, buf, bufsize, NULL);
     if (status == APR_ENOSPC) {
         return dav_new_error(stream->p, HTTP_INSUFFICIENT_STORAGE, 0,
                              "There is not enough storage to write to "
@@ -824,10 +824,10 @@ static dav_error * dav_fs_write_stream(dav_stream *stream,
     return NULL;
 }
 
-static dav_error * dav_fs_seek_stream(dav_stream *stream, ap_off_t abs_pos)
+static dav_error * dav_fs_seek_stream(dav_stream *stream, apr_off_t abs_pos)
 {
-    if (ap_seek(stream->f, APR_SET, &abs_pos) != APR_SUCCESS) {
-	/* ### should check whether ap_seek set abs_pos was set to the
+    if (apr_seek(stream->f, APR_SET, &abs_pos) != APR_SUCCESS) {
+	/* ### should check whether apr_seek set abs_pos was set to the
 	 * correct position? */
 	/* ### use something besides 500? */
 	return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -853,7 +853,7 @@ static dav_error * dav_fs_set_headers(request_rec *r,
     ap_set_etag(r);
 
     /* we accept byte-ranges */
-    ap_table_setn(r->headers_out, "Accept-Ranges", "bytes");
+    apr_table_setn(r->headers_out, "Accept-Ranges", "bytes");
 
     /* set up the Content-Length header */
     ap_set_content_length(r, resource->info->finfo.size);
@@ -880,12 +880,12 @@ static void dav_fs_free_file(void *free_handle)
     /* nothing to free ... */
 }
 
-static dav_error * dav_fs_create_collection(ap_pool_t *p, dav_resource *resource)
+static dav_error * dav_fs_create_collection(apr_pool_t *p, dav_resource *resource)
 {
     dav_resource_private *ctx = resource->info;
-    ap_status_t status;
+    apr_status_t status;
 
-    status = ap_make_dir(ctx->pathname, APR_OS_DEFAULT, p);
+    status = apr_make_dir(ctx->pathname, APR_OS_DEFAULT, p);
     if (status == ENOSPC) {
 	return dav_new_error(p, HTTP_INSUFFICIENT_STORAGE, 0,
 			     "There is not enough storage to create "
@@ -920,7 +920,7 @@ static dav_error * dav_fs_copymove_walker(dav_walker_ctx *ctx, int calltype)
 	}
         else {
 	    /* copy/move of a collection. Create the new, target collection */
-            if (ap_make_dir(dstinfo->pathname, APR_OS_DEFAULT, ctx->pool) 
+            if (apr_make_dir(dstinfo->pathname, APR_OS_DEFAULT, ctx->pool) 
 		!= APR_SUCCESS) {
 		/* ### assume it was a permissions problem */
 		/* ### need a description here */
@@ -1081,13 +1081,13 @@ static dav_error * dav_fs_move_resource(
     }
     else {
 	const char *dirpath;
-	ap_finfo_t finfo;
+	apr_finfo_t finfo;
 
 	/* destination does not exist, but the parent directory should,
 	 * so try it
 	 */
 	dirpath = ap_make_dirstr_parent(dstinfo->pool, dstinfo->pathname);
-	if (ap_stat(&finfo, dirpath, dstinfo->pool) == 0
+	if (apr_stat(&finfo, dirpath, dstinfo->pool) == 0
 	    && finfo.device == srcinfo->finfo.device) {
 	    can_rename = 1;
 	}
@@ -1113,7 +1113,7 @@ static dav_error * dav_fs_move_resource(
     *response = NULL;
 
     /* ### APR has no rename? */
-    if (ap_rename_file(srcinfo->pathname, dstinfo->pathname,
+    if (apr_rename_file(srcinfo->pathname, dstinfo->pathname,
                        srcinfo->pool) != APR_SUCCESS) {
 	/* ### should have a better error than this. */
 	return dav_new_error(srcinfo->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -1133,7 +1133,7 @@ static dav_error * dav_fs_move_resource(
     }
 
     /* error occurred during properties move; try to put resource back */
-    if (ap_rename_file(dstinfo->pathname, srcinfo->pathname,
+    if (apr_rename_file(dstinfo->pathname, srcinfo->pathname,
                        srcinfo->pool) != APR_SUCCESS) {
 	/* couldn't put it back! */
 	return dav_push_error(srcinfo->pool,
@@ -1261,7 +1261,7 @@ static dav_error * dav_fs_walker(dav_fs_walker_context *fsctx, int depth)
     dav_error *err = NULL;
     dav_walker_ctx *wctx = fsctx->wctx;
     int isdir = wctx->resource->collection;
-    ap_dir_t *dirp;
+    apr_dir_t *dirp;
 
     /* ensure the context is prepared properly, then call the func */
     err = (*wctx->func)(wctx,
@@ -1299,15 +1299,15 @@ static dav_error * dav_fs_walker(dav_fs_walker_context *fsctx, int depth)
     fsctx->res2.collection = 0;
 
     /* open and scan the directory */
-    if ((ap_opendir(&dirp, fsctx->path1.buf, wctx->pool)) != APR_SUCCESS) {
+    if ((apr_opendir(&dirp, fsctx->path1.buf, wctx->pool)) != APR_SUCCESS) {
 	/* ### need a better error */
 	return dav_new_error(wctx->pool, HTTP_NOT_FOUND, 0, NULL);
     }
-    while ((ap_readdir(dirp)) == APR_SUCCESS) {
+    while ((apr_readdir(dirp)) == APR_SUCCESS) {
 	char *name;
 	size_t len;
 
-	ap_get_dir_filename(&name, dirp);
+	apr_get_dir_filename(&name, dirp);
 	len = strlen(name);
 
 	/* avoid recursing into our current, parent, or state directories */
@@ -1333,7 +1333,7 @@ static dav_error * dav_fs_walker(dav_fs_walker_context *fsctx, int depth)
 	/* append this file onto the path buffer (copy null term) */
 	dav_buffer_place_mem(wctx->pool, &fsctx->path1, name, len + 1, 0);
 
-	if (ap_lstat(&fsctx->info1.finfo, fsctx->path1.buf, wctx->pool) != 0) {
+	if (apr_lstat(&fsctx->info1.finfo, fsctx->path1.buf, wctx->pool) != 0) {
 	    /* woah! where'd it go? */
 	    /* ### should have a better error here */
 	    err = dav_new_error(wctx->pool, HTTP_NOT_FOUND, 0, NULL);
@@ -1402,7 +1402,7 @@ static dav_error * dav_fs_walker(dav_fs_walker_context *fsctx, int depth)
     }
 
     /* ### check the return value of this? */
-    ap_closedir(dirp);
+    apr_closedir(dirp);
 
     if (err != NULL)
 	return err;
@@ -1603,16 +1603,16 @@ static const char *dav_fs_getetag(const dav_resource *resource)
     dav_resource_private *ctx = resource->info;
 
     if (!resource->exists) 
-	return ap_pstrdup(ctx->pool, "");
+	return apr_pstrdup(ctx->pool, "");
 
     if (ctx->finfo.protection != 0) {
-        return ap_psprintf(ctx->pool, "\"%lx-%lx-%lx\"",
+        return apr_psprintf(ctx->pool, "\"%lx-%lx-%lx\"",
 			   (unsigned long) ctx->finfo.inode,
 			   (unsigned long) ctx->finfo.size,
 			   (unsigned long) ctx->finfo.mtime);
     }
 
-    return ap_psprintf(ctx->pool, "\"%lx\"", (unsigned long) ctx->finfo.mtime);
+    return apr_psprintf(ctx->pool, "\"%lx\"", (unsigned long) ctx->finfo.mtime);
 }
 
 static const dav_hooks_repository dav_hooks_repository_fs =
@@ -1673,7 +1673,7 @@ static dav_prop_insert dav_fs_insert_prop(const dav_resource *resource,
     const char *value;
     const char *s;
     dav_prop_insert which;
-    ap_pool_t *p = resource->info->pool;
+    apr_pool_t *p = resource->info->pool;
     const dav_fs_liveprop_name *scan;
     int ns;
 
@@ -1774,13 +1774,13 @@ static dav_prop_insert dav_fs_insert_prop(const dav_resource *resource,
 
     if (insvalue) {
 	/* use D: prefix to refer to the DAV: namespace URI */
-	s = ap_psprintf(p, "<lp%d:%s>%s</lp%d:%s>" DEBUG_CR,
+	s = apr_psprintf(p, "<lp%d:%s>%s</lp%d:%s>" DEBUG_CR,
 			ns, scan->name, value, ns, scan->name);
 	which = DAV_PROP_INSERT_VALUE;
     }
     else {
 	/* use D: prefix to refer to the DAV: namespace URI */
-	s = ap_psprintf(p, "<lp%d:%s/>" DEBUG_CR, ns, scan->name);
+	s = apr_psprintf(p, "<lp%d:%s/>" DEBUG_CR, ns, scan->name);
 	which = DAV_PROP_INSERT_NAME;
     }
     ap_text_append(p, phdr, s);
@@ -1914,7 +1914,7 @@ static dav_error *dav_fs_patch_exec(dav_resource *resource,
 				    dav_liveprop_rollback **rollback_ctx)
 {
     int value = context != NULL;
-    ap_fileperms_t perms = resource->info->finfo.protection;
+    apr_fileperms_t perms = resource->info->finfo.protection;
     int old_value = (perms & APR_UEXECUTE) != 0;
 
     /* assert: prop == executable. operation == SET. */
@@ -1928,7 +1928,7 @@ static dav_error *dav_fs_patch_exec(dav_resource *resource,
     if (value)
 	perms |= APR_UEXECUTE;
 
-    if (ap_setfileperms(resource->info->pathname, perms) != APR_SUCCESS) {
+    if (apr_setfileperms(resource->info->pathname, perms) != APR_SUCCESS) {
 	return dav_new_error(resource->info->pool,
 			     HTTP_INTERNAL_SERVER_ERROR, 0,
 			     "Could not set the executable flag of the "
@@ -1955,7 +1955,7 @@ static dav_error *dav_fs_patch_rollback(dav_resource *resource,
 					void *context,
 					dav_liveprop_rollback *rollback_ctx)
 {
-    ap_fileperms_t perms = resource->info->finfo.protection & ~APR_UEXECUTE;
+    apr_fileperms_t perms = resource->info->finfo.protection & ~APR_UEXECUTE;
     int value = rollback_ctx != NULL;
 
     /* assert: prop == executable. operation == SET. */
@@ -1964,7 +1964,7 @@ static dav_error *dav_fs_patch_rollback(dav_resource *resource,
     if (value)
 	perms |= APR_UEXECUTE;
 
-    if (ap_setfileperms(resource->info->pathname, perms) != APR_SUCCESS) {
+    if (apr_setfileperms(resource->info->pathname, perms) != APR_SUCCESS) {
 	return dav_new_error(resource->info->pool,
 			     HTTP_INTERNAL_SERVER_ERROR, 0,
 			     "After a failure occurred, the resource's "
@@ -2005,7 +2005,7 @@ int dav_fs_hook_get_resource(request_rec *r, const char *root_dir,
     if (resource == NULL)
         return DECLINED;
 
-    (void) ap_set_userdata(resource, DAV_KEY_RESOURCE, ap_null_cleanup,
+    (void) apr_set_userdata(resource, DAV_KEY_RESOURCE, apr_null_cleanup,
                            r->pool);
     return OK;
 }
@@ -2020,10 +2020,10 @@ const dav_hooks_propdb *dav_fs_get_propdb_hooks(request_rec *r)
     return &dav_hooks_db_dbm;
 }
 
-void dav_fs_gather_propsets(ap_array_header_t *uris)
+void dav_fs_gather_propsets(apr_array_header_t *uris)
 {
 #ifndef WIN32
-    *(const char **)ap_push_array(uris) =
+    *(const char **)apr_push_array(uris) =
         "<http://apache.org/dav/propset/fs/1>";
 #endif
 }
@@ -2046,7 +2046,7 @@ void dav_fs_insert_all_liveprops(request_rec *r, const dav_resource *resource,
     dav_fs_insert_all(resource, insvalue, phdr);
 }
 
-void dav_fs_register_uris(ap_pool_t *p)
+void dav_fs_register_uris(apr_pool_t *p)
 {
     const char * const * uris = dav_fs_namespace_uris;
 
diff --git a/modules/dav/fs/repos.h b/modules/dav/fs/repos.h
index 2ecf314..a580487 100644
--- a/modules/dav/fs/repos.h
+++ b/modules/dav/fs/repos.h
@@ -66,10 +66,10 @@
 
 
 /* ensure that our state subdirectory is present */
-void dav_fs_ensure_state_dir(ap_pool_t *p, const char *dirname);
+void dav_fs_ensure_state_dir(apr_pool_t *p, const char *dirname);
 
 /* return the storage pool associated with a resource */
-ap_pool_t *dav_fs_pool(const dav_resource *resource);
+apr_pool_t *dav_fs_pool(const dav_resource *resource);
 
 /* return the full pathname for a resource */
 const char *dav_fs_pathname(const dav_resource *resource);
@@ -87,9 +87,9 @@ dav_error * dav_fs_get_locknull_members(const dav_resource *resource,
 /* DBM functions used by the repository and locking providers */
 extern const dav_hooks_db dav_hooks_db_dbm;
 
-dav_error * dav_dbm_open_direct(ap_pool_t *p, const char *pathname, int ro,
+dav_error * dav_dbm_open_direct(apr_pool_t *p, const char *pathname, int ro,
 				dav_db **pdb);
-void dav_dbm_get_statefiles(ap_pool_t *p, const char *fname,
+void dav_dbm_get_statefiles(apr_pool_t *p, const char *fname,
 			    const char **state1, const char **state2);
 
 /* where is the lock database located? */
@@ -100,12 +100,12 @@ int dav_fs_hook_get_resource(request_rec *r, const char *root_dir,
 const dav_hooks_locks *dav_fs_get_lock_hooks(request_rec *r);
 const dav_hooks_propdb *dav_fs_get_propdb_hooks(request_rec *r);
 
-void dav_fs_gather_propsets(ap_array_header_t *uris);
+void dav_fs_gather_propsets(apr_array_header_t *uris);
 int dav_fs_find_liveprop(request_rec *r, const char *ns_uri, const char *name,
                          const dav_hooks_liveprop **hooks);
 void dav_fs_insert_all_liveprops(request_rec *r, const dav_resource *resource,
                                  int insvalue, ap_text_header *phdr);
 
-void dav_fs_register_uris(ap_pool_t *p);
+void dav_fs_register_uris(apr_pool_t *p);
 
 #endif /* _DAV_FS_REPOS_H_ */
diff --git a/modules/dav/main/liveprop.c b/modules/dav/main/liveprop.c
index cd720fe..2db0956 100644
--- a/modules/dav/main/liveprop.c
+++ b/modules/dav/main/liveprop.c
@@ -62,18 +62,18 @@
 #include "mod_dav.h"
 
 
-static ap_hash_t *dav_liveprop_uris = NULL;
+static apr_hash_t *dav_liveprop_uris = NULL;
 static int dav_liveprop_count = 0;
 
 
-static ap_status_t dav_cleanup_liveprops(void *ctx)
+static apr_status_t dav_cleanup_liveprops(void *ctx)
 {
     dav_liveprop_uris = NULL;
     dav_liveprop_count = 0;
     return APR_SUCCESS;
 }
 
-void dav_register_liveprop_namespace(ap_pool_t *p, const char *uri)
+void dav_register_liveprop_namespace(apr_pool_t *p, const char *uri)
 {
     int value;
 
@@ -81,23 +81,23 @@ void dav_register_liveprop_namespace(ap_pool_t *p, const char *uri)
     p = ap_global_hook_pool;
 
     if (dav_liveprop_uris == NULL) {
-        dav_liveprop_uris = ap_make_hash(p);
-        ap_register_cleanup(p, NULL, dav_cleanup_liveprops, ap_null_cleanup);
+        dav_liveprop_uris = apr_make_hash(p);
+        apr_register_cleanup(p, NULL, dav_cleanup_liveprops, apr_null_cleanup);
     }
 
-    value = (int)ap_hash_get(dav_liveprop_uris, uri, 0);
+    value = (int)apr_hash_get(dav_liveprop_uris, uri, 0);
     if (value != 0) {
         /* already registered */
         return;
     }
 
     /* start at 1, and count up */
-    ap_hash_set(dav_liveprop_uris, uri, 0, (void *)++dav_liveprop_count);
+    apr_hash_set(dav_liveprop_uris, uri, 0, (void *)++dav_liveprop_count);
 }
 
 int dav_get_liveprop_ns_index(const char *uri)
 {
-    return (int)ap_hash_get(dav_liveprop_uris, uri, 0);
+    return (int)apr_hash_get(dav_liveprop_uris, uri, 0);
 }
 
 int dav_get_liveprop_ns_count(void)
@@ -105,18 +105,18 @@ int dav_get_liveprop_ns_count(void)
     return dav_liveprop_count;
 }
 
-void dav_add_all_liveprop_xmlns(ap_pool_t *p, ap_text_header *phdr)
+void dav_add_all_liveprop_xmlns(apr_pool_t *p, ap_text_header *phdr)
 {
-    ap_hash_index_t *idx = ap_hash_first(dav_liveprop_uris);
+    apr_hash_index_t *idx = apr_hash_first(dav_liveprop_uris);
 
-    for ( ; idx != NULL; idx = ap_hash_next(idx) ) {
+    for ( ; idx != NULL; idx = apr_hash_next(idx) ) {
         const void *key;
         void *val;
         const char *s;
 
-        ap_hash_this(idx, &key, NULL, &val);
+        apr_hash_this(idx, &key, NULL, &val);
 
-        s = ap_psprintf(p, " xmlns:lp%d=\"%s\"", (int)val, key);
+        s = apr_psprintf(p, " xmlns:lp%d=\"%s\"", (int)val, key);
         ap_text_append(p, phdr, s);
     }
 }
diff --git a/modules/dav/main/mod_dav.c b/modules/dav/main/mod_dav.c
index 01b6a06..a74aa0d 100644
--- a/modules/dav/main/mod_dav.c
+++ b/modules/dav/main/mod_dav.c
@@ -108,7 +108,7 @@ typedef struct {
     int handle_get;		/* cached from repository hook structure */
     int allow_depthinfinity;
 
-    ap_table_t *d_params;	/* per-directory DAV config parameters */
+    apr_table_t *d_params;	/* per-directory DAV config parameters */
 
 } dav_dir_conf;
 
@@ -125,7 +125,7 @@ typedef struct {
 /* forward-declare for use in configuration lookup */
 extern module MODULE_VAR_EXPORT dav_module;
 
-static void dav_init_handler(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp,
+static void dav_init_handler(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
                              server_rec *s)
 {
     /* DBG0("dav_init_handler"); */
@@ -133,23 +133,23 @@ static void dav_init_handler(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp,
     ap_add_version_component(p, "DAV/" DAV_VERSION);
 }
 
-static void *dav_create_server_config(ap_pool_t *p, server_rec *s)
+static void *dav_create_server_config(apr_pool_t *p, server_rec *s)
 {
     dav_server_conf *newconf;
 
-    newconf = (dav_server_conf *) ap_pcalloc(p, sizeof(*newconf));
+    newconf = (dav_server_conf *) apr_pcalloc(p, sizeof(*newconf));
 
     dav_create_uuid_state(&newconf->st);
 
     return newconf;
 }
 
-static void *dav_merge_server_config(ap_pool_t *p, void *base, void *overrides)
+static void *dav_merge_server_config(apr_pool_t *p, void *base, void *overrides)
 {
     dav_server_conf *child = overrides;
     dav_server_conf *newconf;
 
-    newconf = (dav_server_conf *) ap_pcalloc(p, sizeof(*newconf));
+    newconf = (dav_server_conf *) apr_pcalloc(p, sizeof(*newconf));
 
     /* ### hmm. we should share the uuid state rather than copy it. if we
        ### do another merge, then we'll just get the old one, rather than
@@ -161,24 +161,24 @@ static void *dav_merge_server_config(ap_pool_t *p, void *base, void *overrides)
     return newconf;
 }
 
-static void *dav_create_dir_config(ap_pool_t *p, char *dir)
+static void *dav_create_dir_config(apr_pool_t *p, char *dir)
 {
     /* NOTE: dir==NULL creates the default per-dir config */
 
     dav_dir_conf *conf;
 
-    conf = (dav_dir_conf *) ap_pcalloc(p, sizeof(*conf));
-    conf->dir = ap_pstrdup(p, dir);
-    conf->d_params = ap_make_table(p, 1);
+    conf = (dav_dir_conf *) apr_pcalloc(p, sizeof(*conf));
+    conf->dir = apr_pstrdup(p, dir);
+    conf->d_params = apr_make_table(p, 1);
 
     return conf;
 }
 
-static void *dav_merge_dir_config(ap_pool_t *p, void *base, void *overrides)
+static void *dav_merge_dir_config(apr_pool_t *p, void *base, void *overrides)
 {
     dav_dir_conf *parent = base;
     dav_dir_conf *child = overrides;
-    dav_dir_conf *newconf = (dav_dir_conf *) ap_pcalloc(p, sizeof(*newconf));
+    dav_dir_conf *newconf = (dav_dir_conf *) apr_pcalloc(p, sizeof(*newconf));
 
     /* DBG3("dav_merge_dir_config: new=%08lx  base=%08lx  overrides=%08lx",
        (long)newconf, (long)base, (long)overrides); */
@@ -189,8 +189,8 @@ static void *dav_merge_dir_config(ap_pool_t *p, void *base, void *overrides)
     newconf->allow_depthinfinity = DAV_INHERIT_VALUE(parent, child,
                                                      allow_depthinfinity);
 
-    newconf->d_params = ap_copy_table(p, parent->d_params);
-    ap_overlap_tables(newconf->d_params, child->d_params,
+    newconf->d_params = apr_copy_table(p, parent->d_params);
+    apr_overlap_tables(newconf->d_params, child->d_params,
 		      AP_OVERLAP_TABLES_SET);
 
     return newconf;
@@ -205,7 +205,7 @@ uuid_state *dav_get_uuid_state(const request_rec *r)
     return &conf->st;
 }
 
-ap_table_t *dav_get_dir_params(const request_rec *r)
+apr_table_t *dav_get_dir_params(const request_rec *r)
 {
     dav_dir_conf *conf;
 
@@ -218,10 +218,10 @@ const dav_hooks_locks *dav_get_lock_hooks(request_rec *r)
     void *data;
     const dav_hooks_locks *hooks;
 
-    (void) ap_get_userdata(&data, DAV_KEY_LOCK_HOOKS, r->pool);
+    (void) apr_get_userdata(&data, DAV_KEY_LOCK_HOOKS, r->pool);
     if (data == NULL) {
         hooks = ap_run_get_lock_hooks(r);
-        (void) ap_set_userdata(hooks, DAV_KEY_LOCK_HOOKS, ap_null_cleanup,
+        (void) apr_set_userdata(hooks, DAV_KEY_LOCK_HOOKS, apr_null_cleanup,
                                r->pool);
     }
     else
@@ -234,10 +234,10 @@ const dav_hooks_propdb *dav_get_propdb_hooks(request_rec *r)
     void *data;
     const dav_hooks_db *hooks;
 
-    (void) ap_get_userdata(&data, DAV_KEY_PROPDB_HOOKS, r->pool);
+    (void) apr_get_userdata(&data, DAV_KEY_PROPDB_HOOKS, r->pool);
     if (data == NULL) {
         hooks = ap_run_get_propdb_hooks(r);
-        (void) ap_set_userdata(hooks, DAV_KEY_PROPDB_HOOKS, ap_null_cleanup,
+        (void) apr_set_userdata(hooks, DAV_KEY_PROPDB_HOOKS, apr_null_cleanup,
                                r->pool);
     }
     else
@@ -250,10 +250,10 @@ const dav_hooks_vsn *dav_get_vsn_hooks(request_rec *r)
     void *data;
     const dav_hooks_vsn *hooks;
 
-    (void) ap_get_userdata(&data, DAV_KEY_VSN_HOOKS, r->pool);
+    (void) apr_get_userdata(&data, DAV_KEY_VSN_HOOKS, r->pool);
     if (data == NULL) {
         hooks = ap_run_get_vsn_hooks(r);
-        (void) ap_set_userdata(hooks, DAV_KEY_VSN_HOOKS, ap_null_cleanup,
+        (void) apr_set_userdata(hooks, DAV_KEY_VSN_HOOKS, apr_null_cleanup,
                                r->pool);
     }
     else
@@ -313,7 +313,7 @@ static const char *dav_cmd_davparam(cmd_parms *cmd, void *config,
 {
     dav_dir_conf *conf = (dav_dir_conf *) config;
 
-    ap_table_set(conf->d_params, arg1, arg2);
+    apr_table_set(conf->d_params, arg1, arg2);
 
     return NULL;
 }
@@ -361,7 +361,7 @@ static int dav_error_response(request_rec *r, int status, const char *body)
 ** in a URI (to form a query section). We must explicitly handle it so that
 ** we can embed the URI into an XML document.
 */
-static const char *dav_xml_escape_uri(ap_pool_t *p, const char *uri)
+static const char *dav_xml_escape_uri(apr_pool_t *p, const char *uri)
 {
     const char *e_uri = ap_escape_uri(p, uri);
 
@@ -380,7 +380,7 @@ static const char *dav_xml_escape_uri(ap_pool_t *p, const char *uri)
 
 static void dav_send_multistatus(request_rec *r, int status,
                                  dav_response *first,
-				 ap_array_header_t *namespaces)
+				 apr_array_header_t *namespaces)
 {
     /* Set the correct status and Content-Type */
     r->status = status;
@@ -501,7 +501,7 @@ static int dav_handle_err(request_rec *r, dav_error *err,
 
     if (response == NULL) {
 	/* our error messages are safe; tell Apache this */
-	ap_table_setn(r->notes, "verbose-error-to", "*");
+	apr_table_setn(r->notes, "verbose-error-to", "*");
 	return err->status;
     }
 
@@ -537,14 +537,14 @@ static int dav_created(request_rec *r, request_rec *rnew,
      * ### the Location header requires an absoluteURI. where to get it? */
     /* ### disable until we get the right value */
 #if 0
-    ap_table_setn(r->headers_out, "Location", rnew->uri);
+    apr_table_setn(r->headers_out, "Location", rnew->uri);
 #endif
 
     /* ### insert an ETag header? see HTTP/1.1 S10.2.2 */
 
     /* Apache doesn't allow us to set a variable body for HTTP_CREATED, so
      * we must manufacture the entire response. */
-    body = ap_psprintf(r->pool, "%s %s has been created.",
+    body = apr_psprintf(r->pool, "%s %s has been created.",
 		       what,
 		       ap_escape_html(rnew->pool, rnew->uri));
     return dav_error_response(r, HTTP_CREATED, body);
@@ -553,7 +553,7 @@ static int dav_created(request_rec *r, request_rec *rnew,
 /* ### move to dav_util? */
 int dav_get_depth(request_rec *r, int def_depth)
 {
-    const char *depth = ap_table_get(r->headers_in, "Depth");
+    const char *depth = apr_table_get(r->headers_in, "Depth");
 
     if (depth == NULL) {
 	return def_depth;
@@ -577,7 +577,7 @@ int dav_get_depth(request_rec *r, int def_depth)
 
 static int dav_get_overwrite(request_rec *r)
 {
-    const char *overwrite = ap_table_get(r->headers_in, "Overwrite");
+    const char *overwrite = apr_table_get(r->headers_in, "Overwrite");
 
     if (overwrite == NULL) {
 	return 1;		/* default is "T" */
@@ -603,7 +603,7 @@ static int dav_get_resource(request_rec *r, dav_resource **res_p)
     void *data;
 
     /* go look for the resource if it isn't already present */
-    (void) ap_get_userdata(&data, DAV_KEY_RESOURCE, r->pool);
+    (void) apr_get_userdata(&data, DAV_KEY_RESOURCE, r->pool);
     if (data == NULL) {
         dav_dir_conf *conf;
         int rv;
@@ -619,7 +619,7 @@ static int dav_get_resource(request_rec *r, dav_resource **res_p)
         else if (rv != OK)
             return rv;
 
-        (void) ap_get_userdata(&data, DAV_KEY_RESOURCE, r->pool);
+        (void) apr_get_userdata(&data, DAV_KEY_RESOURCE, r->pool);
     }
 
     *res_p = data;
@@ -647,11 +647,11 @@ static int dav_parse_range(request_rec *r,
     char *dash;
     char *slash;
 
-    range_c = ap_table_get(r->headers_in, "content-range");
+    range_c = apr_table_get(r->headers_in, "content-range");
     if (range_c == NULL)
         return 0;
 
-    range = ap_pstrdup(r->pool, range_c);
+    range = apr_pstrdup(r->pool, range_c);
     if (strncasecmp(range, "bytes ", 6) != 0
         || (dash = ap_strchr(range, '-')) == NULL
         || (slash = ap_strchr(range, '/')) == NULL) {
@@ -783,9 +783,9 @@ static int dav_method_get(request_rec *r)
 
             /* prep the output */
             r->status = HTTP_PARTIAL_CONTENT;
-            ap_table_setn(r->headers_out,
+            apr_table_setn(r->headers_out,
                           "Content-Range",
-                          ap_psprintf(r->pool, "bytes %ld-%ld/*",
+                          apr_psprintf(r->pool, "bytes %ld-%ld/*",
                                       range_start, range_end));
             ap_set_content_length(r, range_end - range_start + 1);
         }
@@ -799,7 +799,7 @@ static int dav_method_get(request_rec *r)
                                                    &stream)) != NULL) {
 	    /* ### assuming FORBIDDEN is probably not quite right... */
 	    err = dav_push_error(r->pool, HTTP_FORBIDDEN, 0,
-				 ap_psprintf(r->pool,
+				 apr_psprintf(r->pool,
 					     "Unable to GET contents for %s.",
 					     ap_escape_html(r->pool, r->uri)),
 				 err);
@@ -818,7 +818,7 @@ static int dav_method_get(request_rec *r)
 	/* all set. send the headers now. */
 	ap_send_http_header(r);
 
-	buffer = ap_palloc(r->pool, DAV_READ_BLOCKSIZE);
+	buffer = apr_palloc(r->pool, DAV_READ_BLOCKSIZE);
 	while (1) {
 	    size_t amt;
 
@@ -923,7 +923,7 @@ static int dav_method_put(request_rec *r)
 
     /* If not a file or collection resource, PUT not allowed */
     if (resource->type != DAV_RESOURCE_TYPE_REGULAR) {
-        body = ap_psprintf(r->pool,
+        body = apr_psprintf(r->pool,
                            "Cannot create resource %s with PUT.",
                            ap_escape_html(r->pool, r->uri));
 	return dav_error_response(r, HTTP_CONFLICT, body);
@@ -979,7 +979,7 @@ static int dav_method_put(request_rec *r)
                                                &stream)) != NULL) {
 	/* ### assuming FORBIDDEN is probably not quite right... */
 	err = dav_push_error(r->pool, HTTP_FORBIDDEN, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Unable to PUT new contents for %s.",
 					 ap_escape_html(r->pool, r->uri)),
 			     err);
@@ -992,7 +992,7 @@ static int dav_method_put(request_rec *r)
 
     if (err == NULL) {
         if (ap_should_client_block(r)) {
-	    char *buffer = ap_palloc(r->pool, DAV_READ_BLOCKSIZE);
+	    char *buffer = apr_palloc(r->pool, DAV_READ_BLOCKSIZE);
 	    long len;
 
             /*
@@ -1109,8 +1109,8 @@ void dav_add_response(dav_walker_ctx *ctx, const char *href, int status,
     dav_response *resp;
 
     /* just drop some data into an dav_response */
-    resp = ap_pcalloc(ctx->pool, sizeof(*resp));
-    resp->href = ap_pstrdup(ctx->pool, href);
+    resp = apr_pcalloc(ctx->pool, sizeof(*resp));
+    resp->href = apr_pstrdup(ctx->pool, href);
     resp->status = status;
     if (propstats) {
 	resp->propresult = *propstats;
@@ -1169,7 +1169,7 @@ static int dav_method_delete(request_rec *r)
     /* ### allow DAV_RESOURCE_TYPE_REVISION with All-Bindings header */
     if (resource->type != DAV_RESOURCE_TYPE_REGULAR &&
         resource->type != DAV_RESOURCE_TYPE_WORKSPACE) {
-        body = ap_psprintf(r->pool,
+        body = apr_psprintf(r->pool,
                            "Cannot delete resource %s.",
                            ap_escape_html(r->pool, r->uri));
 	return dav_error_response(r, HTTP_CONFLICT, body);
@@ -1188,7 +1188,7 @@ static int dav_method_delete(request_rec *r)
 				    DAV_VALIDATE_PARENT
                                     | DAV_VALIDATE_USE_424, NULL)) != NULL) {
 	err = dav_push_error(r->pool, err->status, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Could not DELETE %s due to a failed "
 					 "precondition (e.g. locks).",
 					 ap_escape_html(r->pool, r->uri)),
@@ -1223,7 +1223,7 @@ static int dav_method_delete(request_rec *r)
     /* check for errors now */
     if (err != NULL) {
 	err = dav_push_error(r->pool, err->status, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Could not DELETE %s.",
 					 ap_escape_html(r->pool, r->uri)),
 			     err);
@@ -1255,7 +1255,7 @@ static int dav_method_options(request_rec *r)
     const char *dav_level;
     const char *vsn_level;
     int result;
-    ap_array_header_t *uri_ary;
+    apr_array_header_t *uri_ary;
     const char *uris;
 
     /* per HTTP/1.1 S9.2, we can discard this body */
@@ -1283,15 +1283,15 @@ static int dav_method_options(request_rec *r)
     }
 
     /* gather property set URIs from all the liveprop providers */
-    uri_ary = ap_make_array(r->pool, 5, sizeof(const char *));
+    uri_ary = apr_make_array(r->pool, 5, sizeof(const char *));
     ap_run_gather_propsets(uri_ary);
-    uris = ap_array_pstrcat(r->pool, uri_ary, ',');
+    uris = apr_array_pstrcat(r->pool, uri_ary, ',');
     if (*uris) {
-        dav_level = ap_pstrcat(r->pool, dav_level, ",", uris, NULL);
+        dav_level = apr_pstrcat(r->pool, dav_level, ",", uris, NULL);
     }
 
     /* this tells MSFT products to skip looking for FrontPage extensions */
-    ap_table_setn(r->headers_out, "MS-Author-Via", "DAV");
+    apr_table_setn(r->headers_out, "MS-Author-Via", "DAV");
 
     /*
     ** Three cases:  resource is null (3), is lock-null (7.4), or exists.
@@ -1308,7 +1308,7 @@ static int dav_method_options(request_rec *r)
     case DAV_RESOURCE_EXISTS:
 	/* resource exists */
 	if (resource->collection) {
-	    options = ap_pstrcat(r->pool,
+	    options = apr_pstrcat(r->pool,
 		"OPTIONS, "
 		"GET, HEAD, POST, DELETE, TRACE, "
 		"PROPFIND, PROPPATCH, COPY, MOVE",
@@ -1317,7 +1317,7 @@ static int dav_method_options(request_rec *r)
 	}
 	else {
 	    /* files also support PUT */
-	    options = ap_pstrcat(r->pool,
+	    options = apr_pstrcat(r->pool,
 		"OPTIONS, "
 		"GET, HEAD, POST, DELETE, TRACE, "
 		"PROPFIND, PROPPATCH, COPY, MOVE, PUT",
@@ -1328,14 +1328,14 @@ static int dav_method_options(request_rec *r)
 
     case DAV_RESOURCE_LOCK_NULL:
 	/* resource is lock-null. */
-	options = ap_pstrcat(r->pool, "OPTIONS, MKCOL, PUT, PROPFIND",
+	options = apr_pstrcat(r->pool, "OPTIONS, MKCOL, PUT, PROPFIND",
                              locks_hooks != NULL ? ", LOCK, UNLOCK" : "",
                              NULL);
 	break;
 
     case DAV_RESOURCE_NULL:
 	/* resource is null. */
-	options = ap_pstrcat(r->pool, "OPTIONS, MKCOL, PUT",
+	options = apr_pstrcat(r->pool, "OPTIONS, MKCOL, PUT",
                              locks_hooks != NULL ? ", LOCK" : "",
                              NULL);
 	break;
@@ -1365,14 +1365,14 @@ static int dav_method_options(request_rec *r)
             vsn_options = ", CHECKOUT";
 
         if (vsn_options != NULL)
-            options = ap_pstrcat(r->pool, options, vsn_options, NULL);
+            options = apr_pstrcat(r->pool, options, vsn_options, NULL);
     }
 
-    ap_table_setn(r->headers_out, "Allow", options);
-    ap_table_setn(r->headers_out, "DAV", dav_level);
+    apr_table_setn(r->headers_out, "Allow", options);
+    apr_table_setn(r->headers_out, "DAV", dav_level);
 
     if (vsn_level != NULL)
-        ap_table_setn(r->headers_out, "Versioning", vsn_level);
+        apr_table_setn(r->headers_out, "Versioning", vsn_level);
 
     /* ### this will send a Content-Type. the default OPTIONS does not. */
     ap_send_http_header(r);
@@ -1496,7 +1496,7 @@ static int dav_method_propfind(request_rec *r)
         /* default is to DISALLOW these requests */
 	if (conf->allow_depthinfinity != DAV_ENABLED_ON) {
             return dav_error_response(r, HTTP_FORBIDDEN,
-                                      ap_psprintf(r->pool,
+                                      apr_psprintf(r->pool,
                                                   "PROPFIND requests with a "
                                                   "Depth of \"infinity\" are "
                                                   "not allowed for %s.",
@@ -1593,8 +1593,8 @@ static int dav_method_propfind(request_rec *r)
     return DONE;
 }
 
-static ap_text * dav_failed_proppatch(ap_pool_t *p,
-                                       ap_array_header_t *prop_ctx)
+static ap_text * dav_failed_proppatch(apr_pool_t *p,
+                                       apr_array_header_t *prop_ctx)
 {
     ap_text_header hdr = { 0 };
     int i = prop_ctx->nelts;
@@ -1634,7 +1634,7 @@ static ap_text * dav_failed_proppatch(ap_pool_t *p,
 	    }
 	}
 
-	s = ap_psprintf(p,
+	s = apr_psprintf(p,
 			"<D:status>"
 			"HTTP/1.1 %d (status)"
 			"</D:status>" DEBUG_CR,
@@ -1654,7 +1654,7 @@ static ap_text * dav_failed_proppatch(ap_pool_t *p,
     return hdr.first;
 }
 
-static ap_text * dav_success_proppatch(ap_pool_t *p, ap_array_header_t *prop_ctx)
+static ap_text * dav_success_proppatch(apr_pool_t *p, apr_array_header_t *prop_ctx)
 {
     ap_text_header hdr = { 0 };
     int i = prop_ctx->nelts;
@@ -1697,7 +1697,7 @@ static void dav_prop_log_errors(dav_prop_ctx *ctx)
 ** reverse order.
 */
 static int dav_process_ctx_list(void (*func)(dav_prop_ctx *ctx),
-				ap_array_header_t *ctx_list, int stop_on_error,
+				apr_array_header_t *ctx_list, int stop_on_error,
 				int reverse)
 {
     int i = ctx_list->nelts;
@@ -1734,7 +1734,7 @@ static int dav_method_proppatch(request_rec *r)
     int failure = 0;
     dav_response resp = { 0 };
     ap_text *propstat_text;
-    ap_array_header_t *ctx_list;
+    apr_array_header_t *ctx_list;
     dav_prop_ctx *ctx;
 
     /* Ask repository module to resolve the resource */
@@ -1770,7 +1770,7 @@ static int dav_method_proppatch(request_rec *r)
     if ((err = dav_open_propdb(r, NULL, resource, 0, doc->namespaces,
 			       &propdb)) != NULL) {
 	err = dav_push_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Could not open the property "
 					 "database for %s.",
 					 ap_escape_html(r->pool, r->uri)),
@@ -1782,7 +1782,7 @@ static int dav_method_proppatch(request_rec *r)
     /* ### validate "live" properties */
 
     /* set up an array to hold property operation contexts */
-    ctx_list = ap_make_array(r->pool, 10, sizeof(dav_prop_ctx));
+    ctx_list = apr_make_array(r->pool, 10, sizeof(dav_prop_ctx));
 
     /* do a first pass to ensure that all "remove" properties exist */
     for (child = doc->root->first_child; child; child = child->next) {
@@ -1811,7 +1811,7 @@ static int dav_method_proppatch(request_rec *r)
 	for (one_prop = prop_group->first_child; one_prop;
 	     one_prop = one_prop->next) {
 
-	    ctx = (dav_prop_ctx *)ap_push_array(ctx_list);
+	    ctx = (dav_prop_ctx *)apr_push_array(ctx_list);
 	    ctx->propdb = propdb;
 	    ctx->operation = is_remove ? DAV_PROP_OP_DELETE : DAV_PROP_OP_SET;
 	    ctx->prop = one_prop;
@@ -1867,8 +1867,8 @@ static int process_mkcol_body(request_rec *r)
      * return HTTP_UNSUPPORTED_MEDIA_TYPE (while ap_setup_client_block
      * returns HTTP_REQUEST_ENTITY_TOO_LARGE). */
 
-    const char *tenc = ap_table_get(r->headers_in, "Transfer-Encoding");
-    const char *lenp = ap_table_get(r->headers_in, "Content-Length");
+    const char *tenc = apr_table_get(r->headers_in, "Transfer-Encoding");
+    const char *lenp = apr_table_get(r->headers_in, "Content-Length");
 
     /* make sure to set the Apache request fields properly. */
     r->read_body = REQUEST_NO_BODY;
@@ -2073,21 +2073,21 @@ static int dav_method_copymove(request_rec *r, int is_move)
 
     /* If not a file or collection resource, COPY/MOVE not allowed */
     if (resource->type != DAV_RESOURCE_TYPE_REGULAR) {
-        body = ap_psprintf(r->pool,
+        body = apr_psprintf(r->pool,
                            "Cannot COPY/MOVE resource %s.",
                            ap_escape_html(r->pool, r->uri));
 	return dav_error_response(r, HTTP_METHOD_NOT_ALLOWED, body);
     }
 
     /* get the destination URI */
-    dest = ap_table_get(r->headers_in, "Destination");
+    dest = apr_table_get(r->headers_in, "Destination");
     if (dest == NULL) {
 	/* Look in headers provided by Netscape's Roaming Profiles */
-	const char *nscp_host = ap_table_get(r->headers_in, "Host");
-	const char *nscp_path = ap_table_get(r->headers_in, "New-uri");
+	const char *nscp_host = apr_table_get(r->headers_in, "Host");
+	const char *nscp_path = apr_table_get(r->headers_in, "New-uri");
 
 	if (nscp_host != NULL && nscp_path != NULL)
-	    dest = ap_psprintf(r->pool, "http://%s%s", nscp_host, nscp_path);
+	    dest = apr_psprintf(r->pool, "http://%s%s", nscp_host, nscp_path);
     }
     if (dest == NULL) {
 	/* This supplies additional information for the default message. */
@@ -2195,7 +2195,7 @@ static int dav_method_copymove(request_rec *r, int is_move)
                                        | DAV_VALIDATE_USE_424,
                                        NULL)) != NULL) {
 	err = dav_push_error(r->pool, err->status, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Could not MOVE %s due to a failed "
 					 "precondition on the source "
 					 "(e.g. locks).",
@@ -2219,7 +2219,7 @@ static int dav_method_copymove(request_rec *r, int is_move)
 				    DAV_VALIDATE_PARENT
                                     | DAV_VALIDATE_USE_424, NULL)) != NULL) {
 	err = dav_push_error(r->pool, err->status, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Could not MOVE/COPY %s due to a "
 					 "failed precondition on the "
 					 "destination (e.g. locks).",
@@ -2366,7 +2366,7 @@ static int dav_method_copymove(request_rec *r, int is_move)
 	    (*lockdb->hooks->close_lockdb)(lockdb);
 
 	err = dav_push_error(r->pool, err->status, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Could not MOVE/COPY %s.",
 					 ap_escape_html(r->pool, r->uri)),
 			     err);
@@ -2470,7 +2470,7 @@ static int dav_method_lock(request_rec *r)
         }
         new_lock_request = 1;
 
-        lock->auth_user = ap_pstrdup(r->pool, r->user);
+        lock->auth_user = apr_pstrdup(r->pool, r->user);
     }
 
     resource_state = dav_get_resource_state(r, resource);
@@ -2490,7 +2490,7 @@ static int dav_method_lock(request_rec *r)
                                     | DAV_VALIDATE_ADD_LD,
                                     lockdb)) != OK) {
 	err = dav_push_error(r->pool, err->status, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Could not LOCK %s due to a failed "
 					 "precondition (e.g. other locks).",
 					 ap_escape_html(r->pool, r->uri)),
@@ -2511,7 +2511,7 @@ static int dav_method_lock(request_rec *r)
 
 	if ((err = dav_get_locktoken_list(r, &ltl)) != NULL) {
 	    err = dav_push_error(r->pool, err->status, 0,
-				 ap_psprintf(r->pool,
+				 apr_psprintf(r->pool,
 					     "The lock refresh for %s failed "
 					     "because no lock tokens were "
 					     "specified in an \"If:\" "
@@ -2546,11 +2546,11 @@ static int dav_method_lock(request_rec *r)
 	    goto error;
 	}
 
-        locktoken_txt = ap_pstrcat(r->pool, "<",
+        locktoken_txt = apr_pstrcat(r->pool, "<",
 				   (*locks_hooks->format_locktoken)(r->pool, lock->locktoken),
 				   ">", NULL);
 
-	ap_table_set(r->headers_out, "Lock-Token", locktoken_txt);
+	apr_table_set(r->headers_out, "Lock-Token", locktoken_txt);
     }
 
     (*locks_hooks->close_lockdb)(lockdb);
@@ -2600,13 +2600,13 @@ static int dav_method_unlock(request_rec *r)
     if (locks_hooks == NULL)
         return DECLINED;
 
-    if ((const_locktoken_txt = ap_table_get(r->headers_in, "Lock-Token")) == NULL) {
+    if ((const_locktoken_txt = apr_table_get(r->headers_in, "Lock-Token")) == NULL) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
 		      "Unlock failed (%s):  No Lock-Token specified in header", r->filename);
 	return HTTP_BAD_REQUEST;
     }
 
-    locktoken_txt = ap_pstrdup(r->pool, const_locktoken_txt);
+    locktoken_txt = apr_pstrdup(r->pool, const_locktoken_txt);
     if (locktoken_txt[0] != '<') {
 	/* ### should provide more specifics... */
 	return HTTP_BAD_REQUEST;
@@ -2622,7 +2622,7 @@ static int dav_method_unlock(request_rec *r)
     if ((err = (*locks_hooks->parse_locktoken)(r->pool, locktoken_txt,
 					       &locktoken)) != NULL) {
 	err = dav_push_error(r->pool, HTTP_BAD_REQUEST, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "The UNLOCK on %s failed -- an "
 					 "invalid lock token was specified "
 					 "in the \"If:\" header.",
@@ -2735,7 +2735,7 @@ static int dav_method_checkout(request_rec *r)
     /* Do the checkout */
     if ((err = (*vsn_hooks->checkout)(resource)) != NULL) {
 	err = dav_push_error(r->pool, HTTP_CONFLICT, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Could not CHECKOUT resource %s.",
 					 ap_escape_html(r->pool, r->uri)),
 			     err);
@@ -2797,7 +2797,7 @@ static int dav_method_uncheckout(request_rec *r)
     /* Do the uncheckout */
     if ((err = (*vsn_hooks->uncheckout)(resource)) != NULL) {
 	err = dav_push_error(r->pool, HTTP_CONFLICT, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Could not UNCHECKOUT resource %s.",
 					 ap_escape_html(r->pool, r->uri)),
 			     err);
@@ -2859,7 +2859,7 @@ static int dav_method_checkin(request_rec *r)
     /* Do the checkin */
     if ((err = (*vsn_hooks->checkin)(resource)) != NULL) {
 	err = dav_push_error(r->pool, HTTP_CONFLICT, 0,
-			     ap_psprintf(r->pool,
+			     apr_psprintf(r->pool,
 					 "Could not CHECKIN resource %s.",
 					 ap_escape_html(r->pool, r->uri)),
 			     err);
@@ -3145,7 +3145,7 @@ AP_IMPLEMENT_HOOK_RUN_FIRST(const dav_hooks_db *, get_propdb_hooks,
                             (request_rec *r), (r), NULL);
 AP_IMPLEMENT_HOOK_RUN_FIRST(const dav_hooks_vsn *, get_vsn_hooks,
                             (request_rec *r), (r), NULL);
-AP_IMPLEMENT_HOOK_VOID(gather_propsets, (ap_array_header_t *uris), (uris))
+AP_IMPLEMENT_HOOK_VOID(gather_propsets, (apr_array_header_t *uris), (uris))
 AP_IMPLEMENT_HOOK_RUN_FIRST(int, find_liveprop,
                             (request_rec *r,
                              const char *ns_uri, const char *name,
diff --git a/modules/dav/main/mod_dav.h b/modules/dav/main/mod_dav.h
index 12b625e..bc12105 100644
--- a/modules/dav/main/mod_dav.h
+++ b/modules/dav/main/mod_dav.h
@@ -135,7 +135,7 @@ typedef struct dav_error {
     struct dav_error *prev;	/* previous error (in stack) */
 
     /* deferred computation of the description */
-    void (*compute_desc)(struct dav_error *err, ap_pool_t *p);
+    void (*compute_desc)(struct dav_error *err, apr_pool_t *p);
     int ctx_i;
     const char *ctx_s;
     void *ctx_p;
@@ -146,7 +146,7 @@ typedef struct dav_error {
 ** Create a new error structure. save_errno will be filled with the current
 ** errno value.
 */
-dav_error *dav_new_error(ap_pool_t *p, int status, int error_id, const char *desc);
+dav_error *dav_new_error(apr_pool_t *p, int status, int error_id, const char *desc);
 
 /*
 ** Push a new error description onto the stack of errors.
@@ -161,7 +161,7 @@ dav_error *dav_new_error(ap_pool_t *p, int status, int error_id, const char *des
 ** <error_id> can specify a new error_id since the topmost description has
 ** changed.
 */
-dav_error *dav_push_error(ap_pool_t *p, int status, int error_id, const char *desc,
+dav_error *dav_push_error(apr_pool_t *p, int status, int error_id, const char *desc,
 			  dav_error *prev);
 
 
@@ -304,31 +304,31 @@ typedef struct dav_locktoken dav_locktoken;
 /* buffer for reuse; can grow to accomodate needed size */
 typedef struct
 {
-    ap_size_t alloc_len;	/* how much has been allocated */
-    ap_size_t cur_len;		/* how much is currently being used */
+    apr_size_t alloc_len;	/* how much has been allocated */
+    apr_size_t cur_len;		/* how much is currently being used */
     char *buf;			/* buffer contents */
 } dav_buffer;
 #define DAV_BUFFER_MINSIZE	256	/* minimum size for buffer */
 #define DAV_BUFFER_PAD		64	/* amount of pad when growing */
 
 /* set the cur_len to the given size and ensure space is available */
-void dav_set_bufsize(ap_pool_t *p, dav_buffer *pbuf, ap_size_t size);
+void dav_set_bufsize(apr_pool_t *p, dav_buffer *pbuf, apr_size_t size);
 
 /* initialize a buffer and copy the specified (null-term'd) string into it */
-void dav_buffer_init(ap_pool_t *p, dav_buffer *pbuf, const char *str);
+void dav_buffer_init(apr_pool_t *p, dav_buffer *pbuf, const char *str);
 
 /* check that the buffer can accomodate <extra_needed> more bytes */
-void dav_check_bufsize(ap_pool_t *p, dav_buffer *pbuf, ap_size_t extra_needed);
+void dav_check_bufsize(apr_pool_t *p, dav_buffer *pbuf, apr_size_t extra_needed);
 
 /* append a string to the end of the buffer, adjust length */
-void dav_buffer_append(ap_pool_t *p, dav_buffer *pbuf, const char *str);
+void dav_buffer_append(apr_pool_t *p, dav_buffer *pbuf, const char *str);
 
 /* place a string on the end of the buffer, do NOT adjust length */
-void dav_buffer_place(ap_pool_t *p, dav_buffer *pbuf, const char *str);
+void dav_buffer_place(apr_pool_t *p, dav_buffer *pbuf, const char *str);
 
 /* place some memory on the end of a buffer; do NOT adjust length */
-void dav_buffer_place_mem(ap_pool_t *p, dav_buffer *pbuf, const void *mem,
-                          ap_size_t amt, ap_size_t pad);
+void dav_buffer_place_mem(apr_pool_t *p, dav_buffer *pbuf, const void *mem,
+                          apr_size_t amt, apr_size_t pad);
 
 
 /* --------------------------------------------------------------------
@@ -393,7 +393,7 @@ AP_DECLARE_HOOK(const dav_hooks_locks *, get_lock_hooks, (request_rec *r))
 AP_DECLARE_HOOK(const dav_hooks_propdb *, get_propdb_hooks, (request_rec *r))
 AP_DECLARE_HOOK(const dav_hooks_vsn *, get_vsn_hooks, (request_rec *r))
 
-AP_DECLARE_HOOK(void, gather_propsets, (ap_array_header_t *uris))
+AP_DECLARE_HOOK(void, gather_propsets, (apr_array_header_t *uris))
 AP_DECLARE_HOOK(int, find_liveprop, (request_rec *r,
                                      const char *ns_uri, const char *name,
                                      const dav_hooks_liveprop **hooks))
@@ -411,10 +411,10 @@ const dav_hooks_locks *dav_get_lock_hooks(request_rec *r);
 const dav_hooks_propdb *dav_get_propdb_hooks(request_rec *r);
 const dav_hooks_vsn *dav_get_vsn_hooks(request_rec *r);
 
-void dav_register_liveprop_namespace(ap_pool_t *pool, const char *uri);
+void dav_register_liveprop_namespace(apr_pool_t *pool, const char *uri);
 int dav_get_liveprop_ns_index(const char *uri);
 int dav_get_liveprop_ns_count(void);
-void dav_add_all_liveprop_xmlns(ap_pool_t *p, ap_text_header *phdr);
+void dav_add_all_liveprop_xmlns(apr_pool_t *p, ap_text_header *phdr);
 
 
 /* ### deprecated */
@@ -472,7 +472,7 @@ typedef struct dav_if_state_list
 typedef struct dav_if_header
 {
     const char *uri;
-    ap_size_t uri_len;
+    apr_size_t uri_len;
     struct dav_if_state_list *state;
     struct dav_if_header *next;
 
@@ -670,13 +670,13 @@ typedef struct dav_db dav_db;
 typedef struct
 {
     char *dptr;
-    ap_size_t dsize;
+    apr_size_t dsize;
 } dav_datum;
 
 /* hook functions to enable pluggable databases */
 struct dav_hooks_propdb
 {
-    dav_error * (*open)(ap_pool_t *p, const dav_resource *resource, int ro,
+    dav_error * (*open)(apr_pool_t *p, const dav_resource *resource, int ro,
 			dav_db **pdb);
     void (*close)(dav_db *db);
 
@@ -860,7 +860,7 @@ struct dav_hooks_locks
      * in the given pool.
      */
     dav_error * (*parse_locktoken)(
-        ap_pool_t *p,
+        apr_pool_t *p,
         const char *char_token,
         dav_locktoken **locktoken_p
     );
@@ -871,7 +871,7 @@ struct dav_hooks_locks
      * Always returns non-NULL.
      */
     const char * (*format_locktoken)(
-        ap_pool_t *p,
+        apr_pool_t *p,
         const dav_locktoken *locktoken
     );
 
@@ -1064,7 +1064,7 @@ dav_error *dav_open_propdb(
     dav_lockdb *lockdb,
     dav_resource *resource,
     int ro,
-    ap_array_header_t *ns_xlate,
+    apr_array_header_t *ns_xlate,
     dav_propdb **propdb);
 
 void dav_close_propdb(dav_propdb *db);
@@ -1169,7 +1169,7 @@ typedef struct dav_walker_ctx
 #define DAV_CALLTYPE_LOCKNULL	3	/* called for a locknull resource */
 #define DAV_CALLTYPE_POSTFIX	4	/* postfix call for a collection */
 
-    ap_pool_t *pool;
+    apr_pool_t *pool;
 
     request_rec *r;			/* original request */
     dav_buffer uri;			/* current URI */
@@ -1330,7 +1330,7 @@ struct dav_hooks_repository
     ** on each call, until the EOF condition is met.
     */
     dav_error * (*read_stream)(dav_stream *stream,
-			       void *buf, ap_size_t *bufsize);
+			       void *buf, apr_size_t *bufsize);
 
     /*
     ** Write data to the stream.
@@ -1338,7 +1338,7 @@ struct dav_hooks_repository
     ** All of the bytes must be written, or an error should be returned.
     */
     dav_error * (*write_stream)(dav_stream *stream,
-				const void *buf, ap_size_t bufsize);
+				const void *buf, apr_size_t bufsize);
 
     /*
     ** Seek to an absolute position in the stream. This is used to support
@@ -1387,7 +1387,7 @@ struct dav_hooks_repository
      * is a collection.
      */
     dav_error * (*create_collection)(
-        ap_pool_t *p, dav_resource *resource
+        apr_pool_t *p, dav_resource *resource
     );
 
     /* Copy one resource to another. The destination must not exist.
@@ -1551,10 +1551,10 @@ struct dav_hooks_vsn
 */
 
 /* allow providers access to the per-directory parameters */
-ap_table_t *dav_get_dir_params(const request_rec *r);
+apr_table_t *dav_get_dir_params(const request_rec *r);
 
 /* fetch the "LimitXMLRequestBody" in force for this resource */
-ap_size_t dav_get_limit_xml_body(const request_rec *r);
+apr_size_t dav_get_limit_xml_body(const request_rec *r);
 
 typedef struct {
     int propid;				/* live property ID */
diff --git a/modules/dav/main/props.c b/modules/dav/main/props.c
index dc25925..e2ea30b 100644
--- a/modules/dav/main/props.c
+++ b/modules/dav/main/props.c
@@ -240,7 +240,7 @@ typedef struct {
 struct dav_propdb {
     int version;		/* *minor* version of this db */
 
-    ap_pool_t *p;		/* the pool we should use */
+    apr_pool_t *p;		/* the pool we should use */
     request_rec *r;		/* the request record */
 
     dav_resource *resource;	/* the target resource */
@@ -252,7 +252,7 @@ struct dav_propdb {
     short ns_count;		/* number of entries in table */
     int ns_table_dirty;		/* ns_table was modified */
 
-    ap_array_header_t *ns_xlate;	/* translation of an elem->ns to URI */
+    apr_array_header_t *ns_xlate;	/* translation of an elem->ns to URI */
     int *ns_map;		/* map elem->ns to propdb ns values */
     int incomplete_map;		/* some mappings do not exist */
 
@@ -488,7 +488,7 @@ static dav_error * dav_insert_coreprop(dav_propdb *propdb,
 						&propdb->wb_lock);
 
 		/* make a copy to isolate it from changes to wb_lock */
-		value = ap_pstrdup(propdb->p, propdb->wb_lock.buf);
+		value = apr_pstrdup(propdb->p, propdb->wb_lock.buf);
 	    }
         }
 	break;
@@ -515,7 +515,7 @@ static dav_error * dav_insert_coreprop(dav_propdb *propdb,
 	if (propdb->subreq == NULL) {
 	    dav_do_prop_subreq(propdb);
 	}
-	if ((lang = ap_table_get(propdb->subreq->headers_out,
+	if ((lang = apr_table_get(propdb->subreq->headers_out,
 				 "Content-Language")) != NULL) {
 	    value = lang;
 	}
@@ -534,12 +534,12 @@ static dav_error * dav_insert_coreprop(dav_propdb *propdb,
 
 	if (getvals && *value != '\0') {
 	    /* use D: prefix to refer to the DAV: namespace URI */
-	    s = ap_psprintf(propdb->p, "<D:%s>%s</D:%s>" DEBUG_CR,
+	    s = apr_psprintf(propdb->p, "<D:%s>%s</D:%s>" DEBUG_CR,
 			    name, value, name);
 	}
 	else {
 	    /* use D: prefix to refer to the DAV: namespace URI */
-	    s = ap_psprintf(propdb->p, "<D:%s/>" DEBUG_CR, name);
+	    s = apr_psprintf(propdb->p, "<D:%s/>" DEBUG_CR, name);
 	}
 	ap_text_append(propdb->p, phdr, s);
 
@@ -597,29 +597,29 @@ static void dav_append_prop(dav_propdb *propdb,
 	/* the property is an empty value */
 	if (*name == ':') {
 	    /* "no namespace" case */
-	    s = ap_psprintf(propdb->p, "<%s/>" DEBUG_CR, name+1);
+	    s = apr_psprintf(propdb->p, "<%s/>" DEBUG_CR, name+1);
 	}
 	else {
-	    s = ap_psprintf(propdb->p, "<ns%s/>" DEBUG_CR, name);
+	    s = apr_psprintf(propdb->p, "<ns%s/>" DEBUG_CR, name);
 	}
     }
     else if (*lang != '\0') {
 	if (*name == ':') {
 	    /* "no namespace" case */
-	    s = ap_psprintf(propdb->p, "<%s xml:lang=\"%s\">%s</%s>" DEBUG_CR,
+	    s = apr_psprintf(propdb->p, "<%s xml:lang=\"%s\">%s</%s>" DEBUG_CR,
 			    name+1, lang, value, name+1);
 	}
 	else {
-	    s = ap_psprintf(propdb->p, "<ns%s xml:lang=\"%s\">%s</ns%s>" DEBUG_CR,
+	    s = apr_psprintf(propdb->p, "<ns%s xml:lang=\"%s\">%s</ns%s>" DEBUG_CR,
 			    name, lang, value, name);
 	}
     }
     else if (*name == ':') {
 	/* "no namespace" case */
-	s = ap_psprintf(propdb->p, "<%s>%s</%s>" DEBUG_CR, name+1, value, name+1);
+	s = apr_psprintf(propdb->p, "<%s>%s</%s>" DEBUG_CR, name+1, value, name+1);
     }
     else {
-	s = ap_psprintf(propdb->p, "<ns%s>%s</ns%s>" DEBUG_CR, name, value, name);
+	s = apr_psprintf(propdb->p, "<ns%s>%s</ns%s>" DEBUG_CR, name, value, name);
     }
     ap_text_append(propdb->p, phdr, s);
 }
@@ -662,7 +662,7 @@ static void dav_prep_ns_map(dav_propdb *propdb, int add_ns)
 	}
     }
     else {
-	propdb->ns_map = ap_palloc(propdb->p, propdb->ns_xlate->nelts * sizeof(*propdb->ns_map));
+	propdb->ns_map = apr_palloc(propdb->p, propdb->ns_xlate->nelts * sizeof(*propdb->ns_map));
     }
 
     pmap = propdb->ns_map;
@@ -762,12 +762,12 @@ static int dav_find_dav_id(dav_propdb *propdb)
     return -1;
 }
 
-static void dav_insert_xmlns(ap_pool_t *p, const char *pre_prefix, int ns,
+static void dav_insert_xmlns(apr_pool_t *p, const char *pre_prefix, int ns,
 			     const char *ns_uri, ap_text_header *phdr)
 {
     const char *s;
 
-    s = ap_psprintf(p, " xmlns:%s%d=\"%s\"", pre_prefix, ns, ns_uri);
+    s = apr_psprintf(p, " xmlns:%s%d=\"%s\"", pre_prefix, ns, ns_uri);
     ap_text_append(p, phdr, s);
 }
 
@@ -789,7 +789,7 @@ static void dav_get_propdb_xmlns(dav_propdb *propdb, ap_text_header *phdr)
 
 /* add a namespace decl from one of the namespace tables */
 static void dav_add_marked_xmlns(dav_propdb *propdb, char *marks, int ns,
-				 ap_array_header_t *ns_table,
+				 apr_array_header_t *ns_table,
 				 const char *pre_prefix,
 				 ap_text_header *phdr)
 {
@@ -945,10 +945,10 @@ static dav_error *dav_really_open_db(dav_propdb *propdb, int ro)
 dav_error *dav_open_propdb(request_rec *r, dav_lockdb *lockdb,
 			   dav_resource *resource,
 			   int ro,
-			   ap_array_header_t * ns_xlate,
+			   apr_array_header_t * ns_xlate,
 			   dav_propdb **p_propdb)
 {
-    dav_propdb *propdb = ap_pcalloc(r->pool, sizeof(*propdb));
+    dav_propdb *propdb = apr_pcalloc(r->pool, sizeof(*propdb));
     dav_error *err;
 
     *p_propdb = NULL;
@@ -1191,10 +1191,10 @@ dav_get_props_result dav_get_props(dav_propdb *propdb, ap_xml_doc *doc)
     /* ### the marks should be in a buffer! */
     /* allocate zeroed-memory for the marks. These marks indicate which
        input namespaces we've generated into the output xmlns buffer */
-    marks_input = ap_pcalloc(propdb->p, propdb->ns_xlate->nelts);
+    marks_input = apr_pcalloc(propdb->p, propdb->ns_xlate->nelts);
 
     /* same for the liveprops */
-    marks_liveprop = ap_pcalloc(propdb->p, dav_get_liveprop_ns_count() + 1);
+    marks_liveprop = apr_pcalloc(propdb->p, dav_get_liveprop_ns_count() + 1);
 
     for (elem = elem->first_child; elem; elem = elem->next) {
 	dav_datum key;
@@ -1213,7 +1213,7 @@ dav_get_props_result dav_get_props(dav_propdb *propdb, ap_xml_doc *doc)
 	}
 
 	if (elem->private == NULL) {
-	    elem->private = ap_pcalloc(propdb->p, sizeof(*priv));
+	    elem->private = apr_pcalloc(propdb->p, sizeof(*priv));
 	}
 	priv = elem->private;
 
@@ -1284,14 +1284,14 @@ dav_get_props_result dav_get_props(dav_propdb *propdb, ap_xml_doc *doc)
 		     * elem has a prefix already (xml...:name) or the elem
 		     * simply has no namespace.
 		     */
-		    s = ap_psprintf(propdb->p, "<%s/>" DEBUG_CR, elem->name);
+		    s = apr_psprintf(propdb->p, "<%s/>" DEBUG_CR, elem->name);
 		}
 		else {
 		    /* ensure that an xmlns is generated for the
 		       input namespace */
 		    dav_add_marked_xmlns(propdb, marks_input, elem->ns,
 					 propdb->ns_xlate, "i", &hdr_ns);
-		    s = ap_psprintf(propdb->p, "<i%d:%s/>" DEBUG_CR,
+		    s = apr_psprintf(propdb->p, "<i%d:%s/>" DEBUG_CR,
 				    elem->ns, elem->name);
 		}
 		ap_text_append(propdb->p, &hdr_bad, s);
@@ -1347,7 +1347,7 @@ void dav_prop_validate(dav_prop_ctx *ctx)
     ap_xml_elem *prop = ctx->prop;
     dav_elem_private *priv;
 
-    priv = ctx->prop->private = ap_pcalloc(propdb->p, sizeof(*priv));
+    priv = ctx->prop->private = apr_pcalloc(propdb->p, sizeof(*priv));
 
     /*
     ** Check to see if this is a live property, and fill the fields
@@ -1437,7 +1437,7 @@ void dav_prop_exec(dav_prop_ctx *ctx)
     dav_rollback_item *rollback;
     dav_elem_private *priv = ctx->prop->private;
 
-    rollback = ap_pcalloc(propdb->p, sizeof(*rollback));
+    rollback = apr_pcalloc(propdb->p, sizeof(*rollback));
     ctx->rollback = rollback;
 
     if (ctx->is_liveprop) {
diff --git a/modules/dav/main/util.c b/modules/dav/main/util.c
index 48f55bb..187bfbd 100644
--- a/modules/dav/main/util.c
+++ b/modules/dav/main/util.c
@@ -66,10 +66,10 @@
 #include "http_protocol.h"
 
 
-dav_error *dav_new_error(ap_pool_t *p, int status, int error_id, const char *desc)
+dav_error *dav_new_error(apr_pool_t *p, int status, int error_id, const char *desc)
 {
     int save_errno = errno;
-    dav_error *err = ap_pcalloc(p, sizeof(*err));
+    dav_error *err = apr_pcalloc(p, sizeof(*err));
 
     /* DBG3("dav_new_error: %d %d %s", status, error_id, desc ? desc : "(no desc)"); */
 
@@ -81,10 +81,10 @@ dav_error *dav_new_error(ap_pool_t *p, int status, int error_id, const char *des
     return err;
 }
 
-dav_error *dav_push_error(ap_pool_t *p, int status, int error_id, const char *desc,
+dav_error *dav_push_error(apr_pool_t *p, int status, int error_id, const char *desc,
 			  dav_error *prev)
 {
-    dav_error *err = ap_pcalloc(p, sizeof(*err));
+    dav_error *err = apr_pcalloc(p, sizeof(*err));
 
     err->status = status;
     err->error_id = error_id;
@@ -94,20 +94,20 @@ dav_error *dav_push_error(ap_pool_t *p, int status, int error_id, const char *de
     return err;
 }
 
-void dav_check_bufsize(ap_pool_t * p, dav_buffer *pbuf, size_t extra_needed)
+void dav_check_bufsize(apr_pool_t * p, dav_buffer *pbuf, size_t extra_needed)
 {
     /* grow the buffer if necessary */
     if (pbuf->cur_len + extra_needed > pbuf->alloc_len) {
 	char *newbuf;
 
 	pbuf->alloc_len += extra_needed + DAV_BUFFER_PAD;
-	newbuf = ap_palloc(p, pbuf->alloc_len);
+	newbuf = apr_palloc(p, pbuf->alloc_len);
 	memcpy(newbuf, pbuf->buf, pbuf->cur_len);
 	pbuf->buf = newbuf;
     }
 }
 
-void dav_set_bufsize(ap_pool_t * p, dav_buffer *pbuf, size_t size)
+void dav_set_bufsize(apr_pool_t * p, dav_buffer *pbuf, size_t size)
 {
     /* NOTE: this does not retain prior contents */
 
@@ -121,21 +121,21 @@ void dav_set_bufsize(ap_pool_t * p, dav_buffer *pbuf, size_t size)
 	if (pbuf->alloc_len < DAV_BUFFER_MINSIZE)
 	    pbuf->alloc_len = DAV_BUFFER_MINSIZE;
 
-	pbuf->buf = ap_palloc(p, pbuf->alloc_len);
+	pbuf->buf = apr_palloc(p, pbuf->alloc_len);
     }
     pbuf->cur_len = size;
 }
 
 
 /* initialize a buffer and copy the specified (null-term'd) string into it */
-void dav_buffer_init(ap_pool_t *p, dav_buffer *pbuf, const char *str)
+void dav_buffer_init(apr_pool_t *p, dav_buffer *pbuf, const char *str)
 {
     dav_set_bufsize(p, pbuf, strlen(str));
     memcpy(pbuf->buf, str, pbuf->cur_len + 1);
 }
 
 /* append a string to the end of the buffer, adjust length */
-void dav_buffer_append(ap_pool_t *p, dav_buffer *pbuf, const char *str)
+void dav_buffer_append(apr_pool_t *p, dav_buffer *pbuf, const char *str)
 {
     size_t len = strlen(str);
 
@@ -145,7 +145,7 @@ void dav_buffer_append(ap_pool_t *p, dav_buffer *pbuf, const char *str)
 }
 
 /* place a string on the end of the buffer, do NOT adjust length */
-void dav_buffer_place(ap_pool_t *p, dav_buffer *pbuf, const char *str)
+void dav_buffer_place(apr_pool_t *p, dav_buffer *pbuf, const char *str)
 {
     size_t len = strlen(str);
 
@@ -154,7 +154,7 @@ void dav_buffer_place(ap_pool_t *p, dav_buffer *pbuf, const char *str)
 }
 
 /* place some memory on the end of a buffer; do NOT adjust length */
-void dav_buffer_place_mem(ap_pool_t *p, dav_buffer *pbuf, const void *mem,
+void dav_buffer_place_mem(apr_pool_t *p, dav_buffer *pbuf, const void *mem,
                           size_t amt, size_t pad)
 {
     dav_check_bufsize(p, pbuf, amt + pad);
@@ -209,7 +209,7 @@ dav_lookup_result dav_lookup_uri(const char *uri, request_rec * r)
     if (strcasecmp(comp.scheme, scheme) != 0 ||
 	comp.port != port) {
 	result.err.status = HTTP_BAD_GATEWAY;
-	result.err.desc = ap_psprintf(r->pool,
+	result.err.desc = apr_psprintf(r->pool,
 				      "Destination URI refers to different "
 				      "scheme or port (%s://hostname:%d)" 
                                       APR_EOL_STR "(want: %s://hostname:%d)",
@@ -242,7 +242,7 @@ dav_lookup_result dav_lookup_uri(const char *uri, request_rec * r)
     */
     if (strrchr(comp.hostname, '.') == NULL &&
 	(domain = strchr(r->server->server_hostname, '.')) != NULL) {
-	comp.hostname = ap_pstrcat(r->pool, comp.hostname, domain, NULL);
+	comp.hostname = apr_pstrcat(r->pool, comp.hostname, domain, NULL);
     }
 
     /* now, if a hostname was provided, then verify that it represents the
@@ -313,8 +313,8 @@ time_t dav_get_timeout(request_rec *r)
 {
     time_t now, expires = DAV_TIMEOUT_INFINITE;
 
-    const char *timeout_const = ap_table_get(r->headers_in, "Timeout");
-    const char *timeout = ap_pstrdup(r->pool, timeout_const), *val;
+    const char *timeout_const = apr_table_get(r->headers_in, "Timeout");
+    const char *timeout = apr_pstrdup(r->pool, timeout_const), *val;
 
     if (timeout == NULL)
 	return DAV_TIMEOUT_INFINITE;
@@ -350,12 +350,12 @@ time_t dav_get_timeout(request_rec *r)
 
 /* add_if_resource returns a new if_header, linking it to next_ih.
  */
-static dav_if_header *dav_add_if_resource(ap_pool_t *p, dav_if_header *next_ih,
+static dav_if_header *dav_add_if_resource(apr_pool_t *p, dav_if_header *next_ih,
 					  const char *uri, size_t uri_len)
 {
     dav_if_header *ih;
 
-    if ((ih = ap_pcalloc(p, sizeof(*ih))) == NULL)
+    if ((ih = apr_pcalloc(p, sizeof(*ih))) == NULL)
 	return NULL;
 
     ih->uri = uri;
@@ -367,14 +367,14 @@ static dav_if_header *dav_add_if_resource(ap_pool_t *p, dav_if_header *next_ih,
 
 /* add_if_state adds a condition to an if_header.
  */
-static dav_error * dav_add_if_state(ap_pool_t *p, dav_if_header *ih,
+static dav_error * dav_add_if_state(apr_pool_t *p, dav_if_header *ih,
 				    const char *state_token,
 				    dav_if_state_type t, int condition,
 				    const dav_hooks_locks *locks_hooks)
 {
     dav_if_state_list *new_sl;
 
-    new_sl = ap_pcalloc(p, sizeof(*new_sl));
+    new_sl = apr_pcalloc(p, sizeof(*new_sl));
 
     new_sl->condition = condition;
     new_sl->type      = t;
@@ -444,7 +444,7 @@ static dav_error * dav_process_if_header(request_rec *r, dav_if_header **p_ih)
 	
     *p_ih = NULL;
 
-    if ((str = ap_pstrdup(r->pool, ap_table_get(r->headers_in, "If"))) == NULL)
+    if ((str = apr_pstrdup(r->pool, apr_table_get(r->headers_in, "If"))) == NULL)
 	return NULL;
 
     while (*str) {
@@ -556,7 +556,7 @@ static dav_error * dav_process_if_header(request_rec *r, dav_if_header **p_ih)
 		default:
 		    return dav_new_error(r->pool, HTTP_BAD_REQUEST,
 					 DAV_ERR_IF_UNK_CHAR,
-                                         ap_psprintf(r->pool,
+                                         apr_psprintf(r->pool,
                                                      "Invalid \"If:\" "
                                                      "header: Unexpected "
                                                      "character encountered "
@@ -575,7 +575,7 @@ static dav_error * dav_process_if_header(request_rec *r, dav_if_header **p_ih)
 	default:
 	    return dav_new_error(r->pool, HTTP_BAD_REQUEST,
 				 DAV_ERR_IF_UNK_CHAR,
-                                 ap_psprintf(r->pool,
+                                 apr_psprintf(r->pool,
                                              "Invalid \"If:\" header: "
                                              "Unexpected character "
                                              "encountered (0x%02x, '%c').",
@@ -634,7 +634,7 @@ static int dav_find_submitted_locktoken(const dav_if_header *if_header,
 /* dav_validate_resource_state:
  *    Returns NULL if path/uri meets if-header and lock requirements
  */
-static dav_error * dav_validate_resource_state(ap_pool_t *p,
+static dav_error * dav_validate_resource_state(apr_pool_t *p,
 					       const dav_resource *resource,
 					       dav_lockdb *lockdb,
 					       const dav_if_header *if_header,
@@ -981,7 +981,7 @@ static dav_error * dav_validate_resource_state(ap_pool_t *p,
                          strcmp(lock->auth_user, r->user))) {
                         const char *errmsg;
 
-                        errmsg = ap_pstrcat(p, "User \"",
+                        errmsg = apr_pstrcat(p, "User \"",
                                             r->user, 
                                             "\" submitted a locktoken created "
                                             "by user \"",
@@ -1118,7 +1118,7 @@ static dav_error * dav_validate_resource_state(ap_pool_t *p,
 	}
 
 	return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0,
-			     ap_psprintf(p,
+			     apr_psprintf(p,
 					 "The precondition(s) specified by "
 					 "the \"If:\" header did not match "
 					 "this resource. At least one "
@@ -1267,12 +1267,12 @@ dav_error * dav_validate_request(request_rec *r, dav_resource *resource,
     if (locktoken != NULL) {
 	dav_if_header *ifhdr_new;
 
-	ifhdr_new = ap_pcalloc(r->pool, sizeof(*ifhdr_new));
+	ifhdr_new = apr_pcalloc(r->pool, sizeof(*ifhdr_new));
 	ifhdr_new->uri = resource->uri;
 	ifhdr_new->uri_len = strlen(resource->uri);
 	ifhdr_new->dummy_header = 1;
 
-	ifhdr_new->state = ap_pcalloc(r->pool, sizeof(*ifhdr_new->state));
+	ifhdr_new->state = apr_pcalloc(r->pool, sizeof(*ifhdr_new->state));
 	ifhdr_new->state->type = dav_if_opaquelock;
 	ifhdr_new->state->condition = DAV_IF_COND_NORMAL;
 	ifhdr_new->state->locktoken = locktoken;
@@ -1353,7 +1353,7 @@ dav_error * dav_validate_request(request_rec *r, dav_resource *resource,
 	    ** into a multistatus response.
 	    */
 	    if (err != NULL) {
-		new_response = ap_pcalloc(r->pool, sizeof(*new_response));
+		new_response = apr_pcalloc(r->pool, sizeof(*new_response));
 		
 		new_response->href = parent_resource->uri;
 		new_response->status = err->status;
@@ -1362,7 +1362,7 @@ dav_error * dav_validate_request(request_rec *r, dav_resource *resource,
 		    "preventing the operation on the resource specified by "
 		    "the Request-URI.";
                 if (err->desc != NULL) {
-                    new_response->desc = ap_pstrcat(r->pool,
+                    new_response->desc = apr_pstrcat(r->pool,
                                                     new_response->desc,
                                                     " The error was: ",
                                                     err->desc, NULL);
@@ -1407,7 +1407,7 @@ dav_error * dav_validate_request(request_rec *r, dav_resource *resource,
         ** For other methods, return a simple 424.
         */
         if ((flags & DAV_VALIDATE_ADD_LD) != 0) {
-            propstat = ap_pcalloc(r->pool, sizeof(*propstat));
+            propstat = apr_pcalloc(r->pool, sizeof(*propstat));
             propstat->text =
                 "<D:propstat>" DEBUG_CR
                 "<D:prop><D:lockdiscovery/></D:prop>" DEBUG_CR
@@ -1416,7 +1416,7 @@ dav_error * dav_validate_request(request_rec *r, dav_resource *resource,
         }
 
         /* create the 424 response */
-        new_response = ap_pcalloc(r->pool, sizeof(*new_response));
+        new_response = apr_pcalloc(r->pool, sizeof(*new_response));
         new_response->href = resource->uri;
         new_response->status = HTTP_FAILED_DEPENDENCY;
         new_response->propresult.propstats = propstat;
@@ -1460,7 +1460,7 @@ dav_error * dav_get_locktoken_list(request_rec *r, dav_locktoken_list **ltl)
 	while (if_state != NULL)	{
 	    if (if_state->condition == DAV_IF_COND_NORMAL
 	        && if_state->type == dav_if_opaquelock) {
-		lock_token = ap_pcalloc(r->pool, sizeof(dav_locktoken_list));
+		lock_token = apr_pcalloc(r->pool, sizeof(dav_locktoken_list));
 		lock_token->locktoken = if_state->locktoken;
 		lock_token->next = *ltl;
 		*ltl = lock_token;
@@ -1486,7 +1486,7 @@ dav_error * dav_get_locktoken_list(request_rec *r, dav_locktoken_list **ltl)
  */
 const char *dav_get_target_selector(request_rec *r)
 {
-    return ap_table_get(r->headers_in, "Target-Selector");
+    return apr_table_get(r->headers_in, "Target-Selector");
 }
 
 /* Ensure that a resource is writable. If there is no versioning
@@ -1542,7 +1542,7 @@ dav_error *dav_ensure_resource_writable(request_rec *r,
     if (!resource->exists || parent_only) {
 	parent = (*resource->hooks->get_parent_resource)(resource);
         if (parent == NULL || !parent->exists) {
-	    body = ap_psprintf(r->pool,
+	    body = apr_psprintf(r->pool,
 			       "Missing one or more intermediate collections. "
 			       "Cannot create resource %s.",
 			       ap_escape_html(r->pool, resource->uri));
@@ -1577,7 +1577,7 @@ dav_error *dav_ensure_resource_writable(request_rec *r,
 	/* parent must be checked out */
 	if (!parent->working) {
 	    if ((err = (*vsn_hooks->checkout)(parent)) != NULL) {
-		body = ap_psprintf(r->pool,
+		body = apr_psprintf(r->pool,
 				   "Unable to checkout parent collection. "
 				   "Cannot create resource %s.",
 				   ap_escape_html(r->pool, resource->uri));
@@ -1588,7 +1588,7 @@ dav_error *dav_ensure_resource_writable(request_rec *r,
 	/* if not just checking parent, create new child resource */
         if (!parent_only) {
 	    if ((err = (*vsn_hooks->mkresource)(resource)) != NULL) {
-	        body = ap_psprintf(r->pool,
+	        body = apr_psprintf(r->pool,
 			           "Unable to create versioned resource %s.",
 			           ap_escape_html(r->pool, resource->uri));
 	        return dav_push_error(r->pool, HTTP_CONFLICT, 0, body, err);
@@ -1608,7 +1608,7 @@ dav_error *dav_ensure_resource_writable(request_rec *r,
     /* if not just checking parent, make sure child resource is checked out */
     if (!parent_only && !resource->working) {
 	if ((err = (*vsn_hooks->checkout)(resource)) != NULL) {
-	    body = ap_psprintf(r->pool,
+	    body = apr_psprintf(r->pool,
 			       "Unable to checkout resource %s.",
 			       ap_escape_html(r->pool, resource->uri));
 	    return dav_push_error(r->pool, HTTP_CONFLICT, 0, body, err);
@@ -1649,7 +1649,7 @@ dav_error *dav_revert_resource_writability(request_rec *r,
                 err = (*vsn_hooks->checkin)(resource);
 
             if (err != NULL) {
-	        body = ap_psprintf(r->pool,
+	        body = apr_psprintf(r->pool,
 			           "Unable to %s resource %s.",
                                    undo ? "uncheckout" : "checkin",
 			           ap_escape_html(r->pool, resource->uri));
@@ -1664,7 +1664,7 @@ dav_error *dav_revert_resource_writability(request_rec *r,
 	    /* ### should we do anything with the response? */
             if ((err = (*resource->hooks->remove_resource)(resource,
 							   &response)) != NULL) {
-	        body = ap_psprintf(r->pool,
+	        body = apr_psprintf(r->pool,
 			           "Unable to undo creation of resource %s.",
 			           ap_escape_html(r->pool, resource->uri));
                 return dav_push_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -1682,7 +1682,7 @@ dav_error *dav_revert_resource_writability(request_rec *r,
 	    err = (*vsn_hooks->checkin)(parent_resource);
 
 	if (err != NULL) {
-	    body = ap_psprintf(r->pool,
+	    body = apr_psprintf(r->pool,
 			       "Unable to %s parent collection of %s.",
 			       undo ? "uncheckout" : "checkin",
 			       ap_escape_html(r->pool, resource->uri));
diff --git a/modules/dav/main/util_lock.c b/modules/dav/main/util_lock.c
index 6adfdf7..1245416 100644
--- a/modules/dav/main/util_lock.c
+++ b/modules/dav/main/util_lock.c
@@ -81,7 +81,7 @@ const char *dav_lock_get_activelock(request_rec *r, dav_lock *lock,
     const dav_hooks_locks *hooks = DAV_GET_HOOKS_LOCKS(r);
     int count = 0;
     dav_buffer work_buf = { 0 };
-    ap_pool_t *p = r->pool;
+    apr_pool_t *p = r->pool;
 
     /* If no locks or no lock provider, there are no locks */
     if (lock == NULL || hooks == NULL) {
@@ -197,7 +197,7 @@ dav_error * dav_lock_parse_lockinfo(request_rec *r,
 				    const ap_xml_doc *doc,
 				    dav_lock **lock_request)
 {
-    ap_pool_t *p = r->pool;
+    apr_pool_t *p = r->pool;
     dav_error *err;
     ap_xml_elem *child;
     dav_lock *lock;
@@ -262,7 +262,7 @@ dav_error * dav_lock_parse_lockinfo(request_rec *r,
 	}
 
 	return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0,
-			     ap_psprintf(p,
+			     apr_psprintf(p,
 					 "The server cannot satisfy the "
 					 "LOCK request due to an unknown XML "
 					 "element (\"%s\") within the "
@@ -428,7 +428,7 @@ static dav_error * dav_unlock_walker(dav_walker_ctx *ctx, int calltype)
 ** namespace [repository] hierarchy. Note that some lock providers may be
 ** able to return this information with a traversal.
 */
-static dav_error * dav_get_direct_resource(ap_pool_t *p,
+static dav_error * dav_get_direct_resource(apr_pool_t *p,
 					   dav_lockdb *lockdb,
 					   const dav_locktoken *locktoken,
 					   const dav_resource *resource,
diff --git a/modules/echo/mod_echo.c b/modules/echo/mod_echo.c
index 14582a6..011c23e 100644
--- a/modules/echo/mod_echo.c
+++ b/modules/echo/mod_echo.c
@@ -69,9 +69,9 @@ typedef struct
     int bEnabled;
     } EchoConfig;
 
-static void *create_echo_server_config(ap_pool_t *p,server_rec *s)
+static void *create_echo_server_config(apr_pool_t *p,server_rec *s)
     {
-    EchoConfig *pConfig=ap_pcalloc(p,sizeof *pConfig);
+    EchoConfig *pConfig=apr_pcalloc(p,sizeof *pConfig);
 
     pConfig->bEnabled=0;
 
@@ -98,7 +98,7 @@ static int process_echo_connection(conn_rec *c)
 
     for( ; ; )
 	{
-	ap_ssize_t r, w;
+	apr_ssize_t r, w;
         (void) ap_bread(c->client,buf,sizeof buf,&r);
 	if(r <= 0)
 	    break;
@@ -128,7 +128,7 @@ API_VAR_EXPORT module echo_module = {
     NULL,			/* merge per-directory config structures */
     create_echo_server_config,	/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    echo_cmds,			/* command ap_table_t */
+    echo_cmds,			/* command apr_table_t */
     NULL,			/* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/experimental/mod_charset_lite.c b/modules/experimental/mod_charset_lite.c
index c0e5532..a5b8371 100644
--- a/modules/experimental/mod_charset_lite.c
+++ b/modules/experimental/mod_charset_lite.c
@@ -92,14 +92,14 @@ typedef struct charset_dir_t {
 
 module charset_lite_module;
 
-static void *create_charset_dir_conf(ap_pool_t *p,char *dummy)
+static void *create_charset_dir_conf(apr_pool_t *p,char *dummy)
 {
-  return ap_pcalloc(p,sizeof(charset_dir_t));
+  return apr_pcalloc(p,sizeof(charset_dir_t));
 }
 
-static void *merge_charset_dir_conf(ap_pool_t *p, void *basev, void *overridesv)
+static void *merge_charset_dir_conf(apr_pool_t *p, void *basev, void *overridesv)
 {
-    charset_dir_t *a = (charset_dir_t *)ap_pcalloc (p, sizeof(charset_dir_t));
+    charset_dir_t *a = (charset_dir_t *)apr_pcalloc (p, sizeof(charset_dir_t));
     charset_dir_t *base = (charset_dir_t *)basev,
         *over = (charset_dir_t *)overridesv;
 
@@ -154,8 +154,8 @@ static const char *add_charset_debug(cmd_parms *cmd, charset_dir_t *dc, int arg)
 static int find_code_page(request_rec *r)
 {
     charset_dir_t *dc = ap_get_module_config(r->per_dir_config, &charset_lite_module);
-    ap_status_t rv;
-    ap_xlate_t *input_xlate, *output_xlate;
+    apr_status_t rv;
+    apr_xlate_t *input_xlate, *output_xlate;
     const char *mime_type;
     int debug = dc->debug == DEBUG;
 
diff --git a/modules/experimental/mod_example.c b/modules/experimental/mod_example.c
index 223a744..fbea022 100644
--- a/modules/experimental/mod_example.c
+++ b/modules/experimental/mod_example.c
@@ -118,7 +118,7 @@ typedef struct excfg {
  * the same routine/environment.
  */
 static const char *trace = NULL;
-static ap_table_t *static_calls_made = NULL;
+static apr_table_t *static_calls_made = NULL;
 
 /*
  * To avoid leaking memory from pools other than the per-request one, we
@@ -126,8 +126,8 @@ static ap_table_t *static_calls_made = NULL;
  * freed each time we modify the trace.  That way previous layers of trace
  * data don't get lost.
  */
-static ap_pool_t *example_pool = NULL;
-static ap_pool_t *example_subpool = NULL;
+static apr_pool_t *example_pool = NULL;
+static apr_pool_t *example_subpool = NULL;
 
 /*
  * Declare ourselves so the configuration routines can find and know us.
@@ -295,14 +295,14 @@ static void setup_module_cells()
      * If we haven't already allocated our module-private pool, do so now.
      */
     if (example_pool == NULL) {
-        ap_create_pool(&example_pool, NULL);
+        apr_create_pool(&example_pool, NULL);
     };
     /*
-     * Likewise for the ap_table_t of routine/environment pairs we visit outside of
+     * Likewise for the apr_table_t of routine/environment pairs we visit outside of
      * request context.
      */
     if (static_calls_made == NULL) {
-        static_calls_made = ap_make_table(example_pool, 16);
+        static_calls_made = apr_make_table(example_pool, 16);
     };
 }
 
@@ -315,11 +315,11 @@ static void setup_module_cells()
  * The list can be displayed by the example_handler() routine.
  *
  * If the call occurs within a request context (i.e., we're passed a request
- * record), we put the trace into the request ap_pool_t and attach it to the
+ * record), we put the trace into the request apr_pool_t and attach it to the
  * request via the notes mechanism.  Otherwise, the trace gets added
  * to the static (non-request-specific) list.
  *
- * Note that the r->notes ap_table_t is only for storing strings; if you need to
+ * Note that the r->notes apr_table_t is only for storing strings; if you need to
  * maintain per-request data of any other type, you need to use another
  * mechanism.
  */
@@ -333,7 +333,7 @@ static void trace_add(server_rec *s, request_rec *r, excfg *mconfig,
     const char *sofar;
     char *addon;
     char *where;
-    ap_pool_t *p;
+    apr_pool_t *p;
     const char *trace_copy;
 
     /*
@@ -345,7 +345,7 @@ static void trace_add(server_rec *s, request_rec *r, excfg *mconfig,
      */
     if (r != NULL) {
         p = r->pool;
-        if ((trace_copy = ap_table_get(r->notes, TRACE_NOTE)) == NULL) {
+        if ((trace_copy = apr_table_get(r->notes, TRACE_NOTE)) == NULL) {
             trace_copy = "";
         }
     }
@@ -360,16 +360,16 @@ static void trace_add(server_rec *s, request_rec *r, excfg *mconfig,
          * Make a new sub-pool and copy any existing trace to it.  Point the
          * trace cell at the copied value.
          */
-        ap_create_pool(&p, example_pool);
+        apr_create_pool(&p, example_pool);
         if (trace != NULL) {
-            trace = ap_pstrdup(p, trace);
+            trace = apr_pstrdup(p, trace);
         }
         /*
          * Now, if we have a sub-pool from before, nuke it and replace with
          * the one we just allocated.
          */
         if (example_subpool != NULL) {
-            ap_destroy_pool(example_subpool);
+            apr_destroy_pool(example_subpool);
         }
         example_subpool = p;
         trace_copy = trace;
@@ -385,14 +385,14 @@ static void trace_add(server_rec *s, request_rec *r, excfg *mconfig,
     where = (where != NULL) ? where : "";
     /*
      * Now, if we're not in request context, see if we've been called with
-     * this particular combination before.  The ap_table_t is allocated in the
+     * this particular combination before.  The apr_table_t is allocated in the
      * module's private pool, which doesn't get destroyed.
      */
     if (r == NULL) {
         char *key;
 
-        key = ap_pstrcat(p, note, ":", where, NULL);
-        if (ap_table_get(static_calls_made, key) != NULL) {
+        key = apr_pstrcat(p, note, ":", where, NULL);
+        if (apr_table_get(static_calls_made, key) != NULL) {
             /*
              * Been here, done this.
              */
@@ -403,17 +403,17 @@ static void trace_add(server_rec *s, request_rec *r, excfg *mconfig,
              * First time for this combination of routine and environment -
              * log it so we don't do it again.
              */
-            ap_table_set(static_calls_made, key, "been here");
+            apr_table_set(static_calls_made, key, "been here");
         }
     }
-    addon = ap_pstrcat(p, "   <LI>\n", "    <DL>\n", "     <DT><SAMP>",
+    addon = apr_pstrcat(p, "   <LI>\n", "    <DL>\n", "     <DT><SAMP>",
                     note, "</SAMP>\n", "     </DT>\n", "     <DD><SAMP>[",
                     where, "]</SAMP>\n", "     </DD>\n", "    </DL>\n",
                     "   </LI>\n", NULL);
     sofar = (trace_copy == NULL) ? "" : trace_copy;
-    trace_copy = ap_pstrcat(p, sofar, addon, NULL);
+    trace_copy = apr_pstrcat(p, sofar, addon, NULL);
     if (r != NULL) {
-        ap_table_set(r->notes, TRACE_NOTE, trace_copy);
+        apr_table_set(r->notes, TRACE_NOTE, trace_copy);
     }
     else {
         trace = trace_copy;
@@ -563,7 +563,7 @@ static int example_handler(request_rec *r)
     ap_rprintf(r, "  <H2>Static callbacks so far:</H2>\n  <OL>\n%s  </OL>\n",
             trace);
     ap_rputs("  <H2>Request-specific callbacks so far:</H2>\n", r);
-    ap_rprintf(r, "  <OL>\n%s  </OL>\n", ap_table_get(r->notes, TRACE_NOTE));
+    ap_rprintf(r, "  <OL>\n%s  </OL>\n", apr_table_get(r->notes, TRACE_NOTE));
     ap_rputs("  <H2>Environment for <EM>this</EM> call:</H2>\n", r);
     ap_rputs("  <UL>\n", r);
     ap_rprintf(r, "   <LI>Applies-to: <SAMP>%s</SAMP>\n   </LI>\n", dcfg->loc);
@@ -627,8 +627,8 @@ static int example_handler(request_rec *r)
 /*
  * All our module initialiser does is add its trace to the log.
  */
-static void example_init(ap_pool_t *p, ap_pool_t *ptemp, 
-                         ap_pool_t *plog, server_rec *s)
+static void example_init(apr_pool_t *p, apr_pool_t *ptemp, 
+                         apr_pool_t *plog, server_rec *s)
 {
 
     char *note;
@@ -643,7 +643,7 @@ static void example_init(ap_pool_t *p, ap_pool_t *ptemp,
      * we're being called.
      */
     sname = (sname != NULL) ? sname : "";
-    note = ap_pstrcat(p, "example_init(", sname, ")", NULL);
+    note = apr_pstrcat(p, "example_init(", sname, ")", NULL);
     trace_add(s, NULL, NULL, note);
 }
 
@@ -659,7 +659,7 @@ static void example_init(ap_pool_t *p, ap_pool_t *ptemp,
 /*
  * All our process initialiser does is add its trace to the log.
  */
-static void example_child_init(ap_pool_t *p, server_rec *s)
+static void example_child_init(apr_pool_t *p, server_rec *s)
 {
 
     char *note;
@@ -674,7 +674,7 @@ static void example_child_init(ap_pool_t *p, server_rec *s)
      * we're being called.
      */
     sname = (sname != NULL) ? sname : "";
-    note = ap_pstrcat(p, "example_child_init(", sname, ")", NULL);
+    note = apr_pstrcat(p, "example_child_init(", sname, ")", NULL);
     trace_add(s, NULL, NULL, note);
 }
 
@@ -690,7 +690,7 @@ static void example_child_init(ap_pool_t *p, server_rec *s)
 /*
  * All our process-death routine does is add its trace to the log.
  */
-static void example_child_exit(server_rec *s, ap_pool_t *p)
+static void example_child_exit(server_rec *s, apr_pool_t *p)
 {
 
     char *note;
@@ -701,7 +701,7 @@ static void example_child_exit(server_rec *s, ap_pool_t *p)
      * we're being called.
      */
     sname = (sname != NULL) ? sname : "";
-    note = ap_pstrcat(p, "example_child_exit(", sname, ")", NULL);
+    note = apr_pstrcat(p, "example_child_exit(", sname, ")", NULL);
     trace_add(s, NULL, NULL, note);
 }
 
@@ -717,7 +717,7 @@ static void example_child_exit(server_rec *s, ap_pool_t *p)
  * The return value is a pointer to the created module-specific
  * structure.
  */
-static void *example_create_dir_config(ap_pool_t *p, char *dirspec)
+static void *example_create_dir_config(apr_pool_t *p, char *dirspec)
 {
 
     excfg *cfg;
@@ -726,7 +726,7 @@ static void *example_create_dir_config(ap_pool_t *p, char *dirspec)
     /*
      * Allocate the space for our record from the pool supplied.
      */
-    cfg = (excfg *) ap_pcalloc(p, sizeof(excfg));
+    cfg = (excfg *) apr_pcalloc(p, sizeof(excfg));
     /*
      * Now fill in the defaults.  If there are any `parent' configuration
      * records, they'll get merged as part of a separate callback.
@@ -738,7 +738,7 @@ static void *example_create_dir_config(ap_pool_t *p, char *dirspec)
      * Finally, add our trace to the callback list.
      */
     dname = (dname != NULL) ? dname : "";
-    cfg->loc = ap_pstrcat(p, "DIR(", dname, ")", NULL);
+    cfg->loc = apr_pstrcat(p, "DIR(", dname, ")", NULL);
     trace_add(NULL, NULL, cfg, "example_create_dir_config()");
     return (void *) cfg;
 }
@@ -758,11 +758,11 @@ static void *example_create_dir_config(ap_pool_t *p, char *dirspec)
  * The return value is a pointer to the created module-specific structure
  * containing the merged values.
  */
-static void *example_merge_dir_config(ap_pool_t *p, void *parent_conf,
+static void *example_merge_dir_config(apr_pool_t *p, void *parent_conf,
                                       void *newloc_conf)
 {
 
-    excfg *merged_config = (excfg *) ap_pcalloc(p, sizeof(excfg));
+    excfg *merged_config = (excfg *) apr_pcalloc(p, sizeof(excfg));
     excfg *pconf = (excfg *) parent_conf;
     excfg *nconf = (excfg *) newloc_conf;
     char *note;
@@ -772,7 +772,7 @@ static void *example_merge_dir_config(ap_pool_t *p, void *parent_conf,
      * than getting merged.
      */
     merged_config->local = nconf->local;
-    merged_config->loc = ap_pstrdup(p, nconf->loc);
+    merged_config->loc = apr_pstrdup(p, nconf->loc);
     /*
      * Others, like the setting of the `congenital' flag, get ORed in.  The
      * setting of that particular flag, for instance, is TRUE if it was ever
@@ -790,7 +790,7 @@ static void *example_merge_dir_config(ap_pool_t *p, void *parent_conf,
      * Now just record our being called in the trace list.  Include the
      * locations we were asked to merge.
      */
-    note = ap_pstrcat(p, "example_merge_dir_config(\"", pconf->loc, "\",\"",
+    note = apr_pstrcat(p, "example_merge_dir_config(\"", pconf->loc, "\",\"",
                    nconf->loc, "\")", NULL);
     trace_add(NULL, NULL, merged_config, note);
     return (void *) merged_config;
@@ -803,7 +803,7 @@ static void *example_merge_dir_config(ap_pool_t *p, void *parent_conf,
  * The return value is a pointer to the created module-specific
  * structure.
  */
-static void *example_create_server_config(ap_pool_t *p, server_rec *s)
+static void *example_create_server_config(apr_pool_t *p, server_rec *s)
 {
 
     excfg *cfg;
@@ -813,7 +813,7 @@ static void *example_create_server_config(ap_pool_t *p, server_rec *s)
      * As with the example_create_dir_config() reoutine, we allocate and fill
      * in an empty record.
      */
-    cfg = (excfg *) ap_pcalloc(p, sizeof(excfg));
+    cfg = (excfg *) apr_pcalloc(p, sizeof(excfg));
     cfg->local = 0;
     cfg->congenital = 0;
     cfg->cmode = CONFIG_MODE_SERVER;
@@ -821,7 +821,7 @@ static void *example_create_server_config(ap_pool_t *p, server_rec *s)
      * Note that we were called in the trace list.
      */
     sname = (sname != NULL) ? sname : "";
-    cfg->loc = ap_pstrcat(p, "SVR(", sname, ")", NULL);
+    cfg->loc = apr_pstrcat(p, "SVR(", sname, ")", NULL);
     trace_add(s, NULL, cfg, "example_create_server_config()");
     return (void *) cfg;
 }
@@ -839,11 +839,11 @@ static void *example_create_server_config(ap_pool_t *p, server_rec *s)
  * The return value is a pointer to the created module-specific structure
  * containing the merged values.
  */
-static void *example_merge_server_config(ap_pool_t *p, void *server1_conf,
+static void *example_merge_server_config(apr_pool_t *p, void *server1_conf,
                                          void *server2_conf)
 {
 
-    excfg *merged_config = (excfg *) ap_pcalloc(p, sizeof(excfg));
+    excfg *merged_config = (excfg *) apr_pcalloc(p, sizeof(excfg));
     excfg *s1conf = (excfg *) server1_conf;
     excfg *s2conf = (excfg *) server2_conf;
     char *note;
@@ -856,11 +856,11 @@ static void *example_merge_server_config(ap_pool_t *p, void *server1_conf,
         (s1conf->cmode == s2conf->cmode) ? s1conf->cmode : CONFIG_MODE_COMBO;
     merged_config->local = s2conf->local;
     merged_config->congenital = (s1conf->congenital | s1conf->local);
-    merged_config->loc = ap_pstrdup(p, s2conf->loc);
+    merged_config->loc = apr_pstrdup(p, s2conf->loc);
     /*
      * Trace our call, including what we were asked to merge.
      */
-    note = ap_pstrcat(p, "example_merge_server_config(\"", s1conf->loc, "\",\"",
+    note = apr_pstrcat(p, "example_merge_server_config(\"", s1conf->loc, "\",\"",
                    s2conf->loc, "\")", NULL);
     trace_add(NULL, NULL, merged_config, note);
     return (void *) merged_config;
diff --git a/modules/filters/mod_include.c b/modules/filters/mod_include.c
index 1482f1d..f3de9f5 100644
--- a/modules/filters/mod_include.c
+++ b/modules/filters/mod_include.c
@@ -138,38 +138,38 @@ static void add_include_vars(request_rec *r, char *timefmt)
 #ifndef WIN32
     struct passwd *pw;
 #endif /* ndef WIN32 */
-    ap_table_t *e = r->subprocess_env;
+    apr_table_t *e = r->subprocess_env;
     char *t;
-    ap_time_t date = r->request_time;
+    apr_time_t date = r->request_time;
 
-    ap_table_setn(e, "DATE_LOCAL", ap_ht_time(r->pool, date, timefmt, 0));
-    ap_table_setn(e, "DATE_GMT", ap_ht_time(r->pool, date, timefmt, 1));
-    ap_table_setn(e, "LAST_MODIFIED",
+    apr_table_setn(e, "DATE_LOCAL", ap_ht_time(r->pool, date, timefmt, 0));
+    apr_table_setn(e, "DATE_GMT", ap_ht_time(r->pool, date, timefmt, 1));
+    apr_table_setn(e, "LAST_MODIFIED",
               ap_ht_time(r->pool, r->finfo.mtime, timefmt, 0));
-    ap_table_setn(e, "DOCUMENT_URI", r->uri);
-    ap_table_setn(e, "DOCUMENT_PATH_INFO", r->path_info);
+    apr_table_setn(e, "DOCUMENT_URI", r->uri);
+    apr_table_setn(e, "DOCUMENT_PATH_INFO", r->path_info);
 #ifndef WIN32
     pw = getpwuid(r->finfo.user);
     if (pw) {
-        ap_table_setn(e, "USER_NAME", ap_pstrdup(r->pool, pw->pw_name));
+        apr_table_setn(e, "USER_NAME", apr_pstrdup(r->pool, pw->pw_name));
     }
     else {
-        ap_table_setn(e, "USER_NAME", ap_psprintf(r->pool, "user#%lu",
+        apr_table_setn(e, "USER_NAME", apr_psprintf(r->pool, "user#%lu",
                     (unsigned long) r->finfo.user));
     }
 #endif /* ndef WIN32 */
 
     if ((t = strrchr(r->filename, '/'))) {
-        ap_table_setn(e, "DOCUMENT_NAME", ++t);
+        apr_table_setn(e, "DOCUMENT_NAME", ++t);
     }
     else {
-        ap_table_setn(e, "DOCUMENT_NAME", r->uri);
+        apr_table_setn(e, "DOCUMENT_NAME", r->uri);
     }
     if (r->args) {
-        char *arg_copy = ap_pstrdup(r->pool, r->args);
+        char *arg_copy = apr_pstrdup(r->pool, r->args);
 
         ap_unescape_url(arg_copy);
-        ap_table_setn(e, "QUERY_STRING_UNESCAPED",
+        apr_table_setn(e, "QUERY_STRING_UNESCAPED",
                   ap_escape_shell_cmd(r->pool, arg_copy));
     }
 }
@@ -215,7 +215,7 @@ static void add_include_vars(request_rec *r, char *timefmt)
  */
 #define GET_CHAR(f,c,ret,r) \
  { \
-   ap_status_t status = ap_getc(&c, f); \
+   apr_status_t status = apr_getc(&c, f); \
    if (status != APR_SUCCESS) { /* either EOF or error -- needs error handling if latter */ \
        if (status != APR_EOF) { \
            ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, \
@@ -223,12 +223,12 @@ static void add_include_vars(request_rec *r, char *timefmt)
                         "mod_include."); \
        } \
        FLUSH_BUF(r); \
-       ap_close(f); \
+       apr_close(f); \
        return ret; \
    } \
  }
 
-static int find_string(ap_file_t *in, const char *str, request_rec *r, int printing)
+static int find_string(apr_file_t *in, const char *str, request_rec *r, int printing)
 {
     int x, l = strlen(str), p;
     char outbuf[OUTBUFSIZE];
@@ -261,14 +261,14 @@ static int find_string(ap_file_t *in, const char *str, request_rec *r, int print
 #undef GET_CHAR
 #define GET_CHAR(f,c,r,p) \
  { \
-   ap_status_t status = ap_getc(&c, f); \
+   apr_status_t status = apr_getc(&c, f); \
    if (status != APR_SUCCESS) { /* either EOF or error -- needs error handling if latter */ \
        if (status != APR_EOF) { \
            ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, \
                         "encountered error in GET_CHAR macro, " \
                         "mod_include."); \
        } \
-       ap_close(f); \
+       apr_close(f); \
        return r; \
    } \
  }
@@ -373,7 +373,7 @@ otilde\365oslash\370ugrave\371uacute\372yacute\375"     /* 6 */
  * the tag value is html decoded if dodecode is non-zero
  */
 
-static char *get_tag(ap_pool_t *p, ap_file_t *in, char *tag, int tagbuf_len, int dodecode)
+static char *get_tag(apr_pool_t *p, apr_file_t *in, char *tag, int tagbuf_len, int dodecode)
 {
     char *t = tag, *tag_val, c, term;
 
@@ -392,7 +392,7 @@ static char *get_tag(ap_pool_t *p, ap_file_t *in, char *tag, int tagbuf_len, int
                 GET_CHAR(in, c, NULL, p);
             } while (ap_isspace(c));
             if (c == '>') {
-                ap_cpystrn(tag, "done", tagbuf_len);
+                apr_cpystrn(tag, "done", tagbuf_len);
                 return tag;
             }
         }
@@ -419,7 +419,7 @@ static char *get_tag(ap_pool_t *p, ap_file_t *in, char *tag, int tagbuf_len, int
         GET_CHAR(in, c, NULL, p);       /* space before = */
     }
     if (c != '=') {
-        ap_ungetc(c, in);
+        apr_ungetc(c, in);
         return NULL;
     }
 
@@ -456,10 +456,10 @@ static char *get_tag(ap_pool_t *p, ap_file_t *in, char *tag, int tagbuf_len, int
     if (dodecode) {
         decodehtml(tag_val);
     }
-    return ap_pstrdup(p, tag_val);
+    return apr_pstrdup(p, tag_val);
 }
 
-static int get_directive(ap_file_t *in, char *dest, size_t len, ap_pool_t *p)
+static int get_directive(apr_file_t *in, char *dest, size_t len, apr_pool_t *p)
 {
     char *d = dest;
     char c;
@@ -557,7 +557,7 @@ static void parse_string(request_rec *r, const char *in, char *out,
 		    memcpy(var, start_of_var_name, l);
 		    var[l] = '\0';
 
-		    val = ap_table_get(r->subprocess_env, var);
+		    val = apr_table_get(r->subprocess_env, var);
 		    if (val) {
 			expansion = val;
 			l = strlen(expansion);
@@ -627,7 +627,7 @@ static int include_cgi(char *s, request_rec *r)
 
     rr_status = ap_run_sub_req(rr);
     if (ap_is_HTTP_REDIRECT(rr_status)) {
-        const char *location = ap_table_get(rr->headers_out, "Location");
+        const char *location = apr_table_get(rr->headers_out, "Location");
         location = ap_escape_html(rr->pool, location);
         ap_rvputs(r, "<A HREF=\"", location, "\">", location, "</A>", NULL);
     }
@@ -666,7 +666,7 @@ static int is_only_below(const char *path)
     return 1;
 }
 
-static int handle_include(ap_file_t *in, request_rec *r, const char *error, int noexec)
+static int handle_include(apr_file_t *in, request_rec *r, const char *error, int noexec)
 {
     char tag[MAX_STRING_LEN];
     char parsed_string[MAX_STRING_LEN];
@@ -789,7 +789,7 @@ typedef struct {
 
 
 
-static ap_status_t build_argv_list(char ***argv, request_rec *r, ap_pool_t *p)
+static apr_status_t build_argv_list(char ***argv, request_rec *r, apr_pool_t *p)
 {
     int numwords, x, idx;
     char *w;
@@ -812,7 +812,7 @@ static ap_status_t build_argv_list(char ***argv, request_rec *r, ap_pool_t *p)
     if (numwords > APACHE_ARG_MAX - 1) {
         numwords = APACHE_ARG_MAX - 1;	/* Truncate args to prevent overrun */
     }
-    *argv = (char **) ap_palloc(p, (numwords + 2) * sizeof(char *));
+    *argv = (char **) apr_palloc(p, (numwords + 2) * sizeof(char *));
  
     for (x = 1, idx = 1; x < numwords; x++) {
         w = ap_getword_nulls(p, &args, '+');
@@ -830,12 +830,12 @@ static int include_cmd(char *s, request_rec *r)
 {
     include_cmd_arg arg;
     BUFF *script_in;
-    ap_procattr_t *procattr;
-    ap_proc_t *procnew;
-    ap_status_t rc;
-    ap_table_t *env = r->subprocess_env;
+    apr_procattr_t *procattr;
+    apr_proc_t *procnew;
+    apr_status_t rc;
+    apr_table_t *env = r->subprocess_env;
     char **argv;
-    ap_file_t *file = NULL;
+    apr_file_t *file = NULL;
     ap_iol *iol;
 #if defined(RLIMIT_CPU)  || defined(RLIMIT_NPROC) || \
     defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined (RLIMIT_AS)
@@ -855,39 +855,39 @@ static int include_cmd(char *s, request_rec *r)
     if (r->path_info && r->path_info[0] != '\0') {
         request_rec *pa_req;
 
-        ap_table_setn(env, "PATH_INFO", ap_escape_shell_cmd(r->pool, r->path_info));
+        apr_table_setn(env, "PATH_INFO", ap_escape_shell_cmd(r->pool, r->path_info));
 
         pa_req = ap_sub_req_lookup_uri(ap_escape_uri(r->pool, r->path_info), r);
         if (pa_req->filename) {
-            ap_table_setn(env, "PATH_TRANSLATED",
-                      ap_pstrcat(r->pool, pa_req->filename, pa_req->path_info,
+            apr_table_setn(env, "PATH_TRANSLATED",
+                      apr_pstrcat(r->pool, pa_req->filename, pa_req->path_info,
                               NULL));
         }
     }
 
     if (r->args) {
-        char *arg_copy = ap_pstrdup(r->pool, r->args);
+        char *arg_copy = apr_pstrdup(r->pool, r->args);
 
-        ap_table_setn(env, "QUERY_STRING", r->args);
+        apr_table_setn(env, "QUERY_STRING", r->args);
         ap_unescape_url(arg_copy);
-        ap_table_setn(env, "QUERY_STRING_UNESCAPED",
+        apr_table_setn(env, "QUERY_STRING_UNESCAPED",
                   ap_escape_shell_cmd(r->pool, arg_copy));
     }
 
-    if ((ap_createprocattr_init(&procattr, r->pool) != APR_SUCCESS) ||
-        (ap_setprocattr_io(procattr, APR_NO_PIPE, 
+    if ((apr_createprocattr_init(&procattr, r->pool) != APR_SUCCESS) ||
+        (apr_setprocattr_io(procattr, APR_NO_PIPE, 
                            APR_FULL_BLOCK, APR_NO_PIPE) != APR_SUCCESS) ||
-        (ap_setprocattr_dir(procattr, ap_make_dirstr_parent(r->pool, r->filename)) != APR_SUCCESS) ||
+        (apr_setprocattr_dir(procattr, ap_make_dirstr_parent(r->pool, r->filename)) != APR_SUCCESS) ||
 #ifdef RLIMIT_CPU
-        ((rc = ap_setprocattr_limit(procattr, APR_LIMIT_CPU, conf->limit_cpu)) != APR_SUCCESS) ||
+        ((rc = apr_setprocattr_limit(procattr, APR_LIMIT_CPU, conf->limit_cpu)) != APR_SUCCESS) ||
 #endif
 #if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
-        ((rc = ap_setprocattr_limit(procattr, APR_LIMIT_MEM, conf->limit_mem)) != APR_SUCCESS) ||
+        ((rc = apr_setprocattr_limit(procattr, APR_LIMIT_MEM, conf->limit_mem)) != APR_SUCCESS) ||
 #endif
 #ifdef RLIMIT_NPROC
-        ((rc = ap_setprocattr_limit(procattr, APR_LIMIT_NPROC, conf->limit_nproc)) != APR_SUCCESS) ||
+        ((rc = apr_setprocattr_limit(procattr, APR_LIMIT_NPROC, conf->limit_nproc)) != APR_SUCCESS) ||
 #endif
-        (ap_setprocattr_cmdtype(procattr, APR_SHELLCMD) != APR_SUCCESS)) {
+        (apr_setprocattr_cmdtype(procattr, APR_SHELLCMD) != APR_SUCCESS)) {
         /* Something bad happened, tell the world. */
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
             "couldn't initialize proc attributes: %s %s", r->filename, s);
@@ -895,9 +895,9 @@ static int include_cmd(char *s, request_rec *r)
     }
     else {
         build_argv_list(&argv, r, r->pool);
-        argv[0] = ap_pstrdup(r->pool, s);
-        procnew = ap_pcalloc(r->pool, sizeof(*procnew));
-        rc = ap_create_process(procnew, s, argv, ap_create_environment(r->pool, env), procattr, r->pool);
+        argv[0] = apr_pstrdup(r->pool, s);
+        procnew = apr_pcalloc(r->pool, sizeof(*procnew));
+        rc = apr_create_process(procnew, s, argv, ap_create_environment(r->pool, env), procattr, r->pool);
 
         if (rc != APR_SUCCESS) {
             /* Bad things happened. Everyone should have cleaned up. */
@@ -905,7 +905,7 @@ static int include_cmd(char *s, request_rec *r)
                         "couldn't create child process: %d: %s", rc, s);
         }
         else {
-            ap_note_subprocess(r->pool, procnew, kill_after_timeout);
+            apr_note_subprocess(r->pool, procnew, kill_after_timeout);
             /* Fill in BUFF structure for parents pipe to child's stdout */
             file = procnew->out;
             iol = ap_create_file_iol(file);
@@ -921,7 +921,7 @@ static int include_cmd(char *s, request_rec *r)
     return 0;
 }
 
-static int handle_exec(ap_file_t *in, request_rec *r, const char *error)
+static int handle_exec(apr_file_t *in, request_rec *r, const char *error)
 {
     char tag[MAX_STRING_LEN];
     char *tag_val;
@@ -966,7 +966,7 @@ static int handle_exec(ap_file_t *in, request_rec *r, const char *error)
 
 }
 
-static int handle_echo(ap_file_t *in, request_rec *r, const char *error)
+static int handle_echo(apr_file_t *in, request_rec *r, const char *error)
 {
     char tag[MAX_STRING_LEN];
     char *tag_val;
@@ -979,7 +979,7 @@ static int handle_echo(ap_file_t *in, request_rec *r, const char *error)
             return 1;
         }
         if (!strcmp(tag, "var")) {
-            const char *val = ap_table_get(r->subprocess_env, tag_val);
+            const char *val = apr_table_get(r->subprocess_env, tag_val);
 
             if (val) {
 		if (encode == E_NONE) {
@@ -1022,7 +1022,7 @@ static int handle_echo(ap_file_t *in, request_rec *r, const char *error)
 }
 
 #ifdef USE_PERL_SSI
-static int handle_perl(ap_file_t *in, request_rec *r, const char *error)
+static int handle_perl(apr_file_t *in, request_rec *r, const char *error)
 {
     char tag[MAX_STRING_LEN];
     char parsed_string[MAX_STRING_LEN];
@@ -1061,13 +1061,13 @@ static int handle_perl(ap_file_t *in, request_rec *r, const char *error)
 /* error and tf must point to a string with room for at 
  * least MAX_STRING_LEN characters 
  */
-static int handle_config(ap_file_t *in, request_rec *r, char *error, char *tf,
+static int handle_config(apr_file_t *in, request_rec *r, char *error, char *tf,
                          int *sizefmt)
 {
     char tag[MAX_STRING_LEN];
     char *tag_val;
     char parsed_string[MAX_STRING_LEN];
-    ap_table_t *env = r->subprocess_env;
+    apr_table_t *env = r->subprocess_env;
 
     while (1) {
         if (!(tag_val = get_tag(r->pool, in, tag, sizeof(tag), 0))) {
@@ -1077,12 +1077,12 @@ static int handle_config(ap_file_t *in, request_rec *r, char *error, char *tf,
             parse_string(r, tag_val, error, MAX_STRING_LEN, 0);
         }
         else if (!strcmp(tag, "timefmt")) {
-            ap_time_t date = r->request_time;
+            apr_time_t date = r->request_time;
 
             parse_string(r, tag_val, tf, MAX_STRING_LEN, 0);
-            ap_table_setn(env, "DATE_LOCAL", ap_ht_time(r->pool, date, tf, 0));
-            ap_table_setn(env, "DATE_GMT", ap_ht_time(r->pool, date, tf, 1));
-            ap_table_setn(env, "LAST_MODIFIED",
+            apr_table_setn(env, "DATE_LOCAL", ap_ht_time(r->pool, date, tf, 0));
+            apr_table_setn(env, "DATE_GMT", ap_ht_time(r->pool, date, tf, 1));
+            apr_table_setn(env, "LAST_MODIFIED",
                       ap_ht_time(r->pool, r->finfo.mtime, tf, 0));
         }
         else if (!strcmp(tag, "sizefmt")) {
@@ -1109,7 +1109,7 @@ static int handle_config(ap_file_t *in, request_rec *r, char *error, char *tf,
 
 
 static int find_file(request_rec *r, const char *directive, const char *tag,
-                     char *tag_val, ap_finfo_t *finfo, const char *error)
+                     char *tag_val, apr_finfo_t *finfo, const char *error)
 {
     char *to_send = tag_val;
     request_rec *rr = NULL;
@@ -1128,7 +1128,7 @@ static int find_file(request_rec *r, const char *directive, const char *tag,
 
             if (rr->status == HTTP_OK && rr->finfo.protection != 0) {
                 to_send = rr->filename;
-                if (ap_stat(finfo, to_send, rr->pool) != APR_SUCCESS) {
+                if (apr_stat(finfo, to_send, rr->pool) != APR_SUCCESS) {
                     error_fmt = "unable to get information about \"%s\" "
                         "in parsed file %s";
                 }
@@ -1141,7 +1141,7 @@ static int find_file(request_rec *r, const char *directive, const char *tag,
 
         if (error_fmt) {
             ret = -1;
-            /* TODO: pass APLOG_NOERRNO if no ap_stat() failure; pass rv from ap_stat()
+            /* TODO: pass APLOG_NOERRNO if no apr_stat() failure; pass rv from apr_stat()
              * otherwise
              */
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, error_fmt, to_send, r->filename);
@@ -1181,11 +1181,11 @@ static int find_file(request_rec *r, const char *directive, const char *tag,
 }
 
 
-static int handle_fsize(ap_file_t *in, request_rec *r, const char *error, int sizefmt)
+static int handle_fsize(apr_file_t *in, request_rec *r, const char *error, int sizefmt)
 {
     char tag[MAX_STRING_LEN];
     char *tag_val;
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     char parsed_string[MAX_STRING_LEN];
 
     while (1) {
@@ -1203,7 +1203,7 @@ static int handle_fsize(ap_file_t *in, request_rec *r, const char *error, int si
                 }
                 else {
                     int l, x;
-                    ap_snprintf(tag, sizeof(tag), "%" APR_OFF_T_FMT, finfo.size);
+                    apr_snprintf(tag, sizeof(tag), "%" APR_OFF_T_FMT, finfo.size);
                     l = strlen(tag);    /* grrr */
                     for (x = 0; x < l; x++) {
                         if (x && (!((l - x) % 3))) {
@@ -1217,11 +1217,11 @@ static int handle_fsize(ap_file_t *in, request_rec *r, const char *error, int si
     }
 }
 
-static int handle_flastmod(ap_file_t *in, request_rec *r, const char *error, const char *tf)
+static int handle_flastmod(apr_file_t *in, request_rec *r, const char *error, const char *tf)
 {
     char tag[MAX_STRING_LEN];
     char *tag_val;
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     char parsed_string[MAX_STRING_LEN];
 
     while (1) {
@@ -1438,19 +1438,19 @@ static int parse_expr(request_rec *r, const char *expr, const char *error)
     }         *root, *current, *new;
     const char *parse;
     char buffer[MAX_STRING_LEN];
-    ap_pool_t *expr_pool;
+    apr_pool_t *expr_pool;
     int retval = 0;
 
     if ((parse = expr) == (char *) NULL) {
         return (0);
     }
     root = current = (struct parse_node *) NULL;
-    if (ap_create_pool(&expr_pool, r->pool) != APR_SUCCESS)
+    if (apr_create_pool(&expr_pool, r->pool) != APR_SUCCESS)
 		return 0;
 
     /* Create Parse Tree */
     while (1) {
-        new = (struct parse_node *) ap_palloc(expr_pool,
+        new = (struct parse_node *) apr_palloc(expr_pool,
                                            sizeof(struct parse_node));
         new->parent = new->left = new->right = (struct parse_node *) NULL;
         new->done = 0;
@@ -1736,7 +1736,7 @@ static int parse_expr(request_rec *r, const char *expr, const char *error)
             ap_rputs("     Evaluate string\n", r);
 #endif
             parse_string(r, current->token.value, buffer, sizeof(buffer), 0);
-	    ap_cpystrn(current->token.value, buffer, sizeof(current->token.value));
+	    apr_cpystrn(current->token.value, buffer, sizeof(current->token.value));
             current->value = (current->token.value[0] != '\0');
             current->done = 1;
             current = current->parent;
@@ -1760,7 +1760,7 @@ static int parse_expr(request_rec *r, const char *expr, const char *error)
                 case token_string:
                     parse_string(r, current->left->token.value,
                                  buffer, sizeof(buffer), 0);
-                    ap_cpystrn(current->left->token.value, buffer,
+                    apr_cpystrn(current->left->token.value, buffer,
                             sizeof(current->left->token.value));
 		    current->left->value = (current->left->token.value[0] != '\0');
                     current->left->done = 1;
@@ -1775,7 +1775,7 @@ static int parse_expr(request_rec *r, const char *expr, const char *error)
                 case token_string:
                     parse_string(r, current->right->token.value,
                                  buffer, sizeof(buffer), 0);
-                    ap_cpystrn(current->right->token.value, buffer,
+                    apr_cpystrn(current->right->token.value, buffer,
                             sizeof(current->right->token.value));
 		    current->right->value = (current->right->token.value[0] != '\0');
                     current->right->done = 1;
@@ -1822,11 +1822,11 @@ static int parse_expr(request_rec *r, const char *expr, const char *error)
             }
             parse_string(r, current->left->token.value,
                          buffer, sizeof(buffer), 0);
-            ap_cpystrn(current->left->token.value, buffer,
+            apr_cpystrn(current->left->token.value, buffer,
 			sizeof(current->left->token.value));
             parse_string(r, current->right->token.value,
                          buffer, sizeof(buffer), 0);
-            ap_cpystrn(current->right->token.value, buffer,
+            apr_cpystrn(current->right->token.value, buffer,
 			sizeof(current->right->token.value));
             if (current->right->token.value[0] == '/') {
                 int len;
@@ -1887,11 +1887,11 @@ static int parse_expr(request_rec *r, const char *expr, const char *error)
             }
             parse_string(r, current->left->token.value,
                          buffer, sizeof(buffer), 0);
-            ap_cpystrn(current->left->token.value, buffer,
+            apr_cpystrn(current->left->token.value, buffer,
 			sizeof(current->left->token.value));
             parse_string(r, current->right->token.value,
                          buffer, sizeof(buffer), 0);
-            ap_cpystrn(current->right->token.value, buffer,
+            apr_cpystrn(current->right->token.value, buffer,
 			sizeof(current->right->token.value));
 #ifdef DEBUG_INCLUDE
             ap_rvputs(r, "     Compare (", current->left->token.value,
@@ -1985,11 +1985,11 @@ static int parse_expr(request_rec *r, const char *expr, const char *error)
 
     retval = (root == (struct parse_node *) NULL) ? 0 : root->value;
   RETURN:
-    ap_destroy_pool(expr_pool);
+    apr_destroy_pool(expr_pool);
     return (retval);
 }
 
-static int handle_if(ap_file_t *in, request_rec *r, const char *error,
+static int handle_if(apr_file_t *in, request_rec *r, const char *error,
                      int *conditional_status, int *printing)
 {
     char tag[MAX_STRING_LEN];
@@ -2032,7 +2032,7 @@ static int handle_if(ap_file_t *in, request_rec *r, const char *error,
     }
 }
 
-static int handle_elif(ap_file_t *in, request_rec *r, const char *error,
+static int handle_elif(apr_file_t *in, request_rec *r, const char *error,
                        int *conditional_status, int *printing)
 {
     char tag[MAX_STRING_LEN];
@@ -2083,7 +2083,7 @@ static int handle_elif(ap_file_t *in, request_rec *r, const char *error,
     }
 }
 
-static int handle_else(ap_file_t *in, request_rec *r, const char *error,
+static int handle_else(apr_file_t *in, request_rec *r, const char *error,
                        int *conditional_status, int *printing)
 {
     char tag[MAX_STRING_LEN];
@@ -2111,7 +2111,7 @@ static int handle_else(ap_file_t *in, request_rec *r, const char *error,
     }
 }
 
-static int handle_endif(ap_file_t *in, request_rec *r, const char *error,
+static int handle_endif(apr_file_t *in, request_rec *r, const char *error,
                         int *conditional_status, int *printing)
 {
     char tag[MAX_STRING_LEN];
@@ -2137,7 +2137,7 @@ static int handle_endif(ap_file_t *in, request_rec *r, const char *error,
     }
 }
 
-static int handle_set(ap_file_t *in, request_rec *r, const char *error)
+static int handle_set(apr_file_t *in, request_rec *r, const char *error)
 {
     char tag[MAX_STRING_LEN];
     char parsed_string[MAX_STRING_LEN];
@@ -2164,7 +2164,7 @@ static int handle_set(ap_file_t *in, request_rec *r, const char *error)
                 return -1;
             }
             parse_string(r, tag_val, parsed_string, sizeof(parsed_string), 0);
-            ap_table_setn(r->subprocess_env, var, ap_pstrdup(r->pool, parsed_string));
+            apr_table_setn(r->subprocess_env, var, apr_pstrdup(r->pool, parsed_string));
         }
         else {
             ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
@@ -2175,12 +2175,12 @@ static int handle_set(ap_file_t *in, request_rec *r, const char *error)
     }
 }
 
-static int handle_printenv(ap_file_t *in, request_rec *r, const char *error)
+static int handle_printenv(apr_file_t *in, request_rec *r, const char *error)
 {
     char tag[MAX_STRING_LEN];
     char *tag_val;
-    ap_array_header_t *arr = ap_table_elts(r->subprocess_env);
-    ap_table_entry_t *elts = (ap_table_entry_t *)arr->elts;
+    apr_array_header_t *arr = ap_table_elts(r->subprocess_env);
+    apr_table_entry_t *elts = (apr_table_entry_t *)arr->elts;
     int i;
 
     if (!(tag_val = get_tag(r->pool, in, tag, sizeof(tag), 1))) {
@@ -2208,7 +2208,7 @@ static int handle_printenv(ap_file_t *in, request_rec *r, const char *error)
 
 /* This is a stub which parses a file descriptor. */
 
-static void send_parsed_content(ap_file_t *f, request_rec *r)
+static void send_parsed_content(apr_file_t *f, request_rec *r)
 {
     char directive[MAX_STRING_LEN], error[MAX_STRING_LEN];
     char timefmt[MAX_STRING_LEN];
@@ -2218,8 +2218,8 @@ static void send_parsed_content(ap_file_t *f, request_rec *r)
     int printing;
     int conditional_status;
 
-    ap_cpystrn(error, DEFAULT_ERROR_MSG, sizeof(error));
-    ap_cpystrn(timefmt, DEFAULT_TIME_FORMAT, sizeof(timefmt));
+    apr_cpystrn(error, DEFAULT_ERROR_MSG, sizeof(error));
+    apr_cpystrn(timefmt, DEFAULT_TIME_FORMAT, sizeof(timefmt));
     sizefmt = SIZEFMT_KMG;
 
 /*  Turn printing on */
@@ -2228,11 +2228,11 @@ static void send_parsed_content(ap_file_t *f, request_rec *r)
 
     ap_chdir_file(r->filename);
     if (r->args) {              /* add QUERY stuff to env cause it ain't yet */
-        char *arg_copy = ap_pstrdup(r->pool, r->args);
+        char *arg_copy = apr_pstrdup(r->pool, r->args);
 
-        ap_table_setn(r->subprocess_env, "QUERY_STRING", r->args);
+        apr_table_setn(r->subprocess_env, "QUERY_STRING", r->args);
         ap_unescape_url(arg_copy);
-        ap_table_setn(r->subprocess_env, "QUERY_STRING_UNESCAPED",
+        apr_table_setn(r->subprocess_env, "QUERY_STRING_UNESCAPED",
                   ap_escape_shell_cmd(r->pool, arg_copy));
     }
 
@@ -2363,9 +2363,9 @@ enum xbithack {
 #define DEFAULT_XBITHACK xbithack_off
 #endif
 
-static void *create_includes_dir_config(ap_pool_t *p, char *dummy)
+static void *create_includes_dir_config(apr_pool_t *p, char *dummy)
 {
-    enum xbithack *result = (enum xbithack *) ap_palloc(p, sizeof(enum xbithack));
+    enum xbithack *result = (enum xbithack *) apr_palloc(p, sizeof(enum xbithack));
     *result = DEFAULT_XBITHACK;
     return result;
 }
@@ -2392,7 +2392,7 @@ static const char *set_xbithack(cmd_parms *cmd, void *xbp, const char *arg)
 
 static int send_parsed_file(request_rec *r)
 {
-    ap_file_t *f = NULL;
+    apr_file_t *f = NULL;
     enum xbithack *state =
     (enum xbithack *) ap_get_module_config(r->per_dir_config, &includes_module);
     int errstatus;
@@ -2409,12 +2409,12 @@ static int send_parsed_file(request_rec *r)
         ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		    "File does not exist: %s",
                     (r->path_info
-                     ? ap_pstrcat(r->pool, r->filename, r->path_info, NULL)
+                     ? apr_pstrcat(r->pool, r->filename, r->path_info, NULL)
                      : r->filename));
         return HTTP_NOT_FOUND;
     }
 
-    errstatus = ap_open(&f, r->filename, APR_READ|APR_BUFFERED, 0, r->pool);
+    errstatus = apr_open(&f, r->filename, APR_READ|APR_BUFFERED, 0, r->pool);
 
     if (errstatus != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, errstatus, r,
@@ -2438,7 +2438,7 @@ static int send_parsed_file(request_rec *r)
     ap_send_http_header(r);
 
     if (r->header_only) {
-        ap_close(f);
+        apr_close(f);
         return OK;
     }
 
@@ -2534,7 +2534,7 @@ module MODULE_VAR_EXPORT includes_module =
     NULL,                       /* dir merger --- default is to override */
     NULL,                       /* server config */
     NULL,                       /* merge server config */
-    includes_cmds,              /* command ap_table_t */
+    includes_cmds,              /* command apr_table_t */
     includes_handlers,          /* handlers */
     NULL			/* register hooks */
 };
diff --git a/modules/generators/mod_asis.c b/modules/generators/mod_asis.c
index 2e5c6e4..bb45f81 100644
--- a/modules/generators/mod_asis.c
+++ b/modules/generators/mod_asis.c
@@ -70,10 +70,10 @@
 
 static int asis_handler(request_rec *r)
 {
-    ap_file_t *f = NULL;
-    ap_status_t status;
+    apr_file_t *f = NULL;
+    apr_status_t status;
     const char *location;
-    ap_size_t nbytes;
+    apr_size_t nbytes;
 
     r->allowed |= (1 << M_GET);
     if (r->method_number != M_GET)
@@ -84,7 +84,7 @@ static int asis_handler(request_rec *r)
 	return HTTP_NOT_FOUND;
     }
 
-    if ((status = ap_open(&f, r->filename, APR_READ, 
+    if ((status = apr_open(&f, r->filename, APR_READ, 
                 APR_OS_DEFAULT, r->pool)) != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
 		    "file permissions deny server access: %s", r->filename);
@@ -92,12 +92,12 @@ static int asis_handler(request_rec *r)
     }
 
     ap_scan_script_header_err(r, f, NULL);
-    location = ap_table_get(r->headers_out, "Location");
+    location = apr_table_get(r->headers_out, "Location");
 
     if (location && location[0] == '/' &&
 	((r->status == HTTP_OK) || ap_is_HTTP_REDIRECT(r->status))) {
 
-	ap_close(f);
+	apr_close(f);
 
 	/* Internal redirect -- fake-up a pseudo-request */
 	r->status = HTTP_OK;
@@ -105,7 +105,7 @@ static int asis_handler(request_rec *r)
 	/* This redirect needs to be a GET no matter what the original
 	 * method was.
 	 */
-	r->method = ap_pstrdup(r->pool, "GET");
+	r->method = apr_pstrdup(r->pool, "GET");
 	r->method_number = M_GET;
 
 	ap_internal_redirect_handler(location, r);
@@ -117,7 +117,7 @@ static int asis_handler(request_rec *r)
 	ap_send_fd(f, r, 0, r->finfo.size, &nbytes);
     }
 
-    ap_close(f);
+    apr_close(f);
     return OK;
 }
 
@@ -135,7 +135,7 @@ module MODULE_VAR_EXPORT asis_module =
     NULL,			/* merge per-directory config structures */
     NULL,			/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    NULL,			/* command ap_table_t */
+    NULL,			/* command apr_table_t */
     asis_handlers,		/* handlers */
     NULL			/* register hooks */
 };
diff --git a/modules/generators/mod_autoindex.c b/modules/generators/mod_autoindex.c
index 1ba8689..3c11591 100644
--- a/modules/generators/mod_autoindex.c
+++ b/modules/generators/mod_autoindex.c
@@ -163,12 +163,12 @@ typedef struct autoindex_config_struct {
     int icon_height;
     char *default_order;
 
-    ap_array_header_t *icon_list;
-    ap_array_header_t *alt_list;
-    ap_array_header_t *desc_list;
-    ap_array_header_t *ign_list;
-    ap_array_header_t *hdr_list;
-    ap_array_header_t *rdme_list;
+    apr_array_header_t *icon_list;
+    apr_array_header_t *alt_list;
+    apr_array_header_t *desc_list;
+    apr_array_header_t *ign_list;
+    apr_array_header_t *hdr_list;
+    apr_array_header_t *rdme_list;
 
 } autoindex_config_rec;
 
@@ -209,10 +209,10 @@ static void emit_preamble(request_rec *r, char *title)
 	      "</TITLE>\n </HEAD>\n <BODY>\n", NULL);
 }
 
-static void push_item(ap_array_header_t *arr, char *type, const char *to,
+static void push_item(apr_array_header_t *arr, char *type, const char *to,
 		      const char *path, const char *data)
 {
-    struct item *p = (struct item *) ap_push_array(arr);
+    struct item *p = (struct item *) apr_push_array(arr);
 
     if (!to) {
 	to = "";
@@ -222,14 +222,14 @@ static void push_item(ap_array_header_t *arr, char *type, const char *to,
     }
 
     p->type = type;
-    p->data = data ? ap_pstrdup(arr->cont, data) : NULL;
-    p->apply_path = ap_pstrcat(arr->cont, path, "*", NULL);
+    p->data = data ? apr_pstrdup(arr->cont, data) : NULL;
+    p->apply_path = apr_pstrcat(arr->cont, path, "*", NULL);
 
     if ((type == BY_PATH) && (!ap_is_matchexp(to))) {
-	p->apply_to = ap_pstrcat(arr->cont, "*", to, NULL);
+	p->apply_to = apr_pstrcat(arr->cont, "*", to, NULL);
     }
     else if (to) {
-	p->apply_to = ap_pstrdup(arr->cont, to);
+	p->apply_to = apr_pstrdup(arr->cont, to);
     }
     else {
 	p->apply_to = NULL;
@@ -245,7 +245,7 @@ static const char *add_alt(cmd_parms *cmd, void *d, const char *alt,
 	}
     }
     if (cmd->info == BY_ENCODING) {
-        char *tmp = ap_pstrdup(cmd->pool, to);
+        char *tmp = apr_pstrdup(cmd->pool, to);
 	ap_str_tolower(tmp);
 	to = tmp;
     }
@@ -258,7 +258,7 @@ static const char *add_alt(cmd_parms *cmd, void *d, const char *alt,
 static const char *add_icon(cmd_parms *cmd, void *d, const char *icon,
 			    const char *to)
 {
-    char *iconbak = ap_pstrdup(cmd->pool, icon);
+    char *iconbak = apr_pstrdup(cmd->pool, icon);
 
     if (icon[0] == '(') {
 	char *alt;
@@ -277,7 +277,7 @@ static const char *add_icon(cmd_parms *cmd, void *d, const char *icon,
 	}
     }
     if (cmd->info == BY_ENCODING) {
-        char *tmp = ap_pstrdup(cmd->pool, to);
+        char *tmp = apr_pstrdup(cmd->pool, to);
 	ap_str_tolower(tmp);
 	to = tmp;
     }
@@ -316,20 +316,20 @@ static const char *add_desc(cmd_parms *cmd, void *d, const char *desc,
     ai_desc_t *desc_entry;
     char *prefix = "";
 
-    desc_entry = (ai_desc_t *) ap_push_array(dcfg->desc_list);
+    desc_entry = (ai_desc_t *) apr_push_array(dcfg->desc_list);
     desc_entry->full_path = (ap_strchr_c(to, '/') == NULL) ? 0 : 1;
     desc_entry->wildcards = (WILDCARDS_REQUIRED
 			     || desc_entry->full_path
-			     || ap_is_fnmatch(to));
+			     || apr_is_fnmatch(to));
     if (desc_entry->wildcards) {
 	prefix = desc_entry->full_path ? "*/" : "*";
-	desc_entry->pattern = ap_pstrcat(dcfg->desc_list->cont,
+	desc_entry->pattern = apr_pstrcat(dcfg->desc_list->cont,
 					 prefix, to, "*", NULL);
     }
     else {
-	desc_entry->pattern = ap_pstrdup(dcfg->desc_list->cont, to);
+	desc_entry->pattern = apr_pstrdup(dcfg->desc_list->cont, to);
     }
-    desc_entry->description = ap_pstrdup(dcfg->desc_list->cont, desc);
+    desc_entry->description = apr_pstrdup(dcfg->desc_list->cont, desc);
     return NULL;
 }
 
@@ -515,7 +515,7 @@ static const char *set_default_order(cmd_parms *cmd, void *m, const char *direct
     char temp[4];
     autoindex_config_rec *d_cfg = (autoindex_config_rec *) m;
 
-    ap_cpystrn(temp, "k=d", sizeof(temp));
+    apr_cpystrn(temp, "k=d", sizeof(temp));
     if (!strcasecmp(direction, "Ascending")) {
 	temp[2] = D_ASCENDING;
     }
@@ -544,10 +544,10 @@ static const char *set_default_order(cmd_parms *cmd, void *m, const char *direct
     }
 
     if (d_cfg->default_order == NULL) {
-	d_cfg->default_order = ap_palloc(cmd->pool, 4);
+	d_cfg->default_order = apr_palloc(cmd->pool, 4);
 	d_cfg->default_order[3] = '\0';
     }
-    ap_cpystrn(d_cfg->default_order, temp, sizeof(temp));
+    apr_cpystrn(d_cfg->default_order, temp, sizeof(temp));
     return NULL;
 }
 
@@ -587,21 +587,21 @@ static const command_rec autoindex_cmds[] =
     {NULL}
 };
 
-static void *create_autoindex_config(ap_pool_t *p, char *dummy)
+static void *create_autoindex_config(apr_pool_t *p, char *dummy)
 {
     autoindex_config_rec *new =
-    (autoindex_config_rec *) ap_pcalloc(p, sizeof(autoindex_config_rec));
+    (autoindex_config_rec *) apr_pcalloc(p, sizeof(autoindex_config_rec));
 
     new->icon_width = 0;
     new->icon_height = 0;
     new->name_width = DEFAULT_NAME_WIDTH;
     new->name_adjust = K_UNSET;
-    new->icon_list = ap_make_array(p, 4, sizeof(struct item));
-    new->alt_list = ap_make_array(p, 4, sizeof(struct item));
-    new->desc_list = ap_make_array(p, 4, sizeof(ai_desc_t));
-    new->ign_list = ap_make_array(p, 4, sizeof(struct item));
-    new->hdr_list = ap_make_array(p, 4, sizeof(struct item));
-    new->rdme_list = ap_make_array(p, 4, sizeof(struct item));
+    new->icon_list = apr_make_array(p, 4, sizeof(struct item));
+    new->alt_list = apr_make_array(p, 4, sizeof(struct item));
+    new->desc_list = apr_make_array(p, 4, sizeof(ai_desc_t));
+    new->ign_list = apr_make_array(p, 4, sizeof(struct item));
+    new->hdr_list = apr_make_array(p, 4, sizeof(struct item));
+    new->rdme_list = apr_make_array(p, 4, sizeof(struct item));
     new->opts = 0;
     new->incremented_opts = 0;
     new->decremented_opts = 0;
@@ -610,24 +610,24 @@ static void *create_autoindex_config(ap_pool_t *p, char *dummy)
     return (void *) new;
 }
 
-static void *merge_autoindex_configs(ap_pool_t *p, void *basev, void *addv)
+static void *merge_autoindex_configs(apr_pool_t *p, void *basev, void *addv)
 {
     autoindex_config_rec *new;
     autoindex_config_rec *base = (autoindex_config_rec *) basev;
     autoindex_config_rec *add = (autoindex_config_rec *) addv;
 
-    new = (autoindex_config_rec *) ap_pcalloc(p, sizeof(autoindex_config_rec));
+    new = (autoindex_config_rec *) apr_pcalloc(p, sizeof(autoindex_config_rec));
     new->default_icon = add->default_icon ? add->default_icon
                                           : base->default_icon;
     new->icon_height = add->icon_height ? add->icon_height : base->icon_height;
     new->icon_width = add->icon_width ? add->icon_width : base->icon_width;
 
-    new->alt_list = ap_append_arrays(p, add->alt_list, base->alt_list);
-    new->ign_list = ap_append_arrays(p, add->ign_list, base->ign_list);
-    new->hdr_list = ap_append_arrays(p, add->hdr_list, base->hdr_list);
-    new->desc_list = ap_append_arrays(p, add->desc_list, base->desc_list);
-    new->icon_list = ap_append_arrays(p, add->icon_list, base->icon_list);
-    new->rdme_list = ap_append_arrays(p, add->rdme_list, base->rdme_list);
+    new->alt_list = apr_append_arrays(p, add->alt_list, base->alt_list);
+    new->ign_list = apr_append_arrays(p, add->ign_list, base->ign_list);
+    new->hdr_list = apr_append_arrays(p, add->hdr_list, base->hdr_list);
+    new->desc_list = apr_append_arrays(p, add->desc_list, base->desc_list);
+    new->icon_list = apr_append_arrays(p, add->icon_list, base->icon_list);
+    new->rdme_list = apr_append_arrays(p, add->rdme_list, base->rdme_list);
     if (add->opts & NO_OPTIONS) {
 	/*
 	 * If the current directory says 'no options' then we also
@@ -702,13 +702,13 @@ struct ent {
     char *alt;
     char *desc;
     off_t size;
-    ap_time_t lm;
+    apr_time_t lm;
     struct ent *next;
     int ascending, version_sort;
     char key;
 };
 
-static char *find_item(request_rec *r, ap_array_header_t *list, int path_only)
+static char *find_item(request_rec *r, apr_array_header_t *list, int path_only)
 {
     const char *content_type = ap_field_noparam(r->pool, r->content_type);
     const char *content_encoding = r->content_encoding;
@@ -819,7 +819,7 @@ static char *find_desc(autoindex_config_rec *dcfg, request_rec *r)
 	 * wildcard checking if we must.
 	 */
 	if (tuple->wildcards) {
-	    found = (ap_fnmatch(tuple->pattern, filename, MATCH_FLAGS) == 0);
+	    found = (apr_fnmatch(tuple->pattern, filename, MATCH_FLAGS) == 0);
 	}
 	else {
 	    found = (ap_strstr_c(filename, tuple->pattern) != NULL);
@@ -833,7 +833,7 @@ static char *find_desc(autoindex_config_rec *dcfg, request_rec *r)
 
 static int ignore_entry(autoindex_config_rec *d, char *path)
 {
-    ap_array_header_t *list = d->ign_list;
+    apr_array_header_t *list = d->ign_list;
     struct item *items = (struct item *) list->elts;
     char *tt;
     int i;
@@ -908,18 +908,18 @@ static int ignore_entry(autoindex_config_rec *d, char *path)
 /*
  * emit a plain text file
  */
-static void do_emit_plain(request_rec *r, ap_file_t *f)
+static void do_emit_plain(request_rec *r, apr_file_t *f)
 {
     char buf[IOBUFSIZE + 1];
     int i, c, ch;
-    ap_ssize_t n;
-    ap_status_t stat;
+    apr_ssize_t n;
+    apr_status_t stat;
 
     ap_rputs("<PRE>\n", r);
-    while (!ap_eof(f)) {
+    while (!apr_eof(f)) {
 	do {
             n = sizeof(char) * IOBUFSIZE;
-	    stat = ap_read(f, buf, &n);
+	    stat = apr_read(f, buf, &n);
 	}
 	while (stat != APR_SUCCESS && stat == EINTR);
 	if (n == -1 || n == 0) {
@@ -963,7 +963,7 @@ static void do_emit_plain(request_rec *r, ap_file_t *f)
 static void emit_head(request_rec *r, char *header_fname, int suppress_amble,
 		      char *title)
 {
-    ap_file_t *f = NULL;
+    apr_file_t *f = NULL;
     request_rec *rr = NULL;
     int emit_amble = 1;
     int emit_H1 = 1;
@@ -1011,12 +1011,12 @@ static void emit_head(request_rec *r, char *header_fname, int suppress_amble,
 		 * the file's contents, any HTML header it had won't end up
 		 * where it belongs.
 		 */
-		if (ap_open(&f, rr->filename, APR_READ,
+		if (apr_open(&f, rr->filename, APR_READ,
                             APR_OS_DEFAULT, r->pool) == APR_SUCCESS) {
 		    emit_preamble(r, title);
 		    emit_amble = 0;
 		    do_emit_plain(r, f);
-		    ap_close(f);
+		    apr_close(f);
 		    emit_H1 = 0;
 		}
 	    }
@@ -1046,7 +1046,7 @@ static void emit_head(request_rec *r, char *header_fname, int suppress_amble,
  */
 static void emit_tail(request_rec *r, char *readme_fname, int suppress_amble)
 {
-    ap_file_t *f = NULL;
+    apr_file_t *f = NULL;
     request_rec *rr = NULL;
     int suppress_post = 0;
     int suppress_sig = 0;
@@ -1079,10 +1079,10 @@ static void emit_tail(request_rec *r, char *readme_fname, int suppress_amble)
 		/*
 		 * If we can open the file, suppress the signature.
 		 */
-		if (ap_open(&f, rr->filename, APR_READ,
+		if (apr_open(&f, rr->filename, APR_READ,
                             APR_OS_DEFAULT, r->pool) == APR_SUCCESS) {
 		    do_emit_plain(r, f);
-		    ap_close(f);
+		    apr_close(f);
 		    suppress_sig = 1;
 		}
 	    }
@@ -1104,9 +1104,9 @@ static void emit_tail(request_rec *r, char *readme_fname, int suppress_amble)
 static char *find_title(request_rec *r)
 {
     char titlebuf[MAX_STRING_LEN], *find = "<TITLE>";
-    ap_file_t *thefile = NULL;
+    apr_file_t *thefile = NULL;
     int x, y, p;
-    ap_ssize_t n;
+    apr_ssize_t n;
 
     if (r->status != HTTP_OK) {
 	return NULL;
@@ -1116,14 +1116,14 @@ static char *find_title(request_rec *r)
 			"text/html")
 	    || !strcmp(r->content_type, INCLUDES_MAGIC_TYPE))
 	&& !r->content_encoding) {
-        if (ap_open(&thefile, r->filename, APR_READ,
+        if (apr_open(&thefile, r->filename, APR_READ,
                     APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
 	    return NULL;
 	}
         n = sizeof(char) * (MAX_STRING_LEN - 1);
-	ap_read(thefile, titlebuf, &n);
+	apr_read(thefile, titlebuf, &n);
 	if (n <= 0) {
-	    ap_close(thefile);
+	    apr_close(thefile);
 	    return NULL;
 	}
 	titlebuf[n] = '\0';
@@ -1144,15 +1144,15 @@ static char *find_title(request_rec *r)
 			    }
 			}
 		    }
-		    ap_close(thefile);
-		    return ap_pstrdup(r->pool, &titlebuf[x]);
+		    apr_close(thefile);
+		    return apr_pstrdup(r->pool, &titlebuf[x]);
 		}
 	    }
 	    else {
 		p = 0;
 	    }
 	}
-	ap_close(thefile);
+	apr_close(thefile);
     }
     return NULL;
 }
@@ -1172,8 +1172,8 @@ static struct ent *make_autoindex_entry(char *name, int autoindex_opts,
         return (NULL);
     }
 
-    p = (struct ent *) ap_pcalloc(r->pool, sizeof(struct ent));
-    p->name = ap_pstrdup(r->pool, name);
+    p = (struct ent *) apr_pcalloc(r->pool, sizeof(struct ent));
+    p->name = apr_pstrdup(r->pool, name);
     p->size = -1;
     p->icon = NULL;
     p->alt = NULL;
@@ -1196,7 +1196,7 @@ static struct ent *make_autoindex_entry(char *name, int autoindex_opts,
 		    p->alt = "DIR";
 		}
 		p->size = -1;
-		p->name = ap_pstrcat(r->pool, name, "/", NULL);
+		p->name = apr_pstrcat(r->pool, name, "/", NULL);
 	    }
 	    else {
 		p->icon = find_icon(d, rr, 0);
@@ -1208,7 +1208,7 @@ static struct ent *make_autoindex_entry(char *name, int autoindex_opts,
 	p->desc = find_desc(d, rr);
 
 	if ((!p->desc) && (autoindex_opts & SCAN_HTML_TITLES)) {
-	    p->desc = ap_pstrdup(r->pool, find_title(rr));
+	    p->desc = apr_pstrdup(r->pool, find_title(rr));
 	}
 
 	ap_destroy_sub_req(rr);
@@ -1299,16 +1299,16 @@ static void output_directories(struct ent **ar, int n,
 			       int autoindex_opts, char keyid, char direction)
 {
     int x;
-    ap_size_t rv;
+    apr_size_t rv;
     char *name = r->uri;
     char *tp;
     int static_columns = (autoindex_opts & SUPPRESS_COLSORT);
-    ap_pool_t *scratch;
+    apr_pool_t *scratch;
     int name_width;
     char *name_scratch;
     char *pad_scratch;
 
-    ap_create_pool(&scratch, r->pool);
+    apr_create_pool(&scratch, r->pool);
     if (name[0] == '\0') {
 	name = "/";
     }
@@ -1322,8 +1322,8 @@ static void output_directories(struct ent **ar, int n,
 	    }
 	}
     }
-    name_scratch = ap_palloc(r->pool, name_width + 1);
-    pad_scratch = ap_palloc(r->pool, name_width + 1);
+    name_scratch = apr_palloc(r->pool, name_width + 1);
+    pad_scratch = apr_palloc(r->pool, name_width + 1);
     memset(pad_scratch, ' ', name_width);
     pad_scratch[name_width] = '\0';
 
@@ -1372,7 +1372,7 @@ static void output_directories(struct ent **ar, int n,
 	char *anchor, *t, *t2;
 	int nwidth;
 
-	ap_clear_pool(scratch);
+	apr_clear_pool(scratch);
 
 	if (is_parent(ar[x]->name)) {
 	    t = ap_make_full_path(scratch, name, "../");
@@ -1431,8 +1431,8 @@ static void output_directories(struct ent **ar, int n,
 		if (ar[x]->lm != -1) {
 		    char time_str[MAX_STRING_LEN];
 		    ap_exploded_time_t ts;
-                    ap_explode_localtime(&ts, ar[x]->lm);
-		    ap_strftime(time_str, &rv, MAX_STRING_LEN, 
+                    apr_explode_localtime(&ts, ar[x]->lm);
+		    apr_strftime(time_str, &rv, MAX_STRING_LEN, 
                                 "%d-%b-%Y %H:%M  ", &ts);
 		    ap_rputs(time_str, r);
 		}
@@ -1519,7 +1519,7 @@ static int dsortf(struct ent **e1, struct ent **e2)
         break;
     case K_DESC:
 	if (c1->version_sort)
-	    result = ap_strnatcmp(c1->desc ? c1->desc : "", c2->desc ? c2->desc : "");
+	    result = apr_strnatcmp(c1->desc ? c1->desc : "", c2->desc ? c2->desc : "");
 	else
 	    result = strcmp(c1->desc ? c1->desc : "", c2->desc ? c2->desc : "");
         if (result) {
@@ -1528,7 +1528,7 @@ static int dsortf(struct ent **e1, struct ent **e2)
         break;
     }
     if (c1->version_sort)
-	return ap_strnatcmp(c1->name, c2->name);
+	return apr_strnatcmp(c1->name, c2->name);
     else
 	return strcmp(c1->name, c2->name);
 }
@@ -1541,8 +1541,8 @@ static int index_directory(request_rec *r,
     char *title_endp;
     char *name = r->filename;
 
-    ap_dir_t *d;
-    ap_status_t status;
+    apr_dir_t *d;
+    apr_status_t status;
     int num_ent = 0, x;
     struct ent *head, *p;
     struct ent **ar = NULL;
@@ -1551,7 +1551,7 @@ static int index_directory(request_rec *r,
     char keyid;
     char direction;
 
-    if ((status = ap_opendir(&d, name, r->pool)) != APR_SUCCESS) {
+    if ((status = apr_opendir(&d, name, r->pool)) != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
 		    "Can't open directory for index: %s", r->filename);
 	return HTTP_FORBIDDEN;
@@ -1562,7 +1562,7 @@ static int index_directory(request_rec *r,
     ap_send_http_header(r);
 
     if (r->header_only) {
-	ap_closedir(d);
+	apr_closedir(d);
 	return 0;
     }
 
@@ -1614,9 +1614,9 @@ static int index_directory(request_rec *r,
      * linked list and then arrayificate them so qsort can use them. 
      */
     head = NULL;
-    while (ap_readdir(d) == APR_SUCCESS) {
+    while (apr_readdir(d) == APR_SUCCESS) {
         char *d_name;
-        ap_get_dir_filename(&d_name, d);
+        apr_get_dir_filename(&d_name, d);
 	p = make_autoindex_entry(d_name, autoindex_opts,
 				 autoindex_conf, r, keyid, direction);
 	if (p != NULL) {
@@ -1626,7 +1626,7 @@ static int index_directory(request_rec *r,
 	}
     }
     if (num_ent > 0) {
-	ar = (struct ent **) ap_palloc(r->pool,
+	ar = (struct ent **) apr_palloc(r->pool,
 				       num_ent * sizeof(struct ent *));
 	p = head;
 	x = 0;
@@ -1640,7 +1640,7 @@ static int index_directory(request_rec *r,
     }
     output_directories(ar, num_ent, autoindex_conf, r, autoindex_opts, keyid,
 		       direction);
-    ap_closedir(d);
+    apr_closedir(d);
 
     if (autoindex_opts & FANCY_INDEXING) {
 	ap_rputs("<HR>\n", r);
@@ -1675,7 +1675,7 @@ static int handle_autoindex(request_rec *r)
 	 */
 
 	if (r->filename[strlen(r->filename) - 1] != '/') {
-	    r->filename = ap_pstrcat(r->pool, r->filename, "/", NULL);
+	    r->filename = apr_pstrcat(r->pool, r->filename, "/", NULL);
 	}
 	return index_directory(r, d);
     }
@@ -1700,7 +1700,7 @@ module MODULE_VAR_EXPORT autoindex_module =
     merge_autoindex_configs,	/* dir merger --- default is to override */
     NULL,			/* server config */
     NULL,			/* merge server config */
-    autoindex_cmds,		/* command ap_table_t */
+    autoindex_cmds,		/* command apr_table_t */
     autoindex_handlers,		/* handlers */
     NULL			/* register hooks */
 };
diff --git a/modules/generators/mod_cgi.c b/modules/generators/mod_cgi.c
index 3bde51f..a79d2c3 100644
--- a/modules/generators/mod_cgi.c
+++ b/modules/generators/mod_cgi.c
@@ -99,7 +99,7 @@ module MODULE_VAR_EXPORT cgi_module;
 
 static int is_scriptaliased(request_rec *r)
 {
-    const char *t = ap_table_get(r->notes, "alias-forced-type");
+    const char *t = apr_table_get(r->notes, "alias-forced-type");
     return t && (!strcasecmp(t, "cgi-script"));
 }
 
@@ -114,10 +114,10 @@ typedef struct {
     int bufbytes;
 } cgi_server_conf;
 
-static void *create_cgi_config(ap_pool_t *p, server_rec *s)
+static void *create_cgi_config(apr_pool_t *p, server_rec *s)
 {
     cgi_server_conf *c =
-    (cgi_server_conf *) ap_pcalloc(p, sizeof(cgi_server_conf));
+    (cgi_server_conf *) apr_pcalloc(p, sizeof(cgi_server_conf));
 
     c->logname = NULL;
     c->logbytes = DEFAULT_LOGBYTES;
@@ -126,7 +126,7 @@ static void *create_cgi_config(ap_pool_t *p, server_rec *s)
     return c;
 }
 
-static void *merge_cgi_config(ap_pool_t *p, void *basev, void *overridesv)
+static void *merge_cgi_config(apr_pool_t *p, void *basev, void *overridesv)
 {
     cgi_server_conf *base = (cgi_server_conf *) basev, *overrides = (cgi_server_conf *) overridesv;
 
@@ -179,31 +179,31 @@ AP_INIT_TAKE1("ScriptLogBuffer", set_scriptlog_buffer, NULL, RSRC_CONF,
 static int log_scripterror(request_rec *r, cgi_server_conf * conf, int ret,
 			   int show_errno, char *error)
 {
-    ap_file_t *f = NULL;
-    ap_finfo_t finfo;
+    apr_file_t *f = NULL;
+    apr_finfo_t finfo;
     char time_str[AP_CTIME_LEN];
 
     ap_log_rerror(APLOG_MARK, show_errno|APLOG_ERR, errno, r, 
 		"%s: %s", error, r->filename);
 
     if (!conf->logname ||
-        ((ap_stat(&finfo, ap_server_root_relative(r->pool, conf->logname), r->pool) == APR_SUCCESS)
+        ((apr_stat(&finfo, ap_server_root_relative(r->pool, conf->logname), r->pool) == APR_SUCCESS)
          &&  (finfo.size > conf->logbytes)) ||
-          (ap_open(&f, ap_server_root_relative(r->pool, conf->logname),
+          (apr_open(&f, ap_server_root_relative(r->pool, conf->logname),
                    APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) {
 	return ret;
     }
 
     /* "%% [Wed Jun 19 10:53:21 1996] GET /cgi-bin/printenv HTTP/1.0" */
-    ap_ctime(time_str, ap_now());
-    ap_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri,
+    apr_ctime(time_str, apr_now());
+    apr_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri,
 	    r->args ? "?" : "", r->args ? r->args : "", r->protocol);
     /* "%% 500 /usr/local/apache/cgi-bin */
-    ap_fprintf(f, "%%%% %d %s\n", ret, r->filename);
+    apr_fprintf(f, "%%%% %d %s\n", ret, r->filename);
 
-    ap_fprintf(f, "%%error\n%s\n", error);
+    apr_fprintf(f, "%%error\n%s\n", error);
 
-    ap_close(f);
+    apr_close(f);
     return ret;
 }
 
@@ -227,18 +227,18 @@ static void log_script_err(request_rec *r, BUFF *script_err)
 static int log_script(request_rec *r, cgi_server_conf * conf, int ret,
 		  char *dbuf, const char *sbuf, BUFF *script_in, BUFF *script_err)
 {
-    ap_array_header_t *hdrs_arr = ap_table_elts(r->headers_in);
-    ap_table_entry_t *hdrs = (ap_table_entry_t *) hdrs_arr->elts;
+    apr_array_header_t *hdrs_arr = ap_table_elts(r->headers_in);
+    apr_table_entry_t *hdrs = (apr_table_entry_t *) hdrs_arr->elts;
     char argsbuffer[HUGE_STRING_LEN];
-    ap_file_t *f = NULL;
+    apr_file_t *f = NULL;
     int i;
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     char time_str[AP_CTIME_LEN];
 
     if (!conf->logname ||
-        ((ap_stat(&finfo, ap_server_root_relative(r->pool, conf->logname), r->pool) == APR_SUCCESS)
+        ((apr_stat(&finfo, ap_server_root_relative(r->pool, conf->logname), r->pool) == APR_SUCCESS)
          &&  (finfo.size > conf->logbytes)) ||
-         (ap_open(&f, ap_server_root_relative(r->pool, conf->logname),
+         (apr_open(&f, ap_server_root_relative(r->pool, conf->logname),
                   APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) {
 	/* Soak up script output */
 	while (ap_bgets(argsbuffer, HUGE_STRING_LEN, script_in) > 0)
@@ -249,66 +249,66 @@ static int log_script(request_rec *r, cgi_server_conf * conf, int ret,
     }
 
     /* "%% [Wed Jun 19 10:53:21 1996] GET /cgi-bin/printenv HTTP/1.0" */
-    ap_ctime(time_str, ap_now());
-    ap_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri,
+    apr_ctime(time_str, apr_now());
+    apr_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri,
 	    r->args ? "?" : "", r->args ? r->args : "", r->protocol);
     /* "%% 500 /usr/local/apache/cgi-bin" */
-    ap_fprintf(f, "%%%% %d %s\n", ret, r->filename);
+    apr_fprintf(f, "%%%% %d %s\n", ret, r->filename);
 
-    ap_puts("%request\n", f);
+    apr_puts("%request\n", f);
     for (i = 0; i < hdrs_arr->nelts; ++i) {
 	if (!hdrs[i].key)
 	    continue;
-	ap_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
+	apr_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
     }
     if ((r->method_number == M_POST || r->method_number == M_PUT)
 	&& *dbuf) {
-	ap_fprintf(f, "\n%s\n", dbuf);
+	apr_fprintf(f, "\n%s\n", dbuf);
     }
 
-    ap_puts("%response\n", f);
+    apr_puts("%response\n", f);
     hdrs_arr = ap_table_elts(r->err_headers_out);
-    hdrs = (ap_table_entry_t *) hdrs_arr->elts;
+    hdrs = (apr_table_entry_t *) hdrs_arr->elts;
 
     for (i = 0; i < hdrs_arr->nelts; ++i) {
 	if (!hdrs[i].key)
 	    continue;
-	ap_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
+	apr_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
     }
 
     if (sbuf && *sbuf)
-	ap_fprintf(f, "%s\n", sbuf);
+	apr_fprintf(f, "%s\n", sbuf);
 
     if (ap_bgets(argsbuffer, HUGE_STRING_LEN, script_in) > 0) {
-	ap_puts("%stdout\n", f);
-	ap_puts(argsbuffer, f);
+	apr_puts("%stdout\n", f);
+	apr_puts(argsbuffer, f);
 	while (ap_bgets(argsbuffer, HUGE_STRING_LEN, script_in) > 0)
-	    ap_puts(argsbuffer, f);
-	ap_puts("\n", f);
+	    apr_puts(argsbuffer, f);
+	apr_puts("\n", f);
     }
 
     if (ap_bgets(argsbuffer, HUGE_STRING_LEN, script_err) > 0) {
-	ap_puts("%stderr\n", f);
-	ap_puts(argsbuffer, f);
+	apr_puts("%stderr\n", f);
+	apr_puts(argsbuffer, f);
 	while (ap_bgets(argsbuffer, HUGE_STRING_LEN, script_err) > 0)
-	    ap_puts(argsbuffer, f);
-	ap_puts("\n", f);
+	    apr_puts(argsbuffer, f);
+	apr_puts("\n", f);
     }
 
     ap_bclose(script_in);
     ap_bclose(script_err);
 
-    ap_close(f);
+    apr_close(f);
     return ret;
 }
-static ap_status_t run_cgi_child(BUFF **script_out, BUFF **script_in, BUFF **script_err, 
-                                 char *command, char *const argv[], request_rec *r, ap_pool_t *p)
+static apr_status_t run_cgi_child(BUFF **script_out, BUFF **script_in, BUFF **script_err, 
+                                 char *command, char *const argv[], request_rec *r, apr_pool_t *p)
 {
     char **env;
-    ap_procattr_t *procattr;
-    ap_proc_t *procnew = ap_pcalloc(p, sizeof(*procnew));
-    ap_status_t rc = APR_SUCCESS;
-    ap_file_t *file = NULL;
+    apr_procattr_t *procattr;
+    apr_proc_t *procnew = apr_pcalloc(p, sizeof(*procnew));
+    apr_status_t rc = APR_SUCCESS;
+    apr_file_t *file = NULL;
     ap_iol *iol;
 #if defined(RLIMIT_CPU)  || defined(RLIMIT_NPROC) || \
     defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined (RLIMIT_AS)
@@ -345,29 +345,29 @@ static ap_status_t run_cgi_child(BUFF **script_out, BUFF **script_in, BUFF **scr
     /* Transumute ourselves into the script.
      * NB only ISINDEX scripts get decoded arguments.
      */
-    if (((rc = ap_createprocattr_init(&procattr, p)) != APR_SUCCESS) ||
-        ((rc = ap_setprocattr_io(procattr, 
+    if (((rc = apr_createprocattr_init(&procattr, p)) != APR_SUCCESS) ||
+        ((rc = apr_setprocattr_io(procattr, 
                                  APR_CHILD_BLOCK, 
                                  APR_CHILD_BLOCK,
                                  APR_CHILD_BLOCK)) != APR_SUCCESS) ||
-        ((rc = ap_setprocattr_dir(procattr, 
+        ((rc = apr_setprocattr_dir(procattr, 
                                   ap_make_dirstr_parent(r->pool, r->filename))) != APR_SUCCESS) ||
 #ifdef RLIMIT_CPU
-        ((rc = ap_setprocattr_limit(procattr, APR_LIMIT_CPU, conf->limit_cpu)) != APR_SUCCESS) ||
+        ((rc = apr_setprocattr_limit(procattr, APR_LIMIT_CPU, conf->limit_cpu)) != APR_SUCCESS) ||
 #endif
 #if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
-        ((rc = ap_setprocattr_limit(procattr, APR_LIMIT_MEM, conf->limit_mem)) != APR_SUCCESS) ||
+        ((rc = apr_setprocattr_limit(procattr, APR_LIMIT_MEM, conf->limit_mem)) != APR_SUCCESS) ||
 #endif
 #ifdef RLIMIT_NPROC
-        ((rc = ap_setprocattr_limit(procattr, APR_LIMIT_NPROC, conf->limit_nproc)) != APR_SUCCESS) ||
+        ((rc = apr_setprocattr_limit(procattr, APR_LIMIT_NPROC, conf->limit_nproc)) != APR_SUCCESS) ||
 #endif
-        ((rc = ap_setprocattr_cmdtype(procattr, APR_PROGRAM)) != APR_SUCCESS)) {
+        ((rc = apr_setprocattr_cmdtype(procattr, APR_PROGRAM)) != APR_SUCCESS)) {
         /* Something bad happened, tell the world. */
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
 		      "couldn't set child process attributes: %s", r->filename);
     }
     else {
-        rc = ap_create_process(procnew, command, argv, env, procattr, p);
+        rc = apr_create_process(procnew, command, argv, env, procattr, p);
     
         if (rc != APR_SUCCESS) {
             /* Bad things happened. Everyone should have cleaned up. */
@@ -375,7 +375,7 @@ static ap_status_t run_cgi_child(BUFF **script_out, BUFF **script_in, BUFF **scr
                         "couldn't create child process: %d: %s", rc, r->filename);
         }
         else {
-            ap_note_subprocess(p, procnew, kill_after_timeout);
+            apr_note_subprocess(p, procnew, kill_after_timeout);
 
             /* Fill in BUFF structure for parents pipe to child's stdout */
             file = procnew->out;
@@ -407,7 +407,7 @@ static ap_status_t run_cgi_child(BUFF **script_out, BUFF **script_in, BUFF **scr
     }
     return (rc);
 }
-static ap_status_t build_argv_list(char ***argv, request_rec *r, ap_pool_t *p)
+static apr_status_t build_argv_list(char ***argv, request_rec *r, apr_pool_t *p)
 {
     int numwords, x, idx;
     char *w;
@@ -430,7 +430,7 @@ static ap_status_t build_argv_list(char ***argv, request_rec *r, ap_pool_t *p)
     if (numwords > APACHE_ARG_MAX - 1) {
         numwords = APACHE_ARG_MAX - 1;	/* Truncate args to prevent overrun */
     }
-    *argv = (char **) ap_palloc(p, (numwords + 2) * sizeof(char *));
+    *argv = (char **) apr_palloc(p, (numwords + 2) * sizeof(char *));
  
     for (x = 1, idx = 1; x < numwords; x++) {
         w = ap_getword_nulls(p, &args, '+');
@@ -442,7 +442,7 @@ static ap_status_t build_argv_list(char ***argv, request_rec *r, ap_pool_t *p)
     return APR_SUCCESS;
 }
 
-static ap_status_t build_command_line(char **cmd, request_rec *r, ap_pool_t *p)
+static apr_status_t build_command_line(char **cmd, request_rec *r, apr_pool_t *p)
 {
 #ifdef WIN32
     char *quoted_filename = NULL;
@@ -462,24 +462,24 @@ static ap_status_t build_command_line(char **cmd, request_rec *r, ap_pool_t *p)
     }
 
     /*
-     * Build the command string to pass to ap_create_process()
+     * Build the command string to pass to apr_create_process()
      */
-    quoted_filename = ap_pstrcat(p, "\"", r->filename, "\"", NULL);
+    quoted_filename = apr_pstrcat(p, "\"", r->filename, "\"", NULL);
     if (interpreter && *interpreter) {
         if (arguments && *arguments)
-            *cmd = ap_pstrcat(p, interpreter, " ", quoted_filename, " ", 
+            *cmd = apr_pstrcat(p, interpreter, " ", quoted_filename, " ", 
                               arguments, NULL);
         else
-            *cmd = ap_pstrcat(p, interpreter, " ", quoted_filename, " ", NULL);
+            *cmd = apr_pstrcat(p, interpreter, " ", quoted_filename, " ", NULL);
     }
     else if (arguments && *arguments) {
-        *cmd = ap_pstrcat(p, quoted_filename, " ", arguments, NULL);
+        *cmd = apr_pstrcat(p, quoted_filename, " ", arguments, NULL);
     }
     else {
-        *cmd = ap_pstrcat(p, quoted_filename, NULL);
+        *cmd = apr_pstrcat(p, quoted_filename, NULL);
     }
 #else
-    *cmd = ap_pstrcat(p, r->filename, NULL);
+    *cmd = apr_pstrcat(p, r->filename, NULL);
 #endif
     return APR_SUCCESS;
 }
@@ -495,7 +495,7 @@ static int cgi_handler(request_rec *r)
     char argsbuffer[HUGE_STRING_LEN];
     int is_included = !strcmp(r->protocol, "INCLUDED");
     void *sconf = r->server->module_config;
-    ap_pool_t *p;
+    apr_pool_t *p;
     cgi_server_conf *conf =
     (cgi_server_conf *) ap_get_module_config(sconf, &cgi_module);
 
@@ -525,11 +525,11 @@ static int cgi_handler(request_rec *r)
 #if defined(OS2) || defined(WIN32)
     /* Allow for cgi files without the .EXE extension on them under OS/2 */
     if (r->finfo.protection == 0) {
-        ap_finfo_t finfo;
+        apr_finfo_t finfo;
         char *newfile;
 
-        newfile = ap_pstrcat(r->pool, r->filename, ".EXE", NULL);
-        if ((ap_stat(&finfo, newfile, r->pool) != APR_SUCCESS) || 
+        newfile = apr_pstrcat(r->pool, r->filename, ".EXE", NULL);
+        if ((apr_stat(&finfo, newfile, r->pool) != APR_SUCCESS) || 
             (finfo.filetype != APR_REG)) {
             return log_scripterror(r, conf, HTTP_NOT_FOUND, 0,
                                    "script not found or unable to stat");
@@ -571,7 +571,7 @@ static int cgi_handler(request_rec *r)
                       "couldn't spawn child process: %s", r->filename);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
-    argv[0] = ap_pstrdup(p, command);
+    argv[0] = apr_pstrdup(p, command);
     /* run the script in its own process */
     if (run_cgi_child(&script_out, &script_in, &script_err, command, argv, r, p) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
@@ -584,10 +584,10 @@ static int cgi_handler(request_rec *r)
      */
     if (ap_should_client_block(r)) {
 	int dbsize, len_read;
-        ap_ssize_t bytes_written;
+        apr_ssize_t bytes_written;
 
 	if (conf->logname) {
-	    dbuf = ap_pcalloc(r->pool, conf->bufbytes + 1);
+	    dbuf = apr_pcalloc(r->pool, conf->bufbytes + 1);
 	    dbpos = 0;
 	}
 
@@ -627,7 +627,7 @@ static int cgi_handler(request_rec *r)
 	    return log_script(r, conf, ret, dbuf, sbuf, script_in, script_err);
 	}
 
-	location = ap_table_get(r->headers_out, "Location");
+	location = apr_table_get(r->headers_out, "Location");
 
 	if (location && location[0] == '/' && r->status == 200) {
 
@@ -639,14 +639,14 @@ static int cgi_handler(request_rec *r)
 	    /* This redirect needs to be a GET no matter what the original
 	     * method was.
 	     */
-	    r->method = ap_pstrdup(r->pool, "GET");
+	    r->method = apr_pstrdup(r->pool, "GET");
 	    r->method_number = M_GET;
 
 	    /* We already read the message body (if any), so don't allow
 	     * the redirected request to think it has one.  We can ignore 
 	     * Transfer-Encoding, since we used REQUEST_CHUNKED_ERROR.
 	     */
-	    ap_table_unset(r->headers_in, "Content-Length");
+	    apr_table_unset(r->headers_in, "Content-Length");
 
 	    ap_internal_redirect_handler(location, r);
 	    return OK;
@@ -689,7 +689,7 @@ module MODULE_VAR_EXPORT cgi_module =
     NULL,			/* dir merger --- default is to override */
     create_cgi_config,		/* server config */
     merge_cgi_config,		/* merge server config */
-    cgi_cmds,			/* command ap_table_t */
+    cgi_cmds,			/* command apr_table_t */
     cgi_handlers,		/* handlers */
     NULL			/* register hooks */
 };
diff --git a/modules/generators/mod_cgid.c b/modules/generators/mod_cgid.c
index e8b1bc5..9e9e591 100644
--- a/modules/generators/mod_cgid.c
+++ b/modules/generators/mod_cgid.c
@@ -106,10 +106,10 @@
 
 module MODULE_VAR_EXPORT cgid_module; 
 
-static void cgid_init(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *main_server); 
+static void cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *main_server); 
 static int once_through = 0; 
 
-static ap_pool_t *pcgi; 
+static apr_pool_t *pcgi; 
 
 /* KLUDGE --- for back-combatibility, we don't have to check Execcgid 
  * in ScriptAliased directories, which means we need to know if this 
@@ -119,7 +119,7 @@ static ap_pool_t *pcgi;
 
 static int is_scriptaliased(request_rec *r) 
 { 
-    const char *t = ap_table_get(r->notes, "alias-forced-type"); 
+    const char *t = apr_table_get(r->notes, "alias-forced-type"); 
     return t && (!strcasecmp(t, "cgi-script")); 
 } 
 
@@ -165,7 +165,7 @@ typedef struct {
  * are handled in create_argv.
  *
  */
-static char **create_argv(ap_pool_t *p, char *path, char *user, char *group,
+static char **create_argv(apr_pool_t *p, char *path, char *user, char *group,
                           char *av0, const char *args)
 {
     int x, numwords;
@@ -184,7 +184,7 @@ static char **create_argv(ap_pool_t *p, char *path, char *user, char *group,
     if (numwords > APACHE_ARG_MAX - 5) {
         numwords = APACHE_ARG_MAX - 5;  /* Truncate args to prevent overrun */
     }
-    av = (char **) ap_palloc(p, (numwords + 5) * sizeof(char *));
+    av = (char **) apr_palloc(p, (numwords + 5) * sizeof(char *));
 
     if (path) {
         av[idx++] = path;
@@ -215,7 +215,7 @@ static int call_exec(request_rec *r, char *argv0, char **env, int shellcmd)
      * put the error messages from the log_* functions. So, we use stderr,
      * since that is better than allowing errors to go unnoticed. 
      */
-    ap_put_os_file(&r->server->error_log, &errfileno, r->pool);
+    apr_put_os_file(&r->server->error_log, &errfileno, r->pool);
     /* TODO: reimplement suexec */
 #if 0
     if (ap_suexec_enabled
@@ -229,7 +229,7 @@ static int call_exec(request_rec *r, char *argv0, char **env, int shellcmd)
 
         if (!strncmp("/~", r->uri, 2)) {
             gid_t user_gid;
-            char *username = ap_pstrdup(r->pool, r->uri + 2);
+            char *username = apr_pstrdup(r->pool, r->uri + 2);
             char *pos = strchr(username, '/');
 
             if (pos) {
@@ -241,15 +241,15 @@ static int call_exec(request_rec *r, char *argv0, char **env, int shellcmd)
                              "getpwnam: invalid username %s", username);
                 return (pid);
             }
-            execuser = ap_pstrcat(r->pool, "~", pw->pw_name, NULL);
+            execuser = apr_pstrcat(r->pool, "~", pw->pw_name, NULL);
             user_gid = pw->pw_gid;
 
             if ((gr = getgrgid(user_gid)) == NULL) {
-                if ((grpname = ap_palloc(r->pool, 16)) == NULL) {
+                if ((grpname = apr_palloc(r->pool, 16)) == NULL) {
                     return (pid);
                 }
                 else {
-                    ap_snprintf(grpname, 16, "%ld", (long) user_gid);
+                    apr_snprintf(grpname, 16, "%ld", (long) user_gid);
                 }
             }
             else {
@@ -263,7 +263,7 @@ static int call_exec(request_rec *r, char *argv0, char **env, int shellcmd)
                              (long) r->server->server_uid);
                 return (pid);
             }
-            execuser = ap_pstrdup(r->pool, pw->pw_name);
+            execuser = apr_pstrdup(r->pool, pw->pw_name);
 
             if ((gr = getgrgid(r->server->server_gid)) == NULL) {
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
@@ -321,12 +321,12 @@ static void cgid_maint(int reason, void *data, ap_wait_t status)
         case APR_OC_REASON_LOST:
             /* stop gap to make sure everything else works.  In the end,
              * we'll just restart the cgid server. */
-            ap_destroy_pool(pcgi);
+            apr_destroy_pool(pcgi);
             kill(getppid(), SIGWINCH);
             break;
         case APR_OC_REASON_RESTART:
         case APR_OC_REASON_UNREGISTER:
-            ap_destroy_pool(pcgi);
+            apr_destroy_pool(pcgi);
             kill(*sd, SIGHUP);
             break;
     }
@@ -341,11 +341,11 @@ static void get_req(int fd, request_rec *r, char **filename, char **argv0, char
     core_dir_config *temp_core; 
     void **dconf; 
 
-    r->server = ap_pcalloc(r->pool, sizeof(server_rec)); 
+    r->server = apr_pcalloc(r->pool, sizeof(server_rec)); 
 
     read(fd, &j, sizeof(int)); 
     read(fd, &len, sizeof(int)); 
-    data = ap_pcalloc(r->pool, len + 1); /* get a cleared byte for final '\0' */
+    data = apr_pcalloc(r->pool, len + 1); /* get a cleared byte for final '\0' */
     i = read(fd, data, len); 
 
     r->filename = ap_getword(r->pool, (const char **)&data, '\n'); 
@@ -353,7 +353,7 @@ static void get_req(int fd, request_rec *r, char **filename, char **argv0, char
 
     r->uri = ap_getword(r->pool, (const char **)&data, '\n'); 
     
-    environ = ap_pcalloc(r->pool, (j + 2) *sizeof(char *)); 
+    environ = apr_pcalloc(r->pool, (j + 2) *sizeof(char *)); 
     i = 0; 
     for (i = 0; i < j; i++) { 
         environ[i] = ap_getword(r->pool, (const char **)&data, '\n'); 
@@ -416,7 +416,7 @@ static void send_req(int fd, request_rec *r, char *argv0, char **env)
     int i = 0; 
     char *data; 
 
-    data = ap_pstrcat(r->pool, r->filename, "\n", argv0, "\n", r->uri, "\n", 
+    data = apr_pstrcat(r->pool, r->filename, "\n", argv0, "\n", r->uri, "\n", 
                      NULL); 
 
     for (i =0; env[i]; i++) { 
@@ -429,9 +429,9 @@ static void send_req(int fd, request_rec *r, char *argv0, char **env)
         }     
 
     for (i = 0; env[i]; i++) { 
-        data = ap_pstrcat(r->pool, data, env[i], "\n", NULL); 
+        data = apr_pstrcat(r->pool, data, env[i], "\n", NULL); 
     } 
-    data = ap_pstrcat(r->pool, data, r->args, NULL); 
+    data = apr_pstrcat(r->pool, data, r->args, NULL); 
     len = strlen(data); 
     if (write(fd, &len, sizeof(int)) < 0) { 
         ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r, 
@@ -497,11 +497,11 @@ static int cgid_server_child(int sd)
     char *argv0; 
     char *filename; 
     char **env; 
-    ap_pool_t *p; 
+    apr_pool_t *p; 
     request_rec *r; 
 
-    ap_create_pool(&p, pcgi); 
-    r = ap_pcalloc(p, sizeof(request_rec)); 
+    apr_create_pool(&p, pcgi); 
+    r = apr_pcalloc(p, sizeof(request_rec)); 
     r->pool = p; 
     dup2(sd, STDIN_FILENO); 
     dup2(sd, STDOUT_FILENO); 
@@ -521,7 +521,7 @@ static int cgid_server(void *data)
     cgid_server_conf *sconf = (cgid_server_conf *)ap_get_module_config( 
                        main_server->module_config, &cgid_module); 
 
-    ap_signal(SIGCHLD, SIG_IGN); 
+    apr_signal(SIGCHLD, SIG_IGN); 
     if (unlink(sconf->sockname) < 0 &&
         errno != ENOENT) {
         ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server,
@@ -588,7 +588,7 @@ static int cgid_server(void *data)
                 dup2(open(sconf->logname, O_WRONLY), STDERR_FILENO);
             }
             else {
-                ap_get_os_file(&errfile, main_server->error_log);
+                apr_get_os_file(&errfile, main_server->error_log);
                 dup2(errfile, STDERR_FILENO);
             }
             cgid_server_child(sd2); 
@@ -601,13 +601,13 @@ static int cgid_server(void *data)
     return -1; 
 } 
 
-static void cgid_init(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *main_server) 
+static void cgid_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *main_server) 
 { 
     pid_t pid; 
-    ap_proc_t *procnew;
+    apr_proc_t *procnew;
 
     if (once_through > 0) { 
-        ap_create_pool(&pcgi, p); 
+        apr_create_pool(&pcgi, p); 
 
         if ((pid = fork()) < 0) {
             ap_log_error(APLOG_MARK, APLOG_ERR, errno, main_server, 
@@ -617,21 +617,21 @@ static void cgid_init(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp, server_re
             cgid_server(main_server);
             exit(-1);
         } 
-        procnew = ap_pcalloc(p, sizeof(*procnew));        
+        procnew = apr_pcalloc(p, sizeof(*procnew));        
         procnew->pid = pid;
         procnew->err = procnew->in = procnew->out = NULL;
-        ap_note_subprocess(p, procnew, kill_after_timeout);
+        apr_note_subprocess(p, procnew, kill_after_timeout);
 #if APR_HAS_OTHER_CHILD
-        ap_register_other_child(procnew, cgid_maint, NULL, NULL, p);
+        apr_register_other_child(procnew, cgid_maint, NULL, NULL, p);
 #endif
     } 
     else once_through++; 
 } 
 
-static void *create_cgid_config(ap_pool_t *p, server_rec *s) 
+static void *create_cgid_config(apr_pool_t *p, server_rec *s) 
 { 
     cgid_server_conf *c = 
-    (cgid_server_conf *) ap_pcalloc(p, sizeof(cgid_server_conf)); 
+    (cgid_server_conf *) apr_pcalloc(p, sizeof(cgid_server_conf)); 
 
     c->logname = NULL; 
     c->logbytes = DEFAULT_LOGBYTES; 
@@ -641,7 +641,7 @@ static void *create_cgid_config(ap_pool_t *p, server_rec *s)
     return c; 
 } 
 
-static void *merge_cgid_config(ap_pool_t *p, void *basev, void *overridesv) 
+static void *merge_cgid_config(apr_pool_t *p, void *basev, void *overridesv) 
 { 
     cgid_server_conf *base = (cgid_server_conf *) basev, *overrides = (cgid_server_conf *) overridesv; 
 
@@ -705,7 +705,7 @@ static const command_rec cgid_cmds[] =
 static int log_scripterror(request_rec *r, cgid_server_conf * conf, int ret, 
                            int show_errno, char *error) 
 { 
-    ap_file_t *f = NULL; 
+    apr_file_t *f = NULL; 
     struct stat finfo; 
     char time_str[AP_CTIME_LEN];
 
@@ -715,31 +715,31 @@ static int log_scripterror(request_rec *r, cgid_server_conf * conf, int ret,
     if (!conf->logname || 
         ((stat(ap_server_root_relative(r->pool, conf->logname), &finfo) == 0) 
          && (finfo.st_size > conf->logbytes)) || 
-         (ap_open(&f, ap_server_root_relative(r->pool, conf->logname),
+         (apr_open(&f, ap_server_root_relative(r->pool, conf->logname),
                   APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) { 
         return ret; 
     } 
 
     /* "%% [Wed Jun 19 10:53:21 1996] GET /cgid-bin/printenv HTTP/1.0" */ 
-    ap_ctime(time_str, ap_now());
-    ap_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, 
+    apr_ctime(time_str, apr_now());
+    apr_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, 
             r->args ? "?" : "", r->args ? r->args : "", r->protocol); 
     /* "%% 500 /usr/local/apache/cgid-bin */ 
-    ap_fprintf(f, "%%%% %d %s\n", ret, r->filename); 
+    apr_fprintf(f, "%%%% %d %s\n", ret, r->filename); 
 
-    ap_fprintf(f, "%%error\n%s\n", error); 
+    apr_fprintf(f, "%%error\n%s\n", error); 
 
-    ap_close(f); 
+    apr_close(f); 
     return ret; 
 } 
 
 static int log_script(request_rec *r, cgid_server_conf * conf, int ret, 
                   char *dbuf, const char *sbuf, BUFF *script_in, BUFF *script_err) 
 { 
-    ap_array_header_t *hdrs_arr = ap_table_elts(r->headers_in); 
-    ap_table_entry_t *hdrs = (ap_table_entry_t *) hdrs_arr->elts; 
+    apr_array_header_t *hdrs_arr = ap_table_elts(r->headers_in); 
+    apr_table_entry_t *hdrs = (apr_table_entry_t *) hdrs_arr->elts; 
     char argsbuffer[HUGE_STRING_LEN]; 
-    ap_file_t *f = NULL; 
+    apr_file_t *f = NULL; 
     int i; 
     struct stat finfo; 
     char time_str[AP_CTIME_LEN];
@@ -747,7 +747,7 @@ static int log_script(request_rec *r, cgid_server_conf * conf, int ret,
     if (!conf->logname || 
         ((stat(ap_server_root_relative(r->pool, conf->logname), &finfo) == 0) 
          && (finfo.st_size > conf->logbytes)) || 
-         (ap_open(&f, ap_server_root_relative(r->pool, conf->logname), 
+         (apr_open(&f, ap_server_root_relative(r->pool, conf->logname), 
                   APR_APPEND|APR_WRITE|APR_CREATE, APR_OS_DEFAULT, r->pool) != APR_SUCCESS)) { 
         /* Soak up script output */ 
         while (ap_bgets(argsbuffer, HUGE_STRING_LEN, script_in) > 0) 
@@ -760,51 +760,51 @@ static int log_script(request_rec *r, cgid_server_conf * conf, int ret,
     } 
 
     /* "%% [Wed Jun 19 10:53:21 1996] GET /cgid-bin/printenv HTTP/1.0" */ 
-    ap_ctime(time_str, ap_now());
-    ap_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, 
+    apr_ctime(time_str, apr_now());
+    apr_fprintf(f, "%%%% [%s] %s %s%s%s %s\n", time_str, r->method, r->uri, 
             r->args ? "?" : "", r->args ? r->args : "", r->protocol); 
     /* "%% 500 /usr/local/apache/cgid-bin" */ 
-    ap_fprintf(f, "%%%% %d %s\n", ret, r->filename); 
+    apr_fprintf(f, "%%%% %d %s\n", ret, r->filename); 
 
-    ap_puts("%request\n", f); 
+    apr_puts("%request\n", f); 
     for (i = 0; i < hdrs_arr->nelts; ++i) { 
         if (!hdrs[i].key) 
             continue; 
-        ap_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val); 
+        apr_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val); 
     } 
     if ((r->method_number == M_POST || r->method_number == M_PUT) 
         && *dbuf) { 
-        ap_fprintf(f, "\n%s\n", dbuf); 
+        apr_fprintf(f, "\n%s\n", dbuf); 
     } 
 
-    ap_puts("%response\n", f); 
+    apr_puts("%response\n", f); 
     hdrs_arr = ap_table_elts(r->err_headers_out); 
-    hdrs = (ap_table_entry_t *) hdrs_arr->elts; 
+    hdrs = (apr_table_entry_t *) hdrs_arr->elts; 
 
     for (i = 0; i < hdrs_arr->nelts; ++i) { 
         if (!hdrs[i].key) 
             continue; 
-        ap_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val); 
+        apr_fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val); 
     } 
 
     if (sbuf && *sbuf) 
-        ap_fprintf(f, "%s\n", sbuf); 
+        apr_fprintf(f, "%s\n", sbuf); 
 
     if (ap_bgets(argsbuffer, HUGE_STRING_LEN, script_in) > 0) { 
-        ap_puts("%stdout\n", f); 
-        ap_puts(argsbuffer, f); 
+        apr_puts("%stdout\n", f); 
+        apr_puts(argsbuffer, f); 
         while (ap_bgets(argsbuffer, HUGE_STRING_LEN, script_in) > 0) 
-            ap_puts(argsbuffer, f); 
-        ap_puts("\n", f); 
+            apr_puts(argsbuffer, f); 
+        apr_puts("\n", f); 
     } 
 
     if (script_err) {
         if (ap_bgets(argsbuffer, HUGE_STRING_LEN, script_err) > 0) { 
-            ap_puts("%stderr\n", f); 
-            ap_puts(argsbuffer, f); 
+            apr_puts("%stderr\n", f); 
+            apr_puts(argsbuffer, f); 
             while (ap_bgets(argsbuffer, HUGE_STRING_LEN, script_err) > 0) 
-                ap_puts(argsbuffer, f); 
-            ap_puts("\n", f); 
+                apr_puts(argsbuffer, f); 
+            apr_puts("\n", f); 
         } 
     }
 
@@ -813,7 +813,7 @@ static int log_script(request_rec *r, cgid_server_conf * conf, int ret,
         ap_bclose(script_err); 
     }
 
-    ap_close(f); 
+    apr_close(f); 
     return ret; 
 } 
 
@@ -835,7 +835,7 @@ static int cgid_handler(request_rec *r)
     int sd;
     char **env; 
     struct sockaddr_un unix_addr;
-    ap_socket_t *tempsock = NULL;
+    apr_socket_t *tempsock = NULL;
     int nbytes;
     ap_iol *iol;
     script = ap_bcreate(r->pool, B_RDWR); 
@@ -872,7 +872,7 @@ static int cgid_handler(request_rec *r)
         struct stat statbuf; 
         char *newfile; 
 
-        newfile = ap_pstrcat(r->pool, r->filename, ".EXE", NULL); 
+        newfile = apr_pstrcat(r->pool, r->filename, ".EXE", NULL); 
 
         if ((stat(newfile, &statbuf) != 0) || (!S_ISREG(statbuf.st_mode))) { 
             return log_scripterror(r, conf, HTTP_NOT_FOUND, 0, 
@@ -915,7 +915,7 @@ static int cgid_handler(request_rec *r)
 
     send_req(sd, r, argv0, env); 
 
-    ap_put_os_sock(&tempsock, &sd, pcgi);
+    apr_put_os_sock(&tempsock, &sd, pcgi);
 
     iol = ap_iol_attach_socket(pcgi, tempsock);
 
@@ -937,7 +937,7 @@ static int cgid_handler(request_rec *r)
         int dbsize, len_read; 
 
         if (conf->logname) { 
-            dbuf = ap_pcalloc(r->pool, conf->bufbytes + 1); 
+            dbuf = apr_pcalloc(r->pool, conf->bufbytes + 1); 
             dbpos = 0; 
         } 
 
@@ -979,7 +979,7 @@ static int cgid_handler(request_rec *r)
             return log_script(r, conf, ret, dbuf, sbuf, script, NULL); 
         } 
 
-        location = ap_table_get(r->headers_out, "Location"); 
+        location = apr_table_get(r->headers_out, "Location"); 
 
         if (location && location[0] == '/' && r->status == 200) { 
 
@@ -990,14 +990,14 @@ static int cgid_handler(request_rec *r)
             /* This redirect needs to be a GET no matter what the original 
              * method was. 
              */ 
-            r->method = ap_pstrdup(r->pool, "GET"); 
+            r->method = apr_pstrdup(r->pool, "GET"); 
             r->method_number = M_GET; 
 
             /* We already read the message body (if any), so don't allow 
              * the redirected request to think it has one. We can ignore 
              * Transfer-Encoding, since we used REQUEST_CHUNKED_ERROR. 
              */ 
-            ap_table_unset(r->headers_in, "Content-Length"); 
+            apr_table_unset(r->headers_in, "Content-Length"); 
 
             ap_internal_redirect_handler(location, r); 
             return OK; 
diff --git a/modules/generators/mod_info.c b/modules/generators/mod_info.c
index c5dda74..e8f2e9d 100644
--- a/modules/generators/mod_info.c
+++ b/modules/generators/mod_info.c
@@ -94,7 +94,7 @@ typedef struct {
 } info_entry;
 
 typedef struct {
-    ap_array_header_t *more_info;
+    apr_array_header_t *more_info;
 } info_svr_conf;
 
 typedef struct info_cfg_lines {
@@ -106,21 +106,21 @@ typedef struct info_cfg_lines {
 module MODULE_VAR_EXPORT info_module;
 extern module *top_module;
 
-static void *create_info_config(ap_pool_t *p, server_rec *s)
+static void *create_info_config(apr_pool_t *p, server_rec *s)
 {
-    info_svr_conf *conf = (info_svr_conf *) ap_pcalloc(p, sizeof(info_svr_conf));
+    info_svr_conf *conf = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
 
-    conf->more_info = ap_make_array(p, 20, sizeof(info_entry));
+    conf->more_info = apr_make_array(p, 20, sizeof(info_entry));
     return conf;
 }
 
-static void *merge_info_config(ap_pool_t *p, void *basev, void *overridesv)
+static void *merge_info_config(apr_pool_t *p, void *basev, void *overridesv)
 {
-    info_svr_conf *new = (info_svr_conf *) ap_pcalloc(p, sizeof(info_svr_conf));
+    info_svr_conf *new = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
     info_svr_conf *base = (info_svr_conf *) basev;
     info_svr_conf *overrides = (info_svr_conf *) overridesv;
 
-    new->more_info = ap_append_arrays(p, overrides->more_info, base->more_info);
+    new->more_info = apr_append_arrays(p, overrides->more_info, base->more_info);
     return new;
 }
 
@@ -162,7 +162,7 @@ static char *mod_info_html_cmd_string(const char *string, char *buf, size_t buf_
     return (buf);
 }
 
-static info_cfg_lines *mod_info_load_config(ap_pool_t *p, const char *filename,
+static info_cfg_lines *mod_info_load_config(apr_pool_t *p, const char *filename,
                                             request_rec *r)
 {
     char s[MAX_STRING_LEN];
@@ -183,7 +183,7 @@ static info_cfg_lines *mod_info_load_config(ap_pool_t *p, const char *filename,
         if (*s == '#') {
             continue;           /* skip comments */
         }
-        new = ap_palloc(p, sizeof(struct info_cfg_lines));
+        new = apr_palloc(p, sizeof(struct info_cfg_lines));
         new->next = NULL;
         if (!ret) {
             ret = new;
@@ -194,7 +194,7 @@ static info_cfg_lines *mod_info_load_config(ap_pool_t *p, const char *filename,
 	t = s;
 	new->cmd = ap_getword_conf(p, &t);
 	if (*t) {
-	    new->line = ap_pstrdup(p, t);
+	    new->line = apr_pstrdup(p, t);
 	}
 	else {
 	    new->line = NULL;
@@ -641,7 +641,7 @@ static const char *add_module_info(cmd_parms *cmd, void *dummy, char *name,
     server_rec *s = cmd->server;
     info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                               &info_module);
-    info_entry *new = ap_push_array(conf->more_info);
+    info_entry *new = apr_push_array(conf->more_info);
 
     new->name = name;
     new->info = info;
@@ -669,7 +669,7 @@ module MODULE_VAR_EXPORT info_module =
     NULL,                       /* dir merger --- default is to override */
     create_info_config,         /* server config */
     merge_info_config,          /* merge server config */
-    info_cmds,                  /* command ap_table_t */
+    info_cmds,                  /* command apr_table_t */
     info_handlers,              /* handlers */
     NULL,                       /* filename translation */
     NULL,                       /* check_user_id */
diff --git a/modules/generators/mod_status.c b/modules/generators/mod_status.c
index 75009a5..de9dc88 100644
--- a/modules/generators/mod_status.c
+++ b/modules/generators/mod_status.c
@@ -81,7 +81,7 @@ static int print_status_value(void *data, const char *key, const char *val)
 static int status_handler(request_rec *r)
 {
     int i;
-    ap_array_header_t *server_status;
+    apr_array_header_t *server_status;
     ap_status_table_row_t *status_rows;
 
     r->allowed = (1 << M_GET);
@@ -107,14 +107,14 @@ static int status_handler(request_rec *r)
     ap_rvputs(r, "Server Built: ",
       ap_get_server_built(), "<br>\n<hr>\n", NULL);
     ap_rvputs(r, "Current Time: ",
-      ap_ht_time(r->pool, ap_now(), DEFAULT_TIME_FORMAT, 0), "<br>\n", NULL);
+      ap_ht_time(r->pool, apr_now(), DEFAULT_TIME_FORMAT, 0), "<br>\n", NULL);
     ap_rprintf(r, "\n%d connections currently being processed\n",
                server_status->nelts);
 
     status_rows = (ap_status_table_row_t *) server_status->elts;
     for (i = 0; i < server_status->nelts; i++) {
 	ap_rprintf(r, "<h2>Connection %ld</h2>\n", status_rows[i].conn_id);
-        ap_table_do(print_status_value, (void *) r, status_rows[i].data, NULL);
+        apr_table_do(print_status_value, (void *) r, status_rows[i].data, NULL);
     }
     ap_rputs("</body></html>\n", r);
     return 0;
diff --git a/modules/http/http_core.c b/modules/http/http_core.c
index 1ab446e..c00e9a3 100644
--- a/modules/http/http_core.c
+++ b/modules/http/http_core.c
@@ -129,21 +129,21 @@
  * the http_conf_globals.
  */
 
-static void *create_core_dir_config(ap_pool_t *a, char *dir)
+static void *create_core_dir_config(apr_pool_t *a, char *dir)
 {
     core_dir_config *conf;
 
-    conf = (core_dir_config *)ap_pcalloc(a, sizeof(core_dir_config));
+    conf = (core_dir_config *)apr_pcalloc(a, sizeof(core_dir_config));
     if (!dir || dir[strlen(dir) - 1] == '/') {
         conf->d = dir;
     }
     else if (strncmp(dir, "proxy:", 6) == 0) {
-        conf->d = ap_pstrdup(a, dir);
+        conf->d = apr_pstrdup(a, dir);
     }
     else {
-        conf->d = ap_pstrcat(a, dir, "/", NULL);
+        conf->d = apr_pstrcat(a, dir, "/", NULL);
     }
-    conf->d_is_fnmatch = conf->d ? (ap_is_fnmatch(conf->d) != 0) : 0;
+    conf->d_is_fnmatch = conf->d ? (apr_is_fnmatch(conf->d) != 0) : 0;
     conf->d_components = conf->d ? ap_count_dirs(conf->d) : 0;
 
     conf->opts = dir ? OPT_UNSET : OPT_UNSET|OPT_ALL;
@@ -170,7 +170,7 @@ static void *create_core_dir_config(ap_pool_t *a, char *dir)
 
     conf->limit_req_body = 0;
     conf->limit_xml_body = AP_LIMIT_UNSET;
-    conf->sec = ap_make_array(a, 2, sizeof(void *));
+    conf->sec = apr_make_array(a, 2, sizeof(void *));
 #ifdef WIN32
     conf->script_interpreter_source = INTERPRETER_SOURCE_UNSET;
 #endif
@@ -183,18 +183,18 @@ static void *create_core_dir_config(ap_pool_t *a, char *dir)
     return (void *)conf;
 }
 
-static void *merge_core_dir_configs(ap_pool_t *a, void *basev, void *newv)
+static void *merge_core_dir_configs(apr_pool_t *a, void *basev, void *newv)
 {
     core_dir_config *base = (core_dir_config *)basev;
     core_dir_config *new = (core_dir_config *)newv;
     core_dir_config *conf;
     int i;
   
-    conf = (core_dir_config *)ap_palloc(a, sizeof(core_dir_config));
+    conf = (core_dir_config *)apr_palloc(a, sizeof(core_dir_config));
     memcpy((char *)conf, (const char *)base, sizeof(core_dir_config));
     if (base->response_code_strings) {
 	conf->response_code_strings =
-	    ap_palloc(a, sizeof(*conf->response_code_strings)
+	    apr_palloc(a, sizeof(*conf->response_code_strings)
 		      * RESPONSE_CODES);
 	memcpy(conf->response_code_strings, base->response_code_strings,
 	       sizeof(*conf->response_code_strings) * RESPONSE_CODES);
@@ -245,7 +245,7 @@ static void *merge_core_dir_configs(ap_pool_t *a, void *basev, void *newv)
 
     if (new->response_code_strings) {
 	if (conf->response_code_strings == NULL) {
-	    conf->response_code_strings = ap_palloc(a,
+	    conf->response_code_strings = apr_palloc(a,
 		sizeof(*conf->response_code_strings) * RESPONSE_CODES);
 	    memcpy(conf->response_code_strings, new->response_code_strings,
 		   sizeof(*conf->response_code_strings) * RESPONSE_CODES);
@@ -297,7 +297,7 @@ static void *merge_core_dir_configs(ap_pool_t *a, void *basev, void *newv)
     else
         conf->limit_xml_body = base->limit_xml_body;
 
-    conf->sec = ap_append_arrays(a, base->sec, new->sec);
+    conf->sec = apr_append_arrays(a, base->sec, new->sec);
 
     if (new->satisfy != SATISFY_NOSPEC) {
         conf->satisfy = new->satisfy;
@@ -324,30 +324,30 @@ static void *merge_core_dir_configs(ap_pool_t *a, void *basev, void *newv)
     return (void*)conf;
 }
 
-static void *create_core_server_config(ap_pool_t *a, server_rec *s)
+static void *create_core_server_config(apr_pool_t *a, server_rec *s)
 {
     core_server_config *conf;
     int is_virtual = s->is_virtual;
   
-    conf = (core_server_config *)ap_pcalloc(a, sizeof(core_server_config));
+    conf = (core_server_config *)apr_pcalloc(a, sizeof(core_server_config));
 #ifdef GPROF
     conf->gprof_dir = NULL;
 #endif
     conf->access_name = is_virtual ? NULL : DEFAULT_ACCESS_FNAME;
     conf->ap_document_root = is_virtual ? NULL : DOCUMENT_LOCATION;
-    conf->sec = ap_make_array(a, 40, sizeof(void *));
-    conf->sec_url = ap_make_array(a, 40, sizeof(void *));
+    conf->sec = apr_make_array(a, 40, sizeof(void *));
+    conf->sec_url = apr_make_array(a, 40, sizeof(void *));
     
     return (void *)conf;
 }
 
-static void *merge_core_server_configs(ap_pool_t *p, void *basev, void *virtv)
+static void *merge_core_server_configs(apr_pool_t *p, void *basev, void *virtv)
 {
     core_server_config *base = (core_server_config *)basev;
     core_server_config *virt = (core_server_config *)virtv;
     core_server_config *conf;
 
-    conf = (core_server_config *)ap_pcalloc(p, sizeof(core_server_config));
+    conf = (core_server_config *)apr_pcalloc(p, sizeof(core_server_config));
     *conf = *virt;
     if (!conf->access_name) {
         conf->access_name = base->access_name;
@@ -355,8 +355,8 @@ static void *merge_core_server_configs(ap_pool_t *p, void *basev, void *virtv)
     if (!conf->ap_document_root) {
         conf->ap_document_root = base->ap_document_root;
     }
-    conf->sec = ap_append_arrays(p, base->sec, virt->sec);
-    conf->sec_url = ap_append_arrays(p, base->sec_url, virt->sec_url);
+    conf->sec = apr_append_arrays(p, base->sec, virt->sec);
+    conf->sec_url = apr_append_arrays(p, base->sec_url, virt->sec_url);
 
     return conf;
 }
@@ -369,7 +369,7 @@ CORE_EXPORT(void) ap_add_per_dir_conf(server_rec *s, void *dir_config)
 {
     core_server_config *sconf = ap_get_module_config(s->module_config,
 						     &core_module);
-    void **new_space = (void **)ap_push_array(sconf->sec);
+    void **new_space = (void **)apr_push_array(sconf->sec);
     
     *new_space = dir_config;
 }
@@ -378,14 +378,14 @@ CORE_EXPORT(void) ap_add_per_url_conf(server_rec *s, void *url_config)
 {
     core_server_config *sconf = ap_get_module_config(s->module_config,
 						     &core_module);
-    void **new_space = (void **)ap_push_array(sconf->sec_url);
+    void **new_space = (void **)apr_push_array(sconf->sec_url);
     
     *new_space = url_config;
 }
 
 CORE_EXPORT(void) ap_add_file_conf(core_dir_config *conf, void *url_config)
 {
-    void **new_space = (void **)ap_push_array(conf->sec);
+    void **new_space = (void **)apr_push_array(conf->sec);
     
     *new_space = url_config;
 }
@@ -449,15 +449,15 @@ static int reorder_sorter(const void *va, const void *vb)
     return a->orig_index - b->orig_index;
 }
 
-void ap_core_reorder_directories(ap_pool_t *p, server_rec *s)
+void ap_core_reorder_directories(apr_pool_t *p, server_rec *s)
 {
     core_server_config *sconf;
-    ap_array_header_t *sec;
+    apr_array_header_t *sec;
     struct reorder_sort_rec *sortbin;
     int nelts;
     void **elts;
     int i;
-    ap_pool_t *tmp;
+    apr_pool_t *tmp;
 
     sconf = ap_get_module_config(s->module_config, &core_module);
     sec = sconf->sec;
@@ -465,8 +465,8 @@ void ap_core_reorder_directories(ap_pool_t *p, server_rec *s)
     elts = (void **)sec->elts;
 
     /* we have to allocate tmp space to do a stable sort */
-    ap_create_pool(&tmp, p);
-    sortbin = ap_palloc(tmp, sec->nelts * sizeof(*sortbin));
+    apr_create_pool(&tmp, p);
+    sortbin = apr_palloc(tmp, sec->nelts * sizeof(*sortbin));
     for (i = 0; i < nelts; ++i) {
 	sortbin[i].orig_index = i;
 	sortbin[i].elt = elts[i];
@@ -479,7 +479,7 @@ void ap_core_reorder_directories(ap_pool_t *p, server_rec *s)
       elts[i] = sortbin[i].elt;
     }
 
-    ap_destroy_pool(tmp);
+    apr_destroy_pool(tmp);
 }
 
 /*****************************************************************
@@ -545,7 +545,7 @@ API_EXPORT(const char *) ap_document_root(request_rec *r) /* Don't use this! */
     return conf->ap_document_root;
 }
 
-API_EXPORT(const ap_array_header_t *) ap_requires(request_rec *r)
+API_EXPORT(const apr_array_header_t *) ap_requires(request_rec *r)
 {
     core_dir_config *conf;
 
@@ -640,7 +640,7 @@ API_EXPORT(const char *) ap_get_remote_host(conn_rec *conn, void *dir_config,
 	iaddr = &(conn->remote_addr.sin_addr);
 	hptr = gethostbyaddr((char *)iaddr, sizeof(struct in_addr), AF_INET);
 	if (hptr != NULL) {
-	    conn->remote_host = ap_pstrdup(conn->pool, (void *)hptr->h_name);
+	    conn->remote_host = apr_pstrdup(conn->pool, (void *)hptr->h_name);
 	    ap_str_tolower(conn->remote_host);
 	   
 	    if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {
@@ -732,12 +732,12 @@ API_EXPORT(const char *) ap_get_server_name(request_rec *r)
 	    hptr = gethostbyaddr((char *)iaddr, sizeof(struct in_addr),
 				 AF_INET);
 	    if (hptr != NULL) {
-	        conn->local_host = ap_pstrdup(conn->pool,
+	        conn->local_host = apr_pstrdup(conn->pool,
 					      (void *)hptr->h_name);
 		ap_str_tolower(conn->local_host);
 	    }
 	    else {
-	        conn->local_host = ap_pstrdup(conn->pool,
+	        conn->local_host = apr_pstrdup(conn->pool,
 					      r->server->server_hostname);
 	    }
 	}
@@ -764,16 +764,16 @@ API_EXPORT(unsigned) ap_get_server_port(const request_rec *r)
     return port;
 }
 
-API_EXPORT(char *) ap_construct_url(ap_pool_t *p, const char *uri,
+API_EXPORT(char *) ap_construct_url(apr_pool_t *p, const char *uri,
 				    request_rec *r)
 {
     unsigned port = ap_get_server_port(r);
     const char *host = ap_get_server_name(r);
 
     if (ap_is_default_port(port, r)) {
-	return ap_pstrcat(p, ap_http_method(r), "://", host, uri, NULL);
+	return apr_pstrcat(p, ap_http_method(r), "://", host, uri, NULL);
     }
-    return ap_psprintf(p, "%s://%s:%u%s", ap_http_method(r), host, port, uri);
+    return apr_psprintf(p, "%s://%s:%u%s", ap_http_method(r), host, port, uri);
 }
 
 API_EXPORT(unsigned long) ap_get_limit_req_body(const request_rec *r)
@@ -785,7 +785,7 @@ API_EXPORT(unsigned long) ap_get_limit_req_body(const request_rec *r)
 }
 
 #ifdef WIN32
-static DWORD get_win32_registry_default_value(ap_pool_t *p, HKEY hkey, 
+static DWORD get_win32_registry_default_value(apr_pool_t *p, HKEY hkey, 
                                               char* relativepath, char **value)
 {
     HKEY hkeyOpen;
@@ -805,7 +805,7 @@ static DWORD get_win32_registry_default_value(ap_pool_t *p, HKEY hkey,
             result = ERROR_INVALID_PARAMETER;
         }
         else {
-            *value = ap_palloc(p, size);
+            *value = apr_palloc(p, size);
             /* Read value based on size query above */
             result = RegQueryValueEx(hkeyOpen, "", 0, &type, *value, &size);
         }
@@ -820,7 +820,7 @@ static DWORD get_win32_registry_default_value(ap_pool_t *p, HKEY hkey,
         char *tmp = *value;
         size = ExpandEnvironmentStrings(tmp, *value, 0);
         if (size) {
-            *value = ap_palloc(p, size);
+            *value = apr_palloc(p, size);
             size = ExpandEnvironmentStrings(tmp, *value, size);
         }
     }
@@ -829,7 +829,7 @@ static DWORD get_win32_registry_default_value(ap_pool_t *p, HKEY hkey,
     return result;
 }
 
-static char* get_interpreter_from_win32_registry(ap_pool_t *p, const char* ext,
+static char* get_interpreter_from_win32_registry(apr_pool_t *p, const char* ext,
                                                  char** arguments, int strict)
 {
     char execcgi_path[] = "SHELL\\EXECCGI\\COMMAND";
@@ -981,7 +981,7 @@ API_EXPORT (file_type_e) ap_get_win32_interpreter(const  request_rec *r,
     {
         char *comspec = getenv("COMSPEC");
         if (comspec) {
-            *interpreter = ap_pstrcat(r->pool, "\"", comspec, "\" /c ", NULL);
+            *interpreter = apr_pstrcat(r->pool, "\"", comspec, "\" /c ", NULL);
             return eFileTypeSCRIPT;
         }
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, r->server,
@@ -1048,7 +1048,7 @@ API_EXPORT (file_type_e) ap_get_win32_interpreter(const  request_rec *r,
         buffer[i] = '\0';
         for (i = 2; buffer[i] == ' ' ; ++i)
             ;
-        *interpreter = ap_pstrdup(r->pool, buffer + i ); 
+        *interpreter = apr_pstrdup(r->pool, buffer + i ); 
     }
     else {
         /* Not a script, is it an executable? */
@@ -1096,18 +1096,18 @@ API_EXPORT(const char *) ap_check_cmd_context(cmd_parms *cmd,
     const ap_directive_t *found;
 
     if ((forbidden & NOT_IN_VIRTUALHOST) && cmd->server->is_virtual) {
-	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
+	return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,
 			  " cannot occur within <VirtualHost> section", NULL);
     }
 
     if ((forbidden & NOT_IN_LIMIT) && cmd->limited != -1) {
-	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
+	return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,
 			  " cannot occur within <Limit> section", NULL);
     }
 
     if ((forbidden & NOT_IN_DIR_LOC_FILE) == NOT_IN_DIR_LOC_FILE
 	&& cmd->path != NULL) {
-	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
+	return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,
 			  " cannot occur within <Directory/Location/Files> "
 			  "section", NULL);
     }
@@ -1121,7 +1121,7 @@ API_EXPORT(const char *) ap_check_cmd_context(cmd_parms *cmd,
 	|| ((forbidden & NOT_IN_FILES)
 	    && ((found = find_parent(cmd->directive, "<Files"))
 		|| (found = find_parent(cmd->directive, "<FilesMatch"))))) {
-	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
+	return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,
 			  " cannot occur within ", found->directive,
 			  "> section", NULL);
     }
@@ -1141,7 +1141,7 @@ static const char *set_access_name(cmd_parms *cmd, void *dummy,
         return err;
     }
 
-    conf->access_name = ap_pstrdup(cmd->pool, arg);
+    conf->access_name = apr_pstrdup(cmd->pool, arg);
     return NULL;
 }
 
@@ -1157,7 +1157,7 @@ static const char *set_gprof_dir(cmd_parms *cmd, void *dummy, char *arg)
         return err;
     }
 
-    conf->gprof_dir = ap_pstrdup(cmd->pool, arg);
+    conf->gprof_dir = apr_pstrdup(cmd->pool, arg);
     return NULL;
 }
 #endif /*GPROF*/
@@ -1221,7 +1221,7 @@ API_EXPORT(void) ap_custom_response(request_rec *r, int status, char *string)
 
     if(conf->response_code_strings == NULL) {
         conf->response_code_strings = 
-	    ap_pcalloc(r->pool,
+	    apr_pcalloc(r->pool,
 		    sizeof(*conf->response_code_strings) * 
 		    RESPONSE_CODES);
     }
@@ -1230,7 +1230,7 @@ API_EXPORT(void) ap_custom_response(request_rec *r, int status, char *string)
 
     conf->response_code_strings[idx] = 
        ((ap_is_url(string) || (*string == '/')) && (*string != '"')) ? 
-       ap_pstrdup(r->pool, string) : ap_pstrcat(r->pool, "\"", string, NULL);
+       apr_pstrdup(r->pool, string) : apr_pstrcat(r->pool, "\"", string, NULL);
 }
 
 static const char *set_error_document(cmd_parms *cmd, void *conf_,
@@ -1255,7 +1255,7 @@ static const char *set_error_document(cmd_parms *cmd, void *conf_,
         index_number = idx500;
     }
     else if ((index_number = ap_index_of_response(error_number)) == idx500) {
-        return ap_pstrcat(cmd->pool, "Unsupported HTTP response code ",
+        return apr_pstrcat(cmd->pool, "Unsupported HTTP response code ",
 			  errno_str, NULL);
     }
 
@@ -1279,7 +1279,7 @@ static const char *set_error_document(cmd_parms *cmd, void *conf_,
     else { /* Store it... */
     	if (conf->response_code_strings == NULL) {
 	    conf->response_code_strings =
-		ap_pcalloc(cmd->pool,
+		apr_pcalloc(cmd->pool,
 			   sizeof(*conf->response_code_strings) * RESPONSE_CODES);
         }
 	/* hack. Prefix a " if it is a msg; as that is what
@@ -1287,8 +1287,8 @@ static const char *set_error_document(cmd_parms *cmd, void *conf_,
 	 * a msg and a (local) path.
 	 */
         conf->response_code_strings[index_number] = (what == MSG) ?
-		ap_pstrcat(cmd->pool, "\"",msg,NULL) :
-		ap_pstrdup(cmd->pool, msg);
+		apr_pstrcat(cmd->pool, "\"",msg,NULL) :
+		apr_pstrdup(cmd->pool, msg);
     }   
 
     return NULL;
@@ -1329,7 +1329,7 @@ static const char *set_override(cmd_parms *cmd, void *d_, const char *l)
 	    d->override = OR_ALL;
 	}
 	else {
-	    return ap_pstrcat(cmd->pool, "Illegal override option ", w, NULL);
+	    return apr_pstrcat(cmd->pool, "Illegal override option ", w, NULL);
 	}
 	d->override &= ~OR_UNSET;
     }
@@ -1387,7 +1387,7 @@ static const char *set_options(cmd_parms *cmd, void *d_, const char *l)
 	    opt = OPT_ALL;
 	}
 	else {
-	    return ap_pstrcat(cmd->pool, "Illegal option ", w, NULL);
+	    return apr_pstrcat(cmd->pool, "Illegal option ", w, NULL);
 	}
 
 	/* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
@@ -1431,10 +1431,10 @@ static const char *require(cmd_parms *cmd, void *c_, const char *arg)
     core_dir_config *c=c_;
 
     if (!c->ap_requires) {
-        c->ap_requires = ap_make_array(cmd->pool, 2, sizeof(require_line));
+        c->ap_requires = apr_make_array(cmd->pool, 2, sizeof(require_line));
     }
-    r = (require_line *)ap_push_array(c->ap_requires);
-    r->requirement = ap_pstrdup(cmd->pool, arg);
+    r = (require_line *)apr_push_array(c->ap_requires);
+    r->requirement = apr_pstrdup(cmd->pool, arg);
     r->method_mask = cmd->limited;
     return NULL;
 }
@@ -1460,7 +1460,7 @@ CORE_EXPORT_NONSTD(const char *) ap_limit_section(cmd_parms *cmd, void *dummy,
             return "TRACE cannot be controlled by <Limit>";
         }
         else if (methnum == M_INVALID) {
-            return ap_pstrcat(cmd->pool, "unknown method \"", method,
+            return apr_pstrcat(cmd->pool, "unknown method \"", method,
                               "\" in <Limit", tog ? "Except>" : ">", NULL);
         }
         else {
@@ -1495,7 +1495,7 @@ CORE_EXPORT_NONSTD(const char *) ap_limit_section(cmd_parms *cmd, void *dummy,
  */
 static char *unclosed_directive(cmd_parms *cmd)
 {
-    return ap_pstrcat(cmd->pool, cmd->cmd->name,
+    return apr_pstrcat(cmd->pool, cmd->cmd->name,
 		      "> directive missing closing '>'", NULL);
 }
 
@@ -1520,7 +1520,7 @@ static const char *dirsection(cmd_parms *cmd, void *mconfig, const char *arg)
 	return unclosed_directive(cmd);
     }
 
-    arg=ap_pstrndup(cmd->pool, arg, endp-arg);
+    arg=apr_pstrndup(cmd->pool, arg, endp-arg);
 
     cmd->path = ap_getword_conf(cmd->pool, &arg);
     cmd->override = OR_ALL|ACCESS_CONF;
@@ -1550,7 +1550,7 @@ static const char *dirsection(cmd_parms *cmd, void *mconfig, const char *arg)
     ap_add_per_dir_conf(cmd->server, new_dir_conf);
 
     if (*arg != '\0') {
-	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
+	return apr_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
 			  "> arguments not (yet) supported.", NULL);
     }
 
@@ -1582,7 +1582,7 @@ static const char *urlsection(cmd_parms *cmd, void *mconfig, const char *arg)
 	return unclosed_directive(cmd);
     }
 
-    arg=ap_pstrndup(cmd->pool, arg, endp-arg);
+    arg=apr_pstrndup(cmd->pool, arg, endp-arg);
 
     cmd->path = ap_getword_conf(cmd->pool, &arg);
     cmd->override = OR_ALL|ACCESS_CONF;
@@ -1603,14 +1603,14 @@ static const char *urlsection(cmd_parms *cmd, void *mconfig, const char *arg)
     if (errmsg != NULL)
 	return errmsg;
 
-    conf->d = ap_pstrdup(cmd->pool, cmd->path);	/* No mangling, please */
-    conf->d_is_fnmatch = ap_is_fnmatch(conf->d) != 0;
+    conf->d = apr_pstrdup(cmd->pool, cmd->path);	/* No mangling, please */
+    conf->d_is_fnmatch = apr_is_fnmatch(conf->d) != 0;
     conf->r = r;
 
     ap_add_per_url_conf(cmd->server, new_url_conf);
     
     if (*arg != '\0') {
-	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
+	return apr_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
 			  "> arguments not (yet) supported.", NULL);
     }
 
@@ -1642,7 +1642,7 @@ static const char *filesection(cmd_parms *cmd, void *mconfig, const char *arg)
 	return unclosed_directive(cmd);
     }
 
-    arg=ap_pstrndup(cmd->pool, arg, endp-arg);
+    arg=apr_pstrndup(cmd->pool, arg, endp-arg);
 
     cmd->path = ap_getword_conf(cmd->pool, &arg);
     /* Only if not an .htaccess file */
@@ -1671,13 +1671,13 @@ static const char *filesection(cmd_parms *cmd, void *mconfig, const char *arg)
 	return errmsg;
 
     conf->d = cmd->path;
-    conf->d_is_fnmatch = ap_is_fnmatch(conf->d) != 0;
+    conf->d_is_fnmatch = apr_is_fnmatch(conf->d) != 0;
     conf->r = r;
 
     ap_add_file_conf(c, new_file_conf);
 
     if (*arg != '\0') {
-	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
+	return apr_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
 			  "> arguments not (yet) supported.", NULL);
     }
 
@@ -1697,7 +1697,7 @@ static const char *start_ifmod(cmd_parms *cmd, void *mconfig, const char *arg)
 	return unclosed_directive(cmd);
     }
 
-    arg=ap_pstrndup(cmd->pool, arg, endp-arg);
+    arg=apr_pstrndup(cmd->pool, arg, endp-arg);
 
     if (not) {
         arg++;
@@ -1746,7 +1746,7 @@ static const char *start_ifdefine(cmd_parms *cmd, void *dummy, const char *arg)
 	return unclosed_directive(cmd);
     }
 
-    arg=ap_pstrndup(cmd->pool, arg, endp-arg);
+    arg=apr_pstrndup(cmd->pool, arg, endp-arg);
 
     if (arg[0] == '!') {
         not = 1;
@@ -1778,7 +1778,7 @@ static const char *virtualhost_section(cmd_parms *cmd, void *dummy,
     server_rec *main_server = cmd->server, *s;
     const char *errmsg;
     const char *endp = ap_strrchr_c(arg, '>');
-    ap_pool_t *p = cmd->pool;
+    apr_pool_t *p = cmd->pool;
 
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1789,7 +1789,7 @@ static const char *virtualhost_section(cmd_parms *cmd, void *dummy,
 	return unclosed_directive(cmd);
     }
 
-    arg=ap_pstrndup(cmd->pool, arg, endp-arg);
+    arg=apr_pstrndup(cmd->pool, arg, endp-arg);
     
     /* FIXME: There's another feature waiting to happen here -- since you
 	can now put multiple addresses/names on a single <VirtualHost>
@@ -1830,10 +1830,10 @@ static const char *set_server_alias(cmd_parms *cmd, void *dummy,
     while (*arg) {
 	char **item, *name = ap_getword_conf(cmd->pool, &arg);
 	if (ap_is_matchexp(name)) {
-	    item = (char **)ap_push_array(cmd->server->wild_names);
+	    item = (char **)apr_push_array(cmd->server->wild_names);
 	}
 	else {
-	    item = (char **)ap_push_array(cmd->server->names);
+	    item = (char **)apr_push_array(cmd->server->names);
 	}
 	*item = name;
     }
@@ -1849,7 +1849,7 @@ static const char *add_module_command(cmd_parms *cmd, void *dummy,
     }
 
     if (!ap_add_named_module(arg)) {
-	return ap_pstrcat(cmd->pool, "Cannot add module via name '", arg, 
+	return apr_pstrcat(cmd->pool, "Cannot add module via name '", arg, 
 			  "': not in list of loaded modules", NULL);
     }
     *(ap_directive_t **)dummy = NULL;
@@ -1896,7 +1896,7 @@ static const char *server_port(cmd_parms *cmd, void *dummy, const char *arg)
     }
     port = atoi(arg);
     if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */
-	return ap_pstrcat(cmd->temp_pool, "The port number \"", arg, 
+	return apr_pstrcat(cmd->temp_pool, "The port number \"", arg, 
 			  "\" is outside the appropriate range "
 			  "(i.e., 1..65535).", NULL);
     }
@@ -2160,16 +2160,16 @@ API_EXPORT(const char *) ap_psignature(const char *prefix, request_rec *r)
 	return "";
     }
 
-    ap_snprintf(sport, sizeof sport, "%u", (unsigned) ap_get_server_port(r));
+    apr_snprintf(sport, sizeof sport, "%u", (unsigned) ap_get_server_port(r));
 
     if (conf->server_signature == srv_sig_withmail) {
-	return ap_pstrcat(r->pool, prefix, "<ADDRESS>" AP_SERVER_BASEVERSION
+	return apr_pstrcat(r->pool, prefix, "<ADDRESS>" AP_SERVER_BASEVERSION
 			  " Server at <A HREF=\"mailto:",
 			  r->server->server_admin, "\">",
 			  ap_get_server_name(r), "</A> Port ", sport,
 			  "</ADDRESS>\n", NULL);
     }
-    return ap_pstrcat(r->pool, prefix, "<ADDRESS>" AP_SERVER_BASEVERSION
+    return apr_pstrcat(r->pool, prefix, "<ADDRESS>" AP_SERVER_BASEVERSION
 		      " Server at ", ap_get_server_name(r), " Port ", sport,
 		      "</ADDRESS>\n", NULL);
 }
@@ -2218,7 +2218,7 @@ enum server_token_type {
 };
 static enum server_token_type ap_server_tokens = SrvTk_FULL;
 
-static ap_status_t reset_version(void *dummy)
+static apr_status_t reset_version(void *dummy)
 {
     version_locked = 0;
     ap_server_tokens = SrvTk_FULL;
@@ -2231,7 +2231,7 @@ API_EXPORT(const char *) ap_get_server_version(void)
     return (server_version ? server_version : AP_SERVER_BASEVERSION);
 }
 
-API_EXPORT(void) ap_add_version_component(ap_pool_t *pconf, const char *component)
+API_EXPORT(void) ap_add_version_component(apr_pool_t *pconf, const char *component)
 {
     if (! version_locked) {
         /*
@@ -2240,16 +2240,16 @@ API_EXPORT(void) ap_add_version_component(ap_pool_t *pconf, const char *componen
          * we are adding the original SERVER_BASEVERSION string.
          */
         if (server_version == NULL) {
-            ap_register_cleanup(pconf, NULL, reset_version,
-                                ap_null_cleanup);
-            server_version = ap_pstrdup(pconf, component);
+            apr_register_cleanup(pconf, NULL, reset_version,
+                                apr_null_cleanup);
+            server_version = apr_pstrdup(pconf, component);
         }
         else {
             /*
              * Tack the given component identifier to the end of
              * the existing string.
              */
-            server_version = ap_pstrcat(pconf, server_version, " ",
+            server_version = apr_pstrcat(pconf, server_version, " ",
                                         component, NULL);
         }
     }
@@ -2259,7 +2259,7 @@ API_EXPORT(void) ap_add_version_component(ap_pool_t *pconf, const char *componen
  * This routine adds the real server base identity to the version string,
  * and then locks out changes until the next reconfig.
  */
-static void ap_set_version(ap_pool_t *pconf)
+static void ap_set_version(apr_pool_t *pconf)
 {
     if (ap_server_tokens == SrvTk_PRODUCT_ONLY) {
         ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT);
@@ -2314,11 +2314,11 @@ static const char *set_limit_req_line(cmd_parms *cmd, void *dummy,
     }
     lim = atoi(arg);
     if (lim < 0) {
-        return ap_pstrcat(cmd->temp_pool, "LimitRequestLine \"", arg, 
+        return apr_pstrcat(cmd->temp_pool, "LimitRequestLine \"", arg, 
                           "\" must be a non-negative integer", NULL);
     }
     if (lim > DEFAULT_LIMIT_REQUEST_LINE) {
-        return ap_psprintf(cmd->temp_pool, "LimitRequestLine \"%s\" "
+        return apr_psprintf(cmd->temp_pool, "LimitRequestLine \"%s\" "
                            "must not exceed the precompiled maximum of %d",
                            arg, DEFAULT_LIMIT_REQUEST_LINE);
     }
@@ -2338,12 +2338,12 @@ static const char *set_limit_req_fieldsize(cmd_parms *cmd, void *dummy,
     }
     lim = atoi(arg);
     if (lim < 0) {
-        return ap_pstrcat(cmd->temp_pool, "LimitRequestFieldsize \"", arg, 
+        return apr_pstrcat(cmd->temp_pool, "LimitRequestFieldsize \"", arg, 
                           "\" must be a non-negative integer (0 = no limit)",
                           NULL);
     }
     if (lim > DEFAULT_LIMIT_REQUEST_FIELDSIZE) {
-        return ap_psprintf(cmd->temp_pool, "LimitRequestFieldsize \"%s\" "
+        return apr_psprintf(cmd->temp_pool, "LimitRequestFieldsize \"%s\" "
                           "must not exceed the precompiled maximum of %d",
                            arg, DEFAULT_LIMIT_REQUEST_FIELDSIZE);
     }
@@ -2363,7 +2363,7 @@ static const char *set_limit_req_fields(cmd_parms *cmd, void *dummy,
     }
     lim = atoi(arg);
     if (lim < 0) {
-        return ap_pstrcat(cmd->temp_pool, "LimitRequestFields \"", arg, 
+        return apr_pstrcat(cmd->temp_pool, "LimitRequestFields \"", arg, 
                           "\" must be a non-negative integer (0 = no limit)",
                           NULL);
     }
@@ -2680,7 +2680,7 @@ API_EXPORT_NONSTD(int) ap_core_translate(request_rec *r)
 	&& (r->server->path[r->server->pathlen - 1] == '/'
 	    || r->uri[r->server->pathlen] == '/'
 	    || r->uri[r->server->pathlen] == '\0')) {
-        r->filename = ap_pstrcat(r->pool, conf->ap_document_root,
+        r->filename = apr_pstrcat(r->pool, conf->ap_document_root,
 				 (r->uri + r->server->pathlen), NULL);
     }
     else {
@@ -2691,11 +2691,11 @@ API_EXPORT_NONSTD(int) ap_core_translate(request_rec *r)
          */
         if ((conf->ap_document_root[strlen(conf->ap_document_root)-1] == '/')
 	    && (*(r->uri) == '/')) {
-	    r->filename = ap_pstrcat(r->pool, conf->ap_document_root, r->uri+1,
+	    r->filename = apr_pstrcat(r->pool, conf->ap_document_root, r->uri+1,
 				     NULL);
 	}
 	else {
-	    r->filename = ap_pstrcat(r->pool, conf->ap_document_root, r->uri,
+	    r->filename = apr_pstrcat(r->pool, conf->ap_document_root, r->uri,
 				     NULL);
 	}
     }
@@ -2718,10 +2718,10 @@ static int default_handler(request_rec *r)
     core_dir_config *d =
 	    (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
     int rangestatus, errstatus;
-    ap_file_t *fd = NULL;
-    ap_status_t status;
+    apr_file_t *fd = NULL;
+    apr_status_t status;
 #ifdef USE_MMAP_FILES
-    ap_mmap_t *mm = NULL;
+    apr_mmap_t *mm = NULL;
 #endif
 
     /* This handler has no use for a request body (yet), but we still
@@ -2747,7 +2747,7 @@ static int default_handler(request_rec *r)
     if (r->finfo.protection == 0 || (r->path_info && *r->path_info)) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, r,
 		      "File does not exist: %s",r->path_info ?
-		      ap_pstrcat(r->pool, r->filename, r->path_info, NULL)
+		      apr_pstrcat(r->pool, r->filename, r->path_info, NULL)
 		      : r->filename);
 	return HTTP_NOT_FOUND;
     }
@@ -2755,7 +2755,7 @@ static int default_handler(request_rec *r)
         return HTTP_METHOD_NOT_ALLOWED;
     }
 	
-    if ((status = ap_open(&fd, r->filename, APR_READ | APR_BINARY, 0, r->pool)) != APR_SUCCESS) {
+    if ((status = apr_open(&fd, r->filename, APR_READ | APR_BINARY, 0, r->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
 		     "file permissions deny server access: %s", r->filename);
         return HTTP_FORBIDDEN;
@@ -2763,10 +2763,10 @@ static int default_handler(request_rec *r)
     ap_update_mtime(r, r->finfo.mtime);
     ap_set_last_modified(r);
     ap_set_etag(r);
-    ap_table_setn(r->headers_out, "Accept-Ranges", "bytes");
+    apr_table_setn(r->headers_out, "Accept-Ranges", "bytes");
     if (((errstatus = ap_meets_conditions(r)) != OK)
 	|| (errstatus = ap_set_content_length(r, r->finfo.size))) {
-        ap_close(fd);
+        apr_close(fd);
         return errstatus;
     }
 
@@ -2788,8 +2788,8 @@ static int default_handler(request_rec *r)
 	&& (!r->header_only || (d->content_md5 & 1))) {
 	/* we need to protect ourselves in case we die while we've got the
  	 * file mmapped */
-        ap_status_t status;
-        if ((status = ap_mmap_create(&mm, fd, 0, r->finfo.size, r->pool)) != APR_SUCCESS) {
+        apr_status_t status;
+        if ((status = apr_mmap_create(&mm, fd, 0, r->finfo.size, r->pool)) != APR_SUCCESS) {
 	    ap_log_rerror(APLOG_MARK, APLOG_CRIT, status, r,
 			 "default_handler: mmap failed: %s", r->filename);
 	    mm = NULL;
@@ -2804,13 +2804,13 @@ static int default_handler(request_rec *r)
 
 #ifdef APACHE_XLATE
 	if (d->content_md5 & 1) {
-	    ap_table_setn(r->headers_out, "Content-MD5",
+	    apr_table_setn(r->headers_out, "Content-MD5",
 			  ap_md5digest(r->pool, fd,
                                        r->rrx->to_net));
 	}
 #else
 	if (d->content_md5 & 1) {
-	    ap_table_setn(r->headers_out, "Content-MD5",
+	    apr_table_setn(r->headers_out, "Content-MD5",
 			  ap_md5digest(r->pool, fd));
 	}
 #endif /* APACHE_XLATE */
@@ -2820,9 +2820,9 @@ static int default_handler(request_rec *r)
 	ap_send_http_header(r);
 	
 	if (!r->header_only) {
-            ap_size_t length = r->finfo.size;
-            ap_off_t  offset = 0;
-            ap_size_t nbytes = 0;
+            apr_size_t length = r->finfo.size;
+            apr_off_t  offset = 0;
+            apr_size_t nbytes = 0;
 
 	    if (!rangestatus) {
 		ap_send_fd(fd, r, offset, length, &nbytes);
@@ -2842,19 +2842,19 @@ static int default_handler(request_rec *r)
     }
     else {
 	unsigned char *addr;
-        ap_mmap_offset((void**)&addr, mm ,0);
+        apr_mmap_offset((void**)&addr, mm ,0);
 
 	if (d->content_md5 & 1) {
 	    ap_md5_ctx_t context;
 	    
-	    ap_MD5Init(&context);
+	    apr_MD5Init(&context);
 #ifdef APACHE_XLATE
             if (r->rrx->to_net) {
                 ap_MD5SetXlate(&context, r->rrx->to_net);
             }
 #endif
-	    ap_MD5Update(&context, addr, (unsigned int)r->finfo.size);
-	    ap_table_setn(r->headers_out, "Content-MD5",
+	    apr_MD5Update(&context, addr, (unsigned int)r->finfo.size);
+	    apr_table_setn(r->headers_out, "Content-MD5",
 			  ap_md5contextTo64(r->pool, &context));
 	}
 
@@ -2866,8 +2866,8 @@ static int default_handler(request_rec *r)
 		ap_send_mmap(mm, r, 0, r->finfo.size);
 	    }
 	    else {
-		ap_off_t offset;
-		ap_size_t length;
+		apr_off_t offset;
+		apr_size_t length;
 		while (ap_each_byterange(r, &offset, &length)) {
 		    ap_send_mmap(mm, r, offset, length);
 		}
@@ -2876,7 +2876,7 @@ static int default_handler(request_rec *r)
     }
 #endif
 
-    ap_close(fd);
+    apr_close(fd);
     return OK;
 }
 
@@ -2886,12 +2886,12 @@ static const handler_rec core_handlers[] = {
 { NULL, NULL }
 };
 
-static void core_post_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *s)
+static void core_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
 {
     ap_set_version(pconf);
 }
 
-static void core_open_logs(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *s)
+static void core_open_logs(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
 {
     ap_open_logs(s, pconf);
 }
@@ -2922,7 +2922,7 @@ API_VAR_EXPORT module core_module = {
     merge_core_dir_configs,	/* merge per-directory config structures */
     create_core_server_config,	/* create per-server config structure */
     merge_core_server_configs,	/* merge per-server config structures */
-    core_cmds,			/* command ap_table_t */
+    core_cmds,			/* command apr_table_t */
     core_handlers,		/* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/http/http_protocol.c b/modules/http/http_protocol.c
index 5b8c3c2..7e1e122 100644
--- a/modules/http/http_protocol.c
+++ b/modules/http/http_protocol.c
@@ -105,7 +105,7 @@ AP_HOOK_STRUCT(
  * connection.
  */
 static void check_first_conn_error(const request_rec *r, const char *operation,
-                                   ap_status_t status)
+                                   apr_status_t status)
 {
     if (!r->connection->aborted) {
         if (status == 0)
@@ -141,7 +141,7 @@ static int checked_bputstrs(request_rec *r, ...)
 
 static int checked_bflush(request_rec *r)
 {
-    ap_status_t rv;
+    apr_status_t rv;
 
     if ((rv = ap_bflush(r->connection->client)) != APR_SUCCESS) {
         check_first_conn_error(r, "checked_bflush", rv);
@@ -198,7 +198,7 @@ static const char *make_content_type(request_rec *r, const char *type) {
 	 */
 	for (pcset = needcset; *pcset ; pcset++)
 	    if (ap_strcasestr(type, *pcset) != NULL) {
-		type = ap_pstrcat(r->pool, type, "; charset=", 
+		type = apr_pstrcat(r->pool, type, "; charset=", 
 		    conf->add_default_charset_name, NULL);
 		break;
 	    }
@@ -241,7 +241,7 @@ static int parse_byterange(char *range, long clength, long *start, long *end)
 }
 
 static int internal_byterange(int, long *, request_rec *, const char **,
-			      ap_off_t *, ap_size_t *);
+			      apr_off_t *, apr_size_t *);
 
 API_EXPORT(int) ap_set_byterange(request_rec *r)
 {
@@ -261,8 +261,8 @@ API_EXPORT(int) ap_set_byterange(request_rec *r)
      * Navigator 2-3 and MSIE 3.
      */
 
-    if (!(range = ap_table_get(r->headers_in, "Range")))
-        range = ap_table_get(r->headers_in, "Request-Range");
+    if (!(range = apr_table_get(r->headers_in, "Range")))
+        range = apr_table_get(r->headers_in, "Request-Range");
 
     if (!range || strncasecmp(range, "bytes=", 6)) {
         return 0;
@@ -272,42 +272,42 @@ API_EXPORT(int) ap_set_byterange(request_rec *r)
      * Note that this check will return false (as required) if either
      * of the two etags are weak.
      */
-    if ((if_range = ap_table_get(r->headers_in, "If-Range"))) {
+    if ((if_range = apr_table_get(r->headers_in, "If-Range"))) {
         if (if_range[0] == '"') {
-            if (!(match = ap_table_get(r->headers_out, "Etag")) ||
+            if (!(match = apr_table_get(r->headers_out, "Etag")) ||
                 (strcmp(if_range, match) != 0))
                 return 0;
         }
-        else if (!(match = ap_table_get(r->headers_out, "Last-Modified")) ||
+        else if (!(match = apr_table_get(r->headers_out, "Last-Modified")) ||
                  (strcmp(if_range, match) != 0))
             return 0;
     }
 
     if (!ap_strchr_c(range, ',')) {
         /* A single range */
-        if (!parse_byterange(ap_pstrdup(r->pool, range + 6), r->clength,
+        if (!parse_byterange(apr_pstrdup(r->pool, range + 6), r->clength,
                              &range_start, &range_end))
             return 0;
 
         r->byterange = 1;
 
-        ap_table_setn(r->headers_out, "Content-Range",
-	    ap_psprintf(r->pool, "bytes %ld-%ld/%ld",
+        apr_table_setn(r->headers_out, "Content-Range",
+	    apr_psprintf(r->pool, "bytes %ld-%ld/%ld",
 		range_start, range_end, r->clength));
-        ap_table_setn(r->headers_out, "Content-Length",
-	    ap_psprintf(r->pool, "%ld", range_end - range_start + 1));
+        apr_table_setn(r->headers_out, "Content-Length",
+	    apr_psprintf(r->pool, "%ld", range_end - range_start + 1));
     }
     else {
         /* a multiple range */
-        const char *r_range = ap_pstrdup(r->pool, range + 6);
+        const char *r_range = apr_pstrdup(r->pool, range + 6);
         long tlength = 0;
 
         r->byterange = 2;
-        r->boundary = ap_psprintf(r->pool, "%llx%lx",
+        r->boundary = apr_psprintf(r->pool, "%llx%lx",
 				r->request_time, (long) getpid());
         while (internal_byterange(0, &tlength, r, &r_range, NULL, NULL));
-        ap_table_setn(r->headers_out, "Content-Length",
-	    ap_psprintf(r->pool, "%ld", tlength));
+        apr_table_setn(r->headers_out, "Content-Length",
+	    apr_psprintf(r->pool, "%ld", tlength));
     }
 
     r->status = HTTP_PARTIAL_CONTENT;
@@ -316,8 +316,8 @@ API_EXPORT(int) ap_set_byterange(request_rec *r)
     return 1;
 }
 
-API_EXPORT(int) ap_each_byterange(request_rec *r, ap_off_t *offset,
-				  ap_size_t *length)
+API_EXPORT(int) ap_each_byterange(request_rec *r, apr_off_t *offset,
+				  apr_size_t *length)
 {
     return internal_byterange(1, NULL, r, &r->range, offset, length);
 }
@@ -333,8 +333,8 @@ API_EXPORT(int) ap_each_byterange(request_rec *r, ap_off_t *offset,
  * when done.
  */
 static int internal_byterange(int realreq, long *tlength, request_rec *r,
-                              const char **r_range, ap_off_t *offset,
-			      ap_size_t *length)
+                              const char **r_range, apr_off_t *offset,
+			      apr_size_t *length)
 {
     long range_start, range_end;
     char *range;
@@ -380,7 +380,7 @@ static int internal_byterange(int realreq, long *tlength, request_rec *r,
         const char *ct = make_content_type(r, r->content_type);
         char ts[MAX_STRING_LEN];
 
-        ap_snprintf(ts, sizeof(ts), "%ld-%ld/%ld", range_start, range_end,
+        apr_snprintf(ts, sizeof(ts), "%ld-%ld/%ld", range_start, range_end,
                     r->clength);
         if (realreq)
             (void) checked_bputstrs(r, CRLF "--", r->boundary,
@@ -408,7 +408,7 @@ static int internal_byterange(int realreq, long *tlength, request_rec *r,
 API_EXPORT(int) ap_set_content_length(request_rec *r, long clength)
 {
     r->clength = clength;
-    ap_table_setn(r->headers_out, "Content-Length", ap_psprintf(r->pool, "%ld", clength));
+    apr_table_setn(r->headers_out, "Content-Length", apr_psprintf(r->pool, "%ld", clength));
     return 0;
 }
 
@@ -416,8 +416,8 @@ API_EXPORT(int) ap_set_keepalive(request_rec *r)
 {
     int ka_sent = 0;
     int wimpy = ap_find_token(r->pool,
-                           ap_table_get(r->headers_out, "Connection"), "close");
-    const char *conn = ap_table_get(r->headers_in, "Connection");
+                           apr_table_get(r->headers_out, "Connection"), "close");
+    const char *conn = apr_table_get(r->headers_in, "Connection");
 
 #ifdef APACHE_XLATE
     if (r->rrx->to_net && !r->rrx->to_net_sb) {
@@ -426,7 +426,7 @@ API_EXPORT(int) ap_set_keepalive(request_rec *r)
          * following logic, as the absence of the Content-Length header
          * may affect the decision on chunked encoding.
          */
-        ap_table_unset(r->headers_out,"Content-Length");
+        apr_table_unset(r->headers_out,"Content-Length");
     }
 #endif /* APACHE_XLATE */
 
@@ -459,9 +459,9 @@ API_EXPORT(int) ap_set_keepalive(request_rec *r)
         ((r->status == HTTP_NOT_MODIFIED) ||
          (r->status == HTTP_NO_CONTENT) ||
          r->header_only ||
-         ap_table_get(r->headers_out, "Content-Length") ||
+         apr_table_get(r->headers_out, "Content-Length") ||
          ap_find_last_token(r->pool,
-                         ap_table_get(r->headers_out, "Transfer-Encoding"),
+                         apr_table_get(r->headers_out, "Transfer-Encoding"),
                          "chunked") ||
          ((r->proto_num >= HTTP_VERSION(1,1)) &&
 	  (r->chunked = 1))) && /* THIS CODE IS CORRECT, see comment above. */
@@ -472,8 +472,8 @@ API_EXPORT(int) ap_set_keepalive(request_rec *r)
         !ap_status_drops_connection(r->status) &&
         !wimpy &&
         !ap_find_token(r->pool, conn, "close") &&
-        (!ap_table_get(r->subprocess_env, "nokeepalive") ||
-         ap_table_get(r->headers_in, "Via")) &&
+        (!apr_table_get(r->subprocess_env, "nokeepalive") ||
+         apr_table_get(r->headers_in, "Via")) &&
         ((ka_sent = ap_find_token(r->pool, conn, "keep-alive")) ||
          (r->proto_num >= HTTP_VERSION(1,1)))
        ) {
@@ -485,14 +485,14 @@ API_EXPORT(int) ap_set_keepalive(request_rec *r)
         /* If they sent a Keep-Alive token, send one back */
         if (ka_sent) {
             if (r->server->keep_alive_max)
-		ap_table_setn(r->headers_out, "Keep-Alive",
-		    ap_psprintf(r->pool, "timeout=%d, max=%d",
+		apr_table_setn(r->headers_out, "Keep-Alive",
+		    apr_psprintf(r->pool, "timeout=%d, max=%d",
                             r->server->keep_alive_timeout, left));
             else
-		ap_table_setn(r->headers_out, "Keep-Alive",
-		    ap_psprintf(r->pool, "timeout=%d",
+		apr_table_setn(r->headers_out, "Keep-Alive",
+		    apr_psprintf(r->pool, "timeout=%d",
                             r->server->keep_alive_timeout));
-            ap_table_mergen(r->headers_out, "Connection", "Keep-Alive");
+            apr_table_mergen(r->headers_out, "Connection", "Keep-Alive");
         }
 
         return 1;
@@ -507,7 +507,7 @@ API_EXPORT(int) ap_set_keepalive(request_rec *r)
      * to a HTTP/1.1 client. Better safe than sorry.
      */
     if (!wimpy)
-	ap_table_mergen(r->headers_out, "Connection", "close");
+	apr_table_mergen(r->headers_out, "Connection", "close");
 
     r->connection->keepalive = 0;
 
@@ -521,9 +521,9 @@ API_EXPORT(int) ap_set_keepalive(request_rec *r)
  * to limit the number of calls to time().  We don't check for futurosity
  * unless the mtime is at least as new as the reference.
  */
-API_EXPORT(ap_time_t) ap_rationalize_mtime(request_rec *r, ap_time_t mtime)
+API_EXPORT(apr_time_t) ap_rationalize_mtime(request_rec *r, apr_time_t mtime)
 {
-    ap_time_t now;
+    apr_time_t now;
 
     /* For all static responses, it's almost certain that the file was
      * last modified before the beginning of the request.  So there's
@@ -534,15 +534,15 @@ API_EXPORT(ap_time_t) ap_rationalize_mtime(request_rec *r, ap_time_t mtime)
      * were given a time in the future, we return the current time - the
      * Last-Modified can't be in the future.
      */
-    now = (mtime < r->request_time) ? r->request_time : ap_now();
+    now = (mtime < r->request_time) ? r->request_time : apr_now();
     return (mtime > now) ? now : mtime;
 }
 
 API_EXPORT(int) ap_meets_conditions(request_rec *r)
 {
-    const char *etag = ap_table_get(r->headers_out, "ETag");
+    const char *etag = apr_table_get(r->headers_out, "ETag");
     const char *if_match, *if_modified_since, *if_unmodified, *if_nonematch;
-    ap_time_t mtime;
+    apr_time_t mtime;
 
     /* Check for conditional requests --- note that we only want to do
      * this if we are successful so far and we are not processing a
@@ -560,14 +560,14 @@ API_EXPORT(int) ap_meets_conditions(request_rec *r)
     }
 
     /* XXX: we should define a "time unset" constant */
-    mtime = (r->mtime != 0) ? r->mtime : ap_now();
+    mtime = (r->mtime != 0) ? r->mtime : apr_now();
 
     /* If an If-Match request-header field was given
      * AND the field value is not "*" (meaning match anything)
      * AND if our strong ETag does not match any entity tag in that field,
      *     respond with a status of 412 (Precondition Failed).
      */
-    if ((if_match = ap_table_get(r->headers_in, "If-Match")) != NULL) {
+    if ((if_match = apr_table_get(r->headers_in, "If-Match")) != NULL) {
         if (if_match[0] != '*' &&
             (etag == NULL || etag[0] == 'W' ||
              !ap_find_list_item(r->pool, if_match, etag))) {
@@ -580,9 +580,9 @@ API_EXPORT(int) ap_meets_conditions(request_rec *r)
          * specified in this field, then the server MUST
          *     respond with a status of 412 (Precondition Failed).
          */
-        if_unmodified = ap_table_get(r->headers_in, "If-Unmodified-Since");
+        if_unmodified = apr_table_get(r->headers_in, "If-Unmodified-Since");
         if (if_unmodified != NULL) {
-            ap_time_t ius = ap_parseHTTPdate(if_unmodified);
+            apr_time_t ius = ap_parseHTTPdate(if_unmodified);
 
             if ((ius != BAD_DATE) && (mtime > ius)) {
                 return HTTP_PRECONDITION_FAILED;
@@ -602,13 +602,13 @@ API_EXPORT(int) ap_meets_conditions(request_rec *r)
      * GET or HEAD allow weak etag comparison, all other methods require
      * strong comparison.  We can only use weak if it's not a range request.
      */
-    if_nonematch = ap_table_get(r->headers_in, "If-None-Match");
+    if_nonematch = apr_table_get(r->headers_in, "If-None-Match");
     if (if_nonematch != NULL) {
         if (r->method_number == M_GET) {
             if (if_nonematch[0] == '*')
                 return HTTP_NOT_MODIFIED;
             if (etag != NULL) {
-                if (ap_table_get(r->headers_in, "Range")) {
+                if (apr_table_get(r->headers_in, "Range")) {
                     if (etag[0] != 'W' &&
                         ap_find_list_item(r->pool, if_nonematch, etag)) {
                         return HTTP_NOT_MODIFIED;
@@ -634,8 +634,8 @@ API_EXPORT(int) ap_meets_conditions(request_rec *r)
      */
     else if ((r->method_number == M_GET)
              && ((if_modified_since =
-                  ap_table_get(r->headers_in, "If-Modified-Since")) != NULL)) {
-        ap_time_t ims = ap_parseHTTPdate(if_modified_since);
+                  apr_table_get(r->headers_in, "If-Modified-Since")) != NULL)) {
+        apr_time_t ims = ap_parseHTTPdate(if_modified_since);
 
 	if ((ims >= mtime) && (ims <= r->request_time)) {
             return HTTP_NOT_MODIFIED;
@@ -672,14 +672,14 @@ API_EXPORT(char *) ap_make_etag(request_rec *r, int force_weak)
     weak = ((r->request_time - r->mtime > AP_USEC_PER_SEC) && !force_weak) ? "" : "W/";
 
     if (r->finfo.protection != 0) {
-        etag = ap_psprintf(r->pool,
+        etag = apr_psprintf(r->pool,
                     "%s\"%lx-%lx-%lx\"", weak,
                     (unsigned long) r->finfo.inode,
                     (unsigned long) r->finfo.size,
                     (unsigned long) r->mtime);
     }
     else {
-        etag = ap_psprintf(r->pool, "%s\"%lx\"", weak,
+        etag = apr_psprintf(r->pool, "%s\"%lx\"", weak,
                     (unsigned long) r->mtime);
     }
 
@@ -724,10 +724,10 @@ API_EXPORT(void) ap_set_etag(request_rec *r)
             vlv += 3;
         else
             vlv++;
-        etag = ap_pstrcat(r->pool, variant_etag, ";", vlv, NULL);
+        etag = apr_pstrcat(r->pool, variant_etag, ";", vlv, NULL);
     }
 
-    ap_table_setn(r->headers_out, "ETag", etag);
+    apr_table_setn(r->headers_out, "ETag", etag);
 }
 
 /*
@@ -737,10 +737,10 @@ API_EXPORT(void) ap_set_etag(request_rec *r)
  */
 API_EXPORT(void) ap_set_last_modified(request_rec *r)
 {
-    ap_time_t mod_time = ap_rationalize_mtime(r, r->mtime);
-    char *datestr = ap_palloc(r->pool, AP_RFC822_DATE_LEN);
-    ap_rfc822_date(datestr, mod_time);
-    ap_table_setn(r->headers_out, "Last-Modified", datestr);
+    apr_time_t mod_time = ap_rationalize_mtime(r, r->mtime);
+    char *datestr = apr_palloc(r->pool, AP_RFC822_DATE_LEN);
+    apr_rfc822_date(datestr, mod_time);
+    apr_table_setn(r->headers_out, "Last-Modified", datestr);
 }
 
 /* Get the method number associated with the given string, assumed to
@@ -901,7 +901,7 @@ CORE_EXPORT(void) ap_parse_uri(request_rec *r, const char *uri)
 {
     int status = HTTP_OK;
 
-    r->unparsed_uri = ap_pstrdup(r->pool, uri);
+    r->unparsed_uri = apr_pstrdup(r->pool, uri);
 
     if (r->method_number == M_CONNECT) {
 	status = ap_parse_hostinfo_components(r->pool, uri, &r->parsed_uri);
@@ -920,7 +920,7 @@ CORE_EXPORT(void) ap_parse_uri(request_rec *r, const char *uri)
 	}
 	r->args = r->parsed_uri.query;
 	r->uri = r->parsed_uri.path ? r->parsed_uri.path
-				    : ap_pstrdup(r->pool, "/");
+				    : apr_pstrdup(r->pool, "/");
 #if defined(OS2) || defined(WIN32)
 	/* Handle path translations for OS/2 and plug security hole.
 	 * This will prevent "http://www.wherever.com/..\..\/" from
@@ -938,7 +938,7 @@ CORE_EXPORT(void) ap_parse_uri(request_rec *r, const char *uri)
 	r->args = NULL;
 	r->hostname = NULL;
 	r->status = status;             /* set error status */
-	r->uri = ap_pstrdup(r->pool, uri);
+	r->uri = apr_pstrdup(r->pool, uri);
     }
 }
 
@@ -973,7 +973,7 @@ static int read_request_line(request_rec *r)
 	    /* this is a hack to make sure that request time is set,
 	     * it's not perfect, but it's better than nothing 
 	     */
-	    r->request_time = ap_now();
+	    r->request_time = apr_now();
             return 0;
         }
     }
@@ -986,14 +986,14 @@ static int read_request_line(request_rec *r)
      * thread isn't used. - mvsk
 
 #ifdef SIGWINCH
-    ap_signal(SIGWINCH, SIG_IGN);
+    apr_signal(SIGWINCH, SIG_IGN);
 #endif
     */
 
     ap_bsetflag(conn->client, B_SAFEREAD, 0);
 
-    r->request_time = ap_now();
-    r->the_request = ap_pstrdup(r->pool, l);
+    r->request_time = apr_now();
+    r->the_request = apr_pstrdup(r->pool, l);
     r->method = ap_getword_white(r->pool, &ll);
     ap_update_connection_status(conn->id, "Method", r->method);
     uri = ap_getword_white(r->pool, &ll);
@@ -1014,12 +1014,12 @@ static int read_request_line(request_rec *r)
     if (len > r->server->limit_req_line) {
         r->status    = HTTP_REQUEST_URI_TOO_LARGE;
         r->proto_num = HTTP_VERSION(1,0);
-        r->protocol  = ap_pstrdup(r->pool, "HTTP/1.0");
+        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
         return 0;
     }
 
     r->assbackwards = (ll[0] == '\0');
-    r->protocol = ap_pstrdup(r->pool, ll[0] ? ll : "HTTP/0.9");
+    r->protocol = apr_pstrdup(r->pool, ll[0] ? ll : "HTTP/0.9");
     ap_update_connection_status(conn->id, "Protocol", r->protocol);
 
     if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
@@ -1039,10 +1039,10 @@ static void get_mime_headers(request_rec *r)
     char *copy;
     int len;
     unsigned int fields_read = 0;
-    ap_table_t *tmp_headers;
+    apr_table_t *tmp_headers;
 
-    /* We'll use ap_overlap_tables later to merge these into r->headers_in. */
-    tmp_headers = ap_make_table(r->pool, 50);
+    /* We'll use apr_overlap_tables later to merge these into r->headers_in. */
+    tmp_headers = apr_make_table(r->pool, 50);
 
     /*
      * Read header lines until we get the empty separator line, a read error,
@@ -1053,7 +1053,7 @@ static void get_mime_headers(request_rec *r)
         if (r->server->limit_req_fields &&
             (++fields_read > r->server->limit_req_fields)) {
             r->status = HTTP_BAD_REQUEST;
-            ap_table_setn(r->notes, "error-notes",
+            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields exceeds "
                           "this server's limit.<P>\n");
             return;
@@ -1064,17 +1064,17 @@ static void get_mime_headers(request_rec *r)
          */
         if (len > r->server->limit_req_fieldsize) {
             r->status = HTTP_BAD_REQUEST;
-            ap_table_setn(r->notes, "error-notes", ap_pstrcat(r->pool,
+            apr_table_setn(r->notes, "error-notes", apr_pstrcat(r->pool,
                 "Size of a request header field exceeds server limit.<P>\n"
                 "<PRE>\n", ap_escape_html(r->pool, field), "</PRE>\n", NULL));
             return;
         }
-        copy = ap_palloc(r->pool, len + 1);
+        copy = apr_palloc(r->pool, len + 1);
         memcpy(copy, field, len + 1);
 
         if (!(value = strchr(copy, ':'))) {     /* Find the colon separator */
             r->status = HTTP_BAD_REQUEST;       /* or abort the bad request */
-            ap_table_setn(r->notes, "error-notes", ap_pstrcat(r->pool,
+            apr_table_setn(r->notes, "error-notes", apr_pstrcat(r->pool,
                 "Request header field is missing colon separator.<P>\n"
                 "<PRE>\n", ap_escape_html(r->pool, copy), "</PRE>\n", NULL));
             return;
@@ -1085,21 +1085,21 @@ static void get_mime_headers(request_rec *r)
         while (*value == ' ' || *value == '\t')
             ++value;            /* Skip to start of value   */
 
-	ap_table_addn(tmp_headers, copy, value);
+	apr_table_addn(tmp_headers, copy, value);
     }
 
-    ap_overlap_tables(r->headers_in, tmp_headers, AP_OVERLAP_TABLES_MERGE);
+    apr_overlap_tables(r->headers_in, tmp_headers, AP_OVERLAP_TABLES_MERGE);
 }
 
 request_rec *ap_read_request(conn_rec *conn)
 {
     request_rec *r;
-    ap_pool_t *p;
+    apr_pool_t *p;
     const char *expect;
     int access_status;
 
-    ap_create_pool(&p, conn->pool);
-    r = ap_pcalloc(p, sizeof(request_rec));
+    apr_create_pool(&p, conn->pool);
+    r = apr_pcalloc(p, sizeof(request_rec));
     r->pool            = p;
     r->connection      = conn;
     r->server          = conn->base_server;
@@ -1110,11 +1110,11 @@ request_rec *ap_read_request(conn_rec *conn)
     r->user            = NULL;
     r->ap_auth_type    = NULL;
 
-    r->headers_in      = ap_make_table(r->pool, 50);
-    r->subprocess_env  = ap_make_table(r->pool, 50);
-    r->headers_out     = ap_make_table(r->pool, 12);
-    r->err_headers_out = ap_make_table(r->pool, 5);
-    r->notes           = ap_make_table(r->pool, 5);
+    r->headers_in      = apr_make_table(r->pool, 50);
+    r->subprocess_env  = apr_make_table(r->pool, 50);
+    r->headers_out     = apr_make_table(r->pool, 12);
+    r->err_headers_out = apr_make_table(r->pool, 5);
+    r->notes           = apr_make_table(r->pool, 5);
 
     r->request_config  = ap_create_request_config(r->pool);
     r->per_dir_config  = r->server->lookup_defaults;
@@ -1128,7 +1128,7 @@ request_rec *ap_read_request(conn_rec *conn)
     r->the_request     = NULL;
 
 #ifdef APACHE_XLATE
-    r->rrx = ap_pcalloc(p, sizeof(struct ap_rr_xlate));
+    r->rrx = apr_pcalloc(p, sizeof(struct ap_rr_xlate));
     ap_set_content_xlate(r, 1, ap_locale_to_ascii);
     ap_set_content_xlate(r, 0, ap_locale_from_ascii);
 #endif /*APACHE_XLATE*/
@@ -1195,7 +1195,7 @@ request_rec *ap_read_request(conn_rec *conn)
 
     if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1,1))) ||
         ((r->proto_num == HTTP_VERSION(1,1)) &&
-         !ap_table_get(r->headers_in, "Host"))) {
+         !apr_table_get(r->headers_in, "Host"))) {
         /*
          * Client sent us an HTTP/1.1 or later request without telling us the
          * hostname, either with a full URL or a Host: header. We therefore
@@ -1213,7 +1213,7 @@ request_rec *ap_read_request(conn_rec *conn)
         ap_run_log_transaction(r);
         return r;
     }
-    if (((expect = ap_table_get(r->headers_in, "Expect")) != NULL) &&
+    if (((expect = apr_table_get(r->headers_in, "Expect")) != NULL) &&
         (expect[0] != '\0')) {
         /*
          * The Expect header field was added to HTTP/1.1 after RFC 2068
@@ -1266,10 +1266,10 @@ void ap_set_sub_req_protocol(request_rec *rnew, const request_rec *r)
     rnew->status          = HTTP_OK;
 
     rnew->headers_in      = r->headers_in;
-    rnew->subprocess_env  = ap_copy_table(rnew->pool, r->subprocess_env);
-    rnew->headers_out     = ap_make_table(rnew->pool, 5);
-    rnew->err_headers_out = ap_make_table(rnew->pool, 5);
-    rnew->notes           = ap_make_table(rnew->pool, 5);
+    rnew->subprocess_env  = apr_copy_table(rnew->pool, r->subprocess_env);
+    rnew->headers_out     = apr_make_table(rnew->pool, 5);
+    rnew->err_headers_out = apr_make_table(rnew->pool, 5);
+    rnew->notes           = apr_make_table(rnew->pool, 5);
 
     rnew->expecting_100   = r->expecting_100;
     rnew->read_length     = r->read_length;
@@ -1311,23 +1311,23 @@ API_EXPORT(void) ap_note_basic_auth_failure(request_rec *r)
     if (strcasecmp(ap_auth_type(r), "Basic"))
         ap_note_auth_failure(r);
     else
-        ap_table_setn(r->err_headers_out,
+        apr_table_setn(r->err_headers_out,
                   r->proxyreq ? "Proxy-Authenticate" : "WWW-Authenticate",
-                  ap_pstrcat(r->pool, "Basic realm=\"", ap_auth_name(r), "\"",
+                  apr_pstrcat(r->pool, "Basic realm=\"", ap_auth_name(r), "\"",
                           NULL));
 }
 
 API_EXPORT(void) ap_note_digest_auth_failure(request_rec *r)
 {
-    ap_table_setn(r->err_headers_out,
+    apr_table_setn(r->err_headers_out,
 	    r->proxyreq ? "Proxy-Authenticate" : "WWW-Authenticate",
-	    ap_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%llx\"",
+	    apr_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%llx\"",
 		ap_auth_name(r), r->request_time));
 }
 
 API_EXPORT(int) ap_get_basic_auth_pw(request_rec *r, const char **pw)
 {
-    const char *auth_line = ap_table_get(r->headers_in,
+    const char *auth_line = apr_table_get(r->headers_in,
                                       r->proxyreq ? "Proxy-Authorization"
                                                   : "Authorization");
     const char *t;
@@ -1510,7 +1510,7 @@ API_EXPORT(void) ap_basic_http_header(request_rec *r)
      */
     if (r->proxyreq
         || (r->proto_num == HTTP_VERSION(1,0)
-            && ap_table_get(r->subprocess_env, "force-response-1.0"))) {
+            && apr_table_get(r->subprocess_env, "force-response-1.0"))) {
 
         protocol = "HTTP/1.0";
         r->connection->keepalive = -1;
@@ -1527,13 +1527,13 @@ API_EXPORT(void) ap_basic_http_header(request_rec *r)
 
     (void) checked_bputstrs(r, protocol, " ", r->status_line, CRLF, NULL);
 
-    date = ap_palloc(r->pool, AP_RFC822_DATE_LEN);
-    ap_rfc822_date(date, r->request_time);
+    date = apr_palloc(r->pool, AP_RFC822_DATE_LEN);
+    apr_rfc822_date(date, r->request_time);
     ap_send_header_field(r, "Date", date);
     ap_send_header_field(r, "Server", ap_get_server_version());
 
-    ap_table_unset(r->headers_out, "Date");        /* Avoid bogosity */
-    ap_table_unset(r->headers_out, "Server");
+    apr_table_unset(r->headers_out, "Date");        /* Avoid bogosity */
+    apr_table_unset(r->headers_out, "Server");
 #ifdef APACHE_XLATE
     AP_POP_OUTPUTCONVERSION_STATE(r->connection->client); }
 #endif /*APACHE_XLATE*/
@@ -1572,7 +1572,7 @@ static void terminate_header(request_rec *r)
  */
 static char *make_allow(request_rec *r)
 {
-    return 2 + ap_pstrcat(r->pool,
+    return 2 + apr_pstrcat(r->pool,
                    (r->allowed & (1 << M_GET))       ? ", GET, HEAD" : "",
                    (r->allowed & (1 << M_POST))      ? ", POST"      : "",
                    (r->allowed & (1 << M_PUT))       ? ", PUT"       : "",
@@ -1609,7 +1609,7 @@ API_EXPORT(int) ap_send_http_trace(request_rec *r)
 
     ap_rvputs(r, r->the_request, CRLF, NULL);
 
-    ap_table_do((int (*) (void *, const char *, const char *))
+    apr_table_do((int (*) (void *, const char *, const char *))
                 ap_send_header_field, (void *) r, r->headers_in, NULL);
     ap_rputs(CRLF, r);
 
@@ -1625,11 +1625,11 @@ int ap_send_http_options(request_rec *r)
 
     ap_basic_http_header(r);
 
-    ap_table_setn(r->headers_out, "Content-Length", "0");
-    ap_table_setn(r->headers_out, "Allow", make_allow(r));
+    apr_table_setn(r->headers_out, "Content-Length", "0");
+    apr_table_setn(r->headers_out, "Allow", make_allow(r));
     ap_set_keepalive(r);
 
-    ap_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
+    apr_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
              (void *) r, r->headers_out, NULL);
 
     terminate_header(r);
@@ -1649,12 +1649,12 @@ int ap_send_http_options(request_rec *r)
 static int use_range_x(request_rec *r)
 {
     const char *ua;
-    return (ap_table_get(r->headers_in, "Request-Range") ||
-            ((ua = ap_table_get(r->headers_in, "User-Agent"))
+    return (apr_table_get(r->headers_in, "Request-Range") ||
+            ((ua = apr_table_get(r->headers_in, "User-Agent"))
              && ap_strstr_c(ua, "MSIE 3")));
 }
 
-/* This routine is called by ap_table_do and merges all instances of
+/* This routine is called by apr_table_do and merges all instances of
  * the passed field values into a single array that will be further
  * processed by some later routine.  Originally intended to help split
  * and recombine multiple Vary fields, though it is generic to any field
@@ -1662,15 +1662,15 @@ static int use_range_x(request_rec *r)
  */
 static int uniq_field_values(void *d, const char *key, const char *val)
 {
-    ap_array_header_t *values;
+    apr_array_header_t *values;
     char *start;
     char *e;
     char **strpp;
     int  i;
 
-    values = (ap_array_header_t *)d;
+    values = (apr_array_header_t *)d;
 
-    e = ap_pstrdup(values->cont, val);
+    e = apr_pstrdup(values->cont, val);
 
     do {
         /* Find a non-empty fieldname */
@@ -1699,7 +1699,7 @@ static int uniq_field_values(void *d, const char *key, const char *val)
             }
         }
         if (i == values->nelts) {  /* if not found */
-           *(char **)ap_push_array(values) = start;
+           *(char **)apr_push_array(values) = start;
         }
     } while (*e != '\0');
 
@@ -1713,22 +1713,22 @@ static int uniq_field_values(void *d, const char *key, const char *val)
  */
 static void fixup_vary(request_rec *r)
 {
-    ap_array_header_t *varies;
+    apr_array_header_t *varies;
 
-    varies = ap_make_array(r->pool, 5, sizeof(char *));
+    varies = apr_make_array(r->pool, 5, sizeof(char *));
 
     /* Extract all Vary fields from the headers_out, separate each into
      * its comma-separated fieldname values, and then add them to varies
      * if not already present in the array.
      */
-    ap_table_do((int (*)(void *, const char *, const char *))uniq_field_values,
+    apr_table_do((int (*)(void *, const char *, const char *))uniq_field_values,
 		(void *) varies, r->headers_out, "Vary", NULL);
 
     /* If we found any, replace old Vary fields with unique-ified value */
 
     if (varies->nelts > 0) {
-	ap_table_setn(r->headers_out, "Vary",
-		      ap_array_pstrcat(r->pool, varies, ','));
+	apr_table_setn(r->headers_out, "Vary",
+		      apr_array_pstrcat(r->pool, varies, ','));
     }
 }
 
@@ -1765,7 +1765,7 @@ API_EXPORT(void) ap_send_http_header(request_rec *r)
      * later attempts to set or unset a given fieldname might be bypassed.
      */
     if (!ap_is_empty_table(r->err_headers_out))
-        r->headers_out = ap_overlay_tables(r->pool, r->err_headers_out,
+        r->headers_out = apr_overlay_tables(r->pool, r->err_headers_out,
                                         r->headers_out);
 
     /*
@@ -1773,10 +1773,10 @@ API_EXPORT(void) ap_send_http_header(request_rec *r)
      * Since this will have nasty effects on HTTP/1.1 caches, force
      * the response into HTTP/1.0 mode.
      */
-    if (ap_table_get(r->subprocess_env, "force-no-vary") != NULL) {
-	ap_table_unset(r->headers_out, "Vary");
+    if (apr_table_get(r->subprocess_env, "force-no-vary") != NULL) {
+	apr_table_unset(r->headers_out, "Vary");
 	r->proto_num = HTTP_VERSION(1,0);
-	ap_table_set(r->subprocess_env, "force-response-1.0", "1");
+	apr_table_set(r->subprocess_env, "force-response-1.0", "1");
     }
     else {
 	fixup_vary(r);
@@ -1792,42 +1792,42 @@ API_EXPORT(void) ap_send_http_header(request_rec *r)
     ap_set_keepalive(r);
 
     if (r->chunked) {
-        ap_table_mergen(r->headers_out, "Transfer-Encoding", "chunked");
-        ap_table_unset(r->headers_out, "Content-Length");
+        apr_table_mergen(r->headers_out, "Transfer-Encoding", "chunked");
+        apr_table_unset(r->headers_out, "Content-Length");
     }
 
     if (r->byterange > 1)
-        ap_table_setn(r->headers_out, "Content-Type",
-                  ap_pstrcat(r->pool, "multipart", use_range_x(r) ? "/x-" : "/",
+        apr_table_setn(r->headers_out, "Content-Type",
+                  apr_pstrcat(r->pool, "multipart", use_range_x(r) ? "/x-" : "/",
                           "byteranges; boundary=", r->boundary, NULL));
-    else ap_table_setn(r->headers_out, "Content-Type", make_content_type(r, 
+    else apr_table_setn(r->headers_out, "Content-Type", make_content_type(r, 
 	r->content_type));
 
     if (r->content_encoding)
-        ap_table_setn(r->headers_out, "Content-Encoding", r->content_encoding);
+        apr_table_setn(r->headers_out, "Content-Encoding", r->content_encoding);
 
     if (r->content_languages && r->content_languages->nelts) {
         for (i = 0; i < r->content_languages->nelts; ++i) {
-            ap_table_mergen(r->headers_out, "Content-Language",
+            apr_table_mergen(r->headers_out, "Content-Language",
                         ((char **) (r->content_languages->elts))[i]);
         }
     }
     else if (r->content_language)
-        ap_table_setn(r->headers_out, "Content-Language", r->content_language);
+        apr_table_setn(r->headers_out, "Content-Language", r->content_language);
 
     /*
      * Control cachability for non-cachable responses if not already set by
      * some other part of the server configuration.
      */
-    if (r->no_cache && !ap_table_get(r->headers_out, "Expires")) {
-	date = ap_palloc(r->pool, AP_RFC822_DATE_LEN);
-        ap_rfc822_date(date, r->request_time);
-        ap_table_addn(r->headers_out, "Expires", date);
+    if (r->no_cache && !apr_table_get(r->headers_out, "Expires")) {
+	date = apr_palloc(r->pool, AP_RFC822_DATE_LEN);
+        apr_rfc822_date(date, r->request_time);
+        apr_table_addn(r->headers_out, "Expires", date);
     }
 
-    /* Send the entire ap_table_t of header fields, terminated by an empty line. */
+    /* Send the entire apr_table_t of header fields, terminated by an empty line. */
 
-    ap_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
+    apr_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
              (void *) r, r->headers_out, NULL);
 
     terminate_header(r);
@@ -1919,8 +1919,8 @@ API_EXPORT(void) ap_finalize_request_protocol(request_rec *r)
 
 API_EXPORT(int) ap_setup_client_block(request_rec *r, int read_policy)
 {
-    const char *tenc = ap_table_get(r->headers_in, "Transfer-Encoding");
-    const char *lenp = ap_table_get(r->headers_in, "Content-Length");
+    const char *tenc = apr_table_get(r->headers_in, "Transfer-Encoding");
+    const char *lenp = apr_table_get(r->headers_in, "Content-Length");
     unsigned long max_body;
 
     r->read_body = read_policy;
@@ -1976,7 +1976,7 @@ API_EXPORT(int) ap_setup_client_block(request_rec *r, int read_policy)
          * from looking at the MIME header. 
          * If no Content-Type header is found, text conversion is assumed.
          */
-        const char *typep = ap_table_get(r->headers_in, "Content-Type");
+        const char *typep = apr_table_get(r->headers_in, "Content-Type");
         int convert_in = (typep == NULL ||
                           strncasecmp(typep, "text/", 5) == 0 ||
                           strncasecmp(typep, "message/", 8) == 0 ||
@@ -2049,11 +2049,11 @@ static long get_chunk_size(char *b)
 API_EXPORT(long) ap_get_client_block(request_rec *r, char *buffer, int bufsiz)
 {
     int c;
-    ap_size_t len_to_read;
-    ap_ssize_t len_read;
+    apr_size_t len_to_read;
+    apr_ssize_t len_read;
     long chunk_start = 0;
     unsigned long max_body;
-    ap_status_t rv;
+    apr_status_t rv;
 
     if (!r->read_chunked) {     /* Content-length read */
         len_to_read = (r->remaining > bufsiz) ? bufsiz : r->remaining;
@@ -2108,10 +2108,10 @@ API_EXPORT(long) ap_get_client_block(request_rec *r, char *buffer, int bufsiz)
         if (len_to_read == 0) { /* Last chunk indicated, get footers */
             if (r->read_body == REQUEST_CHUNKED_DECHUNK) {
                 get_mime_headers(r);
-                ap_snprintf(buffer, bufsiz, "%ld", r->read_length);
-                ap_table_unset(r->headers_in, "Transfer-Encoding");
-                ap_table_setn(r->headers_in, "Content-Length",
-                    ap_pstrdup(r->pool, buffer));
+                apr_snprintf(buffer, bufsiz, "%ld", r->read_length);
+                apr_table_unset(r->headers_in, "Transfer-Encoding");
+                apr_table_setn(r->headers_in, "Content-Length",
+                    apr_pstrdup(r->pool, buffer));
                 return 0;
             }
             r->remaining = -1;  /* Indicate footers in-progress */
@@ -2252,13 +2252,13 @@ API_EXPORT(int) ap_discard_request_body(request_rec *r)
 }
 
 #if APR_HAS_SENDFILE
-static ap_status_t static_send_file(ap_file_t *fd, request_rec *r, ap_off_t offset, 
-                                    ap_size_t length, ap_size_t *nbytes) 
+static apr_status_t static_send_file(apr_file_t *fd, request_rec *r, apr_off_t offset, 
+                                    apr_size_t length, apr_size_t *nbytes) 
 {
-    ap_int32_t flags = 0;
-    ap_status_t rv;
+    apr_int32_t flags = 0;
+    apr_status_t rv;
     struct iovec iov;
-    ap_hdtr_t hdtr;
+    apr_hdtr_t hdtr;
 
     ap_bsetopt(r->connection->client, BO_TIMEOUT,
                r->connection->keptalive
@@ -2276,7 +2276,7 @@ static ap_status_t static_send_file(ap_file_t *fd, request_rec *r, ap_off_t offs
     iov.iov_len =  r->connection->client->outcnt;
     r->connection->client->outcnt = 0;
 
-    /* initialize the ap_hdtr_t struct */
+    /* initialize the apr_hdtr_t struct */
     hdtr.headers = &iov;
     hdtr.numheaders = 1;
     hdtr.trailers = NULL;
@@ -2308,13 +2308,13 @@ static ap_status_t static_send_file(ap_file_t *fd, request_rec *r, ap_off_t offs
 /*
  * Send the body of a response to the client.
  */
-API_EXPORT(ap_status_t) ap_send_fd(ap_file_t *fd, request_rec *r, ap_off_t offset, 
-                                   ap_size_t length, ap_size_t *nbytes) 
+API_EXPORT(apr_status_t) ap_send_fd(apr_file_t *fd, request_rec *r, apr_off_t offset, 
+                                   apr_size_t length, apr_size_t *nbytes) 
 {
-    ap_status_t rv = APR_SUCCESS;
-    ap_size_t total_bytes_sent = 0;
+    apr_status_t rv = APR_SUCCESS;
+    apr_size_t total_bytes_sent = 0;
     register int o;
-    ap_ssize_t n;
+    apr_ssize_t n;
     char buf[IOBUFSIZE];
 
     if ((length == 0) || r->connection->aborted) {
@@ -2344,10 +2344,10 @@ API_EXPORT(ap_status_t) ap_send_fd(ap_file_t *fd, request_rec *r, ap_off_t offse
     /* Either sendfile is not defined or it failed with APR_ENOTIMPL */
     if (offset) {
         /* Seek the file to the offset */
-        rv = ap_seek(fd, APR_SET, &offset);
+        rv = apr_seek(fd, APR_SET, &offset);
         if (rv != APR_SUCCESS) {
             *nbytes = total_bytes_sent;
-            /* ap_close(fd); close the file or let the caller handle it? */
+            /* apr_close(fd); close the file or let the caller handle it? */
             return rv;
         }
     }
@@ -2359,7 +2359,7 @@ API_EXPORT(ap_status_t) ap_send_fd(ap_file_t *fd, request_rec *r, ap_off_t offse
             n = IOBUFSIZE;
         
         do {
-            rv = ap_read(fd, buf, &n);
+            rv = apr_read(fd, buf, &n);
         } while (rv == APR_EINTR && !r->connection->aborted);
 
         /* Is this still the right check? maybe check for n==0 or rv == APR_EOF? */
@@ -2392,9 +2392,9 @@ API_EXPORT(long) ap_send_fb_length(BUFF *fb, request_rec *r, long length)
     long total_bytes_sent = 0;
     long zero_timeout = 0;
     register int o;
-    ap_ssize_t n;
-    ap_ssize_t bytes_read;
-    ap_status_t read_rv;
+    apr_ssize_t n;
+    apr_ssize_t bytes_read;
+    apr_status_t read_rv;
 
     if (length == 0) {
         return 0;
@@ -2430,7 +2430,7 @@ API_EXPORT(long) ap_send_fb_length(BUFF *fb, request_rec *r, long length)
             (void) ap_rflush(r);
             break;
         }
-        else if (ap_canonical_error(read_rv) != APR_EAGAIN) {
+        else if (apr_canonical_error(read_rv) != APR_EAGAIN) {
             r->connection->aborted = 1;
             break;
         }
@@ -2465,12 +2465,12 @@ API_EXPORT(long) ap_send_fb_length(BUFF *fb, request_rec *r, long length)
 #endif
 
 /* send data from an in-memory buffer */
-API_EXPORT(size_t) ap_send_mmap(ap_mmap_t *mm, request_rec *r, size_t offset,
+API_EXPORT(size_t) ap_send_mmap(apr_mmap_t *mm, request_rec *r, size_t offset,
                              size_t length)
 {
     size_t total_bytes_sent = 0;
     int n;
-    ap_ssize_t w;
+    apr_ssize_t w;
     char *addr;
     
     if (length == 0)
@@ -2486,7 +2486,7 @@ API_EXPORT(size_t) ap_send_mmap(ap_mmap_t *mm, request_rec *r, size_t offset,
             n = length - offset;
         }
 
-        ap_mmap_offset((void**)&addr, mm, offset);
+        apr_mmap_offset((void**)&addr, mm, offset);
         w = ap_rwrite(addr, n, r);
         if (w < 0)
             break;
@@ -2530,8 +2530,8 @@ API_EXPORT(int) ap_rputs(const char *str, request_rec *r)
 
 API_EXPORT(int) ap_rwrite(const void *buf, int nbyte, request_rec *r)
 {
-    ap_ssize_t n;
-    ap_status_t rv;
+    apr_ssize_t n;
+    apr_status_t rv;
 
     if (r->connection->aborted)
         return EOF;
@@ -2606,7 +2606,7 @@ API_EXPORT_NONSTD(int) ap_rvputs(request_rec *r, ...)
 
 API_EXPORT(int) ap_rflush(request_rec *r)
 {
-    ap_status_t rv;
+    apr_status_t rv;
 
     if ((rv = ap_bflush(r->connection->client)) != APR_SUCCESS) {
         check_first_conn_error(r, "rflush", rv);
@@ -2626,7 +2626,7 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
     int status = r->status;
     int idx = ap_index_of_response(status);
     char *custom_response;
-    const char *location = ap_table_get(r->headers_out, "Location");
+    const char *location = apr_table_get(r->headers_out, "Location");
 
     /*
      * It's possible that the Location field might be in r->err_headers_out
@@ -2634,7 +2634,7 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
      * former.
      */
     if (location == NULL) {
-	location = ap_table_get(r->err_headers_out, "Location");
+	location = apr_table_get(r->err_headers_out, "Location");
     }
     /* We need to special-case the handling of 204 and 304 responses,
      * since they have specific HTTP requirements and do not include a
@@ -2642,12 +2642,12 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
      */
     if (status == HTTP_NOT_MODIFIED) {
         if (!ap_is_empty_table(r->err_headers_out))
-            r->headers_out = ap_overlay_tables(r->pool, r->err_headers_out,
+            r->headers_out = apr_overlay_tables(r->pool, r->err_headers_out,
                                                r->headers_out);
         ap_basic_http_header(r);
         ap_set_keepalive(r);
 
-        ap_table_do((int (*)(void *, const char *, const char *)) ap_send_header_field,
+        apr_table_do((int (*)(void *, const char *, const char *)) ap_send_header_field,
                     (void *) r, r->headers_out,
                     "Connection",
                     "Keep-Alive",
@@ -2673,7 +2673,7 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
     }
 
     if (!r->assbackwards) {
-        ap_table_t *tmp = r->headers_out;
+        apr_table_t *tmp = r->headers_out;
 
         /* For all HTTP/1.x responses for which we generate the message,
          * we need to avoid inheriting the "normal status" header fields
@@ -2682,11 +2682,11 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
          */
         r->headers_out = r->err_headers_out;
         r->err_headers_out = tmp;
-        ap_clear_table(r->err_headers_out);
+        apr_clear_table(r->err_headers_out);
 
         if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {
             if ((location != NULL) && *location) {
-	        ap_table_setn(r->headers_out, "Location", location);
+	        apr_table_setn(r->headers_out, "Location", location);
             }
             else {
                 location = "";   /* avoids coredump when printing, below */
@@ -2701,7 +2701,7 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
 
         if ((status == HTTP_METHOD_NOT_ALLOWED)
             || (status == HTTP_NOT_IMPLEMENTED)) {
-            ap_table_setn(r->headers_out, "Allow", make_allow(r));
+            apr_table_setn(r->headers_out, "Allow", make_allow(r));
         }
 
         ap_send_http_header(r);
@@ -2806,7 +2806,7 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
 	case HTTP_BAD_REQUEST:
 	    ap_rputs("Your browser sent a request that "
 	             "this server could not understand.<P>\n", r);
-	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+	    if ((error_notes = apr_table_get(r->notes, "error-notes")) != NULL) {
 		ap_rvputs(r, error_notes, "<P>\n", NULL);
 	    }
 	    break;
@@ -2836,14 +2836,14 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
 	case HTTP_MULTIPLE_CHOICES:
 	    {
 		const char *list;
-		if ((list = ap_table_get(r->notes, "variant-list")))
+		if ((list = apr_table_get(r->notes, "variant-list")))
 		    ap_rputs(list, r);
 	    }
 	    break;
 	case HTTP_LENGTH_REQUIRED:
 	    ap_rvputs(r, "A request of the requested method ", r->method,
 		      " requires a valid Content-length.<P>\n", NULL);
-	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+	    if ((error_notes = apr_table_get(r->notes, "error-notes")) != NULL) {
 		ap_rvputs(r, error_notes, "<P>\n", NULL);
 	    }
 	    break;
@@ -2856,14 +2856,14 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
 	    ap_rvputs(r, ap_escape_html(r->pool, r->method), " to ",
 		      ap_escape_html(r->pool, r->uri),
 		      " not supported.<P>\n", NULL);
-	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+	    if ((error_notes = apr_table_get(r->notes, "error-notes")) != NULL) {
 		ap_rvputs(r, error_notes, "<P>\n", NULL);
 	    }
 	    break;
 	case HTTP_BAD_GATEWAY:
 	    ap_rputs("The proxy server received an invalid" CRLF
 	             "response from an upstream server.<P>" CRLF, r);
-	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+	    if ((error_notes = apr_table_get(r->notes, "error-notes")) != NULL) {
 		ap_rvputs(r, error_notes, "<P>\n", NULL);
 	    }
 	    break;
@@ -2894,7 +2894,7 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
 	case HTTP_REQUEST_URI_TOO_LARGE:
 	    ap_rputs("The requested URL's length exceeds the capacity\n"
 	             "limit for this server.<P>\n", r);
-	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+	    if ((error_notes = apr_table_get(r->notes, "error-notes")) != NULL) {
 		ap_rvputs(r, error_notes, "<P>\n", NULL);
 	    }
 	    break;
@@ -2911,7 +2911,7 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
 	    ap_rvputs(r, "The expectation given in the Expect request-header"
 	              "\nfield could not be met by this server.<P>\n"
 	              "The client sent<PRE>\n    Expect: ",
-	              ap_table_get(r->headers_in, "Expect"), "\n</PRE>\n"
+	              apr_table_get(r->headers_in, "Expect"), "\n</PRE>\n"
 	              "but we only allow the 100-continue expectation.\n",
 	              NULL);
 	    break;
@@ -2958,8 +2958,8 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
 	     * that is totally safe for any user to see (ie lacks paths,
 	     * database passwords, etc.)
 	     */
-	    if (((error_notes = ap_table_get(r->notes, "error-notes")) != NULL)
-		&& (h1 = ap_table_get(r->notes, "verbose-error-to")) != NULL
+	    if (((error_notes = apr_table_get(r->notes, "error-notes")) != NULL)
+		&& (h1 = apr_table_get(r->notes, "verbose-error-to")) != NULL
 		&& (strcmp(h1, "*") == 0)) {
 	        ap_rvputs(r, error_notes, "<P>\n", NULL);
 	    }
@@ -2984,7 +2984,7 @@ API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
 	  * which some people consider to be a breach of privacy.  Until we
 	  * can figure out a way to remove the pathname, leave this commented.
 	  *
-	  * if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+	  * if ((error_notes = apr_table_get(r->notes, "error-notes")) != NULL) {
 	  *     ap_rvputs(r, error_notes, "<P>\n", NULL);
 	  * }
 	  */
diff --git a/modules/http/http_request.c b/modules/http/http_request.c
index 9bde865..2f81390 100644
--- a/modules/http/http_request.c
+++ b/modules/http/http_request.c
@@ -140,13 +140,13 @@ static int check_safe_file(request_rec *r)
 }
 
 
-static int check_symlinks(char *d, int opts, ap_pool_t *p)
+static int check_symlinks(char *d, int opts, apr_pool_t *p)
 {
 #if defined(OS2) || defined(WIN32)
     /* OS/2 doesn't have symlinks */
     return OK;
 #else
-    ap_finfo_t lfi, fi;
+    apr_finfo_t lfi, fi;
     char *lastp;
     int res;
 
@@ -172,7 +172,7 @@ static int check_symlinks(char *d, int opts, ap_pool_t *p)
     else
         lastp = NULL;
 
-    res = ap_lstat(&lfi, d, p);
+    res = apr_lstat(&lfi, d, p);
 
     if (lastp)
         *lastp = '/';
@@ -190,7 +190,7 @@ static int check_symlinks(char *d, int opts, ap_pool_t *p)
     if (!(opts & OPT_SYM_OWNER))
         return HTTP_FORBIDDEN;
 
-    if (ap_stat(&fi, d, p) < 0)
+    if (apr_stat(&fi, d, p) < 0)
         return HTTP_FORBIDDEN;
 
     return (fi.user == lfi.user) ? OK : HTTP_FORBIDDEN;
@@ -271,7 +271,7 @@ static int get_path_info(request_rec *r)
          }
          else {
              errno = 0;
-             rv = ap_stat(&r->finfo, path, r->pool);
+             rv = apr_stat(&r->finfo, path, r->pool);
          }
 
         if (cp != end)
@@ -289,7 +289,7 @@ static int get_path_info(request_rec *r)
                 cp = last_cp;
             }
 
-            r->path_info = ap_pstrdup(r->pool, cp);
+            r->path_info = apr_pstrdup(r->pool, cp);
             *cp = '\0';
             return OK;
         }
@@ -297,7 +297,7 @@ static int get_path_info(request_rec *r)
 	 * even if they returned an error.
 	 */
 	r->finfo.protection = 0;
-	rvc = ap_canonical_error(rv);
+	rvc = apr_canonical_error(rv);
 
 #if defined(APR_ENOENT) && defined(APR_ENOTDIR)
         if (rvc == APR_ENOENT || rvc == APR_ENOTDIR) {
@@ -366,7 +366,7 @@ static int directory_walk(request_rec *r)
      */
 
     if (r->filename == NULL) {
-        r->filename = ap_pstrdup(r->pool, r->uri);
+        r->filename = apr_pstrdup(r->pool, r->uri);
         r->finfo.protection = 0;   /* Not really a file... */
         r->finfo.filetype = APR_NOFILE;
         r->per_dir_config = per_dir_defaults;
@@ -405,7 +405,7 @@ static int directory_walk(request_rec *r)
                     this_conf = entry_config;
             }
             else if (entry_core->d_is_fnmatch) {
-                if (!ap_fnmatch(entry_dir, r->filename, 0))
+                if (!apr_fnmatch(entry_dir, r->filename, 0))
                     this_conf = entry_config;
             }
             else if (!strncmp(r->filename, entry_dir, strlen(entry_dir)))
@@ -431,7 +431,7 @@ static int directory_walk(request_rec *r)
 
     r->filename   = ap_os_canonical_filename(r->pool, r->filename);
 
-    test_filename = ap_pstrdup(r->pool, r->filename);
+    test_filename = apr_pstrdup(r->pool, r->filename);
 
     ap_no2slash(test_filename);
     num_dirs = ap_count_dirs(test_filename);
@@ -460,7 +460,7 @@ static int directory_walk(request_rec *r)
      * We need 2 extra bytes, one for trailing \0 and one because
      * make_dirstr_prefix will add potentially one extra /.
      */
-    test_dirname = ap_palloc(r->pool, test_filename_len + 2);
+    test_dirname = apr_palloc(r->pool, test_filename_len + 2);
 
     iStart = 1;
 #ifdef WIN32
@@ -517,7 +517,7 @@ static int directory_walk(request_rec *r)
 
             this_conf = NULL;
             if (entry_core->d_is_fnmatch) {
-                if (!ap_fnmatch(entry_dir, test_dirname, FNM_PATHNAME)) {
+                if (!apr_fnmatch(entry_dir, test_dirname, FNM_PATHNAME)) {
                     this_conf = entry_config;
                 }
             }
@@ -540,7 +540,7 @@ static int directory_walk(request_rec *r)
             void *htaccess_conf = NULL;
 
             res = ap_parse_htaccess(&htaccess_conf, r, overrides_here,
-                                 ap_pstrdup(r->pool, test_dirname),
+                                 apr_pstrdup(r->pool, test_dirname),
                                  sconf->access_name);
             if (res)
                 return res;
@@ -621,7 +621,7 @@ static int location_walk(request_rec *r)
 	test_location = r->uri;
     }
     else {
-	test_location = ap_pstrdup(r->pool, r->uri);
+	test_location = apr_pstrdup(r->pool, r->uri);
 	ap_no2slash(test_location);
     }
 
@@ -647,7 +647,7 @@ static int location_walk(request_rec *r)
 		this_conf = entry_config;
 	}
 	else if (entry_core->d_is_fnmatch) {
-	    if (!ap_fnmatch(entry_url, test_location, FNM_PATHNAME)) {
+	    if (!apr_fnmatch(entry_url, test_location, FNM_PATHNAME)) {
 		this_conf = entry_config;
 	    }
 	}
@@ -708,7 +708,7 @@ static int file_walk(request_rec *r)
                     this_conf = entry_config;
             }
             else if (entry_core->d_is_fnmatch) {
-                if (!ap_fnmatch(entry_file, test_file, FNM_PATHNAME)) {
+                if (!apr_fnmatch(entry_file, test_file, FNM_PATHNAME)) {
                     this_conf = entry_config;
                 }
             }
@@ -744,11 +744,11 @@ static int file_walk(request_rec *r)
 
 static request_rec *make_sub_request(const request_rec *r)
 {
-    ap_pool_t *rrp;
+    apr_pool_t *rrp;
     request_rec *rr;
     
-    ap_create_pool(&rrp, r->pool);
-    rr = ap_pcalloc(rrp, sizeof(request_rec));
+    apr_create_pool(&rrp, r->pool);
+    rr = apr_pcalloc(rrp, sizeof(request_rec));
     rr->pool = rrp;
     return rr;
 }
@@ -881,7 +881,7 @@ API_EXPORT(request_rec *) ap_sub_req_lookup_file(const char *new_file,
         rnew->filename = ap_make_full_path(rnew->pool, fdir, new_file);
         ap_parse_uri(rnew, rnew->uri);    /* fill in parsed_uri values */
 
-        if (ap_stat(&rnew->finfo, rnew->filename, rnew->pool) != APR_SUCCESS) {
+        if (apr_stat(&rnew->finfo, rnew->filename, rnew->pool) != APR_SUCCESS) {
             rnew->finfo.protection = 0;
         }
 
@@ -936,7 +936,7 @@ API_EXPORT(request_rec *) ap_sub_req_lookup_file(const char *new_file,
          */
         rnew->uri = "INTERNALLY GENERATED file-relative req";
         rnew->filename = ((ap_os_is_path_absolute(new_file)) ?
-                          ap_pstrdup(rnew->pool, new_file) :
+                          apr_pstrdup(rnew->pool, new_file) :
                           ap_make_full_path(rnew->pool, fdir, new_file));
         rnew->per_dir_config = r->server->lookup_defaults;
         res = directory_walk(rnew);
@@ -977,7 +977,7 @@ API_EXPORT(int) ap_run_sub_req(request_rec *r)
 #else /*APACHE_XLATE*/
     {
         /* Save the output conversion setting across subrequests */
-        ap_xlate_t *saved_xlate;
+        apr_xlate_t *saved_xlate;
 
         ap_bgetopt(r->connection->client, BO_WXLATE, &saved_xlate);
         retval  = ap_invoke_handler(r);
@@ -991,7 +991,7 @@ API_EXPORT(int) ap_run_sub_req(request_rec *r)
 API_EXPORT(void) ap_destroy_sub_req(request_rec *r)
 {
     /* Reclaim the space */
-    ap_destroy_pool(r->pool);
+    apr_destroy_pool(r->pool);
 }
 
 /*****************************************************************
@@ -1064,7 +1064,7 @@ API_EXPORT(void) ap_die(int type, request_rec *r)
              * status...
              */
             r->status = HTTP_MOVED_TEMPORARILY;
-            ap_table_setn(r->headers_out, "Location", custom_response);
+            apr_table_setn(r->headers_out, "Location", custom_response);
         }
         else if (custom_response[0] == '/') {
             const char *error_notes;
@@ -1074,17 +1074,17 @@ API_EXPORT(void) ap_die(int type, request_rec *r)
              * This redirect needs to be a GET no matter what the original
              * method was.
              */
-            ap_table_setn(r->subprocess_env, "REQUEST_METHOD", r->method);
+            apr_table_setn(r->subprocess_env, "REQUEST_METHOD", r->method);
 
 	    /*
 	     * Provide a special method for modules to communicate
 	     * more informative (than the plain canned) messages to us.
 	     * Propagate them to ErrorDocuments via the ERROR_NOTES variable:
 	     */
-            if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
-		ap_table_setn(r->subprocess_env, "ERROR_NOTES", error_notes);
+            if ((error_notes = apr_table_get(r->notes, "error-notes")) != NULL) {
+		apr_table_setn(r->subprocess_env, "ERROR_NOTES", error_notes);
 	    }
-            r->method = ap_pstrdup(r->pool, "GET");
+            r->method = apr_pstrdup(r->pool, "GET");
             r->method_number = M_GET;
             ap_internal_redirect(custom_response, r);
             return;
@@ -1118,7 +1118,7 @@ API_EXPORT(int) ap_some_auth_required(request_rec *r)
 {
     /* Is there a require line configured for the type of *this* req? */
 
-    const ap_array_header_t *reqs_arr = ap_requires(r);
+    const apr_array_header_t *reqs_arr = ap_requires(r);
     require_line *reqs;
     int i;
 
@@ -1173,7 +1173,7 @@ static void process_request_internal(request_rec *r)
 	}
     }
 
-    if (r->proto_num > HTTP_VERSION(1,0) && ap_table_get(r->subprocess_env, "downgrade-1.0")) {
+    if (r->proto_num > HTTP_VERSION(1,0) && apr_table_get(r->subprocess_env, "downgrade-1.0")) {
         r->proto_num = HTTP_VERSION(1,0);
     }
 
@@ -1295,17 +1295,17 @@ void ap_process_request(request_rec *r)
     ap_run_log_transaction(r);
 }
 
-static ap_table_t *rename_original_env(ap_pool_t *p, ap_table_t *t)
+static apr_table_t *rename_original_env(apr_pool_t *p, apr_table_t *t)
 {
-    ap_array_header_t *env_arr = ap_table_elts(t);
-    ap_table_entry_t *elts = (ap_table_entry_t *) env_arr->elts;
-    ap_table_t *new = ap_make_table(p, env_arr->nalloc);
+    apr_array_header_t *env_arr = ap_table_elts(t);
+    apr_table_entry_t *elts = (apr_table_entry_t *) env_arr->elts;
+    apr_table_t *new = apr_make_table(p, env_arr->nalloc);
     int i;
 
     for (i = 0; i < env_arr->nelts; ++i) {
         if (!elts[i].key)
             continue;
-        ap_table_setn(new, ap_pstrcat(p, "REDIRECT_", elts[i].key, NULL),
+        apr_table_setn(new, apr_pstrcat(p, "REDIRECT_", elts[i].key, NULL),
                   elts[i].val);
     }
 
@@ -1315,7 +1315,7 @@ static ap_table_t *rename_original_env(ap_pool_t *p, ap_table_t *t)
 static request_rec *internal_internal_redirect(const char *new_uri, request_rec *r)
 {
     int access_status;
-    request_rec *new = (request_rec *) ap_pcalloc(r->pool, sizeof(request_rec));
+    request_rec *new = (request_rec *) apr_pcalloc(r->pool, sizeof(request_rec));
 
     new->connection = r->connection;
     new->server     = r->server;
@@ -1352,10 +1352,10 @@ static request_rec *internal_internal_redirect(const char *new_uri, request_rec
     new->main            = r->main;
 
     new->headers_in      = r->headers_in;
-    new->headers_out     = ap_make_table(r->pool, 12);
+    new->headers_out     = apr_make_table(r->pool, 12);
     new->err_headers_out = r->err_headers_out;
     new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);
-    new->notes           = ap_make_table(r->pool, 5);
+    new->notes           = apr_make_table(r->pool, 5);
 
     new->htaccess        = r->htaccess;
     new->no_cache        = r->no_cache;
@@ -1364,8 +1364,8 @@ static request_rec *internal_internal_redirect(const char *new_uri, request_rec
     new->read_length     = r->read_length;     /* We can only read it once */
     new->vlist_validator = r->vlist_validator;
 
-    ap_table_setn(new->subprocess_env, "REDIRECT_STATUS",
-	ap_psprintf(r->pool, "%d", r->status));
+    apr_table_setn(new->subprocess_env, "REDIRECT_STATUS",
+	apr_psprintf(r->pool, "%d", r->status));
 
     /*
      * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need
@@ -1378,7 +1378,7 @@ static request_rec *internal_internal_redirect(const char *new_uri, request_rec
     }
 
 #ifdef APACHE_XLATE
-    new->rrx = ap_pcalloc(new->pool, sizeof(struct ap_rr_xlate));
+    new->rrx = apr_pcalloc(new->pool, sizeof(struct ap_rr_xlate));
     ap_set_content_xlate(new, 1, ap_locale_to_ascii);
     ap_set_content_xlate(new, 0, ap_locale_from_ascii);
 #endif /*APACHE_XLATE*/
@@ -1419,7 +1419,7 @@ API_EXPORT(int) ap_is_initial_req(request_rec *r)
  * Function to set the r->mtime field to the specified value if it's later
  * than what's already there.
  */
-API_EXPORT(void) ap_update_mtime(request_rec *r, ap_time_t dependency_mtime)
+API_EXPORT(void) ap_update_mtime(request_rec *r, apr_time_t dependency_mtime)
 {
     if (r->mtime < dependency_mtime) {
 	r->mtime = dependency_mtime;
diff --git a/modules/http/mod_mime.c b/modules/http/mod_mime.c
index 6beddfc..34a73be 100644
--- a/modules/http/mod_mime.c
+++ b/modules/http/mod_mime.c
@@ -96,12 +96,12 @@ typedef struct handlers_info {
 } handlers_info;
 
 typedef struct {
-    ap_table_t *forced_types;        /* Additional AddTyped stuff */
-    ap_table_t *encoding_types;      /* Added with AddEncoding... */
-    ap_table_t *language_types;      /* Added with AddLanguage... */
-    ap_table_t *handlers;            /* Added with AddHandler...  */
-    ap_table_t *charset_types;       /* Added with AddCharset... */       
-    ap_array_header_t *handlers_remove;     /* List of handlers to remove */
+    apr_table_t *forced_types;        /* Additional AddTyped stuff */
+    apr_table_t *encoding_types;      /* Added with AddEncoding... */
+    apr_table_t *language_types;      /* Added with AddLanguage... */
+    apr_table_t *handlers;            /* Added with AddHandler...  */
+    apr_table_t *charset_types;       /* Added with AddCharset... */       
+    apr_array_header_t *handlers_remove;     /* List of handlers to remove */
 
     char *type;                 /* Type forced with ForceType  */
     char *handler;              /* Handler forced with SetHandler */
@@ -130,17 +130,17 @@ static char tspecial[] = {
 
 module MODULE_VAR_EXPORT mime_module;
 
-static void *create_mime_dir_config(ap_pool_t *p, char *dummy)
+static void *create_mime_dir_config(apr_pool_t *p, char *dummy)
 {
     mime_dir_config *new =
-    (mime_dir_config *) ap_palloc(p, sizeof(mime_dir_config));
+    (mime_dir_config *) apr_palloc(p, sizeof(mime_dir_config));
 
-    new->forced_types = ap_make_table(p, 4);
-    new->encoding_types = ap_make_table(p, 4);
-    new->charset_types = ap_make_table(p, 4);
-    new->language_types = ap_make_table(p, 4);
-    new->handlers = ap_make_table(p, 4);
-    new->handlers_remove = ap_make_array(p, 4, sizeof(handlers_info));
+    new->forced_types = apr_make_table(p, 4);
+    new->encoding_types = apr_make_table(p, 4);
+    new->charset_types = apr_make_table(p, 4);
+    new->language_types = apr_make_table(p, 4);
+    new->handlers = apr_make_table(p, 4);
+    new->handlers_remove = apr_make_array(p, 4, sizeof(handlers_info));
 
     new->type = NULL;
     new->handler = NULL;
@@ -149,29 +149,29 @@ static void *create_mime_dir_config(ap_pool_t *p, char *dummy)
     return new;
 }
 
-static void *merge_mime_dir_configs(ap_pool_t *p, void *basev, void *addv)
+static void *merge_mime_dir_configs(apr_pool_t *p, void *basev, void *addv)
 {
     mime_dir_config *base = (mime_dir_config *) basev;
     mime_dir_config *add = (mime_dir_config *) addv;
     mime_dir_config *new =
-        (mime_dir_config *) ap_palloc(p, sizeof(mime_dir_config));
+        (mime_dir_config *) apr_palloc(p, sizeof(mime_dir_config));
     int i;
     handlers_info *hand;
 
     hand = (handlers_info *) add->handlers_remove->elts;
     for (i = 0; i < add->handlers_remove->nelts; i++) {
-        ap_table_unset(base->handlers, hand[i].name);
+        apr_table_unset(base->handlers, hand[i].name);
     }
 
-    new->forced_types = ap_overlay_tables(p, add->forced_types,
+    new->forced_types = apr_overlay_tables(p, add->forced_types,
 					 base->forced_types);
-    new->encoding_types = ap_overlay_tables(p, add->encoding_types,
+    new->encoding_types = apr_overlay_tables(p, add->encoding_types,
                                          base->encoding_types);
-    new->charset_types = ap_overlay_tables(p, add->charset_types,
+    new->charset_types = apr_overlay_tables(p, add->charset_types,
 					   base->charset_types);
-    new->language_types = ap_overlay_tables(p, add->language_types,
+    new->language_types = apr_overlay_tables(p, add->language_types,
                                          base->language_types);
-    new->handlers = ap_overlay_tables(p, add->handlers,
+    new->handlers = apr_overlay_tables(p, add->handlers,
                                    base->handlers);
 
     new->type = add->type ? add->type : base->type;
@@ -186,13 +186,13 @@ static const char *add_type(cmd_parms *cmd, void *m_, const char *ct_,
                             const char *ext)
 {
     mime_dir_config *m=m_;
-    char *ct=ap_pstrdup(cmd->pool,ct_);
+    char *ct=apr_pstrdup(cmd->pool,ct_);
 
     if (*ext == '.')
 	++ext;
 	
     ap_str_tolower(ct);
-    ap_table_setn(m->forced_types, ext, ct);
+    apr_table_setn(m->forced_types, ext, ct);
     return NULL;
 }
 
@@ -200,12 +200,12 @@ static const char *add_encoding(cmd_parms *cmd, void *m_, const char *enc_,
 				const char *ext)
 {
     mime_dir_config *m=m_;
-    char *enc=ap_pstrdup(cmd->pool,enc_);
+    char *enc=apr_pstrdup(cmd->pool,enc_);
 
     if (*ext == '.')
         ++ext;
     ap_str_tolower(enc);
-    ap_table_setn(m->encoding_types, ext, enc);
+    apr_table_setn(m->encoding_types, ext, enc);
     return NULL;
 }
 
@@ -213,13 +213,13 @@ static const char *add_charset(cmd_parms *cmd, void *m_, const char *charset_,
 			       const char *ext)
 {
     mime_dir_config *m=m_;
-    char *charset=ap_pstrdup(cmd->pool,charset_);
+    char *charset=apr_pstrdup(cmd->pool,charset_);
 
     if (*ext == '.') {
 	++ext;
     }
     ap_str_tolower(charset);
-    ap_table_setn(m->charset_types, ext, charset);
+    apr_table_setn(m->charset_types, ext, charset);
     return NULL;
 }
 
@@ -227,13 +227,13 @@ static const char *add_language(cmd_parms *cmd, void *m_, const char *lang_,
                                 const char *ext)
 {
     mime_dir_config *m=m_;
-    char *lang=ap_pstrdup(cmd->pool,lang_);
+    char *lang=apr_pstrdup(cmd->pool,lang_);
 
     if (*ext == '.') {
 	++ext;
     }
     ap_str_tolower(lang);
-    ap_table_setn(m->language_types, ext, lang);
+    apr_table_setn(m->language_types, ext, lang);
     return NULL;
 }
 
@@ -241,12 +241,12 @@ static const char *add_handler(cmd_parms *cmd, void *m_, const char *hdlr_,
                                const char *ext)
 {
     mime_dir_config *m=m_;
-    char *hdlr=ap_pstrdup(cmd->pool,hdlr_);
+    char *hdlr=apr_pstrdup(cmd->pool,hdlr_);
 
     if (*ext == '.')
         ++ext;
     ap_str_tolower(hdlr);
-    ap_table_setn(m->handlers, ext, hdlr);
+    apr_table_setn(m->handlers, ext, hdlr);
     return NULL;
 }
 
@@ -263,8 +263,8 @@ static const char *remove_handler(cmd_parms *cmd, void *m, const char *ext)
     if (*ext == '.') {
         ++ext;
     }
-    hand = (handlers_info *) ap_push_array(mcfg->handlers_remove);
-    hand->name = ap_pstrdup(cmd->pool, ext);
+    hand = (handlers_info *) apr_push_array(mcfg->handlers_remove);
+    hand->name = apr_pstrdup(cmd->pool, ext);
     return NULL;
 }
 
@@ -308,22 +308,22 @@ AP_INIT_TAKE1("DefaultLanguage", ap_set_string_slot,
     {NULL}
 };
 
-/* Hash ap_table_t  --- only one of these per daemon; virtual hosts can
+/* Hash apr_table_t  --- only one of these per daemon; virtual hosts can
  * get private versions through AddType...
  */
 
 #define MIME_HASHSIZE (32)
 #define hash(i) (ap_tolower(i) % MIME_HASHSIZE)
 
-static ap_table_t *hash_buckets[MIME_HASHSIZE];
+static apr_table_t *hash_buckets[MIME_HASHSIZE];
 
-static void mime_post_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *s)
+static void mime_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
 {
     configfile_t *f;
     char l[MAX_STRING_LEN];
     int x;
     const char *types_confname = ap_get_module_config(s->module_config, &mime_module);
-    ap_status_t status;
+    apr_status_t status;
 
     if (!types_confname)
         types_confname = AP_TYPES_CONFIG_FILE;
@@ -337,7 +337,7 @@ static void mime_post_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp, se
     }
 
     for (x = 0; x < MIME_HASHSIZE; x++)
-        hash_buckets[x] = ap_make_table(p, 10);
+        hash_buckets[x] = apr_make_table(p, 10);
 
     while (!(ap_cfg_getline(l, MAX_STRING_LEN, f))) {
         const char *ll = l, *ct;
@@ -349,7 +349,7 @@ static void mime_post_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp, se
         while (ll[0]) {
             char *ext = ap_getword_conf(p, &ll);
             ap_str_tolower(ext);   /* ??? */
-            ap_table_setn(hash_buckets[hash(ext[0])], ext, ct);
+            apr_table_setn(hash_buckets[hash(ext[0])], ext, ct);
         }
     }
     ap_cfg_closefile(f);
@@ -415,18 +415,18 @@ static content_type *analyze_ct(request_rec *r, char *s)
     char *attribute, *value;
     int quoted = 0;
     server_rec * ss = r->server;
-    ap_pool_t  * p = r->pool;
+    apr_pool_t  * p = r->pool;
 
     content_type *ctp;
     param *pp, *npp;
 
     /* initialize ctp */
-    ctp = (content_type *) ap_palloc(p, sizeof(content_type));
+    ctp = (content_type *) apr_palloc(p, sizeof(content_type));
     ctp->type = NULL;
     ctp->subtype = NULL;
     ctp->param = NULL;
 
-    tp = ap_pstrdup(p, s);
+    tp = apr_pstrdup(p, s);
 
     mp = tp;
     cp = mp;
@@ -438,7 +438,7 @@ static content_type *analyze_ct(request_rec *r, char *s)
 		     (const char *) mp);
 	return (NULL);
     }
-    ctp->type = ap_pstrndup(p, mp, cp - mp);
+    ctp->type = apr_pstrndup(p, mp, cp - mp);
     ctp->type = zap_sp(ctp->type);
     if (ctp->type == NULL || *(ctp->type) == '\0' ||
 	strchr(ctp->type, ';') || strchr(ctp->type, ' ') ||
@@ -453,7 +453,7 @@ static content_type *analyze_ct(request_rec *r, char *s)
     mp = cp;
 
     for (; *cp != ';' && *cp != '\0'; cp++);
-    ctp->subtype = ap_pstrndup(p, mp, cp - mp);
+    ctp->subtype = apr_pstrndup(p, mp, cp - mp);
     ctp->subtype = zap_sp(ctp->subtype);
     if ((ctp->subtype == NULL) || (*(ctp->subtype) == '\0') ||
 	strchr(ctp->subtype, ' ') || strchr(ctp->subtype, '\t')) {
@@ -489,7 +489,7 @@ static content_type *analyze_ct(request_rec *r, char *s)
 		continue;
 	    }
 	    else if (*cp == '=') {
-		attribute = ap_pstrndup(p, mp, cp - mp);
+		attribute = apr_pstrndup(p, mp, cp - mp);
 		attribute = zap_sp(attribute);
 		if (attribute == NULL || *attribute == '\0') {
 		    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
@@ -564,7 +564,7 @@ static content_type *analyze_ct(request_rec *r, char *s)
 		    }
 		}
 	    }
-	    value = ap_pstrndup(p, mp, cp - mp);
+	    value = apr_pstrndup(p, mp, cp - mp);
 	    value = zap_sp(value);
 	    if (value == NULL || *value == '\0') {
 		ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
@@ -572,7 +572,7 @@ static content_type *analyze_ct(request_rec *r, char *s)
 		return (NULL);
 	    }
 
-	    pp = ap_palloc(p, sizeof(param));
+	    pp = apr_palloc(p, sizeof(param));
 	    pp->attr = attribute;
 	    pp->val = value;
 	    pp->next = NULL;
@@ -629,42 +629,42 @@ static int find_ct(request_rec *r)
         int found = 0;
 
         /* Check for Content-Type */
-        if ((type = ap_table_get(conf->forced_types, ext))
-            || (type = ap_table_get(hash_buckets[hash(*ext)], ext))) {
+        if ((type = apr_table_get(conf->forced_types, ext))
+            || (type = apr_table_get(hash_buckets[hash(*ext)], ext))) {
             r->content_type = type;
             found = 1;
         }
 
 	/* Add charset to Content-Type */
-	if ((type = ap_table_get(conf->charset_types, ext))) {
+	if ((type = apr_table_get(conf->charset_types, ext))) {
 	    charset = type;
 	    found = 1;
 	}
 
         /* Check for Content-Language */
-        if ((type = ap_table_get(conf->language_types, ext))) {
+        if ((type = apr_table_get(conf->language_types, ext))) {
             const char **new;
 
             r->content_language = type;         /* back compat. only */
             if (!r->content_languages)
-                r->content_languages = ap_make_array(r->pool, 2, sizeof(char *));
-            new = (const char **) ap_push_array(r->content_languages);
+                r->content_languages = apr_make_array(r->pool, 2, sizeof(char *));
+            new = (const char **) apr_push_array(r->content_languages);
             *new = type;
             found = 1;
         }
 
         /* Check for Content-Encoding */
-        if ((type = ap_table_get(conf->encoding_types, ext))) {
+        if ((type = apr_table_get(conf->encoding_types, ext))) {
             if (!r->content_encoding)
                 r->content_encoding = type;
             else
-                r->content_encoding = ap_pstrcat(r->pool, r->content_encoding,
+                r->content_encoding = apr_pstrcat(r->pool, r->content_encoding,
                                               ", ", type, NULL);
             found = 1;
         }
 
         /* Check for a special handler, but not for proxy request */
-        if ((type = ap_table_get(conf->handlers, ext))
+        if ((type = apr_table_get(conf->handlers, ext))
 #if 0	
 	/* XXX fix me when the proxy code is updated */
 	    && r->proxyreq == NOT_PROXY) 
@@ -694,25 +694,25 @@ static int find_ct(request_rec *r)
 	char *ct;
 	int override = 0;
 
-	ct = (char *) ap_palloc(r->pool,
+	ct = (char *) apr_palloc(r->pool,
 				sizeof(char) * (strlen(r->content_type) + 1));
 	strcpy(ct, r->content_type);
 
 	if ((ctp = analyze_ct(r, ct))) {
 	    param *pp = ctp->param;
-	    r->content_type = ap_pstrcat(r->pool, ctp->type, "/",
+	    r->content_type = apr_pstrcat(r->pool, ctp->type, "/",
 					 ctp->subtype, NULL);
 	    while (pp != NULL) {
 		if (charset && !strcmp(pp->attr, "charset")) {
 		    if (!override) {
-			r->content_type = ap_pstrcat(r->pool, r->content_type,
+			r->content_type = apr_pstrcat(r->pool, r->content_type,
 						     "; charset=", charset,
 						     NULL);
 			override = 1;
 		    }
 		}
 		else {
-		    r->content_type = ap_pstrcat(r->pool, r->content_type,
+		    r->content_type = apr_pstrcat(r->pool, r->content_type,
 						 "; ", pp->attr,
 						 "=", pp->val,
 						 NULL);
@@ -720,7 +720,7 @@ static int find_ct(request_rec *r)
 		pp = pp->next;
 	    }
 	    if (charset && !override) {
-		r->content_type = ap_pstrcat(r->pool, r->content_type,
+		r->content_type = apr_pstrcat(r->pool, r->content_type,
 					     "; charset=", charset,
 					     NULL);
 	    }
@@ -736,8 +736,8 @@ static int find_ct(request_rec *r)
 
         r->content_language = conf->default_language; /* back compat. only */
         if (!r->content_languages)
-            r->content_languages = ap_make_array(r->pool, 2, sizeof(char *));
-        new = (const char **) ap_push_array(r->content_languages);
+            r->content_languages = apr_make_array(r->pool, 2, sizeof(char *));
+        new = (const char **) apr_push_array(r->content_languages);
         *new = conf->default_language;
     }
 
@@ -766,7 +766,7 @@ module MODULE_VAR_EXPORT mime_module = {
     merge_mime_dir_configs,	/* merge per-directory config structures */
     NULL,			/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    mime_cmds,			/* command ap_table_t */
+    mime_cmds,			/* command apr_table_t */
     NULL,			/* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/loggers/mod_log_config.c b/modules/loggers/mod_log_config.c
index 00b5d47..1136a6f 100644
--- a/modules/loggers/mod_log_config.c
+++ b/modules/loggers/mod_log_config.c
@@ -190,7 +190,7 @@
 module MODULE_VAR_EXPORT config_log_module;
 
 static int xfer_flags = (APR_WRITE | APR_APPEND | APR_CREATE);
-static ap_fileperms_t xfer_perms = APR_OS_DEFAULT;
+static apr_fileperms_t xfer_perms = APR_OS_DEFAULT;
 
 /* POSIX.1 defines PIPE_BUF as the maximum number of bytes that is
  * guaranteed to be atomic when writing a pipe.  And PIPE_BUF >= 512
@@ -224,10 +224,10 @@ static ap_fileperms_t xfer_perms = APR_OS_DEFAULT;
 
 typedef struct {
     const char *default_format_string;
-    ap_array_header_t *default_format;
-    ap_array_header_t *config_logs;
-    ap_array_header_t *server_config_logs;
-    ap_table_t *formats;
+    apr_array_header_t *default_format;
+    apr_array_header_t *config_logs;
+    apr_array_header_t *server_config_logs;
+    apr_table_t *formats;
 } multi_log_state;
 
 /*
@@ -242,8 +242,8 @@ typedef struct {
 typedef struct {
     const char *fname;
     const char *format_string;
-    ap_array_header_t *format;
-    ap_file_t *log_fd;
+    apr_array_header_t *format;
+    apr_file_t *log_fd;
     char *condition_var;
 #ifdef BUFFERED_LOGS
     int outcnt;
@@ -263,15 +263,15 @@ typedef struct {
     char *arg;
     int condition_sense;
     int want_orig;
-    ap_array_header_t *conditions;
+    apr_array_header_t *conditions;
 } log_format_item;
 
-static char *format_integer(ap_pool_t *p, int i)
+static char *format_integer(apr_pool_t *p, int i)
 {
-    return ap_psprintf(p, "%d", i);
+    return apr_psprintf(p, "%d", i);
 }
 
-static char *pfmt(ap_pool_t *p, int i)
+static char *pfmt(apr_pool_t *p, int i)
 {
     if (i <= 0) {
         return "-";
@@ -327,7 +327,7 @@ static const char *log_request_line(request_rec *r, char *a)
 	     * (note the truncation before the protocol string for HTTP/0.9 requests)
 	     * (note also that r->the_request contains the unmodified request)
 	     */
-    return (r->parsed_uri.password) ? ap_pstrcat(r->pool, r->method, " ",
+    return (r->parsed_uri.password) ? apr_pstrcat(r->pool, r->method, " ",
 					 ap_unparse_uri_components(r->pool, &r->parsed_uri, 0),
 					 r->assbackwards ? NULL : " ", r->protocol, NULL)
 					: r->the_request;
@@ -354,40 +354,40 @@ static const char *log_bytes_sent(request_rec *r, char *a)
     else {
         long int bs;
         ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
-	return ap_psprintf(r->pool, "%ld", bs);
+	return apr_psprintf(r->pool, "%ld", bs);
     }
 }
 
 static const char *log_header_in(request_rec *r, char *a)
 {
-    return ap_table_get(r->headers_in, a);
+    return apr_table_get(r->headers_in, a);
 }
 
 static const char *log_header_out(request_rec *r, char *a)
 {
-    const char *cp = ap_table_get(r->headers_out, a);
+    const char *cp = apr_table_get(r->headers_out, a);
     if (!strcasecmp(a, "Content-type") && r->content_type) {
         cp = ap_field_noparam(r->pool, r->content_type);
     }
     if (cp) {
         return cp;
     }
-    return ap_table_get(r->err_headers_out, a);
+    return apr_table_get(r->err_headers_out, a);
 }
 
 static const char *log_note(request_rec *r, char *a)
 {
-    return ap_table_get(r->notes, a);
+    return apr_table_get(r->notes, a);
 }
 static const char *log_env_var(request_rec *r, char *a)
 {
-    return ap_table_get(r->subprocess_env, a);
+    return apr_table_get(r->subprocess_env, a);
 }
 
 static const char *log_request_time(request_rec *r, char *a)
 {
     ap_exploded_time_t xt;
-    ap_size_t retcode;
+    apr_size_t retcode;
     char tstr[MAX_STRING_LEN];
 
     /*
@@ -402,12 +402,12 @@ static const char *log_request_time(request_rec *r, char *a)
 	a problem with this, you can set the define.  -djg
     */
 #ifdef I_INSIST_ON_EXTRA_CYCLES_FOR_CLF_COMPLIANCE
-    ap_explode_localtime(&xt, ap_now());
+    apr_explode_localtime(&xt, apr_now());
 #else
-    ap_explode_localtime(&xt, r->request_time);
+    apr_explode_localtime(&xt, r->request_time);
 #endif
     if (a && *a) {              /* Custom format */
-        ap_strftime(tstr, &retcode, MAX_STRING_LEN, a, &xt);
+        apr_strftime(tstr, &retcode, MAX_STRING_LEN, a, &xt);
     }
     else {                      /* CLF format */
 	char sign;
@@ -422,18 +422,18 @@ static const char *log_request_time(request_rec *r, char *a)
 	    sign = '+';
 	}
 
-        ap_snprintf(tstr, sizeof(tstr), "[%02d/%s/%d:%02d:%02d:%02d %c%.2d%.2d]",
+        apr_snprintf(tstr, sizeof(tstr), "[%02d/%s/%d:%02d:%02d:%02d %c%.2d%.2d]",
                 xt.tm_mday, ap_month_snames[xt.tm_mon], xt.tm_year+1900,
                 xt.tm_hour, xt.tm_min, xt.tm_sec,
                 sign, timz / (60*60), timz % (60*60));
     }
 
-    return ap_pstrdup(r->pool, tstr);
+    return apr_pstrdup(r->pool, tstr);
 }
 
 static const char *log_request_duration(request_rec *r, char *a)
 {
-    return ap_psprintf(r->pool, "%lld", (ap_now() - r->request_time) / AP_USEC_PER_SEC);
+    return apr_psprintf(r->pool, "%lld", (apr_now() - r->request_time) / AP_USEC_PER_SEC);
 }
 
 /* These next two routines use the canonical name:port so that log
@@ -446,7 +446,7 @@ static const char *log_virtual_host(request_rec *r, char *a)
 
 static const char *log_server_port(request_rec *r, char *a)
 {
-    return ap_psprintf(r->pool, "%u",
+    return apr_psprintf(r->pool, "%u",
 	r->server->port ? r->server->port : ap_default_port(r));
 }
 
@@ -460,7 +460,7 @@ static const char *log_server_name(request_rec *r, char *a)
 
 static const char *log_child_pid(request_rec *r, char *a)
 {
-    return ap_psprintf(r->pool, "%ld", (long) getpid());
+    return apr_psprintf(r->pool, "%ld", (long) getpid());
 }
 
 /*****************************************************************
@@ -551,7 +551,7 @@ static struct log_item_list *find_log_func(char k)
     return NULL;
 }
 
-static char *parse_log_misc_string(ap_pool_t *p, log_format_item *it,
+static char *parse_log_misc_string(apr_pool_t *p, log_format_item *it,
                                    const char **sa)
 {
     const char *s;
@@ -568,7 +568,7 @@ static char *parse_log_misc_string(ap_pool_t *p, log_format_item *it,
      * This might allocate a few chars extra if there's a backslash
      * escape in the format string.
      */
-    it->arg = ap_palloc(p, s - *sa + 1);
+    it->arg = apr_palloc(p, s - *sa + 1);
 
     d = it->arg;
     s = *sa;
@@ -613,7 +613,7 @@ static char *parse_log_misc_string(ap_pool_t *p, log_format_item *it,
     return NULL;
 }
 
-static char *parse_log_item(ap_pool_t *p, log_format_item *it, const char **sa)
+static char *parse_log_item(apr_pool_t *p, log_format_item *it, const char **sa)
 {
     const char *s = *sa;
 
@@ -671,9 +671,9 @@ static char *parse_log_item(ap_pool_t *p, log_format_item *it, const char **sa)
                 i = i * 10 + (*s) - '0';
             }
             if (!it->conditions) {
-                it->conditions = ap_make_array(p, 4, sizeof(int));
+                it->conditions = apr_make_array(p, 4, sizeof(int));
             }
-            *(int *) ap_push_array(it->conditions) = i;
+            *(int *) apr_push_array(it->conditions) = i;
             break;
 
         default:
@@ -683,7 +683,7 @@ static char *parse_log_item(ap_pool_t *p, log_format_item *it, const char **sa)
 
                 dummy[0] = s[-1];
                 dummy[1] = '\0';
-                return ap_pstrcat(p, "Unrecognized LogFormat directive %",
+                return apr_pstrcat(p, "Unrecognized LogFormat directive %",
                                dummy, NULL);
             }
             it->func = l->func;
@@ -698,20 +698,20 @@ static char *parse_log_item(ap_pool_t *p, log_format_item *it, const char **sa)
     return "Ran off end of LogFormat parsing args to some directive";
 }
 
-static ap_array_header_t *parse_log_string(ap_pool_t *p, const char *s, const char **err)
+static apr_array_header_t *parse_log_string(apr_pool_t *p, const char *s, const char **err)
 {
-    ap_array_header_t *a = ap_make_array(p, 30, sizeof(log_format_item));
+    apr_array_header_t *a = apr_make_array(p, 30, sizeof(log_format_item));
     char *res;
 
     while (*s) {
-        if ((res = parse_log_item(p, (log_format_item *) ap_push_array(a), &s))) {
+        if ((res = parse_log_item(p, (log_format_item *) apr_push_array(a), &s))) {
             *err = res;
             return NULL;
         }
     }
 
     s = APR_EOL_STR;
-    parse_log_item(p, (log_format_item *) ap_push_array(a), &s);
+    parse_log_item(p, (log_format_item *) apr_push_array(a), &s);
     return a;
 }
 
@@ -755,14 +755,14 @@ static const char *process_item(request_rec *r, request_rec *orig,
 static void flush_log(config_log_state *cls)
 {
     if (cls->outcnt && cls->log_fd != NULL) {
-        ap_write(cls->log_fd, cls->outbuf, cls->outcnt);
+        apr_write(cls->log_fd, cls->outbuf, cls->outcnt);
         cls->outcnt = 0;
     }
 }
 #endif
 
 static int config_log_transaction(request_rec *r, config_log_state *cls,
-                                  ap_array_header_t *default_format)
+                                  apr_array_header_t *default_format)
 {
     log_format_item *items;
     char *str, *s;
@@ -770,8 +770,8 @@ static int config_log_transaction(request_rec *r, config_log_state *cls,
     int *strl;
     request_rec *orig;
     int i;
-    ap_ssize_t len = 0;
-    ap_array_header_t *format;
+    apr_ssize_t len = 0;
+    apr_array_header_t *format;
     char *envar;
 
     if (cls->fname == NULL) {
@@ -785,12 +785,12 @@ static int config_log_transaction(request_rec *r, config_log_state *cls,
     if (cls->condition_var != NULL) {
 	envar = cls->condition_var;
 	if (*envar != '!') {
-	    if (ap_table_get(r->subprocess_env, envar) == NULL) {
+	    if (apr_table_get(r->subprocess_env, envar) == NULL) {
 		return DECLINED;
 	    }
 	}
 	else {
-	    if (ap_table_get(r->subprocess_env, &envar[1]) != NULL) {
+	    if (apr_table_get(r->subprocess_env, &envar[1]) != NULL) {
 		return DECLINED;
 	    }
 	}
@@ -798,8 +798,8 @@ static int config_log_transaction(request_rec *r, config_log_state *cls,
 
     format = cls->format ? cls->format : default_format;
 
-    strs = ap_palloc(r->pool, sizeof(char *) * (format->nelts));
-    strl = ap_palloc(r->pool, sizeof(int) * (format->nelts));
+    strs = apr_palloc(r->pool, sizeof(char *) * (format->nelts));
+    strl = apr_palloc(r->pool, sizeof(int) * (format->nelts));
     items = (log_format_item *) format->elts;
 
     orig = r;
@@ -823,12 +823,12 @@ static int config_log_transaction(request_rec *r, config_log_state *cls,
         flush_log(cls);
     }
     if (len >= LOG_BUFSIZE) {
-        str = ap_palloc(r->pool, len + 1);
+        str = apr_palloc(r->pool, len + 1);
         for (i = 0, s = str; i < format->nelts; ++i) {
             memcpy(s, strs[i], strl[i]);
             s += strl[i];
         }
-        ap_write(cls->log_fd, str, len);
+        apr_write(cls->log_fd, str, len);
     }
     else {
         for (i = 0, s = &cls->outbuf[cls->outcnt]; i < format->nelts; ++i) {
@@ -838,14 +838,14 @@ static int config_log_transaction(request_rec *r, config_log_state *cls,
         cls->outcnt += len;
     }
 #else
-    str = ap_palloc(r->pool, len + 1);
+    str = apr_palloc(r->pool, len + 1);
 
     for (i = 0, s = str; i < format->nelts; ++i) {
         memcpy(s, strs[i], strl[i]);
         s += strl[i];
     }
 
-    ap_write(cls->log_fd, str, &len);
+    apr_write(cls->log_fd, str, &len);
 #endif
 
     return OK;
@@ -886,17 +886,17 @@ static int multi_log_transaction(request_rec *r)
  * Module glue...
  */
 
-static void *make_config_log_state(ap_pool_t *p, server_rec *s)
+static void *make_config_log_state(apr_pool_t *p, server_rec *s)
 {
     multi_log_state *mls;
 
-    mls = (multi_log_state *) ap_palloc(p, sizeof(multi_log_state));
-    mls->config_logs = ap_make_array(p, 1, sizeof(config_log_state));
+    mls = (multi_log_state *) apr_palloc(p, sizeof(multi_log_state));
+    mls->config_logs = apr_make_array(p, 1, sizeof(config_log_state));
     mls->default_format_string = NULL;
     mls->default_format = NULL;
     mls->server_config_logs = NULL;
-    mls->formats = ap_make_table(p, 4);
-    ap_table_setn(mls->formats, "CLF", DEFAULT_LOG_FORMAT);
+    mls->formats = apr_make_table(p, 4);
+    apr_table_setn(mls->formats, "CLF", DEFAULT_LOG_FORMAT);
 
     return mls;
 }
@@ -907,7 +907,7 @@ static void *make_config_log_state(ap_pool_t *p, server_rec *s)
  * vhosts inherit any globally-defined format names.
  */
 
-static void *merge_config_log_state(ap_pool_t *p, void *basev, void *addv)
+static void *merge_config_log_state(apr_pool_t *p, void *basev, void *addv)
 {
     multi_log_state *base = (multi_log_state *) basev;
     multi_log_state *add = (multi_log_state *) addv;
@@ -917,7 +917,7 @@ static void *merge_config_log_state(ap_pool_t *p, void *basev, void *addv)
         add->default_format_string = base->default_format_string;
         add->default_format = base->default_format;
     }
-    add->formats = ap_overlay_tables(p, base->formats, add->formats);
+    add->formats = apr_overlay_tables(p, base->formats, add->formats);
 
     return add;
 }
@@ -940,7 +940,7 @@ static const char *log_format(cmd_parms *cmd, void *dummy, const char *fmt,
     if (name != NULL) {
         parse_log_string(cmd->pool, fmt, &err_string);
         if (err_string == NULL) {
-            ap_table_setn(mls->formats, name, fmt);
+            apr_table_setn(mls->formats, name, fmt);
         }
     }
     else {
@@ -959,7 +959,7 @@ static const char *add_custom_log(cmd_parms *cmd, void *dummy, const char *fn,
 						&config_log_module);
     config_log_state *cls;
 
-    cls = (config_log_state *) ap_push_array(mls->config_logs);
+    cls = (config_log_state *) apr_push_array(mls->config_logs);
     cls->condition_var = NULL;
     if (envclause != NULL) {
 	if (strncasecmp(envclause, "env=", 4) != 0) {
@@ -969,7 +969,7 @@ static const char *add_custom_log(cmd_parms *cmd, void *dummy, const char *fn,
 	    || ((envclause[4] == '!') && (envclause[5] == '\0'))) {
 	    return "missing environment variable name";
 	}
-	cls->condition_var = ap_pstrdup(cmd->pool, &envclause[4]);
+	cls->condition_var = apr_pstrdup(cmd->pool, &envclause[4]);
     }
 
     cls->fname = fn;
@@ -1010,11 +1010,11 @@ AP_INIT_TAKE1("CookieLog", set_cookie_log, NULL, RSRC_CONF,
     {NULL}
 };
 
-static config_log_state *open_config_log(server_rec *s, ap_pool_t *p,
+static config_log_state *open_config_log(server_rec *s, apr_pool_t *p,
                                          config_log_state *cls,
-                                         ap_array_header_t *default_format)
+                                         apr_array_header_t *default_format)
 {
-    ap_status_t status;
+    apr_status_t status;
 
     if (cls->log_fd != NULL) {
         return cls;             /* virtual config shared w/main server */
@@ -1035,7 +1035,7 @@ static config_log_state *open_config_log(server_rec *s, ap_pool_t *p,
     }
     else {
         const char *fname = ap_server_root_relative(p, cls->fname);
-        if ((status = ap_open(&cls->log_fd, fname, xfer_flags, xfer_perms, p)) 
+        if ((status = apr_open(&cls->log_fd, fname, xfer_flags, xfer_perms, p)) 
             != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR, status, s,
                          "could not open transfer log file %s.", fname);
@@ -1049,7 +1049,7 @@ static config_log_state *open_config_log(server_rec *s, ap_pool_t *p,
     return cls;
 }
 
-static config_log_state *open_multi_logs(server_rec *s, ap_pool_t *p)
+static config_log_state *open_multi_logs(server_rec *s, apr_pool_t *p)
 {
     int i;
     multi_log_state *mls = ap_get_module_config(s->module_config,
@@ -1059,7 +1059,7 @@ static config_log_state *open_multi_logs(server_rec *s, ap_pool_t *p)
     const char *format;
 
     if (mls->default_format_string) {
-	format = ap_table_get(mls->formats, mls->default_format_string);
+	format = apr_table_get(mls->formats, mls->default_format_string);
 	if (format) {
 	    mls->default_format = parse_log_string(p, format, &dummy);
 	}
@@ -1075,7 +1075,7 @@ static config_log_state *open_multi_logs(server_rec *s, ap_pool_t *p)
             config_log_state *cls = &clsarray[i];
 
 	    if (cls->format_string) {
-		format = ap_table_get(mls->formats, cls->format_string);
+		format = apr_table_get(mls->formats, cls->format_string);
 		if (format) {
 		    cls->format = parse_log_string(p, format, &dummy);
 		}
@@ -1090,7 +1090,7 @@ static config_log_state *open_multi_logs(server_rec *s, ap_pool_t *p)
             config_log_state *cls = &clsarray[i];
 
 	    if (cls->format_string) {
-		format = ap_table_get(mls->formats, cls->format_string);
+		format = apr_table_get(mls->formats, cls->format_string);
 		if (format) {
 		    cls->format = parse_log_string(p, format, &dummy);
 		}
@@ -1103,7 +1103,7 @@ static config_log_state *open_multi_logs(server_rec *s, ap_pool_t *p)
     return NULL;
 }
 
-static void init_config_log(ap_pool_t *pc, ap_pool_t *p, ap_pool_t *pt, server_rec *s)
+static void init_config_log(apr_pool_t *pc, apr_pool_t *p, apr_pool_t *pt, server_rec *s)
 {
     /* First, do "physical" server, which gets default log fd and format
      * for the virtual servers, if they don't override...
@@ -1118,7 +1118,7 @@ static void init_config_log(ap_pool_t *pc, ap_pool_t *p, ap_pool_t *pt, server_r
     }
 #ifdef BUFFERED_LOGS
 	/* Now register the last buffer flush with the cleanup engine */
-	ap_register_cleanup(p , s, flush_all_logs, flush_all_logs);
+	apr_register_cleanup(p , s, flush_all_logs, flush_all_logs);
 #endif
 }
 
@@ -1126,7 +1126,7 @@ static void init_config_log(ap_pool_t *pc, ap_pool_t *p, ap_pool_t *pt, server_r
 static void flush_all_logs(server_rec *s)
 {
     multi_log_state *mls;
-    ap_array_header_t *log_list;
+    apr_array_header_t *log_list;
     config_log_state *clsarray;
     int i;
 
@@ -1162,7 +1162,7 @@ module MODULE_VAR_EXPORT config_log_module =
     NULL,                       /* merge per-dir config */
     make_config_log_state,      /* server config */
     merge_config_log_state,     /* merge server config */
-    config_log_cmds,            /* command ap_table_t */
+    config_log_cmds,            /* command apr_table_t */
     NULL,                       /* handlers */
     register_hooks              /* register hooks */
 };
diff --git a/modules/mappers/mod_actions.c b/modules/mappers/mod_actions.c
index a8db173..7d48fe6 100644
--- a/modules/mappers/mod_actions.c
+++ b/modules/mappers/mod_actions.c
@@ -90,32 +90,32 @@
 #include "util_script.h"
 
 typedef struct {
-    ap_table_t *action_types;       /* Added with Action... */
+    apr_table_t *action_types;       /* Added with Action... */
     const char *scripted[METHODS];   /* Added with Script... */
 } action_dir_config;
 
 module action_module;
 
-static void *create_action_dir_config(ap_pool_t *p, char *dummy)
+static void *create_action_dir_config(apr_pool_t *p, char *dummy)
 {
     action_dir_config *new =
-    (action_dir_config *) ap_palloc(p, sizeof(action_dir_config));
+    (action_dir_config *) apr_palloc(p, sizeof(action_dir_config));
 
-    new->action_types = ap_make_table(p, 4);
+    new->action_types = apr_make_table(p, 4);
     memset(new->scripted, 0, sizeof(new->scripted));
 
     return new;
 }
 
-static void *merge_action_dir_configs(ap_pool_t *p, void *basev, void *addv)
+static void *merge_action_dir_configs(apr_pool_t *p, void *basev, void *addv)
 {
     action_dir_config *base = (action_dir_config *) basev;
     action_dir_config *add = (action_dir_config *) addv;
-    action_dir_config *new = (action_dir_config *) ap_palloc(p,
+    action_dir_config *new = (action_dir_config *) apr_palloc(p,
                                   sizeof(action_dir_config));
     int i;
 
-    new->action_types = ap_overlay_tables(p, add->action_types,
+    new->action_types = apr_overlay_tables(p, add->action_types,
 				       base->action_types);
 
     for (i = 0; i < METHODS; ++i) {
@@ -129,7 +129,7 @@ static const char *add_action(cmd_parms *cmd, void *m_v,
                               const char *type, const char *script)
 {
     action_dir_config *m = (action_dir_config *)m_v;
-    ap_table_setn(m->action_types, type, script);
+    apr_table_setn(m->action_types, type, script);
     return NULL;
 }
 
@@ -190,7 +190,7 @@ static int action_handler(request_rec *r)
 	return DECLINED;
 
     /* Second, check for actions (which override the method scripts) */
-    if ((t = ap_table_get(conf->action_types,
+    if ((t = apr_table_get(conf->action_types,
 		       action ? action : ap_default_type(r)))) {
 	script = t;
 	if (r->finfo.protection == 0) {
@@ -203,7 +203,7 @@ static int action_handler(request_rec *r)
     if (script == NULL)
 	return DECLINED;
 
-    ap_internal_redirect_handler(ap_pstrcat(r->pool, script, ap_escape_uri(r->pool,
+    ap_internal_redirect_handler(apr_pstrcat(r->pool, script, ap_escape_uri(r->pool,
 			  r->uri), r->args ? "?" : NULL, r->args, NULL), r);
     return OK;
 }
@@ -221,7 +221,7 @@ module action_module =
     merge_action_dir_configs,	/* dir merger --- default is to override */
     NULL,			/* server config */
     NULL,			/* merge server config */
-    action_cmds,		/* command ap_table_t */
+    action_cmds,		/* command apr_table_t */
     action_handlers,		/* handlers */
     NULL			/* register hooks */
 };
diff --git a/modules/mappers/mod_alias.c b/modules/mappers/mod_alias.c
index b41dfc6..d01ca91 100644
--- a/modules/mappers/mod_alias.c
+++ b/modules/mappers/mod_alias.c
@@ -82,51 +82,51 @@ typedef struct {
 } alias_entry;
 
 typedef struct {
-    ap_array_header_t *aliases;
-    ap_array_header_t *redirects;
+    apr_array_header_t *aliases;
+    apr_array_header_t *redirects;
 } alias_server_conf;
 
 typedef struct {
-    ap_array_header_t *redirects;
+    apr_array_header_t *redirects;
 } alias_dir_conf;
 
 module MODULE_VAR_EXPORT alias_module;
 
-static void *create_alias_config(ap_pool_t *p, server_rec *s)
+static void *create_alias_config(apr_pool_t *p, server_rec *s)
 {
     alias_server_conf *a =
-    (alias_server_conf *) ap_pcalloc(p, sizeof(alias_server_conf));
+    (alias_server_conf *) apr_pcalloc(p, sizeof(alias_server_conf));
 
-    a->aliases = ap_make_array(p, 20, sizeof(alias_entry));
-    a->redirects = ap_make_array(p, 20, sizeof(alias_entry));
+    a->aliases = apr_make_array(p, 20, sizeof(alias_entry));
+    a->redirects = apr_make_array(p, 20, sizeof(alias_entry));
     return a;
 }
 
-static void *create_alias_dir_config(ap_pool_t *p, char *d)
+static void *create_alias_dir_config(apr_pool_t *p, char *d)
 {
     alias_dir_conf *a =
-    (alias_dir_conf *) ap_pcalloc(p, sizeof(alias_dir_conf));
-    a->redirects = ap_make_array(p, 2, sizeof(alias_entry));
+    (alias_dir_conf *) apr_pcalloc(p, sizeof(alias_dir_conf));
+    a->redirects = apr_make_array(p, 2, sizeof(alias_entry));
     return a;
 }
 
-static void *merge_alias_config(ap_pool_t *p, void *basev, void *overridesv)
+static void *merge_alias_config(apr_pool_t *p, void *basev, void *overridesv)
 {
     alias_server_conf *a =
-    (alias_server_conf *) ap_pcalloc(p, sizeof(alias_server_conf));
+    (alias_server_conf *) apr_pcalloc(p, sizeof(alias_server_conf));
     alias_server_conf *base = (alias_server_conf *) basev, *overrides = (alias_server_conf *) overridesv;
 
-    a->aliases = ap_append_arrays(p, overrides->aliases, base->aliases);
-    a->redirects = ap_append_arrays(p, overrides->redirects, base->redirects);
+    a->aliases = apr_append_arrays(p, overrides->aliases, base->aliases);
+    a->redirects = apr_append_arrays(p, overrides->redirects, base->redirects);
     return a;
 }
 
-static void *merge_alias_dir_config(ap_pool_t *p, void *basev, void *overridesv)
+static void *merge_alias_dir_config(apr_pool_t *p, void *basev, void *overridesv)
 {
     alias_dir_conf *a =
-    (alias_dir_conf *) ap_pcalloc(p, sizeof(alias_dir_conf));
+    (alias_dir_conf *) apr_pcalloc(p, sizeof(alias_dir_conf));
     alias_dir_conf *base = (alias_dir_conf *) basev, *overrides = (alias_dir_conf *) overridesv;
-    a->redirects = ap_append_arrays(p, overrides->redirects, base->redirects);
+    a->redirects = apr_append_arrays(p, overrides->redirects, base->redirects);
     return a;
 }
 
@@ -137,7 +137,7 @@ static const char *add_alias_internal(cmd_parms *cmd, void *dummy,
     server_rec *s = cmd->server;
     alias_server_conf *conf =
     (alias_server_conf *) ap_get_module_config(s->module_config, &alias_module);
-    alias_entry *new = ap_push_array(conf->aliases);
+    alias_entry *new = apr_push_array(conf->aliases);
 
     /* XX r can NOT be relative to DocumentRoot here... compat bug. */
 
@@ -213,9 +213,9 @@ static const char *add_redirect_internal(cmd_parms *cmd,
     }
 
     if (cmd->path)
-	new = ap_push_array(dirconf->redirects);
+	new = apr_push_array(dirconf->redirects);
     else
-	new = ap_push_array(serverconf->redirects);
+	new = apr_push_array(serverconf->redirects);
 
     new->fake = f;
     new->real = url;
@@ -309,7 +309,7 @@ static int alias_matches(const char *uri, const char *alias_fakename)
     return urip - uri;
 }
 
-static char *try_alias_list(request_rec *r, ap_array_header_t *aliases, int doesc, int *status)
+static char *try_alias_list(request_rec *r, apr_array_header_t *aliases, int doesc, int *status)
 {
     alias_entry *entries = (alias_entry *) aliases->elts;
     regmatch_t regm[10];
@@ -331,7 +331,7 @@ static char *try_alias_list(request_rec *r, ap_array_header_t *aliases, int does
 		}
 		else {
 		    /* need something non-null */
-		    found = ap_pstrdup(r->pool, "");
+		    found = apr_pstrdup(r->pool, "");
 		}
 	    }
 	}
@@ -343,17 +343,17 @@ static char *try_alias_list(request_rec *r, ap_array_header_t *aliases, int does
 		    char *escurl;
 		    escurl = ap_os_escape_path(r->pool, r->uri + l, 1);
 
-		    found = ap_pstrcat(r->pool, p->real, escurl, NULL);
+		    found = apr_pstrcat(r->pool, p->real, escurl, NULL);
 		}
 		else
-		    found = ap_pstrcat(r->pool, p->real, r->uri + l, NULL);
+		    found = apr_pstrcat(r->pool, p->real, r->uri + l, NULL);
 	    }
 	}
 
 	if (found) {
 	    if (p->handler) {	/* Set handler, and leave a note for mod_cgi */
 		r->handler = p->handler;
-		ap_table_setn(r->notes, "alias-forced-type", r->handler);
+		apr_table_setn(r->notes, "alias-forced-type", r->handler);
 	    }
 
 	    *status = p->redir_status;
@@ -381,9 +381,9 @@ static int translate_alias_redir(request_rec *r)
 	if (ap_is_HTTP_REDIRECT(status)) {
 	    /* include QUERY_STRING if any */
 	    if (r->args) {
-		ret = ap_pstrcat(r->pool, ret, "?", r->args, NULL);
+		ret = apr_pstrcat(r->pool, ret, "?", r->args, NULL);
 	    }
-	    ap_table_setn(r->headers_out, "Location", ret);
+	    apr_table_setn(r->headers_out, "Location", ret);
 	}
 	return status;
     }
@@ -408,7 +408,7 @@ static int fixup_redir(request_rec *r)
 
     if ((ret = try_alias_list(r, dirconf->redirects, 1, &status)) != NULL) {
 	if (ap_is_HTTP_REDIRECT(status))
-	    ap_table_setn(r->headers_out, "Location", ret);
+	    apr_table_setn(r->headers_out, "Location", ret);
 	return status;
     }
 
@@ -430,7 +430,7 @@ module MODULE_VAR_EXPORT alias_module =
     merge_alias_dir_config,	/* dir merger --- default is to override */
     create_alias_config,	/* server config */
     merge_alias_config,		/* merge server configs */
-    alias_cmds,			/* command ap_table_t */
+    alias_cmds,			/* command apr_table_t */
     NULL,			/* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/mappers/mod_dir.c b/modules/mappers/mod_dir.c
index 7be20b5..791057f 100644
--- a/modules/mappers/mod_dir.c
+++ b/modules/mappers/mod_dir.c
@@ -74,7 +74,7 @@
 module MODULE_VAR_EXPORT dir_module;
 
 typedef struct dir_config_struct {
-    ap_array_header_t *index_names;
+    apr_array_header_t *index_names;
 } dir_config_rec;
 
 #define DIR_CMD_PERMS OR_INDEXES
@@ -84,9 +84,9 @@ static const char *add_index(cmd_parms *cmd, void *dummy, const char *arg)
     dir_config_rec *d = dummy;
 
     if (!d->index_names) {
-	d->index_names = ap_make_array(cmd->pool, 2, sizeof(char *));
+	d->index_names = apr_make_array(cmd->pool, 2, sizeof(char *));
     }
-    *(const char **)ap_push_array(d->index_names) = arg;
+    *(const char **)apr_push_array(d->index_names) = arg;
     return NULL;
 }
 
@@ -97,18 +97,18 @@ static const command_rec dir_cmds[] =
     {NULL}
 };
 
-static void *create_dir_config(ap_pool_t *p, char *dummy)
+static void *create_dir_config(apr_pool_t *p, char *dummy)
 {
     dir_config_rec *new =
-    (dir_config_rec *) ap_pcalloc(p, sizeof(dir_config_rec));
+    (dir_config_rec *) apr_pcalloc(p, sizeof(dir_config_rec));
 
     new->index_names = NULL;
     return (void *) new;
 }
 
-static void *merge_dir_configs(ap_pool_t *p, void *basev, void *addv)
+static void *merge_dir_configs(apr_pool_t *p, void *basev, void *addv)
 {
-    dir_config_rec *new = (dir_config_rec *) ap_pcalloc(p, sizeof(dir_config_rec));
+    dir_config_rec *new = (dir_config_rec *) apr_pcalloc(p, sizeof(dir_config_rec));
     dir_config_rec *base = (dir_config_rec *) basev;
     dir_config_rec *add = (dir_config_rec *) addv;
 
@@ -129,13 +129,13 @@ static int handle_dir(request_rec *r)
     if (r->uri[0] == '\0' || r->uri[strlen(r->uri) - 1] != '/') {
         char *ifile;
         if (r->args != NULL)
-            ifile = ap_pstrcat(r->pool, ap_escape_uri(r->pool, r->uri),
+            ifile = apr_pstrcat(r->pool, ap_escape_uri(r->pool, r->uri),
                             "/", "?", r->args, NULL);
         else
-            ifile = ap_pstrcat(r->pool, ap_escape_uri(r->pool, r->uri),
+            ifile = apr_pstrcat(r->pool, ap_escape_uri(r->pool, r->uri),
                             "/", NULL);
 
-        ap_table_setn(r->headers_out, "Location",
+        apr_table_setn(r->headers_out, "Location",
                   ap_construct_url(r->pool, ifile, r));
         return HTTP_MOVED_PERMANENTLY;
     }
@@ -146,7 +146,7 @@ static int handle_dir(request_rec *r)
      */
 
     if (r->filename[strlen(r->filename) - 1] != '/') {
-        r->filename = ap_pstrcat(r->pool, r->filename, "/", NULL);
+        r->filename = apr_pstrcat(r->pool, r->filename, "/", NULL);
     }
 
     if (d->index_names) {
@@ -167,9 +167,9 @@ static int handle_dir(request_rec *r)
             char *new_uri = ap_escape_uri(r->pool, rr->uri);
 
             if (rr->args != NULL)
-                new_uri = ap_pstrcat(r->pool, new_uri, "?", rr->args, NULL);
+                new_uri = apr_pstrcat(r->pool, new_uri, "?", rr->args, NULL);
             else if (r->args != NULL)
-                new_uri = ap_pstrcat(r->pool, new_uri, "?", r->args, NULL);
+                new_uri = apr_pstrcat(r->pool, new_uri, "?", r->args, NULL);
 
             ap_destroy_sub_req(rr);
             ap_internal_redirect(new_uri, r);
@@ -183,10 +183,10 @@ static int handle_dir(request_rec *r)
 
             ap_pool_join(r->pool, rr->pool);
             error_notfound = rr->status;
-            r->notes = ap_overlay_tables(r->pool, r->notes, rr->notes);
-            r->headers_out = ap_overlay_tables(r->pool, r->headers_out,
+            r->notes = apr_overlay_tables(r->pool, r->notes, rr->notes);
+            r->headers_out = apr_overlay_tables(r->pool, r->headers_out,
                                             rr->headers_out);
-            r->err_headers_out = ap_overlay_tables(r->pool, r->err_headers_out,
+            r->err_headers_out = apr_overlay_tables(r->pool, r->err_headers_out,
                                                 rr->err_headers_out);
             return error_notfound;
         }
@@ -230,7 +230,7 @@ module MODULE_VAR_EXPORT dir_module = {
     merge_dir_configs,		/* merge per-directory config structures */
     NULL,			/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    dir_cmds,			/* command ap_table_t */
+    dir_cmds,			/* command apr_table_t */
     dir_handlers,		/* handlers */
     NULL			/* register hooks */
 };
diff --git a/modules/mappers/mod_imap.c b/modules/mappers/mod_imap.c
index c7fced9..5f0d8e8 100644
--- a/modules/mappers/mod_imap.c
+++ b/modules/mappers/mod_imap.c
@@ -130,10 +130,10 @@ typedef struct {
     char *imap_base;
 } imap_conf_rec;
 
-static void *create_imap_dir_config(ap_pool_t *p, char *dummy)
+static void *create_imap_dir_config(apr_pool_t *p, char *dummy)
 {
     imap_conf_rec *icr =
-    (imap_conf_rec *) ap_palloc(p, sizeof(imap_conf_rec));
+    (imap_conf_rec *) apr_palloc(p, sizeof(imap_conf_rec));
 
     icr->imap_menu = NULL;
     icr->imap_default = NULL;
@@ -142,9 +142,9 @@ static void *create_imap_dir_config(ap_pool_t *p, char *dummy)
     return icr;
 }
 
-static void *merge_imap_dir_configs(ap_pool_t *p, void *basev, void *addv)
+static void *merge_imap_dir_configs(apr_pool_t *p, void *basev, void *addv)
 {
-    imap_conf_rec *new = (imap_conf_rec *) ap_pcalloc(p, sizeof(imap_conf_rec));
+    imap_conf_rec *new = (imap_conf_rec *) apr_pcalloc(p, sizeof(imap_conf_rec));
     imap_conf_rec *base = (imap_conf_rec *) basev;
     imap_conf_rec *add = (imap_conf_rec *) addv;
 
@@ -374,14 +374,14 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
     }
 
     if (!strcasecmp(value, "nocontent") || !strcasecmp(value, "error")) {
-        return ap_pstrdup(r->pool, value);      /* these are handled elsewhere,
+        return apr_pstrdup(r->pool, value);      /* these are handled elsewhere,
                                                 so just copy them */
     }
 
     if (!strcasecmp(value, "referer")) {
-        referer = ap_table_get(r->headers_in, "Referer");
+        referer = apr_table_get(r->headers_in, "Referer");
         if (referer && *referer) {
-	    return ap_pstrdup(r->pool, referer);
+	    return apr_pstrdup(r->pool, referer);
         }
         else {
 	    /* XXX:  This used to do *value = '\0'; ... which is totally bogus
@@ -403,12 +403,12 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
     if (*string_pos_const == ':') {
 	/* if letters and then a colon (like http:) */
 	/* it's an absolute URL, so use it! */
-	return ap_pstrdup(r->pool, value);
+	return apr_pstrdup(r->pool, value);
     }
 
     if (!base || !*base) {
         if (value && *value) {
-	    return ap_pstrdup(r->pool, value); /* no base: use what is given */
+	    return apr_pstrdup(r->pool, value); /* no base: use what is given */
         }
 	/* no base, no value: pick a simple default */
 	return ap_construct_url(r->pool, "/", r);
@@ -421,7 +421,7 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
                     "invalid base directive in map file: %s", r->uri);
         return NULL;
     }
-    my_base = ap_pstrdup(r->pool, base);
+    my_base = apr_pstrdup(r->pool, base);
     string_pos = my_base;
     while (*string_pos) {
         if (*string_pos == '/' && *(string_pos + 1) == '/') {
@@ -493,7 +493,7 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
                                    with '..' */
 
     if (value && *value) {
-	return ap_pstrcat(r->pool, my_base, value, NULL);
+	return apr_pstrcat(r->pool, my_base, value, NULL);
     }
     return my_base;
 }
@@ -510,7 +510,7 @@ static int imap_reply(request_rec *r, char *redirect)
     }
     if (redirect && *redirect) {
         /* must be a URL, so redirect to it */
-        ap_table_setn(r->headers_out, "Location", redirect);
+        apr_table_setn(r->headers_out, "Location", redirect);
         return HTTP_MOVED_TEMPORARILY;
     }
     return HTTP_INTERNAL_SERVER_ERROR;
@@ -617,7 +617,7 @@ static int imap_handler(request_rec *r)
     char *mapdflt;
     char *closest = NULL;
     double closest_yet = -1;
-    ap_status_t status;
+    apr_status_t status;
 
     double testpoint[2];
     double pointarray[MAXVERTS + 1][2];
@@ -847,7 +847,7 @@ static int imap_handler(request_rec *r)
         if (!strcasecmp(directive, "point")) {  /* point */
 
             if (is_closer(testpoint, pointarray, &closest_yet)) {
-		closest = ap_pstrdup(r->pool, value);
+		closest = apr_pstrdup(r->pool, value);
             }
 
             continue;
@@ -916,7 +916,7 @@ module MODULE_VAR_EXPORT imap_module =
     merge_imap_dir_configs,     /* dir merger --- default is to override */
     NULL,                       /* server config */
     NULL,                       /* merge server config */
-    imap_cmds,                  /* command ap_table_t */
+    imap_cmds,                  /* command apr_table_t */
     imap_handlers,              /* handlers */
     NULL                        /* register hooks */
 };
diff --git a/modules/mappers/mod_negotiation.c b/modules/mappers/mod_negotiation.c
index 5dfacdd..f344138 100644
--- a/modules/mappers/mod_negotiation.c
+++ b/modules/mappers/mod_negotiation.c
@@ -87,27 +87,27 @@
  */
 
 typedef struct {
-    ap_array_header_t *language_priority;
+    apr_array_header_t *language_priority;
 } neg_dir_config;
 
 module MODULE_VAR_EXPORT negotiation_module;
 
-static void *create_neg_dir_config(ap_pool_t *p, char *dummy)
+static void *create_neg_dir_config(apr_pool_t *p, char *dummy)
 {
-    neg_dir_config *new = (neg_dir_config *) ap_palloc(p, sizeof(neg_dir_config));
+    neg_dir_config *new = (neg_dir_config *) apr_palloc(p, sizeof(neg_dir_config));
 
-    new->language_priority = ap_make_array(p, 4, sizeof(char *));
+    new->language_priority = apr_make_array(p, 4, sizeof(char *));
     return new;
 }
 
-static void *merge_neg_dir_configs(ap_pool_t *p, void *basev, void *addv)
+static void *merge_neg_dir_configs(apr_pool_t *p, void *basev, void *addv)
 {
     neg_dir_config *base = (neg_dir_config *) basev;
     neg_dir_config *add = (neg_dir_config *) addv;
-    neg_dir_config *new = (neg_dir_config *) ap_palloc(p, sizeof(neg_dir_config));
+    neg_dir_config *new = (neg_dir_config *) apr_palloc(p, sizeof(neg_dir_config));
 
     /* give priority to the config in the subdirectory */
-    new->language_priority = ap_append_arrays(p, add->language_priority,
+    new->language_priority = apr_append_arrays(p, add->language_priority,
                                            base->language_priority);
     return new;
 }
@@ -115,8 +115,8 @@ static void *merge_neg_dir_configs(ap_pool_t *p, void *basev, void *addv)
 static const char *set_language_priority(cmd_parms *cmd, void *n,
 					 const char *lang)
 {
-    ap_array_header_t *arr = ((neg_dir_config *) n)->language_priority;
-    const char **langp = (const char **) ap_push_array(arr);
+    apr_array_header_t *arr = ((neg_dir_config *) n)->language_priority;
+    const char **langp = (const char **) apr_push_array(arr);
 
     *langp = lang;
     return NULL;
@@ -183,7 +183,7 @@ typedef struct var_rec {
     char *mime_type;            /* MUST be lowercase */
     char *file_name;
     const char *content_encoding;
-    ap_array_header_t *content_languages;   /* list of languages for this variant */
+    apr_array_header_t *content_languages;   /* list of languages for this variant */
     char *content_charset;
     char *description;
 
@@ -222,7 +222,7 @@ typedef struct var_rec {
  */
 
 typedef struct {
-    ap_pool_t *pool;
+    apr_pool_t *pool;
     request_rec *r;
     char *dir_name;
     int accept_q;               /* 1 if an Accept item has a q= param */
@@ -231,12 +231,12 @@ typedef struct {
     /* the array pointers below are NULL if the corresponding accept
      * headers are not present
      */
-    ap_array_header_t *accepts;            /* accept_recs */
-    ap_array_header_t *accept_encodings;   /* accept_recs */
-    ap_array_header_t *accept_charsets;    /* accept_recs */
-    ap_array_header_t *accept_langs;       /* accept_recs */
+    apr_array_header_t *accepts;            /* accept_recs */
+    apr_array_header_t *accept_encodings;   /* accept_recs */
+    apr_array_header_t *accept_charsets;    /* accept_recs */
+    apr_array_header_t *accept_langs;       /* accept_recs */
 
-    ap_array_header_t *avail_vars;         /* available variants */
+    apr_array_header_t *avail_vars;         /* available variants */
 
     int count_multiviews_variants;    /* number of variants found on disk */
 
@@ -323,7 +323,7 @@ static void set_vlist_validator(request_rec *r, request_rec *vlistr)
  * enter the values we recognize into the argument accept_rec
  */
 
-static const char *get_entry(ap_pool_t *p, accept_rec *result,
+static const char *get_entry(apr_pool_t *p, accept_rec *result,
                              const char *accept_line)
 {
     result->quality = 1.0f;
@@ -430,18 +430,18 @@ static const char *get_entry(ap_pool_t *p, accept_rec *result,
  * where charset is only valid in Accept.
  */
 
-static ap_array_header_t *do_header_line(ap_pool_t *p, const char *accept_line)
+static apr_array_header_t *do_header_line(apr_pool_t *p, const char *accept_line)
 {
-    ap_array_header_t *accept_recs;
+    apr_array_header_t *accept_recs;
 
     if (!accept_line) {
         return NULL;
     }
 
-    accept_recs = ap_make_array(p, 40, sizeof(accept_rec));
+    accept_recs = apr_make_array(p, 40, sizeof(accept_rec));
 
     while (*accept_line) {
-        accept_rec *new = (accept_rec *) ap_push_array(accept_recs);
+        accept_rec *new = (accept_rec *) apr_push_array(accept_recs);
         accept_line = get_entry(p, new, accept_line);
     }
 
@@ -452,16 +452,16 @@ static ap_array_header_t *do_header_line(ap_pool_t *p, const char *accept_line)
  * return an array containing the languages of this variant
  */
 
-static ap_array_header_t *do_languages_line(ap_pool_t *p, const char **lang_line)
+static apr_array_header_t *do_languages_line(apr_pool_t *p, const char **lang_line)
 {
-    ap_array_header_t *lang_recs = ap_make_array(p, 2, sizeof(char *));
+    apr_array_header_t *lang_recs = apr_make_array(p, 2, sizeof(char *));
 
     if (!lang_line) {
         return lang_recs;
     }
 
     while (**lang_line) {
-        char **new = (char **) ap_push_array(lang_recs);
+        char **new = (char **) apr_push_array(lang_recs);
         *new = ap_get_token(p, lang_line, 0);
         ap_str_tolower(*new);
         if (**lang_line == ',' || **lang_line == ';') {
@@ -480,16 +480,16 @@ static ap_array_header_t *do_languages_line(ap_pool_t *p, const char **lang_line
 static negotiation_state *parse_accept_headers(request_rec *r)
 {
     negotiation_state *new =
-        (negotiation_state *) ap_pcalloc(r->pool, sizeof(negotiation_state));
+        (negotiation_state *) apr_pcalloc(r->pool, sizeof(negotiation_state));
     accept_rec *elts;
-    ap_table_t *hdrs = r->headers_in;
+    apr_table_t *hdrs = r->headers_in;
     int i;
 
     new->pool = r->pool;
     new->r = r;
     new->dir_name = ap_make_dirstr_parent(r->pool, r->filename);
 
-    new->accepts = do_header_line(r->pool, ap_table_get(hdrs, "Accept"));
+    new->accepts = do_header_line(r->pool, apr_table_get(hdrs, "Accept"));
 
     /* calculate new->accept_q value */
     if (new->accepts) {
@@ -503,13 +503,13 @@ static negotiation_state *parse_accept_headers(request_rec *r)
     }
 
     new->accept_encodings =
-        do_header_line(r->pool, ap_table_get(hdrs, "Accept-Encoding"));
+        do_header_line(r->pool, apr_table_get(hdrs, "Accept-Encoding"));
     new->accept_langs =
-        do_header_line(r->pool, ap_table_get(hdrs, "Accept-Language"));
+        do_header_line(r->pool, apr_table_get(hdrs, "Accept-Language"));
     new->accept_charsets =
-        do_header_line(r->pool, ap_table_get(hdrs, "Accept-Charset"));
+        do_header_line(r->pool, apr_table_get(hdrs, "Accept-Charset"));
 
-    new->avail_vars = ap_make_array(r->pool, 40, sizeof(var_rec));
+    new->avail_vars = apr_make_array(r->pool, 40, sizeof(var_rec));
 
     return new;
 }
@@ -517,7 +517,7 @@ static negotiation_state *parse_accept_headers(request_rec *r)
 
 static void parse_negotiate_header(request_rec *r, negotiation_state *neg)
 {
-    const char *negotiate = ap_table_get(r->headers_in, "Negotiate");
+    const char *negotiate = apr_table_get(r->headers_in, "Negotiate");
     char *tok;
     
     /* First, default to no TCN, no Alternates, and the original Apache
@@ -546,7 +546,7 @@ static void parse_negotiate_header(request_rec *r, negotiation_state *neg)
          * they can send the equivalent 'negotiate: trans, trans' instead
          * to avoid triggering the workaround below. 
          */
-        const char *ua = ap_table_get(r->headers_in, "User-Agent");
+        const char *ua = apr_table_get(r->headers_in, "User-Agent");
 
         if (ua && (strncmp(ua, "Lynx", 4) == 0))
             return;
@@ -614,16 +614,16 @@ static void maybe_add_default_accepts(negotiation_state *neg,
     accept_rec *new_accept;
 
     if (!neg->accepts) {
-        neg->accepts = ap_make_array(neg->pool, 4, sizeof(accept_rec));
+        neg->accepts = apr_make_array(neg->pool, 4, sizeof(accept_rec));
 
-        new_accept = (accept_rec *) ap_push_array(neg->accepts);
+        new_accept = (accept_rec *) apr_push_array(neg->accepts);
         
         new_accept->name = "*/*";
         new_accept->quality = 1.0f;
         new_accept->level = 0.0f;
     }    
 
-    new_accept = (accept_rec *) ap_push_array(neg->accepts);
+    new_accept = (accept_rec *) apr_push_array(neg->accepts);
 
     new_accept->name = CGI_MAGIC_TYPE;
     if (neg->use_rvsa) {
@@ -649,7 +649,7 @@ enum header_state {
     header_eof, header_seen, header_sep
 };
 
-static enum header_state get_header_line(char *buffer, int len, ap_file_t *map)
+static enum header_state get_header_line(char *buffer, int len, apr_file_t *map)
 {
     char *buf_end = buffer + len;
     char *cp;
@@ -658,7 +658,7 @@ static enum header_state get_header_line(char *buffer, int len, ap_file_t *map)
     /* Get a noncommented line */
 
     do {
-        if (ap_fgets(buffer, MAX_STRING_LEN, map) != APR_SUCCESS) {
+        if (apr_fgets(buffer, MAX_STRING_LEN, map) != APR_SUCCESS) {
             return header_eof;
         }
     } while (buffer[0] == '#');
@@ -679,10 +679,10 @@ static enum header_state get_header_line(char *buffer, int len, ap_file_t *map)
 
     cp += strlen(cp);
 
-    while (ap_getc(&c, map) != APR_EOF) {
+    while (apr_getc(&c, map) != APR_EOF) {
         if (c == '#') {
             /* Comment line */
-            while (ap_getc(&c, map) != EOF && c != '\n') {
+            while (apr_getc(&c, map) != EOF && c != '\n') {
                 continue;
             }
         }
@@ -693,11 +693,11 @@ static enum header_state get_header_line(char *buffer, int len, ap_file_t *map)
              */
 
             while (c != '\n' && ap_isspace(c)) {
-                if(ap_getc(&c, map) != APR_SUCCESS)
+                if(apr_getc(&c, map) != APR_SUCCESS)
 		    break;
             }
 
-            ap_ungetc(c, map);
+            apr_ungetc(c, map);
 
             if (c == '\n') {
                 return header_seen;     /* Blank line */
@@ -705,7 +705,7 @@ static enum header_state get_header_line(char *buffer, int len, ap_file_t *map)
 
             /* Continuation */
 
-            while (cp < buf_end - 2 && (ap_getc(&c, map)) != EOF && c != '\n') {
+            while (cp < buf_end - 2 && (apr_getc(&c, map)) != EOF && c != '\n') {
                 *cp++ = c;
             }
 
@@ -716,7 +716,7 @@ static enum header_state get_header_line(char *buffer, int len, ap_file_t *map)
 
             /* Line beginning with something other than whitespace */
 
-            ap_ungetc(c, map);
+            apr_ungetc(c, map);
             return header_seen;
         }
     }
@@ -787,8 +787,8 @@ static char *lcase_header_name_return_body(char *header, request_rec *r)
 static int read_type_map(negotiation_state *neg, request_rec *rr)
 {
     request_rec *r = neg->r;
-    ap_file_t *map = NULL;
-    ap_status_t status;
+    apr_file_t *map = NULL;
+    apr_status_t status;
     char buffer[MAX_STRING_LEN];
     enum header_state hstate;
     struct var_rec mime_info;
@@ -797,7 +797,7 @@ static int read_type_map(negotiation_state *neg, request_rec *rr)
     /* We are not using multiviews */
     neg->count_multiviews_variants = 0;
 
-    if ((status = ap_open(&map, rr->filename, APR_READ,
+    if ((status = apr_open(&map, rr->filename, APR_READ,
                 APR_OS_DEFAULT, neg->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
                       "cannot access type map file: %s", rr->filename);
@@ -845,7 +845,7 @@ static int read_type_map(negotiation_state *neg, request_rec *rr)
                 has_content = 1;
             }
             else if (!strncmp(buffer, "description:", 12)) {
-                char *desc = ap_pstrdup(neg->pool, body);
+                char *desc = apr_pstrdup(neg->pool, body);
                 char *cp;
 
                 for (cp = desc; *cp; ++cp) {
@@ -857,7 +857,7 @@ static int read_type_map(negotiation_state *neg, request_rec *rr)
         }
         else {
             if (*mime_info.file_name && has_content) {
-                void *new_var = ap_push_array(neg->avail_vars);
+                void *new_var = apr_push_array(neg->avail_vars);
 
                 memcpy(new_var, (void *) &mime_info, sizeof(var_rec));
             }
@@ -867,7 +867,7 @@ static int read_type_map(negotiation_state *neg, request_rec *rr)
         }
     } while (hstate != header_eof);
 
-    ap_close(map);
+    apr_close(map);
 
     set_vlist_validator(r, rr);
 
@@ -905,8 +905,8 @@ static int read_types_multi(negotiation_state *neg)
 
     char *filp;
     int prefix_len;
-    ap_dir_t *dirp;
-    ap_status_t status;
+    apr_dir_t *dirp;
+    apr_status_t status;
     struct var_rec mime_info;
     struct accept_rec accept_info;
     void *new_var;
@@ -924,17 +924,17 @@ static int read_types_multi(negotiation_state *neg)
     ++filp;
     prefix_len = strlen(filp);
 
-    if ((status = ap_opendir(&dirp, neg->dir_name, neg->pool)) != APR_SUCCESS) {
+    if ((status = apr_opendir(&dirp, neg->dir_name, neg->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
                     "cannot read directory for multi: %s", neg->dir_name);
         return HTTP_FORBIDDEN;
     }
 
-    while (ap_readdir(dirp) == APR_SUCCESS) {
+    while (apr_readdir(dirp) == APR_SUCCESS) {
         request_rec *sub_req;
         char *d_name;
 
-        ap_get_dir_filename(&d_name, dirp);
+        apr_get_dir_filename(&d_name, dirp);
         /* Do we have a match? */
 
         if (strncmp(d_name, filp, prefix_len)) {
@@ -973,7 +973,7 @@ static int read_types_multi(negotiation_state *neg)
             ((sub_req->handler) &&
              !strcmp(sub_req->handler, "type-map"))) {
 
-            ap_closedir(dirp);
+            apr_closedir(dirp);
             neg->avail_vars->nelts = 0;
             if (sub_req->status != HTTP_OK) {
                 return sub_req->status;
@@ -984,7 +984,7 @@ static int read_types_multi(negotiation_state *neg)
         /* Have reasonable variant --- gather notes. */
 
         mime_info.sub_req = sub_req;
-        mime_info.file_name = ap_pstrdup(neg->pool, d_name);
+        mime_info.file_name = apr_pstrdup(neg->pool, d_name);
         if (sub_req->content_encoding) {
             mime_info.content_encoding = sub_req->content_encoding;
         }
@@ -995,7 +995,7 @@ static int read_types_multi(negotiation_state *neg)
         get_entry(neg->pool, &accept_info, sub_req->content_type);
         set_mime_fields(&mime_info, &accept_info);
 
-        new_var = ap_push_array(neg->avail_vars);
+        new_var = apr_push_array(neg->avail_vars);
         memcpy(new_var, (void *) &mime_info, sizeof(var_rec));
 
         neg->count_multiviews_variants++;
@@ -1003,7 +1003,7 @@ static int read_types_multi(negotiation_state *neg)
         clean_var_rec(&mime_info);
     }
 
-    ap_closedir(dirp);
+    apr_closedir(dirp);
 
     set_vlist_validator(r, r);
 
@@ -1155,7 +1155,7 @@ static int level_cmp(var_rec *var1, var_rec *var2)
  * to set lang_index.  
  */
 
-static int find_lang_index(ap_array_header_t *accept_langs, char *lang)
+static int find_lang_index(apr_array_header_t *accept_langs, char *lang)
 {
     accept_rec *accs;
     int i;
@@ -1182,7 +1182,7 @@ static int find_lang_index(ap_array_header_t *accept_langs, char *lang)
 
 static int find_default_index(neg_dir_config *conf, char *lang)
 {
-    ap_array_header_t *arr;
+    apr_array_header_t *arr;
     int nelts;
     char **elts;
     int i;
@@ -1456,13 +1456,13 @@ static void set_language_quality(negotiation_state *neg, var_rec *variant)
 
 static float find_content_length(negotiation_state *neg, var_rec *variant)
 {
-    ap_finfo_t statb;
+    apr_finfo_t statb;
 
     if (variant->bytes == 0) {
         char *fullname = ap_make_full_path(neg->pool, neg->dir_name,
                                            variant->file_name);
 
-        if (ap_stat(&statb, fullname, neg->pool) == APR_SUCCESS) {
+        if (apr_stat(&statb, fullname, neg->pool) == APR_SUCCESS) {
             /* Note, precision may be lost */
             variant->bytes = (float) statb.size;
         }
@@ -1778,7 +1778,7 @@ static int is_variant_better_rvsa(negotiation_state *neg, var_rec *variant,
             (variant->file_name ? variant->file_name : ""),
             (variant->mime_type ? variant->mime_type : ""),
             (variant->content_languages
-             ? ap_array_pstrcat(neg->pool, variant->content_languages, ',')
+             ? apr_array_pstrcat(neg->pool, variant->content_languages, ',')
              : ""),
             variant->source_quality,
             variant->mime_type_quality,
@@ -1848,7 +1848,7 @@ static int is_variant_better(negotiation_state *neg, var_rec *variant,
             (variant->file_name ? variant->file_name : ""),
             (variant->mime_type ? variant->mime_type : ""),
             (variant->content_languages
-             ? ap_array_pstrcat(neg->pool, variant->content_languages, ',')
+             ? apr_array_pstrcat(neg->pool, variant->content_languages, ',')
              : ""),
             variant->source_quality,
             variant->mime_type_quality,
@@ -2048,7 +2048,7 @@ static int best_match(negotiation_state *neg, var_rec **pbest)
 static void set_neg_headers(request_rec *r, negotiation_state *neg,
                             int alg_result)
 {
-    ap_table_t *hdrs;
+    apr_table_t *hdrs;
     var_rec *avail_recs = (var_rec *) neg->avail_vars->elts;
     const char *sample_type = NULL;
     const char *sample_language = NULL;
@@ -2058,7 +2058,7 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
     char *qstr;
     char *lenstr;
     long len;
-    ap_array_header_t *arr;
+    apr_array_header_t *arr;
     int max_vlist_array = (neg->avail_vars->nelts * 21);
     int first_variant = 1;
     int vary_by_type = 0;
@@ -2068,13 +2068,13 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
     int j;
 
     /* In order to avoid O(n^2) memory copies in building Alternates,
-     * we preallocate a ap_table_t with the maximum substrings possible,
+     * we preallocate a apr_table_t with the maximum substrings possible,
      * fill it with the variant list, and then concatenate the entire array.
      * Note that if you change the number of substrings pushed, you also
      * need to change the calculation of max_vlist_array above.
      */
     if (neg->send_alternates && neg->avail_vars->nelts)
-        arr = ap_make_array(r->pool, max_vlist_array, sizeof(char *));
+        arr = apr_make_array(r->pool, max_vlist_array, sizeof(char *));
     else
         arr = NULL;
 
@@ -2087,7 +2087,7 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
         var_rec *variant = &avail_recs[j];
 
         if (variant->content_languages && variant->content_languages->nelts) {
-            lang = ap_array_pstrcat(r->pool, variant->content_languages, ',');
+            lang = apr_array_pstrcat(r->pool, variant->content_languages, ',');
         }
         else {
             lang = NULL;
@@ -2132,12 +2132,12 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
 
         /* Generate the string components for this Alternates entry */
 
-        *((const char **) ap_push_array(arr)) = "{\"";
-        *((const char **) ap_push_array(arr)) = variant->file_name;
-        *((const char **) ap_push_array(arr)) = "\" ";
+        *((const char **) apr_push_array(arr)) = "{\"";
+        *((const char **) apr_push_array(arr)) = variant->file_name;
+        *((const char **) apr_push_array(arr)) = "\" ";
 
-        qstr = (char *) ap_palloc(r->pool, 6);
-        ap_snprintf(qstr, 6, "%1.3f", variant->source_quality);
+        qstr = (char *) apr_palloc(r->pool, 6);
+        apr_snprintf(qstr, 6, "%1.3f", variant->source_quality);
 
         /* Strip trailing zeros (saves those valuable network bytes) */
         if (qstr[4] == '0') {
@@ -2149,29 +2149,29 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
                 }
             }
         }
-        *((const char **) ap_push_array(arr)) = qstr;
+        *((const char **) apr_push_array(arr)) = qstr;
 
         if (variant->mime_type && *variant->mime_type) {
-            *((const char **) ap_push_array(arr)) = " {type ";
-            *((const char **) ap_push_array(arr)) = variant->mime_type;
-            *((const char **) ap_push_array(arr)) = "}";
+            *((const char **) apr_push_array(arr)) = " {type ";
+            *((const char **) apr_push_array(arr)) = variant->mime_type;
+            *((const char **) apr_push_array(arr)) = "}";
         }
         if (variant->content_charset && *variant->content_charset) {
-            *((const char **) ap_push_array(arr)) = " {charset ";
-            *((const char **) ap_push_array(arr)) = variant->content_charset;
-            *((const char **) ap_push_array(arr)) = "}";
+            *((const char **) apr_push_array(arr)) = " {charset ";
+            *((const char **) apr_push_array(arr)) = variant->content_charset;
+            *((const char **) apr_push_array(arr)) = "}";
         }
         if (lang) {
-            *((const char **) ap_push_array(arr)) = " {language ";
-            *((const char **) ap_push_array(arr)) = lang;
-            *((const char **) ap_push_array(arr)) = "}";
+            *((const char **) apr_push_array(arr)) = " {language ";
+            *((const char **) apr_push_array(arr)) = lang;
+            *((const char **) apr_push_array(arr)) = "}";
         }
         if (variant->content_encoding && *variant->content_encoding) {
             /* Strictly speaking, this is non-standard, but so is TCN */
 
-            *((const char **) ap_push_array(arr)) = " {encoding ";
-            *((const char **) ap_push_array(arr)) = variant->content_encoding;
-            *((const char **) ap_push_array(arr)) = "}";
+            *((const char **) apr_push_array(arr)) = " {encoding ";
+            *((const char **) apr_push_array(arr)) = variant->content_encoding;
+            *((const char **) apr_push_array(arr)) = "}";
         }
 
         /* Note that the Alternates specification (in rfc2295) does
@@ -2192,27 +2192,27 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
         if (!(variant->sub_req && variant->sub_req->handler)
             && (len = find_content_length(neg, variant)) != 0) {
 
-            lenstr = (char *) ap_palloc(r->pool, 22);
-            ap_snprintf(lenstr, 22, "%ld", len);
-            *((const char **) ap_push_array(arr)) = " {length ";
-            *((const char **) ap_push_array(arr)) = lenstr;
-            *((const char **) ap_push_array(arr)) = "}";
+            lenstr = (char *) apr_palloc(r->pool, 22);
+            apr_snprintf(lenstr, 22, "%ld", len);
+            *((const char **) apr_push_array(arr)) = " {length ";
+            *((const char **) apr_push_array(arr)) = lenstr;
+            *((const char **) apr_push_array(arr)) = "}";
         }
       
-        *((const char **) ap_push_array(arr)) = "}";
-        *((const char **) ap_push_array(arr)) = ", "; /* trimmed below */
+        *((const char **) apr_push_array(arr)) = "}";
+        *((const char **) apr_push_array(arr)) = ", "; /* trimmed below */
     }
 
     if (neg->send_alternates && neg->avail_vars->nelts) {
         arr->nelts--;                                 /* remove last comma */
-        ap_table_mergen(hdrs, "Alternates",
-                        ap_array_pstrcat(r->pool, arr, '\0'));
+        apr_table_mergen(hdrs, "Alternates",
+                        apr_array_pstrcat(r->pool, arr, '\0'));
     } 
 
     if (neg->is_transparent || vary_by_type || vary_by_language ||
         vary_by_language || vary_by_charset || vary_by_encoding) {
 
-        ap_table_mergen(hdrs, "Vary", 2 + ap_pstrcat(r->pool,
+        apr_table_mergen(hdrs, "Vary", 2 + apr_pstrcat(r->pool,
             neg->is_transparent ? ", negotiate"       : "",
             vary_by_type        ? ", accept"          : "",
             vary_by_language    ? ", accept-language" : "",
@@ -2221,7 +2221,7 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
     }
 
     if (neg->is_transparent) { /* Create TCN response header */
-        ap_table_setn(hdrs, "TCN",
+        apr_table_setn(hdrs, "TCN",
                       alg_result == alg_list ? "list" : "choice");
     }
 }
@@ -2234,22 +2234,22 @@ static void set_neg_headers(request_rec *r, negotiation_state *neg,
 
 static char *make_variant_list(request_rec *r, negotiation_state *neg)
 {
-    ap_array_header_t *arr;
+    apr_array_header_t *arr;
     int i;
     int max_vlist_array = (neg->avail_vars->nelts * 15) + 2;
 
     /* In order to avoid O(n^2) memory copies in building the list,
-     * we preallocate a ap_table_t with the maximum substrings possible,
+     * we preallocate a apr_table_t with the maximum substrings possible,
      * fill it with the variant list, and then concatenate the entire array.
      */
-    arr = ap_make_array(r->pool, max_vlist_array, sizeof(char *));
+    arr = apr_make_array(r->pool, max_vlist_array, sizeof(char *));
 
-    *((const char **) ap_push_array(arr)) = "Available variants:\n<ul>\n";
+    *((const char **) apr_push_array(arr)) = "Available variants:\n<ul>\n";
 
     for (i = 0; i < neg->avail_vars->nelts; ++i) {
         var_rec *variant = &((var_rec *) neg->avail_vars->elts)[i];
         char *filename = variant->file_name ? variant->file_name : "";
-        ap_array_header_t *languages = variant->content_languages;
+        apr_array_header_t *languages = variant->content_languages;
         char *description = variant->description ? variant->description : "";
 
         /* The format isn't very neat, and it would be nice to make
@@ -2257,44 +2257,44 @@ static char *make_variant_list(request_rec *r, negotiation_state *neg)
          * Note that if you change the number of substrings pushed, you also
          * need to change the calculation of max_vlist_array above.
          */
-        *((const char **) ap_push_array(arr)) = "<li><a href=\"";
-        *((const char **) ap_push_array(arr)) = filename;
-        *((const char **) ap_push_array(arr)) = "\">";
-        *((const char **) ap_push_array(arr)) = filename;
-        *((const char **) ap_push_array(arr)) = "</a> ";
-        *((const char **) ap_push_array(arr)) = description;
+        *((const char **) apr_push_array(arr)) = "<li><a href=\"";
+        *((const char **) apr_push_array(arr)) = filename;
+        *((const char **) apr_push_array(arr)) = "\">";
+        *((const char **) apr_push_array(arr)) = filename;
+        *((const char **) apr_push_array(arr)) = "</a> ";
+        *((const char **) apr_push_array(arr)) = description;
 
         if (variant->mime_type && *variant->mime_type) {
-            *((const char **) ap_push_array(arr)) = ", type ";
-            *((const char **) ap_push_array(arr)) = variant->mime_type;
+            *((const char **) apr_push_array(arr)) = ", type ";
+            *((const char **) apr_push_array(arr)) = variant->mime_type;
         }
         if (languages && languages->nelts) {
-            *((const char **) ap_push_array(arr)) = ", language ";
-            *((const char **) ap_push_array(arr)) = ap_array_pstrcat(r->pool,
+            *((const char **) apr_push_array(arr)) = ", language ";
+            *((const char **) apr_push_array(arr)) = apr_array_pstrcat(r->pool,
                                                        languages, ',');
         }
         if (variant->content_charset && *variant->content_charset) {
-            *((const char **) ap_push_array(arr)) = ", charset ";
-            *((const char **) ap_push_array(arr)) = variant->content_charset;
+            *((const char **) apr_push_array(arr)) = ", charset ";
+            *((const char **) apr_push_array(arr)) = variant->content_charset;
         }
         if (variant->content_encoding) {
-            *((const char **) ap_push_array(arr)) = ", encoding ";
-            *((const char **) ap_push_array(arr)) = variant->content_encoding;
+            *((const char **) apr_push_array(arr)) = ", encoding ";
+            *((const char **) apr_push_array(arr)) = variant->content_encoding;
         }
-        *((const char **) ap_push_array(arr)) = "\n";
+        *((const char **) apr_push_array(arr)) = "\n";
     }
-    *((const char **) ap_push_array(arr)) = "</ul>\n";
+    *((const char **) apr_push_array(arr)) = "</ul>\n";
 
-    return ap_array_pstrcat(r->pool, arr, '\0');
+    return apr_array_pstrcat(r->pool, arr, '\0');
 }
 
 static void store_variant_list(request_rec *r, negotiation_state *neg)
 {
     if (r->main == NULL) {
-        ap_table_setn(r->notes, "variant-list", make_variant_list(r, neg));
+        apr_table_setn(r->notes, "variant-list", make_variant_list(r, neg));
     }
     else {
-        ap_table_setn(r->main->notes, "variant-list",
+        apr_table_setn(r->main->notes, "variant-list",
                       make_variant_list(r->main, neg));
     }
 }
@@ -2318,7 +2318,7 @@ static int setup_choice_response(request_rec *r, negotiation_state *neg,
         status = sub_req->status;
 
         if (status != HTTP_OK && 
-            !ap_table_get(sub_req->err_headers_out, "TCN")) {
+            !apr_table_get(sub_req->err_headers_out, "TCN")) {
             ap_destroy_sub_req(sub_req);
             return status;
         }
@@ -2351,7 +2351,7 @@ static int setup_choice_response(request_rec *r, negotiation_state *neg,
      * for this type of recursive negotiation too.
      */
     if (neg->is_transparent &&
-        ap_table_get(sub_req->err_headers_out, "TCN")) {
+        apr_table_get(sub_req->err_headers_out, "TCN")) {
         return HTTP_VARIANT_ALSO_VARIES;
     }
 
@@ -2394,19 +2394,19 @@ static int setup_choice_response(request_rec *r, negotiation_state *neg,
      * problems if a CGI returns an Etag header which also need to be
      * fixed.
      */
-    if ((sub_vary = ap_table_get(sub_req->err_headers_out, "Vary")) != NULL) {
-        ap_table_setn(r->err_headers_out, "Variant-Vary", sub_vary);
+    if ((sub_vary = apr_table_get(sub_req->err_headers_out, "Vary")) != NULL) {
+        apr_table_setn(r->err_headers_out, "Variant-Vary", sub_vary);
 
         /* Move the subreq Vary header into the main request to
          * prevent having two Vary headers in the response, which
          * would be legal but strange.
          */
-        ap_table_setn(r->err_headers_out, "Vary", sub_vary);
-        ap_table_unset(sub_req->err_headers_out, "Vary");
+        apr_table_setn(r->err_headers_out, "Vary", sub_vary);
+        apr_table_unset(sub_req->err_headers_out, "Vary");
     }
     
-    ap_table_setn(r->err_headers_out, "Content-Location",
-                  ap_pstrdup(r->pool, variant->file_name));
+    apr_table_setn(r->err_headers_out, "Content-Location",
+                  apr_pstrdup(r->pool, variant->file_name));
 
     set_neg_headers(r, neg, alg_choice);         /* add Alternates and Vary */
 
@@ -2579,7 +2579,7 @@ static int handle_map_file(request_rec *r)
     }
     udir = ap_make_dirstr_parent(r->pool, r->uri);
     udir = ap_escape_uri(r->pool, udir);
-    ap_internal_redirect(ap_pstrcat(r->pool, udir, best->file_name,
+    ap_internal_redirect(apr_pstrcat(r->pool, udir, best->file_name,
                                     r->path_info, NULL), r);
     return OK;
 }
@@ -2659,12 +2659,12 @@ static int handle_multi(request_rec *r)
     r->finfo = sub_req->finfo;
     r->per_dir_config = sub_req->per_dir_config;
     /* copy output headers from subrequest, but leave negotiation headers */
-    r->notes = ap_overlay_tables(r->pool, sub_req->notes, r->notes);
-    r->headers_out = ap_overlay_tables(r->pool, sub_req->headers_out,
+    r->notes = apr_overlay_tables(r->pool, sub_req->notes, r->notes);
+    r->headers_out = apr_overlay_tables(r->pool, sub_req->headers_out,
                                     r->headers_out);
-    r->err_headers_out = ap_overlay_tables(r->pool, sub_req->err_headers_out,
+    r->err_headers_out = apr_overlay_tables(r->pool, sub_req->err_headers_out,
                                         r->err_headers_out);
-    r->subprocess_env = ap_overlay_tables(r->pool, sub_req->subprocess_env,
+    r->subprocess_env = apr_overlay_tables(r->pool, sub_req->subprocess_env,
                                        r->subprocess_env);
     avail_recs = (var_rec *) neg->avail_vars->elts;
     for (j = 0; j < neg->avail_vars->nelts; ++j) {
@@ -2695,7 +2695,7 @@ static int fix_encoding(request_rec *r)
 {
     const char *enc = r->content_encoding;
     char *x_enc = NULL;
-    ap_array_header_t *accept_encodings;
+    apr_array_header_t *accept_encodings;
     accept_rec *accept_recs;
     int i;
 
@@ -2708,7 +2708,7 @@ static int fix_encoding(request_rec *r)
     }
 
     if ((accept_encodings = do_header_line(r->pool,
-             ap_table_get(r->headers_in, "Accept-Encoding"))) == NULL) {
+             apr_table_get(r->headers_in, "Accept-Encoding"))) == NULL) {
         return DECLINED;
     }
 
@@ -2755,7 +2755,7 @@ module MODULE_VAR_EXPORT negotiation_module =
     merge_neg_dir_configs,      /* dir merger --- default is to override */
     NULL,                       /* server config */
     NULL,                       /* merge server config */
-    negotiation_cmds,           /* command ap_table_t */
+    negotiation_cmds,           /* command apr_table_t */
     negotiation_handlers,       /* handlers */
     register_hooks              /* register hooks */
 };
diff --git a/modules/mappers/mod_rewrite.c b/modules/mappers/mod_rewrite.c
index e295df7..b787d65 100644
--- a/modules/mappers/mod_rewrite.c
+++ b/modules/mappers/mod_rewrite.c
@@ -180,7 +180,7 @@
      * MODULE-DEFINITION-END
      */
 
-    /* the ap_table_t of commands we provide */
+    /* the apr_table_t of commands we provide */
 static const command_rec command_table[] = {
     { "RewriteEngine",   cmd_rewriteengine,   NULL, OR_FILEINFO, FLAG,
       "On or Off to enable or disable (default) the whole rewriting engine" },
@@ -204,7 +204,7 @@ static const command_rec command_table[] = {
     { NULL }
 };
 
-    /* the ap_table_t of content handlers we provide */
+    /* the apr_table_t of content handlers we provide */
 static const handler_rec handler_table[] = {
     { "redirect-handler", handler_redirect },
     { NULL }
@@ -227,7 +227,7 @@ module MODULE_VAR_EXPORT rewrite_module = {
    config_perdir_merge,         /* merge  per-dir    config structures */
    config_server_create,        /* create per-server config structures */
    config_server_merge,         /* merge  per-server config structures */
-   command_table,               /* ap_table_t of config file commands  */
+   command_table,               /* apr_table_t of config file commands  */
    handler_table,               /* [#8] MIME-typed-dispatched handlers */
    register_hooks               /* register hooks                      */
 };
@@ -240,8 +240,8 @@ static int proxy_available;
 static int once_through = 0;
 
 static const char *lockname;
-static ap_lock_t *rewrite_map_lock = NULL;
-static ap_lock_t *rewrite_log_lock = NULL;
+static apr_lock_t *rewrite_mapr_lock = NULL;
+static apr_lock_t *rewrite_log_lock = NULL;
 
 /*
 ** +-------------------------------------------------------+
@@ -257,30 +257,30 @@ static ap_lock_t *rewrite_log_lock = NULL;
 **
 */
 
-static void *config_server_create(ap_pool_t *p, server_rec *s)
+static void *config_server_create(apr_pool_t *p, server_rec *s)
 {
     rewrite_server_conf *a;
 
-    a = (rewrite_server_conf *)ap_pcalloc(p, sizeof(rewrite_server_conf));
+    a = (rewrite_server_conf *)apr_pcalloc(p, sizeof(rewrite_server_conf));
 
     a->state           = ENGINE_DISABLED;
     a->options         = OPTION_NONE;
     a->rewritelogfile  = NULL;
     a->rewritelogfp    = NULL;
     a->rewriteloglevel = 0;
-    a->rewritemaps     = ap_make_array(p, 2, sizeof(rewritemap_entry));
-    a->rewriteconds    = ap_make_array(p, 2, sizeof(rewritecond_entry));
-    a->rewriterules    = ap_make_array(p, 2, sizeof(rewriterule_entry));
+    a->rewritemaps     = apr_make_array(p, 2, sizeof(rewritemap_entry));
+    a->rewriteconds    = apr_make_array(p, 2, sizeof(rewritecond_entry));
+    a->rewriterules    = apr_make_array(p, 2, sizeof(rewriterule_entry));
     a->server          = s;
 
     return (void *)a;
 }
 
-static void *config_server_merge(ap_pool_t *p, void *basev, void *overridesv)
+static void *config_server_merge(apr_pool_t *p, void *basev, void *overridesv)
 {
     rewrite_server_conf *a, *base, *overrides;
 
-    a         = (rewrite_server_conf *)ap_pcalloc(p, sizeof(rewrite_server_conf));
+    a         = (rewrite_server_conf *)apr_pcalloc(p, sizeof(rewrite_server_conf));
     base      = (rewrite_server_conf *)basev;
     overrides = (rewrite_server_conf *)overridesv;
 
@@ -302,11 +302,11 @@ static void *config_server_merge(ap_pool_t *p, void *basev, void *overridesv)
         a->rewritelogfp    = overrides->rewritelogfp != NULL 
                              ? overrides->rewritelogfp 
                              : base->rewritelogfp;
-        a->rewritemaps     = ap_append_arrays(p, overrides->rewritemaps,
+        a->rewritemaps     = apr_append_arrays(p, overrides->rewritemaps,
                                               base->rewritemaps);
-        a->rewriteconds    = ap_append_arrays(p, overrides->rewriteconds,
+        a->rewriteconds    = apr_append_arrays(p, overrides->rewriteconds,
                                               base->rewriteconds);
-        a->rewriterules    = ap_append_arrays(p, overrides->rewriterules,
+        a->rewriterules    = apr_append_arrays(p, overrides->rewriterules,
                                               base->rewriterules);
     }
     else {
@@ -332,17 +332,17 @@ static void *config_server_merge(ap_pool_t *p, void *basev, void *overridesv)
 **
 */
 
-static void *config_perdir_create(ap_pool_t *p, char *path)
+static void *config_perdir_create(apr_pool_t *p, char *path)
 {
     rewrite_perdir_conf *a;
 
-    a = (rewrite_perdir_conf *)ap_pcalloc(p, sizeof(rewrite_perdir_conf));
+    a = (rewrite_perdir_conf *)apr_pcalloc(p, sizeof(rewrite_perdir_conf));
 
     a->state           = ENGINE_DISABLED;
     a->options         = OPTION_NONE;
     a->baseurl         = NULL;
-    a->rewriteconds    = ap_make_array(p, 2, sizeof(rewritecond_entry));
-    a->rewriterules    = ap_make_array(p, 2, sizeof(rewriterule_entry));
+    a->rewriteconds    = apr_make_array(p, 2, sizeof(rewritecond_entry));
+    a->rewriterules    = apr_make_array(p, 2, sizeof(rewriterule_entry));
 
     if (path == NULL) {
         a->directory = NULL;
@@ -350,21 +350,21 @@ static void *config_perdir_create(ap_pool_t *p, char *path)
     else {
         /* make sure it has a trailing slash */
         if (path[strlen(path)-1] == '/') {
-            a->directory = ap_pstrdup(p, path);
+            a->directory = apr_pstrdup(p, path);
         }
         else {
-            a->directory = ap_pstrcat(p, path, "/", NULL);
+            a->directory = apr_pstrcat(p, path, "/", NULL);
         }
     }
 
     return (void *)a;
 }
 
-static void *config_perdir_merge(ap_pool_t *p, void *basev, void *overridesv)
+static void *config_perdir_merge(apr_pool_t *p, void *basev, void *overridesv)
 {
     rewrite_perdir_conf *a, *base, *overrides;
 
-    a         = (rewrite_perdir_conf *)ap_pcalloc(p,
+    a         = (rewrite_perdir_conf *)apr_pcalloc(p,
                                                   sizeof(rewrite_perdir_conf));
     base      = (rewrite_perdir_conf *)basev;
     overrides = (rewrite_perdir_conf *)overridesv;
@@ -375,9 +375,9 @@ static void *config_perdir_merge(ap_pool_t *p, void *basev, void *overridesv)
     a->baseurl   = overrides->baseurl;
 
     if (a->options & OPTION_INHERIT) {
-        a->rewriteconds = ap_append_arrays(p, overrides->rewriteconds,
+        a->rewriteconds = apr_append_arrays(p, overrides->rewriteconds,
                                            base->rewriteconds);
-        a->rewriterules = ap_append_arrays(p, overrides->rewriterules,
+        a->rewriterules = apr_append_arrays(p, overrides->rewriterules,
                                            base->rewriterules);
     }
     else {
@@ -435,14 +435,14 @@ static const char *cmd_rewriteoptions(cmd_parms *cmd,
     return err;
 }
 
-static const char *cmd_rewriteoptions_setoption(ap_pool_t *p, int *options,
+static const char *cmd_rewriteoptions_setoption(apr_pool_t *p, int *options,
                                                 char *name)
 {
     if (strcasecmp(name, "inherit") == 0) {
         *options |= OPTION_INHERIT;
     }
     else {
-        return ap_pstrcat(p, "RewriteOptions: unknown option '",
+        return apr_pstrcat(p, "RewriteOptions: unknown option '",
                           name, "'", NULL);
     }
     return NULL;
@@ -477,12 +477,12 @@ static const char *cmd_rewritemap(cmd_parms *cmd, void *dconf, char *a1,
 {
     rewrite_server_conf *sconf;
     rewritemap_entry *newmap;
-    ap_finfo_t st;
+    apr_finfo_t st;
 
     sconf = (rewrite_server_conf *)
             ap_get_module_config(cmd->server->module_config, &rewrite_module);
 
-    newmap = ap_push_array(sconf->rewritemaps);
+    newmap = apr_push_array(sconf->rewritemaps);
 
     newmap->name = a1;
     newmap->func = NULL;
@@ -500,9 +500,9 @@ static const char *cmd_rewritemap(cmd_parms *cmd, void *dconf, char *a1,
 #ifndef NO_DBM_REWRITEMAP
         newmap->type      = MAPTYPE_DBM;
         newmap->datafile  = a2+4;
-        newmap->checkfile = ap_pstrcat(cmd->pool, a2+4, NDBM_FILE_SUFFIX, NULL);
+        newmap->checkfile = apr_pstrcat(cmd->pool, a2+4, NDBM_FILE_SUFFIX, NULL);
 #else
-        return ap_pstrdup(cmd->pool, "RewriteMap: cannot use NDBM mapfile, "
+        return apr_pstrdup(cmd->pool, "RewriteMap: cannot use NDBM mapfile, "
                           "because no NDBM support is compiled in");
 #endif
     }
@@ -528,7 +528,7 @@ static const char *cmd_rewritemap(cmd_parms *cmd, void *dconf, char *a1,
             newmap->func = rewrite_mapfunc_unescape;
         }
         else if (sconf->state == ENGINE_ENABLED) {
-            return ap_pstrcat(cmd->pool, "RewriteMap: internal map not found:",
+            return apr_pstrcat(cmd->pool, "RewriteMap: internal map not found:",
                               a2+4, NULL);
         }
     }
@@ -541,8 +541,8 @@ static const char *cmd_rewritemap(cmd_parms *cmd, void *dconf, char *a1,
     newmap->fpout = NULL;
 
     if (newmap->checkfile && (sconf->state == ENGINE_ENABLED)
-        && (ap_stat(&st, newmap->checkfile, cmd->pool) != APR_SUCCESS)) {
-        return ap_pstrcat(cmd->pool,
+        && (apr_stat(&st, newmap->checkfile, cmd->pool) != APR_SUCCESS)) {
+        return apr_pstrcat(cmd->pool,
                           "RewriteMap: map file or program not found:",
                           newmap->checkfile, NULL);
     }
@@ -598,20 +598,20 @@ static const char *cmd_rewritecond(cmd_parms *cmd, rewrite_perdir_conf *dconf,
 
     /*  make a new entry in the internal temporary rewrite rule list */
     if (cmd->path == NULL) {   /* is server command */
-        newcond = ap_push_array(sconf->rewriteconds);
+        newcond = apr_push_array(sconf->rewriteconds);
     }
     else {                     /* is per-directory command */
-        newcond = ap_push_array(dconf->rewriteconds);
+        newcond = apr_push_array(dconf->rewriteconds);
     }
 
     /*  parse the argument line ourself */
     if (parseargline(str, &a1, &a2, &a3)) {
-        return ap_pstrcat(cmd->pool, "RewriteCond: bad argument line '", str,
+        return apr_pstrcat(cmd->pool, "RewriteCond: bad argument line '", str,
                           "'", NULL);
     }
 
     /*  arg1: the input string */
-    newcond->input = ap_pstrdup(cmd->pool, a1);
+    newcond->input = apr_pstrdup(cmd->pool, a1);
 
     /* arg3: optional flags field
        (this have to be first parsed, because we need to
@@ -643,18 +643,18 @@ static const char *cmd_rewritecond(cmd_parms *cmd, rewrite_perdir_conf *dconf,
         rc = ((regexp = ap_pregcomp(cmd->pool, cp, REG_EXTENDED)) == NULL);
     }
     if (rc) {
-        return ap_pstrcat(cmd->pool,
+        return apr_pstrcat(cmd->pool,
                           "RewriteCond: cannot compile regular expression '",
                           a2, "'", NULL);
     }
 
-    newcond->pattern = ap_pstrdup(cmd->pool, cp);
+    newcond->pattern = apr_pstrdup(cmd->pool, cp);
     newcond->regexp  = regexp;
 
     return NULL;
 }
 
-static const char *cmd_rewritecond_parseflagfield(ap_pool_t *p,
+static const char *cmd_rewritecond_parseflagfield(apr_pool_t *p,
                                                   rewritecond_entry *cfg,
                                                   char *str)
 {
@@ -706,7 +706,7 @@ static const char *cmd_rewritecond_parseflagfield(ap_pool_t *p,
     return NULL;
 }
 
-static const char *cmd_rewritecond_setflag(ap_pool_t *p, rewritecond_entry *cfg,
+static const char *cmd_rewritecond_setflag(apr_pool_t *p, rewritecond_entry *cfg,
                                            char *key, char *val)
 {
     if (   strcasecmp(key, "nocase") == 0
@@ -718,7 +718,7 @@ static const char *cmd_rewritecond_setflag(ap_pool_t *p, rewritecond_entry *cfg,
         cfg->flags |= CONDFLAG_ORNEXT;
     }
     else {
-        return ap_pstrcat(p, "RewriteCond: unknown flag '", key, "'", NULL);
+        return apr_pstrcat(p, "RewriteCond: unknown flag '", key, "'", NULL);
     }
     return NULL;
 }
@@ -741,15 +741,15 @@ static const char *cmd_rewriterule(cmd_parms *cmd, rewrite_perdir_conf *dconf,
 
     /*  make a new entry in the internal rewrite rule list */
     if (cmd->path == NULL) {   /* is server command */
-        newrule = ap_push_array(sconf->rewriterules);
+        newrule = apr_push_array(sconf->rewriterules);
     }
     else {                     /* is per-directory command */
-        newrule = ap_push_array(dconf->rewriterules);
+        newrule = apr_push_array(dconf->rewriterules);
     }
 
     /*  parse the argument line ourself */
     if (parseargline(str, &a1, &a2, &a3)) {
-        return ap_pstrcat(cmd->pool, "RewriteRule: bad argument line '", str,
+        return apr_pstrcat(cmd->pool, "RewriteRule: bad argument line '", str,
                           "'", NULL);
     }
 
@@ -779,18 +779,18 @@ static const char *cmd_rewriterule(cmd_parms *cmd, rewrite_perdir_conf *dconf,
         mode |= REG_ICASE;
     }
     if ((regexp = ap_pregcomp(cmd->pool, cp, mode)) == NULL) {
-        return ap_pstrcat(cmd->pool,
+        return apr_pstrcat(cmd->pool,
                           "RewriteRule: cannot compile regular expression '",
                           a1, "'", NULL);
     }
-    newrule->pattern = ap_pstrdup(cmd->pool, cp);
+    newrule->pattern = apr_pstrdup(cmd->pool, cp);
     newrule->regexp  = regexp;
 
     /*  arg2: the output string
      *  replace the $<N> by \<n> which is needed by the currently
      *  used Regular Expression library
      */
-    newrule->output = ap_pstrdup(cmd->pool, a2);
+    newrule->output = apr_pstrdup(cmd->pool, a2);
 
     /* now, if the server or per-dir config holds an
      * array of RewriteCond entries, we take it for us
@@ -798,19 +798,19 @@ static const char *cmd_rewriterule(cmd_parms *cmd, rewrite_perdir_conf *dconf,
      */
     if (cmd->path == NULL) {  /* is server command */
         newrule->rewriteconds   = sconf->rewriteconds;
-        sconf->rewriteconds = ap_make_array(cmd->pool, 2,
+        sconf->rewriteconds = apr_make_array(cmd->pool, 2,
                                             sizeof(rewritecond_entry));
     }
     else {                    /* is per-directory command */
         newrule->rewriteconds   = dconf->rewriteconds;
-        dconf->rewriteconds = ap_make_array(cmd->pool, 2,
+        dconf->rewriteconds = apr_make_array(cmd->pool, 2,
                                             sizeof(rewritecond_entry));
     }
 
     return NULL;
 }
 
-static const char *cmd_rewriterule_parseflagfield(ap_pool_t *p,
+static const char *cmd_rewriterule_parseflagfield(apr_pool_t *p,
                                                   rewriterule_entry *cfg,
                                                   char *str)
 {
@@ -862,7 +862,7 @@ static const char *cmd_rewriterule_parseflagfield(ap_pool_t *p,
     return NULL;
 }
 
-static const char *cmd_rewriterule_setflag(ap_pool_t *p, rewriterule_entry *cfg,
+static const char *cmd_rewriterule_setflag(apr_pool_t *p, rewriterule_entry *cfg,
                                            char *key, char *val)
 {
     int status = 0;
@@ -905,7 +905,7 @@ static const char *cmd_rewriterule_setflag(ap_pool_t *p, rewriterule_entry *cfg,
     }
     else if (   strcasecmp(key, "type") == 0
              || strcasecmp(key, "T") == 0   ) {
-        cfg->forced_mimetype = ap_pstrdup(p, val);
+        cfg->forced_mimetype = apr_pstrdup(p, val);
         ap_str_tolower(cfg->forced_mimetype);
     }
     else if (   strcasecmp(key, "env") == 0
@@ -913,7 +913,7 @@ static const char *cmd_rewriterule_setflag(ap_pool_t *p, rewriterule_entry *cfg,
         for (i = 0; (cfg->env[i] != NULL) && (i < MAX_ENV_FLAGS); i++)
             ;
         if (i < MAX_ENV_FLAGS) {
-            cfg->env[i] = ap_pstrdup(p, val);
+            cfg->env[i] = apr_pstrdup(p, val);
             cfg->env[i+1] = NULL;
         }
         else {
@@ -953,7 +953,7 @@ static const char *cmd_rewriterule_setflag(ap_pool_t *p, rewriterule_entry *cfg,
         cfg->flags |= RULEFLAG_NOCASE;
     }
     else {
-        return ap_pstrcat(p, "RewriteRule: unknown flag '", key, "'", NULL);
+        return apr_pstrcat(p, "RewriteRule: unknown flag '", key, "'", NULL);
     }
     return NULL;
 }
@@ -967,22 +967,22 @@ static const char *cmd_rewriterule_setflag(ap_pool_t *p, rewriterule_entry *cfg,
 **
 */
 
-static void init_module(ap_pool_t *p,
-                        ap_pool_t *plog,
-                        ap_pool_t *ptemp,
+static void init_module(apr_pool_t *p,
+                        apr_pool_t *plog,
+                        apr_pool_t *ptemp,
                         server_rec *s)
 {
     /* check if proxy module is available */
     proxy_available = (ap_find_linked_module("mod_proxy.c") != NULL);
 
     /* create the rewriting lockfiles in the parent */
-    if (ap_create_lock (&rewrite_log_lock, APR_MUTEX, APR_INTRAPROCESS,
+    if (apr_create_lock (&rewrite_log_lock, APR_MUTEX, APR_INTRAPROCESS,
                         NULL, NULL) != APR_SUCCESS)
         exit(1);    /* ugly but I can't log anything yet. This is what */
                     /*   the pre-existing rewritelock_create code did. */
 
     rewritelock_create(s, p);
-    ap_register_cleanup(p, (void *)s, rewritelock_remove, ap_null_cleanup);
+    apr_register_cleanup(p, (void *)s, rewritelock_remove, apr_null_cleanup);
 
     /* step through the servers and
      * - open each rewriting logfile
@@ -1005,11 +1005,11 @@ static void init_module(ap_pool_t *p,
 **
 */
 
-static void init_child(ap_pool_t *p, server_rec *s)
+static void init_child(apr_pool_t *p, server_rec *s)
 {
 
     if (lockname != NULL && *(lockname) != '\0')
-        ap_child_init_lock (&rewrite_map_lock, lockname, p);
+        apr_child_init_lock (&rewrite_mapr_lock, lockname, p);
 
     /* create the lookup cache */
     cachep = init_cache(p);
@@ -1045,7 +1045,7 @@ static int hook_uri2file(request_rec *r)
     char docroot[512];
     char *cp, *cp2;
     const char *ccp;
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     unsigned int port;
     int n;
     int l;
@@ -1083,18 +1083,18 @@ static int hook_uri2file(request_rec *r)
      */
 
     if (r->main == NULL) {
-         var = ap_pstrcat(r->pool, "REDIRECT_", ENVVAR_SCRIPT_URL, NULL);
-         var = ap_table_get(r->subprocess_env, var);
+         var = apr_pstrcat(r->pool, "REDIRECT_", ENVVAR_SCRIPT_URL, NULL);
+         var = apr_table_get(r->subprocess_env, var);
          if (var == NULL) {
-             ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, r->uri);
+             apr_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, r->uri);
          }
          else {
-             ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, var);
+             apr_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, var);
          }
     }
     else {
-         var = ap_table_get(r->main->subprocess_env, ENVVAR_SCRIPT_URL);
-         ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, var);
+         var = apr_table_get(r->main->subprocess_env, ENVVAR_SCRIPT_URL);
+         apr_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, var);
     }
 
     /*
@@ -1108,21 +1108,21 @@ static int hook_uri2file(request_rec *r)
         thisport = "";
     }
     else {
-        ap_snprintf(buf, sizeof(buf), ":%u", port);
+        apr_snprintf(buf, sizeof(buf), ":%u", port);
         thisport = buf;
     }
-    thisurl = ap_table_get(r->subprocess_env, ENVVAR_SCRIPT_URL);
+    thisurl = apr_table_get(r->subprocess_env, ENVVAR_SCRIPT_URL);
 
     /* set the variable */
-    var = ap_pstrcat(r->pool, ap_http_method(r), "://", thisserver, thisport,
+    var = apr_pstrcat(r->pool, ap_http_method(r), "://", thisserver, thisport,
                      thisurl, NULL);
-    ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URI, var);
+    apr_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URI, var);
 
     /* if filename was not initially set,
      * we start with the requested URI
      */
     if (r->filename == NULL) {
-        r->filename = ap_pstrdup(r->pool, r->uri);
+        r->filename = apr_pstrdup(r->pool, r->uri);
         rewritelog(r, 2, "init rewrite engine with requested uri %s",
                    r->filename);
     }
@@ -1150,13 +1150,13 @@ static int hook_uri2file(request_rec *r)
              * PATH_INFO parts get incorporated
              */
             if (r->path_info != NULL) {
-                r->filename = ap_pstrcat(r->pool, r->filename,
+                r->filename = apr_pstrcat(r->pool, r->filename,
                                          r->path_info, NULL);
             }
             if (r->args != NULL &&
                 r->uri == r->unparsed_uri) {
                 /* see proxy_http:proxy_http_canon() */
-                r->filename = ap_pstrcat(r->pool, r->filename,
+                r->filename = apr_pstrcat(r->pool, r->filename,
                                          "?", r->args, NULL);
             }
 
@@ -1196,12 +1196,12 @@ static int hook_uri2file(request_rec *r)
                 rewritelog(r, 1, "escaping %s for redirect", r->filename);
                 cp2 = ap_escape_uri(r->pool, cp);
                 *cp = '\0';
-                r->filename = ap_pstrcat(r->pool, r->filename, cp2, NULL);
+                r->filename = apr_pstrcat(r->pool, r->filename, cp2, NULL);
             }
 
             /* append the QUERY_STRING part */
             if (r->args != NULL) {
-                r->filename = ap_pstrcat(r->pool, r->filename, "?", 
+                r->filename = apr_pstrcat(r->pool, r->filename, "?", 
                                          ap_escape_uri(r->pool, r->args), NULL);
             }
 
@@ -1215,7 +1215,7 @@ static int hook_uri2file(request_rec *r)
             }
 
             /* now do the redirection */
-            ap_table_setn(r->headers_out, "Location", r->filename);
+            apr_table_setn(r->headers_out, "Location", r->filename);
             rewritelog(r, 1, "redirect to %s [REDIRECT/%d]", r->filename, n);
             return n;
         }
@@ -1239,7 +1239,7 @@ static int hook_uri2file(request_rec *r)
              * r->uri! The difference here is: We do not try to
              * add the document root
              */
-            r->uri = ap_pstrdup(r->pool, r->filename+12);
+            r->uri = apr_pstrdup(r->pool, r->filename+12);
             return DECLINED;
         }
         else {
@@ -1279,7 +1279,7 @@ static int hook_uri2file(request_rec *r)
             n = prefix_stat(r->filename, &finfo);
             if (n == 0) {
                 if ((ccp = ap_document_root(r)) != NULL) {
-                    l = ap_cpystrn(docroot, ccp, sizeof(docroot)) - docroot;
+                    l = apr_cpystrn(docroot, ccp, sizeof(docroot)) - docroot;
 
                     /* always NOT have a trailing slash */
                     if (docroot[l-1] == '/') {
@@ -1288,12 +1288,12 @@ static int hook_uri2file(request_rec *r)
                     if (r->server->path
                         && !strncmp(r->filename, r->server->path,
                                     r->server->pathlen)) {
-                        r->filename = ap_pstrcat(r->pool, docroot,
+                        r->filename = apr_pstrcat(r->pool, docroot,
                                                  (r->filename +
                                                   r->server->pathlen), NULL);
                     }
                     else {
-                        r->filename = ap_pstrcat(r->pool, docroot, 
+                        r->filename = apr_pstrcat(r->pool, docroot, 
                                                  r->filename, NULL);
                     }
                     rewritelog(r, 2, "prefixed with document_root to %s",
@@ -1325,7 +1325,7 @@ static int hook_mimetype(request_rec *r)
     const char *t;
 
     /* now check if we have to force a MIME-type */
-    t = ap_table_get(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR);
+    t = apr_table_get(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR);
     if (t == NULL) {
         return DECLINED;
     }
@@ -1420,7 +1420,7 @@ static int hook_fixup(request_rec *r)
              * rewriting engine because of the per-dir context!)
              */
             if (r->args != NULL) {
-                r->filename = ap_pstrcat(r->pool, r->filename,
+                r->filename = apr_pstrcat(r->pool, r->filename,
                                          "?", r->args, NULL);
             }
 
@@ -1468,7 +1468,7 @@ static int hook_fixup(request_rec *r)
                                             dconf->baseurl);
                     if (strcmp(cp2, cp) != 0) {
                         *cp = '\0';
-                        r->filename = ap_pstrcat(r->pool, r->filename,
+                        r->filename = apr_pstrcat(r->pool, r->filename,
                                                  cp2, NULL);
                     }
                 }
@@ -1489,12 +1489,12 @@ static int hook_fixup(request_rec *r)
                            dconf->directory, r->filename);
                 cp2 = ap_escape_uri(r->pool, cp);
                 *cp = '\0';
-                r->filename = ap_pstrcat(r->pool, r->filename, cp2, NULL);
+                r->filename = apr_pstrcat(r->pool, r->filename, cp2, NULL);
             }
 
             /* append the QUERY_STRING part */
             if (r->args != NULL) {
-                r->filename = ap_pstrcat(r->pool, r->filename, "?", 
+                r->filename = apr_pstrcat(r->pool, r->filename, "?", 
                                          ap_escape_uri(r->pool, r->args), NULL);
             }
 
@@ -1508,7 +1508,7 @@ static int hook_fixup(request_rec *r)
             }
 
             /* now do the redirection */
-            ap_table_setn(r->headers_out, "Location", r->filename);
+            apr_table_setn(r->headers_out, "Location", r->filename);
             rewritelog(r, 1, "[per-dir %s] redirect to %s [REDIRECT/%d]",
                        dconf->directory, r->filename, n);
             return n;
@@ -1532,7 +1532,7 @@ static int hook_fixup(request_rec *r)
              */
             if (strlen(r->filename) > 12 &&
                 strncmp(r->filename, "passthrough:", 12) == 0) {
-                r->filename = ap_pstrdup(r->pool, r->filename+12);
+                r->filename = apr_pstrdup(r->pool, r->filename+12);
             }
 
             /* the filename has to start with a slash! */
@@ -1575,7 +1575,7 @@ static int hook_fixup(request_rec *r)
                  * document_root if it is prefix
                  */
                 if ((ccp = ap_document_root(r)) != NULL) {
-                    prefix = ap_pstrdup(r->pool, ccp);
+                    prefix = apr_pstrdup(r->pool, ccp);
                     /* always NOT have a trailing slash */
                     l = strlen(prefix);
                     if (prefix[l-1] == '/') {
@@ -1588,7 +1588,7 @@ static int hook_fixup(request_rec *r)
                                    "prefix: %s -> %s",
                                    dconf->directory, r->filename,
                                    r->filename+l);
-                        r->filename = ap_pstrdup(r->pool, r->filename+l);
+                        r->filename = apr_pstrdup(r->pool, r->filename+l);
                     }
                 }
             }
@@ -1596,7 +1596,7 @@ static int hook_fixup(request_rec *r)
             /* now initiate the internal redirect */
             rewritelog(r, 1, "[per-dir %s] internal redirect with %s "
                        "[INTERNAL REDIRECT]", dconf->directory, r->filename);
-            r->filename = ap_pstrcat(r->pool, "redirect:", r->filename, NULL);
+            r->filename = apr_pstrcat(r->pool, "redirect:", r->filename, NULL);
             r->handler = "redirect-handler";
             return OK;
         }
@@ -1625,7 +1625,7 @@ static int handler_redirect(request_rec *r)
     }
 
     /* now do the internal redirect */
-    ap_internal_redirect(ap_pstrcat(r->pool, r->filename+9,
+    ap_internal_redirect(apr_pstrcat(r->pool, r->filename+9,
                                     r->args ? "?" : NULL, r->args, NULL), r);
 
     /* and return gracefully */
@@ -1645,7 +1645,7 @@ static int handler_redirect(request_rec *r)
  *  Apply a complete rule set,
  *  i.e. a list of rewrite rules
  */
-static int apply_rewrite_list(request_rec *r, ap_array_header_t *rewriterules,
+static int apply_rewrite_list(request_rec *r, apr_array_header_t *rewriterules,
                               char *perdir)
 {
     rewriterule_entry *entries;
@@ -1697,7 +1697,7 @@ static int apply_rewrite_list(request_rec *r, ap_array_header_t *rewriterules,
             if (p->flags & RULEFLAG_PASSTHROUGH) {
                 rewritelog(r, 2, "forcing '%s' to get passed through "
                            "to next API URI-to-filename handler", r->filename);
-                r->filename = ap_pstrcat(r->pool, "passthrough:",
+                r->filename = apr_pstrcat(r->pool, "passthrough:",
                                          r->filename, NULL);
                 changed = 1;
                 break;
@@ -1709,7 +1709,7 @@ static int apply_rewrite_list(request_rec *r, ap_array_header_t *rewriterules,
              */
             if (p->flags & RULEFLAG_FORBIDDEN) {
                 rewritelog(r, 2, "forcing '%s' to be forbidden", r->filename);
-                r->filename = ap_pstrcat(r->pool, "forbidden:",
+                r->filename = apr_pstrcat(r->pool, "forbidden:",
                                          r->filename, NULL);
                 changed = 1;
                 break;
@@ -1721,7 +1721,7 @@ static int apply_rewrite_list(request_rec *r, ap_array_header_t *rewriterules,
              */
             if (p->flags & RULEFLAG_GONE) {
                 rewritelog(r, 2, "forcing '%s' to be gone", r->filename);
-                r->filename = ap_pstrcat(r->pool, "gone:", r->filename, NULL);
+                r->filename = apr_pstrcat(r->pool, "gone:", r->filename, NULL);
                 changed = 1;
                 break;
             }
@@ -1790,7 +1790,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
     backrefinfo *briRC = NULL;
     int prefixstrip;
     int failed;
-    ap_array_header_t *rewriteconds;
+    apr_array_header_t *rewriteconds;
     rewritecond_entry *conds;
     rewritecond_entry *c;
     int i;
@@ -1810,7 +1810,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
     if (perdir != NULL && r->path_info != NULL && r->path_info[0] != '\0') {
         rewritelog(r, 3, "[per-dir %s] add path info postfix: %s -> %s%s",
                    perdir, uri, uri, r->path_info);
-        uri = ap_pstrcat(r->pool, uri, r->path_info, NULL);
+        uri = apr_pstrcat(r->pool, uri, r->path_info, NULL);
     }
 
     /*
@@ -1852,14 +1852,14 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
      *  Else create the RewriteRule `regsubinfo' structure which
      *  holds the substitution information.
      */
-    briRR = (backrefinfo *)ap_palloc(r->pool, sizeof(backrefinfo));
+    briRR = (backrefinfo *)apr_palloc(r->pool, sizeof(backrefinfo));
     if (!rc && (p->flags & RULEFLAG_NOTMATCH)) {
         /*  empty info on negative patterns  */
         briRR->source = "";
         briRR->nsub   = 0;
     }
     else {
-        briRR->source = ap_pstrdup(r->pool, uri);
+        briRR->source = apr_pstrdup(r->pool, uri);
         briRR->nsub   = regexp->re_nsub;
         memcpy((void *)(briRR->regmatch), (void *)(regmatch),
                sizeof(regmatch));
@@ -1870,7 +1870,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
      *  empty backrefinfo, i.e. not subst parts
      *  (this one is adjusted inside apply_rewrite_cond() later!!)
      */
-    briRC = (backrefinfo *)ap_pcalloc(r->pool, sizeof(backrefinfo));
+    briRC = (backrefinfo *)apr_pcalloc(r->pool, sizeof(backrefinfo));
     briRC->source = "";
     briRC->nsub   = 0;
 
@@ -1895,7 +1895,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
                 /*  One condition is false, but another can be
                  *  still true, so we have to continue...
                  */
-	        ap_table_unset(r->notes, VARY_KEY_THIS);
+	        apr_table_unset(r->notes, VARY_KEY_THIS);
                 continue;
             }
             else {
@@ -1921,16 +1921,16 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
                 break;
             }
         }
-	vary = ap_table_get(r->notes, VARY_KEY_THIS);
+	vary = apr_table_get(r->notes, VARY_KEY_THIS);
 	if (vary != NULL) {
-	    ap_table_merge(r->notes, VARY_KEY, vary);
-	    ap_table_unset(r->notes, VARY_KEY_THIS);
+	    apr_table_merge(r->notes, VARY_KEY, vary);
+	    apr_table_unset(r->notes, VARY_KEY_THIS);
 	}
     }
     /*  if any condition fails the complete rule fails  */
     if (failed) {
-        ap_table_unset(r->notes, VARY_KEY);
-        ap_table_unset(r->notes, VARY_KEY_THIS);
+        apr_table_unset(r->notes, VARY_KEY);
+        apr_table_unset(r->notes, VARY_KEY_THIS);
         return 0;
     }
 
@@ -1939,9 +1939,9 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
      * if any of the request header fields were involved, and add them
      * to the Vary field of the response.
      */
-    if ((vary = ap_table_get(r->notes, VARY_KEY)) != NULL) {
-        ap_table_merge(r->headers_out, "Vary", vary);
-	ap_table_unset(r->notes, VARY_KEY);
+    if ((vary = apr_table_get(r->notes, VARY_KEY)) != NULL) {
+        apr_table_merge(r->headers_out, "Vary", vary);
+	apr_table_unset(r->notes, VARY_KEY);
     }
 
     /*
@@ -1953,7 +1953,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
     if (strcmp(output, "-") == 0) {
         for (i = 0; p->env[i] != NULL; i++) {
             /*  1. take the string  */
-            ap_cpystrn(env, p->env[i], sizeof(env));
+            apr_cpystrn(env, p->env[i], sizeof(env));
             /*  2. expand $N (i.e. backrefs to RewriteRule pattern)  */
             expand_backref_inbuffer(r->pool, env, sizeof(env), briRR, '$');
             /*  3. expand %N (i.e. backrefs to latest RewriteCond pattern)  */
@@ -1973,7 +1973,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
                  */
                 rewritelog(r, 2, "remember %s to have MIME-type '%s'",
                            r->filename, p->forced_mimetype);
-                ap_table_setn(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR,
+                apr_table_setn(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR,
                               p->forced_mimetype);
             }
             else {
@@ -2000,7 +2000,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
      *  substitution URL string in `newuri'.
      */
     /*  1. take the output string  */
-    ap_cpystrn(newuri, output, sizeof(newuri));
+    apr_cpystrn(newuri, output, sizeof(newuri));
     /*  2. expand $N (i.e. backrefs to RewriteRule pattern)  */
     expand_backref_inbuffer(r->pool, newuri, sizeof(newuri), briRR, '$');
     /*  3. expand %N (i.e. backrefs to latest RewriteCond pattern)  */
@@ -2023,7 +2023,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
      */
     for (i = 0; p->env[i] != NULL; i++) {
         /*  1. take the string  */
-        ap_cpystrn(env, p->env[i], sizeof(env));
+        apr_cpystrn(env, p->env[i], sizeof(env));
         /*  2. expand $N (i.e. backrefs to RewriteRule pattern)  */
         expand_backref_inbuffer(r->pool, env, sizeof(env), briRR, '$');
         /*  3. expand %N (i.e. backrefs to latest RewriteCond pattern)  */
@@ -2041,7 +2041,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
      *  Replace r->filename with the new URI string and split out
      *  an on-the-fly generated QUERY_STRING part into r->args
      */
-    r->filename = ap_pstrdup(r->pool, newuri);
+    r->filename = apr_pstrdup(r->pool, newuri);
     splitout_queryargs(r, p->flags & RULEFLAG_QSAPPEND);
 
     /*
@@ -2062,7 +2062,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
                  || (i > 7 && strncasecmp(r->filename, "mailto:",   7) == 0)))) {
         rewritelog(r, 3, "[per-dir %s] add per-dir prefix: %s -> %s%s",
                    perdir, r->filename, perdir, r->filename);
-        r->filename = ap_pstrcat(r->pool, perdir, r->filename, NULL);
+        r->filename = apr_pstrcat(r->pool, perdir, r->filename, NULL);
     }
 
     /*
@@ -2082,7 +2082,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
             rewritelog(r, 2, "[per-dir %s] forcing proxy-throughput with %s",
                        perdir, r->filename);
         }
-        r->filename = ap_pstrcat(r->pool, "proxy:", r->filename, NULL);
+        r->filename = apr_pstrcat(r->pool, "proxy:", r->filename, NULL);
         return 1;
     }
 
@@ -2155,7 +2155,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
     if (prefixstrip && r->filename[0] != '/') {
         rewritelog(r, 3, "[per-dir %s] add per-dir prefix: %s -> %s%s",
                    perdir, r->filename, perdir, r->filename);
-        r->filename = ap_pstrcat(r->pool, perdir, r->filename, NULL);
+        r->filename = apr_pstrcat(r->pool, perdir, r->filename, NULL);
     }
 
     /*
@@ -2167,7 +2167,7 @@ static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
      *  already processed) because a sub-request happens ;-)
      */
     if (p->forced_mimetype != NULL) {
-        ap_table_setn(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR,
+        apr_table_setn(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR,
                       p->forced_mimetype);
         if (perdir == NULL) {
             rewritelog(r, 2, "remember %s to have MIME-type '%s'",
@@ -2192,7 +2192,7 @@ static int apply_rewrite_cond(request_rec *r, rewritecond_entry *p,
                               backrefinfo *briRC)
 {
     char input[MAX_STRING_LEN];
-    ap_finfo_t sb;
+    apr_finfo_t sb;
     request_rec *rsub;
     regmatch_t regmatch[MAX_NMATCH];
     int rc;
@@ -2202,7 +2202,7 @@ static int apply_rewrite_cond(request_rec *r, rewritecond_entry *p,
      */
 
     /*  1. take the string  */
-    ap_cpystrn(input, p->input, sizeof(input));
+    apr_cpystrn(input, p->input, sizeof(input));
     /*  2. expand $N (i.e. backrefs to RewriteRule pattern)  */
     expand_backref_inbuffer(r->pool, input, sizeof(input), briRR, '$');
     /*  3. expand %N (i.e. backrefs to latest RewriteCond pattern)  */
@@ -2218,14 +2218,14 @@ static int apply_rewrite_cond(request_rec *r, rewritecond_entry *p,
 
     rc = 0;
     if (strcmp(p->pattern, "-f") == 0) {
-        if (ap_stat(&sb, input, r->pool) == APR_SUCCESS) {
+        if (apr_stat(&sb, input, r->pool) == APR_SUCCESS) {
             if (sb.filetype == APR_REG) {
                 rc = 1;
             }
         }
     }
     else if (strcmp(p->pattern, "-s") == 0) {
-        if (ap_stat(&sb, input, r->pool) == APR_SUCCESS) {
+        if (apr_stat(&sb, input, r->pool) == APR_SUCCESS) {
             if ((sb.filetype == APR_REG) && sb.size > 0) {
                 rc = 1;
             }
@@ -2233,7 +2233,7 @@ static int apply_rewrite_cond(request_rec *r, rewritecond_entry *p,
     }
     else if (strcmp(p->pattern, "-l") == 0) {
 #if !defined(OS2) && !defined(WIN32)
-        if (ap_lstat(&sb, input, r->pool) == APR_SUCCESS) {
+        if (apr_lstat(&sb, input, r->pool) == APR_SUCCESS) {
             if (sb.filetype == APR_LNK) {
                 rc = 1;
             }
@@ -2241,7 +2241,7 @@ static int apply_rewrite_cond(request_rec *r, rewritecond_entry *p,
 #endif
     }
     else if (strcmp(p->pattern, "-d") == 0) {
-        if (ap_stat(&sb, input, r->pool) == APR_SUCCESS) {
+        if (apr_stat(&sb, input, r->pool) == APR_SUCCESS) {
             if (sb.filetype == APR_DIR) {
                 rc = 1;
             }
@@ -2288,7 +2288,7 @@ static int apply_rewrite_cond(request_rec *r, rewritecond_entry *p,
             /* file exists for any result up to 2xx, no redirects */
             if (rsub->status < 300 &&
                 /* double-check that file exists since default result is 200 */
-                ap_stat(&sb, rsub->filename, r->pool) == APR_SUCCESS) {
+                apr_stat(&sb, rsub->filename, r->pool) == APR_SUCCESS) {
                 rc = 1;
             }
 
@@ -2323,7 +2323,7 @@ static int apply_rewrite_cond(request_rec *r, rewritecond_entry *p,
         /* if it isn't a negated pattern and really matched
            we update the passed-through regex subst info structure */
         if (rc && !(p->flags & CONDFLAG_NOTMATCH)) {
-            briRC->source = ap_pstrdup(r->pool, input);
+            briRC->source = apr_pstrdup(r->pool, input);
             briRC->nsub   = p->regexp->re_nsub;
             memcpy((void *)(briRC->regmatch), (void *)(regmatch),
                    sizeof(regmatch));
@@ -2366,13 +2366,13 @@ static void splitout_queryargs(request_rec *r, int qsappend)
 
     q = strchr(r->filename, '?');
     if (q != NULL) {
-        olduri = ap_pstrdup(r->pool, r->filename);
+        olduri = apr_pstrdup(r->pool, r->filename);
         *q++ = '\0';
         if (qsappend) {
-            r->args = ap_pstrcat(r->pool, q, "&", r->args, NULL);
+            r->args = apr_pstrcat(r->pool, q, "&", r->args, NULL);
         }
         else {
-            r->args = ap_pstrdup(r->pool, q);
+            r->args = apr_pstrdup(r->pool, q);
         }
         if (strlen(r->args) == 0) {
             r->args = NULL;
@@ -2419,17 +2419,17 @@ static void reduce_uri(request_rec *r)
         && r->filename[l+2] == '/'             ) {
         /* there was really a rewrite to a remote path */
 
-        olduri = ap_pstrdup(r->pool, r->filename); /* save for logging */
+        olduri = apr_pstrdup(r->pool, r->filename); /* save for logging */
 
         /* cut the hostname and port out of the URI */
-        ap_cpystrn(buf, r->filename+(l+3), sizeof(buf));
+        apr_cpystrn(buf, r->filename+(l+3), sizeof(buf));
         hostp = buf;
         for (cp = hostp; *cp != '\0' && *cp != '/' && *cp != ':'; cp++)
             ;
         if (*cp == ':') {
             /* set host */
             *cp++ = '\0';
-            ap_cpystrn(host, hostp, sizeof(host));
+            apr_cpystrn(host, hostp, sizeof(host));
             /* set port */
             portp = cp;
             for (; *cp != '\0' && *cp != '/'; cp++)
@@ -2444,7 +2444,7 @@ static void reduce_uri(request_rec *r)
         else if (*cp == '/') {
             /* set host */
             *cp = '\0';
-            ap_cpystrn(host, hostp, sizeof(host));
+            apr_cpystrn(host, hostp, sizeof(host));
             *cp = '/';
             /* set port */
             port = ap_default_port(r);
@@ -2453,7 +2453,7 @@ static void reduce_uri(request_rec *r)
         }
         else {
             /* set host */
-            ap_cpystrn(host, hostp, sizeof(host));
+            apr_cpystrn(host, hostp, sizeof(host));
             /* set port */
             port = ap_default_port(r);
             /* set remaining url */
@@ -2463,7 +2463,7 @@ static void reduce_uri(request_rec *r)
         /* now check whether we could reduce it to a local path... */
         if (ap_matches_request_vhost(r, host, port)) {
             /* this is our host, so only the URL remains */
-            r->filename = ap_pstrdup(r->pool, url);
+            r->filename = apr_pstrdup(r->pool, url);
             rewritelog(r, 3, "reduce %s -> %s", olduri, r->filename);
         }
     }
@@ -2501,17 +2501,17 @@ static void fully_qualify_uri(request_rec *r)
             thisport = "";
         }
         else {
-            ap_snprintf(buf, sizeof(buf), ":%u", port);
+            apr_snprintf(buf, sizeof(buf), ":%u", port);
             thisport = buf;
         }
 
         if (r->filename[0] == '/') {
-            r->filename = ap_psprintf(r->pool, "%s://%s%s%s",
+            r->filename = apr_psprintf(r->pool, "%s://%s%s%s",
                                       ap_http_method(r), thisserver,
                                       thisport, r->filename);
         }
         else {
-            r->filename = ap_psprintf(r->pool, "%s://%s%s/%s",
+            r->filename = apr_psprintf(r->pool, "%s://%s%s/%s",
                                       ap_http_method(r), thisserver,
                                       thisport, r->filename);
         }
@@ -2526,7 +2526,7 @@ static void fully_qualify_uri(request_rec *r)
 **
 */
 
-static void expand_backref_inbuffer(ap_pool_t *p, char *buf, int nbuf,
+static void expand_backref_inbuffer(apr_pool_t *p, char *buf, int nbuf,
                                     backrefinfo *bri, char c)
 {
     register int i;
@@ -2550,7 +2550,7 @@ static void expand_backref_inbuffer(ap_pool_t *p, char *buf, int nbuf,
     }
 
     /* now apply the standard regex substitution function */
-    ap_cpystrn(buf, ap_pregsub(p, buf, bri->source,
+    apr_cpystrn(buf, ap_pregsub(p, buf, bri->source,
                                bri->nsub+1, bri->regmatch), nbuf);
 
     /* restore the original $N and & backrefs */
@@ -2597,11 +2597,11 @@ static char *expand_tildepaths(request_rec *r, char *uri)
                 if (pw->pw_dir[strlen(pw->pw_dir)-1] == '/') {
                     pw->pw_dir[strlen(pw->pw_dir)-1] = '\0';
                 }
-                newuri = ap_pstrcat(r->pool, pw->pw_dir, uri+i, NULL);
+                newuri = apr_pstrcat(r->pool, pw->pw_dir, uri+i, NULL);
             }
             else {
                 /* only ~user has to be expanded */
-                newuri = ap_pstrdup(r->pool, pw->pw_dir);
+                newuri = apr_pstrdup(r->pool, pw->pw_dir);
             }
         }
     }
@@ -2716,7 +2716,7 @@ static void expand_map_lookups(request_rec *r, char *uri, int uri_len)
         }
     }
     *cpO = '\0';
-    ap_cpystrn(uri, newuri, uri_len);
+    apr_cpystrn(uri, newuri, uri_len);
     return;
 }
 
@@ -2737,11 +2737,11 @@ static char *lookup_map(request_rec *r, char *name, char *key)
 {
     void *sconf;
     rewrite_server_conf *conf;
-    ap_array_header_t *rewritemaps;
+    apr_array_header_t *rewritemaps;
     rewritemap_entry *entries;
     rewritemap_entry *s;
     char *value;
-    ap_finfo_t st;
+    apr_finfo_t st;
     int i;
 
     /* get map configuration */
@@ -2755,7 +2755,7 @@ static char *lookup_map(request_rec *r, char *name, char *key)
         s = &entries[i];
         if (strcmp(s->name, name) == 0) {
             if (s->type == MAPTYPE_TXT) {
-                if (ap_stat(&st, s->checkfile, r->pool) != APR_SUCCESS) {
+                if (apr_stat(&st, s->checkfile, r->pool) != APR_SUCCESS) {
                     ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "mod_rewrite: can't access text RewriteMap "
                                  "file %s", s->checkfile);
@@ -2792,7 +2792,7 @@ static char *lookup_map(request_rec *r, char *name, char *key)
             }
             else if (s->type == MAPTYPE_DBM) {
 #ifndef NO_DBM_REWRITEMAP
-                if (ap_stat(&st, s->checkfile, r->pool) != APR_SUCCESS) {
+                if (apr_stat(&st, s->checkfile, r->pool) != APR_SUCCESS) {
                     ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
                                  "mod_rewrite: can't access DBM RewriteMap "
                                  "file %s", s->checkfile);
@@ -2854,7 +2854,7 @@ static char *lookup_map(request_rec *r, char *name, char *key)
                 }
             }
             else if (s->type == MAPTYPE_RND) {
-                if (ap_stat(&st, s->checkfile, r->pool) == -1) {
+                if (apr_stat(&st, s->checkfile, r->pool) == -1) {
                     ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
                                  "mod_rewrite: can't access text RewriteMap "
                                  "file %s", s->checkfile);
@@ -2902,8 +2902,8 @@ static char *lookup_map(request_rec *r, char *name, char *key)
 
 static char *lookup_map_txtfile(request_rec *r, char *file, char *key)
 {
-    ap_file_t *fp = NULL;
-    ap_status_t rc;
+    apr_file_t *fp = NULL;
+    apr_status_t rc;
     char line[1024];
     char *value = NULL;
     char *cpT;
@@ -2911,12 +2911,12 @@ static char *lookup_map_txtfile(request_rec *r, char *file, char *key)
     char *curkey;
     char *curval;
 
-    rc = ap_open(&fp, file, APR_READ, APR_OS_DEFAULT, r->pool);
+    rc = apr_open(&fp, file, APR_READ, APR_OS_DEFAULT, r->pool);
     if (rc != APR_SUCCESS) {
        return NULL;
     }
 
-    while (ap_fgets(line, sizeof(line), fp) == APR_SUCCESS) {
+    while (apr_fgets(line, sizeof(line), fp) == APR_SUCCESS) {
         if (line[0] == '#')
             continue; /* ignore comments */
         cpT = line;
@@ -2939,10 +2939,10 @@ static char *lookup_map_txtfile(request_rec *r, char *file, char *key)
             continue; /* no value... */
         cpT += skip;
         *cpT = '\0';
-        value = ap_pstrdup(r->pool, curval);
+        value = apr_pstrdup(r->pool, curval);
         break;
     }
-    ap_close(fp);
+    apr_close(fp);
     return value;
 }
 
@@ -2964,7 +2964,7 @@ static char *lookup_map_dbmfile(request_rec *r, char *file, char *key)
                    dbmval.dsize < sizeof(buf)-1 ? 
                    dbmval.dsize : sizeof(buf)-1  );
             buf[dbmval.dsize] = '\0';
-            value = ap_pstrdup(r->pool, buf);
+            value = apr_pstrdup(r->pool, buf);
         }
         dbm_close(dbmfp);
     }
@@ -2972,17 +2972,17 @@ static char *lookup_map_dbmfile(request_rec *r, char *file, char *key)
 }
 #endif
 
-static char *lookup_map_program(request_rec *r, ap_file_t *fpin,
-                                ap_file_t *fpout, char *key)
+static char *lookup_map_program(request_rec *r, apr_file_t *fpin,
+                                apr_file_t *fpout, char *key)
 {
     char buf[LONG_STRING_LEN];
     char c;
     int i;
-    ap_ssize_t nbytes;
+    apr_ssize_t nbytes;
 
 #ifndef NO_WRITEV
     struct iovec iova[2];
-    ap_size_t niov;
+    apr_size_t niov;
 #endif
 
     /* when `RewriteEngine off' was used in the per-server
@@ -2996,14 +2996,14 @@ static char *lookup_map_program(request_rec *r, ap_file_t *fpin,
 
     /* take the lock */
 
-    ap_lock(rewrite_map_lock);
+    apr_lock(rewrite_mapr_lock);
 
     /* write out the request key */
 #ifdef NO_WRITEV
     nbytes = strlen(key);
-    ap_write(fpin, key, &nbytes);
+    apr_write(fpin, key, &nbytes);
     nbytes = 1;
-    ap_write(fpin, "\n", &nbytes);
+    apr_write(fpin, "\n", &nbytes);
 #else
     iova[0].iov_base = key;
     iova[0].iov_len = strlen(key);
@@ -3011,31 +3011,31 @@ static char *lookup_map_program(request_rec *r, ap_file_t *fpin,
     iova[1].iov_len = 1;
 
     niov = 2;
-    ap_writev(fpin, iova, niov, &nbytes);
+    apr_writev(fpin, iova, niov, &nbytes);
 #endif
 
     /* read in the response value */
     i = 0;
     nbytes = 1;
-    ap_read(fpout, &c, &nbytes);
+    apr_read(fpout, &c, &nbytes);
     while (nbytes == 1 && (i < LONG_STRING_LEN-1)) {
         if (c == '\n') {
             break;
         }
         buf[i++] = c;
 
-        ap_read(fpout, &c, &nbytes);
+        apr_read(fpout, &c, &nbytes);
     }
     buf[i] = '\0';
 
     /* give the lock back */
-    ap_unlock(rewrite_map_lock);
+    apr_unlock(rewrite_mapr_lock);
 
     if (strcasecmp(buf, "NULL") == 0) {
         return NULL;
     }
     else {
-        return ap_pstrdup(r->pool, buf);
+        return apr_pstrdup(r->pool, buf);
     }
 }
 
@@ -3052,7 +3052,7 @@ static char *rewrite_mapfunc_toupper(request_rec *r, char *key)
 {
     char *value, *cp;
 
-    for (cp = value = ap_pstrdup(r->pool, key); cp != NULL && *cp != '\0';
+    for (cp = value = apr_pstrdup(r->pool, key); cp != NULL && *cp != '\0';
          cp++) {
         *cp = ap_toupper(*cp);
     }
@@ -3063,7 +3063,7 @@ static char *rewrite_mapfunc_tolower(request_rec *r, char *key)
 {
     char *value, *cp;
 
-    for (cp = value = ap_pstrdup(r->pool, key); cp != NULL && *cp != '\0';
+    for (cp = value = apr_pstrdup(r->pool, key); cp != NULL && *cp != '\0';
          cp++) {
         *cp = ap_tolower(*cp);
     }
@@ -3082,7 +3082,7 @@ static char *rewrite_mapfunc_unescape(request_rec *r, char *key)
 {
     char *value;
 
-    value = ap_pstrdup(r->pool, key);
+    value = apr_pstrdup(r->pool, key);
     ap_unescape_url(value);
     return value;
 }
@@ -3139,7 +3139,7 @@ static char *select_random_value_part(request_rec *r, char *value)
             n++;
         }
     }
-    buf = ap_pstrdup(r->pool, &value[i]);
+    buf = apr_pstrdup(r->pool, &value[i]);
     for (i = 0; buf[i] != '\0' && buf[i] != '|'; i++)
         ;
     buf[i] = '\0';
@@ -3156,11 +3156,11 @@ static char *select_random_value_part(request_rec *r, char *value)
 */
 
 
-static void open_rewritelog(server_rec *s, ap_pool_t *p)
+static void open_rewritelog(server_rec *s, apr_pool_t *p)
 {
     rewrite_server_conf *conf;
     const char *fname;
-    ap_status_t rc;
+    apr_status_t rc;
     piped_log *pl;
     int    rewritelog_flags = ( APR_WRITE | APR_APPEND | APR_CREATE );
     mode_t rewritelog_mode  = ( APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD );
@@ -3189,7 +3189,7 @@ static void open_rewritelog(server_rec *s, ap_pool_t *p)
         conf->rewritelogfp = ap_piped_log_write_fd(pl);
     }
     else if (*conf->rewritelogfile != '\0') {
-        rc = ap_open(&conf->rewritelogfp, fname, rewritelog_flags, rewritelog_mode, p);
+        rc = apr_open(&conf->rewritelogfp, fname, rewritelog_flags, rewritelog_mode, p);
         if (rc != APR_SUCCESS)  {
             ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, 
                          "mod_rewrite: could not open RewriteLog "
@@ -3211,7 +3211,7 @@ static void rewritelog(request_rec *r, int level, const char *text, ...)
     char redir[20];
     va_list ap;
     int i;
-    ap_ssize_t nbytes;
+    apr_ssize_t nbytes;
     request_rec *req;
     char *ruser;
     const char *rhost;
@@ -3250,11 +3250,11 @@ static void rewritelog(request_rec *r, int level, const char *text, ...)
         rhost = "UNKNOWN-HOST";
     }
 
-    str1 = ap_pstrcat(r->pool, rhost, " ",
+    str1 = apr_pstrcat(r->pool, rhost, " ",
                       (conn->remote_logname != NULL ?
                       conn->remote_logname : "-"), " ",
                       ruser, NULL);
-    ap_vsnprintf(str2, sizeof(str2), text, ap);
+    apr_vsnprintf(str2, sizeof(str2), text, ap);
 
     if (r->main == NULL) {
         strcpy(type, "initial");
@@ -3270,19 +3270,19 @@ static void rewritelog(request_rec *r, int level, const char *text, ...)
         redir[0] = '\0';
     }
     else {
-        ap_snprintf(redir, sizeof(redir), "/redir#%d", i);
+        apr_snprintf(redir, sizeof(redir), "/redir#%d", i);
     }
 
-    ap_snprintf(str3, sizeof(str3),
+    apr_snprintf(str3, sizeof(str3),
                 "%s %s [%s/sid#%lx][rid#%lx/%s%s] (%d) %s\n", str1,
                 current_logtime(r), ap_get_server_name(r),
                 (unsigned long)(r->server), (unsigned long)r,
                 type, redir, level, str2);
 
-    ap_lock(rewrite_log_lock);
+    apr_lock(rewrite_log_lock);
     nbytes = strlen(str3);
-    ap_write(conf->rewritelogfp, str3, &nbytes);
-    ap_unlock(rewrite_log_lock);
+    apr_write(conf->rewritelogfp, str3, &nbytes);
+    apr_unlock(rewrite_log_lock);
 
     va_end(ap);
     return;
@@ -3292,15 +3292,15 @@ static char *current_logtime(request_rec *r)
 {
     ap_exploded_time_t t;
     char tstr[80];
-    ap_size_t len;
+    apr_size_t len;
 
-    ap_explode_localtime(&t, ap_now());
+    apr_explode_localtime(&t, apr_now());
 
-    ap_strftime(tstr, &len, 80, "[%d/%b/%Y:%H:%M:%S ", &t);
-    ap_snprintf(tstr + strlen(tstr), 80-strlen(tstr), "%c%.2d%.2d]",
+    apr_strftime(tstr, &len, 80, "[%d/%b/%Y:%H:%M:%S ", &t);
+    apr_snprintf(tstr + strlen(tstr), 80-strlen(tstr), "%c%.2d%.2d]",
                 t.tm_gmtoff < 0 ? '-' : '+',
 		t.tm_gmtoff / (60*60), t.tm_gmtoff % (60*60));
-    return ap_pstrdup(r->pool, tstr);
+    return apr_pstrdup(r->pool, tstr);
 }
 
 
@@ -3316,9 +3316,9 @@ static char *current_logtime(request_rec *r)
 
 #define REWRITELOCK_MODE ( APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD )
 
-static void rewritelock_create(server_rec *s, ap_pool_t *p)
+static void rewritelock_create(server_rec *s, apr_pool_t *p)
 {
-    ap_status_t rc;
+    apr_status_t rc;
 
     /* only operate if a lockfile is used */
     if (lockname == NULL || *(lockname) == '\0') {
@@ -3329,7 +3329,7 @@ static void rewritelock_create(server_rec *s, ap_pool_t *p)
     lockname = ap_server_root_relative(p, lockname);
 
     /* create the lockfile */
-    rc = ap_create_lock (&rewrite_map_lock, APR_MUTEX, APR_LOCKALL, lockname, p);
+    rc = apr_create_lock (&rewrite_mapr_lock, APR_MUTEX, APR_LOCKALL, lockname, p);
     if (rc != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                      "mod_rewrite: Parent could not create RewriteLock "
@@ -3340,7 +3340,7 @@ static void rewritelock_create(server_rec *s, ap_pool_t *p)
     return;
 }
 
-static ap_status_t rewritelock_remove(void *data)
+static apr_status_t rewritelock_remove(void *data)
 {
     /* only operate if a lockfile is used */
     if (lockname == NULL || *(lockname) == '\0') {
@@ -3348,8 +3348,8 @@ static ap_status_t rewritelock_remove(void *data)
     }
 
     /* destroy the rewritelock */
-    ap_destroy_lock (rewrite_map_lock);
-    rewrite_map_lock = NULL;
+    apr_destroy_lock (rewrite_mapr_lock);
+    rewrite_mapr_lock = NULL;
     lockname = NULL;
     return(0);
 }
@@ -3363,13 +3363,13 @@ static ap_status_t rewritelock_remove(void *data)
 ** +-------------------------------------------------------+
 */
 
-static void run_rewritemap_programs(server_rec *s, ap_pool_t *p)
+static void run_rewritemap_programs(server_rec *s, apr_pool_t *p)
 {
     rewrite_server_conf *conf;
-    ap_file_t *fpin = NULL;
-    ap_file_t *fpout = NULL;
-    ap_file_t *fperr = NULL;
-    ap_array_header_t *rewritemaps;
+    apr_file_t *fpin = NULL;
+    apr_file_t *fpout = NULL;
+    apr_file_t *fperr = NULL;
+    apr_array_header_t *rewritemaps;
     rewritemap_entry *entries;
     rewritemap_entry *map;
     int i;
@@ -3415,35 +3415,35 @@ static void run_rewritemap_programs(server_rec *s, ap_pool_t *p)
 }
 
 /* child process code */
-static int rewritemap_program_child(ap_pool_t *p, char *progname,
-                                    ap_file_t **fpout, ap_file_t **fpin,
-                                    ap_file_t **fperr)
+static int rewritemap_program_child(apr_pool_t *p, char *progname,
+                                    apr_file_t **fpout, apr_file_t **fpin,
+                                    apr_file_t **fperr)
 {
     int rc = -1;
-    ap_procattr_t *procattr;
-    ap_proc_t *procnew;
+    apr_procattr_t *procattr;
+    apr_proc_t *procnew;
 
 #ifdef SIGHUP
-    ap_signal(SIGHUP, SIG_IGN);
+    apr_signal(SIGHUP, SIG_IGN);
 #endif
 
     
-    if ((ap_createprocattr_init(&procattr, p)           != APR_SUCCESS) ||
-        (ap_setprocattr_io(procattr, APR_FULL_BLOCK,
+    if ((apr_createprocattr_init(&procattr, p)           != APR_SUCCESS) ||
+        (apr_setprocattr_io(procattr, APR_FULL_BLOCK,
                                      APR_FULL_NONBLOCK,
                                      APR_FULL_NONBLOCK) != APR_SUCCESS) ||
-        (ap_setprocattr_dir(procattr, ap_make_dirstr_parent(p, progname))
+        (apr_setprocattr_dir(procattr, ap_make_dirstr_parent(p, progname))
                                                         != APR_SUCCESS) ||
-        (ap_setprocattr_cmdtype(procattr, APR_PROGRAM)  != APR_SUCCESS)) {
+        (apr_setprocattr_cmdtype(procattr, APR_PROGRAM)  != APR_SUCCESS)) {
         /* Something bad happened, give up and go away. */
         rc = -1;
     }
     else {
-        procnew = ap_pcalloc(p, sizeof(*procnew));
-        rc = ap_create_process(procnew, progname, NULL, NULL, procattr, p);
+        procnew = apr_pcalloc(p, sizeof(*procnew));
+        rc = apr_create_process(procnew, progname, NULL, NULL, procattr, p);
     
         if (rc == APR_SUCCESS) {
-            ap_note_subprocess(p, procnew, kill_after_timeout);
+            apr_note_subprocess(p, procnew, kill_after_timeout);
 
             if (fpin) {
                 (*fpin) = procnew->in;
@@ -3479,7 +3479,7 @@ static void expand_variables_inbuffer(request_rec *r, char *buf, int buf_len)
     char *newbuf;
     newbuf = expand_variables(r, buf);
     if (strcmp(newbuf, buf) != 0) {
-        ap_cpystrn(buf, newbuf, buf_len);
+        apr_cpystrn(buf, newbuf, buf_len);
     }
     return;
 }
@@ -3495,7 +3495,7 @@ static char *expand_variables(request_rec *r, char *str)
     char *outp;
     char *endp;
 
-    ap_cpystrn(input, str, sizeof(input));
+    apr_cpystrn(input, str, sizeof(input));
     output[0] = '\0';
     outp = output;
     endp = output + sizeof(output);
@@ -3504,21 +3504,21 @@ static char *expand_variables(request_rec *r, char *str)
         if ((cp2 = strstr(cp, "%{")) != NULL) {
             if ((cp3 = strstr(cp2, "}")) != NULL) {
                 *cp2 = '\0';
-                outp = ap_cpystrn(outp, cp, endp - outp);
+                outp = apr_cpystrn(outp, cp, endp - outp);
 
                 cp2 += 2;
                 *cp3 = '\0';
-                outp = ap_cpystrn(outp, lookup_variable(r, cp2), endp - outp);
+                outp = apr_cpystrn(outp, lookup_variable(r, cp2), endp - outp);
 
                 cp = cp3+1;
                 expanded = 1;
                 continue;
             }
         }
-        outp = ap_cpystrn(outp, cp, endp - outp);
+        outp = apr_cpystrn(outp, cp, endp - outp);
         break;
     }
-    return expanded ? ap_pstrdup(r->pool, output) : str;
+    return expanded ? apr_pstrdup(r->pool, output) : str;
 }
 
 static char *lookup_variable(request_rec *r, char *var)
@@ -3530,7 +3530,7 @@ static char *lookup_variable(request_rec *r, char *var)
 #ifndef WIN32
     struct passwd *pw;
     struct group *gr;
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
 #endif
 
     result = NULL;
@@ -3618,7 +3618,7 @@ static char *lookup_variable(request_rec *r, char *var)
         result = r->connection->local_ip;
     }
     else if (strcasecmp(var, "SERVER_PORT") == 0) {
-        ap_snprintf(resultbuf, sizeof(resultbuf), "%u", ap_get_server_port(r));
+        apr_snprintf(resultbuf, sizeof(resultbuf), "%u", ap_get_server_port(r));
         result = resultbuf;
     }
     else if (strcasecmp(var, "SERVER_PROTOCOL") == 0) {
@@ -3628,7 +3628,7 @@ static char *lookup_variable(request_rec *r, char *var)
         result = ap_get_server_version();
     }
     else if (strcasecmp(var, "API_VERSION") == 0) { /* non-standard */
-        ap_snprintf(resultbuf, sizeof(resultbuf), "%d:%d",
+        apr_snprintf(resultbuf, sizeof(resultbuf), "%d:%d",
 		    MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
         result = resultbuf;
     }
@@ -3636,13 +3636,13 @@ static char *lookup_variable(request_rec *r, char *var)
 /* XXX: wow this has gotta be slow if you actually use it for a lot, recalculates exploded time for each variable */
     /* underlaying Unix system stuff */
     else if (strcasecmp(var, "TIME_YEAR") == 0) {
-        ap_explode_localtime(&tm, ap_now());
-        ap_snprintf(resultbuf, sizeof(resultbuf), "%04d", tm.tm_year + 1900);
+        apr_explode_localtime(&tm, apr_now());
+        apr_snprintf(resultbuf, sizeof(resultbuf), "%04d", tm.tm_year + 1900);
         result = resultbuf;
     }
 #define MKTIMESTR(format, tmfield) \
-    ap_explode_localtime(&tm, ap_now()); \
-    ap_snprintf(resultbuf, sizeof(resultbuf), format, tm.tmfield); \
+    apr_explode_localtime(&tm, apr_now()); \
+    apr_snprintf(resultbuf, sizeof(resultbuf), format, tm.tmfield); \
     result = resultbuf;
     else if (strcasecmp(var, "TIME_MON") == 0) {
         MKTIMESTR("%02d", tm_mon+1)
@@ -3663,8 +3663,8 @@ static char *lookup_variable(request_rec *r, char *var)
         MKTIMESTR("%d", tm_wday)
     }
     else if (strcasecmp(var, "TIME") == 0) {
-        ap_explode_localtime(&tm, ap_now());
-        ap_snprintf(resultbuf, sizeof(resultbuf),
+        apr_explode_localtime(&tm, apr_now());
+        apr_snprintf(resultbuf, sizeof(resultbuf),
 		    "%04d%02d%02d%02d%02d%02d", tm.tm_year + 1900,
 		    tm.tm_mon+1, tm.tm_mday,
 		    tm.tm_hour, tm.tm_min, tm.tm_sec);
@@ -3675,10 +3675,10 @@ static char *lookup_variable(request_rec *r, char *var)
     /* all other env-variables from the parent Apache process */
     else if (strlen(var) > 4 && strncasecmp(var, "ENV:", 4) == 0) {
         /* first try the internal Apache notes structure */
-        result = ap_table_get(r->notes, var+4);
+        result = apr_table_get(r->notes, var+4);
         /* second try the internal Apache env structure  */
         if (result == NULL) {
-            result = ap_table_get(r->subprocess_env, var+4);
+            result = apr_table_get(r->subprocess_env, var+4);
         }
         /* third try the external OS env */
         if (result == NULL) {
@@ -3700,8 +3700,8 @@ static char *lookup_variable(request_rec *r, char *var)
             rsub = subrecfunc(r->filename, r); \
             /* now recursively lookup the variable in the sub_req */ \
             result = lookup_variable(rsub, var+5); \
-            /* copy it up to our scope before we destroy sub_req's ap_pool_t */ \
-            result = ap_pstrdup(r->pool, result); \
+            /* copy it up to our scope before we destroy sub_req's apr_pool_t */ \
+            result = apr_pstrdup(r->pool, result); \
             /* cleanup by destroying the subrequest */ \
             ap_destroy_sub_req(rsub); \
             /* log it */ \
@@ -3733,7 +3733,7 @@ static char *lookup_variable(request_rec *r, char *var)
             }
         }
         else {
-            if (ap_stat(&finfo, r->filename, r->pool) == APR_SUCCESS) {
+            if (apr_stat(&finfo, r->filename, r->pool) == APR_SUCCESS) {
                 if ((pw = getpwuid(finfo.user)) != NULL) {
                     result = pw->pw_name;
                 }
@@ -3748,7 +3748,7 @@ static char *lookup_variable(request_rec *r, char *var)
             }
         }
         else {
-            if (ap_stat(&finfo, r->filename, r->pool) == 0) {
+            if (apr_stat(&finfo, r->filename, r->pool) == 0) {
                 if ((gr = getgrgid(finfo.group)) != NULL) {
                     result = gr->gr_name;
                 }
@@ -3758,27 +3758,27 @@ static char *lookup_variable(request_rec *r, char *var)
 #endif /* ndef WIN32 && NETWARE*/
 
     if (result == NULL) {
-        return ap_pstrdup(r->pool, "");
+        return apr_pstrdup(r->pool, "");
     }
     else {
-        return ap_pstrdup(r->pool, result);
+        return apr_pstrdup(r->pool, result);
     }
 }
 
 static char *lookup_header(request_rec *r, const char *name)
 {
-    ap_array_header_t *hdrs_arr;
-    ap_table_entry_t *hdrs;
+    apr_array_header_t *hdrs_arr;
+    apr_table_entry_t *hdrs;
     int i;
 
     hdrs_arr = ap_table_elts(r->headers_in);
-    hdrs = (ap_table_entry_t *)hdrs_arr->elts;
+    hdrs = (apr_table_entry_t *)hdrs_arr->elts;
     for (i = 0; i < hdrs_arr->nelts; ++i) {
         if (hdrs[i].key == NULL) {
             continue;
         }
         if (strcasecmp(hdrs[i].key, name) == 0) {
-	    ap_table_merge(r->notes, VARY_KEY_THIS, name);
+	    apr_table_merge(r->notes, VARY_KEY_THIS, name);
             return hdrs[i].val;
         }
     }
@@ -3797,14 +3797,14 @@ static char *lookup_header(request_rec *r, const char *name)
 */
 
 
-static cache *init_cache(ap_pool_t *p)
+static cache *init_cache(apr_pool_t *p)
 {
     cache *c;
 
-    c = (cache *)ap_palloc(p, sizeof(cache));
-    if (ap_create_pool(&c->pool, p) != APR_SUCCESS)
+    c = (cache *)apr_palloc(p, sizeof(cache));
+    if (apr_create_pool(&c->pool, p) != APR_SUCCESS)
 		return NULL;
-    c->lists = ap_make_array(c->pool, 2, sizeof(cachelist));
+    c->lists = apr_make_array(c->pool, 2, sizeof(cachelist));
     return c;
 }
 
@@ -3839,7 +3839,7 @@ static char *get_cache_string(cache *c, char *res, int mode,
             return NULL;
         }
     }
-    return ap_pstrdup(c->pool, ce->value);
+    return apr_pstrdup(c->pool, ce->value);
 }
 
 static int cache_tlb_hash(char *key)
@@ -3906,7 +3906,7 @@ static void store_cache_string(cache *c, char *res, cacheentry *ce)
                                  (cacheentry *)l->entries->elts, ce->key);
             if (e != NULL) {
                 e->time  = ce->time;
-                e->value = ap_pstrdup(c->pool, ce->value);
+                e->value = apr_pstrdup(c->pool, ce->value);
                 return;
             }
 
@@ -3914,7 +3914,7 @@ static void store_cache_string(cache *c, char *res, cacheentry *ce)
                 e = &(((cacheentry *)l->entries->elts)[j]);
                 if (strcmp(e->key, ce->key) == 0) {
                     e->time  = ce->time;
-                    e->value = ap_pstrdup(c->pool, ce->value);
+                    e->value = apr_pstrdup(c->pool, ce->value);
                   cache_tlb_replace((cachetlbentry *)l->tlb->elts,
                                     (cacheentry *)l->entries->elts, e);
                     return;
@@ -3925,10 +3925,10 @@ static void store_cache_string(cache *c, char *res, cacheentry *ce)
 
     /* create a needed new list */
     if (!found_list) {
-        l = ap_push_array(c->lists);
-        l->resource = ap_pstrdup(c->pool, res);
-        l->entries  = ap_make_array(c->pool, 2, sizeof(cacheentry));
-        l->tlb      = ap_make_array(c->pool, CACHE_TLB_ROWS,
+        l = apr_push_array(c->lists);
+        l->resource = apr_pstrdup(c->pool, res);
+        l->entries  = apr_make_array(c->pool, 2, sizeof(cacheentry));
+        l->tlb      = apr_make_array(c->pool, CACHE_TLB_ROWS,
                                     sizeof(cachetlbentry));
         for (i=0; i<CACHE_TLB_ROWS; ++i) {
             t = &((cachetlbentry *)l->tlb->elts)[i];
@@ -3941,10 +3941,10 @@ static void store_cache_string(cache *c, char *res, cacheentry *ce)
     for (i = 0; i < c->lists->nelts; i++) {
         l = &(((cachelist *)c->lists->elts)[i]);
         if (strcmp(l->resource, res) == 0) {
-            e = ap_push_array(l->entries);
+            e = apr_push_array(l->entries);
             e->time  = ce->time;
-            e->key   = ap_pstrdup(c->pool, ce->key);
-            e->value = ap_pstrdup(c->pool, ce->value);
+            e->key   = apr_pstrdup(c->pool, ce->key);
+            e->value = apr_pstrdup(c->pool, ce->value);
             cache_tlb_replace((cachetlbentry *)l->tlb->elts,
                               (cacheentry *)l->entries->elts, e);
             return;
@@ -4004,7 +4004,7 @@ static char *subst_prefix_path(request_rec *r, char *input, char *match,
     output = input;
 
     /* first create a match string which always has a trailing slash */
-    l = ap_cpystrn(matchbuf, match, sizeof(matchbuf)) - matchbuf;
+    l = apr_cpystrn(matchbuf, match, sizeof(matchbuf)) - matchbuf;
     if (matchbuf[l-1] != '/') {
        matchbuf[l] = '/';
        matchbuf[l+1] = '\0';
@@ -4013,10 +4013,10 @@ static char *subst_prefix_path(request_rec *r, char *input, char *match,
     /* now compare the prefix */
     if (strncmp(input, matchbuf, l) == 0) {
         rewritelog(r, 5, "strip matching prefix: %s -> %s", output, output+l);
-        output = ap_pstrdup(r->pool, output+l);
+        output = apr_pstrdup(r->pool, output+l);
 
         /* and now add the base-URL as replacement prefix */
-        l = ap_cpystrn(substbuf, subst, sizeof(substbuf)) - substbuf;
+        l = apr_cpystrn(substbuf, subst, sizeof(substbuf)) - substbuf;
         if (substbuf[l-1] != '/') {
            substbuf[l] = '/';
            substbuf[l+1] = '\0';
@@ -4025,12 +4025,12 @@ static char *subst_prefix_path(request_rec *r, char *input, char *match,
         if (output[0] == '/') {
             rewritelog(r, 4, "add subst prefix: %s -> %s%s",
                        output, substbuf, output+1);
-            output = ap_pstrcat(r->pool, substbuf, output+1, NULL);
+            output = apr_pstrcat(r->pool, substbuf, output+1, NULL);
         }
         else {
             rewritelog(r, 4, "add subst prefix: %s -> %s%s",
                        output, substbuf, output);
-            output = ap_pstrcat(r->pool, substbuf, output, NULL);
+            output = apr_pstrcat(r->pool, substbuf, output, NULL);
         }
     }
     return output;
@@ -4128,8 +4128,8 @@ static void add_env_variable(request_rec *r, char *s)
         n = ((cp-s) > MAX_STRING_LEN-1 ? MAX_STRING_LEN-1 : (cp-s));
         memcpy(var, s, n);
         var[n] = '\0';
-        ap_cpystrn(val, cp+1, sizeof(val));
-        ap_table_set(r->subprocess_env, var, val);
+        apr_cpystrn(val, cp+1, sizeof(val));
+        apr_table_set(r->subprocess_env, var, val);
         rewritelog(r, 5, "setting env variable '%s' to '%s'", var, val);
     }
 }
@@ -4142,19 +4142,19 @@ static void add_env_variable(request_rec *r, char *s)
 **
 */
 
-static int prefix_stat(const char *path, ap_finfo_t *sb)
+static int prefix_stat(const char *path, apr_finfo_t *sb)
 {
     char curpath[LONG_STRING_LEN];
     char *cp;
 
-    ap_cpystrn(curpath, path, sizeof(curpath));
+    apr_cpystrn(curpath, path, sizeof(curpath));
     if (curpath[0] != '/') {
         return 0;
     }
     if ((cp = strchr(curpath+1, '/')) != NULL) {
         *cp = '\0';
     }
-    if (ap_stat(sb, curpath, NULL) == 0) {
+    if (apr_stat(sb, curpath, NULL) == 0) {
         return 1;
     }
     else {
diff --git a/modules/mappers/mod_rewrite.h b/modules/mappers/mod_rewrite.h
index 6432ee9..cc8cac6 100644
--- a/modules/mappers/mod_rewrite.h
+++ b/modules/mappers/mod_rewrite.h
@@ -127,7 +127,7 @@
 #include "http_vhost.h"
 
     /*
-     * The key in the r->notes ap_table_t wherein we store our accumulated
+     * The key in the r->notes apr_table_t wherein we store our accumulated
      * Vary values, and the one used for per-condition checks in a chain.
      */
 #define VARY_KEY "rewrite-Vary"
@@ -243,9 +243,9 @@ typedef struct {
     char *datafile;                /* filename for map data files */
     char *checkfile;               /* filename to check for map existence */
     int   type;                    /* the type of the map */
-    ap_file_t *fpin;               /* in  file pointer for program maps */
-    ap_file_t *fpout;              /* out file pointer for program maps */
-    ap_file_t *fperr;              /* err file pointer for program maps */
+    apr_file_t *fpin;               /* in  file pointer for program maps */
+    apr_file_t *fpout;              /* out file pointer for program maps */
+    apr_file_t *fperr;              /* err file pointer for program maps */
     char *(*func)(request_rec *,   /* function pointer for internal maps */
                   char *);
 } rewritemap_entry;
@@ -258,7 +258,7 @@ typedef struct {
 } rewritecond_entry;
 
 typedef struct {
-    ap_array_header_t *rewriteconds;    /* the corresponding RewriteCond entries */
+    apr_array_header_t *rewriteconds;    /* the corresponding RewriteCond entries */
     char    *pattern;              /* the RegExp pattern string */
     regex_t *regexp;               /* the RegExp pattern compilation */
     char    *output;               /* the Substitution string */
@@ -277,11 +277,11 @@ typedef struct {
     int           state;           /* the RewriteEngine state */
     int           options;         /* the RewriteOption state */
     char         *rewritelogfile;  /* the RewriteLog filename */
-    ap_file_t    *rewritelogfp;    /* the RewriteLog open filepointer */
+    apr_file_t    *rewritelogfp;    /* the RewriteLog open filepointer */
     int           rewriteloglevel; /* the RewriteLog level of verbosity */
-    ap_array_header_t *rewritemaps;     /* the RewriteMap entries */
-    ap_array_header_t *rewriteconds;    /* the RewriteCond entries (temporary) */
-    ap_array_header_t *rewriterules;    /* the RewriteRule entries */
+    apr_array_header_t *rewritemaps;     /* the RewriteMap entries */
+    apr_array_header_t *rewriteconds;    /* the RewriteCond entries (temporary) */
+    apr_array_header_t *rewriterules;    /* the RewriteRule entries */
     server_rec   *server;          /* the corresponding server indicator */
 } rewrite_server_conf;
 
@@ -292,15 +292,15 @@ typedef struct {
 typedef struct {
     int           state;           /* the RewriteEngine state */
     int           options;         /* the RewriteOption state */
-    ap_array_header_t *rewriteconds;    /* the RewriteCond entries (temporary) */
-    ap_array_header_t *rewriterules;    /* the RewriteRule entries */
+    apr_array_header_t *rewriteconds;    /* the RewriteCond entries (temporary) */
+    apr_array_header_t *rewriterules;    /* the RewriteRule entries */
     char         *directory;       /* the directory where it applies */
     char         *baseurl;         /* the base-URL  where it applies */
 } rewrite_perdir_conf;
 
 
     /* the cache structures,
-     * a 4-way hash ap_table_t with LRU functionality
+     * a 4-way hash apr_table_t with LRU functionality
      */
 typedef struct cacheentry {
     time_t time;
@@ -314,13 +314,13 @@ typedef struct tlbentry {
 
 typedef struct cachelist {
     char         *resource;
-    ap_array_header_t *entries;
-    ap_array_header_t *tlb;
+    apr_array_header_t *entries;
+    apr_array_header_t *tlb;
 } cachelist;
 
 typedef struct cache {
-    ap_pool_t         *pool;
-    ap_array_header_t *lists;
+    apr_pool_t         *pool;
+    apr_array_header_t *lists;
 } cache;
 
 
@@ -341,10 +341,10 @@ typedef struct backrefinfo {
 */
 
     /* config structure handling */
-static void *config_server_create(ap_pool_t *p, server_rec *s);
-static void *config_server_merge (ap_pool_t *p, void *basev, void *overridesv);
-static void *config_perdir_create(ap_pool_t *p, char *path);
-static void *config_perdir_merge (ap_pool_t *p, void *basev, void *overridesv);
+static void *config_server_create(apr_pool_t *p, server_rec *s);
+static void *config_server_merge (apr_pool_t *p, void *basev, void *overridesv);
+static void *config_perdir_create(apr_pool_t *p, char *path);
+static void *config_perdir_merge (apr_pool_t *p, void *basev, void *overridesv);
 
     /* config directive handling */
 static const char *cmd_rewriteengine(cmd_parms *cmd,
@@ -352,7 +352,7 @@ static const char *cmd_rewriteengine(cmd_parms *cmd,
 static const char *cmd_rewriteoptions(cmd_parms *cmd,
                                       rewrite_perdir_conf *dconf,
                                       char *option);
-static const char *cmd_rewriteoptions_setoption(ap_pool_t *p, int *options,
+static const char *cmd_rewriteoptions_setoption(apr_pool_t *p, int *options,
                                                 char *name);
 static const char *cmd_rewritelog     (cmd_parms *cmd, void *dconf, char *a1);
 static const char *cmd_rewriteloglevel(cmd_parms *cmd, void *dconf, char *a1);
@@ -363,25 +363,25 @@ static const char *cmd_rewritebase(cmd_parms *cmd, rewrite_perdir_conf *dconf,
                                    char *a1);
 static const char *cmd_rewritecond(cmd_parms *cmd, rewrite_perdir_conf *dconf,
                                    char *str);
-static const char *cmd_rewritecond_parseflagfield(ap_pool_t *p,
+static const char *cmd_rewritecond_parseflagfield(apr_pool_t *p,
                                                   rewritecond_entry *new,
                                                   char *str);
-static const char *cmd_rewritecond_setflag(ap_pool_t *p, rewritecond_entry *cfg,
+static const char *cmd_rewritecond_setflag(apr_pool_t *p, rewritecond_entry *cfg,
                                            char *key, char *val);
 static const char *cmd_rewriterule(cmd_parms *cmd, rewrite_perdir_conf *dconf,
                                    char *str);
-static const char *cmd_rewriterule_parseflagfield(ap_pool_t *p,
+static const char *cmd_rewriterule_parseflagfield(apr_pool_t *p,
                                                   rewriterule_entry *new,
                                                   char *str);
-static const char *cmd_rewriterule_setflag(ap_pool_t *p, rewriterule_entry *cfg,
+static const char *cmd_rewriterule_setflag(apr_pool_t *p, rewriterule_entry *cfg,
                                            char *key, char *val);
 
     /* initialisation */
-static void init_module(ap_pool_t *p,
-                        ap_pool_t *plog,
-                        ap_pool_t *ptemp,
+static void init_module(apr_pool_t *p,
+                        apr_pool_t *plog,
+                        apr_pool_t *ptemp,
                         server_rec *s);
-static void init_child(ap_pool_t *p, server_rec *s);
+static void init_child(apr_pool_t *p, server_rec *s);
 
     /* runtime hooks */
 static int hook_uri2file   (request_rec *r);
@@ -390,7 +390,7 @@ static int hook_fixup      (request_rec *r);
 static int handler_redirect(request_rec *r);
 
     /* rewriting engine */
-static int apply_rewrite_list(request_rec *r, ap_array_header_t *rewriterules,
+static int apply_rewrite_list(request_rec *r, apr_array_header_t *rewriterules,
                               char *perdir);
 static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
                               char *perdir);
@@ -402,7 +402,7 @@ static int apply_rewrite_cond(request_rec *r, rewritecond_entry *p,
 static void  splitout_queryargs(request_rec *r, int qsappend);
 static void  fully_qualify_uri(request_rec *r);
 static void  reduce_uri(request_rec *r);
-static void  expand_backref_inbuffer(ap_pool_t *p, char *buf, int nbuf,
+static void  expand_backref_inbuffer(apr_pool_t *p, char *buf, int nbuf,
                                      backrefinfo *bri, char c);
 static char *expand_tildepaths(request_rec *r, char *uri);
 static void  expand_map_lookups(request_rec *r, char *uri, int uri_len);
@@ -413,8 +413,8 @@ static char *lookup_map_txtfile(request_rec *r, char *file, char *key);
 #ifndef NO_DBM_REWRITEMAP
 static char *lookup_map_dbmfile(request_rec *r, char *file, char *key);
 #endif
-static char *lookup_map_program(request_rec *r, ap_file_t *fpin,
-                                ap_file_t *fpout, char *key);
+static char *lookup_map_program(request_rec *r, apr_file_t *fpin,
+                                apr_file_t *fpout, char *key);
 static char *lookup_map_internal(request_rec *r,
                                  char *(*func)(request_rec *r, char *key),
                                  char *key);
@@ -427,20 +427,20 @@ static void  rewrite_rand_init(void);
 static int   rewrite_rand(int l, int h);
 
     /* rewriting logfile support */
-static void  open_rewritelog(server_rec *s, ap_pool_t *p);
+static void  open_rewritelog(server_rec *s, apr_pool_t *p);
 static void  rewritelog(request_rec *r, int level, const char *text, ...)
                         __attribute__((format(printf,3,4)));
 static char *current_logtime(request_rec *r);
 
     /* rewriting lockfile support */
-static void rewritelock_create(server_rec *s, ap_pool_t *p);
-static ap_status_t rewritelock_remove(void *data);
+static void rewritelock_create(server_rec *s, apr_pool_t *p);
+static apr_status_t rewritelock_remove(void *data);
 
     /* program map support */
-static void  run_rewritemap_programs(server_rec *s, ap_pool_t *p);
-static int   rewritemap_program_child(ap_pool_t *p, char *progname,
-                                    ap_file_t **fpout, ap_file_t **fpin,
-                                    ap_file_t **fperr);
+static void  run_rewritemap_programs(server_rec *s, apr_pool_t *p);
+static int   rewritemap_program_child(apr_pool_t *p, char *progname,
+                                    apr_file_t **fpout, apr_file_t **fpin,
+                                    apr_file_t **fperr);
 
     /* env variable support */
 static void  expand_variables_inbuffer(request_rec *r, char *buf, int buf_len);
@@ -449,7 +449,7 @@ static char *lookup_variable(request_rec *r, char *var);
 static char *lookup_header(request_rec *r, const char *name);
 
     /* caching functions */
-static cache *init_cache(ap_pool_t *p);
+static cache *init_cache(apr_pool_t *p);
 static char  *get_cache_string(cache *c, char *res, int mode, time_t mtime,
                                char *key);
 static void   set_cache_string(cache *c, char *res, int mode, time_t mtime,
@@ -461,7 +461,7 @@ static void   store_cache_string(cache *c, char *res, cacheentry *ce);
 static char  *subst_prefix_path(request_rec *r, char *input, char *match,
                                 char *subst);
 static int    parseargline(char *str, char **a1, char **a2, char **a3);
-static int    prefix_stat(const char *path, ap_finfo_t *sb);
+static int    prefix_stat(const char *path, apr_finfo_t *sb);
 static void   add_env_variable(request_rec *r, char *s);
 
     /* Lexicographic Comparison */
diff --git a/modules/mappers/mod_so.c b/modules/mappers/mod_so.c
index 829f49c..bab952f 100644
--- a/modules/mappers/mod_so.c
+++ b/modules/mappers/mod_so.c
@@ -149,15 +149,15 @@ typedef struct moduleinfo {
 } moduleinfo;
 
 typedef struct so_server_conf {
-    ap_array_header_t *loaded_modules;
+    apr_array_header_t *loaded_modules;
 } so_server_conf;
 
-static void *so_sconf_create(ap_pool_t *p, server_rec *s)
+static void *so_sconf_create(apr_pool_t *p, server_rec *s)
 {
     so_server_conf *soc;
 
-    soc = (so_server_conf *)ap_pcalloc(p, sizeof(so_server_conf));
-    soc->loaded_modules = ap_make_array(p, DYNAMIC_MODULE_LIMIT, 
+    soc = (so_server_conf *)apr_pcalloc(p, sizeof(so_server_conf));
+    soc->loaded_modules = apr_make_array(p, DYNAMIC_MODULE_LIMIT, 
                                      sizeof(moduleinfo));
 
     return (void *)soc;
@@ -170,9 +170,9 @@ static void *so_sconf_create(ap_pool_t *p, server_rec *s)
  * This is called as a cleanup function from the core.
  */
 
-static ap_status_t unload_module(void *data)
+static apr_status_t unload_module(void *data)
 {
-    ap_status_t status;
+    apr_status_t status;
     moduleinfo *modi = (moduleinfo*)data;
 
     /* only unload if module information is still existing */
@@ -183,7 +183,7 @@ static ap_status_t unload_module(void *data)
     ap_remove_loaded_module(modi->modp);
 
     /* unload the module space itself */
-    if ((status = ap_dso_unload(modi->modp->dynamic_load_handle)) != APR_SUCCESS) {
+    if ((status = apr_dso_unload(modi->modp->dynamic_load_handle)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, 0, NULL,
 		     "dso unload failure");
         return status;
@@ -202,11 +202,11 @@ static ap_status_t unload_module(void *data)
  * or include the filename in error message.
  */
 
-static ap_status_t unload_file(void *handle)
+static apr_status_t unload_file(void *handle)
 {
-    ap_status_t status;
+    apr_status_t status;
     
-    if ((status = ap_dso_unload((ap_dso_handle_t *)handle)) != APR_SUCCESS)
+    if ((status = apr_dso_unload((apr_dso_handle_t *)handle)) != APR_SUCCESS)
         return status;
     return APR_SUCCESS;
 }
@@ -219,9 +219,9 @@ static ap_status_t unload_file(void *handle)
 static const char *load_module(cmd_parms *cmd, void *dummy, 
                                const char *modname, const char *filename)
 {
-    ap_status_t status;
-    ap_dso_handle_t *modhandle;
-    ap_dso_handle_sym_t modsym;
+    apr_status_t status;
+    apr_dso_handle_t *modhandle;
+    apr_dso_handle_sym_t modsym;
     module *modp;
     const char *szModuleFile=ap_server_root_relative(cmd->pool, filename);
     so_server_conf *sconf;
@@ -247,18 +247,18 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
         if (modi->name != NULL && strcmp(modi->name, modname) == 0)
             return NULL;
     }
-    modi = ap_push_array(sconf->loaded_modules);
+    modi = apr_push_array(sconf->loaded_modules);
     modi->name = modname;
 
     /*
      * Load the file into the Apache address space
      */
-    if ((status = ap_dso_load(&modhandle, szModuleFile, cmd->pool )) != APR_SUCCESS) {
+    if ((status = apr_dso_load(&modhandle, szModuleFile, cmd->pool )) != APR_SUCCESS) {
         char my_error[256];
 
-        return ap_pstrcat(cmd->pool, "Cannot load ", szModuleFile,
+        return apr_pstrcat(cmd->pool, "Cannot load ", szModuleFile,
 			  " into server: ",
-			  ap_dso_error(modhandle, my_error, sizeof(my_error)),
+			  apr_dso_error(modhandle, my_error, sizeof(my_error)),
 			  NULL);
     }
     ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
@@ -269,16 +269,16 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
      * First with the hidden variant (prefix `AP_') and then with the plain
      * symbol name.
      */
-    if ((status = ap_dso_sym(&modsym, modhandle, modname)) != APR_SUCCESS) {
+    if ((status = apr_dso_sym(&modsym, modhandle, modname)) != APR_SUCCESS) {
         char my_error[256];
 
-	return ap_pstrcat(cmd->pool, "Can't locate API module structure `",
+	return apr_pstrcat(cmd->pool, "Can't locate API module structure `",
 			  modname, "' in file ", szModuleFile, ": ", 
-			  ap_dso_error(modhandle, my_error, sizeof(my_error)),
+			  apr_dso_error(modhandle, my_error, sizeof(my_error)),
 			  NULL);
     }
     modp = (module*) modsym;
-    modp->dynamic_load_handle = (ap_dso_handle_t *)modhandle;
+    modp->dynamic_load_handle = (apr_dso_handle_t *)modhandle;
     modi->modp = modp;
 
     /* 
@@ -286,7 +286,7 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
      * 
      */
     if (modp->magic != MODULE_MAGIC_COOKIE) {
-        return ap_pstrcat(cmd->pool, "API module structure `", modname,
+        return apr_pstrcat(cmd->pool, "API module structure `", modname,
                           "' in file ", szModuleFile, " is garbled -"
                           " perhaps this is not an Apache module DSO?", NULL);
     }
@@ -297,11 +297,11 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
     ap_add_loaded_module(modp);
 
     /* 
-     * Register a cleanup in the config ap_pool_t (normally pconf). When
+     * Register a cleanup in the config apr_pool_t (normally pconf). When
      * we do a restart (or shutdown) this cleanup will cause the
      * shared object to be unloaded.
      */
-    ap_register_cleanup(cmd->pool, modi, unload_module, ap_null_cleanup);
+    apr_register_cleanup(cmd->pool, modi, unload_module, apr_null_cleanup);
 
     /* 
      * Finally we need to run the configuration process for the module
@@ -318,25 +318,25 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
 
 static const char *load_file(cmd_parms *cmd, void *dummy, const char *filename)
 {
-    ap_status_t status;
-    ap_dso_handle_t *handle;
+    apr_status_t status;
+    apr_dso_handle_t *handle;
     const char *file;
 
     file = ap_server_root_relative(cmd->pool, filename);
     
-    if ((status = ap_dso_load(&handle, file, cmd->pool)) != APR_SUCCESS) {
+    if ((status = apr_dso_load(&handle, file, cmd->pool)) != APR_SUCCESS) {
         char my_error[256];
 
-	return ap_pstrcat(cmd->pool, "Cannot load ", filename, 
+	return apr_pstrcat(cmd->pool, "Cannot load ", filename, 
 			  " into server: ", 
-			  ap_strerror(status, my_error, sizeof(my_error)),
+			  apr_strerror(status, my_error, sizeof(my_error)),
 			  NULL);
     }
     
     ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
 		 "loaded file %s", filename);
 
-    ap_register_cleanup(cmd->pool, (void *)handle, unload_file, ap_null_cleanup);
+    apr_register_cleanup(cmd->pool, (void *)handle, unload_file, apr_null_cleanup);
 
     return NULL;
 }
@@ -374,7 +374,7 @@ module MODULE_VAR_EXPORT so_module = {
    NULL,			    /* merge per-dir config */
    so_sconf_create,		/* server config */
    NULL,			    /* merge server config */
-   so_cmds,			    /* command ap_table_t */
+   so_cmds,			    /* command apr_table_t */
    NULL,			    /* handlers */
    NULL				    /* register hooks */
 };
diff --git a/modules/mappers/mod_speling.c b/modules/mappers/mod_speling.c
index 62fd5b1..b7afc44 100644
--- a/modules/mappers/mod_speling.c
+++ b/modules/mappers/mod_speling.c
@@ -103,9 +103,9 @@ typedef struct {
  * bother to have such a function.
  */
 
-static void *mkconfig(ap_pool_t *p)
+static void *mkconfig(apr_pool_t *p)
 {
-    spconfig *cfg = ap_pcalloc(p, sizeof(spconfig));
+    spconfig *cfg = apr_pcalloc(p, sizeof(spconfig));
 
     cfg->enabled = 0;
     return cfg;
@@ -115,7 +115,7 @@ static void *mkconfig(ap_pool_t *p)
  * Respond to a callback to create configuration record for a server or
  * vhost environment.
  */
-static void *create_mconfig_for_server(ap_pool_t *p, server_rec *s)
+static void *create_mconfig_for_server(apr_pool_t *p, server_rec *s)
 {
     return mkconfig(p);
 }
@@ -123,7 +123,7 @@ static void *create_mconfig_for_server(ap_pool_t *p, server_rec *s)
 /*
  * Respond to a callback to create a config record for a specific directory.
  */
-static void *create_mconfig_for_directory(ap_pool_t *p, char *dir)
+static void *create_mconfig_for_directory(apr_pool_t *p, char *dir)
 {
     return mkconfig(p);
 }
@@ -234,8 +234,8 @@ static int check_speling(request_rec *r)
     spconfig *cfg;
     char *good, *bad, *postgood, *url, *fname;
     int filoc, dotloc, urlen, pglen;
-    ap_array_header_t *candidates = NULL;
-    ap_dir_t          *dir;
+    apr_array_header_t *candidates = NULL;
+    apr_dir_t          *dir;
 
     cfg = ap_get_module_config(r->per_dir_config, &speling_module);
     if (!cfg->enabled) {
@@ -275,11 +275,11 @@ static int check_speling(request_rec *r)
     }
 
     /* good = /correct-file */
-    good = ap_pstrndup(r->pool, r->filename, filoc);
+    good = apr_pstrndup(r->pool, r->filename, filoc);
     /* bad = mispelling */
-    bad = ap_pstrdup(r->pool, r->filename + filoc + 1);
+    bad = apr_pstrdup(r->pool, r->filename + filoc + 1);
     /* postgood = mispelling/more */
-    postgood = ap_pstrcat(r->pool, bad, r->path_info, NULL);
+    postgood = apr_pstrcat(r->pool, bad, r->path_info, NULL);
 
     urlen = strlen(r->uri);
     pglen = strlen(postgood);
@@ -290,27 +290,27 @@ static int check_speling(request_rec *r)
     }
 
     /* url = /correct-url */
-    url = ap_pstrndup(r->pool, r->uri, (urlen - pglen));
+    url = apr_pstrndup(r->pool, r->uri, (urlen - pglen));
 
     /* Now open the directory and do ourselves a check... */
-    if (ap_opendir(&dir, good, r->pool) != APR_SUCCESS) {
+    if (apr_opendir(&dir, good, r->pool) != APR_SUCCESS) {
         /* Oops, not a directory... */
         return DECLINED;
     }
 
-    candidates = ap_make_array(r->pool, 2, sizeof(misspelled_file));
+    candidates = apr_make_array(r->pool, 2, sizeof(misspelled_file));
 
     dotloc = ap_ind(bad, '.');
     if (dotloc == -1) {
         dotloc = strlen(bad);
     }
 
-    /* NOTE: ap_get_dir_filename() fills fname with a ap_palloc()ed copy
+    /* NOTE: apr_get_dir_filename() fills fname with a apr_palloc()ed copy
      * of the found directory name already. We don't need to copy it.
      * @@@: Copying *ALL* found file names is wasted energy (and memory)!
      */
-    while (ap_readdir(dir) == APR_SUCCESS &&
-	   ap_get_dir_filename(&fname, dir) == APR_SUCCESS) {
+    while (apr_readdir(dir) == APR_SUCCESS &&
+	   apr_get_dir_filename(&fname, dir) == APR_SUCCESS) {
         sp_reason q;
 
         /*
@@ -319,7 +319,7 @@ static int check_speling(request_rec *r)
          * Do _not_ try to redirect this, it causes a loop!
          */
         if (strcmp(bad, fname) == 0) {
-            ap_closedir(dir);
+            apr_closedir(dir);
             return OK;
         }
 
@@ -330,7 +330,7 @@ static int check_speling(request_rec *r)
         else if (strcasecmp(bad, fname) == 0) {
             misspelled_file *sp_new;
 
-	    sp_new = (misspelled_file *) ap_push_array(candidates);
+	    sp_new = (misspelled_file *) apr_push_array(candidates);
             sp_new->name = fname;
             sp_new->quality = SP_MISCAPITALIZED;
         }
@@ -342,7 +342,7 @@ static int check_speling(request_rec *r)
         else if ((q = spdist(bad, fname)) != SP_VERYDIFFERENT) {
             misspelled_file *sp_new;
 
-	    sp_new = (misspelled_file *) ap_push_array(candidates);
+	    sp_new = (misspelled_file *) apr_push_array(candidates);
             sp_new->name = fname;
             sp_new->quality = q;
         }
@@ -388,14 +388,14 @@ static int check_speling(request_rec *r)
                 && !strncasecmp(bad, fname, dotloc)) {
                 misspelled_file *sp_new;
 
-		sp_new = (misspelled_file *) ap_push_array(candidates);
+		sp_new = (misspelled_file *) apr_push_array(candidates);
                 sp_new->name = fname;
                 sp_new->quality = SP_VERYDIFFERENT;
             }
 #endif
         }
     }
-    ap_closedir(dir);
+    apr_closedir(dir);
 
     if (candidates->nelts != 0) {
         /* Wow... we found us a mispelling. Construct a fixed url */
@@ -404,7 +404,7 @@ static int check_speling(request_rec *r)
         misspelled_file *variant = (misspelled_file *) candidates->elts;
         int i;
 
-        ref = ap_table_get(r->headers_in, "Referer");
+        ref = apr_table_get(r->headers_in, "Referer");
 
         qsort((void *) candidates->elts, candidates->nelts,
               sizeof(misspelled_file), sort_by_quality);
@@ -420,13 +420,13 @@ static int check_speling(request_rec *r)
 	    && (candidates->nelts == 1
 		|| variant[0].quality != variant[1].quality)) {
 
-            nuri = ap_escape_uri(r->pool, ap_pstrcat(r->pool, url,
+            nuri = ap_escape_uri(r->pool, apr_pstrcat(r->pool, url,
 						     variant[0].name,
 						     r->path_info, NULL));
 	    if (r->parsed_uri.query)
-		nuri = ap_pstrcat(r->pool, nuri, "?", r->parsed_uri.query, NULL);
+		nuri = apr_pstrcat(r->pool, nuri, "?", r->parsed_uri.query, NULL);
 
-            ap_table_setn(r->headers_out, "Location",
+            apr_table_setn(r->headers_out, "Location",
 			  ap_construct_url(r->pool, nuri, r));
 
             ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_INFO, APR_SUCCESS,
@@ -442,11 +442,11 @@ static int check_speling(request_rec *r)
          * returned.
          */
         else {
-            ap_pool_t *p;
-            ap_table_t *notes;
-	    ap_pool_t *sub_pool;
-	    ap_array_header_t *t;
-	    ap_array_header_t *v;
+            apr_pool_t *p;
+            apr_table_t *notes;
+	    apr_pool_t *sub_pool;
+	    apr_array_header_t *t;
+	    apr_array_header_t *v;
 
 
             if (r->main == NULL) {
@@ -458,20 +458,20 @@ static int check_speling(request_rec *r)
                 notes = r->main->notes;
             }
 
-	    if (ap_create_pool(&sub_pool, p) != APR_SUCCESS)
+	    if (apr_create_pool(&sub_pool, p) != APR_SUCCESS)
 		return DECLINED;
 
-	    t = ap_make_array(sub_pool, candidates->nelts * 8 + 8,
+	    t = apr_make_array(sub_pool, candidates->nelts * 8 + 8,
 			      sizeof(char *));
-	    v = ap_make_array(sub_pool, candidates->nelts * 5,
+	    v = apr_make_array(sub_pool, candidates->nelts * 5,
 			      sizeof(char *));
 
             /* Generate the response text. */
 
-	    *(const char **)ap_push_array(t) =
+	    *(const char **)apr_push_array(t) =
 			  "The document name you requested (<code>";
-	    *(const char **)ap_push_array(t) = ap_escape_html(sub_pool, r->uri);
-	    *(const char **)ap_push_array(t) =
+	    *(const char **)apr_push_array(t) = ap_escape_html(sub_pool, r->uri);
+	    *(const char **)apr_push_array(t) =
 			   "</code>) could not be found on this server.\n"
 			   "However, we found documents with names similar "
 			   "to the one you requested.<p>"
@@ -483,24 +483,24 @@ static int check_speling(request_rec *r)
 
 		reason = sp_reason_str[(int) (variant[i].quality)];
                 /* The format isn't very neat... */
-		vuri = ap_pstrcat(sub_pool, url, variant[i].name, r->path_info,
+		vuri = apr_pstrcat(sub_pool, url, variant[i].name, r->path_info,
 				  (r->parsed_uri.query != NULL) ? "?" : "",
 				  (r->parsed_uri.query != NULL)
 				      ? r->parsed_uri.query : "",
 				  NULL);
-		*(const char **)ap_push_array(v) = "\"";
-		*(const char **)ap_push_array(v) = ap_escape_uri(sub_pool, vuri);
-		*(const char **)ap_push_array(v) = "\";\"";
-		*(const char **)ap_push_array(v) = reason;
-		*(const char **)ap_push_array(v) = "\"";
-
-		*(const char **)ap_push_array(t) = "<li><a href=\"";
-		*(const char **)ap_push_array(t) = ap_escape_uri(sub_pool, vuri);
-		*(const char **)ap_push_array(t) = "\">";
-		*(const char **)ap_push_array(t) = ap_escape_html(sub_pool, vuri);
-		*(const char **)ap_push_array(t) = "</a> (";
-		*(const char **)ap_push_array(t) = reason;
-		*(const char **)ap_push_array(t) = ")\n";
+		*(const char **)apr_push_array(v) = "\"";
+		*(const char **)apr_push_array(v) = ap_escape_uri(sub_pool, vuri);
+		*(const char **)apr_push_array(v) = "\";\"";
+		*(const char **)apr_push_array(v) = reason;
+		*(const char **)apr_push_array(v) = "\"";
+
+		*(const char **)apr_push_array(t) = "<li><a href=\"";
+		*(const char **)apr_push_array(t) = ap_escape_uri(sub_pool, vuri);
+		*(const char **)apr_push_array(t) = "\">";
+		*(const char **)apr_push_array(t) = ap_escape_html(sub_pool, vuri);
+		*(const char **)apr_push_array(t) = "</a> (";
+		*(const char **)apr_push_array(t) = reason;
+		*(const char **)apr_push_array(t) = ")\n";
 
                 /*
                  * when we have printed the "close matches" and there are
@@ -512,31 +512,31 @@ static int check_speling(request_rec *r)
                 if (i > 0 && i < candidates->nelts - 1
                     && variant[i].quality != SP_VERYDIFFERENT
                     && variant[i + 1].quality == SP_VERYDIFFERENT) {
-		    *(const char **)ap_push_array(t) = 
+		    *(const char **)apr_push_array(t) = 
 				   "</ul>\nFurthermore, the following related "
 				   "documents were found:\n<ul>\n";
                 }
             }
-	    *(const char **)ap_push_array(t) = "</ul>\n";
+	    *(const char **)apr_push_array(t) = "</ul>\n";
 
             /* If we know there was a referring page, add a note: */
             if (ref != NULL) {
-                *(const char **)ap_push_array(t) =
+                *(const char **)apr_push_array(t) =
 			       "Please consider informing the owner of the "
 			       "<a href=\"";
-		*(const char **)ap_push_array(t) = ap_escape_uri(sub_pool, ref);
-                *(const char **)ap_push_array(t) = "\">referring page</a> "
+		*(const char **)apr_push_array(t) = ap_escape_uri(sub_pool, ref);
+                *(const char **)apr_push_array(t) = "\">referring page</a> "
 			       "about the broken link.\n";
 	    }
 
 
-            /* Pass our ap_table_t to http_protocol.c (see mod_negotiation): */
-            ap_table_setn(notes, "variant-list", ap_array_pstrcat(p, t, 0));
+            /* Pass our apr_table_t to http_protocol.c (see mod_negotiation): */
+            apr_table_setn(notes, "variant-list", apr_array_pstrcat(p, t, 0));
 
-	    ap_table_mergen(r->subprocess_env, "VARIANTS",
-			    ap_array_pstrcat(p, v, ','));
+	    apr_table_mergen(r->subprocess_env, "VARIANTS",
+			    apr_array_pstrcat(p, v, ','));
 	  
-	    ap_destroy_pool(sub_pool);
+	    apr_destroy_pool(sub_pool);
 
             ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_INFO, 0, r,
 			 ref ? "Spelling fix: %s: %d candidates from %s"
@@ -562,7 +562,7 @@ module MODULE_VAR_EXPORT speling_module =
     NULL,                       /* merge per-dir config */
     create_mconfig_for_server,  /* server config */
     NULL,                       /* merge server config */
-    speling_cmds,               /* command ap_table_t */
+    speling_cmds,               /* command apr_table_t */
     NULL,                       /* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/mappers/mod_userdir.c b/modules/mappers/mod_userdir.c
index ce44971..2843791 100644
--- a/modules/mappers/mod_userdir.c
+++ b/modules/mappers/mod_userdir.c
@@ -113,8 +113,8 @@ module userdir_module;
 typedef struct userdir_config {
     int globally_disabled;
     char *userdir;
-    ap_table_t *enabled_users;
-    ap_table_t *disabled_users;
+    apr_table_t *enabled_users;
+    apr_table_t *disabled_users;
 }              userdir_config;
 
 /*
@@ -123,15 +123,15 @@ typedef struct userdir_config {
  * explicit) disablement, and the replacement string for all others.
  */
 
-static void *create_userdir_config(ap_pool_t *p, server_rec *s)
+static void *create_userdir_config(apr_pool_t *p, server_rec *s)
 {
     userdir_config
-    * newcfg = (userdir_config *) ap_pcalloc(p, sizeof(userdir_config));
+    * newcfg = (userdir_config *) apr_pcalloc(p, sizeof(userdir_config));
 
     newcfg->globally_disabled = 0;
     newcfg->userdir = DEFAULT_USER_DIR;
-    newcfg->enabled_users = ap_make_table(p, 4);
-    newcfg->disabled_users = ap_make_table(p, 4);
+    newcfg->enabled_users = apr_make_table(p, 4);
+    newcfg->disabled_users = apr_make_table(p, 4);
     return (void *) newcfg;
 }
 
@@ -151,7 +151,7 @@ static const char *set_user_dir(cmd_parms *cmd, void *dummy, const char *arg)
     const char
         *usernames = arg;
     char *kw = ap_getword_conf(cmd->pool, &usernames);
-    ap_table_t *usertable;
+    apr_table_t *usertable;
 
     /*
      * Let's do the comparisons once.
@@ -183,7 +183,7 @@ static const char *set_user_dir(cmd_parms *cmd, void *dummy, const char *arg)
          * If the first (only?) value isn't one of our keywords, just copy
          * the string to the userdir string.
          */
-        s_cfg->userdir = ap_pstrdup(cmd->pool, arg);
+        s_cfg->userdir = apr_pstrdup(cmd->pool, arg);
         return NULL;
     }
     /*
@@ -192,7 +192,7 @@ static const char *set_user_dir(cmd_parms *cmd, void *dummy, const char *arg)
      */
     while (*usernames) {
         username = ap_getword_conf(cmd->pool, &usernames);
-        ap_table_setn(usertable, username, kw);
+        apr_table_setn(usertable, username, kw);
     }
     return NULL;
 }
@@ -215,7 +215,7 @@ static int translate_userdir(request_rec *r)
     const char *w, *dname;
     char *redirect;
     char *x = NULL;
-    ap_finfo_t statbuf;
+    apr_finfo_t statbuf;
 
     /*
      * If the URI doesn't match our basic pattern, we've nothing to do with
@@ -252,7 +252,7 @@ static int translate_userdir(request_rec *r)
     /*
      * Nor if there's an username but it's in the disabled list.
      */
-    if (ap_table_get(s_cfg->disabled_users, w) != NULL) {
+    if (apr_table_get(s_cfg->disabled_users, w) != NULL) {
         return DECLINED;
     }
     /*
@@ -261,7 +261,7 @@ static int translate_userdir(request_rec *r)
      */
     if (
         s_cfg->globally_disabled &&
-        (ap_table_get(s_cfg->enabled_users, w) == NULL)
+        (apr_table_get(s_cfg->enabled_users, w) == NULL)
         ) {
         return DECLINED;
     }
@@ -291,19 +291,19 @@ static int translate_userdir(request_rec *r)
                 if (strchr(x, ':'))
 #endif                          /* WIN32 */
 		{
-                    redirect = ap_pstrcat(r->pool, x, w, userdir, dname, NULL);
-                    ap_table_setn(r->headers_out, "Location", redirect);
+                    redirect = apr_pstrcat(r->pool, x, w, userdir, dname, NULL);
+                    apr_table_setn(r->headers_out, "Location", redirect);
                     return HTTP_MOVED_TEMPORARILY;
                 }
                 else
-                    filename = ap_pstrcat(r->pool, x, w, userdir, NULL);
+                    filename = apr_pstrcat(r->pool, x, w, userdir, NULL);
             }
             else
-                filename = ap_pstrcat(r->pool, userdir, "/", w, NULL);
+                filename = apr_pstrcat(r->pool, userdir, "/", w, NULL);
         }
         else if (ap_strchr_c(userdir, ':')) {
-            redirect = ap_pstrcat(r->pool, userdir, "/", w, dname, NULL);
-            ap_table_setn(r->headers_out, "Location", redirect);
+            redirect = apr_pstrcat(r->pool, userdir, "/", w, dname, NULL);
+            apr_table_setn(r->headers_out, "Location", redirect);
             return HTTP_MOVED_TEMPORARILY;
         }
         else {
@@ -315,9 +315,9 @@ static int translate_userdir(request_rec *r)
             if ((pw = getpwnam(w))) {
 #ifdef OS2
                 /* Need to manually add user name for OS/2 */
-                filename = ap_pstrcat(r->pool, pw->pw_dir, w, "/", userdir, NULL);
+                filename = apr_pstrcat(r->pool, pw->pw_dir, w, "/", userdir, NULL);
 #else
-                filename = ap_pstrcat(r->pool, pw->pw_dir, "/", userdir, NULL);
+                filename = apr_pstrcat(r->pool, pw->pw_dir, "/", userdir, NULL);
 #endif
             }
 #endif                          /* WIN32 */
@@ -330,8 +330,8 @@ static int translate_userdir(request_rec *r)
          * used, for example, to run a CGI script for the user.
          */
         if (filename && (!*userdirs || 
-            ap_stat(&statbuf, filename, r->pool) == APR_SUCCESS)) {
-            r->filename = ap_pstrcat(r->pool, filename, dname, NULL);
+            apr_stat(&statbuf, filename, r->pool) == APR_SUCCESS)) {
+            r->filename = apr_pstrcat(r->pool, filename, dname, NULL);
 	    /* when statbuf contains info on r->filename we can save a syscall
 	     * by copying it to r->finfo
 	     */
@@ -357,7 +357,7 @@ module userdir_module = {
     NULL,                       /* dir merger --- default is to override */
     create_userdir_config,      /* server config */
     NULL,                       /* merge server config */
-    userdir_cmds,               /* command ap_table_t */
+    userdir_cmds,               /* command apr_table_t */
     NULL,                       /* handlers */
     register_hooks              /* register hooks */
 };
diff --git a/modules/mappers/mod_vhost_alias.c b/modules/mappers/mod_vhost_alias.c
index 1340e87..7b9fc24 100644
--- a/modules/mappers/mod_vhost_alias.c
+++ b/modules/mappers/mod_vhost_alias.c
@@ -104,11 +104,11 @@ typedef struct mva_sconf_t {
     mva_mode_e cgi_root_mode;
 } mva_sconf_t;
 
-static void *mva_create_server_config(ap_pool_t *p, server_rec *s)
+static void *mva_create_server_config(apr_pool_t *p, server_rec *s)
 {
     mva_sconf_t *conf;
 
-    conf = (mva_sconf_t *) ap_pcalloc(p, sizeof(mva_sconf_t));
+    conf = (mva_sconf_t *) apr_pcalloc(p, sizeof(mva_sconf_t));
     conf->doc_root = NULL;
     conf->cgi_root = NULL;
     conf->doc_root_mode = VHOST_ALIAS_UNSET;
@@ -116,13 +116,13 @@ static void *mva_create_server_config(ap_pool_t *p, server_rec *s)
     return conf;
 }
 
-static void *mva_merge_server_config(ap_pool_t *p, void *parentv, void *childv)
+static void *mva_merge_server_config(apr_pool_t *p, void *parentv, void *childv)
 {
     mva_sconf_t *parent = (mva_sconf_t *) parentv;
     mva_sconf_t *child = (mva_sconf_t *) childv;
     mva_sconf_t *conf;
 
-    conf = (mva_sconf_t *) ap_pcalloc(p, sizeof(*conf));
+    conf = (mva_sconf_t *) apr_pcalloc(p, sizeof(*conf));
     if (child->doc_root_mode == VHOST_ALIAS_UNSET) {
 	conf->doc_root_mode = parent->doc_root_mode;
 	conf->doc_root = parent->doc_root;
@@ -272,10 +272,10 @@ static ap_inline void vhost_alias_checkspace(request_rec *r, char *buf,
     if (*pdest + size > buf + HUGE_STRING_LEN) {
 	**pdest = '\0';
 	if (r->filename) {
-	    r->filename = ap_pstrcat(r->pool, r->filename, buf, NULL);
+	    r->filename = apr_pstrcat(r->pool, r->filename, buf, NULL);
 	}
 	else {
-	    r->filename = ap_pstrdup(r->pool, buf);
+	    r->filename = apr_pstrdup(r->pool, buf);
 	}
 	*pdest = buf;
     }
@@ -333,7 +333,7 @@ static void vhost_alias_interpolate(request_rec *r, const char *name,
 	    ++map;
 	    /* no. of decimal digits in a short plus one */
 	    vhost_alias_checkspace(r, buf, &dest, 7);
-	    dest += ap_snprintf(dest, 7, "%d", ap_get_server_port(r));
+	    dest += apr_snprintf(dest, 7, "%d", ap_get_server_port(r));
 	    continue;
 	}
 	/* deal with %-N+.-M+ -- syntax is already checked */
@@ -403,10 +403,10 @@ static void vhost_alias_interpolate(request_rec *r, const char *name,
 	++uri;
     }
     if (r->filename) {
-	r->filename = ap_pstrcat(r->pool, r->filename, buf, uri, NULL);
+	r->filename = apr_pstrcat(r->pool, r->filename, buf, uri, NULL);
     }
     else {
-	r->filename = ap_pstrcat(r->pool, buf, uri, NULL);
+	r->filename = apr_pstrcat(r->pool, buf, uri, NULL);
     }
 }
 
@@ -452,7 +452,7 @@ static int mva_translate(request_rec *r)
     if (cgi) {
 	/* see is_scriptaliased() in mod_cgi */
 	r->handler = "cgi-script";
-	ap_table_setn(r->notes, "alias-forced-type", r->handler);
+	apr_table_setn(r->notes, "alias-forced-type", r->handler);
     }
 
     return OK;
@@ -470,7 +470,7 @@ module MODULE_VAR_EXPORT vhost_alias_module =
     NULL,			/* dir merger --- default is to override */
     mva_create_server_config,	/* server config */
     mva_merge_server_config,	/* merge server configs */
-    mva_commands,		/* command ap_table_t */
+    mva_commands,		/* command apr_table_t */
     NULL,			/* handlers */
     register_hooks              /* register hooks */
 };
diff --git a/modules/metadata/mod_cern_meta.c b/modules/metadata/mod_cern_meta.c
index 5900cfd..c0c36e7 100644
--- a/modules/metadata/mod_cern_meta.c
+++ b/modules/metadata/mod_cern_meta.c
@@ -175,10 +175,10 @@ typedef struct {
     char *metafiles;
 } cern_meta_dir_config;
 
-static void *create_cern_meta_dir_config(ap_pool_t *p, char *dummy)
+static void *create_cern_meta_dir_config(apr_pool_t *p, char *dummy)
 {
     cern_meta_dir_config *new =
-    (cern_meta_dir_config *) ap_palloc(p, sizeof(cern_meta_dir_config));
+    (cern_meta_dir_config *) apr_palloc(p, sizeof(cern_meta_dir_config));
 
     new->metadir = NULL;
     new->metasuffix = NULL;
@@ -187,12 +187,12 @@ static void *create_cern_meta_dir_config(ap_pool_t *p, char *dummy)
     return new;
 }
 
-static void *merge_cern_meta_dir_configs(ap_pool_t *p, void *basev, void *addv)
+static void *merge_cern_meta_dir_configs(apr_pool_t *p, void *basev, void *addv)
 {
     cern_meta_dir_config *base = (cern_meta_dir_config *) basev;
     cern_meta_dir_config *add = (cern_meta_dir_config *) addv;
     cern_meta_dir_config *new =
-    (cern_meta_dir_config *) ap_palloc(p, sizeof(cern_meta_dir_config));
+    (cern_meta_dir_config *) apr_palloc(p, sizeof(cern_meta_dir_config));
 
     new->metadir = add->metadir ? add->metadir : base->metadir;
     new->metasuffix = add->metasuffix ? add->metasuffix : base->metasuffix;
@@ -234,15 +234,15 @@ static const command_rec cern_meta_cmds[] =
 /* XXX: this is very similar to ap_scan_script_header_err_core...
  * are the differences deliberate, or just a result of bit rot?
  */
-static int scan_meta_file(request_rec *r, ap_file_t *f)
+static int scan_meta_file(request_rec *r, apr_file_t *f)
 {
     char w[MAX_STRING_LEN];
     char *l;
     int p;
-    ap_table_t *tmp_headers;
+    apr_table_t *tmp_headers;
 
-    tmp_headers = ap_make_table(r->pool, 5);
-    while (ap_fgets(w, MAX_STRING_LEN - 1, f) != APR_SUCCESS) {
+    tmp_headers = apr_make_table(r->pool, 5);
+    while (apr_fgets(w, MAX_STRING_LEN - 1, f) != APR_SUCCESS) {
 
 	/* Delete terminal (CR?)LF */
 
@@ -278,19 +278,19 @@ static int scan_meta_file(request_rec *r, ap_file_t *f)
 	    while (endp > l && ap_isspace(*endp))
 		*endp-- = '\0';
 
-	    tmp = ap_pstrdup(r->pool, l);
+	    tmp = apr_pstrdup(r->pool, l);
 	    ap_content_type_tolower(tmp);
 	    r->content_type = tmp;
 	}
 	else if (!strcasecmp(w, "Status")) {
 	    sscanf(l, "%d", &r->status);
-	    r->status_line = ap_pstrdup(r->pool, l);
+	    r->status_line = apr_pstrdup(r->pool, l);
 	}
 	else {
-	    ap_table_set(tmp_headers, w, l);
+	    apr_table_set(tmp_headers, w, l);
 	}
     }
-    ap_overlap_tables(r->headers_out, tmp_headers, AP_OVERLAP_TABLES_SET);
+    apr_overlap_tables(r->headers_out, tmp_headers, AP_OVERLAP_TABLES_SET);
     return OK;
 }
 
@@ -300,8 +300,8 @@ static int add_cern_meta_data(request_rec *r)
     char *last_slash;
     char *real_file;
     char *scrap_book;
-    ap_file_t *f = NULL;
-    ap_status_t retcode;
+    apr_file_t *f = NULL;
+    apr_status_t retcode;
     cern_meta_dir_config *dconf;
     int rv;
     request_rec *rr;
@@ -324,7 +324,7 @@ static int add_cern_meta_data(request_rec *r)
     };
 
     /* what directory is this file in? */
-    scrap_book = ap_pstrdup(r->pool, r->filename);
+    scrap_book = apr_pstrdup(r->pool, r->filename);
     /* skip leading slash, recovered in later processing */
     scrap_book++;
     last_slash = strrchr(scrap_book, '/');
@@ -342,7 +342,7 @@ static int add_cern_meta_data(request_rec *r)
 	return DECLINED;
     };
 
-    metafilename = ap_pstrcat(r->pool, "/", scrap_book, "/",
+    metafilename = apr_pstrcat(r->pool, "/", scrap_book, "/",
 			   dconf->metadir ? dconf->metadir : DEFAULT_METADIR,
 			   "/", real_file,
 		 dconf->metasuffix ? dconf->metasuffix : DEFAULT_METASUFFIX,
@@ -360,7 +360,7 @@ static int add_cern_meta_data(request_rec *r)
     }
     ap_destroy_sub_req(rr);
 
-    retcode = ap_open(&f, metafilename, APR_READ | APR_CREATE, APR_OS_DEFAULT, r->pool);
+    retcode = apr_open(&f, metafilename, APR_READ | APR_CREATE, APR_OS_DEFAULT, r->pool);
     if (retcode != APR_SUCCESS) {
 	if (errno == ENOENT) {
 	    return DECLINED;
@@ -372,7 +372,7 @@ static int add_cern_meta_data(request_rec *r)
 
     /* read the headers in */
     rv = scan_meta_file(r, f);
-    ap_close(f);
+    apr_close(f);
 
     return rv;
 }
@@ -387,7 +387,7 @@ module MODULE_VAR_EXPORT cern_meta_module =
     merge_cern_meta_dir_configs,/* dir merger --- default is to override */
     NULL,			/* server config */
     NULL,			/* merge server configs */
-    cern_meta_cmds,		/* command ap_table_t */
+    cern_meta_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/metadata/mod_env.c b/modules/metadata/mod_env.c
index 0eaf0d1..4f8f29b 100644
--- a/modules/metadata/mod_env.c
+++ b/modules/metadata/mod_env.c
@@ -68,7 +68,7 @@
  * 08.Dec.95 Now allows PassEnv directive to appear more than once in
  *           conf files.
  * 10.Dec.95 optimisation.  getenv() only called at startup and used 
- *           to build a fast-to-access table.  ap_table_t used to build 
+ *           to build a fast-to-access table.  apr_table_t used to build 
  *           per-server environment for each request.
  *           robustness.  better able to handle errors in configuration
  *           files:
@@ -109,33 +109,33 @@
 #endif
 
 typedef struct {
-    ap_table_t *vars;
+    apr_table_t *vars;
     const char *unsetenv;
     int vars_present;
 } env_dir_config_rec;
 
 module MODULE_VAR_EXPORT env_module;
 
-static void *create_env_dir_config(ap_pool_t *p, char *dummy)
+static void *create_env_dir_config(apr_pool_t *p, char *dummy)
 {
     env_dir_config_rec *new =
-    (env_dir_config_rec *) ap_palloc(p, sizeof(env_dir_config_rec));
-    new->vars = ap_make_table(p, 50);
+    (env_dir_config_rec *) apr_palloc(p, sizeof(env_dir_config_rec));
+    new->vars = apr_make_table(p, 50);
     new->unsetenv = "";
     new->vars_present = 0;
     return (void *) new;
 }
 
-static void *merge_env_dir_configs(ap_pool_t *p, void *basev, void *addv)
+static void *merge_env_dir_configs(apr_pool_t *p, void *basev, void *addv)
 {
     env_dir_config_rec *base = (env_dir_config_rec *) basev;
     env_dir_config_rec *add = (env_dir_config_rec *) addv;
     env_dir_config_rec *new =
-    (env_dir_config_rec *) ap_palloc(p, sizeof(env_dir_config_rec));
+    (env_dir_config_rec *) apr_palloc(p, sizeof(env_dir_config_rec));
 
-    ap_table_t *new_table;
-    ap_table_entry_t *elts;
-    ap_array_header_t *arr;
+    apr_table_t *new_table;
+    apr_table_entry_t *elts;
+    apr_array_header_t *arr;
 
     int i;
     const char *uenv, *unset;
@@ -150,19 +150,19 @@ static void *merge_env_dir_configs(ap_pool_t *p, void *basev, void *addv)
      * }
      */
 
-    new_table = ap_copy_table(p, base->vars);
+    new_table = apr_copy_table(p, base->vars);
 
     arr = ap_table_elts(add->vars);
-    elts = (ap_table_entry_t *)arr->elts;
+    elts = (apr_table_entry_t *)arr->elts;
 
     for (i = 0; i < arr->nelts; ++i) {
-        ap_table_setn(new_table, elts[i].key, elts[i].val);
+        apr_table_setn(new_table, elts[i].key, elts[i].val);
     }
 
     unset = add->unsetenv;
     uenv = ap_getword_conf(p, &unset);
     while (uenv[0] != '\0') {
-        ap_table_unset(new_table, uenv);
+        apr_table_unset(new_table, uenv);
         uenv = ap_getword_conf(p, &unset);
     }
 
@@ -177,7 +177,7 @@ static const char *add_env_module_vars_passed(cmd_parms *cmd, void *sconf_,
                                               const char *arg)
 {
     env_dir_config_rec *sconf=sconf_;
-    ap_table_t *vars = sconf->vars;
+    apr_table_t *vars = sconf->vars;
     char *env_var;
     char *name_ptr;
 
@@ -186,7 +186,7 @@ static const char *add_env_module_vars_passed(cmd_parms *cmd, void *sconf_,
         env_var = getenv(name_ptr);
         if (env_var != NULL) {
             sconf->vars_present = 1;
-            ap_table_setn(vars, name_ptr, ap_pstrdup(cmd->pool, env_var));
+            apr_table_setn(vars, name_ptr, apr_pstrdup(cmd->pool, env_var));
         }
     }
     return NULL;
@@ -196,7 +196,7 @@ static const char *add_env_module_vars_set(cmd_parms *cmd, void *sconf_,
                                            const char *arg)
 {
     env_dir_config_rec *sconf=sconf_;
-    ap_table_t *vars = sconf->vars;
+    apr_table_t *vars = sconf->vars;
     char *name, *value;
 
     name = ap_getword_conf(cmd->pool, &arg);
@@ -212,7 +212,7 @@ static const char *add_env_module_vars_set(cmd_parms *cmd, void *sconf_,
     }
 
     sconf->vars_present = 1;
-    ap_table_setn(vars, name, value);
+    apr_table_setn(vars, name, value);
 
     return NULL;
 }
@@ -223,7 +223,7 @@ static const char *add_env_module_vars_unset(cmd_parms *cmd, void *sconf_,
     env_dir_config_rec *sconf=sconf_;
 
     sconf->unsetenv = sconf->unsetenv ?
-        ap_pstrcat(cmd->pool, sconf->unsetenv, " ", arg, NULL) :
+        apr_pstrcat(cmd->pool, sconf->unsetenv, " ", arg, NULL) :
          arg;
     return NULL;
 }
@@ -241,15 +241,15 @@ AP_INIT_RAW_ARGS("UnsetEnv", add_env_module_vars_unset, NULL,
 
 static int fixup_env_module(request_rec *r)
 {
-    ap_table_t *e = r->subprocess_env;
+    apr_table_t *e = r->subprocess_env;
     env_dir_config_rec *sconf = ap_get_module_config(r->per_dir_config,
                                                      &env_module);
-    ap_table_t *vars = sconf->vars;
+    apr_table_t *vars = sconf->vars;
 
     if (!sconf->vars_present)
         return DECLINED;
 
-    r->subprocess_env = ap_overlay_tables(r->pool, e, vars);
+    r->subprocess_env = apr_overlay_tables(r->pool, e, vars);
 
     return OK;
 }
@@ -267,7 +267,7 @@ module MODULE_VAR_EXPORT env_module =
     merge_env_dir_configs,      /* dir merger --- default is to override */
     NULL,                       /* server config */
     NULL,                       /* merge server configs */
-    env_module_cmds,            /* command ap_table_t */
+    env_module_cmds,            /* command apr_table_t */
     NULL,                       /* handlers */
     register_hooks              /* register hooks */
 };
diff --git a/modules/metadata/mod_expires.c b/modules/metadata/mod_expires.c
index e89073c..9b6bb2a 100644
--- a/modules/metadata/mod_expires.c
+++ b/modules/metadata/mod_expires.c
@@ -206,7 +206,7 @@
 typedef struct {
     int active;
     char *expiresdefault;
-    ap_table_t *expiresbytype;
+    apr_table_t *expiresbytype;
 } expires_dir_config;
 
 /* from mod_dir, why is this alias used?
@@ -219,13 +219,13 @@ typedef struct {
 
 module MODULE_VAR_EXPORT expires_module;
 
-static void *create_dir_expires_config(ap_pool_t *p, char *dummy)
+static void *create_dir_expires_config(apr_pool_t *p, char *dummy)
 {
     expires_dir_config *new =
-    (expires_dir_config *) ap_pcalloc(p, sizeof(expires_dir_config));
+    (expires_dir_config *) apr_pcalloc(p, sizeof(expires_dir_config));
     new->active = ACTIVE_DONTCARE;
     new->expiresdefault = "";
-    new->expiresbytype = ap_make_table(p, 4);
+    new->expiresbytype = apr_make_table(p, 4);
     return (void *) new;
 }
 
@@ -245,7 +245,7 @@ static const char *set_expiresactive(cmd_parms *cmd, expires_dir_config * dir_co
  * string.  If we return NULL then real_code contains code converted
  * to the cnnnn format.
  */
-static char *check_code(ap_pool_t *p, const char *code, char **real_code)
+static char *check_code(apr_pool_t *p, const char *code, char **real_code)
 {
     char *word;
     char base = 'X';
@@ -274,7 +274,7 @@ static char *check_code(ap_pool_t *p, const char *code, char **real_code)
         base = 'M';
     }
     else {
-        return ap_pstrcat(p, "bad expires code, unrecognised <base> '",
+        return apr_pstrcat(p, "bad expires code, unrecognised <base> '",
                        word, "'", NULL);
     };
 
@@ -294,7 +294,7 @@ static char *check_code(ap_pool_t *p, const char *code, char **real_code)
             num = atoi(word);
         }
         else {
-            return ap_pstrcat(p, "bad expires code, numeric value expected <num> '",
+            return apr_pstrcat(p, "bad expires code, numeric value expected <num> '",
                            word, "'", NULL);
         };
 
@@ -305,7 +305,7 @@ static char *check_code(ap_pool_t *p, const char *code, char **real_code)
             /* do nothing */
         }
         else {
-            return ap_pstrcat(p, "bad expires code, missing <type>", NULL);
+            return apr_pstrcat(p, "bad expires code, missing <type>", NULL);
         };
 
         factor = 0;
@@ -331,7 +331,7 @@ static char *check_code(ap_pool_t *p, const char *code, char **real_code)
             factor = 1;
         }
         else {
-            return ap_pstrcat(p, "bad expires code, unrecognised <type>",
+            return apr_pstrcat(p, "bad expires code, unrecognised <type>",
                            "'", word, "'", NULL);
         };
 
@@ -342,7 +342,7 @@ static char *check_code(ap_pool_t *p, const char *code, char **real_code)
         word = ap_getword_conf(p, &code);
     };
 
-    *real_code = ap_psprintf(p, "%c%d", base, modifier);
+    *real_code = apr_psprintf(p, "%c%d", base, modifier);
 
     return NULL;
 }
@@ -352,10 +352,10 @@ static const char *set_expiresbytype(cmd_parms *cmd, expires_dir_config * dir_co
     char *response, *real_code;
 
     if ((response = check_code(cmd->pool, code, &real_code)) == NULL) {
-        ap_table_setn(dir_config->expiresbytype, mime, real_code);
+        apr_table_setn(dir_config->expiresbytype, mime, real_code);
         return NULL;
     };
-    return ap_pstrcat(cmd->pool,
+    return apr_pstrcat(cmd->pool,
                  "'ExpiresByType ", mime, " ", code, "': ", response, NULL);
 }
 
@@ -367,7 +367,7 @@ static const char *set_expiresdefault(cmd_parms *cmd, expires_dir_config * dir_c
         dir_config->expiresdefault = real_code;
         return NULL;
     };
-    return ap_pstrcat(cmd->pool,
+    return apr_pstrcat(cmd->pool,
                    "'ExpiresDefault ", code, "': ", response, NULL);
 }
 
@@ -382,9 +382,9 @@ static const command_rec expires_cmds[] =
     {NULL}
 };
 
-static void *merge_expires_dir_configs(ap_pool_t *p, void *basev, void *addv)
+static void *merge_expires_dir_configs(apr_pool_t *p, void *basev, void *addv)
 {
-    expires_dir_config *new = (expires_dir_config *) ap_pcalloc(p, sizeof(expires_dir_config));
+    expires_dir_config *new = (expires_dir_config *) apr_pcalloc(p, sizeof(expires_dir_config));
     expires_dir_config *base = (expires_dir_config *) basev;
     expires_dir_config *add = (expires_dir_config *) addv;
 
@@ -399,7 +399,7 @@ static void *merge_expires_dir_configs(ap_pool_t *p, void *basev, void *addv)
         new->expiresdefault = add->expiresdefault;
     };
 
-    new->expiresbytype = ap_overlay_tables(p, add->expiresbytype,
+    new->expiresbytype = apr_overlay_tables(p, add->expiresbytype,
                                         base->expiresbytype);
     return new;
 }
@@ -408,9 +408,9 @@ static int add_expires(request_rec *r)
 {
     expires_dir_config *conf;
     char *code;
-    ap_time_t base;
-    ap_time_t additional;
-    ap_time_t expires;
+    apr_time_t base;
+    apr_time_t additional;
+    apr_time_t expires;
     char *timestr;
 
     if (ap_is_HTTP_ERROR(r->status))       /* Don't add Expires headers to errors */
@@ -443,7 +443,7 @@ static int add_expires(request_rec *r)
     if (r->content_type == NULL)
         code = NULL;
     else
-        code = (char *) ap_table_get(conf->expiresbytype, 
+        code = (char *) apr_table_get(conf->expiresbytype, 
 		ap_field_noparam(r->pool, r->content_type));
 
     if (code == NULL) {
@@ -484,13 +484,13 @@ static int add_expires(request_rec *r)
     };
 
     expires = base + additional;
-    ap_table_mergen(r->headers_out, "Cache-Control",
-		    ap_psprintf(r->pool, "max-age=%qd",
+    apr_table_mergen(r->headers_out, "Cache-Control",
+		    apr_psprintf(r->pool, "max-age=%qd",
 				(expires - r->request_time)
 				    / AP_USEC_PER_SEC));
-    timestr = ap_palloc(r->pool, AP_RFC822_DATE_LEN);
-    ap_rfc822_date(timestr, expires);
-    ap_table_setn(r->headers_out, "Expires", timestr);
+    timestr = apr_palloc(r->pool, AP_RFC822_DATE_LEN);
+    apr_rfc822_date(timestr, expires);
+    apr_table_setn(r->headers_out, "Expires", timestr);
     return OK;
 }
 
@@ -506,7 +506,7 @@ module MODULE_VAR_EXPORT expires_module =
     merge_expires_dir_configs,  /* dir merger --- default is to override */
     NULL,                       /* server config */
     NULL,                       /* merge server configs */
-    expires_cmds,               /* command ap_table_t */
+    expires_cmds,               /* command apr_table_t */
     NULL,                       /* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/metadata/mod_headers.c b/modules/metadata/mod_headers.c
index 432307d..f0eb1ac 100644
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -125,32 +125,32 @@ typedef struct {
  * a per-dir and per-server config
  */
 typedef struct {
-    ap_array_header_t *headers;
+    apr_array_header_t *headers;
 } headers_conf;
 
 module MODULE_VAR_EXPORT headers_module;
 
-static void *create_headers_config(ap_pool_t *p, server_rec *s)
+static void *create_headers_config(apr_pool_t *p, server_rec *s)
 {
     headers_conf *a =
-    (headers_conf *) ap_pcalloc(p, sizeof(headers_conf));
+    (headers_conf *) apr_pcalloc(p, sizeof(headers_conf));
 
-    a->headers = ap_make_array(p, 2, sizeof(header_entry));
+    a->headers = apr_make_array(p, 2, sizeof(header_entry));
     return a;
 }
 
-static void *create_headers_dir_config(ap_pool_t *p, char *d)
+static void *create_headers_dir_config(apr_pool_t *p, char *d)
 {
     return (headers_conf *) create_headers_config(p, NULL);
 }
 
-static void *merge_headers_config(ap_pool_t *p, void *basev, void *overridesv)
+static void *merge_headers_config(apr_pool_t *p, void *basev, void *overridesv)
 {
     headers_conf *a =
-    (headers_conf *) ap_pcalloc(p, sizeof(headers_conf));
+    (headers_conf *) apr_pcalloc(p, sizeof(headers_conf));
     headers_conf *base = (headers_conf *) basev, *overrides = (headers_conf *) overridesv;
 
-    a->headers = ap_append_arrays(p, base->headers, overrides->headers);
+    a->headers = apr_append_arrays(p, base->headers, overrides->headers);
 
     return a;
 }
@@ -160,7 +160,7 @@ static const char *header_cmd(cmd_parms *cmd, void *indirconf,
                               const char *action, const char *inhdr, const char *value)
 {
     headers_conf *dirconf = indirconf;
-    char *hdr = ap_pstrdup(cmd->pool, inhdr);
+    char *hdr = apr_pstrdup(cmd->pool, inhdr);
     header_entry *new;
     server_rec *s = cmd->server;
     headers_conf *serverconf =
@@ -168,10 +168,10 @@ static const char *header_cmd(cmd_parms *cmd, void *indirconf,
     char *colon;
 
     if (cmd->path) {
-        new = (header_entry *) ap_push_array(dirconf->headers);
+        new = (header_entry *) apr_push_array(dirconf->headers);
     }
     else {
-        new = (header_entry *) ap_push_array(serverconf->headers);
+        new = (header_entry *) apr_push_array(serverconf->headers);
     }
 
     if (!strcasecmp(action, "set"))
@@ -208,7 +208,7 @@ static const command_rec headers_cmds[] =
     {NULL}
 };
 
-static void do_headers_fixup(request_rec *r, ap_array_header_t *headers)
+static void do_headers_fixup(request_rec *r, apr_array_header_t *headers)
 {
     int i;
 
@@ -216,16 +216,16 @@ static void do_headers_fixup(request_rec *r, ap_array_header_t *headers)
         header_entry *hdr = &((header_entry *) (headers->elts))[i];
         switch (hdr->action) {
         case hdr_add:
-            ap_table_addn(r->headers_out, hdr->header, hdr->value);
+            apr_table_addn(r->headers_out, hdr->header, hdr->value);
             break;
         case hdr_append:
-            ap_table_mergen(r->headers_out, hdr->header, hdr->value);
+            apr_table_mergen(r->headers_out, hdr->header, hdr->value);
             break;
         case hdr_set:
-            ap_table_setn(r->headers_out, hdr->header, hdr->value);
+            apr_table_setn(r->headers_out, hdr->header, hdr->value);
             break;
         case hdr_unset:
-            ap_table_unset(r->headers_out, hdr->header);
+            apr_table_unset(r->headers_out, hdr->header);
             break;
         }
     }
@@ -257,7 +257,7 @@ module MODULE_VAR_EXPORT headers_module =
     merge_headers_config,       /* dir merger --- default is to override */
     create_headers_config,      /* server config */
     merge_headers_config,       /* merge server configs */
-    headers_cmds,               /* command ap_table_t */
+    headers_cmds,               /* command apr_table_t */
     NULL,                       /* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/metadata/mod_mime_magic.c b/modules/metadata/mod_mime_magic.c
index 6f4257d..76a053b 100644
--- a/modules/metadata/mod_mime_magic.c
+++ b/modules/metadata/mod_mime_magic.c
@@ -96,7 +96,7 @@
  * modified from the free "file" command.
  * - all-in-one file for compilation convenience when moving from one
  *   version of Apache to the next.
- * - Memory allocation is done through the Apache API's ap_pool_t structure.
+ * - Memory allocation is done through the Apache API's apr_pool_t structure.
  * - All functions have had necessary Apache API request or server
  *   structures passed to them where necessary to call other Apache API
  *   routines.  (i.e. usually for logging, files, or memory allocation in
@@ -255,7 +255,7 @@ static int zmagic(request_rec *, unsigned char *, int);
 static int getvalue(server_rec *, struct magic *, char **);
 static int hextoint(int);
 static char *getstr(server_rec *, char *, char *, int, int *);
-static int parse(server_rec *, ap_pool_t *p, char *, int);
+static int parse(server_rec *, apr_pool_t *p, char *, int);
 
 static int match(request_rec *, unsigned char *, int);
 static int mget(request_rec *, union VALUETYPE *, unsigned char *,
@@ -278,7 +278,7 @@ static int fsmagic(request_rec *r, const char *fn);
  * make HOWMANY too high unless you have a very fast CPU.
  */
 
-/* these types are used to index the ap_table_t 'types': keep em in sync! */
+/* these types are used to index the apr_table_t 'types': keep em in sync! */
 /* HTML inserted in first because this is a web server module now */
 #define L_HTML    0		/* HTML */
 #define L_C       1		/* first and foremost on UNIX */
@@ -505,18 +505,18 @@ typedef struct {
 
 module mime_magic_module;
 
-static void *create_magic_server_config(ap_pool_t *p, server_rec *d)
+static void *create_magic_server_config(apr_pool_t *p, server_rec *d)
 {
     /* allocate the config - use pcalloc because it needs to be zeroed */
-    return ap_pcalloc(p, sizeof(magic_server_config_rec));
+    return apr_pcalloc(p, sizeof(magic_server_config_rec));
 }
 
-static void *merge_magic_server_config(ap_pool_t *p, void *basev, void *addv)
+static void *merge_magic_server_config(apr_pool_t *p, void *basev, void *addv)
 {
     magic_server_config_rec *base = (magic_server_config_rec *) basev;
     magic_server_config_rec *add = (magic_server_config_rec *) addv;
     magic_server_config_rec *new = (magic_server_config_rec *)
-			    ap_palloc(p, sizeof(magic_server_config_rec));
+			    apr_palloc(p, sizeof(magic_server_config_rec));
 
     new->magicfile = add->magicfile ? add->magicfile : base->magicfile;
     new->magic = NULL;
@@ -564,7 +564,7 @@ static const command_rec mime_magic_cmds[] =
 /* allocate a per-request structure and put it in the request record */
 static magic_req_rec *magic_set_config(request_rec *r)
 {
-    magic_req_rec *req_dat = (magic_req_rec *) ap_palloc(r->pool,
+    magic_req_rec *req_dat = (magic_req_rec *) apr_palloc(r->pool,
 						      sizeof(magic_req_rec));
 
     req_dat->head = req_dat->tail = (magic_rsl *) NULL;
@@ -591,7 +591,7 @@ static int magic_rsl_add(request_rec *r, char *str)
     }
 
     /* allocate the list entry */
-    rsl = (magic_rsl *) ap_palloc(r->pool, sizeof(magic_rsl));
+    rsl = (magic_rsl *) apr_palloc(r->pool, sizeof(magic_rsl));
 
     /* fill it */
     rsl->str = str;
@@ -625,7 +625,7 @@ static int magic_rsl_printf(request_rec *r, char *str,...)
 
     /* assemble the string into the buffer */
     va_start(ap, str);
-    ap_vsnprintf(buf, sizeof(buf), str, ap);
+    apr_vsnprintf(buf, sizeof(buf), str, ap);
     va_end(ap);
 
     /* add the buffer to the list */
@@ -655,7 +655,7 @@ static char *rsl_strdup(request_rec *r, int start_frag, int start_pos, int len)
 		    ap_get_module_config(r->request_config, &mime_magic_module);
 
     /* allocate the result string */
-    result = (char *) ap_palloc(r->pool, len + 1);
+    result = (char *) apr_palloc(r->pool, len + 1);
 
     /* loop through and collect the string */
     res_pos = 0;
@@ -854,7 +854,7 @@ static int magic_rsl_to_request(request_rec *r)
  */
 static int magic_process(request_rec *r)
 {
-    ap_file_t *fd = NULL;
+    apr_file_t *fd = NULL;
     unsigned char buf[HOWMANY + 1];	/* one extra for terminating '\0' */
     int nbytes = 0;		/* number of bytes read from a datafile */
     int result;
@@ -873,7 +873,7 @@ static int magic_process(request_rec *r)
 	return result;
     }
 
-    if (ap_open(&fd, r->filename, APR_READ, APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
+    if (apr_open(&fd, r->filename, APR_READ, APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
 	/* We can't open it, but we were able to stat it. */
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
 		    MODNAME ": can't read `%s'", r->filename);
@@ -885,7 +885,7 @@ static int magic_process(request_rec *r)
      * try looking at the first HOWMANY bytes
      */
     nbytes = sizeof(buf) - 1;
-    if ((result = ap_read(fd, (char *) buf, &nbytes)) != APR_SUCCESS) {
+    if ((result = apr_read(fd, (char *) buf, &nbytes)) != APR_SUCCESS) {
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, result, r,
 		    MODNAME ": read failed: %s", r->filename);
 	return HTTP_INTERNAL_SERVER_ERROR;
@@ -898,7 +898,7 @@ static int magic_process(request_rec *r)
 	tryit(r, buf, nbytes, 1); 
     }
 
-    (void) ap_close(fd);
+    (void) apr_close(fd);
     (void) magic_rsl_putchar(r, '\n');
 
     return OK;
@@ -939,10 +939,10 @@ static void tryit(request_rec *r, unsigned char *buf, int nb, int checkzmagic)
  * apprentice - load configuration from the magic file r
  *  API request record
  */
-static int apprentice(server_rec *s, ap_pool_t *p)
+static int apprentice(server_rec *s, apr_pool_t *p)
 {
-    ap_file_t *f = NULL;
-    ap_status_t result;
+    apr_file_t *f = NULL;
+    apr_status_t result;
     char line[BUFSIZ + 1];
     int errs = 0;
     int lineno;
@@ -954,7 +954,7 @@ static int apprentice(server_rec *s, ap_pool_t *p)
 		    ap_get_module_config(s->module_config, &mime_magic_module);
 
     const char *fname = ap_server_root_relative(p, conf->magicfile);
-    result = ap_open(&f, fname, APR_READ | APR_BUFFERED, APR_OS_DEFAULT, p);
+    result = apr_open(&f, fname, APR_READ | APR_BUFFERED, APR_OS_DEFAULT, p);
     if (result != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_ERR, result, s,
 		    MODNAME ": can't read magic file %s", fname);
@@ -965,7 +965,7 @@ static int apprentice(server_rec *s, ap_pool_t *p)
     conf->magic = conf->last = NULL;
 
     /* parse it */
-    for (lineno = 1; ap_fgets(line, BUFSIZ, f) == APR_SUCCESS; lineno++) {
+    for (lineno = 1; apr_fgets(line, BUFSIZ, f) == APR_SUCCESS; lineno++) {
 	int ws_offset;
 
 	/* delete newline */
@@ -998,7 +998,7 @@ static int apprentice(server_rec *s, ap_pool_t *p)
 	    ++errs;
     }
 
-    (void) ap_close(f);
+    (void) apr_close(f);
 
 #if MIME_MAGIC_DEBUG
     ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, s,
@@ -1079,7 +1079,7 @@ static unsigned long signextend(server_rec *s, struct magic *m, unsigned long v)
 /*
  * parse one line from magic file, put into magic[index++] if valid
  */
-static int parse(server_rec *serv, ap_pool_t *p, char *l, int lineno)
+static int parse(server_rec *serv, apr_pool_t *p, char *l, int lineno)
 {
     struct magic *m;
     char *t, *s;
@@ -1087,7 +1087,7 @@ static int parse(server_rec *serv, ap_pool_t *p, char *l, int lineno)
 		    ap_get_module_config(serv->module_config, &mime_magic_module);
 
     /* allocate magic structure entry */
-    m = (struct magic *) ap_pcalloc(p, sizeof(struct magic));
+    m = (struct magic *) apr_pcalloc(p, sizeof(struct magic));
 
     /* append to linked list */
     m->next = NULL;
@@ -2139,25 +2139,25 @@ struct uncompress_parms {
     int method;
 };
 
-static int uncompress_child(struct uncompress_parms *parm, ap_pool_t *cntxt,
+static int uncompress_child(struct uncompress_parms *parm, apr_pool_t *cntxt,
                             BUFF **script_in)
 {
     int rc = 1;
     char *new_argv[4];
     char **env;
     request_rec *r = parm->r;
-    ap_pool_t *child_context = cntxt;
-    ap_procattr_t *procattr;
-    ap_proc_t *procnew;
+    apr_pool_t *child_context = cntxt;
+    apr_procattr_t *procattr;
+    apr_proc_t *procnew;
     ap_iol *iol;
 
     env = ap_create_environment(child_context, r->subprocess_env);
 
-    if ((ap_createprocattr_init(&procattr, child_context) != APR_SUCCESS) ||
-        (ap_setprocattr_io(procattr, APR_FULL_BLOCK, 
+    if ((apr_createprocattr_init(&procattr, child_context) != APR_SUCCESS) ||
+        (apr_setprocattr_io(procattr, APR_FULL_BLOCK, 
                            APR_FULL_BLOCK, APR_NO_PIPE)   != APR_SUCCESS) ||
-        (ap_setprocattr_dir(procattr, r->filename)        != APR_SUCCESS) ||
-        (ap_setprocattr_cmdtype(procattr, APR_PROGRAM)    != APR_SUCCESS)) {
+        (apr_setprocattr_dir(procattr, r->filename)        != APR_SUCCESS) ||
+        (apr_setprocattr_cmdtype(procattr, APR_PROGRAM)    != APR_SUCCESS)) {
         /* Something bad happened, tell the world. */
         ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_ENOPROC, r,
                "couldn't setup child process: %s", r->filename);
@@ -2172,8 +2172,8 @@ static int uncompress_child(struct uncompress_parms *parm, ap_pool_t *cntxt,
             close(STDERR_FILENO);
         }
 
-        procnew = ap_pcalloc(child_context, sizeof(*procnew));
-        rc = ap_create_process(procnew, compr[parm->method].argv[0],
+        procnew = apr_pcalloc(child_context, sizeof(*procnew));
+        rc = apr_create_process(procnew, compr[parm->method].argv[0],
                                new_argv, env, procattr, child_context);
 
         if (rc != APR_SUCCESS) {
@@ -2183,7 +2183,7 @@ static int uncompress_child(struct uncompress_parms *parm, ap_pool_t *cntxt,
                           compr[parm->method].argv[0]);
         }
         else {
-            ap_note_subprocess(child_context, procnew, kill_after_timeout);
+            apr_note_subprocess(child_context, procnew, kill_after_timeout);
             /* Fill in BUFF structure for parents pipe to child's stdout */
             iol = ap_create_file_iol(procnew->out);
             if (!iol)
@@ -2203,8 +2203,8 @@ static int uncompress(request_rec *r, int method,
 {
     struct uncompress_parms parm;
     BUFF *bout = NULL;
-    ap_pool_t *sub_context;
-    ap_status_t rv;
+    apr_pool_t *sub_context;
+    apr_status_t rv;
 
     parm.r = r;
     parm.method = method;
@@ -2213,7 +2213,7 @@ static int uncompress(request_rec *r, int method,
      * there are cases (i.e. generating directory indicies with mod_autoindex)
      * where we would end up with LOTS of zombies.
      */
-    if (ap_create_pool(&sub_context, r->pool) != APR_SUCCESS)
+    if (apr_create_pool(&sub_context, r->pool) != APR_SUCCESS)
         return -1;
 
     if ((rv = uncompress_child(&parm, sub_context, &bout)) != APR_SUCCESS) {
@@ -2222,15 +2222,15 @@ static int uncompress(request_rec *r, int method,
 	return -1;
     }
 
-    *newch = (unsigned char *) ap_palloc(r->pool, n);
+    *newch = (unsigned char *) apr_palloc(r->pool, n);
     rv = ap_bread(bout, *newch, n, &n);
     if (n == 0) {
-	ap_destroy_pool(sub_context);
+	apr_destroy_pool(sub_context);
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
 	    MODNAME ": read failed %s", r->filename);
 	return -1;
     }
-    ap_destroy_pool(sub_context);
+    apr_destroy_pool(sub_context);
     return n;
 }
 
@@ -2350,7 +2350,7 @@ static int revision_suffix(request_rec *r)
 
     /* perform sub-request for the file name without the suffix */
     result = 0;
-    sub_filename = ap_pstrndup(r->pool, r->filename, suffix_pos);
+    sub_filename = apr_pstrndup(r->pool, r->filename, suffix_pos);
 #if MIME_MAGIC_DEBUG
     ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
 		MODNAME ": subrequest lookup for %s", sub_filename);
@@ -2359,7 +2359,7 @@ static int revision_suffix(request_rec *r)
 
     /* extract content type/encoding/language from sub-request */
     if (sub->content_type) {
-	r->content_type = ap_pstrdup(r->pool, sub->content_type);
+	r->content_type = apr_pstrdup(r->pool, sub->content_type);
 #if MIME_MAGIC_DEBUG
 	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, 0, r,
 		    MODNAME ": subrequest %s got %s",
@@ -2367,10 +2367,10 @@ static int revision_suffix(request_rec *r)
 #endif /* MIME_MAGIC_DEBUG */
 	if (sub->content_encoding)
 	    r->content_encoding =
-		ap_pstrdup(r->pool, sub->content_encoding);
+		apr_pstrdup(r->pool, sub->content_encoding);
 	if (sub->content_language)
 	    r->content_language =
-		ap_pstrdup(r->pool, sub->content_language);
+		apr_pstrdup(r->pool, sub->content_language);
 	result = 1;
     }
 
@@ -2383,7 +2383,7 @@ static int revision_suffix(request_rec *r)
 /*
  * initialize the module
  */
-static void magic_init(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *main_server)
+static void magic_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *main_server)
 {
     int result;
     magic_server_config_rec *conf;
@@ -2492,7 +2492,7 @@ module mime_magic_module =
     NULL,                      /* dir merger --- default is to override */
     create_magic_server_config,        /* server config */
     merge_magic_server_config, /* merge server config */
-    mime_magic_cmds,           /* command ap_table_t */
+    mime_magic_cmds,           /* command apr_table_t */
     NULL,                      /* handlers */
     register_hooks              /* register hooks */
 };
diff --git a/modules/metadata/mod_setenvif.c b/modules/metadata/mod_setenvif.c
index 147a978..55ccef6 100644
--- a/modules/metadata/mod_setenvif.c
+++ b/modules/metadata/mod_setenvif.c
@@ -139,7 +139,7 @@ typedef struct {
     char *name;                 /* header name */
     char *regex;                /* regex to match against */
     regex_t *preg;              /* compiled regex */
-    ap_table_t *features;            /* env vars to set (or unset) */
+    apr_table_t *features;            /* env vars to set (or unset) */
     ENUM_BITFIELD(              /* is it a "special" header ? */
 	enum special,
 	special_type,4);
@@ -147,7 +147,7 @@ typedef struct {
 } sei_entry;
 
 typedef struct {
-    ap_array_header_t *conditionals;
+    apr_array_header_t *conditionals;
 } sei_cfg_rec;
 
 module MODULE_VAR_EXPORT setenvif_module;
@@ -161,30 +161,30 @@ module MODULE_VAR_EXPORT setenvif_module;
  * the URI has been mapped to a file and we have anything from the
  * .htaccess file and <Directory> and <Files> containers).
  */
-static void *create_setenvif_config(ap_pool_t *p)
+static void *create_setenvif_config(apr_pool_t *p)
 {
-    sei_cfg_rec *new = (sei_cfg_rec *) ap_palloc(p, sizeof(sei_cfg_rec));
+    sei_cfg_rec *new = (sei_cfg_rec *) apr_palloc(p, sizeof(sei_cfg_rec));
 
-    new->conditionals = ap_make_array(p, 20, sizeof(sei_entry));
+    new->conditionals = apr_make_array(p, 20, sizeof(sei_entry));
     return (void *) new;
 }
 
-static void *create_setenvif_config_svr(ap_pool_t *p, server_rec *dummy)
+static void *create_setenvif_config_svr(apr_pool_t *p, server_rec *dummy)
 {
     return create_setenvif_config(p);
 }
 
-static void *create_setenvif_config_dir(ap_pool_t *p, char *dummy)
+static void *create_setenvif_config_dir(apr_pool_t *p, char *dummy)
 {
     return create_setenvif_config(p);
 }
 
-static void *merge_setenvif_config(ap_pool_t *p, void *basev, void *overridesv)
+static void *merge_setenvif_config(apr_pool_t *p, void *basev, void *overridesv)
 {
-    sei_cfg_rec *a = ap_pcalloc(p, sizeof(sei_cfg_rec));
+    sei_cfg_rec *a = apr_pcalloc(p, sizeof(sei_cfg_rec));
     sei_cfg_rec *base = basev, *overrides = overridesv;
 
-    a->conditionals = ap_append_arrays(p, base->conditionals,
+    a->conditionals = apr_append_arrays(p, base->conditionals,
 				       overrides->conditionals);
     return a;
 }
@@ -222,7 +222,7 @@ static const char *add_setenvif_core(cmd_parms *cmd, void *mconfig,
     /* get regex */
     regex = ap_getword_conf(cmd->pool, &args);
     if (!*regex) {
-        return ap_pstrcat(cmd->pool, "Missing regular expression for ",
+        return apr_pstrcat(cmd->pool, "Missing regular expression for ",
 			  cmd->cmd->name, NULL);
     }
 
@@ -252,7 +252,7 @@ static const char *add_setenvif_core(cmd_parms *cmd, void *mconfig,
 
 	/* no match, create a new entry */
 
-	new = ap_push_array(sconf->conditionals);
+	new = apr_push_array(sconf->conditionals);
 	new->name = fname;
 	new->regex = regex;
 	new->icase = icase;
@@ -260,10 +260,10 @@ static const char *add_setenvif_core(cmd_parms *cmd, void *mconfig,
 				(REG_EXTENDED | REG_NOSUB
 				 | (icase ? REG_ICASE : 0)));
 	if (new->preg == NULL) {
-	    return ap_pstrcat(cmd->pool, cmd->cmd->name,
+	    return apr_pstrcat(cmd->pool, cmd->cmd->name,
 			      " regex could not be compiled.", NULL);
 	}
-	new->features = ap_make_table(cmd->pool, 2);
+	new->features = apr_make_table(cmd->pool, 2);
 
 	if (!strcasecmp(fname, "remote_addr")) {
 	    new->special_type = SPECIAL_REMOTE_ADDR;
@@ -300,18 +300,18 @@ static const char *add_setenvif_core(cmd_parms *cmd, void *mconfig,
 
         var = ap_getword(cmd->pool, &feature, '=');
         if (*feature) {
-            ap_table_setn(new->features, var, feature);
+            apr_table_setn(new->features, var, feature);
         }
         else if (*var == '!') {
-            ap_table_setn(new->features, var + 1, "!");
+            apr_table_setn(new->features, var + 1, "!");
         }
         else {
-            ap_table_setn(new->features, var, "1");
+            apr_table_setn(new->features, var, "1");
         }
     }
 
     if (!beenhere) {
-        return ap_pstrcat(cmd->pool, "Missing envariable expression for ",
+        return apr_pstrcat(cmd->pool, "Missing envariable expression for ",
 			  cmd->cmd->name, NULL);
     }
 
@@ -326,7 +326,7 @@ static const char *add_setenvif(cmd_parms *cmd, void *mconfig,
     /* get header name */
     fname = ap_getword_conf(cmd->pool, &args);
     if (!*fname) {
-        return ap_pstrcat(cmd->pool, "Missing header-field name for ",
+        return apr_pstrcat(cmd->pool, "Missing header-field name for ",
 			  cmd->cmd->name, NULL);
     }
     return add_setenvif_core(cmd, mconfig, fname, args);
@@ -368,13 +368,13 @@ static int match_headers(request_rec *r)
 {
     sei_cfg_rec *sconf;
     sei_entry *entries;
-    ap_table_entry_t *elts;
+    apr_table_entry_t *elts;
     const char *val;
     int i, j;
     char *last_name;
 
-    if (ap_table_get(r->notes, SEI_MAGIC_HEIRLOOM) == NULL) {
-	ap_table_set(r->notes, SEI_MAGIC_HEIRLOOM, "post-read done");
+    if (apr_table_get(r->notes, SEI_MAGIC_HEIRLOOM) == NULL) {
+	apr_table_set(r->notes, SEI_MAGIC_HEIRLOOM, "post-read done");
 	sconf  = (sei_cfg_rec *) ap_get_module_config(r->server->module_config,
 						      &setenvif_module);
     }
@@ -416,9 +416,9 @@ static int match_headers(request_rec *r)
 		val = r->protocol;
 		break;
 	    case SPECIAL_NOT:
-		val = ap_table_get(r->headers_in, b->name);
+		val = apr_table_get(r->headers_in, b->name);
 		if (val == NULL) {
-		    val = ap_table_get(r->subprocess_env, b->name);
+		    val = apr_table_get(r->subprocess_env, b->name);
 		}
 		break;
 	    }
@@ -435,15 +435,15 @@ static int match_headers(request_rec *r)
         }
 
         if (!ap_regexec(b->preg, val, 0, NULL, 0)) {
-	    ap_array_header_t *arr = ap_table_elts(b->features);
-            elts = (ap_table_entry_t *) arr->elts;
+	    apr_array_header_t *arr = ap_table_elts(b->features);
+            elts = (apr_table_entry_t *) arr->elts;
 
             for (j = 0; j < arr->nelts; ++j) {
                 if (!strcmp(elts[j].val, "!")) {
-                    ap_table_unset(r->subprocess_env, elts[j].key);
+                    apr_table_unset(r->subprocess_env, elts[j].key);
                 }
                 else {
-                    ap_table_setn(r->subprocess_env, elts[j].key, elts[j].val);
+                    apr_table_setn(r->subprocess_env, elts[j].key, elts[j].val);
                 }
             }
         }
@@ -465,7 +465,7 @@ module MODULE_VAR_EXPORT setenvif_module =
     merge_setenvif_config,      /* dir merger --- default is to override */
     create_setenvif_config_svr, /* server config */
     merge_setenvif_config,      /* merge server configs */
-    setenvif_module_cmds,       /* command ap_table_t */
+    setenvif_module_cmds,       /* command apr_table_t */
     NULL,                       /* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/metadata/mod_unique_id.c b/modules/metadata/mod_unique_id.c
index 48b9dbb..b07b5b5 100644
--- a/modules/metadata/mod_unique_id.c
+++ b/modules/metadata/mod_unique_id.c
@@ -176,14 +176,14 @@ static unsigned short unique_id_rec_offset[UNIQUE_ID_REC_MAX],
                       unique_id_rec_total_size,
                       unique_id_rec_size_uu;
 
-static void unique_id_global_init(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *main_server)
+static void unique_id_global_init(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *main_server)
 {
 #ifndef MAXHOSTNAMELEN
 #define MAXHOSTNAMELEN 256
 #endif
     char str[MAXHOSTNAMELEN + 1];
     struct hostent *hent;
-    ap_interval_time_t pause;
+    apr_interval_time_t pause;
 
     /*
      * Calculate the sizes and offsets in cur_unique_id.
@@ -244,14 +244,14 @@ static void unique_id_global_init(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptem
      * But protecting against it is relatively cheap.  We just sleep into the
      * next second.
      */
-    pause = (ap_interval_time_t)(1000000 - (ap_now() % AP_USEC_PER_SEC));
-    ap_sleep(pause);
+    pause = (apr_interval_time_t)(1000000 - (apr_now() % AP_USEC_PER_SEC));
+    apr_sleep(pause);
 }
 
-static void unique_id_child_init(ap_pool_t *p, server_rec *s)
+static void unique_id_child_init(apr_pool_t *p, server_rec *s)
 {
     pid_t pid;
-    ap_time_t tv;
+    apr_time_t tv;
 
     /*
      * Note that we use the pid because it's possible that on the same
@@ -283,7 +283,7 @@ static void unique_id_child_init(ap_pool_t *p, server_rec *s)
      * against restart problems, and a little less protection against a clock
      * going backwards in time.
      */
-    tv = ap_now();
+    tv = apr_now();
     /* Some systems have very low variance on the low end of their system
      * counter, defend against that.
      */
@@ -331,8 +331,8 @@ static int gen_unique_id(request_rec *r)
     /* copy the unique_id if this is an internal redirect (we're never
      * actually called for sub requests, so we don't need to test for
      * them) */
-    if (r->prev && (e = ap_table_get(r->subprocess_env, "REDIRECT_UNIQUE_ID"))) {
-	ap_table_setn(r->subprocess_env, "UNIQUE_ID", e);
+    if (r->prev && (e = apr_table_get(r->subprocess_env, "REDIRECT_UNIQUE_ID"))) {
+	apr_table_setn(r->subprocess_env, "UNIQUE_ID", e);
 	return DECLINED;
     }
     
@@ -361,7 +361,7 @@ static int gen_unique_id(request_rec *r)
     x[k++] = '\0';
     
     /* alloc str and do the uuencoding */
-    str = (char *)ap_palloc(r->pool, unique_id_rec_size_uu + 1);
+    str = (char *)apr_palloc(r->pool, unique_id_rec_size_uu + 1);
     k = 0;
     for (i = 0; i < unique_id_rec_total_size; i += 3) {
         y = x + i;
@@ -375,7 +375,7 @@ static int gen_unique_id(request_rec *r)
     str[k++] = '\0';
 
     /* set the environment variable */
-    ap_table_setn(r->subprocess_env, "UNIQUE_ID", str);
+    apr_table_setn(r->subprocess_env, "UNIQUE_ID", str);
 
     /* and increment the identifier for the next call */
 
@@ -398,7 +398,7 @@ module MODULE_VAR_EXPORT unique_id_module = {
     NULL,                       /* dir merger --- default is to override */
     NULL,                       /* server config */
     NULL,                       /* merge server configs */
-    NULL,                       /* command ap_table_t */
+    NULL,                       /* command apr_table_t */
     NULL,                       /* handlers */
     register_hooks              /* register hooks */
 };
diff --git a/modules/metadata/mod_usertrack.c b/modules/metadata/mod_usertrack.c
index 6fa2f56..f59f08a 100644
--- a/modules/metadata/mod_usertrack.c
+++ b/modules/metadata/mod_usertrack.c
@@ -137,15 +137,15 @@ static void make_cookie(request_rec *r)
     dcfg = ap_get_module_config(r->per_dir_config, &usertrack_module);
 
     /* XXX: hmm, this should really tie in with mod_unique_id */
-    ap_snprintf(cookiebuf, sizeof(cookiebuf), "%s.%qd", rname, ap_now());
+    apr_snprintf(cookiebuf, sizeof(cookiebuf), "%s.%qd", rname, apr_now());
 
     if (cls->expires) {
 	ap_exploded_time_t tms;
 
-	ap_explode_gmt(&tms, r->request_time + cls->expires * AP_USEC_PER_SEC);
+	apr_explode_gmt(&tms, r->request_time + cls->expires * AP_USEC_PER_SEC);
 
         /* Cookie with date; as strftime '%a, %d-%h-%y %H:%M:%S GMT' */
-        new_cookie = ap_psprintf(r->pool,
+        new_cookie = apr_psprintf(r->pool,
                 "%s=%s; path=/; expires=%s, %.2d-%s-%.2d %.2d:%.2d:%.2d GMT",
                     dcfg->cookie_name, cookiebuf, ap_day_snames[tms.tm_wday],
                     tms.tm_mday, ap_month_snames[tms.tm_mon],
@@ -153,12 +153,12 @@ static void make_cookie(request_rec *r)
                     tms.tm_hour, tms.tm_min, tms.tm_sec);
     }
     else {
-	new_cookie = ap_psprintf(r->pool, "%s=%s; path=/",
+	new_cookie = apr_psprintf(r->pool, "%s=%s; path=/",
 				 dcfg->cookie_name, cookiebuf);
     }
 
-    ap_table_setn(r->headers_out, "Set-Cookie", new_cookie);
-    ap_table_setn(r->notes, "cookie", ap_pstrdup(r->pool, cookiebuf));   /* log first time */
+    apr_table_setn(r->headers_out, "Set-Cookie", new_cookie);
+    apr_table_setn(r->notes, "cookie", apr_pstrdup(r->pool, cookiebuf));   /* log first time */
     return;
 }
 
@@ -173,18 +173,18 @@ static int spot_cookie(request_rec *r)
         return DECLINED;
     }
 
-    if ((cookie = ap_table_get(r->headers_in, "Cookie")))
+    if ((cookie = apr_table_get(r->headers_in, "Cookie")))
         if ((value = strstr(cookie, dcfg->cookie_name))) {
             char *cookiebuf, *cookieend;
 
             value += strlen(dcfg->cookie_name) + 1;  /* Skip over the '=' */
-            cookiebuf = ap_pstrdup(r->pool, value);
+            cookiebuf = apr_pstrdup(r->pool, value);
             cookieend = strchr(cookiebuf, ';');
             if (cookieend)
                 *cookieend = '\0';      /* Ignore anything after a ; */
 
             /* Set the cookie in a note, for logging */
-            ap_table_setn(r->notes, "cookie", cookiebuf);
+            apr_table_setn(r->notes, "cookie", cookiebuf);
 
             return DECLINED;    /* There's already a cookie, no new one */
         }
@@ -192,21 +192,21 @@ static int spot_cookie(request_rec *r)
     return OK;                  /* We set our cookie */
 }
 
-static void *make_cookie_log_state(ap_pool_t *p, server_rec *s)
+static void *make_cookie_log_state(apr_pool_t *p, server_rec *s)
 {
     cookie_log_state *cls =
-    (cookie_log_state *) ap_palloc(p, sizeof(cookie_log_state));
+    (cookie_log_state *) apr_palloc(p, sizeof(cookie_log_state));
 
     cls->expires = 0;
 
     return (void *) cls;
 }
 
-static void *make_cookie_dir(ap_pool_t *p, char *d)
+static void *make_cookie_dir(apr_pool_t *p, char *d)
 {
     cookie_dir_rec *dcfg;
 
-    dcfg = (cookie_dir_rec *) ap_pcalloc(p, sizeof(cookie_dir_rec));
+    dcfg = (cookie_dir_rec *) apr_pcalloc(p, sizeof(cookie_dir_rec));
     dcfg->cookie_name = COOKIE_NAME;
     dcfg->enabled = 0;
     return dcfg;
@@ -291,7 +291,7 @@ static const char *set_cookie_name(cmd_parms *cmd, void *mconfig, char *name)
 {
     cookie_dir_rec *dcfg = (cookie_dir_rec *) mconfig;
 
-    dcfg->cookie_name = ap_pstrdup(cmd->pool, name);
+    dcfg->cookie_name = apr_pstrdup(cmd->pool, name);
     return NULL;
 }
 
@@ -314,7 +314,7 @@ module MODULE_VAR_EXPORT usertrack_module = {
     NULL,                       /* dir merger --- default is to override */
     make_cookie_log_state,      /* server config */
     NULL,                       /* merge server configs */
-    cookie_log_cmds,            /* command ap_table_t */
+    cookie_log_cmds,            /* command apr_table_t */
     NULL,                       /* handlers */
     register_hooks		/* register hooks */
 };
diff --git a/modules/proxy/mod_proxy.c b/modules/proxy/mod_proxy.c
index 8ab2836..717426b 100644
--- a/modules/proxy/mod_proxy.c
+++ b/modules/proxy/mod_proxy.c
@@ -157,7 +157,7 @@ static int proxy_detect(request_rec *r)
           r->parsed_uri.port_str ? r->parsed_uri.port : ap_default_port(r)))) {
         r->proxyreq = 1;
         r->uri = r->unparsed_uri;
-        r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
+        r->filename = apr_pstrcat(r->pool, "proxy:", r->uri, NULL);
         r->handler = "proxy-server";
         }
     }
@@ -167,7 +167,7 @@ static int proxy_detect(request_rec *r)
          && r->parsed_uri.port_str) {
         r->proxyreq = 1;
         r->uri = r->unparsed_uri;
-        r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
+        r->filename = apr_pstrcat(r->pool, "proxy:", r->uri, NULL);
         r->handler = "proxy-server";
     }
     return DECLINED;
@@ -197,7 +197,7 @@ static int proxy_trans(request_rec *r)
         len = alias_match(r->uri, ent[i].fake);
         
         if (len > 0) {
-           r->filename = ap_pstrcat(r->pool, "proxy:", ent[i].real,
+           r->filename = apr_pstrcat(r->pool, "proxy:", ent[i].real,
                                  r->uri + len, NULL);
            r->handler = "proxy-server";
            r->proxyreq = 1;
@@ -256,17 +256,17 @@ static int proxy_needsdomain(request_rec *r, const char *url, const char *domain
      || strcasecmp(r->parsed_uri.hostname, "localhost") == 0)
     return DECLINED;    /* host name has a dot already */
 
-    ref = ap_table_get(r->headers_in, "Referer");
+    ref = apr_table_get(r->headers_in, "Referer");
 
     /* Reassemble the request, but insert the domain after the host name */
     /* Note that the domain name always starts with a dot */
-    r->parsed_uri.hostname = ap_pstrcat(r->pool, r->parsed_uri.hostname,
+    r->parsed_uri.hostname = apr_pstrcat(r->pool, r->parsed_uri.hostname,
                      domain, NULL);
     nuri = ap_unparse_uri_components(r->pool,
                   &r->parsed_uri,
                   UNP_REVEALPASSWORD);
 
-    ap_table_set(r->headers_out, "Location", nuri);
+    apr_table_set(r->headers_out, "Location", nuri);
     ap_log_rerror(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, 0, r,
         "Domain missing: %s sent to %s%s%s", r->uri,
         ap_unparse_uri_components(r->pool, &r->parsed_uri,
@@ -285,7 +285,7 @@ static int proxy_handler(request_rec *r)
     void *sconf = r->server->module_config;
     proxy_server_conf *conf = (proxy_server_conf *)
         ap_get_module_config(sconf, &proxy_module);
-    ap_array_header_t *proxies = conf->proxies;
+    apr_array_header_t *proxies = conf->proxies;
     struct proxy_remote *ents = (struct proxy_remote *) proxies->elts;
     int i, rc;
     ap_cache_el *cr=NULL;
@@ -297,7 +297,7 @@ static int proxy_handler(request_rec *r)
         return DECLINED;
 
     if (r->method_number == M_TRACE && (maxfwd_str =
-      ap_table_get(r->headers_in, "Max-Forwards")) != NULL) {
+      apr_table_get(r->headers_in, "Max-Forwards")) != NULL) {
         int maxfwd = strtol(maxfwd_str, NULL, 10);
         if (maxfwd < 1) {
             int access_status;
@@ -308,8 +308,8 @@ static int proxy_handler(request_rec *r)
                 ap_finalize_request_protocol(r);
             return OK;
         }
-        ap_table_setn(r->headers_in, "Max-Forwards", 
-                      ap_psprintf(r->pool, "%d", (maxfwd > 0) ? maxfwd-1 : 0));
+        apr_table_setn(r->headers_in, "Max-Forwards", 
+                      apr_psprintf(r->pool, "%d", (maxfwd > 0) ? maxfwd-1 : 0));
     }
 
     if ((rc = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)))
@@ -320,9 +320,9 @@ static int proxy_handler(request_rec *r)
     if (p == NULL)
         return HTTP_BAD_REQUEST;
 
-    pragma = ap_table_get(r->headers_in, "Pragma");
-    auth = ap_table_get(r->headers_in, "Authorization");
-    imstr = ap_table_get(r->headers_in, "If-Modified-Since");
+    pragma = apr_table_get(r->headers_in, "Pragma");
+    auth = apr_table_get(r->headers_in, "Authorization");
+    imstr = apr_table_get(r->headers_in, "If-Modified-Since");
     
     ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                  "Request for %s, pragma=%s, auth=%s, imstr=%s", url,
@@ -341,7 +341,7 @@ static int proxy_handler(request_rec *r)
             {
                 time_t ims = (time_t)ap_parseHTTPdate(ap_proxy_date_canon(r->pool, imstr));
                 if(ims == BAD_DATE)
-                    ap_table_unset(r->headers_in, "If-Modified-Since");
+                    apr_table_unset(r->headers_in, "If-Modified-Since");
                 else
                 {
                     /* ok we were asked to check, so let's do that */
@@ -353,7 +353,7 @@ static int proxy_handler(request_rec *r)
                         if(lm != BAD_DATE)
                         {
                             if(ims < lm)
-                                ap_table_set(r->headers_in,
+                                apr_table_set(r->headers_in,
                                   "If-Modified-Since", imstr);
                             else
                             {
@@ -379,7 +379,7 @@ static int proxy_handler(request_rec *r)
     }
 
     *p = '\0';
-    scheme = ap_pstrdup(r->pool, url);
+    scheme = apr_pstrdup(r->pool, url);
     *p = ':';
 
     /* Check URI's destination host against NoProxy hosts */
@@ -447,17 +447,17 @@ static int proxy_handler(request_rec *r)
 /* -------------------------------------------------------------- */
 /* Setup configurable data */
 
-static void *create_proxy_config(ap_pool_t *p, server_rec *s)
+static void *create_proxy_config(apr_pool_t *p, server_rec *s)
 {
-    proxy_server_conf *ps = ap_pcalloc(p, sizeof(proxy_server_conf));
-
-    ps->proxies = ap_make_array(p, 10, sizeof(struct proxy_remote));
-    ps->aliases = ap_make_array(p, 10, sizeof(struct proxy_alias));
-    ps->raliases = ap_make_array(p, 10, sizeof(struct proxy_alias));
-    ps->noproxies = ap_make_array(p, 10, sizeof(struct noproxy_entry));
-    ps->dirconn = ap_make_array(p, 10, sizeof(struct dirconn_entry));
-    ps->nocaches = ap_make_array(p, 10, sizeof(struct nocache_entry));
-    ps->allowed_connect_ports = ap_make_array(p, 10, sizeof(int));
+    proxy_server_conf *ps = apr_pcalloc(p, sizeof(proxy_server_conf));
+
+    ps->proxies = apr_make_array(p, 10, sizeof(struct proxy_remote));
+    ps->aliases = apr_make_array(p, 10, sizeof(struct proxy_alias));
+    ps->raliases = apr_make_array(p, 10, sizeof(struct proxy_alias));
+    ps->noproxies = apr_make_array(p, 10, sizeof(struct noproxy_entry));
+    ps->dirconn = apr_make_array(p, 10, sizeof(struct dirconn_entry));
+    ps->nocaches = apr_make_array(p, 10, sizeof(struct nocache_entry));
+    ps->allowed_connect_ports = apr_make_array(p, 10, sizeof(int));
     ps->cache_completion = DEFAULT_CACHE_COMPLETION;
     ps->domain = NULL;
     ps->viaopt = via_off; /* initially backward compatible with 1.3.1 */
@@ -501,7 +501,7 @@ static const char *
     port = defports[i].port;
     }
 
-    new = ap_push_array(conf->proxies);
+    new = apr_push_array(conf->proxies);
     new->scheme = f;
     new->protocol = r;
     new->hostname = p + 3;
@@ -527,7 +527,7 @@ static const char *
     }
 
     if (!found) {
-        new = ap_push_array(psf->nocaches);
+        new = apr_push_array(psf->nocaches);
         new->name = arg;
         /* Don't do name lookups on things that aren't dotted */
         if (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == NULL)
@@ -547,7 +547,7 @@ static const char *
     (proxy_server_conf *) ap_get_module_config(s->module_config, &proxy_module);
     struct proxy_alias *new;
 
-    new = ap_push_array(conf->aliases);
+    new = apr_push_array(conf->aliases);
     new->fake = f;
     new->real = r;
     return NULL;
@@ -562,7 +562,7 @@ static const char *
 
     conf = (proxy_server_conf *)ap_get_module_config(s->module_config, 
                                                   &proxy_module);
-    new = ap_push_array(conf->raliases);
+    new = apr_push_array(conf->raliases);
     new->fake = f;
     new->real = r;
     return NULL;
@@ -586,7 +586,7 @@ static const char *set_proxy_exclude(cmd_parms *parms, void *dummy, char *arg)
     }
 
     if (!found) {
-    new = ap_push_array(conf->noproxies);
+    new = apr_push_array(conf->noproxies);
     new->name = arg;
     /* Don't do name lookups on things that aren't dotted */
     if (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == NULL)
@@ -612,7 +612,7 @@ static const char *
     if (!ap_isdigit(arg[0]))
     return "AllowCONNECT: port number must be numeric";
 
-    New = ap_push_array(conf->allowed_connect_ports);
+    New = apr_push_array(conf->allowed_connect_ports);
     *New = atoi(arg);
     return NULL;
 }
@@ -638,7 +638,7 @@ static const char *
     }
 
     if (!found) {
-    New = ap_push_array(conf->dirconn);
+    New = apr_push_array(conf->dirconn);
     New->name = arg;
     New->hostentry = NULL;
 
@@ -802,7 +802,7 @@ module MODULE_VAR_EXPORT proxy_module =
     NULL,                  /* merge per-directory config structures */
     create_proxy_config,   /* create per-server config structure */
     NULL,                  /* merge per-server config structures */
-    proxy_cmds,            /* command ap_table_t */
+    proxy_cmds,            /* command apr_table_t */
     proxy_handlers,        /* handlers */
     register_hooks
 };
diff --git a/modules/proxy/mod_proxy.h b/modules/proxy/mod_proxy.h
index 4007b87..594fb96 100644
--- a/modules/proxy/mod_proxy.h
+++ b/modules/proxy/mod_proxy.h
@@ -193,13 +193,13 @@ struct nocache_entry {
 };
 
 typedef struct {
-    ap_array_header_t *proxies;
-    ap_array_header_t *aliases;
-    ap_array_header_t *raliases;
-    ap_array_header_t *noproxies;
-    ap_array_header_t *dirconn;
-    ap_array_header_t *nocaches;
-    ap_array_header_t *allowed_connect_ports;
+    apr_array_header_t *proxies;
+    apr_array_header_t *aliases;
+    apr_array_header_t *raliases;
+    apr_array_header_t *noproxies;
+    apr_array_header_t *dirconn;
+    apr_array_header_t *nocaches;
+    apr_array_header_t *allowed_connect_ports;
     char *domain;		/* domain name to use in absence of a domain name in the request */
     int req;			/* true if proxy requests are enabled */
     float cache_completion;	/* Force cache completion after this point */
@@ -241,32 +241,32 @@ int ap_proxy_http_handler(request_rec *r, ap_cache_el  *c, char *url,
 
 int ap_proxy_hex2c(const char *x);
 void ap_proxy_c2hex(int ch, char *x);
-char *ap_proxy_canonenc(ap_pool_t *p, const char *x, int len, enum enctype t,
+char *ap_proxy_canonenc(apr_pool_t *p, const char *x, int len, enum enctype t,
 		     int isenc);
-char *ap_proxy_canon_netloc(ap_pool_t *p, char **const urlp, char **userp,
+char *ap_proxy_canon_netloc(apr_pool_t *p, char **const urlp, char **userp,
 			 char **passwordp, char **hostp, int *port);
-const char *ap_proxy_date_canon(ap_pool_t *p, const char *x);
-ap_table_t *ap_proxy_read_headers(request_rec *r, char *buffer, int size, BUFF *f);
+const char *ap_proxy_date_canon(apr_pool_t *p, const char *x);
+apr_table_t *ap_proxy_read_headers(request_rec *r, char *buffer, int size, BUFF *f);
 long int ap_proxy_send_fb(proxy_completion *, BUFF *f, request_rec *r, ap_cache_el  *c);
-void ap_proxy_send_headers(request_rec *r, const char *respline, ap_table_t *hdrs);
+void ap_proxy_send_headers(request_rec *r, const char *respline, apr_table_t *hdrs);
 int ap_proxy_liststr(const char *list, const char *val);
 void ap_proxy_hash(const char *it, char *val, int ndepth, int nlength);
 int ap_proxy_hex2sec(const char *x);
 void ap_proxy_sec2hex(int t, char *y);
 const char *ap_proxy_host2addr(const char *host, struct hostent *reqhp);
 int ap_proxy_cache_send(request_rec *r, ap_cache_el *c);
-int ap_proxy_cache_should_cache(request_rec *r, ap_table_t *resp_hdrs,
+int ap_proxy_cache_should_cache(request_rec *r, apr_table_t *resp_hdrs,
                                 const int is_HTTP1);
 int ap_proxy_cache_update(ap_cache_el *c);
 void ap_proxy_cache_error(ap_cache_el  **r);
 int ap_proxyerror(request_rec *r, int statuscode, const char *message);
-int ap_proxy_is_ipaddr(struct dirconn_entry *This, ap_pool_t *p);
-int ap_proxy_is_domainname(struct dirconn_entry *This, ap_pool_t *p);
-int ap_proxy_is_hostname(struct dirconn_entry *This, ap_pool_t *p);
-int ap_proxy_is_word(struct dirconn_entry *This, ap_pool_t *p);
-int ap_proxy_doconnect(ap_socket_t *sock, char *host, ap_uint32_t port, request_rec *r);
-int ap_proxy_garbage_init(server_rec *, ap_pool_t *);
-/* This function is called by ap_table_do() for all header lines */
+int ap_proxy_is_ipaddr(struct dirconn_entry *This, apr_pool_t *p);
+int ap_proxy_is_domainname(struct dirconn_entry *This, apr_pool_t *p);
+int ap_proxy_is_hostname(struct dirconn_entry *This, apr_pool_t *p);
+int ap_proxy_is_word(struct dirconn_entry *This, apr_pool_t *p);
+int ap_proxy_doconnect(apr_socket_t *sock, char *host, apr_uint32_t port, request_rec *r);
+int ap_proxy_garbage_init(server_rec *, apr_pool_t *);
+/* This function is called by apr_table_do() for all header lines */
 int ap_proxy_send_hdr_line(void *p, const char *key, const char *value);
 unsigned ap_proxy_bputs2(const char *data, BUFF *client, ap_cache_el  *cache);
 
diff --git a/modules/proxy/proxy_connect.c b/modules/proxy/proxy_connect.c
index 4434254..491d390 100644
--- a/modules/proxy/proxy_connect.c
+++ b/modules/proxy/proxy_connect.c
@@ -118,15 +118,15 @@ int ap_proxy_connect_handler(request_rec *r, ap_cache_el  *c, char *url,
     const char *host;
     char *p;
     int port;
-    ap_socket_t *sock;
+    apr_socket_t *sock;
     char buffer[HUGE_STRING_LEN];
     int nbytes, i;
 
     BUFF *sock_buff;
-    ap_socket_t *client_sock=NULL;
-    ap_pollfd_t *pollfd;
-    ap_int32_t pollcnt;
-    ap_int16_t pollevent;
+    apr_socket_t *client_sock=NULL;
+    apr_pollfd_t *pollfd;
+    apr_int32_t pollcnt;
+    apr_int16_t pollevent;
     
     void *sconf = r->server->module_config;
     proxy_server_conf *conf =
@@ -174,16 +174,16 @@ int ap_proxy_connect_handler(request_rec *r, ap_cache_el  *c, char *url,
                      "CONNECT to %s on port %d", host, port);
     }
 
-    if ((ap_create_tcp_socket(&sock, r->pool)) != APR_SUCCESS) {
+    if ((apr_create_tcp_socket(&sock, r->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "proxy: error creating socket");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     if (ap_proxy_doconnect(sock, (char *)(proxyhost ? proxyhost : host), proxyport ? proxyport : port, r) == -1) {
-        ap_close_socket(sock);
+        apr_close_socket(sock);
         return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
-                             ap_pstrcat(r->pool, "Could not connect to remote machine:<br>",
+                             apr_pstrcat(r->pool, "Could not connect to remote machine:<br>",
                                         strerror(errno), NULL));
     }
 
@@ -197,10 +197,10 @@ int ap_proxy_connect_handler(request_rec *r, ap_cache_el  *c, char *url,
          */
         ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                      "Sending the CONNECT request to the remote proxy");
-        nbytes = ap_snprintf(buffer, sizeof(buffer), "CONNECT %s HTTP/1.0" CRLF, r->uri);
-        ap_send(sock, buffer, &nbytes);
-        nbytes = ap_snprintf(buffer, sizeof(buffer),"Proxy-agent: %s" CRLF CRLF, ap_get_server_version());
-        ap_send(sock, buffer, &nbytes);
+        nbytes = apr_snprintf(buffer, sizeof(buffer), "CONNECT %s HTTP/1.0" CRLF, r->uri);
+        apr_send(sock, buffer, &nbytes);
+        nbytes = apr_snprintf(buffer, sizeof(buffer),"Proxy-agent: %s" CRLF CRLF, ap_get_server_version());
+        apr_send(sock, buffer, &nbytes);
     }
     else {
         ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
@@ -213,9 +213,9 @@ int ap_proxy_connect_handler(request_rec *r, ap_cache_el  *c, char *url,
     sock_buff = ap_bcreate(r->pool, B_RDWR);
     ap_bpush_iol(sock_buff, ap_iol_attach_socket(sock));
 
-    if(ap_setup_poll(&pollfd, 2, r->pool) != APR_SUCCESS)
+    if(apr_setup_poll(&pollfd, 2, r->pool) != APR_SUCCESS)
     {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "proxy: error ap_setup_poll()");
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "proxy: error apr_setup_poll()");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
@@ -226,31 +226,31 @@ int ap_proxy_connect_handler(request_rec *r, ap_cache_el  *c, char *url,
    just see if a recv gives us anything and do the same to sock (server) side, I'll leave this as TBD so
    one can decide the best path to take
 */
-    if(ap_put_os_sock(&client_sock, (ap_os_sock_t *)get_socket(r->connection->client),
+    if(apr_put_os_sock(&client_sock, (apr_os_sock_t *)get_socket(r->connection->client),
                       r->pool) != APR_SUCCESS)
     {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "proxy: error creating client ap_socket_t");
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "proxy: error creating client apr_socket_t");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
-    ap_add_poll_socket(pollfd, client_sock, APR_POLLIN);
+    apr_add_poll_socket(pollfd, client_sock, APR_POLLIN);
 #endif
     
     
     /* Add the server side to the poll */
-    ap_add_poll_socket(pollfd, sock, APR_POLLIN);
+    apr_add_poll_socket(pollfd, sock, APR_POLLIN);
     
     while (1) {            /* Infinite loop until error (one side closes the connection) */
         ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL, "Going to sleep (poll)");
-        if(ap_poll(pollfd, &pollcnt, -1) != APR_SUCCESS)
+        if(apr_poll(pollfd, &pollcnt, -1) != APR_SUCCESS)
         {
-            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "proxy: error ap_poll()");
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "proxy: error apr_poll()");
             return HTTP_INTERNAL_SERVER_ERROR;
         }
         ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                      "Woke from select(), i=%d", pollcnt);
 
         if (pollcnt) {
-            ap_get_revents(&pollevent, sock, pollfd);
+            apr_get_revents(&pollevent, sock, pollfd);
             if (pollevent & APR_POLLIN) {
                 ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                              "sock was set");
@@ -269,7 +269,7 @@ int ap_proxy_connect_handler(request_rec *r, ap_cache_el  *c, char *url,
                     break;
             }
 
-            ap_get_revents(&pollevent, client_sock, pollfd);
+            apr_get_revents(&pollevent, client_sock, pollfd);
             if (pollevent & APR_POLLIN) {
                 ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                              "client was set");
@@ -292,7 +292,7 @@ int ap_proxy_connect_handler(request_rec *r, ap_cache_el  *c, char *url,
             break;
     }
     
-    ap_close_socket(sock);
+    apr_close_socket(sock);
 
     return OK;
 }
diff --git a/modules/proxy/proxy_ftp.c b/modules/proxy/proxy_ftp.c
index 2a82df9..82d32e0 100644
--- a/modules/proxy/proxy_ftp.c
+++ b/modules/proxy/proxy_ftp.c
@@ -127,7 +127,7 @@ static int ftp_check_string(const char *x)
 int ap_proxy_ftp_canon(request_rec *r, char *url)
 {
     char *user, *password, *host, *path, *parms, *strp, sport[7];
-    ap_pool_t *p = r->pool;
+    apr_pool_t *p = r->pool;
     const char *err;
     int port;
 
@@ -167,13 +167,13 @@ int ap_proxy_ftp_canon(request_rec *r, char *url)
         strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_parm, 1);
         if (strp == NULL)
         return HTTP_BAD_REQUEST;
-        parms = ap_pstrcat(p, parms, "?", strp, NULL);
+        parms = apr_pstrcat(p, parms, "?", strp, NULL);
     }
     else {
         strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_fpath, 1);
         if (strp == NULL)
         return HTTP_BAD_REQUEST;
-        path = ap_pstrcat(p, path, "?", strp, NULL);
+        path = apr_pstrcat(p, path, "?", strp, NULL);
     }
     r->args = NULL;
     }
@@ -181,11 +181,11 @@ int ap_proxy_ftp_canon(request_rec *r, char *url)
 /* now, rebuild URL */
 
     if (port != DEFAULT_FTP_PORT)
-    ap_snprintf(sport, sizeof(sport), ":%d", port);
+    apr_snprintf(sport, sizeof(sport), ":%d", port);
     else
     sport[0] = '\0';
 
-    r->filename = ap_pstrcat(p, "proxy:ftp://", (user != NULL) ? user : "",
+    r->filename = apr_pstrcat(p, "proxy:ftp://", (user != NULL) ? user : "",
                    (password != NULL) ? ":" : "",
                    (password != NULL) ? password : "",
                   (user != NULL) ? "@" : "", host, sport, "/", path,
@@ -254,7 +254,7 @@ static int ftp_getrc_msg(BUFF *f, char *msgbuf, int msglen)
     else
     status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
 
-    mb = ap_cpystrn(mb, linebuff+4, me - mb);
+    mb = apr_cpystrn(mb, linebuff+4, me - mb);
 
     if (linebuff[len - 1] != '\n')
         skiplf(f);
@@ -269,7 +269,7 @@ static int ftp_getrc_msg(BUFF *f, char *msgbuf, int msglen)
         if (linebuff[len - 1] != '\n') {
             skiplf(f);
         }
-        mb = ap_cpystrn(mb, linebuff+4, me - mb);
+        mb = apr_cpystrn(mb, linebuff+4, me - mb);
     } while (memcmp(linebuff, buff, 4) != 0);
     }
     return status;
@@ -283,7 +283,7 @@ static long int send_dir(BUFF *f, request_rec *r, ap_cache_el  *c, char *cwd)
     int searchidx = 0;
     char *searchptr = NULL;
     int firstfile = 1;
-    ap_ssize_t cntr;
+    apr_ssize_t cntr;
     unsigned long total_bytes_sent = 0;
     register int n, o, w;
     conn_rec *con = r->connection;
@@ -299,12 +299,12 @@ static long int send_dir(BUFF *f, request_rec *r, ap_cache_el  *c, char *cwd)
     (void)decodeenc(path);
 
     /* Copy path, strip (all except the last) trailing slashes */
-    path = dir = ap_pstrcat(r->pool, path, "/", NULL);
+    path = dir = apr_pstrcat(r->pool, path, "/", NULL);
     while ((n = strlen(path)) > 1 && path[n-1] == '/' && path[n-2] == '/')
     path[n-1] = '\0';
 
     /* print "ftp://host/" */
-    n = ap_snprintf(buf, sizeof(buf), DOCTYPE_HTML_3_2
+    n = apr_snprintf(buf, sizeof(buf), DOCTYPE_HTML_3_2
         "<HTML><HEAD><TITLE>%s%s</TITLE>\n"
         "<BASE HREF=\"%s%s\"></HEAD>\n"
         "<BODY><H2>Directory of "
@@ -320,16 +320,16 @@ static long int send_dir(BUFF *f, request_rec *r, ap_cache_el  *c, char *cwd)
     else
         ++reldir;
     /* print "path/" component */
-    ap_snprintf(buf, sizeof(buf), "<A HREF=\"/%s/\">%s</A>/", path+1, reldir);
+    apr_snprintf(buf, sizeof(buf), "<A HREF=\"/%s/\">%s</A>/", path+1, reldir);
     total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);
     *dir = '/';
     }
     /* If the caller has determined the current directory, and it differs */
     /* from what the client requested, then show the real name */
     if (cwd == NULL || strncmp (cwd, path, strlen(cwd)) == 0) {
-    ap_snprintf(buf, sizeof(buf), "</H2>\n<HR><PRE>");
+    apr_snprintf(buf, sizeof(buf), "</H2>\n<HR><PRE>");
     } else {
-    ap_snprintf(buf, sizeof(buf), "</H2>\n(%s)\n<HR><PRE>", cwd);
+    apr_snprintf(buf, sizeof(buf), "</H2>\n(%s)\n<HR><PRE>", cwd);
     }
     total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);
 
@@ -355,8 +355,8 @@ static long int send_dir(BUFF *f, request_rec *r, ap_cache_el  *c, char *cwd)
         *(link_ptr++) = '\0';
         if ((n = strlen(link_ptr)) > 1 && link_ptr[n - 1] == '\n')
           link_ptr[n - 1] = '\0';
-        ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s %s</A>\n", buf, filename, filename, link_ptr);
-        ap_cpystrn(buf, buf2, sizeof(buf));
+        apr_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s %s</A>\n", buf, filename, filename, link_ptr);
+        apr_cpystrn(buf, buf2, sizeof(buf));
         n = strlen(buf);
     }
     else if (buf[0] == 'd' || buf[0] == '-' || buf[0] == 'l' || ap_isdigit(buf[0])) {
@@ -386,13 +386,13 @@ static long int send_dir(BUFF *f, request_rec *r, ap_cache_el  *c, char *cwd)
 
         /* Special handling for '.' and '..' */
         if (!strcmp(filename, ".") || !strcmp(filename, "..") || buf[0] == 'd') {
-        ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s/\">%s</A>\n",
+        apr_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s/\">%s</A>\n",
             buf, filename, filename);
         }
         else {
-        ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s</A>\n", buf, filename, filename);
+        apr_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s</A>\n", buf, filename, filename);
         }
-        ap_cpystrn(buf, buf2, sizeof(buf));
+        apr_cpystrn(buf, buf2, sizeof(buf));
         n = strlen(buf);
     }
 
@@ -443,8 +443,8 @@ static int ftp_unauthorized (request_rec *r, int log_it)
               ap_unparse_uri_components(r->pool,
               &r->parsed_uri, UNP_OMITPATHINFO));
 
-    ap_table_setn(r->err_headers_out, "WWW-Authenticate",
-                  ap_pstrcat(r->pool, "Basic realm=\"",
+    apr_table_setn(r->err_headers_out, "WWW-Authenticate",
+                  apr_pstrcat(r->pool, "Basic realm=\"",
           ap_unparse_uri_components(r->pool, &r->parsed_uri,
                         UNP_OMITPASSWORD|UNP_OMITPATHINFO),
           "\"", NULL));
@@ -465,16 +465,16 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
     char *user = NULL;
 /*    char *account = NULL; how to supply an account in a URL? */
     const char *password = NULL;
-    ap_socket_t *sock, *dsock, *inc;
+    apr_socket_t *sock, *dsock, *inc;
     int port, i, j, len, rc, nocache = 0;
-    ap_socket_t *csd;
+    apr_socket_t *csd;
     struct in_addr destaddr;
     BUFF *f, *cachefp = NULL;
     BUFF *data = NULL;
-    ap_pool_t *p = r->pool;
+    apr_pool_t *p = r->pool;
     int one = 1;
     const long int zero = 0L;
-    ap_table_t *resp_hdrs;
+    apr_table_t *resp_hdrs;
     
     void *sconf = r->server->module_config;
     proxy_server_conf *conf =
@@ -490,7 +490,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
     char *pstr, dates[AP_RFC822_DATE_LEN];
 
     char *npaddr;
-    ap_uint32_t npport;
+    apr_uint32_t npport;
     
 /* stuff for responses */
     char resp[MAX_STRING_LEN];
@@ -507,7 +507,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
     port = (r->parsed_uri.port != 0)
         ? r->parsed_uri.port
         : ap_default_port_for_request(r);
-    path = ap_pstrdup(p, r->parsed_uri.path);
+    path = apr_pstrdup(p, r->parsed_uri.path);
     path = (path != NULL && path[0] != '\0') ? &path[1] : "";
 
     /* The "Authorization:" header must be checked first.
@@ -518,7 +518,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
      * simply uuencodes the plain text password. 
      * But chances are still smaller that the URL is logged regularly.
      */
-    if ((password = ap_table_get(r->headers_in, "Authorization")) != NULL
+    if ((password = apr_table_get(r->headers_in, "Authorization")) != NULL
     && strcasecmp(ap_getword(r->pool, &password, ' '), "Basic") == 0
         && (password = ap_pbase64decode(r->pool, password))[0] != ':') {
         /* Note that this allocation has to be made from r->connection->pool
@@ -531,10 +531,10 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
         nocache = 1;    /* This resource only accessible with username/password */
     }
     else if ((user = r->parsed_uri.user) != NULL) {
-    user = ap_pstrdup(p, user);
+    user = apr_pstrdup(p, user);
     decodeenc(user);
     if ((password = r->parsed_uri.password) != NULL) {
-        char *tmp = ap_pstrdup(p, password);
+        char *tmp = apr_pstrdup(p, password);
         decodeenc(tmp);
         password = tmp;
     }
@@ -561,30 +561,30 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
     if (parms != NULL)
     *(parms++) = '\0';
 
-    if ((ap_create_tcp_socket(&sock, r->pool)) != APR_SUCCESS) {
+    if ((apr_create_tcp_socket(&sock, r->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "proxy: error creating socket");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
-    if (conf->recv_buffer_size > 0 && ap_setsocketopt(sock, APR_SO_RCVBUF,conf->recv_buffer_size)) {
+    if (conf->recv_buffer_size > 0 && apr_setsocketopt(sock, APR_SO_RCVBUF,conf->recv_buffer_size)) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
     }
     
-    if (ap_setsocketopt(sock, APR_SO_REUSEADDR, one)) {
+    if (apr_setsocketopt(sock, APR_SO_REUSEADDR, one)) {
 #ifndef _OSD_POSIX /* BS2000 has this option "always on" */
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
-        ap_close_socket(sock);
+        apr_close_socket(sock);
         return HTTP_INTERNAL_SERVER_ERROR;
 #endif /*_OSD_POSIX*/
     }
 
     if (ap_proxy_doconnect(sock, host, port, r) == -1) {
-        ap_close_socket(sock);
+        apr_close_socket(sock);
         return ap_proxyerror(r, HTTP_BAD_GATEWAY,
-                             ap_pstrcat(r->pool, "Could not connect to remote machine: ",
+                             apr_pstrcat(r->pool, "Could not connect to remote machine: ",
                                         strerror(errno), NULL));
     }
 
@@ -619,7 +619,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
      *  after the time of the response.
      *     Retry-After  = "Retry-After" ":" ( HTTP-date | delta-seconds )
      */
-    ap_set_header("Retry-After", ap_psprintf(p, "%u", 60*wait_mins);
+    ap_set_header("Retry-After", apr_psprintf(p, "%u", 60*wait_mins);
     return ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE, resp);
     }
 #endif
@@ -776,14 +776,14 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
     }
 
 /* try to set up PASV data connection first */
-    if ((ap_create_tcp_socket(&dsock, r->pool)) != APR_SUCCESS) {
+    if ((apr_create_tcp_socket(&dsock, r->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "proxy: error creating PASV socket");
         ap_bclose(f);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
-    if (conf->recv_buffer_size > 0 && ap_setsocketopt(dsock, APR_SO_RCVBUF,conf->recv_buffer_size)) {
+    if (conf->recv_buffer_size > 0 && apr_setsocketopt(dsock, APR_SO_RCVBUF,conf->recv_buffer_size)) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
              "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
     }
@@ -803,7 +803,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
     if (i == -1) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, r,
                       "PASV: control connection is toast");
-        ap_close_socket(dsock);
+        apr_close_socket(dsock);
         ap_bclose(f);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -838,7 +838,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
 
             if (ap_proxy_doconnect(dsock, inet_ntoa(destaddr), pport, r) == -1) {
                 return ap_proxyerror(r, HTTP_BAD_GATEWAY,
-                                     ap_pstrcat(r->pool,
+                                     apr_pstrcat(r->pool,
                                                 "Could not connect to remote machine: ",
                                                 strerror(errno), NULL));
             }
@@ -847,43 +847,43 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
             }
         }
         else
-            ap_close_socket(dsock);    /* and try the regular way */
+            apr_close_socket(dsock);    /* and try the regular way */
     }
 
     if (!pasvmode) {        /* set up data connection */
         
-        if ((ap_create_tcp_socket(&dsock, r->pool)) != APR_SUCCESS) {
+        if ((apr_create_tcp_socket(&dsock, r->pool)) != APR_SUCCESS) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "proxy: error creating socket");
             ap_bclose(f);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
-        ap_get_local_port(&npport, sock);
-        ap_get_local_ipaddr(&npaddr, sock);
-        ap_set_local_port(dsock, npport);
-        ap_set_local_ipaddr(dsock, npaddr);
+        apr_get_local_port(&npport, sock);
+        apr_get_local_ipaddr(&npaddr, sock);
+        apr_set_local_port(dsock, npport);
+        apr_set_local_ipaddr(dsock, npaddr);
         
-        if (ap_setsocketopt(dsock, APR_SO_REUSEADDR, one) != APR_SUCCESS) {
+        if (apr_setsocketopt(dsock, APR_SO_REUSEADDR, one) != APR_SUCCESS) {
 #ifndef _OSD_POSIX /* BS2000 has this option "always on" */
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "proxy: error setting reuseaddr option");
-            ap_close_socket(dsock);
+            apr_close_socket(dsock);
             ap_bclose(f);
             return HTTP_INTERNAL_SERVER_ERROR;
 #endif /*_OSD_POSIX*/
         }
 
-        if (ap_bind(dsock) != APR_SUCCESS) {
+        if (apr_bind(dsock) != APR_SUCCESS) {
             char buff[22];
 
-            ap_snprintf(buff, sizeof(buff), "%s:%d", npaddr, npport);
+            apr_snprintf(buff, sizeof(buff), "%s:%d", npaddr, npport);
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "proxy: error binding to ftp data socket %s", buff);
             ap_bclose(f);
-            ap_close_socket(dsock);
+            apr_close_socket(dsock);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
-        ap_listen(dsock, 2);    /* only need a short queue */
+        apr_listen(dsock, 2);    /* only need a short queue */
     }
 
 /* set request; "path" holds last path component */
@@ -940,7 +940,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
                     ;
                 resp[j] = '\0';
                 if (resp[0] != '\0')
-                    size = ap_pstrdup(p, resp);
+                    size = apr_pstrdup(p, resp);
             }
         }
     }
@@ -1084,26 +1084,26 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
 
     r->status = HTTP_OK;
     r->status_line = "200 OK";
-    resp_hdrs = ap_make_table(p, 2);
+    resp_hdrs = apr_make_table(p, 2);
     
-    ap_rfc822_date(dates, r->request_time);
-    ap_table_setn(resp_hdrs, "Date", dates);
-    ap_table_setn(resp_hdrs, "Server", ap_get_server_version());
+    apr_rfc822_date(dates, r->request_time);
+    apr_table_setn(resp_hdrs, "Date", dates);
+    apr_table_setn(resp_hdrs, "Server", ap_get_server_version());
 
     if (parms[0] == 'd')
-        ap_table_setn(resp_hdrs, "Content-Type", "text/html");
+        apr_table_setn(resp_hdrs, "Content-Type", "text/html");
     else {
     if (r->content_type != NULL) {
-        ap_table_setn(resp_hdrs, "Content-Type", r->content_type);
+        apr_table_setn(resp_hdrs, "Content-Type", r->content_type);
         ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                      "FTP: Content-Type set to %s", r->content_type);
     }
     else {
-        ap_table_setn(resp_hdrs, "Content-Type", ap_default_type(r));
+        apr_table_setn(resp_hdrs, "Content-Type", ap_default_type(r));
     }
     if (parms[0] != 'a' && size != NULL) {
         /* We "trust" the ftp server to really serve (size) bytes... */
-        ap_table_setn(resp_hdrs, "Content-Length", size);
+        apr_table_setn(resp_hdrs, "Content-Length", size);
         ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                      "FTP: Content-Length set to %s", size);
     }
@@ -1111,7 +1111,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
     if (r->content_encoding != NULL && r->content_encoding[0] != '\0') {
         ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                      "FTP: Content-Encoding set to %s", r->content_encoding);
-        ap_table_setn(resp_hdrs, "Content-Encoding", r->content_encoding);
+        apr_table_setn(resp_hdrs, "Content-Encoding", r->content_encoding);
     }
     ap_cache_el_header_merge(c, resp_hdrs);
     
@@ -1130,7 +1130,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
     if (!pasvmode) {        /* wait for connection */
         for(;;)
         {
-            switch(ap_accept(&inc, dsock, r->pool))
+            switch(apr_accept(&inc, dsock, r->pool))
             {
             case APR_EINTR:
                 continue;
@@ -1139,7 +1139,7 @@ int ap_proxy_ftp_handler(request_rec *r, ap_cache_el  *c, char *url)
             default:
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "proxy: failed to accept data connection");
-                ap_close_socket(dsock);
+                apr_close_socket(dsock);
                 ap_bclose(f);
                 if (c != NULL) ap_proxy_cache_error(&c);
                 return HTTP_BAD_GATEWAY;
diff --git a/modules/proxy/proxy_http.c b/modules/proxy/proxy_http.c
index 7fc91b5..38794c7 100644
--- a/modules/proxy/proxy_http.c
+++ b/modules/proxy/proxy_http.c
@@ -104,11 +104,11 @@ int ap_proxy_http_canon(request_rec *r, char *url, const char *scheme, int def_p
     return HTTP_BAD_REQUEST;
 
     if (port != def_port)
-    ap_snprintf(sport, sizeof(sport), ":%d", port);
+    apr_snprintf(sport, sizeof(sport), ":%d", port);
     else
     sport[0] = '\0';
 
-    r->filename = ap_pstrcat(r->pool, "proxy:", scheme, "://", host, sport, "/",
+    r->filename = apr_pstrcat(r->pool, "proxy:", scheme, "://", host, sport, "/",
            path, (search) ? "?" : "", (search) ? search : "", NULL);
     return OK;
 }
@@ -128,20 +128,20 @@ static const char *proxy_location_reverse_map(request_rec *r, const char *url)
     for (i = 0; i < conf->raliases->nelts; i++) {
         l2 = strlen(ent[i].real);
         if (l1 >= l2 && strncmp(ent[i].real, url, l2) == 0) {
-            u = ap_pstrcat(r->pool, ent[i].fake, &url[l2], NULL);
+            u = apr_pstrcat(r->pool, ent[i].fake, &url[l2], NULL);
             return ap_construct_url(r->pool, u, r);
         }
     }
     return url;
 }
 
-/* Clear all connection-based headers from the incoming headers ap_table_t */
-static void clear_connection(ap_pool_t *p, ap_table_t *headers)
+/* Clear all connection-based headers from the incoming headers apr_table_t */
+static void clear_connection(apr_pool_t *p, apr_table_t *headers)
 {
     const char *name;
-    char *next = ap_pstrdup(p, ap_table_get(headers, "Connection"));
+    char *next = apr_pstrdup(p, apr_table_get(headers, "Connection"));
 
-    ap_table_unset(headers, "Proxy-Connection");
+    apr_table_unset(headers, "Proxy-Connection");
     if (!next)
         return;
 
@@ -153,9 +153,9 @@ static void clear_connection(ap_pool_t *p, ap_table_t *headers)
             *next = '\0';
             ++next;
         }
-        ap_table_unset(headers, name);
+        apr_table_unset(headers, name);
     }
-    ap_table_unset(headers, "Connection");
+    apr_table_unset(headers, "Connection");
 }
 
 /*
@@ -173,20 +173,20 @@ int ap_proxy_http_handler(request_rec *r, ap_cache_el  *c, char *url,
     const char *strp;
     char *strp2;
     const char *desthost;
-    ap_socket_t *sock;
+    apr_socket_t *sock;
     int i, len, backasswards, content_length=-1;
-    ap_array_header_t *reqhdrs_arr;
-    ap_table_t *resp_hdrs=NULL;
-    ap_table_entry_t *reqhdrs;
+    apr_array_header_t *reqhdrs_arr;
+    apr_table_t *resp_hdrs=NULL;
+    apr_table_entry_t *reqhdrs;
     struct sockaddr_in server;
     struct in_addr destaddr;
     BUFF *f, *cachefp=NULL;
     char buffer[HUGE_STRING_LEN];
     char portstr[32];
-    ap_pool_t *p = r->pool;
+    apr_pool_t *p = r->pool;
     const long int zero = 0L;
     int destport = 0;
-    ap_ssize_t cntr;
+    apr_ssize_t cntr;
     char *destportstr = NULL;
     const char *urlptr = NULL;
     char *datestr, *clen;
@@ -210,11 +210,11 @@ int ap_proxy_http_handler(request_rec *r, ap_cache_el  *c, char *url,
     destport = DEFAULT_HTTP_PORT;
     strp = strchr(urlptr, '/');
     if (strp == NULL) {
-        desthost = ap_pstrdup(p, urlptr);
+        desthost = apr_pstrdup(p, urlptr);
         urlptr = "/";
     }
     else {
-        char *q = ap_palloc(p, strp - urlptr + 1);
+        char *q = apr_palloc(p, strp - urlptr + 1);
         memcpy(q, urlptr, strp - urlptr);
         q[strp - urlptr] = '\0';
         urlptr = strp;
@@ -239,13 +239,13 @@ int ap_proxy_http_handler(request_rec *r, ap_cache_el  *c, char *url,
                                  "Connect to remote machine blocked");
     }
 
-    if ((ap_create_tcp_socket(&sock, r->pool)) != APR_SUCCESS) {
+    if ((apr_create_tcp_socket(&sock, r->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "proxy: error creating socket");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
-    if (conf->recv_buffer_size > 0 && ap_setsocketopt(sock, APR_SO_RCVBUF,conf->recv_buffer_size)) {
+    if (conf->recv_buffer_size > 0 && apr_setsocketopt(sock, APR_SO_RCVBUF,conf->recv_buffer_size)) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
     }
@@ -262,7 +262,7 @@ int ap_proxy_http_handler(request_rec *r, ap_cache_el  *c, char *url,
             return DECLINED;    /* try again another way */
         else
             return ap_proxyerror(r, HTTP_BAD_GATEWAY,
-                ap_pstrcat(r->pool, "Could not connect to remote machine: ",
+                apr_pstrcat(r->pool, "Could not connect to remote machine: ",
                     strerror(errno), NULL));
     }
 
@@ -280,24 +280,24 @@ int ap_proxy_http_handler(request_rec *r, ap_cache_el  *c, char *url,
 
     if (conf->viaopt == via_block) {
         /* Block all outgoing Via: headers */
-        ap_table_unset(r->headers_in, "Via");
+        apr_table_unset(r->headers_in, "Via");
     } else if (conf->viaopt != via_off) {
         /* Create a "Via:" request header entry and merge it */
         i = ap_get_server_port(r);
         if (ap_is_default_port(i,r)) {
             strcpy(portstr,"");
         } else {
-            ap_snprintf(portstr, sizeof portstr, ":%d", i);
+            apr_snprintf(portstr, sizeof portstr, ":%d", i);
         }
         /* Generate outgoing Via: header with/without server comment: */
-        ap_table_mergen(r->headers_in, "Via",
+        apr_table_mergen(r->headers_in, "Via",
                         (conf->viaopt == via_full)
-                        ? ap_psprintf(p, "%d.%d %s%s (%s)",
+                        ? apr_psprintf(p, "%d.%d %s%s (%s)",
                                       HTTP_VERSION_MAJOR(r->proto_num),
                                       HTTP_VERSION_MINOR(r->proto_num),
                                       ap_get_server_name(r), portstr,
                                       AP_SERVER_BASEVERSION)
-                        : ap_psprintf(p, "%d.%d %s%s",
+                        : apr_psprintf(p, "%d.%d %s%s",
                                       HTTP_VERSION_MAJOR(r->proto_num),
                                       HTTP_VERSION_MINOR(r->proto_num),
                                       ap_get_server_name(r), portstr)
@@ -305,7 +305,7 @@ int ap_proxy_http_handler(request_rec *r, ap_cache_el  *c, char *url,
     }
 
     reqhdrs_arr = ap_table_elts(r->headers_in);
-    reqhdrs = (ap_table_entry_t *) reqhdrs_arr->elts;
+    reqhdrs = (apr_table_entry_t *) reqhdrs_arr->elts;
     for (i = 0; i < reqhdrs_arr->nelts; i++) {
         if (reqhdrs[i].key == NULL || reqhdrs[i].val == NULL
             /* Clear out headers not to send */
@@ -361,7 +361,7 @@ int ap_proxy_http_handler(request_rec *r, ap_cache_el  *c, char *url,
         buffer[12] = '\0';
         r->status = atoi(&buffer[9]);
         buffer[12] = ' ';
-        r->status_line = ap_pstrdup(p, &buffer[9]);
+        r->status_line = apr_pstrdup(p, &buffer[9]);
 
 /* read the headers. */
 /* N.B. for HTTP/1.0 clients, we have to fold line-wrapped headers */
@@ -385,12 +385,12 @@ int ap_proxy_http_handler(request_rec *r, ap_cache_el  *c, char *url,
             if (ap_is_default_port(i,r)) {
                 strcpy(portstr,"");
             } else {
-                ap_snprintf(portstr, sizeof portstr, ":%d", i);
+                apr_snprintf(portstr, sizeof portstr, ":%d", i);
             }
             ap_cache_el_header_add(c, "Via", (conf->viaopt == via_full)
-                         ? ap_psprintf(p, "%d.%d %s%s (%s)", major, minor,
+                         ? apr_psprintf(p, "%d.%d %s%s (%s)", major, minor,
                                        ap_get_server_name(r), portstr, AP_SERVER_BASEVERSION)
-                         : ap_psprintf(p, "%d.%d %s%s", major, minor, ap_get_server_name(r), portstr)
+                         : apr_psprintf(p, "%d.%d %s%s", major, minor, ap_get_server_name(r), portstr)
                 );
         }
     }
diff --git a/modules/proxy/proxy_util.c b/modules/proxy/proxy_util.c
index 9c2ee29..4bbc8b5 100644
--- a/modules/proxy/proxy_util.c
+++ b/modules/proxy/proxy_util.c
@@ -137,7 +137,7 @@ void ap_proxy_c2hex(int ch, char *x)
  * those which must not be touched.
  */
 char *
-     ap_proxy_canonenc(ap_pool_t *p, const char *x, int len, enum enctype t, int isenc)
+     ap_proxy_canonenc(apr_pool_t *p, const char *x, int len, enum enctype t, int isenc)
 {
     int i, j, ch;
     char *y;
@@ -169,7 +169,7 @@ char *
     else
     reserved = "";
 
-    y = ap_palloc(p, 3 * len + 1);
+    y = apr_palloc(p, 3 * len + 1);
 
     for (i = 0, j = 0; i < len; i++, j++) {
 /* always handle '/' first */
@@ -213,7 +213,7 @@ char *
  * Returns an error string.
  */
 char *
-     ap_proxy_canon_netloc(ap_pool_t *p, char **const urlp, char **userp,
+     ap_proxy_canon_netloc(apr_pool_t *p, char **const urlp, char **userp,
             char **passwordp, char **hostp, int *port)
 {
     int i;
@@ -311,7 +311,7 @@ static const char * const lwday[7] =
  * formatted, then it exits very quickly.
  */
 const char *
-     ap_proxy_date_canon(ap_pool_t *p, const char *x)
+     ap_proxy_date_canon(apr_pool_t *p, const char *x)
 {
     int wk, mday, year, hour, min, sec, mon;
     char *q, month[4], zone[4], week[4];
@@ -359,8 +359,8 @@ const char *
     if (mon == 12)
     return x;
 
-    q = ap_palloc(p, 30);
-    ap_snprintf(q, 30, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", ap_day_snames[wk], mday,
+    q = apr_palloc(p, 30);
+    apr_snprintf(q, 30, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", ap_day_snames[wk], mday,
         ap_month_snames[mon], year, hour, min, sec);
     return q;
 }
@@ -430,14 +430,14 @@ static int proxy_getline(char *s, int n, BUFF *in, int fold)
  * @@@: XXX: FIXME: currently the headers are passed thru un-merged. 
  * Is that okay, or should they be collapsed where possible?
  */
-ap_table_t *ap_proxy_read_headers(request_rec *r, char *buffer, int size, BUFF *f)
+apr_table_t *ap_proxy_read_headers(request_rec *r, char *buffer, int size, BUFF *f)
 {
-    ap_table_t *resp_hdrs;
+    apr_table_t *resp_hdrs;
     int len;
     char *value, *end;
     char field[MAX_STRING_LEN];
 
-    resp_hdrs = ap_make_table(r->pool, 20);
+    resp_hdrs = apr_make_table(r->pool, 20);
 
     /*
      * Read header lines until we get the empty separator line, a read error,
@@ -476,7 +476,7 @@ ap_table_t *ap_proxy_read_headers(request_rec *r, char *buffer, int size, BUFF *
     for (end = &value[strlen(value)-1]; end > value && ap_isspace(*end); --end)
         *end = '\0';
 
-        ap_table_add(resp_hdrs, buffer, value);
+        apr_table_add(resp_hdrs, buffer, value);
 
     /* the header was too long; at the least we should skip extra data */
     if (len >= size - 1) { 
@@ -496,7 +496,7 @@ long int ap_proxy_send_fb(proxy_completion *completion, BUFF *f, request_rec *r,
     int  ok;
     char buf[IOBUFSIZE];
     long total_bytes_rcvd, in_buffer;
-    ap_ssize_t cntr;
+    apr_ssize_t cntr;
     register int n, o;
     conn_rec *con = r->connection;
     int alternate_timeouts = 1;    /* 1 if we alternate between soft & hard timeouts */
@@ -603,18 +603,18 @@ long int ap_proxy_send_fb(proxy_completion *completion, BUFF *f, request_rec *r,
  * 
  * A timeout should be set before calling this routine.
  */
-void ap_proxy_send_headers(request_rec *r, const char *respline, ap_table_t *t)
+void ap_proxy_send_headers(request_rec *r, const char *respline, apr_table_t *t)
 {
     int i;
     BUFF *fp = r->connection->client;
-    ap_table_entry_t *elts = (ap_table_entry_t *) ap_table_elts(t)->elts;
+    apr_table_entry_t *elts = (apr_table_entry_t *) ap_table_elts(t)->elts;
 
     ap_bvputs(fp, respline, CRLF, NULL);
 
     for (i = 0; i < ap_table_elts(t)->nelts; ++i) {
         if (elts[i].key != NULL) {
             ap_bvputs(fp, elts[i].key, ": ", elts[i].val, CRLF, NULL);
-            ap_table_addn(r->headers_out, elts[i].key, elts[i].val);
+            apr_table_addn(r->headers_out, elts[i].key, elts[i].val);
         }
     }
 
@@ -712,8 +712,8 @@ void ap_proxy_cache_error(ap_cache_el  **c)
 
 int ap_proxyerror(request_rec *r, int statuscode, const char *message)
 {
-    ap_table_setn(r->notes, "error-notes",
-          ap_pstrcat(r->pool, 
+    apr_table_setn(r->notes, "error-notes",
+          apr_pstrcat(r->pool, 
                  "The proxy server could not handle the request "
                  "<EM><A HREF=\"", ap_escape_uri(r->pool, r->uri),
                  "\">", ap_escape_html(r->pool, r->method),
@@ -724,9 +724,9 @@ int ap_proxyerror(request_rec *r, int statuscode, const char *message)
                  "</STRONG>", NULL));
 
     /* Allow "error-notes" string to be printed by ap_send_error_response() */
-    ap_table_setn(r->notes, "verbose-error-to", ap_pstrdup(r->pool, "*"));
+    apr_table_setn(r->notes, "verbose-error-to", apr_pstrdup(r->pool, "*"));
 
-    r->status_line = ap_psprintf(r->pool, "%3.3u Proxy Error", statuscode);
+    r->status_line = apr_psprintf(r->pool, "%3.3u Proxy Error", statuscode);
     return statuscode;
 }
 
@@ -784,7 +784,7 @@ static const char *
     || url[1] != '/' || url[2] != '/')
     return NULL;
 
-    url = ap_pstrdup(r->pool, &url[1]);    /* make it point to "//", which is what proxy_canon_netloc expects */
+    url = apr_pstrdup(r->pool, &url[1]);    /* make it point to "//", which is what proxy_canon_netloc expects */
 
     err = ap_proxy_canon_netloc(r->pool, &url, &user, &password, &host, &port);
 
@@ -798,7 +798,7 @@ static const char *
 }
 
 /* Return TRUE if addr represents an IP address (or an IP network address) */
-int ap_proxy_is_ipaddr(struct dirconn_entry *This, ap_pool_t *p)
+int ap_proxy_is_ipaddr(struct dirconn_entry *This, apr_pool_t *p)
 {
     const char *addr = This->name;
     long ip_addr[4];
@@ -994,7 +994,7 @@ static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r)
 }
 
 /* Return TRUE if addr represents a domain name */
-int ap_proxy_is_domainname(struct dirconn_entry *This, ap_pool_t *p)
+int ap_proxy_is_domainname(struct dirconn_entry *This, apr_pool_t *p)
 {
     char *addr = This->name;
     int i;
@@ -1048,7 +1048,7 @@ static int proxy_match_domainname(struct dirconn_entry *This, request_rec *r)
 }
 
 /* Return TRUE if addr represents a host name */
-int ap_proxy_is_hostname(struct dirconn_entry *This, ap_pool_t *p)
+int ap_proxy_is_hostname(struct dirconn_entry *This, apr_pool_t *p)
 {
     struct hostent host;
     char *addr = This->name;
@@ -1115,7 +1115,7 @@ static int proxy_match_hostname(struct dirconn_entry *This, request_rec *r)
 }
 
 /* Return TRUE if addr is to be matched as a word */
-int ap_proxy_is_word(struct dirconn_entry *This, ap_pool_t *p)
+int ap_proxy_is_word(struct dirconn_entry *This, apr_pool_t *p)
 {
     This->matcher = proxy_match_word;
     return 1;
@@ -1128,21 +1128,21 @@ static int proxy_match_word(struct dirconn_entry *This, request_rec *r)
     return host != NULL && strstr(host, This->name) != NULL;
 }
 
-int ap_proxy_doconnect(ap_socket_t *sock, char *host, ap_uint32_t port, request_rec *r)
+int ap_proxy_doconnect(apr_socket_t *sock, char *host, apr_uint32_t port, request_rec *r)
 {
     int i;
     for (i = 0; host[i] != '\0'; i++)
         if (!ap_isdigit(host[i]) && host[i] != '.')
             break;
 
-    ap_set_remote_port(sock, port);
+    apr_set_remote_port(sock, port);
     if (host[i] == '\0') {
-        ap_set_remote_ipaddr(sock, host);
+        apr_set_remote_ipaddr(sock, host);
         host = NULL;
     }
     for(;;)
     {
-        switch(ap_connect(sock, host))
+        switch(apr_connect(sock, host))
         {
         case APR_EINTR:
             continue;
@@ -1156,7 +1156,7 @@ int ap_proxy_doconnect(ap_socket_t *sock, char *host, ap_uint32_t port, request_
     return -1;
 }
 
-/* This function is called by ap_table_do() for all header lines */
+/* This function is called by apr_table_do() for all header lines */
 /* (from proxy_http.c and proxy_ftp.c) */
 /* It is passed a table_do_args struct pointer and a MIME field and value pair */
 int ap_proxy_send_hdr_line(void *p, const char *key, const char *value)
@@ -1166,7 +1166,7 @@ int ap_proxy_send_hdr_line(void *p, const char *key, const char *value)
         return 1;
     if (!r->assbackwards)
         ap_rvputs(r, key, ": ", value, CRLF, NULL);
-    return 1; /* tell ap_table_do() to continue calling us for more headers */
+    return 1; /* tell apr_table_do() to continue calling us for more headers */
 }
 
 /* send a text line to one or two BUFF's; return line length */
@@ -1201,9 +1201,9 @@ int ap_proxy_cache_send(request_rec *r, ap_cache_el *c)
     return OK;
 }
 
-int ap_proxy_cache_should_cache(request_rec *r, ap_table_t *resp_hdrs, const int is_HTTP1)
+int ap_proxy_cache_should_cache(request_rec *r, apr_table_t *resp_hdrs, const int is_HTTP1)
 {
-    const char *expire = ap_table_get(resp_hdrs, "Expires");
+    const char *expire = apr_table_get(resp_hdrs, "Expires");
     time_t expc;
     if (expire != NULL)
         expc = ap_parseHTTPdate(expire);
@@ -1212,9 +1212,9 @@ int ap_proxy_cache_should_cache(request_rec *r, ap_table_t *resp_hdrs, const int
     if((r->status != HTTP_OK && r->status != HTTP_MOVED_PERMANENTLY && r->status != HTTP_NOT_MODIFIED) ||
        (r->status == HTTP_NOT_MODIFIED) ||
        r->header_only ||
-       ap_table_get(r->headers_in, "Authorization") != NULL ||
+       apr_table_get(r->headers_in, "Authorization") != NULL ||
        (expire != NULL && expc == BAD_DATE) ||
-       (r->status == HTTP_OK && !ap_table_get(resp_hdrs, "Last-Modified") && is_HTTP1))
+       (r->status == HTTP_OK && !apr_table_get(resp_hdrs, "Last-Modified") && is_HTTP1))
     {
         ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                      "proxy: Response is not cacheable: %s", r->unparsed_uri);
diff --git a/modules/test/mod_rndchunk.c b/modules/test/mod_rndchunk.c
index e6c4ee1..d28ff0b 100644
--- a/modules/test/mod_rndchunk.c
+++ b/modules/test/mod_rndchunk.c
@@ -167,7 +167,7 @@ module rndchunk_module = {
     NULL,                       /* dir merger --- default is to override */
     NULL,                       /* server config */
     NULL,                       /* merge server config */
-    NULL,			/* command ap_table_t */
+    NULL,			/* command apr_table_t */
     rndchunk_handlers,	        /* handlers */
     NULL,                       /* filename translation */
     NULL,                       /* check_user_id */
diff --git a/modules/test/mod_test_util_uri.c b/modules/test/mod_test_util_uri.c
index eb291f1..0b48ebb 100644
--- a/modules/test/mod_test_util_uri.c
+++ b/modules/test/mod_test_util_uri.c
@@ -67,7 +67,7 @@
  * SetHandler test-util-uri
  * </Location>
  *
- * Then make a request to /test-util-uri.  An html ap_table_t of errors will
+ * Then make a request to /test-util-uri.  An html apr_table_t of errors will
  * be output... and a total count of errors.
  */
 
@@ -139,7 +139,7 @@ static char *my_stpcpy(char *d, const char *s)
 static unsigned iterate_pieces(request_rec *r, const test_uri_t *pieces, int row)
 {
     unsigned u;
-    ap_pool_t *sub;
+    apr_pool_t *sub;
     char *input_uri;
     char *strp;
     uri_components result;
@@ -149,7 +149,7 @@ static unsigned iterate_pieces(request_rec *r, const test_uri_t *pieces, int row
 
     failures = 0;
 
-    input_uri = ap_palloc(r->pool,
+    input_uri = apr_palloc(r->pool,
 	strlen(pieces->scheme) + 3
 	+ strlen(pieces->user) + 1
 	+ strlen(pieces->password) + 1
@@ -207,7 +207,7 @@ static unsigned iterate_pieces(request_rec *r, const test_uri_t *pieces, int row
 	}
 	*strp = 0;
 
-	sub = ap_make_sub_pool(r->pool);
+	sub = apr_make_sub_pool(r->pool);
 	status = ap_parse_uri_components(sub, input_uri, &result);
 	if (status == HTTP_OK) {
 #define CHECK(f)							\
@@ -255,7 +255,7 @@ static unsigned iterate_pieces(request_rec *r, const test_uri_t *pieces, int row
 	    ap_rputs("</tr>\n", r);
 	    ++failures;
 	}
-	ap_destroy_pool(sub);
+	apr_destroy_pool(sub);
     }
     return failures;
 }
@@ -342,7 +342,7 @@ module test_util_uri_module = {
     NULL,                       /* dir merger --- default is to override */
     NULL,                       /* server config */
     NULL,                       /* merge server config */
-    NULL,			/* command ap_table_t */
+    NULL,			/* command apr_table_t */
     test_util_uri_handlers,	/* handlers */
     NULL,                       /* filename translation */
     NULL,                       /* check_user_id */
diff --git a/os/beos/beosd.c b/os/beos/beosd.c
index 5cadf5a..e86314b 100644
--- a/os/beos/beosd.c
+++ b/os/beos/beosd.c
@@ -85,7 +85,7 @@ void beosd_detach(void)
         char buf[120];
 	ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
                      "%s: unable to replace stdin with /dev/null: %s",
-		ap_server_argv0, ap_strerror(errno, buf, sizeof(buf)));
+		ap_server_argv0, apr_strerror(errno, buf, sizeof(buf)));
 	/* continue anyhow -- note we can't close out descriptor 0 because we
 	 * have nothing to replace it with, and if we didn't have a descriptor
 	 * 0 the next file would be created with that value ... leading to
@@ -96,7 +96,7 @@ void beosd_detach(void)
         char buf[120];
 	ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
                      "%s: unable to replace stdout with /dev/null: %s",
-		ap_server_argv0, ap_strerror(errno, buf, sizeof(buf)));
+		ap_server_argv0, apr_strerror(errno, buf, sizeof(buf)));
     }
     /* stderr is a tricky one, we really want it to be the error_log,
      * but we haven't opened that yet.  So leave it alone for now and it'll
diff --git a/os/bs2000/bs2login.c b/os/bs2000/bs2login.c
index 38ef902..8edad89 100644
--- a/os/bs2000/bs2login.c
+++ b/os/bs2000/bs2login.c
@@ -169,11 +169,11 @@ static bs2_ForkType os_forktype(void)
 
 /* This routine is called by http_core for the BS2000Account directive */
 /* It stores the account name for later use */
-const char *os_set_account(ap_pool_t *p, const char *account)
+const char *os_set_account(apr_pool_t *p, const char *account)
 {
     char account_temp[ACCT_LEN+1];
 
-    ap_cpystrn(account_temp, account, sizeof account_temp);
+    apr_cpystrn(account_temp, account, sizeof account_temp);
 
     /* Make account all upper case */
     ap_str_toupper(account_temp);
@@ -181,7 +181,7 @@ const char *os_set_account(ap_pool_t *p, const char *account)
     /* Pad to length 8 */
     ap_pad(account_temp, sizeof account_temp, ' ');
 
-    bs2000_account = ap_pstrdup(p, account_temp);
+    bs2000_account = apr_pstrdup(p, account_temp);
     return NULL;
 }
 
@@ -226,7 +226,7 @@ int os_init_job_environment(server_rec *server, const char *user_name, int one_p
 	exit(APEXIT_CHILDFATAL);
     }
 
-    ap_cpystrn(username, user_name, sizeof username);
+    apr_cpystrn(username, user_name, sizeof username);
 
     /* Make user name all upper case */
     ap_str_toupper(username);
@@ -269,7 +269,7 @@ pid_t os_fork(const char *user)
 	break;
 
       case bs2_UFORK:
-	ap_cpystrn(username, user, sizeof username);
+	apr_cpystrn(username, user, sizeof username);
 
 	/* Make user name all upper case - for some versions of ufork() */
 	ap_str_toupper(username);
diff --git a/os/bs2000/ebcdic.c b/os/bs2000/ebcdic.c
index 82bb52a..70b6f15 100644
--- a/os/bs2000/ebcdic.c
+++ b/os/bs2000/ebcdic.c
@@ -67,7 +67,7 @@ Within the POSIX subsystem, the same character set was chosen as in
 "native BS2000", namely EBCDIC.
 
 EBCDIC Table. (Yes, in EBCDIC, the letters 'a'..'z' are not contiguous!)
-This ap_table_t is bijective, i.e. there are no ambigous or duplicate characters
+This apr_table_t is bijective, i.e. there are no ambigous or duplicate characters
 00    00 01 02 03 85 09 86 7f  87 8d 8e 0b 0c 0d 0e 0f  *................*
 10    10 11 12 13 8f 0a 08 97  18 19 9c 9d 1c 1d 1e 1f  *................*
 20    80 81 82 83 84 92 17 1b  88 89 8a 8b 8c 05 06 07  *................*
@@ -122,17 +122,17 @@ const unsigned char os_toascii_strictly[256] = {
        0x38, 0x39, 0xb3, 0x7b, 0xdc, 0x7d, 0xda, 0x7e  /*0123456789.{.}.~*/
 };
 
-/* This ap_table_t is (almost) identical to the previous one. The only difference
+/* This apr_table_t is (almost) identical to the previous one. The only difference
  * is the fact that it maps every EBCDIC *except 0x0A* to its ASCII
- * equivalent. The reason for this ap_table_t is simple: Throughout the
+ * equivalent. The reason for this apr_table_t is simple: Throughout the
  * server, protocol strings are used in the form
  *  "Content-Type: text/plain\015\012". Now all the characters in the string
  * are stored as EBCDIC, only the semantics of \012 is completely
- * different from LF (look it up in the ap_table_t above). \015 happens to be
+ * different from LF (look it up in the apr_table_t above). \015 happens to be
  * mapped to \015 anyway, so there's no special case for it.
  * 
  * In THIS table, EBCDIC-\012 is mapped to ASCII-\012.
- * This ap_table_t is therefore used wherever an EBCDIC to ASCII conversion is
+ * This apr_table_t is therefore used wherever an EBCDIC to ASCII conversion is
  * needed in the server.
  */
 /* ebcdic-to-ascii with \012 mapped to ASCII-\n */
diff --git a/os/bs2000/os.c b/os/bs2000/os.c
index 591d964..2ad3a49 100644
--- a/os/bs2000/os.c
+++ b/os/bs2000/os.c
@@ -89,7 +89,7 @@ int ap_checkconv(struct request_rec *r)
 		 strncasecmp(type, "message/", 8) == 0)) {
 	if (strncasecmp(type, ASCIITEXT_MAGIC_TYPE_PREFIX,
 			sizeof(ASCIITEXT_MAGIC_TYPE_PREFIX)-1) == 0)
-	    r->content_type = ap_pstrcat(r->pool, "text/",
+	    r->content_type = apr_pstrcat(r->pool, "text/",
 					 type+sizeof(ASCIITEXT_MAGIC_TYPE_PREFIX)-1,
 					 NULL);
         else
diff --git a/os/os2/os.h b/os/os2/os.h
index db354dc..e67f072 100644
--- a/os/os2/os.h
+++ b/os/os2/os.h
@@ -89,9 +89,9 @@ INLINE int ap_os_is_path_absolute(const char *file);
 extern int ap_os_is_path_absolute(const char *file);
 #endif
 
-char *ap_os_canonical_filename(ap_pool_t *p, const char *file);
-char *ap_os_case_canonical_filename(ap_pool_t *p, const char *szFile);
-char *ap_os_systemcase_filename(ap_pool_t *p, const char *szFile);
+char *ap_os_canonical_filename(apr_pool_t *p, const char *file);
+char *ap_os_case_canonical_filename(apr_pool_t *p, const char *szFile);
+char *ap_os_systemcase_filename(apr_pool_t *p, const char *szFile);
 /* FIXME: the following should be implemented on this platform */
 #define ap_os_is_filename_valid(f)         (1)
 
diff --git a/os/os2/util_os2.c b/os/os2/util_os2.c
index 1f813e7..3fbae4b 100644
--- a/os/os2/util_os2.c
+++ b/os/os2/util_os2.c
@@ -69,7 +69,7 @@
 #include <string.h>
 
 
-API_EXPORT(char *)ap_os_case_canonical_filename(ap_pool_t *pPool, const char *szFile)
+API_EXPORT(char *)ap_os_case_canonical_filename(apr_pool_t *pPool, const char *szFile)
 {
     char buf[HUGE_STRING_LEN];
     char buf2[HUGE_STRING_LEN];
@@ -88,9 +88,9 @@ API_EXPORT(char *)ap_os_case_canonical_filename(ap_pool_t *pPool, const char *sz
     if (rc) {
         if ( rc != ERROR_INVALID_NAME ) {
             ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, NULL, "OS/2 error %d for file %s", rc, szFile);
-            return ap_pstrdup(pPool, "");
+            return apr_pstrdup(pPool, "");
         } else {
-            return ap_pstrdup(pPool, szFile);
+            return apr_pstrdup(pPool, szFile);
         }
     }
 
@@ -99,7 +99,7 @@ API_EXPORT(char *)ap_os_case_canonical_filename(ap_pool_t *pPool, const char *sz
         if (*pos == '\\')
             *pos = '/';
     
-    return ap_pstrdup(pPool, buf2);
+    return apr_pstrdup(pPool, buf2);
 }
 
 
@@ -119,7 +119,7 @@ static void fix_component(char *path, char *lastcomp)
 
 
 
-char *ap_os_systemcase_canonical_filename(ap_pool_t *pPool, const char *szFile)
+char *ap_os_systemcase_canonical_filename(apr_pool_t *pPool, const char *szFile)
 {
     char *szCanonicalFile = ap_os_case_canonical_filename(pPool, szFile);
     int startslash = 2, slashnum=0;
@@ -149,7 +149,7 @@ char *ap_os_systemcase_canonical_filename(ap_pool_t *pPool, const char *szFile)
 
 
 
-char *ap_os_canonical_filename(ap_pool_t *pPool, const char *szFile)
+char *ap_os_canonical_filename(apr_pool_t *pPool, const char *szFile)
 {
     char *szCanonicalFile = ap_os_systemcase_canonical_filename(pPool, szFile);
     strlwr(szCanonicalFile);
diff --git a/os/tpf/ebcdic.c b/os/tpf/ebcdic.c
index 0fad41e..c266f64 100644
--- a/os/tpf/ebcdic.c
+++ b/os/tpf/ebcdic.c
@@ -67,7 +67,7 @@ the BS2000 (apache/src/os/bs2000/ebcdic.c).
 
 /*
 Bijective EBCDIC (character set IBM-1047) to US-ASCII table:
-This ap_table_t is bijective - there are no ambigous or duplicate characters.
+This apr_table_t is bijective - there are no ambigous or duplicate characters.
 */
 const unsigned char os_toascii_strictly[256] = {
     0x00, 0x01, 0x02, 0x03, 0x85, 0x09, 0x86, 0x7f, /* 00-0f:           */
@@ -106,7 +106,7 @@ const unsigned char os_toascii_strictly[256] = {
 
 /*
 Server EBCDIC (character set IBM-1047) to US-ASCII table:
-This ap_table_t is a copy of the os_toascii_strictly bijective ap_table_t above.
+This apr_table_t is a copy of the os_toascii_strictly bijective apr_table_t above.
 The only change is that hex 0a (\012 octal) is mapped to hex 0a
 (ASCII's line feed) instead of hex 8e.  This is done because throughout
 Apache, protocol string definitions hardcode the linefeed as \012 (octal):
@@ -150,7 +150,7 @@ const unsigned char os_toascii[256] = {
 
 /*
 The US-ASCII to EBCDIC (character set IBM-1047) table:
-This ap_table_t is bijective (no ambiguous or duplicate characters)
+This apr_table_t is bijective (no ambiguous or duplicate characters)
 */
 const unsigned char os_toebcdic[256] = {
     0x00, 0x01, 0x02, 0x03, 0x37, 0x2d, 0x2e, 0x2f, /* 00-0f:           */
diff --git a/os/tpf/os.c b/os/tpf/os.c
index 246b0a4..d48d243 100644
--- a/os/tpf/os.c
+++ b/os/tpf/os.c
@@ -94,7 +94,7 @@ int ap_checkconv(struct request_rec *r)
 		 strncasecmp(type, "message/", 8) == 0)) {
 	if (strncasecmp(type, ASCIITEXT_MAGIC_TYPE_PREFIX,
                         sizeof(ASCIITEXT_MAGIC_TYPE_PREFIX)-1) == 0){
-	    r->content_type = ap_pstrcat(r->pool, "text/",
+	    r->content_type = apr_pstrcat(r->pool, "text/",
                    type+sizeof(ASCIITEXT_MAGIC_TYPE_PREFIX)-1, NULL);
             if (r->method_number == M_PUT)
                    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, 0);
@@ -212,7 +212,7 @@ int execvp(const char *file, char *const argv[])
 
 
 
-int ap_tpf_spawn_child(ap_pool_t *p, int (*func) (void *, child_info *),
+int ap_tpf_spawn_child(apr_pool_t *p, int (*func) (void *, child_info *),
                        void *data, enum kill_conditions kill_how,
                        int *pipe_in, int *pipe_out, int *pipe_err,
                        int out_fds[], int in_fds[], int err_fds[])
@@ -223,7 +223,7 @@ int ap_tpf_spawn_child(ap_pool_t *p, int (*func) (void *, child_info *),
    int                      fd_flags_out, fd_flags_in, fd_flags_err;
    struct tpf_fork_input    fork_input;
    TPF_FORK_CHILD           *cld = (TPF_FORK_CHILD *) data;
-   ap_array_header_t             *env_arr = ap_table_elts ((array_header *) cld->subprocess_env);
+   apr_array_header_t             *env_arr = ap_table_elts ((array_header *) cld->subprocess_env);
    table_entry              *elts = (table_entry *) env_arr->elts;
 
 
@@ -323,7 +323,7 @@ int ap_tpf_spawn_child(ap_pool_t *p, int (*func) (void *, child_info *),
 
    if (pid) {
 
-       ap_note_subprocess(p, pid, kill_how);
+       apr_note_subprocess(p, pid, kill_how);
 
        if (pipe_out) {
           *pipe_out = out_fds[0];
@@ -396,7 +396,7 @@ int os_check_server(char *server) {
     return 0;
 }
 
-void os_note_additional_cleanups(ap_pool_t *p, int sd) {
+void os_note_additional_cleanups(apr_pool_t *p, int sd) {
     char sockfilename[50];
     /* write the socket to file so that TPF socket device driver will close socket in case
        we happen to abend. */
diff --git a/os/unix/unixd.c b/os/unix/unixd.c
index 0253fda..15081f0 100644
--- a/os/unix/unixd.c
+++ b/os/unix/unixd.c
@@ -349,7 +349,7 @@ API_EXPORT(void) unixd_set_rlimit(cmd_parms *cmd, struct rlimit **plimit,
     rlim_t cur = 0;
     rlim_t max = 0;
 
-    *plimit = (struct rlimit *)ap_pcalloc(cmd->pool, sizeof(**plimit));
+    *plimit = (struct rlimit *)apr_pcalloc(cmd->pool, sizeof(**plimit));
     limit = *plimit;
     if ((getrlimit(type, limit)) != 0)  {
         *plimit = NULL;
diff --git a/os/win32/mod_isapi.c b/os/win32/mod_isapi.c
index 592643c..e61cb47 100644
--- a/os/win32/mod_isapi.c
+++ b/os/win32/mod_isapi.c
@@ -144,12 +144,12 @@ typedef struct {
     PFN_HSE_IO_COMPLETION completion;
     PVOID  completion_arg;
     HANDLE complete;
-    ap_status_t retval;
+    apr_status_t retval;
 } isapi_cid;
 
-ap_status_t isapi_handler (request_rec *r)
+apr_status_t isapi_handler (request_rec *r)
 {
-    ap_table_t *e = r->subprocess_env;
+    apr_table_t *e = r->subprocess_env;
     isapi_loaded *isa;
     isapi_cid *cid;
 
@@ -177,8 +177,8 @@ ap_status_t isapi_handler (request_rec *r)
      * should only be performed on the first isapi dll invocation, 
      * not with every HttpExtensionProc()
      */
-    isa = ap_pcalloc(r->pool, sizeof(isapi_module));
-    isa->pVer = ap_pcalloc(r->pool, sizeof(HSE_VERSION_INFO));
+    isa = apr_pcalloc(r->pool, sizeof(isapi_module));
+    isa->pVer = apr_pcalloc(r->pool, sizeof(HSE_VERSION_INFO));
     isa->refcount = 0;
 
     /* TODO: These may need to become overrideable, so that we
@@ -239,8 +239,8 @@ ap_status_t isapi_handler (request_rec *r)
     ap_add_cgi_vars(r);
 
     /* Set up connection structure and ecb */
-    cid = ap_pcalloc(r->pool, sizeof(isapi_cid));
-    cid->ecb = ap_pcalloc(r->pool, sizeof(struct _EXTENSION_CONTROL_BLOCK));
+    cid = apr_pcalloc(r->pool, sizeof(isapi_cid));
+    cid->ecb = apr_pcalloc(r->pool, sizeof(struct _EXTENSION_CONTROL_BLOCK));
     cid->ecb->ConnID = (HCONN)cid;
     /* TODO: Critical section */
     ++isa->refcount;
@@ -256,15 +256,15 @@ ap_status_t isapi_handler (request_rec *r)
     cid->ecb->dwHttpStatusCode = 0;
     strcpy(cid->ecb->lpszLogData, "");
     // TODO: are copies really needed here?
-    cid->ecb->lpszMethod = ap_pstrdup(r->pool, (char*) r->method);
-    cid->ecb->lpszQueryString = ap_pstrdup(r->pool, 
-                                (char*) ap_table_get(e, "QUERY_STRING"));
-    cid->ecb->lpszPathInfo = ap_pstrdup(r->pool, 
-                             (char*) ap_table_get(e, "PATH_INFO"));
-    cid->ecb->lpszPathTranslated = ap_pstrdup(r->pool, 
-                                   (char*) ap_table_get(e, "PATH_TRANSLATED"));
-    cid->ecb->lpszContentType = ap_pstrdup(r->pool, 
-                                (char*) ap_table_get(e, "CONTENT_TYPE"));
+    cid->ecb->lpszMethod = apr_pstrdup(r->pool, (char*) r->method);
+    cid->ecb->lpszQueryString = apr_pstrdup(r->pool, 
+                                (char*) apr_table_get(e, "QUERY_STRING"));
+    cid->ecb->lpszPathInfo = apr_pstrdup(r->pool, 
+                             (char*) apr_table_get(e, "PATH_INFO"));
+    cid->ecb->lpszPathTranslated = apr_pstrdup(r->pool, 
+                                   (char*) apr_table_get(e, "PATH_TRANSLATED"));
+    cid->ecb->lpszContentType = apr_pstrdup(r->pool, 
+                                (char*) apr_table_get(e, "CONTENT_TYPE"));
     /* Set up the callbacks */
     cid->ecb->GetServerVariable = &GetServerVariable;
     cid->ecb->WriteClient = &WriteClient;
@@ -291,7 +291,7 @@ ap_status_t isapi_handler (request_rec *r)
          * But we can be smarter and read up to our 48k and then allow
          * the ISAPI app to read further blocks as desired.
          */
-        long to_read = atol(ap_table_get(e, "CONTENT_LENGTH"));
+        long to_read = atol(apr_table_get(e, "CONTENT_LENGTH"));
         long read;
 
         /* Actually, let's cap it at 48k, until we figure out what
@@ -306,7 +306,7 @@ ap_status_t isapi_handler (request_rec *r)
             return HTTP_REQUEST_ENTITY_TOO_LARGE;
         }
 
-        cid->ecb->lpbData = ap_pcalloc(r->pool, 1 + to_read);
+        cid->ecb->lpbData = apr_pcalloc(r->pool, 1 + to_read);
 
         if ((read = ap_get_client_block(r, cid->ecb->lpbData, to_read)) < 0) {
             if (isa->TerminateExtension) 
@@ -417,7 +417,7 @@ BOOL WINAPI GetServerVariable (HCONN hConn, LPSTR lpszVariableName,
                                LPVOID lpvBuffer, LPDWORD lpdwSizeofBuffer)
 {
     request_rec *r = ((isapi_cid *)hConn)->r;
-    ap_table_t *e = r->subprocess_env;
+    apr_table_t *e = r->subprocess_env;
     const char *result;
 
     /* Mostly, we just grab it from the environment, but there are
@@ -428,7 +428,7 @@ BOOL WINAPI GetServerVariable (HCONN hConn, LPSTR lpszVariableName,
         /* We don't support NT users, so this is always the same as
          * REMOTE_USER
          */
-        result = ap_table_get(e, "REMOTE_USER");
+        result = apr_table_get(e, "REMOTE_USER");
     }
     else if (!strcasecmp(lpszVariableName, "SERVER_PORT_SECURE")) {
         /* Apache doesn't support secure requests inherently, so
@@ -441,7 +441,7 @@ BOOL WINAPI GetServerVariable (HCONN hConn, LPSTR lpszVariableName,
         result = r->uri;
     }
     else {
-        result = ap_table_get(e, lpszVariableName);
+        result = apr_table_get(e, lpszVariableName);
     }
 
     if (result) {
@@ -549,21 +549,21 @@ static char* ComposeHeaders(request_rec *r, char* data)
             while (endp > value && ap_isspace(*endp)) 
                 *endp-- = '\0';
 
-            tmp = ap_pstrdup (r->pool, value);
+            tmp = apr_pstrdup (r->pool, value);
             ap_str_tolower(tmp);
             r->content_type = tmp;
         }
         else if (!strcasecmp(data, "Content-Length")) {
-            ap_table_set(r->headers_out, data, value);
+            apr_table_set(r->headers_out, data, value);
         }
         else if (!strcasecmp(data, "Transfer-Encoding")) {
-            ap_table_set(r->headers_out, data, value);
+            apr_table_set(r->headers_out, data, value);
         }
         else if (!strcasecmp(data, "Set-Cookie")) {
-            ap_table_add(r->err_headers_out, data, value);
+            apr_table_add(r->err_headers_out, data, value);
         }
         else {
-            ap_table_merge(r->err_headers_out, data, value);
+            apr_table_merge(r->err_headers_out, data, value);
         }
 
         /* Reset data */
@@ -594,7 +594,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
             /* Set the status to be returned when the HttpExtensionProc()
              * is done.
              */
-            ap_table_set (r->headers_out, "Location", lpvBuffer);
+            apr_table_set (r->headers_out, "Location", lpvBuffer);
             cid->r->status = cid->ecb->dwHttpStatusCode 
                                                    = HTTP_MOVED_TEMPORARILY;
             return TRUE;
@@ -609,17 +609,17 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
             }
 
             /* Reset the method to GET */
-            r->method = ap_pstrdup(r->pool, "GET");
+            r->method = apr_pstrdup(r->pool, "GET");
             r->method_number = M_GET;
 
             /* Don't let anyone think there's still data */
-            ap_table_unset(r->headers_in, "Content-Length");
+            apr_table_unset(r->headers_in, "Content-Length");
 
             ap_internal_redirect((char *)lpvBuffer, r);
             return TRUE;
 
         case HSE_REQ_SEND_RESPONSE_HEADER:
-            r->status_line = lpvBuffer ? lpvBuffer : ap_pstrdup(r->pool, "200 OK");
+            r->status_line = lpvBuffer ? lpvBuffer : apr_pstrdup(r->pool, "200 OK");
             sscanf(r->status_line, "%d", &r->status);
             cid->ecb->dwHttpStatusCode = r->status;
 
@@ -636,7 +636,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
             }
                         
             /* Make a copy - don't disturb the original */
-            data = ap_pstrdup(r->pool, (char *)lpdwDataType);
+            data = apr_pstrdup(r->pool, (char *)lpdwDataType);
             
             /* Parse them out, or die trying */
             data = ComposeHeaders(r, data);
@@ -661,7 +661,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
 
         case HSE_REQ_MAP_URL_TO_PATH:
             /* Map a URL to a filename */
-            subreq = ap_sub_req_lookup_uri(ap_pstrndup(r->pool, (char *)lpvBuffer,
+            subreq = ap_sub_req_lookup_uri(apr_pstrndup(r->pool, (char *)lpvBuffer,
                                            *lpdwSize), r);
 
             GetFullPathName(subreq->filename, *lpdwSize - 1, (char *)lpvBuffer, NULL);
@@ -738,7 +738,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
             /* TODO: Not quite ready for prime time yet */
 
             /* Map a URL to a filename */
-            subreq = ap_sub_req_lookup_uri(ap_pstrndup(r->pool, (char *)lpvBuffer,
+            subreq = ap_sub_req_lookup_uri(apr_pstrndup(r->pool, (char *)lpvBuffer,
                                            *lpdwSize), r);
 
             GetFullPathName(subreq->filename, *lpdwSize - 1, (char *)lpvBuffer, NULL);
@@ -752,7 +752,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
                 ((char *)lpvBuffer)[l + 1] = '\0';
             }
 
-            lpdwDataType = (LPDWORD) ap_palloc(r->pool, sizeof(HSE_URL_MAPEX_INFO));
+            lpdwDataType = (LPDWORD) apr_palloc(r->pool, sizeof(HSE_URL_MAPEX_INFO));
             strncpy(((LPHSE_URL_MAPEX_INFO)lpdwDataType)->lpszPath,
                     (char *) lpvBuffer, MAX_PATH);
             ((LPHSE_URL_MAPEX_INFO)lpdwDataType)->dwFlags = 0;
@@ -790,12 +790,12 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
 
             if (((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->pszStatus
                 && ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->cchStatus) {
-                r->status_line = ap_pstrndup(r->pool, 
+                r->status_line = apr_pstrndup(r->pool, 
                            ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->pszStatus,
                            ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->cchStatus);
             }
             else {
-                r->status_line = ap_pstrdup(r->pool, "200 OK");
+                r->status_line = apr_pstrdup(r->pool, "200 OK");
             }
             sscanf(r->status_line, "%d", &r->status);
             cid->ecb->dwHttpStatusCode = r->status;
@@ -804,7 +804,7 @@ BOOL WINAPI ServerSupportFunction (HCONN hConn, DWORD dwHSERequest,
                 && ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->cchHeader)
             {
                 /* Make a copy - don't disturb the original */
-                data = ap_pstrndup(r->pool, 
+                data = apr_pstrndup(r->pool, 
                            ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->pszHeader,
                            ((LPHSE_SEND_HEADER_EX_INFO)lpvBuffer)->cchHeader);
                 
@@ -864,7 +864,7 @@ module isapi_module = {
    NULL,                        /* merge per-dir config */
    NULL,                        /* server config */
    NULL,                        /* merge server config */
-   NULL,                        /* command ap_table_t */
+   NULL,                        /* command apr_table_t */
    isapi_handlers,              /* handlers */
    NULL                         /* register hooks */
 };
diff --git a/os/win32/os.h b/os/win32/os.h
index cb82e7a..2248886 100644
--- a/os/win32/os.h
+++ b/os/win32/os.h
@@ -143,9 +143,9 @@ __inline int ap_os_is_path_absolute(const char *file)
 }
 
 /* OS-dependent filename routines in util_win32.c */
-API_EXPORT(char *) ap_os_canonical_filename(ap_pool_t *p, const char *file);
-API_EXPORT(char *) ap_os_case_canonical_filename(ap_pool_t *pPool, const char *szFile);
-API_EXPORT(char *) ap_os_systemcase_filename(ap_pool_t *pPool, const char *szFile);
+API_EXPORT(char *) ap_os_canonical_filename(apr_pool_t *p, const char *file);
+API_EXPORT(char *) ap_os_case_canonical_filename(apr_pool_t *pPool, const char *szFile);
+API_EXPORT(char *) ap_os_systemcase_filename(apr_pool_t *pPool, const char *szFile);
 API_EXPORT(int) ap_os_is_filename_valid(const char *file);
 
 #define ap_os_dso_error()   ""	/* for now */
diff --git a/os/win32/util_win32.c b/os/win32/util_win32.c
index 8dd410b..66d1263 100644
--- a/os/win32/util_win32.c
+++ b/os/win32/util_win32.c
@@ -86,7 +86,7 @@ static BOOL OnlyDots(char *pString)
  * is present on the existing path.  This routine also
  * converts alias names to long names.
  */
-API_EXPORT(char *) ap_os_systemcase_filename(ap_pool_t *pPool, 
+API_EXPORT(char *) ap_os_systemcase_filename(apr_pool_t *pPool, 
                                              const char *szFile)
 {
     char buf[HUGE_STRING_LEN];
@@ -98,10 +98,10 @@ API_EXPORT(char *) ap_os_systemcase_filename(ap_pool_t *pPool,
     WIN32_FIND_DATA wfd;
 
     if (!szFile || strlen(szFile) == 0 || strlen(szFile) >= sizeof(buf))
-        return ap_pstrdup(pPool, "");
+        return apr_pstrdup(pPool, "");
 
     buf[0] = '\0';
-    pInputName = ap_pstrdup(pPool, szFile);
+    pInputName = apr_pstrdup(pPool, szFile);
 
     /* First convert all slashes to \ so Win32 calls work OK */
     for (p = pInputName; *p; p++) {
@@ -199,14 +199,14 @@ API_EXPORT(char *) ap_os_systemcase_filename(ap_pool_t *pPool,
             *p = '/';
     }
 
-    return ap_pstrdup(pPool, buf);
+    return apr_pstrdup(pPool, buf);
 }
 
 
 /*  Perform canonicalization with the exception that the
  *  input case is preserved.
  */
-API_EXPORT(char *) ap_os_case_canonical_filename(ap_pool_t *pPool, 
+API_EXPORT(char *) ap_os_case_canonical_filename(apr_pool_t *pPool, 
                                                  const char *szFile)
 {
     char *pNewStr;
@@ -215,9 +215,9 @@ API_EXPORT(char *) ap_os_case_canonical_filename(ap_pool_t *pPool,
     char *q;
 
     if (szFile == NULL || strlen(szFile) == 0)
-        return ap_pstrdup(pPool, "");
+        return apr_pstrdup(pPool, "");
 
-    pNewStr = ap_pstrdup(pPool, szFile);
+    pNewStr = apr_pstrdup(pPool, szFile);
 
     /*  Change all '\' characters to '/' characters.
      *  While doing this, remove any trailing '.'.
@@ -315,7 +315,7 @@ API_EXPORT(char *) ap_os_case_canonical_filename(ap_pool_t *pPool,
 
             } while (p != NULL); 
 
-            pNewStr = ap_pstrdup(pPool, buf);
+            pNewStr = apr_pstrdup(pPool, buf);
         }
     }
 
@@ -325,7 +325,7 @@ API_EXPORT(char *) ap_os_case_canonical_filename(ap_pool_t *pPool,
 
 /*  Perform complete canonicalization.
  */
-API_EXPORT(char *) ap_os_canonical_filename(ap_pool_t *pPool, const char *szFile)
+API_EXPORT(char *) ap_os_canonical_filename(apr_pool_t *pPool, const char *szFile)
 {
     char *pNewName;
     pNewName = ap_os_case_canonical_filename(pPool, szFile);
diff --git a/server/config.c b/server/config.c
index cc64d99..ddeb13c 100644
--- a/server/config.c
+++ b/server/config.c
@@ -96,9 +96,9 @@ API_VAR_EXPORT const char *ap_server_argv0;
 
 API_VAR_EXPORT const char *ap_server_root;
 
-API_VAR_EXPORT ap_array_header_t *ap_server_pre_read_config;
-API_VAR_EXPORT ap_array_header_t *ap_server_post_read_config;
-API_VAR_EXPORT ap_array_header_t *ap_server_config_defines;
+API_VAR_EXPORT apr_array_header_t *ap_server_pre_read_config;
+API_VAR_EXPORT apr_array_header_t *ap_server_post_read_config;
+API_VAR_EXPORT apr_array_header_t *ap_server_config_defines;
 
 AP_HOOK_STRUCT(
 	    AP_HOOK_LINK(header_parser)
@@ -111,16 +111,16 @@ AP_HOOK_STRUCT(
 AP_IMPLEMENT_HOOK_RUN_ALL(int,header_parser,
                           (request_rec *r),(r),OK,DECLINED)
 AP_IMPLEMENT_HOOK_VOID(pre_config,
-		       (ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp),
+		       (apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp),
                        (pconf,plog,ptemp))
 AP_IMPLEMENT_HOOK_VOID(post_config,
-		       (ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp,
+		       (apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp,
                         server_rec *s),(pconf,plog,ptemp,s))
 AP_IMPLEMENT_HOOK_VOID(open_logs,
-		       (ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp, 
+		       (apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, 
                         server_rec *s),(pconf,plog,ptemp,s))
 AP_IMPLEMENT_HOOK_VOID(child_init,
-                       (ap_pool_t *pchild, server_rec *s),(pchild,s))
+                       (apr_pool_t *pchild, server_rec *s),(pchild,s))
 
 /****************************************************************
  *
@@ -141,8 +141,8 @@ API_VAR_EXPORT module *top_module = NULL;
 API_VAR_EXPORT module **ap_loaded_modules=NULL;
 
 typedef int (*handler_func) (request_rec *);
-typedef void *(*dir_maker_func) (ap_pool_t *, char *);
-typedef void *(*merger_func) (ap_pool_t *, void *, void *);
+typedef void *(*dir_maker_func) (apr_pool_t *, char *);
+typedef void *(*merger_func) (apr_pool_t *, void *, void *);
 
 /* Dealing with config vectors.  These are associated with per-directory,
  * per-server, and per-request configuration, and have a void* pointer for
@@ -171,16 +171,16 @@ API_EXPORT(void) ap_set_module_config(void *conf_vector, module *m, void *val)
 }
 #endif
 
-static void *create_empty_config(ap_pool_t *p)
+static void *create_empty_config(apr_pool_t *p)
 {
-    void **conf_vector = (void **) ap_pcalloc(p, sizeof(void *) *
+    void **conf_vector = (void **) apr_pcalloc(p, sizeof(void *) *
 				    (total_modules + DYNAMIC_MODULE_LIMIT));
     return (void *) conf_vector;
 }
 
-static void *create_default_per_dir_config(ap_pool_t *p)
+static void *create_default_per_dir_config(apr_pool_t *p)
 {
-    void **conf_vector = (void **) ap_pcalloc(p, sizeof(void *) * (total_modules + DYNAMIC_MODULE_LIMIT));
+    void **conf_vector = (void **) apr_pcalloc(p, sizeof(void *) * (total_modules + DYNAMIC_MODULE_LIMIT));
     module *modp;
 
     for (modp = top_module; modp; modp = modp->next) {
@@ -194,9 +194,9 @@ static void *create_default_per_dir_config(ap_pool_t *p)
 }
 
 void *
-     ap_merge_per_dir_configs(ap_pool_t *p, void *base, void *new)
+     ap_merge_per_dir_configs(apr_pool_t *p, void *base, void *new)
 {
-    void **conf_vector = (void **) ap_palloc(p, sizeof(void *) * total_modules);
+    void **conf_vector = (void **) apr_palloc(p, sizeof(void *) * total_modules);
     void **base_vector = (void **) base;
     void **new_vector = (void **) new;
     module *modp;
@@ -214,9 +214,9 @@ void *
     return (void *) conf_vector;
 }
 
-static void *create_server_config(ap_pool_t *p, server_rec *s)
+static void *create_server_config(apr_pool_t *p, server_rec *s)
 {
-    void **conf_vector = (void **) ap_pcalloc(p, sizeof(void *) * (total_modules + DYNAMIC_MODULE_LIMIT));
+    void **conf_vector = (void **) apr_pcalloc(p, sizeof(void *) * (total_modules + DYNAMIC_MODULE_LIMIT));
     module *modp;
 
     for (modp = top_module; modp; modp = modp->next) {
@@ -227,7 +227,7 @@ static void *create_server_config(ap_pool_t *p, server_rec *s)
     return (void *) conf_vector;
 }
 
-static void merge_server_configs(ap_pool_t *p, void *base, void *virt)
+static void merge_server_configs(apr_pool_t *p, void *base, void *virt)
 {
     /* Can reuse the 'virt' vector for the spine of it, since we don't
      * have to deal with the moral equivalent of .htaccess files here...
@@ -248,17 +248,17 @@ static void merge_server_configs(ap_pool_t *p, void *base, void *virt)
     }
 }
 
-void *ap_create_request_config(ap_pool_t *p)
+void *ap_create_request_config(apr_pool_t *p)
 {
     return create_empty_config(p);
 }
 
-void *ap_create_conn_config(ap_pool_t *p)
+void *ap_create_conn_config(apr_pool_t *p)
 {
     return create_empty_config(p);
 }
 
-CORE_EXPORT(void *) ap_create_per_dir_config(ap_pool_t *p)
+CORE_EXPORT(void *) ap_create_per_dir_config(apr_pool_t *p)
 {
     return create_empty_config(p);
 }
@@ -277,7 +277,7 @@ typedef struct {
 static fast_handler_rec *handlers;
 static fast_handler_rec *wildhandlers;
 
-static void init_handlers(ap_pool_t *p)
+static void init_handlers(apr_pool_t *p)
 {
     module *modp;
     int nhandlers = 0;
@@ -297,8 +297,8 @@ static void init_handlers(ap_pool_t *p)
             }
         }
     }
-    ph = handlers = ap_palloc(p, sizeof(*ph)*(nhandlers + 1));
-    pw = wildhandlers = ap_palloc(p, sizeof(*pw)*(nwildhandlers + 1));
+    ph = handlers = apr_palloc(p, sizeof(*ph)*(nhandlers + 1));
+    pw = wildhandlers = apr_palloc(p, sizeof(*pw)*(nwildhandlers + 1));
     for (modp = top_module; modp; modp = modp->next) {
 	if (!modp->handlers)
 	    continue;
@@ -563,7 +563,7 @@ API_EXPORT(void) ap_setup_prelinked_modules(process_rec *process)
     /* 
      *  Initialise list of loaded modules
      */
-    ap_loaded_modules = (module **)ap_palloc(process->pool,
+    ap_loaded_modules = (module **)apr_palloc(process->pool,
         sizeof(module *)*(total_modules+DYNAMIC_MODULE_LIMIT+1));
     if (ap_loaded_modules == NULL) {
 	ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL,
@@ -649,7 +649,7 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
     const char *errmsg;
 
     if ((parms->override & cmd->req_override) == 0)
-	return ap_pstrcat(parms->pool, cmd->name, " not allowed here", NULL);
+	return apr_pstrcat(parms->pool, cmd->name, " not allowed here", NULL);
 
     parms->info = cmd->cmd_data;
     parms->cmd = cmd;
@@ -663,7 +663,7 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
 
     case NO_ARGS:
 	if (*args != 0)
-	    return ap_pstrcat(parms->pool, cmd->name, " takes no arguments",
+	    return apr_pstrcat(parms->pool, cmd->name, " takes no arguments",
 			   NULL);
 
 	return cmd->AP_NO_ARGS(parms, mconfig);
@@ -672,7 +672,7 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
 	w = ap_getword_conf(parms->pool, &args);
 
 	if (*w == '\0' || *args != 0)
-	    return ap_pstrcat(parms->pool, cmd->name, " takes one argument",
+	    return apr_pstrcat(parms->pool, cmd->name, " takes one argument",
 			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
 
 	return cmd->AP_TAKE1(parms, mconfig, w);
@@ -682,7 +682,7 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
 	w2 = ap_getword_conf(parms->pool, &args);
 
 	if (*w == '\0' || *w2 == '\0' || *args != 0)
-	    return ap_pstrcat(parms->pool, cmd->name, " takes two arguments",
+	    return apr_pstrcat(parms->pool, cmd->name, " takes two arguments",
 			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
 
 	return cmd->AP_TAKE2(parms, mconfig, w, w2);
@@ -693,7 +693,7 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
 	w2 = ap_getword_conf(parms->pool, &args);
 
 	if (*w == '\0' || *args != 0)
-	    return ap_pstrcat(parms->pool, cmd->name, " takes 1-2 arguments",
+	    return apr_pstrcat(parms->pool, cmd->name, " takes 1-2 arguments",
 			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
 
 	return cmd->AP_TAKE2(parms, mconfig, w, *w2 ? w2 : NULL);
@@ -705,7 +705,7 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
 	w3 = ap_getword_conf(parms->pool, &args);
 
 	if (*w == '\0' || *w2 == '\0' || *w3 == '\0' || *args != 0)
-	    return ap_pstrcat(parms->pool, cmd->name, " takes three arguments",
+	    return apr_pstrcat(parms->pool, cmd->name, " takes three arguments",
 			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
 
 	return cmd->AP_TAKE3(parms, mconfig, w, w2, w3);
@@ -717,7 +717,7 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
 	w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
 
 	if (*w == '\0' || *w2 == '\0' || *args != 0)
-	    return ap_pstrcat(parms->pool, cmd->name,
+	    return apr_pstrcat(parms->pool, cmd->name,
 			    " takes two or three arguments",
 			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
 
@@ -730,7 +730,7 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
 	w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
 
 	if (*w == '\0' || *args != 0)
-	    return ap_pstrcat(parms->pool, cmd->name,
+	    return apr_pstrcat(parms->pool, cmd->name,
 			    " takes one, two or three arguments",
 			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
 
@@ -743,7 +743,7 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
 	w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
 
 	if (*w == '\0' || (w2 && *w2 && !w3) || *args != 0)
-	    return ap_pstrcat(parms->pool, cmd->name,
+	    return apr_pstrcat(parms->pool, cmd->name,
 			    " takes one or three arguments",
 			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
 
@@ -764,7 +764,7 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
 	w = ap_getword_conf(parms->pool, &args);
 
 	if (*w == '\0' || *args == 0)
-	    return ap_pstrcat(parms->pool, cmd->name,
+	    return apr_pstrcat(parms->pool, cmd->name,
 			    " requires at least two arguments",
 			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
 
@@ -781,14 +781,14 @@ static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
 	w = ap_getword_conf(parms->pool, &args);
 
 	if (*w == '\0' || (strcasecmp(w, "on") && strcasecmp(w, "off")))
-	    return ap_pstrcat(parms->pool, cmd->name, " must be On or Off",
+	    return apr_pstrcat(parms->pool, cmd->name, " must be On or Off",
 			    NULL);
 
 	return cmd->AP_FLAG(parms, mconfig, strcasecmp(w, "off") != 0);
 
     default:
 
-	return ap_pstrcat(parms->pool, cmd->name,
+	return apr_pstrcat(parms->pool, cmd->name,
 		    " is improperly configured internally (server bug)",
 			NULL);
     }
@@ -837,10 +837,10 @@ CORE_EXPORT(void *) ap_set_config_vectors(cmd_parms *parms, void *config, module
 }
 
 static const char *execute_now(char *cmd_line, const char *args, cmd_parms *parms, 
-                         ap_pool_t *p, ap_pool_t *ptemp,
+                         apr_pool_t *p, apr_pool_t *ptemp,
                          ap_directive_t **sub_tree, ap_directive_t *parent);
 
-static const char * ap_build_config_sub(ap_pool_t *p, ap_pool_t *temp_pool,
+static const char * ap_build_config_sub(apr_pool_t *p, apr_pool_t *temp_pool,
 					const char *l, cmd_parms *parms,
 					ap_directive_t **current,
 					ap_directive_t **curr_parent)
@@ -867,11 +867,11 @@ static const char * ap_build_config_sub(ap_pool_t *p, ap_pool_t *temp_pool,
 	return NULL;
     }
 
-    newdir = ap_pcalloc(p, sizeof(ap_directive_t));
+    newdir = apr_pcalloc(p, sizeof(ap_directive_t));
     newdir->filename = parms->config_file->name;
     newdir->line_num = parms->config_file->line_number;
     newdir->directive = cmd_name;
-    newdir->args = ap_pstrdup(p, args);
+    newdir->args = apr_pstrdup(p, args);
 
     if ((cmd = ap_find_command_in_modules(cmd_name, &mod)) != NULL) {
         if (cmd->req_override & EXEC_ON_READ) {
@@ -909,7 +909,7 @@ static const char * ap_build_config_sub(ap_pool_t *p, ap_pool_t *temp_pool,
         }
 	else if (*curr_parent == NULL) {
             parms->err_directive = newdir;
-	    return ap_pstrcat(p, cmd_name,
+	    return apr_pstrcat(p, cmd_name,
 			      " without matching <", cmd_name + 2,
 			      " section", NULL);
 	}
@@ -917,13 +917,13 @@ static const char * ap_build_config_sub(ap_pool_t *p, ap_pool_t *temp_pool,
 	    char *bracket = cmd_name + strlen(cmd_name) - 1;
 
 	    if (*bracket != '>') {
-		return ap_pstrcat(p, cmd_name,
+		return apr_pstrcat(p, cmd_name,
 				  "> directive missing closing '>'", NULL);
 	    }
 	    *bracket = '\0';
 	    if (strcasecmp(cmd_name + 2,
 			    (*curr_parent)->directive + 1) != 0) {
-		return ap_pstrcat(p, "Expected </",
+		return apr_pstrcat(p, "Expected </",
 				  (*curr_parent)->directive + 1, "> but saw ",
 				  cmd_name, ">", NULL);
 	    }
@@ -941,7 +941,7 @@ static const char * ap_build_config_sub(ap_pool_t *p, ap_pool_t *temp_pool,
     return NULL;
 }
 
-const char * ap_build_cont_config(ap_pool_t *p, ap_pool_t *temp_pool,
+const char * ap_build_cont_config(apr_pool_t *p, apr_pool_t *temp_pool,
 					cmd_parms *parms,
 					ap_directive_t **current,
 					ap_directive_t **curr_parent,
@@ -952,7 +952,7 @@ const char * ap_build_cont_config(ap_pool_t *p, ap_pool_t *temp_pool,
     const char *retval;
     ap_directive_t *conftree = NULL;
 
-    bracket = ap_pstrcat(p, orig_directive + 1, ">", NULL);
+    bracket = apr_pstrcat(p, orig_directive + 1, ">", NULL);
     while(!(ap_cfg_getline(l, MAX_STRING_LEN, parms->config_file))) {
         if ((strcasecmp(l + 2, bracket) == 0) &&
             (*curr_parent == NULL)) {
@@ -983,7 +983,7 @@ static const char *ap_walk_config_sub(const ap_directive_t *current,
 
 	if (!(cmd = ap_find_command_in_modules(current->directive, &mod))) {
             parms->err_directive = current;
-            return ap_pstrcat(parms->pool, "Invalid command '", 
+            return apr_pstrcat(parms->pool, "Invalid command '", 
 			      current->directive,
 			      "', perhaps mis-spelled or defined by a module "
 			      "not included in the server configuration",
@@ -1043,7 +1043,7 @@ API_EXPORT(const char *) ap_walk_config(ap_directive_t *current,
 
 
 API_EXPORT(const char *) ap_build_config(cmd_parms *parms,
-					 ap_pool_t *p, ap_pool_t *temp_pool,
+					 apr_pool_t *p, apr_pool_t *temp_pool,
 					 ap_directive_t **conftree)
 {
     ap_directive_t *current = *conftree;
@@ -1075,7 +1075,7 @@ API_EXPORT(const char *) ap_build_config(cmd_parms *parms,
     if (curr_parent != NULL) {
 	errmsg = "";
 	while (curr_parent != NULL) {
-	    errmsg = ap_psprintf(p, "%s%s%s:%u: %s> was not closed.",
+	    errmsg = apr_psprintf(p, "%s%s%s:%u: %s> was not closed.",
 				 errmsg,
 				 *errmsg == '\0' ? "" : APR_EOL_STR,
 				 curr_parent->filename,
@@ -1109,7 +1109,7 @@ API_EXPORT_NONSTD(const char *) ap_set_string_slot_lower(cmd_parms *cmd,
 							 const char *arg_)
 {
     /* This one's pretty generic... */
-    char *arg=ap_pstrdup(cmd->pool,arg_);
+    char *arg=apr_pstrdup(cmd->pool,arg_);
 
     int offset = (int) (long) cmd->info;
     ap_str_tolower(arg);
@@ -1137,7 +1137,7 @@ API_EXPORT_NONSTD(const char *) ap_set_file_slot(cmd_parms *cmd, char *struct_pt
     char *p;
     int offset = (int) (long) cmd->info;
     if (ap_os_is_path_absolute(arg))
-	p = ap_pstrdup(cmd->pool, arg);
+	p = apr_pstrdup(cmd->pool, arg);
     else
 	p = ap_make_full_path(cmd->pool, ap_server_root, arg);
     *(char **) (struct_ptr + offset) = p;
@@ -1152,7 +1152,7 @@ API_EXPORT_NONSTD(const char *) ap_set_file_slot(cmd_parms *cmd, char *struct_pt
 static cmd_parms default_parms =
 {NULL, 0, -1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
 
-API_EXPORT(const char *) ap_server_root_relative(ap_pool_t *p, const char *file)
+API_EXPORT(const char *) ap_server_root_relative(apr_pool_t *p, const char *file)
 {
     if(ap_os_is_path_absolute(file))
 	return file;
@@ -1176,7 +1176,7 @@ API_EXPORT(const char *) ap_soak_end_container(cmd_parms *cmd, char *directive)
             if (cmd_name[1] == '/') {
                 cmd_name[strlen(cmd_name) - 1] = '\0';
                 if (strcasecmp(cmd_name + 2, directive + 1) != 0) {
-                    return ap_pstrcat(cmd->pool, "Expected </",
+                    return apr_pstrcat(cmd->pool, "Expected </",
                                       directive + 1, "> but saw ",
                                       cmd_name, ">", NULL);
                 }
@@ -1191,14 +1191,14 @@ API_EXPORT(const char *) ap_soak_end_container(cmd_parms *cmd, char *directive)
 }
 
 static const char *execute_now(char *cmd_line, const char *args, cmd_parms *parms, 
-                         ap_pool_t *p, ap_pool_t *ptemp, 
+                         apr_pool_t *p, apr_pool_t *ptemp, 
                          ap_directive_t **sub_tree, ap_directive_t *parent)
 {
     module *mod = top_module;
     const command_rec *cmd;
 
     if (!(cmd = ap_find_command_in_modules(cmd_line, &mod))) {
-        return ap_pstrcat(parms->pool, "Invalid command '", 
+        return apr_pstrcat(parms->pool, "Invalid command '", 
                           cmd_line,
                           "', perhaps mis-spelled or defined by a module "
                           "not included in the server configuration",
@@ -1217,10 +1217,10 @@ static const char *execute_now(char *cmd_line, const char *args, cmd_parms *parm
 /* Structure to be passed to cfg_open_custom(): it contains an
  * index which is incremented from 0 to nelts on each call to
  * cfg_getline() (which in turn calls arr_elts_getstr())
- * and an ap_array_header_t pointer for the string array.
+ * and an apr_array_header_t pointer for the string array.
  */
 typedef struct {
-    ap_array_header_t *array;
+    apr_array_header_t *array;
     int curr_idx;
 } arr_elts_param_t;
 
@@ -1235,7 +1235,7 @@ static void *arr_elts_getstr(void *buf, size_t bufsiz, void *param)
         return NULL;
 
     /* return the line */
-    ap_cpystrn(buf, ((char **) arr_param->array->elts)[arr_param->curr_idx - 1], bufsiz);
+    apr_cpystrn(buf, ((char **) arr_param->array->elts)[arr_param->curr_idx - 1], bufsiz);
 
     return buf;
 }
@@ -1249,9 +1249,9 @@ static int arr_elts_close(void *param)
     return 0;
 }
 
-static void process_command_config(server_rec *s, ap_array_header_t *arr, 
-                              ap_directive_t **conftree, ap_pool_t *p,
-			      ap_pool_t *ptemp)
+static void process_command_config(server_rec *s, apr_array_header_t *arr, 
+                              ap_directive_t **conftree, apr_pool_t *p,
+			      apr_pool_t *ptemp)
 {
     const char *errmsg;
     cmd_parms parms;
@@ -1282,11 +1282,11 @@ static void process_command_config(server_rec *s, ap_array_header_t *arr,
 }
 
 void ap_process_resource_config(server_rec *s, const char *fname, 
-                                ap_directive_t **conftree, ap_pool_t *p, 
-                                ap_pool_t *ptemp)
+                                ap_directive_t **conftree, apr_pool_t *p, 
+                                apr_pool_t *ptemp)
 {
     cmd_parms parms;
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     const char *errmsg;
     configfile_t *cfp;
 
@@ -1295,7 +1295,7 @@ void ap_process_resource_config(server_rec *s, const char *fname,
     /* don't require conf/httpd.conf if we have a -C or -c switch */
     if((ap_server_pre_read_config->nelts || ap_server_post_read_config->nelts) &&
        !(strcmp(fname, ap_server_root_relative(p, SERVER_CONFIG_FILE)))) {
-	if (ap_stat(&finfo, fname, p) != APR_SUCCESS)     
+	if (apr_stat(&finfo, fname, p) != APR_SUCCESS)     
 	    return;
     }
 
@@ -1332,7 +1332,7 @@ void ap_process_resource_config(server_rec *s, const char *fname,
 }
 
 API_EXPORT(void)ap_process_config_tree(server_rec *s, ap_directive_t *conftree,
-                                       ap_pool_t *p, ap_pool_t *ptemp)
+                                       apr_pool_t *p, apr_pool_t *ptemp)
 {
     const char *errmsg;
     cmd_parms parms;
@@ -1364,7 +1364,7 @@ int ap_parse_htaccess(void **result, request_rec *r, int override,
     const struct htaccess_result *cache;
     struct htaccess_result *new;
     void *dc = NULL;
-    ap_status_t status;
+    apr_status_t status;
 
 /* firstly, search cache */
     for (cache = r->htaccess; cache != NULL; cache = cache->next)
@@ -1379,7 +1379,7 @@ int ap_parse_htaccess(void **result, request_rec *r, int override,
     parms.pool = r->pool;
     parms.temp_pool = r->pool;
     parms.server = r->server;
-    parms.path = ap_pstrdup(r->pool, d);
+    parms.path = apr_pstrdup(r->pool, d);
 
     /* loop through the access names and find the first one */
 
@@ -1409,14 +1409,14 @@ int ap_parse_htaccess(void **result, request_rec *r, int override,
             *result = dc;
             break;
         } else {
-	    ap_status_t cerr = ap_canonical_error(status);
+	    apr_status_t cerr = apr_canonical_error(status);
 
 	    if (cerr != APR_ENOENT && cerr != APR_ENOTDIR) {
 		ap_log_rerror(APLOG_MARK, APLOG_CRIT, status, r,
 			      "%s pcfg_openfile: unable to check htaccess file, "
 			      "ensure it is readable",
 			      filename);
-		ap_table_setn(r->notes, "error-notes",
+		apr_table_setn(r->notes, "error-notes",
 			      "Server unable to read htaccess file, denying "
 			      "access to be safe");
 		return HTTP_FORBIDDEN;
@@ -1425,7 +1425,7 @@ int ap_parse_htaccess(void **result, request_rec *r, int override,
     }
 
 /* cache it */
-    new = ap_palloc(r->pool, sizeof(struct htaccess_result));
+    new = apr_palloc(r->pool, sizeof(struct htaccess_result));
     new->dir = parms.path;
     new->override = override;
     new->htaccess = dc;
@@ -1437,10 +1437,10 @@ int ap_parse_htaccess(void **result, request_rec *r, int override,
 }
 
 
-CORE_EXPORT(const char *) ap_init_virtual_host(ap_pool_t *p, const char *hostname,
+CORE_EXPORT(const char *) ap_init_virtual_host(apr_pool_t *p, const char *hostname,
 			      server_rec *main_server, server_rec **ps)
 {
-    server_rec *s = (server_rec *) ap_pcalloc(p, sizeof(server_rec));
+    server_rec *s = (server_rec *) apr_pcalloc(p, sizeof(server_rec));
 
     /* TODO: this crap belongs in http_core */
     s->process = main_server->process;
@@ -1458,8 +1458,8 @@ CORE_EXPORT(const char *) ap_init_virtual_host(ap_pool_t *p, const char *hostnam
     s->next = NULL;
 
     s->is_virtual = 1;
-    s->names = ap_make_array(p, 4, sizeof(char **));
-    s->wild_names = ap_make_array(p, 4, sizeof(char **));
+    s->names = apr_make_array(p, 4, sizeof(char **));
+    s->wild_names = apr_make_array(p, 4, sizeof(char **));
 
     s->module_config = create_empty_config(p);
     s->lookup_defaults = ap_create_per_dir_config(p);
@@ -1479,7 +1479,7 @@ CORE_EXPORT(const char *) ap_init_virtual_host(ap_pool_t *p, const char *hostnam
 }
 
 
-API_EXPORT(void) ap_fixup_virtual_hosts(ap_pool_t *p, server_rec *main_server)
+API_EXPORT(void) ap_fixup_virtual_hosts(apr_pool_t *p, server_rec *main_server)
 {
     server_rec *virt;
 
@@ -1518,17 +1518,17 @@ API_EXPORT(void) ap_fixup_virtual_hosts(ap_pool_t *p, server_rec *main_server)
  * Getting *everything* configured... 
  */
 
-static void init_config_globals(ap_pool_t *p)
+static void init_config_globals(apr_pool_t *p)
 {
     /* Global virtual host hash bucket pointers.  Init to null. */
     ap_init_vhost_config(p);
 }
 
-static server_rec *init_server_config(process_rec *process, ap_pool_t *p)
+static server_rec *init_server_config(process_rec *process, apr_pool_t *p)
 {
-    server_rec *s = (server_rec *) ap_pcalloc(p, sizeof(server_rec));
+    server_rec *s = (server_rec *) apr_pcalloc(p, sizeof(server_rec));
 
-    ap_open_stderr(&s->error_log, p);
+    apr_open_stderr(&s->error_log, p);
     s->process = process;
     s->port = 0;
     s->server_admin = DEFAULT_ADMIN;
@@ -1543,7 +1543,7 @@ static server_rec *init_server_config(process_rec *process, ap_pool_t *p)
     s->keep_alive_max = DEFAULT_KEEPALIVE;
     s->keep_alive = 1;
     s->next = NULL;
-    s->addrs = ap_pcalloc(p, sizeof(server_addr_rec));
+    s->addrs = apr_pcalloc(p, sizeof(server_addr_rec));
     /* NOT virtual host; don't match any real network interface */
     s->addrs->host_addr.s_addr = htonl(INADDR_ANY);
     s->addrs->host_port = 0;	/* matches any port */
@@ -1557,11 +1557,11 @@ static server_rec *init_server_config(process_rec *process, ap_pool_t *p)
 }
 
 
-API_EXPORT(server_rec*) ap_read_config(process_rec *process, ap_pool_t *ptemp,
+API_EXPORT(server_rec*) ap_read_config(process_rec *process, apr_pool_t *ptemp,
                                        const char *confname, 
                                        ap_directive_t **conftree)
 {
-    ap_pool_t *p = process->pconf;
+    apr_pool_t *p = process->pconf;
     server_rec *s = init_server_config(process, p);
 
     init_config_globals(p);
@@ -1579,7 +1579,7 @@ API_EXPORT(server_rec*) ap_read_config(process_rec *process, ap_pool_t *ptemp,
     return s;
 }
 
-void ap_single_module_configure(ap_pool_t *p, server_rec *s, module *m)
+void ap_single_module_configure(apr_pool_t *p, server_rec *s, module *m)
 {
     if (m->create_server_config)
         ap_set_module_config(s->module_config, m,
@@ -1598,13 +1598,13 @@ API_EXPORT(void) ap_run_rewrite_args(process_rec *process)
             (*m->rewrite_args) (process);
 }
 
-API_EXPORT(void) ap_post_config_hook(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *s)
+API_EXPORT(void) ap_post_config_hook(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
 {
     ap_run_post_config(pconf,plog,ptemp,s); 
     init_handlers(pconf);
 }
 
-void ap_child_init_hook(ap_pool_t *pchild, server_rec *s)
+void ap_child_init_hook(apr_pool_t *pchild, server_rec *s)
 {
     /* TODO: uh this seems ugly, is there a better way? */
     /*ap_child_init_alloc();    PUT THIS BACK IN XXXXX */
diff --git a/server/connection.c b/server/connection.c
index 0895534..e8fec98 100644
--- a/server/connection.c
+++ b/server/connection.c
@@ -143,9 +143,9 @@ static void sock_enable_linger(int s)
 void ap_lingering_close(conn_rec *c)
 {
     char dummybuf[512];
-    ap_time_t start;
-    ap_ssize_t nbytes;
-    ap_status_t rc;
+    apr_time_t start;
+    apr_ssize_t nbytes;
+    apr_status_t rc;
     int timeout;
 
 #ifdef NO_LINGCLOSE
@@ -184,7 +184,7 @@ void ap_lingering_close(conn_rec *c)
      * from peer) or we've exceeded our overall timeout.
      */
     
-    start = ap_now();
+    start = apr_now();
     timeout = MAX_SECS_TO_LINGER;
     for (;;) {
         ap_bsetopt(c->client, BO_TIMEOUT, &timeout);
@@ -193,7 +193,7 @@ void ap_lingering_close(conn_rec *c)
         if (rc != APR_SUCCESS || nbytes == 0) break;
 
         /* how much time has elapsed? */
-        timeout = (int)((ap_now() - start) / AP_USEC_PER_SEC);
+        timeout = (int)((apr_now() - start) / AP_USEC_PER_SEC);
         if (timeout >= MAX_SECS_TO_LINGER) break;
 
         /* figure out the new timeout */
@@ -235,7 +235,7 @@ int ap_process_http_connection(conn_rec *c)
 	    break;
 
         ap_update_connection_status(c->id, "Status", "Keepalive");
-	ap_destroy_pool(r->pool);
+	apr_destroy_pool(r->pool);
 
 	if (ap_graceful_stop_signalled())
             break;
@@ -249,28 +249,28 @@ int ap_process_http_connection(conn_rec *c)
    structure, but for now...
 */
 
-conn_rec *ap_new_connection(ap_pool_t *p, server_rec *server, BUFF *inout,
+conn_rec *ap_new_connection(apr_pool_t *p, server_rec *server, BUFF *inout,
 			    const struct sockaddr_in *remaddr,
 			    const struct sockaddr_in *saddr, long id)
 {
-    conn_rec *conn = (conn_rec *) ap_pcalloc(p, sizeof(conn_rec));
+    conn_rec *conn = (conn_rec *) apr_pcalloc(p, sizeof(conn_rec));
 
     /* Got a connection structure, so initialize what fields we can
      * (the rest are zeroed out by pcalloc).
      */
 
     conn->conn_config=ap_create_conn_config(p);
-    conn->notes = ap_make_table(p, 5);
+    conn->notes = apr_make_table(p, 5);
 
     conn->pool = p;
     conn->local_addr = *saddr;
-    conn->local_ip = ap_pstrdup(conn->pool,
+    conn->local_ip = apr_pstrdup(conn->pool,
 				inet_ntoa(conn->local_addr.sin_addr));
     conn->base_server = server;
     conn->client = inout;
 
     conn->remote_addr = *remaddr;
-    conn->remote_ip = ap_pstrdup(conn->pool,
+    conn->remote_ip = apr_pstrdup(conn->pool,
 			      inet_ntoa(conn->remote_addr.sin_addr));
     
     conn->id = id;
@@ -280,12 +280,12 @@ conn_rec *ap_new_connection(ap_pool_t *p, server_rec *server, BUFF *inout,
 
 
 
-conn_rec *ap_new_apr_connection(ap_pool_t *p, server_rec *server, BUFF *inout,
-                                ap_socket_t *conn_socket, long id)
+conn_rec *ap_new_apr_connection(apr_pool_t *p, server_rec *server, BUFF *inout,
+                                apr_socket_t *conn_socket, long id)
 {
     struct sockaddr_in *sa_local, *sa_remote;
 
-    ap_get_local_name(&sa_local, conn_socket);
-    ap_get_remote_name(&sa_remote, conn_socket);
+    apr_get_local_name(&sa_local, conn_socket);
+    apr_get_remote_name(&sa_remote, conn_socket);
     return ap_new_connection(p, server, inout, sa_remote, sa_local, id);
 }
diff --git a/server/gen_uri_delims.c b/server/gen_uri_delims.c
index 562c72f..d123800 100644
--- a/server/gen_uri_delims.c
+++ b/server/gen_uri_delims.c
@@ -58,7 +58,7 @@
 
 #include <stdio.h>
 
-/* generate a ap_table_t of 256 values, where certain characters are
+/* generate a apr_table_t of 256 values, where certain characters are
  * marked "interesting"... for the uri parsing process.
  */
 
diff --git a/server/listen.c b/server/listen.c
index 1c9627a..58fe3c7 100644
--- a/server/listen.c
+++ b/server/listen.c
@@ -76,33 +76,33 @@ static int ap_listenbacklog;
 static int send_buffer_size;
 
 /* TODO: make_sock is just begging and screaming for APR abstraction */
-static ap_status_t make_sock(ap_pool_t *p, ap_listen_rec *server)
+static apr_status_t make_sock(apr_pool_t *p, ap_listen_rec *server)
 {
-    ap_socket_t *s = server->sd;
+    apr_socket_t *s = server->sd;
     int one = 1;
     char addr[512];
-    ap_status_t stat;
-    ap_uint32_t port;
+    apr_status_t stat;
+    apr_uint32_t port;
     char *ipaddr;
 
-    ap_get_local_port(&port,s);
-    ap_get_local_ipaddr(&ipaddr,s);
-    ap_snprintf(addr, sizeof(addr), "address %s port %u", ipaddr,
+    apr_get_local_port(&port,s);
+    apr_get_local_ipaddr(&ipaddr,s);
+    apr_snprintf(addr, sizeof(addr), "address %s port %u", ipaddr,
 		(unsigned) port);
 
-    stat = ap_setsocketopt(s, APR_SO_REUSEADDR, one);
+    stat = apr_setsocketopt(s, APR_SO_REUSEADDR, one);
     if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
 	ap_log_error(APLOG_MARK, APLOG_CRIT, stat, NULL,
 		    "make_sock: for %s, setsockopt: (SO_REUSEADDR)", addr);
-	ap_close_socket(s);
+	apr_close_socket(s);
 	return stat;
     }
     
-    stat = ap_setsocketopt(s, APR_SO_KEEPALIVE, one);
+    stat = apr_setsocketopt(s, APR_SO_KEEPALIVE, one);
     if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
 	ap_log_error(APLOG_MARK, APLOG_CRIT, stat, NULL,
 		    "make_sock: for %s, setsockopt: (SO_KEEPALIVE)", addr);
-	ap_close_socket(s);
+	apr_close_socket(s);
 	return stat;
     }
 
@@ -126,7 +126,7 @@ static ap_status_t make_sock(ap_pool_t *p, ap_listen_rec *server)
      * If no size is specified, use the kernel default.
      */
     if (send_buffer_size) {
-	stat = ap_setsocketopt(s, APR_SO_SNDBUF,  send_buffer_size);
+	stat = apr_setsocketopt(s, APR_SO_SNDBUF,  send_buffer_size);
         if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, stat, NULL,
 			"make_sock: failed to set SendBufferSize for %s, "
@@ -135,17 +135,17 @@ static ap_status_t make_sock(ap_pool_t *p, ap_listen_rec *server)
 	}
     }
 
-    if ((stat = ap_bind(s)) != APR_SUCCESS) {
+    if ((stat = apr_bind(s)) != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_CRIT, stat, NULL,
 	    "make_sock: could not bind to %s", addr);
-	ap_close_socket(s);
+	apr_close_socket(s);
 	return stat;
     }
 
-    if ((stat = ap_listen(s, ap_listenbacklog)) != APR_SUCCESS) {
+    if ((stat = apr_listen(s, ap_listenbacklog)) != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_ERR, stat, NULL,
 	    "make_sock: unable to listen for connections on %s", addr);
-	ap_close_socket(s);
+	apr_close_socket(s);
 	return stat;
     }
 
@@ -155,12 +155,12 @@ static ap_status_t make_sock(ap_pool_t *p, ap_listen_rec *server)
 }
 
 
-static ap_status_t close_listeners_on_exec(void *v)
+static apr_status_t close_listeners_on_exec(void *v)
 {
     ap_listen_rec *lr;
 
     for (lr = ap_listeners; lr; lr = lr->next) {
-	ap_close_socket(lr->sd);
+	apr_close_socket(lr->sd);
 	lr->active = 0;
     }
     return APR_SUCCESS;
@@ -171,14 +171,14 @@ static void alloc_listener(process_rec *process, char *addr, unsigned int port)
 {
     ap_listen_rec **walk;
     ap_listen_rec *new;
-    ap_status_t status;
+    apr_status_t status;
     char *oldaddr;
     unsigned int oldport;
 
     /* see if we've got an old listener for this address:port */
     for (walk = &old_listeners; *walk; walk = &(*walk)->next) {
-        ap_get_local_port(&oldport, (*walk)->sd);
-	ap_get_local_ipaddr(&oldaddr,(*walk)->sd);
+        apr_get_local_port(&oldport, (*walk)->sd);
+	apr_get_local_ipaddr(&oldaddr,(*walk)->sd);
 	if (!strcmp(oldaddr, addr) && port == oldport) {
 	    /* re-use existing record */
 	    new = *walk;
@@ -190,15 +190,15 @@ static void alloc_listener(process_rec *process, char *addr, unsigned int port)
     }
 
     /* this has to survive restarts */
-    new = ap_palloc(process->pool, sizeof(ap_listen_rec));
+    new = apr_palloc(process->pool, sizeof(ap_listen_rec));
     new->active = 0;
-    if ((status = ap_create_tcp_socket(&new->sd, process->pool)) != APR_SUCCESS) {
+    if ((status = apr_create_tcp_socket(&new->sd, process->pool)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, status, NULL,
                  "make_sock: failed to get a socket for %s", addr);
         return;
     }
-    ap_set_local_port(new->sd, port);
-    ap_set_local_ipaddr(new->sd, addr);
+    apr_set_local_port(new->sd, port);
+    apr_set_local_ipaddr(new->sd, addr);
     new->next = ap_listeners;
     ap_listeners = new;
 }
@@ -208,7 +208,7 @@ static
 #endif
 int ap_listen_open(process_rec *process, unsigned port)
 {
-    ap_pool_t *pconf = process->pconf;
+    apr_pool_t *pconf = process->pconf;
     ap_listen_rec *lr;
     ap_listen_rec *next;
     int num_open;
@@ -233,14 +233,14 @@ int ap_listen_open(process_rec *process, unsigned port)
 
     /* close the old listeners */
     for (lr = old_listeners; lr; lr = next) {
-	ap_close_socket(lr->sd);
+	apr_close_socket(lr->sd);
 	lr->active = 0;
 	next = lr->next;
 /*	free(lr);*/
     }
     old_listeners = NULL;
 
-    ap_register_cleanup(pconf, NULL, ap_null_cleanup, close_listeners_on_exec);
+    apr_register_cleanup(pconf, NULL, apr_null_cleanup, close_listeners_on_exec);
 
     return num_open ? 0 : -1;
 }
@@ -270,7 +270,7 @@ void ap_listen_pre_config(void)
 
 const char *ap_set_listener(cmd_parms *cmd, void *dummy, const char *ips_)
 {
-    char *ips=ap_pstrdup(cmd->pool, ips_);
+    char *ips=apr_pstrdup(cmd->pool, ips_);
     char *ports;
     unsigned short port;
 
diff --git a/server/log.c b/server/log.c
index 00e09ad..ff8c162 100644
--- a/server/log.c
+++ b/server/log.c
@@ -65,7 +65,7 @@
 
 
 #define CORE_PRIVATE
-#include "apr.h"  /* for ap_signal */
+#include "apr.h"  /* for apr_signal */
 #include "ap_config.h"
 #include "apr_strings.h"
 #include "apr_lib.h"
@@ -165,24 +165,24 @@ static const TRANS priorities[] = {
     {NULL,	-1},
 };
 
-static int log_child(ap_pool_t *p, const char *progname,
-                     ap_file_t **fpin)
+static int log_child(apr_pool_t *p, const char *progname,
+                     apr_file_t **fpin)
 {
     /* Child process code for 'ErrorLog "|..."';
      * may want a common framework for this, since I expect it will
      * be common for other foo-loggers to want this sort of thing...
      */
     int rc = -1;
-    ap_procattr_t *procattr;
-    ap_proc_t *procnew;
+    apr_procattr_t *procattr;
+    apr_proc_t *procnew;
 
 #ifdef SIGHUP
     /* No concept of a child process on Win32 */
-    ap_signal(SIGHUP, SIG_IGN);
+    apr_signal(SIGHUP, SIG_IGN);
 #endif /* ndef SIGHUP */
 
-    if ((ap_createprocattr_init(&procattr, p) != APR_SUCCESS) ||
-        (ap_setprocattr_io(procattr,
+    if ((apr_createprocattr_init(&procattr, p) != APR_SUCCESS) ||
+        (apr_setprocattr_io(procattr,
                            APR_FULL_BLOCK,
                            APR_NO_PIPE,
                            APR_NO_PIPE) != APR_SUCCESS)) {
@@ -193,13 +193,13 @@ static int log_child(ap_pool_t *p, const char *progname,
         char **args;
         const char *pname;
         
-        ap_tokenize_to_argv(progname, &args, p);
-        pname = ap_pstrdup(p, args[0]);
-        procnew = (ap_proc_t *) ap_palloc(p, sizeof(*procnew));
-        rc = ap_create_process(procnew, pname, args, NULL, procattr, p);
+        apr_tokenize_to_argv(progname, &args, p);
+        pname = apr_pstrdup(p, args[0]);
+        procnew = (apr_proc_t *) apr_palloc(p, sizeof(*procnew));
+        rc = apr_create_process(procnew, pname, args, NULL, procattr, p);
     
         if (rc == APR_SUCCESS) {
-            ap_note_subprocess(p, procnew, kill_after_timeout);
+            apr_note_subprocess(p, procnew, kill_after_timeout);
             (*fpin) = procnew->in;
         }
     }
@@ -207,13 +207,13 @@ static int log_child(ap_pool_t *p, const char *progname,
     return(rc);
 }
 
-static void open_error_log(server_rec *s, ap_pool_t *p)
+static void open_error_log(server_rec *s, apr_pool_t *p)
 {
     const char *fname;
     int rc;
 
     if (*s->error_fname == '|') {
-	ap_file_t *dummy = NULL;
+	apr_file_t *dummy = NULL;
 
         /* This starts a new process... */
         rc = log_child (p, s->error_fname+1, &dummy);
@@ -251,7 +251,7 @@ static void open_error_log(server_rec *s, ap_pool_t *p)
     else {
 	fname = ap_server_root_relative(p, s->error_fname);
 	/*  Change to AP funcs. */
-        if (ap_open(&s->error_log, fname, APR_APPEND | 
+        if (apr_open(&s->error_log, fname, APR_APPEND | 
                     APR_READ | APR_WRITE | APR_CREATE, APR_OS_DEFAULT, p) != APR_SUCCESS) {
             perror("fopen");
             ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
@@ -262,21 +262,21 @@ static void open_error_log(server_rec *s, ap_pool_t *p)
     }
 }
 
-void ap_open_logs(server_rec *s_main, ap_pool_t *p)
+void ap_open_logs(server_rec *s_main, apr_pool_t *p)
 {
-    ap_status_t rc = APR_SUCCESS;
+    apr_status_t rc = APR_SUCCESS;
     server_rec *virt, *q;
     int replace_stderr;
-    ap_file_t *errfile = NULL;
+    apr_file_t *errfile = NULL;
 
     open_error_log(s_main, p);
 
     replace_stderr = 1;
     if (s_main->error_log) {
         /* replace stderr with this new log */
-        ap_flush(s_main->error_log);
-        ap_open_stderr(&errfile, p);        
-        if ((rc = ap_dupfile(&errfile, s_main->error_log, NULL)) != APR_SUCCESS) {
+        apr_flush(s_main->error_log);
+        apr_open_stderr(&errfile, p);        
+        if ((rc = apr_dupfile(&errfile, s_main->error_log, NULL)) != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_CRIT, rc, s_main,
                          "unable to replace stderr with error_log");
         } else {
@@ -309,22 +309,22 @@ void ap_open_logs(server_rec *s_main, ap_pool_t *p)
 }
 
 API_EXPORT(void) ap_error_log2stderr(server_rec *s) {
-    ap_file_t *errfile = NULL;
+    apr_file_t *errfile = NULL;
 
-    ap_open_stderr(&errfile, s->process->pool);        
+    apr_open_stderr(&errfile, s->process->pool);        
     if (s->error_log != NULL) {
-        ap_dupfile(&(s->error_log), errfile, s->process->pool);
+        apr_dupfile(&(s->error_log), errfile, s->process->pool);
     }
 }
 
 static void log_error_core(const char *file, int line, int level, 
-                           ap_status_t status, const server_rec *s, 
-                           const request_rec *r, ap_pool_t *pool,
+                           apr_status_t status, const server_rec *s, 
+                           const request_rec *r, apr_pool_t *pool,
                            const char *fmt, va_list args)
 {
     char errstr[MAX_STRING_LEN];
     size_t len;
-    ap_file_t *logf = NULL;
+    apr_file_t *logf = NULL;
 
     if (s == NULL) {
 	/*
@@ -335,7 +335,7 @@ static void log_error_core(const char *file, int line, int level,
 	if (((level & APLOG_LEVELMASK) != APLOG_NOTICE) &&
 	    ((level & APLOG_LEVELMASK) > DEFAULT_LOGLEVEL))
 	    return;
-	ap_open_stderr(&logf, NULL);
+	apr_open_stderr(&logf, NULL);
     }
     else if (s->error_log) {
 	/*
@@ -371,7 +371,7 @@ static void log_error_core(const char *file, int line, int level,
 
     if (logf && ((level & APLOG_STARTUP) != APLOG_STARTUP)) {
 	errstr[0] = '[';
-	ap_ctime(errstr + 1, ap_now());
+	apr_ctime(errstr + 1, apr_now());
 	errstr[1 + AP_CTIME_LEN - 1] = ']';
 	errstr[1 + AP_CTIME_LEN    ] = ' ';
 	len = 1 + AP_CTIME_LEN + 1;
@@ -380,7 +380,7 @@ static void log_error_core(const char *file, int line, int level,
     }
 
     if ((level & APLOG_STARTUP) != APLOG_STARTUP) {
-        len += ap_snprintf(errstr + len, MAX_STRING_LEN - len,
+        len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,
 	        "[%s] ", priorities[level & APLOG_LEVELMASK].t_name);
     }
 #ifndef TPF
@@ -396,14 +396,14 @@ static void log_error_core(const char *file, int line, int level,
 	 * down to the basename.
 	 */
 	if (e != NULL && e[1] != '\0') {
-	    ap_snprintf(tmp, sizeof(tmp), "%s", &e[1]);
+	    apr_snprintf(tmp, sizeof(tmp), "%s", &e[1]);
 	    e = &tmp[strlen(tmp)-1];
 	    if (*e == ')')
 		*e = '\0';
 	    file = tmp;
 	}
 #endif /*_OSD_POSIX*/
-	len += ap_snprintf(errstr + len, MAX_STRING_LEN - len,
+	len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,
 		"%s(%d): ", file, line);
     }
 #endif /* TPF */
@@ -413,26 +413,26 @@ static void log_error_core(const char *file, int line, int level,
 	 * quad is the most secure, which is why I'm implementing it
 	 * first. -djg
 	 */
-	len += ap_snprintf(errstr + len, MAX_STRING_LEN - len,
+	len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,
 		"[client %s] ", r->connection->remote_ip);
     }
     if (!(level & APLOG_NOERRNO)
 	&& (status != 0)) {
         char buf[120];
-	len += ap_snprintf(errstr + len, MAX_STRING_LEN - len,
-		"(%d)%s: ", status, ap_strerror(status, buf, sizeof(buf)));
+	len += apr_snprintf(errstr + len, MAX_STRING_LEN - len,
+		"(%d)%s: ", status, apr_strerror(status, buf, sizeof(buf)));
     }
 
-    len += ap_vsnprintf(errstr + len, MAX_STRING_LEN - len, fmt, args);
+    len += apr_vsnprintf(errstr + len, MAX_STRING_LEN - len, fmt, args);
 
     /* NULL if we are logging to syslog */
     if (logf) {
-        /* Truncate for the terminator (as ap_snprintf does) */
+        /* Truncate for the terminator (as apr_snprintf does) */
         if (len > MAX_STRING_LEN - sizeof(APR_EOL_STR))
             len = MAX_STRING_LEN - sizeof(APR_EOL_STR);
         strcpy(errstr + len, APR_EOL_STR);
-        ap_puts(errstr, logf);
-	ap_flush(logf);
+        apr_puts(errstr, logf);
+	apr_flush(logf);
     }
 #ifdef HAVE_SYSLOG
     else {
@@ -442,7 +442,7 @@ static void log_error_core(const char *file, int line, int level,
 }
     
 API_EXPORT(void) ap_log_error(const char *file, int line, int level,
-			      ap_status_t status, const server_rec *s, 
+			      apr_status_t status, const server_rec *s, 
                               const char *fmt, ...)
 {
     va_list args;
@@ -453,7 +453,7 @@ API_EXPORT(void) ap_log_error(const char *file, int line, int level,
 }
 
 API_EXPORT(void) ap_log_perror(const char *file, int line, int level,
-			      ap_status_t status, ap_pool_t *p, 
+			      apr_status_t status, apr_pool_t *p, 
                               const char *fmt, ...)
 {
     va_list args;
@@ -464,7 +464,7 @@ API_EXPORT(void) ap_log_perror(const char *file, int line, int level,
 }
 
 API_EXPORT(void) ap_log_rerror(const char *file, int line, int level,
-			       ap_status_t status, const request_rec *r, 
+			       apr_status_t status, const request_rec *r, 
                                const char *fmt, ...)
 {
     va_list args;
@@ -482,28 +482,28 @@ API_EXPORT(void) ap_log_rerror(const char *file, int line, int level,
     va_end(args);
     va_start(args,fmt); 
     if (((level & APLOG_LEVELMASK) <= APLOG_WARNING)
-	&& (ap_table_get(r->notes, "error-notes") == NULL)) {
-	ap_table_setn(r->notes, "error-notes",
-		      ap_escape_html(r->pool, ap_pvsprintf(r->pool, fmt, 
+	&& (apr_table_get(r->notes, "error-notes") == NULL)) {
+	apr_table_setn(r->notes, "error-notes",
+		      ap_escape_html(r->pool, apr_pvsprintf(r->pool, fmt, 
 		      args)));
     }
     va_end(args);
 }
 
-void ap_log_pid(ap_pool_t *p, const char *fname)
+void ap_log_pid(apr_pool_t *p, const char *fname)
 {
-    ap_file_t *pid_file = NULL;
-    ap_finfo_t finfo;
+    apr_file_t *pid_file = NULL;
+    apr_finfo_t finfo;
     static pid_t saved_pid = -1;
     pid_t mypid;
-    ap_status_t rv;
+    apr_status_t rv;
 
     if (!fname) 
 	return;
 
     fname = ap_server_root_relative(p, fname);
     mypid = getpid();
-    if (mypid != saved_pid && ap_stat(&finfo, fname, p) == APR_SUCCESS) {
+    if (mypid != saved_pid && apr_stat(&finfo, fname, p) == APR_SUCCESS) {
       /* WINCH and HUP call this on each restart.
        * Only warn on first time through for this pid.
        *
@@ -512,13 +512,13 @@ void ap_log_pid(ap_pool_t *p, const char *fname)
        *      based on the last modification time of the pid file.
        */
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
-		     ap_psprintf(p,
+		     apr_psprintf(p,
                                  "pid file %s overwritten -- Unclean shutdown of previous Apache run?",
                      fname)
 			       );
     }
 
-    if ((rv = ap_open(&pid_file, fname, APR_WRITE | APR_CREATE | APR_TRUNCATE,
+    if ((rv = apr_open(&pid_file, fname, APR_WRITE | APR_CREATE | APR_TRUNCATE,
                       APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD, p)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, 
                      "could not create %s", fname);
@@ -527,8 +527,8 @@ void ap_log_pid(ap_pool_t *p, const char *fname)
 		     ap_server_argv0, fname);
         exit(1);
     }
-    ap_fprintf(pid_file, "%ld" APR_EOL_STR, (long)mypid);
-    ap_close(pid_file);
+    apr_fprintf(pid_file, "%ld" APR_EOL_STR, (long)mypid);
+    apr_close(pid_file);
     saved_pid = mypid;
 }
 
@@ -565,7 +565,7 @@ API_EXPORT(void) ap_log_assert(const char *szExp, const char *szFile, int nLine)
 {
     char time_str[AP_CTIME_LEN];
 
-    ap_ctime(time_str, ap_now());
+    apr_ctime(time_str, apr_now());
     ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL,
                  "[%s] file %s, line %d, assertion \"%s\" failed",
 	         time_str, szFile, nLine, szExp);
@@ -586,40 +586,40 @@ static void piped_log_maintenance(int reason, void *data, ap_wait_t status);
 static int piped_log_spawn(piped_log *pl)
 {
     int rc;
-    ap_procattr_t *procattr;
-    ap_proc_t *procnew;
-    ap_status_t status;
+    apr_procattr_t *procattr;
+    apr_proc_t *procnew;
+    apr_status_t status;
 
 #ifdef SIGHUP
-    ap_signal(SIGHUP, SIG_IGN);
+    apr_signal(SIGHUP, SIG_IGN);
 #endif
-    if (((status = ap_createprocattr_init(&procattr, pl->p)) != APR_SUCCESS) ||
-        ((status = ap_setprocattr_childin(procattr, ap_piped_log_read_fd(pl), 
+    if (((status = apr_createprocattr_init(&procattr, pl->p)) != APR_SUCCESS) ||
+        ((status = apr_setprocattr_childin(procattr, ap_piped_log_read_fd(pl), 
                                 ap_piped_log_write_fd(pl)))  != APR_SUCCESS)) {
         char buf[120];
         /* Something bad happened, give up and go away. */
 	ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL,
 	    "piped_log_spawn: unable to setup child process '%s': %s",
-	    pl->program, ap_strerror(status, buf, sizeof(buf)));
+	    pl->program, apr_strerror(status, buf, sizeof(buf)));
         rc = -1;
     }
     else {
         char **args;
         const char *pname;
 
-        ap_tokenize_to_argv(pl->program, &args, pl->p);
-        pname = ap_pstrdup(pl->p, args[0]);
-        procnew = (ap_proc_t *) ap_palloc(pl->p, sizeof(*procnew));
-        rc = ap_create_process(procnew, pname, args, NULL, procattr, pl->p);
+        apr_tokenize_to_argv(pl->program, &args, pl->p);
+        pname = apr_pstrdup(pl->p, args[0]);
+        procnew = (apr_proc_t *) apr_palloc(pl->p, sizeof(*procnew));
+        rc = apr_create_process(procnew, pname, args, NULL, procattr, pl->p);
     
         if (rc == APR_SUCCESS) {            
             /* pjr - This no longer happens inside the child, */
-            /*   I am assuming that if ap_create_process was  */
+            /*   I am assuming that if apr_create_process was  */
             /*   successful that the child is running.        */
             RAISE_SIGSTOP(PIPED_LOG_SPAWN); 
             pl->pid = procnew;
             ap_piped_log_write_fd(pl) = procnew->in;
-            ap_register_other_child(procnew, piped_log_maintenance, pl, 
+            apr_register_other_child(procnew, piped_log_maintenance, pl, 
                                     ap_piped_log_write_fd(pl), pl->p);
         }
     }
@@ -631,12 +631,12 @@ static int piped_log_spawn(piped_log *pl)
 static void piped_log_maintenance(int reason, void *data, ap_wait_t status)
 {
     piped_log *pl = data;
-    ap_status_t stats;
+    apr_status_t stats;
 
     switch (reason) {
     case APR_OC_REASON_DEATH:
 	pl->pid = NULL;
-	ap_unregister_other_child(pl);
+	apr_unregister_other_child(pl);
 	if (pl->program == NULL) {
 	    /* during a restart */
 	    break;
@@ -644,7 +644,7 @@ static void piped_log_maintenance(int reason, void *data, ap_wait_t status)
         break;
     case APR_OC_REASON_LOST:
 	pl->pid = NULL;
-	ap_unregister_other_child(pl);
+	apr_unregister_other_child(pl);
 	if (pl->program == NULL) {
 	    /* during a restart */
 	    break;
@@ -655,20 +655,20 @@ static void piped_log_maintenance(int reason, void *data, ap_wait_t status)
             char buf[120];
 	    ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL,
 		"piped_log_maintenance: unable to respawn '%s': %s",
-		pl->program, ap_strerror(stats, buf, sizeof(buf)));
+		pl->program, apr_strerror(stats, buf, sizeof(buf)));
 	}
 	break;
     
     case APR_OC_REASON_UNWRITABLE:
 	if (pl->pid != NULL) {
-	    ap_kill(pl->pid, SIGTERM);
+	    apr_kill(pl->pid, SIGTERM);
 	}
 	break;
     
     case APR_OC_REASON_RESTART:
 	pl->program = NULL;
 	if (pl->pid != NULL) {
-	    ap_kill(pl->pid, SIGTERM);
+	    apr_kill(pl->pid, SIGTERM);
 	}
 	break;
 
@@ -678,46 +678,46 @@ static void piped_log_maintenance(int reason, void *data, ap_wait_t status)
 }
 
 
-static ap_status_t piped_log_cleanup(void *data)
+static apr_status_t piped_log_cleanup(void *data)
 {
     piped_log *pl = data;
 
     if (pl->pid != NULL) {
-	ap_kill(pl->pid, SIGTERM);
+	apr_kill(pl->pid, SIGTERM);
     }
-    ap_unregister_other_child(pl);
-    ap_close(ap_piped_log_read_fd(pl));
-    ap_close(ap_piped_log_write_fd(pl));
+    apr_unregister_other_child(pl);
+    apr_close(ap_piped_log_read_fd(pl));
+    apr_close(ap_piped_log_write_fd(pl));
     return APR_SUCCESS;
 }
 
 
-static ap_status_t piped_log_cleanup_for_exec(void *data)
+static apr_status_t piped_log_cleanup_for_exec(void *data)
 {
     piped_log *pl = data;
 
-    ap_close(ap_piped_log_read_fd(pl));
-    ap_close(ap_piped_log_write_fd(pl));
+    apr_close(ap_piped_log_read_fd(pl));
+    apr_close(ap_piped_log_write_fd(pl));
     return APR_SUCCESS;
 }
 
-API_EXPORT(piped_log *) ap_open_piped_log(ap_pool_t *p, const char *program)
+API_EXPORT(piped_log *) ap_open_piped_log(apr_pool_t *p, const char *program)
 {
     piped_log *pl;
 
-    pl = ap_palloc(p, sizeof (*pl));
+    pl = apr_palloc(p, sizeof (*pl));
     pl->p = p;
-    pl->program = ap_pstrdup(p, program);
+    pl->program = apr_pstrdup(p, program);
     pl->pid = NULL;
-    if (ap_create_pipe(&ap_piped_log_read_fd(pl), &ap_piped_log_write_fd(pl), p) != APR_SUCCESS) {
+    if (apr_create_pipe(&ap_piped_log_read_fd(pl), &ap_piped_log_write_fd(pl), p) != APR_SUCCESS) {
 	return NULL;
     }
-    ap_register_cleanup(p, pl, piped_log_cleanup, piped_log_cleanup_for_exec);
+    apr_register_cleanup(p, pl, piped_log_cleanup, piped_log_cleanup_for_exec);
     if (piped_log_spawn(pl) == -1) {
 	int save_errno = errno;
-	ap_kill_cleanup(p, pl, piped_log_cleanup);
-	ap_close(ap_piped_log_read_fd(pl));
-	ap_close(ap_piped_log_write_fd(pl));
+	apr_kill_cleanup(p, pl, piped_log_cleanup);
+	apr_close(ap_piped_log_read_fd(pl));
+	apr_close(ap_piped_log_write_fd(pl));
 	errno = save_errno;
 	return NULL;
     }
@@ -726,18 +726,18 @@ API_EXPORT(piped_log *) ap_open_piped_log(ap_pool_t *p, const char *program)
 
 #else
 
-static ap_status_t piped_log_cleanup(void *data)
+static apr_status_t piped_log_cleanup(void *data)
 {
     piped_log *pl = data;
 
-    ap_close(ap_piped_log_write_fd(pl));
+    apr_close(ap_piped_log_write_fd(pl));
     return APR_SUCCESS;
 }
 
-API_EXPORT(piped_log *) ap_open_piped_log(ap_pool_t *p, const char *program)
+API_EXPORT(piped_log *) ap_open_piped_log(apr_pool_t *p, const char *program)
 {
     piped_log *pl;
-    ap_file_t *dummy = NULL;
+    apr_file_t *dummy = NULL;
     int rc;
 
     rc = log_child(p, program, &dummy);
@@ -748,11 +748,11 @@ API_EXPORT(piped_log *) ap_open_piped_log(ap_pool_t *p, const char *program)
 	exit (1);
     }
 
-    pl = ap_palloc(p, sizeof (*pl));
+    pl = apr_palloc(p, sizeof (*pl));
     pl->p = p;
     ap_piped_log_read_fd(pl) = NULL;
     ap_piped_log_write_fd(pl) = dummy;
-    ap_register_cleanup(p, pl, piped_log_cleanup, piped_log_cleanup);
+    apr_register_cleanup(p, pl, piped_log_cleanup, piped_log_cleanup);
 
     return pl;
 }
@@ -761,6 +761,6 @@ API_EXPORT(piped_log *) ap_open_piped_log(ap_pool_t *p, const char *program)
 
 API_EXPORT(void) ap_close_piped_log(piped_log *pl)
 {
-    ap_run_cleanup(pl->p, pl, piped_log_cleanup);
+    apr_run_cleanup(pl->p, pl, piped_log_cleanup);
 }
 
diff --git a/server/main.c b/server/main.c
index 4e36b75..48c0827 100644
--- a/server/main.c
+++ b/server/main.c
@@ -191,8 +191,8 @@ static void show_compile_settings(void)
 
 static void destroy_and_exit_process(process_rec *process, int process_exit_value)
 {
-    ap_destroy_pool(process->pool); /* and destroy all descendent pools */
-    ap_terminate();
+    apr_destroy_pool(process->pool); /* and destroy all descendent pools */
+    apr_terminate();
     exit(process_exit_value);
 }
 
@@ -201,25 +201,25 @@ static process_rec *create_process(int argc, char *const *argv)
     process_rec *process;
     
     {
-	ap_pool_t *cntx;
-        ap_status_t stat;
+	apr_pool_t *cntx;
+        apr_status_t stat;
 
-	stat = ap_create_pool(&cntx, NULL);
+	stat = apr_create_pool(&cntx, NULL);
         if (stat != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, NULL,
-                         "ap_create_pool() failed to create "
+                         "apr_create_pool() failed to create "
                          "initial context");
-            ap_terminate();
+            apr_terminate();
             exit(1);
         }
 
-	process = ap_palloc(cntx, sizeof(process_rec));
+	process = apr_palloc(cntx, sizeof(process_rec));
 	process->pool = cntx;
     }
-    ap_create_pool(&process->pconf, process->pool);
+    apr_create_pool(&process->pconf, process->pool);
     process->argc = argc;
     process->argv = argv;
-    process->short_name = ap_filename_of_pathname(argv[0]);
+    process->short_name = apr_filename_of_pathname(argv[0]);
     return process;
 }
 
@@ -282,15 +282,15 @@ int main(int argc, char *argv[])
     const char *def_server_root = HTTPD_ROOT;
     process_rec *process;
     server_rec *server_conf;
-    ap_pool_t *pglobal;
-    ap_pool_t *pconf;
-    ap_pool_t *plog; /* Pool of log streams, reset _after_ each read of conf */
-    ap_pool_t *ptemp; /* Pool for temporary config stuff, reset often */
-    ap_pool_t *pcommands; /* Pool for -D, -C and -c switches */
+    apr_pool_t *pglobal;
+    apr_pool_t *pconf;
+    apr_pool_t *plog; /* Pool of log streams, reset _after_ each read of conf */
+    apr_pool_t *ptemp; /* Pool for temporary config stuff, reset often */
+    apr_pool_t *pcommands; /* Pool for -D, -C and -c switches */
     module **mod;
     ap_directive_t *conftree = NULL;
 
-    ap_initialize();
+    apr_initialize();
     process = create_process(argc, (char *const *)argv);
     pglobal = process->pool;
     pconf = process->pconf;
@@ -306,35 +306,35 @@ int main(int argc, char *argv[])
 
     ap_setup_prelinked_modules(process);
 
-    ap_create_pool(&pcommands, pglobal);
-    ap_server_pre_read_config  = ap_make_array(pcommands, 1, sizeof(char *));
-    ap_server_post_read_config = ap_make_array(pcommands, 1, sizeof(char *));
-    ap_server_config_defines   = ap_make_array(pcommands, 1, sizeof(char *));
+    apr_create_pool(&pcommands, pglobal);
+    ap_server_pre_read_config  = apr_make_array(pcommands, 1, sizeof(char *));
+    ap_server_post_read_config = apr_make_array(pcommands, 1, sizeof(char *));
+    ap_server_config_defines   = apr_make_array(pcommands, 1, sizeof(char *));
 
     ap_run_rewrite_args(process);
 
     /* Maintain AP_SERVER_BASEARGS list in http_main.h to allow the MPM 
      * to safely pass on our args from its rewrite_args() handler.
      */
-    while (ap_getopt(process->argc, process->argv, 
+    while (apr_getopt(process->argc, process->argv, 
                      AP_SERVER_BASEARGS, &c, pcommands) 
             == APR_SUCCESS) {
         char **new;
         switch (c) {
  	case 'c':
-	    new = (char **)ap_push_array(ap_server_post_read_config);
-	    *new = ap_pstrdup(pcommands, ap_optarg);
+	    new = (char **)apr_push_array(ap_server_post_read_config);
+	    *new = apr_pstrdup(pcommands, ap_optarg);
 	    break;
 	case 'C':
-	    new = (char **)ap_push_array(ap_server_pre_read_config);
-	    *new = ap_pstrdup(pcommands, ap_optarg);
+	    new = (char **)apr_push_array(ap_server_pre_read_config);
+	    *new = apr_pstrdup(pcommands, ap_optarg);
 	    break;
 	case 'd':
 	    def_server_root = ap_optarg;
 	    break;
 	case 'D':
-	    new = (char **)ap_push_array(ap_server_config_defines);
-	    *new = ap_pstrdup(pcommands, ap_optarg);
+	    new = (char **)apr_push_array(ap_server_config_defines);
+	    *new = apr_pstrdup(pcommands, ap_optarg);
 	    break;
 	case 'f':
 	    confname = ap_optarg;
@@ -361,8 +361,8 @@ int main(int argc, char *argv[])
 	}
     }
 
-    ap_create_pool(&plog, pglobal);
-    ap_create_pool(&ptemp, pconf);
+    apr_create_pool(&plog, pglobal);
+    apr_create_pool(&ptemp, pconf);
 
     /* Note that we preflight the config file once
        before reading it _again_ in the main loop.
@@ -380,14 +380,14 @@ int main(int argc, char *argv[])
 	ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, "Syntax OK\n");
 	destroy_and_exit_process(process, 0);
     }
-    ap_clear_pool(plog);
+    apr_clear_pool(plog);
     ap_run_open_logs(pconf, plog, ptemp, server_conf);
     ap_post_config_hook(pconf, plog, ptemp, server_conf);
-    ap_destroy_pool(ptemp);
+    apr_destroy_pool(ptemp);
 
     for (;;) {
 	ap_hook_deregister_all();
-	ap_clear_pool(pconf);
+	apr_clear_pool(pconf);
 	for (mod = ap_prelinked_modules; *mod != NULL; mod++) {
 		ap_register_hooks(*mod);
 	}
@@ -396,7 +396,7 @@ int main(int argc, char *argv[])
          * memory.  rbb
          */
         conftree = NULL;
-	ap_create_pool(&ptemp, pconf);
+	apr_create_pool(&ptemp, pconf);
 	ap_server_root = def_server_root;
         server_conf = ap_read_config(process, ptemp, confname, &conftree);
 	ap_run_pre_config(pconf, plog, ptemp);
@@ -404,10 +404,10 @@ int main(int argc, char *argv[])
         ap_fixup_virtual_hosts(pconf, server_conf);
         ap_fini_vhost_config(pconf, server_conf);
         ap_sort_hooks();
-	ap_clear_pool(plog);
+	apr_clear_pool(plog);
 	ap_run_open_logs(pconf, plog, ptemp, server_conf);
 	ap_post_config_hook(pconf, plog, ptemp, server_conf);
-	ap_destroy_pool(ptemp);
+	apr_destroy_pool(ptemp);
 
 	if (ap_mpm_run(pconf, plog, server_conf)) break;
     }
@@ -427,13 +427,13 @@ const XML_LChar *suck_in_expat(void)
 
 #ifndef SHARED_CORE_BOOTSTRAP
 /*
- * Force ap_validate_password() into the image so that modules like
+ * Force apr_validate_password() into the image so that modules like
  * mod_auth can use it even if they're dynamically loaded.
  */
-void suck_in_ap_validate_password(void);
-void suck_in_ap_validate_password(void)
+void suck_in_apr_validate_password(void);
+void suck_in_apr_validate_password(void)
 {
-    ap_validate_password("a", "b");
+    apr_validate_password("a", "b");
 }
 #endif
 
diff --git a/server/mpm/beos/beos.c b/server/mpm/beos/beos.c
index 1e8fb63..88db35e 100644
--- a/server/mpm/beos/beos.c
+++ b/server/mpm/beos/beos.c
@@ -77,7 +77,7 @@
 #include "ap_mpm.h"
 #include "beosd.h"
 #include "ap_iol.h"
-#include "ap_listen.h"
+#include "apr_listen.h"
 #include "scoreboard.h" 
 #include <kernel/OS.h>
 #include "mpm_common.h"
@@ -100,22 +100,22 @@ static int ap_thread_limit=0;
 static time_t ap_restart_time=0;
 API_VAR_EXPORT int ap_extended_status = 0;
 static int num_listening_sockets = 0; /* set by open_listeners in ap_mpm_run */
-static ap_socket_t ** listening_sockets;
-ap_lock_t *accept_mutex = NULL;
+static apr_socket_t ** listening_sockets;
+apr_lock_t *accept_mutex = NULL;
 
-static ap_pool_t *pconf;		/* Pool for config stuff */
-static ap_pool_t *pchild;		/* Pool for httpd child stuff */
+static apr_pool_t *pconf;		/* Pool for config stuff */
+static apr_pool_t *pchild;		/* Pool for httpd child stuff */
 
 static int server_pid; 
 
 /* Keep track of the number of worker threads currently active */
 static int worker_thread_count;
-ap_lock_t *worker_thread_count_mutex;
+apr_lock_t *worker_thread_count_mutex;
 
 /* The structure used to pass unique initialization info to each thread */
 typedef struct {
     int slot;
-    ap_pool_t *tpool;
+    apr_pool_t *tpool;
 } proc_info;
 
 struct ap_ctable ap_child_table[HARD_SERVER_LIMIT];
@@ -151,7 +151,7 @@ API_EXPORT(int) ap_get_max_daemons(void)
 static void clean_child_exit(int code)
 {
     if (pchild)
-        ap_destroy_pool(pchild);
+        apr_destroy_pool(pchild);
     exit(code);
 }
 
@@ -304,7 +304,7 @@ int ap_graceful_stop_signalled(void)
  * Child process main loop.
  */
 
-static void process_socket(ap_pool_t *p, ap_socket_t *sock, int my_child_num)
+static void process_socket(apr_pool_t *p, apr_socket_t *sock, int my_child_num)
 {
     BUFF *conn_io;
     conn_rec *current_conn;
@@ -312,14 +312,14 @@ static void process_socket(ap_pool_t *p, ap_socket_t *sock, int my_child_num)
     long conn_id = my_child_num;
     int csd;
 
-    (void)ap_get_os_sock(&csd, sock);
+    (void)apr_get_os_sock(&csd, sock);
     
     if (csd >= FD_SETSIZE) {
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
             "filedescriptor (%u) larger than FD_SETSIZE (%u) "
             "found, you probably need to rebuild Apache with a "
             "larger FD_SETSIZE", csd, FD_SETSIZE);
-        ap_close_socket(sock);
+        apr_close_socket(sock);
 	    return;
     }
     
@@ -327,7 +327,7 @@ static void process_socket(ap_pool_t *p, ap_socket_t *sock, int my_child_num)
     if (iol == NULL) {
         ap_log_error(APLOG_MARK, APLOG_WARNING, errno, NULL,
           "error attaching to socket");
-        ap_close_socket(sock);
+        apr_close_socket(sock);
 	    return;
     }
 
@@ -360,16 +360,16 @@ static int32 worker_thread(void * dummy)
 {
     proc_info * ti = dummy;
     int child_slot = ti->slot;
-    ap_pool_t *tpool = ti->tpool;
-    ap_socket_t *csd = NULL;
-    ap_pool_t *ptrans;		/* Pool for per-transaction stuff */
-    ap_socket_t *sd = NULL;
-    ap_status_t rv = APR_EINIT;
+    apr_pool_t *tpool = ti->tpool;
+    apr_socket_t *csd = NULL;
+    apr_pool_t *ptrans;		/* Pool for per-transaction stuff */
+    apr_socket_t *sd = NULL;
+    apr_status_t rv = APR_EINIT;
     int srv , n;
     int curr_pollfd, last_pollfd = 0;
     sigset_t sig_mask;
     int requests_this_child = ap_max_requests_per_child;
-    ap_pollfd_t *pollset;
+    apr_pollfd_t *pollset;
     /* each worker thread is in control of it's own destiny...*/
     int this_worker_should_exit = 0; 
     port_id chk = find_port("the_samaritans");    
@@ -379,26 +379,26 @@ static int32 worker_thread(void * dummy)
     sigfillset(&sig_mask);
     sigprocmask(SIG_BLOCK, &sig_mask, NULL);
 
-    ap_create_pool(&ptrans, tpool);
+    apr_create_pool(&ptrans, tpool);
 
-    ap_lock(worker_thread_count_mutex);
+    apr_lock(worker_thread_count_mutex);
     worker_thread_count++;
-    ap_unlock(worker_thread_count_mutex);
+    apr_unlock(worker_thread_count_mutex);
 
     /* now setup our own pollset...this will use APR woohoo! */
-    ap_setup_poll(&pollset, num_listening_sockets, tpool);
+    apr_setup_poll(&pollset, num_listening_sockets, tpool);
     for(n=0 ; n < num_listening_sockets ; ++n)
-	    ap_add_poll_socket(pollset, listening_sockets[n], APR_POLLIN);
+	    apr_add_poll_socket(pollset, listening_sockets[n], APR_POLLIN);
 
     while (!this_worker_should_exit) {
         this_worker_should_exit |= (ap_max_requests_per_child != 0) && (requests_this_child <= 0);
         
         if (this_worker_should_exit) break;
 
-        ap_lock(accept_mutex);
+        apr_lock(accept_mutex);
         while (!this_worker_should_exit) {
-            ap_int16_t event;
-            ap_status_t ret = ap_poll(pollset, &srv, -1);
+            apr_int16_t event;
+            apr_status_t ret = apr_poll(pollset, &srv, -1);
             
             if (call_samaritans(chk))
                 this_worker_should_exit = 1;
@@ -411,7 +411,7 @@ static int32 worker_thread(void * dummy)
                 /* poll() will only return errors in catastrophic
                  * circumstances. Let's try exiting gracefully, for now. */
                 ap_log_error(APLOG_MARK, APLOG_ERR, ret, (const server_rec *)
-                             ap_server_conf, "ap_poll: (listen)");
+                             ap_server_conf, "apr_poll: (listen)");
                 this_worker_should_exit = 1;
             }
 
@@ -430,7 +430,7 @@ static int32 worker_thread(void * dummy)
                         curr_pollfd = 1;
                     }
                     /* Get the revent... */
-                    ap_get_revents(&event, listening_sockets[curr_pollfd], pollset);
+                    apr_get_revents(&event, listening_sockets[curr_pollfd], pollset);
                     
                     if (event & APR_POLLIN) {
                         last_pollfd = curr_pollfd;
@@ -442,31 +442,31 @@ static int32 worker_thread(void * dummy)
         }
     got_fd:
         if (!this_worker_should_exit) {
-            ap_unlock(accept_mutex);
-            if ((rv = ap_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
+            apr_unlock(accept_mutex);
+            if ((rv = apr_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
-                  "ap_accept");
+                  "apr_accept");
             } else {
                 process_socket(ptrans, csd, child_slot);
                 requests_this_child--;
             }
         }
         else {
-            ap_unlock(accept_mutex);
+            apr_unlock(accept_mutex);
             break;
         }
-        ap_clear_pool(ptrans);
+        apr_clear_pool(ptrans);
     }
 
-    ap_destroy_pool(tpool);
-    ap_lock(worker_thread_count_mutex);
+    apr_destroy_pool(tpool);
+    apr_lock(worker_thread_count_mutex);
     worker_thread_count--;
     if (worker_thread_count == 0) {
         /* All the threads have exited, now finish the shutdown process
          * by signalling the sigwait thread */
         kill(server_pid, SIGTERM);
     }
-    ap_unlock(worker_thread_count_mutex);
+    apr_unlock(worker_thread_count_mutex);
 
     return (0);
 }
@@ -483,7 +483,7 @@ static int make_worker(server_rec *s, int slot, time_t now)
     }
     
     my_info->slot = slot;
-    ap_create_pool(&my_info->tpool, pchild);
+    apr_create_pool(&my_info->tpool, pchild);
     
     if (slot + 1 > ap_max_child_assigned)
 	    ap_max_child_assigned = slot + 1;
@@ -592,7 +592,7 @@ static void server_main_loop(int remaining_threads_to_start)
 {
     int child_slot;
     ap_wait_t status;
-    ap_proc_t pid;
+    apr_proc_t pid;
     int i;
 
     while (!restart_pending && !shutdown_pending) {
@@ -626,7 +626,7 @@ static void server_main_loop(int remaining_threads_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (ap_reap_other_child(&pid, status) == 0) {
+	    else if (apr_reap_other_child(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -664,10 +664,10 @@ static void server_main_loop(int remaining_threads_to_start)
     }
 }
 
-int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
+int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 {
     int remaining_threads_to_start, i;
-    ap_status_t rv;
+    apr_status_t rv;
     ap_listen_rec *lr;    
     pconf = _pconf;
     ap_server_conf = s;
@@ -694,7 +694,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
      * used to lock around select so we only have one thread
      * in select at a time
      */
-    if ((rv = ap_create_lock(&accept_mutex, APR_MUTEX, APR_CROSS_PROCESS,
+    if ((rv = apr_create_lock(&accept_mutex, APR_MUTEX, APR_CROSS_PROCESS,
         NULL, pconf)) != APR_SUCCESS) {
         /* tsch tsch, can't have more than one thread in the accept loop
            at a time so we need to fall on our sword... */
@@ -705,7 +705,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     /* worker_thread_count_mutex
      * locks the worker_thread_count so we have ana ccurate count...
      */
-    if ((rv = ap_create_lock(&worker_thread_count_mutex, APR_MUTEX, APR_CROSS_PROCESS,
+    if ((rv = apr_create_lock(&worker_thread_count_mutex, APR_MUTEX, APR_CROSS_PROCESS,
         NULL, pconf)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
                      "Couldn't create worker thread count lock");
@@ -741,13 +741,13 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     /* setup the child pool to use for the workers.  Each worker creates
      * a seperate pool of it's own to use.
      */
-    ap_create_pool(&pchild, pconf);
+    apr_create_pool(&pchild, pconf);
     ap_child_init_hook(pchild, ap_server_conf);
 
     /* Now that we have the child pool (pchild) we can allocate
      * the listenfds and creat the pollset...
      */
-    listening_sockets = ap_palloc(pchild,
+    listening_sockets = apr_palloc(pchild,
        sizeof(*listening_sockets) * (num_listening_sockets));
     for (lr = ap_listeners, i = 0; i < num_listening_sockets; lr = lr->next, ++i)
 	    listening_sockets[i]=lr->sd;
@@ -841,14 +841,14 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
 
     /* just before we go, tidy up the locks we've created to prevent a 
      * potential leak of semaphores... */
-    ap_destroy_lock(worker_thread_count_mutex);
-    ap_destroy_lock(accept_mutex);
+    apr_destroy_lock(worker_thread_count_mutex);
+    apr_destroy_lock(accept_mutex);
     delete_port(port_of_death);
     
     return 0;
 }
 
-static void beos_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp)
+static void beos_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     static int restart_num = 0;
     int no_detach = 0;
@@ -860,7 +860,7 @@ static void beos_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp)
     if (restart_num++ == 1) {
         is_graceful = 0;
         if (!one_process && !no_detach)
-	        ap_detach();
+	        apr_detach();
         server_pid = getpid();
     }
 
@@ -875,7 +875,7 @@ static void beos_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp)
     ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
     ap_beos_set_maintain_connection_status(1);
 
-    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
 }
 
 static void beos_hooks(void)
@@ -1035,7 +1035,7 @@ static const char *set_maintain_connection_status(cmd_parms *cmd,
 
 static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, const char *arg) 
 {
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     const char *fname;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1043,12 +1043,12 @@ static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, const char *arg
     }
 
     fname = ap_server_root_relative(cmd->pool, arg);
-    if ((ap_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
+    if ((apr_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
         (finfo.filetype != APR_DIR)) {
-	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
+	return apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
 			  " does not exist or is not a directory", NULL);
     }
-    ap_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
     return NULL;
 }
 
@@ -1085,7 +1085,7 @@ module MODULE_VAR_EXPORT mpm_beos_module = {
     NULL,			/* merge per-directory config structures */
     NULL,			/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    beos_cmds,		/* command ap_table_t */
+    beos_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     beos_hooks		/* register_hooks */
 };
diff --git a/server/mpm/beos/scoreboard.c b/server/mpm/beos/scoreboard.c
index 78e6c82..e4af0ed 100644
--- a/server/mpm/beos/scoreboard.c
+++ b/server/mpm/beos/scoreboard.c
@@ -68,10 +68,10 @@
 #include "beos.h"
 
 scoreboard *ap_scoreboard_image = NULL;
-extern ap_pool_t * pconf;
+extern apr_pool_t * pconf;
 static int maintain_connection_status = 1;
 
-void reinit_scoreboard(ap_pool_t *p)
+void reinit_scoreboard(apr_pool_t *p)
 {
     if (!ap_scoreboard_image)
         ap_scoreboard_image = (scoreboard *) malloc(SCOREBOARD_SIZE);
@@ -108,7 +108,7 @@ void ap_update_connection_status(long conn_id, const char *key,
             break;
         }
         if (0 == strcmp(ss->key, key)) {
-            ap_cpystrn(ss->value, value, VALUE_LENGTH);
+            apr_cpystrn(ss->value, value, VALUE_LENGTH);
             return;
         }
 	i++;
@@ -116,8 +116,8 @@ void ap_update_connection_status(long conn_id, const char *key,
     if (i >= STATUSES_PER_CONNECTION) {
         return;
     }
-    ap_cpystrn(ss->key, key, KEY_LENGTH);
-    ap_cpystrn(ss->value, value, VALUE_LENGTH);
+    apr_cpystrn(ss->key, key, KEY_LENGTH);
+    apr_cpystrn(ss->value, value, VALUE_LENGTH);
     return;
 }
 
@@ -161,62 +161,62 @@ const char *ap_get_connection_status(long conn_id, const char *key)
     return NULL;
 }
 
-ap_array_header_t *ap_get_connections(ap_pool_t *p)
+apr_array_header_t *ap_get_connections(apr_pool_t *p)
 {
     int i;
-    ap_array_header_t *connection_list;
+    apr_array_header_t *connection_list;
     long *array_slot;
 
-    connection_list = ap_make_array(p, 0, sizeof(long));
+    connection_list = apr_make_array(p, 0, sizeof(long));
     for (i = 0; i < ap_max_child_assigned; i++) {
 	if (ap_scoreboard_image->table[i][0].key[0] != '\0') {
-            array_slot = ap_push_array(connection_list);
+            array_slot = apr_push_array(connection_list);
             *array_slot = i;
         }
     }
     return connection_list;
 }
 
-ap_array_header_t *ap_get_connection_keys(ap_pool_t *p, long conn_id)
+apr_array_header_t *ap_get_connection_keys(apr_pool_t *p, long conn_id)
 {
     int i = 0;
     status_table_entry *ss;
-    ap_array_header_t *key_list;
+    apr_array_header_t *key_list;
     char **array_slot;
 
-    key_list = ap_make_array(p, 0, KEY_LENGTH * sizeof(char));
+    key_list = apr_make_array(p, 0, KEY_LENGTH * sizeof(char));
     while (i < STATUSES_PER_CONNECTION) {
         ss = &(ap_scoreboard_image->table[conn_id][i]);
         if (ss->key[0] == '\0') {
             break;
         }
-        array_slot = ap_push_array(key_list);
-        *array_slot = ap_pstrdup(p, ss->key);
+        array_slot = apr_push_array(key_list);
+        *array_slot = apr_pstrdup(p, ss->key);
         i++;
     }
     return key_list;
 }
 
-ap_array_header_t *ap_get_status_table(ap_pool_t *p)
+apr_array_header_t *ap_get_status_table(apr_pool_t *p)
 {
     int i, j;
-    ap_array_header_t *server_status;
+    apr_array_header_t *server_status;
     ap_status_table_row_t *array_slot;
     status_table_entry *ss;
 
-    server_status = ap_make_array(p, 0, sizeof(ap_status_table_row_t));
+    server_status = apr_make_array(p, 0, sizeof(ap_status_table_row_t));
 
     for (i = 0; i < ap_max_child_assigned; i++) {
 	if (ap_scoreboard_image->table[i][0].key[0] == '\0')
 	    continue;
-        array_slot = ap_push_array(server_status);
-        array_slot->data = ap_make_table(p, 0);
+        array_slot = apr_push_array(server_status);
+        array_slot->data = apr_make_table(p, 0);
         array_slot->conn_id = i;
         
         for (j = 0; j < STATUSES_PER_CONNECTION; j++) {
 	    ss = &(ap_scoreboard_image->table[i][j]);
             if (ss->key[0] != '\0') {
-                ap_table_add(array_slot->data, ss->key, ss->value);
+                apr_table_add(array_slot->data, ss->key, ss->value);
             }
             else {
                 break;
diff --git a/server/mpm/beos/scoreboard.h b/server/mpm/beos/scoreboard.h
index 8ca6d67..53d869d 100644
--- a/server/mpm/beos/scoreboard.h
+++ b/server/mpm/beos/scoreboard.h
@@ -67,11 +67,11 @@ extern "C" {
 #include "mpm_default.h"	/* For HARD_.*_LIMIT */
 
 API_EXPORT(int) ap_exists_scoreboard_image(void);
-void reinit_scoareboard(ap_pool_t *p);
+void reinit_scoareboard(apr_pool_t *p);
 void cleanup_scoreboard(void);
 void ap_beos_set_maintain_connection_status(int flag);
 void ap_beos_force_reset_connection_status(long conn_id);
-void reinit_scoreboard(ap_pool_t *p);
+void reinit_scoreboard(apr_pool_t *p);
 void update_scoreboard_global(void);
 API_EXPORT(int) find_child_by_pid(int pid);
 int ap_update_child_status(int child_num, int thread_num, int status, request_rec *r);
diff --git a/server/mpm/dexter/dexter.c b/server/mpm/dexter/dexter.c
index 6e4e368..2f45da9 100644
--- a/server/mpm/dexter/dexter.c
+++ b/server/mpm/dexter/dexter.c
@@ -72,7 +72,7 @@
 #include "unixd.h"
 #include "mpm_common.h"
 #include "ap_iol.h"
-#include "ap_listen.h"
+#include "apr_listen.h"
 #include "mpm_default.h"
 #include "mpm.h"
 #include "scoreboard.h"
@@ -105,7 +105,7 @@ static int num_daemons=0;
 static int workers_may_exit = 0;
 static int requests_this_child;
 static int num_listenfds = 0;
-static ap_socket_t **listenfds;
+static apr_socket_t **listenfds;
 
 struct ap_ctable ap_child_table[HARD_SERVER_LIMIT];
 
@@ -121,8 +121,8 @@ int ap_max_daemons_limit = -1;
 
 char ap_coredump_dir[MAX_STRING_LEN];
 
-static ap_file_t *pipe_of_death_in = NULL;
-static ap_file_t *pipe_of_death_out = NULL;
+static apr_file_t *pipe_of_death_in = NULL;
+static apr_file_t *pipe_of_death_out = NULL;
 static pthread_mutex_t pipe_of_death_mutex;
 
 /* *Non*-shared http_main globals... */
@@ -146,9 +146,9 @@ static int one_process = 0;
 int raise_sigstop_flags;
 #endif
 
-static ap_pool_t *pconf;		/* Pool for config stuff */
-static ap_pool_t *pchild;		/* Pool for httpd child stuff */
-static ap_pool_t *thread_pool_parent; /* Parent of per-thread pools */
+static apr_pool_t *pconf;		/* Pool for config stuff */
+static apr_pool_t *pchild;		/* Pool for httpd child stuff */
+static apr_pool_t *thread_pool_parent; /* Parent of per-thread pools */
 static pthread_mutex_t thread_pool_parent_mutex;
 
 static int child_num;
@@ -169,7 +169,7 @@ static pthread_mutex_t idle_thread_count_mutex;
 #define SAFE_ACCEPT(stmt) APR_SUCCESS
 #else
 #define SAFE_ACCEPT(stmt) (stmt)
-static ap_lock_t *process_accept_mutex;
+static apr_lock_t *process_accept_mutex;
 #endif /* NO_SERIALIZED_ACCEPT */
 static const char *lock_fname;
 static pthread_mutex_t thread_accept_mutex = PTHREAD_MUTEX_INITIALIZER;
@@ -183,7 +183,7 @@ API_EXPORT(int) ap_get_max_daemons(void)
 static void clean_child_exit(int code)
 {
     if (pchild) {
-	ap_destroy_pool(pchild);
+	apr_destroy_pool(pchild);
     }
     exit(code);
 }
@@ -192,7 +192,7 @@ static void clean_child_exit(int code)
 static void sig_coredump(int sig)
 {
     chdir(ap_coredump_dir);
-    ap_signal(sig, SIG_DFL);
+    apr_signal(sig, SIG_DFL);
     kill(getpid(), sig);
     /* At this point we've got sig blocked, because we're still inside
      * the signal handler.  When we leave the signal handler it will
@@ -259,7 +259,7 @@ static void ap_start_restart(int graceful)
     restart_pending = 1;
     is_graceful = graceful;
     if (is_graceful) {
-        ap_kill_cleanup(pconf, NULL, ap_cleanup_shared_mem);
+        apr_kill_cleanup(pconf, NULL, ap_cleanup_shared_mem);
     }
 }
 
@@ -345,36 +345,36 @@ static void set_signals(void)
 	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGWINCH)");
 #else
     if (!one_process) {
-	ap_signal(SIGSEGV, sig_coredump);
+	apr_signal(SIGSEGV, sig_coredump);
 #ifdef SIGBUS
-	ap_signal(SIGBUS, sig_coredump);
+	apr_signal(SIGBUS, sig_coredump);
 #endif /* SIGBUS */
 #ifdef SIGABORT
-	ap_signal(SIGABORT, sig_coredump);
+	apr_signal(SIGABORT, sig_coredump);
 #endif /* SIGABORT */
 #ifdef SIGABRT
-	ap_signal(SIGABRT, sig_coredump);
+	apr_signal(SIGABRT, sig_coredump);
 #endif /* SIGABRT */
 #ifdef SIGILL
-	ap_signal(SIGILL, sig_coredump);
+	apr_signal(SIGILL, sig_coredump);
 #endif /* SIGILL */
 #ifdef SIGXCPU
-	ap_signal(SIGXCPU, SIG_DFL);
+	apr_signal(SIGXCPU, SIG_DFL);
 #endif /* SIGXCPU */
 #ifdef SIGXFSZ
-	ap_signal(SIGXFSZ, SIG_DFL);
+	apr_signal(SIGXFSZ, SIG_DFL);
 #endif /* SIGXFSZ */
     }
 
-    ap_signal(SIGTERM, sig_term);
+    apr_signal(SIGTERM, sig_term);
 #ifdef SIGHUP
-    ap_signal(SIGHUP, restart);
+    apr_signal(SIGHUP, restart);
 #endif /* SIGHUP */
 #ifdef SIGWINCH
-    ap_signal(SIGWINCH, restart);
+    apr_signal(SIGWINCH, restart);
 #endif /* SIGWINCH */
 #ifdef SIGPIPE
-    ap_signal(SIGPIPE, SIG_IGN);
+    apr_signal(SIGPIPE, SIG_IGN);
 #endif /* SIGPIPE */
 
 #endif
@@ -394,16 +394,16 @@ int ap_graceful_stop_signalled(void)
  * Child process main loop.
  */
 
-static void process_socket(ap_pool_t *p, ap_socket_t *sock, long conn_id)
+static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
 {
     BUFF *conn_io;
     conn_rec *current_conn;
     ap_iol *iol;
     int csd;
-    ap_status_t rv;
+    apr_status_t rv;
 
-    if ((rv = ap_get_os_sock(&csd, sock)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "ap_get_os_sock");
+    if ((rv = apr_get_os_sock(&csd, sock)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_get_os_sock");
     }
 
     if (csd >= FD_SETSIZE) {
@@ -412,7 +412,7 @@ static void process_socket(ap_pool_t *p, ap_socket_t *sock, long conn_id)
                      "to rebuild Apache with a larger FD_SETSIZE "
                      "(currently %d)", 
                      csd, FD_SETSIZE);
-        ap_close_socket(sock);
+        apr_close_socket(sock);
         return;
     }
 
@@ -480,10 +480,10 @@ static void check_pipe_of_death(void)
     if (!workers_may_exit) {
         int ret;
         char pipe_read_char;
-        ap_ssize_t n = 1;
+        apr_ssize_t n = 1;
 
-        ret = ap_recv(listenfds[0], &pipe_read_char, &n);
-        if (ap_canonical_error(ret) == APR_EAGAIN) {
+        ret = apr_recv(listenfds[0], &pipe_read_char, &n);
+        if (apr_canonical_error(ret) == APR_EAGAIN) {
             /* It lost the lottery. It must continue to suffer
              * through a life of servitude. */
         }
@@ -500,27 +500,27 @@ static void check_pipe_of_death(void)
 
 static void *worker_thread(void *arg)
 {
-    ap_socket_t *csd = NULL;
-    ap_pool_t *tpool;		/* Pool for this thread           */
-    ap_pool_t *ptrans;		/* Pool for per-transaction stuff */
-    ap_socket_t *sd = NULL;
+    apr_socket_t *csd = NULL;
+    apr_pool_t *tpool;		/* Pool for this thread           */
+    apr_pool_t *ptrans;		/* Pool for per-transaction stuff */
+    apr_socket_t *sd = NULL;
     int srv;
     int curr_pollfd, last_pollfd = 0;
     int thread_just_started = 1;
     int thread_num = *((int *) arg);
     long conn_id = child_num * HARD_THREAD_LIMIT + thread_num;
-    ap_pollfd_t *pollset;
+    apr_pollfd_t *pollset;
     int n;
-    ap_status_t rv;
+    apr_status_t rv;
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    ap_create_pool(&tpool, thread_pool_parent);
+    apr_create_pool(&tpool, thread_pool_parent);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
-    ap_create_pool(&ptrans, tpool);
+    apr_create_pool(&ptrans, tpool);
 
-    ap_setup_poll(&pollset, num_listenfds+1, tpool);
+    apr_setup_poll(&pollset, num_listenfds+1, tpool);
     for(n=0 ; n <= num_listenfds ; ++n)
-        ap_add_poll_socket(pollset, listenfds[n], APR_POLLIN);
+        apr_add_poll_socket(pollset, listenfds[n], APR_POLLIN);
 
     while (!workers_may_exit) {
         workers_may_exit |= (max_requests_per_child != 0) && (requests_this_child <= 0);
@@ -544,32 +544,32 @@ static void *worker_thread(void *arg)
             pthread_mutex_unlock(&thread_accept_mutex);
             break;
         }
-        if ((rv = SAFE_ACCEPT(ap_lock(process_accept_mutex)))
+        if ((rv = SAFE_ACCEPT(apr_lock(process_accept_mutex)))
             != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                         "ap_lock failed. Attempting to shutdown "
+                         "apr_lock failed. Attempting to shutdown "
                          "process gracefully.");
             workers_may_exit = 1;
         }
 
         while (!workers_may_exit) {
-            ap_int16_t event;
-            srv = ap_poll(pollset, &n, -1);
+            apr_int16_t event;
+            srv = apr_poll(pollset, &n, -1);
 
             if (srv != APR_SUCCESS) {
-                if (ap_canonical_error(srv) == APR_EINTR) {
+                if (apr_canonical_error(srv) == APR_EINTR) {
                     continue;
                 }
 
-                /* ap_poll() will only return errors in catastrophic
+                /* apr_poll() will only return errors in catastrophic
                  * circumstances. Let's try exiting gracefully, for now. */
                 ap_log_error(APLOG_MARK, APLOG_ERR, srv, (const server_rec *)
-                             ap_server_conf, "ap_poll: (listen)");
+                             ap_server_conf, "apr_poll: (listen)");
                 workers_may_exit = 1;
             }
             if (workers_may_exit) break;
 
-            ap_get_revents(&event, listenfds[0], pollset);
+            apr_get_revents(&event, listenfds[0], pollset);
             if (event & APR_POLLIN) {
                 /* A process got a signal on the shutdown pipe. Check if we're
                  * the lucky process to die. */
@@ -590,7 +590,7 @@ static void *worker_thread(void *arg)
                         curr_pollfd = 1;
                     }
                     /* XXX: Should we check for POLLERR? */
-                    ap_get_revents(&event, listenfds[curr_pollfd], pollset);
+                    apr_get_revents(&event, listenfds[curr_pollfd], pollset);
                     if (event & APR_POLLIN) {
                         last_pollfd = curr_pollfd;
                         sd = listenfds[curr_pollfd];
@@ -601,14 +601,14 @@ static void *worker_thread(void *arg)
         }
     got_fd:
         if (!workers_may_exit) {
-            if ((rv = ap_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
+            if ((rv = apr_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
                 csd = NULL;
-                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, "ap_accept");
+                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, "apr_accept");
             }
-            if ((rv = SAFE_ACCEPT(ap_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "ap_unlock failed. Attempting to shutdown "
+                             "apr_unlock failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -628,10 +628,10 @@ static void *worker_thread(void *arg)
                 requests_this_child--;
             }
 	} else {
-            if ((rv = SAFE_ACCEPT(ap_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "ap_unlock failed. Attempting to shutdown "
+                             "apr_unlock failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -641,11 +641,11 @@ static void *worker_thread(void *arg)
             pthread_mutex_unlock(&idle_thread_count_mutex);
 	    break;
 	}
-        ap_clear_pool(ptrans);
+        apr_clear_pool(ptrans);
     }
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    ap_destroy_pool(tpool);
+    apr_destroy_pool(tpool);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
     pthread_mutex_lock(&worker_thread_count_mutex);
     worker_thread_count--;
@@ -666,15 +666,15 @@ static void child_main(int child_num_arg)
     int signal_received;
     int i;
     ap_listen_rec *lr;
-    ap_status_t rv;
+    apr_status_t rv;
 
     my_pid = getpid();
     child_num = child_num_arg;
-    ap_create_pool(&pchild, pconf);
+    apr_create_pool(&pchild, pconf);
 
     /*stuff to do before we switch id's, so we have permissions.*/
 
-    rv = SAFE_ACCEPT(ap_child_init_lock(&process_accept_mutex, lock_fname,
+    rv = SAFE_ACCEPT(apr_child_init_lock(&process_accept_mutex, lock_fname,
                                         pchild));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
@@ -710,9 +710,9 @@ static void child_main(int child_num_arg)
     requests_this_child = max_requests_per_child;
     
     /* Set up the pollfd array */
-    listenfds = ap_pcalloc(pchild, sizeof(*listenfds) * (num_listenfds + 1));
+    listenfds = apr_pcalloc(pchild, sizeof(*listenfds) * (num_listenfds + 1));
 #if APR_FILES_AS_SOCKETS
-    ap_socket_from_file(&listenfds[0], pipe_of_death_in);
+    apr_socket_from_file(&listenfds[0], pipe_of_death_in);
 #endif
     for (lr = ap_listeners, i = 1; i <= num_listenfds; lr = lr->next, ++i)
         listenfds[i]=lr->sd;
@@ -727,7 +727,7 @@ static void child_main(int child_num_arg)
     for (i = 0; i < max_threads; i++) {
         worker_thread_free_ids[i] = i;
     }
-    ap_create_pool(&thread_pool_parent, pchild);
+    apr_create_pool(&thread_pool_parent, pchild);
     pthread_mutex_init(&thread_pool_parent_mutex, NULL);
     pthread_mutex_init(&idle_thread_count_mutex, NULL);
     pthread_mutex_init(&worker_thread_count_mutex, NULL);
@@ -810,7 +810,7 @@ static int make_child(server_rec *s, int slot, time_t now)
         RAISE_SIGSTOP(MAKE_CHILD);
 
 	/* XXX - For an unthreaded server, a signal handler will be necessary
-        ap_signal(SIGTERM, just_die);
+        apr_signal(SIGTERM, just_die);
 	*/
         child_main(slot);
 
@@ -904,7 +904,7 @@ static void server_main_loop(int remaining_children_to_start)
 {
     int child_slot;
     ap_wait_t status;
-    ap_proc_t pid;
+    apr_proc_t pid;
     int i;
 
     while (!restart_pending && !shutdown_pending) {
@@ -939,7 +939,7 @@ static void server_main_loop(int remaining_children_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (ap_reap_other_child(&pid, status) == 0) {
+	    else if (apr_reap_other_child(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -978,26 +978,26 @@ static void server_main_loop(int remaining_children_to_start)
     }
 }
 
-int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
+int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 {
     int remaining_children_to_start;
     int i;
-    ap_status_t rv;
-    ap_ssize_t one = 1;
+    apr_status_t rv;
+    apr_ssize_t one = 1;
 
     pconf = _pconf;
     ap_server_conf = s;
-    if ((rv = ap_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
+    if ((rv = apr_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
         != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "ap_create_pipe (pipe_of_death)");
+                     "apr_create_pipe (pipe_of_death)");
         exit(1);
     }
-    if ((rv = ap_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
+    if ((rv = apr_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "ap_set_pipe_timeout (pipe_of_death)");
+                     "apr_set_pipe_timeout (pipe_of_death)");
         exit(1);
     }
     ap_server_conf = s;
@@ -1010,10 +1010,10 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     ap_log_pid(pconf, ap_pid_fname);
 
     /* Initialize cross-process accept lock */
-    lock_fname = ap_psprintf(_pconf, "%s.%u",
+    lock_fname = apr_psprintf(_pconf, "%s.%u",
                              ap_server_root_relative(_pconf, lock_fname),
                              my_pid);
-    rv = SAFE_ACCEPT(ap_create_lock(&process_accept_mutex, APR_MUTEX,
+    rv = SAFE_ACCEPT(apr_create_lock(&process_accept_mutex, APR_MUTEX,
                                     APR_CROSS_PROCESS, lock_fname, _pconf));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1089,7 +1089,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     }
 
     /* we've been told to restart */
-    ap_signal(SIGHUP, SIG_IGN);
+    apr_signal(SIGHUP, SIG_IGN);
 
     if (one_process) {
 	/* not worth thinking about */
@@ -1113,8 +1113,8 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
 	}
 	/* give the children the signal to die */
         for (i = 0; i < num_daemons;) {
-            if ((rv = ap_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
-                if (ap_canonical_error(rv) == APR_EINTR) continue;
+            if ((rv = apr_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
+                if (apr_canonical_error(rv) == APR_EINTR) continue;
                 ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
                              "write pipe_of_death");
             }
@@ -1137,7 +1137,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     return 0;
 }
 
-static void dexter_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
+static void dexter_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     static int restart_num = 0;
     int no_detach = 0;
@@ -1150,7 +1150,7 @@ static void dexter_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
 	is_graceful = 0;
 
 	if (!one_process && !no_detach) {
-	    ap_detach();
+	    apr_detach();
 	}
 
 	my_pid = getpid();
@@ -1169,7 +1169,7 @@ static void dexter_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
     max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
     ap_dexter_set_maintain_connection_status(1);
 
-    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
 }
 
 static void dexter_hooks(void)
@@ -1354,7 +1354,7 @@ static const char *set_maintain_connection_status(cmd_parms *cmd,
 
 static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, const char *arg) 
 {
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     const char *fname;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1362,12 +1362,12 @@ static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, const char *arg
     }
 
     fname = ap_server_root_relative(cmd->pool, arg);
-    if ((ap_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
+    if ((apr_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
         (finfo.filetype != APR_DIR)) {
-	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
+	return apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
 			  " does not exist or is not a directory", NULL);
     }
-    ap_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
     return NULL;
 }
 
@@ -1406,7 +1406,7 @@ module MODULE_VAR_EXPORT mpm_dexter_module = {
     NULL,			/* merge per-directory config structures */
     NULL,			/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    dexter_cmds,		/* command ap_table_t */
+    dexter_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     dexter_hooks 		/* register_hooks */
 };
diff --git a/server/mpm/dexter/scoreboard.c b/server/mpm/dexter/scoreboard.c
index 02e5dd8..8630ccf 100644
--- a/server/mpm/dexter/scoreboard.c
+++ b/server/mpm/dexter/scoreboard.c
@@ -86,40 +86,40 @@ static scoreboard *ap_scoreboard_image = NULL;
 #if APR_HAS_SHARED_MEMORY
 #include "apr_shmem.h"
 
-static ap_shmem_t *scoreboard_shm = NULL;
+static apr_shmem_t *scoreboard_shm = NULL;
 
-ap_status_t ap_cleanup_shared_mem(void *d)
+apr_status_t ap_cleanup_shared_mem(void *d)
 {
-    ap_shm_free(scoreboard_shm, ap_scoreboard_image);
+    apr_shm_free(scoreboard_shm, ap_scoreboard_image);
     ap_scoreboard_image = NULL;
-    ap_shm_destroy(scoreboard_shm);
+    apr_shm_destroy(scoreboard_shm);
     return APR_SUCCESS;
 }
 
-static void setup_shared_mem(ap_pool_t *p)
+static void setup_shared_mem(apr_pool_t *p)
 {
     char buf[512];
     const char *fname;
 
     fname = ap_server_root_relative(p, ap_scoreboard_fname);
-    if (ap_shm_init(&scoreboard_shm, SCOREBOARD_SIZE + 40, fname, p) != APR_SUCCESS) {
-        ap_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
+    if (apr_shm_init(&scoreboard_shm, SCOREBOARD_SIZE + 40, fname, p) != APR_SUCCESS) {
+        apr_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
                     ap_server_argv0);
         perror(buf);
         exit(APEXIT_INIT);
     }
-    ap_scoreboard_image = ap_shm_malloc(scoreboard_shm, SCOREBOARD_SIZE);
+    ap_scoreboard_image = apr_shm_malloc(scoreboard_shm, SCOREBOARD_SIZE);
     if (ap_scoreboard_image == NULL) {
-        ap_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
+        apr_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
                     ap_server_argv0);
         perror(buf);
-        ap_shm_destroy(scoreboard_shm);
+        apr_shm_destroy(scoreboard_shm);
         exit(APEXIT_INIT);
     }
-    ap_register_cleanup(p, NULL, ap_cleanup_shared_mem, ap_null_cleanup);
+    apr_register_cleanup(p, NULL, ap_cleanup_shared_mem, apr_null_cleanup);
 }
 
-void reinit_scoreboard(ap_pool_t *p)
+void reinit_scoreboard(apr_pool_t *p)
 {
     if (ap_scoreboard_image == NULL) {
         setup_shared_mem(p);
@@ -177,40 +177,40 @@ const char *ap_get_connection_status(long conn_id, const char *key)
     return NULL;
 }
 
-ap_array_header_t *ap_get_connections(ap_pool_t *p)
+apr_array_header_t *ap_get_connections(apr_pool_t *p)
 {
     int i;
-    ap_array_header_t *connection_list;
+    apr_array_header_t *connection_list;
     long *array_slot;
 
-    connection_list = ap_make_array(p, 0, sizeof(long));
+    connection_list = apr_make_array(p, 0, sizeof(long));
     /* We assume that there is a connection iff it has an entry in the status
      * table. Connections without any status sound problematic to me, so this
      * is probably for the best. - manoj */
     for (i = 0; i < ap_max_daemons_limit*HARD_THREAD_LIMIT; i++) {
 	if (ap_scoreboard_image->table[i][0].key[0] != '\0') {
-            array_slot = ap_push_array(connection_list);
+            array_slot = apr_push_array(connection_list);
             *array_slot = i;
         }
     }
     return connection_list;
 }
 
-ap_array_header_t *ap_get_connection_keys(ap_pool_t *p, long conn_id)
+apr_array_header_t *ap_get_connection_keys(apr_pool_t *p, long conn_id)
 {
     int i = 0;
     status_table_entry *ss;
-    ap_array_header_t *key_list;
+    apr_array_header_t *key_list;
     char **array_slot;
 
-    key_list = ap_make_array(p, 0, KEY_LENGTH * sizeof(char));
+    key_list = apr_make_array(p, 0, KEY_LENGTH * sizeof(char));
     while (i < STATUSES_PER_CONNECTION) {
         ss = &(ap_scoreboard_image->table[conn_id][i]);
         if (ss->key[0] == '\0') {
             break;
         }
-        array_slot = ap_push_array(key_list);
-        *array_slot = ap_pstrdup(p, ss->key);
+        array_slot = apr_push_array(key_list);
+        *array_slot = apr_pstrdup(p, ss->key);
         i++;
     }
     return key_list;
@@ -233,7 +233,7 @@ void ap_update_connection_status(long conn_id, const char *key,
             break;
         }
         if (0 == strcmp(ss->key, key)) {
-            ap_cpystrn(ss->value, value, VALUE_LENGTH);
+            apr_cpystrn(ss->value, value, VALUE_LENGTH);
             return;
         }
 	i++;
@@ -243,19 +243,19 @@ void ap_update_connection_status(long conn_id, const char *key,
         /* No room. Oh well, not much anyone can do about it. */
         return;
     }
-    ap_cpystrn(ss->key, key, KEY_LENGTH);
-    ap_cpystrn(ss->value, value, VALUE_LENGTH);
+    apr_cpystrn(ss->key, key, KEY_LENGTH);
+    apr_cpystrn(ss->value, value, VALUE_LENGTH);
     return;
 }
 
-ap_array_header_t *ap_get_status_table(ap_pool_t *p)
+apr_array_header_t *ap_get_status_table(apr_pool_t *p)
 {
     int i, j;
-    ap_array_header_t *server_status;
+    apr_array_header_t *server_status;
     ap_status_table_row_t *array_slot;
     status_table_entry *ss;
 
-    server_status = ap_make_array(p, 0, sizeof(ap_status_table_row_t));
+    server_status = apr_make_array(p, 0, sizeof(ap_status_table_row_t));
 
     /* Go ahead and return what's in the connection status table even if we
      * aren't maintaining it. We can at least look at what children from
@@ -264,14 +264,14 @@ ap_array_header_t *ap_get_status_table(ap_pool_t *p)
     for (i = 0; i < ap_max_daemons_limit*HARD_THREAD_LIMIT; i++) {
 	if (ap_scoreboard_image->table[i][0].key[0] == '\0')
 	    continue;
-        array_slot = ap_push_array(server_status);
-        array_slot->data = ap_make_table(p, 0);
+        array_slot = apr_push_array(server_status);
+        array_slot->data = apr_make_table(p, 0);
         array_slot->conn_id = i;
         
         for (j = 0; j < STATUSES_PER_CONNECTION; j++) {
 	    ss = &(ap_scoreboard_image->table[i][j]);
             if (ss->key[0] != '\0') {
-                ap_table_add(array_slot->data, ss->key, ss->value);
+                apr_table_add(array_slot->data, ss->key, ss->value);
             }
             else {
                 break;
diff --git a/server/mpm/dexter/scoreboard.h b/server/mpm/dexter/scoreboard.h
index 73a54f1..7106f35 100644
--- a/server/mpm/dexter/scoreboard.h
+++ b/server/mpm/dexter/scoreboard.h
@@ -72,9 +72,9 @@ extern "C" {
 #include "mpm_default.h"	/* For HARD_.*_LIMIT */
 
 /* The generic shared memory chunk code */
-void reinit_scoreboard(ap_pool_t *p);
+void reinit_scoreboard(apr_pool_t *p);
 
-API_EXPORT(void) reopen_scoreboard(ap_pool_t *p);
+API_EXPORT(void) reopen_scoreboard(apr_pool_t *p);
 
 /* The stuff for Dexter's status table */
 
@@ -100,7 +100,7 @@ typedef struct {
 
 API_VAR_EXPORT extern const char *ap_scoreboard_fname;
 
-ap_status_t ap_cleanup_shared_mem(void *d);
+apr_status_t ap_cleanup_shared_mem(void *d);
 
 #ifdef __cplusplus
 }
diff --git a/server/mpm/experimental/perchild/perchild.c b/server/mpm/experimental/perchild/perchild.c
index 32c1a4d..5e8d3ae 100644
--- a/server/mpm/experimental/perchild/perchild.c
+++ b/server/mpm/experimental/perchild/perchild.c
@@ -74,7 +74,7 @@
 #include "unixd.h"
 #include "mpm_common.h"
 #include "ap_iol.h"
-#include "ap_listen.h"
+#include "apr_listen.h"
 #include "mpm_default.h"
 #include "mpm.h"
 #include "scoreboard.h"
@@ -113,7 +113,7 @@ static int socket_num=0;
 static int workers_may_exit = 0;
 static int requests_this_child;
 static int num_listenfds = 0;
-static ap_socket_t **listenfds;
+static apr_socket_t **listenfds;
 
 struct child_info_t {
     uid_t uid;
@@ -140,7 +140,7 @@ typedef struct socket_info_t socket_info_t;
  * process.
  */
 static child_info_t child_info_table[HARD_SERVER_LIMIT];
-static ap_hash_t    *socket_info_table = NULL;
+static apr_hash_t    *socket_info_table = NULL;
 
 
 struct ap_ctable    ap_child_table[HARD_SERVER_LIMIT];
@@ -159,8 +159,8 @@ char ap_coredump_dir[MAX_STRING_LEN];
 
 module MODULE_VAR_EXPORT mpm_perchild_module;
 
-static ap_file_t *pipe_of_death_in = NULL;
-static ap_file_t *pipe_of_death_out = NULL;
+static apr_file_t *pipe_of_death_in = NULL;
+static apr_file_t *pipe_of_death_out = NULL;
 static pthread_mutex_t pipe_of_death_mutex;
 
 /* *Non*-shared http_main globals... */
@@ -184,9 +184,9 @@ static int one_process = 0;
 int raise_sigstop_flags;
 #endif
 
-static ap_pool_t *pconf;		/* Pool for config stuff */
-static ap_pool_t *pchild;		/* Pool for httpd child stuff */
-static ap_pool_t *thread_pool_parent; /* Parent of per-thread pools */
+static apr_pool_t *pconf;		/* Pool for config stuff */
+static apr_pool_t *pchild;		/* Pool for httpd child stuff */
+static apr_pool_t *thread_pool_parent; /* Parent of per-thread pools */
 static pthread_mutex_t thread_pool_parent_mutex;
 
 static int child_num;
@@ -207,7 +207,7 @@ static pthread_mutex_t idle_thread_count_mutex;
 #define SAFE_ACCEPT(stmt) APR_SUCCESS
 #else
 #define SAFE_ACCEPT(stmt) (stmt)
-static ap_lock_t *process_accept_mutex;
+static apr_lock_t *process_accept_mutex;
 #endif /* NO_SERIALIZED_ACCEPT */
 static const char *lock_fname;
 static pthread_mutex_t thread_accept_mutex = PTHREAD_MUTEX_INITIALIZER;
@@ -221,7 +221,7 @@ API_EXPORT(int) ap_get_max_daemons(void)
 static void clean_child_exit(int code)
 {
     if (pchild) {
-	ap_destroy_pool(pchild);
+	apr_destroy_pool(pchild);
     }
     exit(code);
 }
@@ -230,7 +230,7 @@ static void clean_child_exit(int code)
 static void sig_coredump(int sig)
 {
     chdir(ap_coredump_dir);
-    ap_signal(sig, SIG_DFL);
+    apr_signal(sig, SIG_DFL);
     kill(getpid(), sig);
     /* At this point we've got sig blocked, because we're still inside
      * the signal handler.  When we leave the signal handler it will
@@ -297,7 +297,7 @@ static void ap_start_restart(int graceful)
     restart_pending = 1;
     is_graceful = graceful;
     if (is_graceful) {
-        ap_kill_cleanup(pconf, NULL, ap_cleanup_shared_mem);
+        apr_kill_cleanup(pconf, NULL, ap_cleanup_shared_mem);
     }
 }
 
@@ -383,36 +383,36 @@ static void set_signals(void)
 	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGWINCH)");
 #else
     if (!one_process) {
-	ap_signal(SIGSEGV, sig_coredump);
+	apr_signal(SIGSEGV, sig_coredump);
 #ifdef SIGBUS
-	ap_signal(SIGBUS, sig_coredump);
+	apr_signal(SIGBUS, sig_coredump);
 #endif /* SIGBUS */
 #ifdef SIGABORT
-	ap_signal(SIGABORT, sig_coredump);
+	apr_signal(SIGABORT, sig_coredump);
 #endif /* SIGABORT */
 #ifdef SIGABRT
-	ap_signal(SIGABRT, sig_coredump);
+	apr_signal(SIGABRT, sig_coredump);
 #endif /* SIGABRT */
 #ifdef SIGILL
-	ap_signal(SIGILL, sig_coredump);
+	apr_signal(SIGILL, sig_coredump);
 #endif /* SIGILL */
 #ifdef SIGXCPU
-	ap_signal(SIGXCPU, SIG_DFL);
+	apr_signal(SIGXCPU, SIG_DFL);
 #endif /* SIGXCPU */
 #ifdef SIGXFSZ
-	ap_signal(SIGXFSZ, SIG_DFL);
+	apr_signal(SIGXFSZ, SIG_DFL);
 #endif /* SIGXFSZ */
     }
 
-    ap_signal(SIGTERM, sig_term);
+    apr_signal(SIGTERM, sig_term);
 #ifdef SIGHUP
-    ap_signal(SIGHUP, restart);
+    apr_signal(SIGHUP, restart);
 #endif /* SIGHUP */
 #ifdef SIGWINCH
-    ap_signal(SIGWINCH, restart);
+    apr_signal(SIGWINCH, restart);
 #endif /* SIGWINCH */
 #ifdef SIGPIPE
-    ap_signal(SIGPIPE, SIG_IGN);
+    apr_signal(SIGPIPE, SIG_IGN);
 #endif /* SIGPIPE */
 
 #endif
@@ -432,16 +432,16 @@ int ap_graceful_stop_signalled(void)
  * Child process main loop.
  */
 
-static void process_socket(ap_pool_t *p, ap_socket_t *sock, long conn_id)
+static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
 {
     BUFF *conn_io;
     conn_rec *current_conn;
     ap_iol *iol;
     int csd;
-    ap_status_t rv;
+    apr_status_t rv;
 
-    if ((rv = ap_get_os_sock(&csd, sock)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "ap_get_os_sock");
+    if ((rv = apr_get_os_sock(&csd, sock)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_get_os_sock");
     }
 
     if (csd >= FD_SETSIZE) {
@@ -450,7 +450,7 @@ static void process_socket(ap_pool_t *p, ap_socket_t *sock, long conn_id)
                      "to rebuild Apache with a larger FD_SETSIZE "
                      "(currently %d)", 
                      csd, FD_SETSIZE);
-        ap_close_socket(sock);
+        apr_close_socket(sock);
         return;
     }
 
@@ -518,10 +518,10 @@ static void check_pipe_of_death(void)
     if (!workers_may_exit) {
         int ret;
         char pipe_read_char;
-        ap_ssize_t n = 1;
+        apr_ssize_t n = 1;
 
-        ret = ap_recv(listenfds[0], &pipe_read_char, &n);
-        if (ap_canonical_error(ret) == APR_EAGAIN) {
+        ret = apr_recv(listenfds[0], &pipe_read_char, &n);
+        if (apr_canonical_error(ret) == APR_EAGAIN) {
             /* It lost the lottery. It must continue to suffer
              * through a life of servitude. */
         }
@@ -538,27 +538,27 @@ static void check_pipe_of_death(void)
 
 static void *worker_thread(void *arg)
 {
-    ap_socket_t *csd = NULL;
-    ap_pool_t *tpool;		/* Pool for this thread           */
-    ap_pool_t *ptrans;		/* Pool for per-transaction stuff */
-    ap_socket_t *sd = NULL;
+    apr_socket_t *csd = NULL;
+    apr_pool_t *tpool;		/* Pool for this thread           */
+    apr_pool_t *ptrans;		/* Pool for per-transaction stuff */
+    apr_socket_t *sd = NULL;
     int srv;
     int curr_pollfd, last_pollfd = 0;
     int thread_just_started = 1;
     int thread_num = *((int *) arg);
     long conn_id = child_num * HARD_THREAD_LIMIT + thread_num;
-    ap_pollfd_t *pollset;
+    apr_pollfd_t *pollset;
     int n;
-    ap_status_t rv;
+    apr_status_t rv;
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    ap_create_pool(&tpool, thread_pool_parent);
+    apr_create_pool(&tpool, thread_pool_parent);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
-    ap_create_pool(&ptrans, tpool);
+    apr_create_pool(&ptrans, tpool);
 
-    ap_setup_poll(&pollset, num_listenfds+1, tpool);
+    apr_setup_poll(&pollset, num_listenfds+1, tpool);
     for(n=0 ; n <= num_listenfds ; ++n) {
-        ap_add_poll_socket(pollset, listenfds[n], APR_POLLIN);
+        apr_add_poll_socket(pollset, listenfds[n], APR_POLLIN);
     }
 
     while (!workers_may_exit) {
@@ -583,32 +583,32 @@ static void *worker_thread(void *arg)
             pthread_mutex_unlock(&thread_accept_mutex);
             break;
         }
-        if ((rv = SAFE_ACCEPT(ap_lock(process_accept_mutex)))
+        if ((rv = SAFE_ACCEPT(apr_lock(process_accept_mutex)))
             != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                         "ap_lock failed. Attempting to shutdown "
+                         "apr_lock failed. Attempting to shutdown "
                          "process gracefully.");
             workers_may_exit = 1;
         }
 
         while (!workers_may_exit) {
-            ap_int16_t event;
-            srv = ap_poll(pollset, &n, -1);
+            apr_int16_t event;
+            srv = apr_poll(pollset, &n, -1);
 
             if (srv != APR_SUCCESS) {
-                if (ap_canonical_error(srv) == APR_EINTR) {
+                if (apr_canonical_error(srv) == APR_EINTR) {
                     continue;
                 }
 
-                /* ap_poll() will only return errors in catastrophic
+                /* apr_poll() will only return errors in catastrophic
                  * circumstances. Let's try exiting gracefully, for now. */
                 ap_log_error(APLOG_MARK, APLOG_ERR, srv, (const server_rec *)
-                             ap_server_conf, "ap_poll: (listen)");
+                             ap_server_conf, "apr_poll: (listen)");
                 workers_may_exit = 1;
             }
             if (workers_may_exit) break;
 
-            ap_get_revents(&event, listenfds[0], pollset);
+            apr_get_revents(&event, listenfds[0], pollset);
             if (event & APR_POLLIN) {
                 /* A process got a signal on the shutdown pipe. Check if we're
                  * the lucky process to die. */
@@ -629,7 +629,7 @@ static void *worker_thread(void *arg)
                         curr_pollfd = 1;
                     }
                     /* XXX: Should we check for POLLERR? */
-                    ap_get_revents(&event, listenfds[curr_pollfd], pollset);
+                    apr_get_revents(&event, listenfds[curr_pollfd], pollset);
                     if (event & APR_POLLIN) {
                         last_pollfd = curr_pollfd;
                         sd = listenfds[curr_pollfd];
@@ -640,13 +640,13 @@ static void *worker_thread(void *arg)
         }
     got_fd:
         if (!workers_may_exit) {
-            if ((rv = ap_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, "ap_accept");
+            if ((rv = apr_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
+                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, "apr_accept");
             }
-            if ((rv = SAFE_ACCEPT(ap_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "ap_unlock failed. Attempting to shutdown "
+                             "apr_unlock failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -664,10 +664,10 @@ static void *worker_thread(void *arg)
             process_socket(ptrans, csd, conn_id);
             requests_this_child--;
 	} else {
-            if ((rv = SAFE_ACCEPT(ap_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "ap_unlock failed. Attempting to shutdown "
+                             "apr_unlock failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -677,11 +677,11 @@ static void *worker_thread(void *arg)
             pthread_mutex_unlock(&idle_thread_count_mutex);
 	    break;
 	}
-        ap_clear_pool(ptrans);
+        apr_clear_pool(ptrans);
     }
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    ap_destroy_pool(tpool);
+    apr_destroy_pool(tpool);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
     pthread_mutex_lock(&worker_thread_count_mutex);
     worker_thread_count--;
@@ -770,7 +770,7 @@ static int perchild_setup_child(int childnum)
     return 0;
 }
 
-static int create_child_socket(int child_num, ap_pool_t *p)
+static int create_child_socket(int child_num, apr_pool_t *p)
 {
     struct sockaddr_un unix_addr;
     mode_t omask;
@@ -779,9 +779,9 @@ static int create_child_socket(int child_num, ap_pool_t *p)
     perchild_server_conf *sconf = (perchild_server_conf *)
               ap_get_module_config(ap_server_conf->module_config, &mpm_perchild_module);
     int len = strlen(sconf->sockname) + strlen(child_info_table[child_num].name) + 3;
-    char *socket_name = ap_palloc(p, len);
+    char *socket_name = apr_palloc(p, len);
 
-    ap_snprintf(socket_name, len, "%s.%s", sconf->sockname, child_info_table[child_num].name);
+    apr_snprintf(socket_name, len, "%s.%s", sconf->sockname, child_info_table[child_num].name);
     if (unlink(socket_name) < 0 &&
         errno != ENOENT) {
         ap_log_error(APLOG_MARK, APLOG_ERR, errno, ap_server_conf,
@@ -833,15 +833,15 @@ static void child_main(int child_num_arg)
     int signal_received;
     int i;
     ap_listen_rec *lr;
-    ap_status_t rv;
+    apr_status_t rv;
 
     my_pid = getpid();
     child_num = child_num_arg;
-    ap_create_pool(&pchild, pconf);
+    apr_create_pool(&pchild, pconf);
 
     /*stuff to do before we switch id's, so we have permissions.*/
 
-    rv = SAFE_ACCEPT(ap_child_init_lock(&process_accept_mutex, lock_fname,
+    rv = SAFE_ACCEPT(apr_child_init_lock(&process_accept_mutex, lock_fname,
                                         pchild));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
@@ -879,13 +879,13 @@ static void child_main(int child_num_arg)
     /* Set up the pollfd array, num_listenfds + 1 for the pipe and 1 for
      * the child socket.
      */
-    listenfds = ap_pcalloc(pchild, sizeof(*listenfds) * (num_listenfds + 2));
+    listenfds = apr_pcalloc(pchild, sizeof(*listenfds) * (num_listenfds + 2));
 #if APR_FILES_AS_SOCKETS
-    ap_socket_from_file(&listenfds[0], pipe_of_death_in);
+    apr_socket_from_file(&listenfds[0], pipe_of_death_in);
 #endif
 
     /* The child socket */
-    ap_put_os_sock(&listenfds[1], &child_info_table[child_num].sd, pchild);
+    apr_put_os_sock(&listenfds[1], &child_info_table[child_num].sd, pchild);
 
     num_listenfds++;
     for (lr = ap_listeners, i = 2; i <= num_listenfds; lr = lr->next, ++i)
@@ -901,7 +901,7 @@ static void child_main(int child_num_arg)
     for (i = 0; i < max_threads; i++) {
         worker_thread_free_ids[i] = i;
     }
-    ap_create_pool(&thread_pool_parent, pchild);
+    apr_create_pool(&thread_pool_parent, pchild);
     pthread_mutex_init(&thread_pool_parent_mutex, NULL);
     pthread_mutex_init(&idle_thread_count_mutex, NULL);
     pthread_mutex_init(&worker_thread_count_mutex, NULL);
@@ -984,7 +984,7 @@ static int make_child(server_rec *s, int slot, time_t now)
         RAISE_SIGSTOP(MAKE_CHILD);
 
 	/* XXX - For an unthreaded server, a signal handler will be necessary
-        ap_signal(SIGTERM, just_die);
+        apr_signal(SIGTERM, just_die);
 	*/
         child_main(slot);
 
@@ -1078,7 +1078,7 @@ static void server_main_loop(int remaining_children_to_start)
 {
     int child_slot;
     ap_wait_t status;
-    ap_proc_t pid;
+    apr_proc_t pid;
     int i;
 
     while (!restart_pending && !shutdown_pending) {
@@ -1113,7 +1113,7 @@ static void server_main_loop(int remaining_children_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (ap_reap_other_child(&pid, status) == 0) {
+	    else if (apr_reap_other_child(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -1152,26 +1152,26 @@ static void server_main_loop(int remaining_children_to_start)
     }
 }
 
-int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
+int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 {
     int remaining_children_to_start;
     int i;
-    ap_status_t rv;
-    ap_ssize_t one = 1;
+    apr_status_t rv;
+    apr_ssize_t one = 1;
 
     pconf = _pconf;
     ap_server_conf = s;
-    if ((rv = ap_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
+    if ((rv = apr_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
         != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "ap_create_pipe (pipe_of_death)");
+                     "apr_create_pipe (pipe_of_death)");
         exit(1);
     }
-    if ((rv = ap_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
+    if ((rv = apr_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "ap_set_pipe_timeout (pipe_of_death)");
+                     "apr_set_pipe_timeout (pipe_of_death)");
         exit(1);
     }
     ap_server_conf = s;
@@ -1205,10 +1205,10 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     } 
 
     /* Initialize cross-process accept lock */
-    lock_fname = ap_psprintf(_pconf, "%s.%u",
+    lock_fname = apr_psprintf(_pconf, "%s.%u",
                              ap_server_root_relative(_pconf, lock_fname),
                              my_pid);
-    rv = SAFE_ACCEPT(ap_create_lock(&process_accept_mutex, APR_MUTEX,
+    rv = SAFE_ACCEPT(apr_create_lock(&process_accept_mutex, APR_MUTEX,
                                     APR_CROSS_PROCESS, lock_fname, _pconf));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1284,7 +1284,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     }
 
     /* we've been told to restart */
-    ap_signal(SIGHUP, SIG_IGN);
+    apr_signal(SIGHUP, SIG_IGN);
 
     if (one_process) {
 	/* not worth thinking about */
@@ -1308,8 +1308,8 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
 	}
 	/* give the children the signal to die */
         for (i = 0; i < num_daemons;) {
-            if ((rv = ap_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
-                if (ap_canonical_error(rv) == APR_EINTR) continue;
+            if ((rv = apr_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
+                if (apr_canonical_error(rv) == APR_EINTR) continue;
                 ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
                              "write pipe_of_death");
             }
@@ -1332,7 +1332,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     return 0;
 }
 
-static void perchild_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
+static void perchild_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     static int restart_num = 0;
     int no_detach = 0;
@@ -1346,7 +1346,7 @@ static void perchild_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
 	is_graceful = 0;
 
 	if (!one_process && !no_detach) {
-	    ap_detach();
+	    apr_detach();
 	}
 
 	my_pid = getpid();
@@ -1367,7 +1367,7 @@ static void perchild_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
     curr_child_num = 0;
     socket_num = 0;
 
-    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
 
     for (i = 0; i < HARD_SERVER_LIMIT; i++) {
         child_info_table[i].uid = -1;
@@ -1377,13 +1377,13 @@ static void perchild_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
     }
 }
 
-static void perchild_post_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *s)
+static void perchild_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
 {
     int i;
 
     for (i = 0; i < num_daemons; i++) {
         if (child_info_table[i].name == NULL) {
-            child_info_table[i].name = ap_pstrdup(p, "DEFAULT");
+            child_info_table[i].name = apr_pstrdup(p, "DEFAULT");
             child_info_table[i].num = socket_num;
         }
     }
@@ -1391,13 +1391,13 @@ static void perchild_post_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp
 
 static int perchild_post_read(request_rec *r)
 {
-    const char *hostname = ap_table_get(r->headers_in, "Host");
+    const char *hostname = apr_table_get(r->headers_in, "Host");
     char *process_num;
     int num;
 
 fprintf(stderr, "In perchild_post_read\n");
     fflush(stderr);
-    process_num = ap_hash_get(socket_info_table, hostname, 0);
+    process_num = apr_hash_get(socket_info_table, hostname, 0);
     if (process_num) {
         num = atoi(process_num);
     }
@@ -1603,7 +1603,7 @@ static const char *set_maintain_connection_status(cmd_parms *cmd,
 
 static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, const char *arg) 
 {
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     const char *fname;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1611,12 +1611,12 @@ static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, const char *arg
     }
 
     fname = ap_server_root_relative(cmd->pool, arg);
-    if ((ap_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
+    if ((apr_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
         (finfo.filetype != APR_DIR)) {
-	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
+	return apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
 			  " does not exist or is not a directory", NULL);
     }
-    ap_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
     return NULL;
 }
 
@@ -1635,7 +1635,7 @@ static const char *set_child_per_uid(cmd_parms *cmd, void *dummy, const char *u,
     
         ug->uid = atoi(u);
         ug->gid = atoi(g); 
-        ug->name = ap_pstrcat(cmd->pool, u, ":", g, NULL);
+        ug->name = apr_pstrcat(cmd->pool, u, ":", g, NULL);
         ug->num = socket_num;
     }
     socket_num++;
@@ -1652,7 +1652,7 @@ static const char *set_socket_name(cmd_parms *cmd, void *dummy, const char *arg)
     return NULL;
 }
     
-static ap_status_t cleanup_hash(void *dptr)
+static apr_status_t cleanup_hash(void *dptr)
 {
     socket_info_table = NULL;
     return APR_SUCCESS;
@@ -1661,12 +1661,12 @@ static ap_status_t cleanup_hash(void *dptr)
 static const char *assign_childuid(cmd_parms *cmd, void *dummy, const char *uid,
                                    const char *gid)
 {
-    char *socketname = ap_pstrcat(cmd->pool, uid, ":", gid, NULL);
+    char *socketname = apr_pstrcat(cmd->pool, uid, ":", gid, NULL);
     if (socket_info_table == NULL) {
-        socket_info_table = ap_make_hash(cmd->pool);
-        ap_register_cleanup(cmd->pool, socket_info_table, cleanup_hash, NULL);
+        socket_info_table = apr_make_hash(cmd->pool);
+        apr_register_cleanup(cmd->pool, socket_info_table, cleanup_hash, NULL);
     }
-    ap_hash_set(socket_info_table, cmd->server->server_hostname, 0, socketname);
+    apr_hash_set(socket_info_table, cmd->server->server_hostname, 0, socketname);
     return NULL;
 }
 
@@ -1707,10 +1707,10 @@ AP_INIT_TAKE1("ChildSockName", set_socket_name, NULL, RSRC_CONF,
 { NULL }
 };
 
-static void *perchild_create_config(ap_pool_t *p, server_rec *s)
+static void *perchild_create_config(apr_pool_t *p, server_rec *s)
 {
     perchild_server_conf *c =
-    (perchild_server_conf *) ap_pcalloc(p, sizeof(perchild_server_conf));
+    (perchild_server_conf *) apr_pcalloc(p, sizeof(perchild_server_conf));
 
     c->sockname = ap_server_root_relative(p, DEFAULT_PERCHILD_SOCKET);
     return c;
@@ -1723,7 +1723,7 @@ module MODULE_VAR_EXPORT mpm_perchild_module = {
     NULL,			/* merge per-directory config structures */
     perchild_create_config,	/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    perchild_cmds,		/* command ap_table_t */
+    perchild_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     perchild_hooks 		/* register_hooks */
 };
diff --git a/server/mpm/mpmt_beos/mpmt_beos.c b/server/mpm/mpmt_beos/mpmt_beos.c
index ba5514f..ff66f04 100644
--- a/server/mpm/mpmt_beos/mpmt_beos.c
+++ b/server/mpm/mpmt_beos/mpmt_beos.c
@@ -73,7 +73,7 @@
 #include "ap_mpm.h"
 #include "beosd.h"
 #include "ap_iol.h"
-#include "ap_listen.h"
+#include "apr_listen.h"
 #include "scoreboard.h" 
 #include "poll.h"
 #include "mpm_common.h"
@@ -98,24 +98,24 @@ static int workers_may_exit = 0;
 static int requests_this_child;
 static int num_listenfds = 0;
 static struct pollfd *listenfds;
-ap_lock_t *accept_mutex = NULL;
+apr_lock_t *accept_mutex = NULL;
 
-static ap_pool_t *pconf;		/* Pool for config stuff */
-static ap_pool_t *pchild;		/* Pool for httpd child stuff */
+static apr_pool_t *pconf;		/* Pool for config stuff */
+static apr_pool_t *pchild;		/* Pool for httpd child stuff */
 
 static int my_pid; /* Linux getpid() doesn't work except in main thread. Use
                       this instead */
 
 /* Keep track of the number of worker threads currently active */
 static int worker_thread_count;
-ap_lock_t *worker_thread_count_mutex;
+apr_lock_t *worker_thread_count_mutex;
 
 /* The structure used to pass unique initialization info to each thread */
 typedef struct {
     int pid;
     thread_id tid;
     int sd;
-    ap_pool_t *tpool; /* "pthread" would be confusing */
+    apr_pool_t *tpool; /* "pthread" would be confusing */
 } proc_info;
 
 struct ap_ctable ap_child_table[HARD_SERVER_LIMIT];
@@ -151,7 +151,7 @@ API_EXPORT(int) ap_get_max_daemons(void)
 void clean_child_exit(int code)
 {
     if (pchild) {
-	ap_destroy_pool(pchild);
+	apr_destroy_pool(pchild);
     }
     exit(code);
 }
@@ -294,7 +294,7 @@ int ap_graceful_stop_signalled(void)
  * Child process main loop.
  */
 
-static void process_socket(ap_pool_t *p, ap_socket_t *sock, int my_child_num, int my_thread_num)
+static void process_socket(apr_pool_t *p, apr_socket_t *sock, int my_child_num, int my_thread_num)
 {
     BUFF *conn_io;
     conn_rec *current_conn;
@@ -314,7 +314,7 @@ static void process_socket(ap_pool_t *p, ap_socket_t *sock, int my_child_num, in
             ap_log_error(APLOG_MARK, APLOG_WARNING, errno, NULL,
                 "error attaching to socket");
         }
-        ap_close_socket(sock);
+        apr_close_socket(sock);
 	return;
     }
 
@@ -333,10 +333,10 @@ static int32 worker_thread(void * dummy)
     proc_info * ti = dummy;
     int process_slot = ti->pid;
     int thread_slot = ti->tid;
-    ap_pool_t *tpool = ti->tpool;
-    ap_socket_t *csd = NULL;
-    ap_pool_t *ptrans;		/* Pool for per-transaction stuff */
-    ap_socket_t *sd = NULL;
+    apr_pool_t *tpool = ti->tpool;
+    apr_socket_t *csd = NULL;
+    apr_pool_t *ptrans;		/* Pool for per-transaction stuff */
+    apr_socket_t *sd = NULL;
     int srv;
     int curr_pollfd, last_pollfd = 0;
     sigset_t sig_mask;
@@ -347,11 +347,11 @@ static int32 worker_thread(void * dummy)
     sigfillset(&sig_mask);
     sigprocmask(SIG_BLOCK, &sig_mask, NULL);
 
-    ap_create_pool(&ptrans, tpool);
+    apr_create_pool(&ptrans, tpool);
 
-    ap_lock(worker_thread_count_mutex);
+    apr_lock(worker_thread_count_mutex);
     worker_thread_count++;
-    ap_unlock(worker_thread_count_mutex);
+    apr_unlock(worker_thread_count_mutex);
 
     /* TODO: Switch to a system where threads reuse the results from earlier
        poll calls - manoj */
@@ -359,7 +359,7 @@ static int32 worker_thread(void * dummy)
         workers_may_exit |= (ap_max_requests_per_child != 0) && (requests_this_child <= 0);
         if (workers_may_exit) break;
 
-        ap_lock(accept_mutex);
+        apr_lock(accept_mutex);
         while (!workers_may_exit) {
             srv = poll(listenfds, num_listenfds + 1, -1);
             if (srv < 0) {
@@ -391,7 +391,7 @@ static int32 worker_thread(void * dummy)
                     /* XXX: Should we check for POLLERR? */
                     if (listenfds[curr_pollfd].revents & POLLIN) {
                         last_pollfd = curr_pollfd;
-                        ap_put_os_sock(&sd, &listenfds[curr_pollfd].fd, tpool); 
+                        apr_put_os_sock(&sd, &listenfds[curr_pollfd].fd, tpool); 
                         goto got_fd;
                     }
                 } while (curr_pollfd != last_pollfd);
@@ -399,28 +399,28 @@ static int32 worker_thread(void * dummy)
         }
     got_fd:
         if (!workers_may_exit) {
-            ap_accept(&csd, sd, ptrans);
-            ap_unlock(accept_mutex);
+            apr_accept(&csd, sd, ptrans);
+            apr_unlock(accept_mutex);
             process_socket(ptrans, csd, process_slot,
                        thread_slot);
             requests_this_child--;
         }
         else {
-            ap_unlock(accept_mutex);
+            apr_unlock(accept_mutex);
             break;
         }
-        ap_clear_pool(ptrans);
+        apr_clear_pool(ptrans);
     }
 
-    ap_destroy_pool(tpool);
-    ap_lock(worker_thread_count_mutex);
+    apr_destroy_pool(tpool);
+    apr_lock(worker_thread_count_mutex);
     worker_thread_count--;
     if (worker_thread_count == 0) {
         /* All the threads have exited, now finish the shutdown process
          * by signalling the sigwait thread */
         kill(my_pid, SIGTERM);
     }
-    ap_unlock(worker_thread_count_mutex);
+    apr_unlock(worker_thread_count_mutex);
 
     return (0);
 }
@@ -437,10 +437,10 @@ static int32 child_main(void * data)
     struct sigaction sa;
     int32 msg;
     char buf;
-    ap_status_t rv;
+    apr_status_t rv;
         
     my_pid = getpid();
-    ap_create_pool(&pchild, pconf);
+    apr_create_pool(&pchild, pconf);
 
     if (beosd_setup_child()) {
 	clean_child_exit(APEXIT_CHILDFATAL);
@@ -457,9 +457,9 @@ static int32 child_main(void * data)
     requests_this_child = ap_max_requests_per_child;
     
     /* Set up the pollfd array */
-    listenfds = ap_palloc(pchild, sizeof(struct pollfd) * (num_listenfds));
+    listenfds = apr_palloc(pchild, sizeof(struct pollfd) * (num_listenfds));
     for (lr = ap_listeners, i = 0; i < num_listenfds; lr = lr->next, ++i) {
-        ap_get_os_sock(&listenfds[i].fd , lr->sd);
+        apr_get_os_sock(&listenfds[i].fd , lr->sd);
         listenfds[i].events = POLLIN; /* should we add POLLPRI ?*/
         listenfds[i].revents = 0;
     }
@@ -467,7 +467,7 @@ static int32 child_main(void * data)
     /* Setup worker threads */
 
     worker_thread_count = 0;
-    if ((rv = ap_create_lock(&worker_thread_count_mutex, APR_MUTEX, 
+    if ((rv = apr_create_lock(&worker_thread_count_mutex, APR_MUTEX, 
         APR_CROSS_PROCESS, NULL, pchild)) != APR_SUCCESS) {
         /* Oh dear, didn't manage to create a worker thread mutex, 
            so there's no point on going on with this child... */
@@ -484,7 +484,7 @@ static int32 child_main(void * data)
         my_info->pid = my_child_num;
         my_info->tid = i;
         my_info->sd = 0;
-        ap_create_pool(&my_info->tpool, pchild);
+        apr_create_pool(&my_info->tpool, pchild);
 
         /* We are creating threads right now */
         if ((thread = spawn_thread(worker_thread, "httpd_worker_thread",
@@ -625,7 +625,7 @@ static void server_main_loop(int remaining_children_to_start)
 {
     int child_slot;
     ap_wait_t status;
-    ap_proc_t pid;
+    apr_proc_t pid;
     int i;
 
     while (!restart_pending && !shutdown_pending) {
@@ -659,7 +659,7 @@ static void server_main_loop(int remaining_children_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (ap_reap_other_child(&pid, status) == 0) {
+	    else if (apr_reap_other_child(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -696,10 +696,10 @@ static void server_main_loop(int remaining_children_to_start)
     }
 }
 
-int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
+int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 {
     int remaining_children_to_start;
-    ap_status_t rv;
+    apr_status_t rv;
     
     pconf = _pconf;
     ap_server_conf = s;
@@ -714,7 +714,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     ap_log_pid(pconf, ap_pid_fname);
 
     /* create the accept_mutex */
-    if ((rv = ap_create_lock(&accept_mutex, APR_MUTEX, APR_CROSS_PROCESS,
+    if ((rv = apr_create_lock(&accept_mutex, APR_MUTEX, APR_CROSS_PROCESS,
         NULL, pconf)) != APR_SUCCESS) {
         /* tsch tsch, can't have more than one thread in the accept loop
            at a time so we need to fall on our sword... */
@@ -838,7 +838,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     return 0;
 }
 
-static void mpmt_beos_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp)
+static void mpmt_beos_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     static int restart_num = 0;
     int no_detach = 0;
@@ -868,7 +868,7 @@ static void mpmt_beos_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *p
     ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
     ap_mpmt_beos_set_maintain_connection_status(1);
 
-    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
 }
 
 static void mpmt_beos_hooks(void)
@@ -1030,7 +1030,7 @@ static const char *set_maintain_connection_status(cmd_parms *cmd,
 
 static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg) 
 {
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     const char *fname;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1038,12 +1038,12 @@ static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg)
     }
 
     fname = ap_server_root_relative(cmd->pool, arg);
-    if ((ap_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
+    if ((apr_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
         (finfo.filetype != APR_DIR)) {
-	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
+	return apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
 			  " does not exist or is not a directory", NULL);
     }
-    ap_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
     return NULL;
 }
 
@@ -1080,7 +1080,7 @@ module MODULE_VAR_EXPORT mpm_mpmt_beos_module = {
     NULL,			/* merge per-directory config structures */
     NULL,			/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    mpmt_beos_cmds,		/* command ap_table_t */
+    mpmt_beos_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     mpmt_beos_hooks		/* register_hooks */
 };
diff --git a/server/mpm/mpmt_beos/scoreboard.c b/server/mpm/mpmt_beos/scoreboard.c
index eaebe85..da7b6d2 100644
--- a/server/mpm/mpmt_beos/scoreboard.c
+++ b/server/mpm/mpmt_beos/scoreboard.c
@@ -68,11 +68,11 @@
 #include "mpm.h" /* includes scoreboard.h */
 
 scoreboard *ap_scoreboard_image = NULL;
-extern ap_pool_t * pconf;
+extern apr_pool_t * pconf;
 extern int ap_max_daemons_limit;
 static int maintain_connection_status = 1;
 
-void reinit_scoreboard(ap_pool_t *p)
+void reinit_scoreboard(apr_pool_t *p)
 {
     ap_assert(!ap_scoreboard_image);
     ap_scoreboard_image = (scoreboard *) malloc(SCOREBOARD_SIZE);
@@ -109,7 +109,7 @@ void ap_update_connection_status(long conn_id, const char *key,
             break;
         }
         if (0 == strcmp(ss->key, key)) {
-            ap_cpystrn(ss->value, value, VALUE_LENGTH);
+            apr_cpystrn(ss->value, value, VALUE_LENGTH);
             return;
         }
 	i++;
@@ -117,8 +117,8 @@ void ap_update_connection_status(long conn_id, const char *key,
     if (i >= STATUSES_PER_CONNECTION) {
         return;
     }
-    ap_cpystrn(ss->key, key, KEY_LENGTH);
-    ap_cpystrn(ss->value, value, VALUE_LENGTH);
+    apr_cpystrn(ss->key, key, KEY_LENGTH);
+    apr_cpystrn(ss->value, value, VALUE_LENGTH);
     return;
 }
 
@@ -162,62 +162,62 @@ const char *ap_get_connection_status(long conn_id, const char *key)
     return NULL;
 }
 
-ap_array_header_t *ap_get_connections(ap_pool_t *p)
+apr_array_header_t *ap_get_connections(apr_pool_t *p)
 {
     int i;
-    ap_array_header_t *connection_list;
+    apr_array_header_t *connection_list;
     long *array_slot;
 
-    connection_list = ap_make_array(p, 0, sizeof(long));
+    connection_list = apr_make_array(p, 0, sizeof(long));
     for (i = 0; i < ap_max_daemons_limit * HARD_THREAD_LIMIT; i++) {
 	if (ap_scoreboard_image->table[i][0].key[0] != '\0') {
-            array_slot = ap_push_array(connection_list);
+            array_slot = apr_push_array(connection_list);
             *array_slot = i;
         }
     }
     return connection_list;
 }
 
-ap_array_header_t *ap_get_connection_keys(ap_pool_t *p, long conn_id)
+apr_array_header_t *ap_get_connection_keys(apr_pool_t *p, long conn_id)
 {
     int i = 0;
     status_table_entry *ss;
-    ap_array_header_t *key_list;
+    apr_array_header_t *key_list;
     char **array_slot;
 
-    key_list = ap_make_array(p, 0, KEY_LENGTH * sizeof(char));
+    key_list = apr_make_array(p, 0, KEY_LENGTH * sizeof(char));
     while (i < STATUSES_PER_CONNECTION) {
         ss = &(ap_scoreboard_image->table[conn_id][i]);
         if (ss->key[0] == '\0') {
             break;
         }
-        array_slot = ap_push_array(key_list);
-        *array_slot = ap_pstrdup(p, ss->key);
+        array_slot = apr_push_array(key_list);
+        *array_slot = apr_pstrdup(p, ss->key);
         i++;
     }
     return key_list;
 }
 
-ap_array_header_t *ap_get_status_table(ap_pool_t *p)
+apr_array_header_t *ap_get_status_table(apr_pool_t *p)
 {
     int i, j;
-    ap_array_header_t *server_status;
+    apr_array_header_t *server_status;
     ap_status_table_row_t *array_slot;
     status_table_entry *ss;
 
-    server_status = ap_make_array(p, 0, sizeof(ap_status_table_row_t));
+    server_status = apr_make_array(p, 0, sizeof(ap_status_table_row_t));
 
     for (i = 0; i < ap_max_daemons_limit * HARD_THREAD_LIMIT; i++) {
 	if (ap_scoreboard_image->table[i][0].key[0] == '\0')
 	    continue;
-        array_slot = ap_push_array(server_status);
-        array_slot->data = ap_make_table(p, 0);
+        array_slot = apr_push_array(server_status);
+        array_slot->data = apr_make_table(p, 0);
         array_slot->conn_id = i;
         
         for (j = 0; j < STATUSES_PER_CONNECTION; j++) {
 	    ss = &(ap_scoreboard_image->table[i][j]);
             if (ss->key[0] != '\0') {
-                ap_table_add(array_slot->data, ss->key, ss->value);
+                apr_table_add(array_slot->data, ss->key, ss->value);
             }
             else {
                 break;
diff --git a/server/mpm/mpmt_beos/scoreboard.h b/server/mpm/mpmt_beos/scoreboard.h
index 116be56..cf1bbce 100644
--- a/server/mpm/mpmt_beos/scoreboard.h
+++ b/server/mpm/mpmt_beos/scoreboard.h
@@ -67,11 +67,11 @@ extern "C" {
 #include "mpm_default.h"	/* For HARD_.*_LIMIT */
 
 API_EXPORT(int) ap_exists_scoreboard_image(void);
-void reinit_scoareboard(ap_pool_t *p);
+void reinit_scoareboard(apr_pool_t *p);
 void cleanup_scoreboard(void);
 void ap_mpmt_beos_set_maintain_connection_status(int flag);
 void ap_mpmt_beos_force_reset_connection_status(long conn_id);
-void reinit_scoreboard(ap_pool_t *p);
+void reinit_scoreboard(apr_pool_t *p);
 void update_scoreboard_global(void);
 API_EXPORT(int) find_child_by_pid(int pid);
 int ap_update_child_status(int child_num, int thread_num, int status, request_rec *r);
diff --git a/server/mpm/mpmt_pthread/mpmt_pthread.c b/server/mpm/mpmt_pthread/mpmt_pthread.c
index c9e7dc3..761df42 100644
--- a/server/mpm/mpmt_pthread/mpmt_pthread.c
+++ b/server/mpm/mpmt_pthread/mpmt_pthread.c
@@ -105,14 +105,14 @@ API_VAR_EXPORT int ap_extended_status = 0;
 static int workers_may_exit = 0;
 static int requests_this_child;
 static int num_listensocks = 0;
-static ap_socket_t **listensocks;
+static apr_socket_t **listensocks;
 
 /* The structure used to pass unique initialization info to each thread */
 typedef struct {
     int pid;
     int tid;
     int sd;
-    ap_pool_t *tpool; /* "pthread" would be confusing */
+    apr_pool_t *tpool; /* "pthread" would be confusing */
 } proc_info;
 
 /*
@@ -124,8 +124,8 @@ int ap_max_daemons_limit = -1;
 
 char ap_coredump_dir[MAX_STRING_LEN];
 
-static ap_file_t *pipe_of_death_in = NULL;
-static ap_file_t *pipe_of_death_out = NULL;
+static apr_file_t *pipe_of_death_in = NULL;
+static apr_file_t *pipe_of_death_out = NULL;
 static pthread_mutex_t pipe_of_death_mutex;
 
 /* *Non*-shared http_main globals... */
@@ -149,8 +149,8 @@ static int one_process = 0;
 int raise_sigstop_flags;
 #endif
 
-static ap_pool_t *pconf;		/* Pool for config stuff */
-static ap_pool_t *pchild;		/* Pool for httpd child stuff */
+static apr_pool_t *pconf;		/* Pool for config stuff */
+static apr_pool_t *pchild;		/* Pool for httpd child stuff */
 
 unsigned int ap_my_pid; /* Linux getpid() doesn't work except in main 
                            thread. Use this instead */
@@ -160,7 +160,7 @@ static pthread_mutex_t worker_thread_count_mutex;
 
 /* Locks for accept serialization */
 static pthread_mutex_t thread_accept_mutex = PTHREAD_MUTEX_INITIALIZER;
-static ap_lock_t *process_accept_mutex;
+static apr_lock_t *process_accept_mutex;
 static const char *lock_fname;
 
 #ifdef NO_SERIALIZED_ACCEPT
@@ -179,7 +179,7 @@ static void clean_child_exit(int code) __attribute__ ((noreturn));
 void clean_child_exit(int code)
 {
     if (pchild) {
-	ap_destroy_pool(pchild);
+	apr_destroy_pool(pchild);
     }
     exit(code);
 }
@@ -188,7 +188,7 @@ void clean_child_exit(int code)
 static void sig_coredump(int sig)
 {
     chdir(ap_coredump_dir);
-    ap_signal(sig, SIG_DFL);
+    apr_signal(sig, SIG_DFL);
     kill(ap_my_pid, sig);
     /* At this point we've got sig blocked, because we're still inside
      * the signal handler.  When we leave the signal handler it will
@@ -256,7 +256,7 @@ static void ap_start_restart(int graceful)
     restart_pending = 1;
     is_graceful = graceful;
     if (is_graceful) {
-        ap_kill_cleanup(pconf, NULL, ap_cleanup_shared_mem);
+        apr_kill_cleanup(pconf, NULL, ap_cleanup_shared_mem);
     }
 }
 
@@ -342,36 +342,36 @@ static void set_signals(void)
 	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGWINCH)");
 #else
     if (!one_process) {
-	ap_signal(SIGSEGV, sig_coredump);
+	apr_signal(SIGSEGV, sig_coredump);
 #ifdef SIGBUS
-	ap_signal(SIGBUS, sig_coredump);
+	apr_signal(SIGBUS, sig_coredump);
 #endif /* SIGBUS */
 #ifdef SIGABORT
-	ap_signal(SIGABORT, sig_coredump);
+	apr_signal(SIGABORT, sig_coredump);
 #endif /* SIGABORT */
 #ifdef SIGABRT
-	ap_signal(SIGABRT, sig_coredump);
+	apr_signal(SIGABRT, sig_coredump);
 #endif /* SIGABRT */
 #ifdef SIGILL
-	ap_signal(SIGILL, sig_coredump);
+	apr_signal(SIGILL, sig_coredump);
 #endif /* SIGILL */
 #ifdef SIGXCPU
-	ap_signal(SIGXCPU, SIG_DFL);
+	apr_signal(SIGXCPU, SIG_DFL);
 #endif /* SIGXCPU */
 #ifdef SIGXFSZ
-	ap_signal(SIGXFSZ, SIG_DFL);
+	apr_signal(SIGXFSZ, SIG_DFL);
 #endif /* SIGXFSZ */
     }
 
-    ap_signal(SIGTERM, sig_term);
+    apr_signal(SIGTERM, sig_term);
 #ifdef SIGHUP
-    ap_signal(SIGHUP, restart);
+    apr_signal(SIGHUP, restart);
 #endif /* SIGHUP */
 #ifdef SIGWINCH
-    ap_signal(SIGWINCH, restart);
+    apr_signal(SIGWINCH, restart);
 #endif /* SIGWINCH */
 #ifdef SIGPIPE
-    ap_signal(SIGPIPE, SIG_IGN);
+    apr_signal(SIGPIPE, SIG_IGN);
 #endif /* SIGPIPE */
 
 #endif
@@ -391,7 +391,7 @@ int ap_graceful_stop_signalled(void)
  * Child process main loop.
  */
 
-static void process_socket(ap_pool_t *p, ap_socket_t *sock, int my_child_num, int my_thread_num)
+static void process_socket(apr_pool_t *p, apr_socket_t *sock, int my_child_num, int my_thread_num)
 {
     BUFF *conn_io;
     conn_rec *current_conn;
@@ -399,7 +399,7 @@ static void process_socket(ap_pool_t *p, ap_socket_t *sock, int my_child_num, in
     long conn_id = my_child_num * HARD_THREAD_LIMIT + my_thread_num;
     int csd;
 
-    (void) ap_get_os_sock(&csd, sock);
+    (void) apr_get_os_sock(&csd, sock);
 
     if (csd >= FD_SETSIZE) {
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
@@ -407,7 +407,7 @@ static void process_socket(ap_pool_t *p, ap_socket_t *sock, int my_child_num, in
                      "to rebuild Apache with a larger FD_SETSIZE "
                      "(currently %d)", 
                      csd, FD_SETSIZE);
-        ap_close_socket(sock);
+        apr_close_socket(sock);
         return;
     }
 
@@ -431,12 +431,12 @@ static void check_pipe_of_death(void)
 {
     pthread_mutex_lock(&pipe_of_death_mutex);
     if (!workers_may_exit) {
-        ap_status_t ret;
+        apr_status_t ret;
         char pipe_read_char;
-	ap_ssize_t n = 1;
+	apr_ssize_t n = 1;
 
-        ret = ap_recv(listensocks[0], &pipe_read_char, &n);
-        if (ap_canonical_error(ret) == APR_EAGAIN) {
+        ret = apr_recv(listensocks[0], &pipe_read_char, &n);
+        if (apr_canonical_error(ret) == APR_EAGAIN) {
             /* It lost the lottery. It must continue to suffer
              * through a life of servitude. */
         }
@@ -454,26 +454,26 @@ static void * worker_thread(void * dummy)
     proc_info * ti = dummy;
     int process_slot = ti->pid;
     int thread_slot = ti->tid;
-    ap_pool_t *tpool = ti->tpool;
-    ap_socket_t *csd = NULL;
-    ap_pool_t *ptrans;		/* Pool for per-transaction stuff */
-    ap_socket_t *sd = NULL;
+    apr_pool_t *tpool = ti->tpool;
+    apr_socket_t *csd = NULL;
+    apr_pool_t *ptrans;		/* Pool for per-transaction stuff */
+    apr_socket_t *sd = NULL;
     int n;
     int curr_pollfd, last_pollfd = 0;
-    ap_pollfd_t *pollset;
-    ap_status_t rv;
+    apr_pollfd_t *pollset;
+    apr_status_t rv;
 
     free(ti);
 
-    ap_create_pool(&ptrans, tpool);
+    apr_create_pool(&ptrans, tpool);
 
     pthread_mutex_lock(&worker_thread_count_mutex);
     worker_thread_count++;
     pthread_mutex_unlock(&worker_thread_count_mutex);
 
-    ap_setup_poll(&pollset, num_listensocks+1, tpool);
+    apr_setup_poll(&pollset, num_listensocks+1, tpool);
     for(n=0 ; n <= num_listensocks ; ++n)
-	ap_add_poll_socket(pollset, listensocks[n], APR_POLLIN);
+	apr_add_poll_socket(pollset, listensocks[n], APR_POLLIN);
 
     /* TODO: Switch to a system where threads reuse the results from earlier
        poll calls - manoj */
@@ -488,34 +488,34 @@ static void * worker_thread(void * dummy)
             pthread_mutex_unlock(&thread_accept_mutex);
             break;
         }
-        if ((rv = SAFE_ACCEPT(ap_lock(process_accept_mutex)))
+        if ((rv = SAFE_ACCEPT(apr_lock(process_accept_mutex)))
             != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                         "ap_lock failed. Attempting to shutdown "
+                         "apr_lock failed. Attempting to shutdown "
                          "process gracefully.");
             workers_may_exit = 1;
         }
 
         while (!workers_may_exit) {
-	    ap_status_t ret;
-	    ap_int16_t event;
+	    apr_status_t ret;
+	    apr_int16_t event;
 
-            ret = ap_poll(pollset, &n, -1);
+            ret = apr_poll(pollset, &n, -1);
             if (ret != APR_SUCCESS) {
-                if (ap_canonical_error(ret) == APR_EINTR) {
+                if (apr_canonical_error(ret) == APR_EINTR) {
                     continue;
                 }
 
-                /* ap_poll() will only return errors in catastrophic
+                /* apr_poll() will only return errors in catastrophic
                  * circumstances. Let's try exiting gracefully, for now. */
                 ap_log_error(APLOG_MARK, APLOG_ERR, ret, (const server_rec *)
-                             ap_server_conf, "ap_poll: (listen)");
+                             ap_server_conf, "apr_poll: (listen)");
                 workers_may_exit = 1;
             }
 
             if (workers_may_exit) break;
 
-	    ap_get_revents(&event, listensocks[0], pollset);
+	    apr_get_revents(&event, listensocks[0], pollset);
             if (event & APR_POLLIN) {
                 /* A process got a signal on the shutdown pipe. Check if we're
                  * the lucky process to die. */
@@ -536,7 +536,7 @@ static void * worker_thread(void * dummy)
                         curr_pollfd = 1;
                     }
                     /* XXX: Should we check for POLLERR? */
-		    ap_get_revents(&event, listensocks[curr_pollfd], pollset);
+		    apr_get_revents(&event, listensocks[curr_pollfd], pollset);
                     if (event & APR_POLLIN) {
                         last_pollfd = curr_pollfd;
 			sd=listensocks[curr_pollfd];
@@ -547,15 +547,15 @@ static void * worker_thread(void * dummy)
         }
     got_fd:
         if (!workers_may_exit) {
-            if ((rv = ap_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
+            if ((rv = apr_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
                 csd = NULL;
                 ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, 
-                             "ap_accept");
+                             "apr_accept");
             }
-            if ((rv = SAFE_ACCEPT(ap_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "ap_unlock failed. Attempting to shutdown "
+                             "apr_unlock failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -566,20 +566,20 @@ static void * worker_thread(void * dummy)
             }
         }
         else {
-            if ((rv = SAFE_ACCEPT(ap_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "ap_unlock failed. Attempting to shutdown "
+                             "apr_unlock failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
             pthread_mutex_unlock(&thread_accept_mutex);
             break;
         }
-        ap_clear_pool(ptrans);
+        apr_clear_pool(ptrans);
     }
 
-    ap_destroy_pool(tpool);
+    apr_destroy_pool(tpool);
     ap_update_child_status(process_slot, thread_slot, SERVER_DEAD,
         (request_rec *) NULL);
     pthread_mutex_lock(&worker_thread_count_mutex);
@@ -605,16 +605,16 @@ static void child_main(int child_num_arg)
     int my_child_num = child_num_arg;
     proc_info *my_info = NULL;
     ap_listen_rec *lr;
-    ap_status_t rv;
+    apr_status_t rv;
 
 
     ap_my_pid = getpid();
-    ap_create_pool(&pchild, pconf);
+    apr_create_pool(&pchild, pconf);
 
     /*stuff to do before we switch id's, so we have permissions.*/
     reopen_scoreboard(pchild);
 
-    rv = SAFE_ACCEPT(ap_child_init_lock(&process_accept_mutex, lock_fname,
+    rv = SAFE_ACCEPT(apr_child_init_lock(&process_accept_mutex, lock_fname,
                      pchild));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
@@ -649,10 +649,10 @@ static void child_main(int child_num_arg)
     requests_this_child = ap_max_requests_per_child;
     
     /* Set up the pollfd array */
-    listensocks = ap_pcalloc(pchild,
+    listensocks = apr_pcalloc(pchild,
 			    sizeof(*listensocks) * (num_listensocks + 1));
 #if APR_FILES_AS_SOCKETS
-    ap_socket_from_file(&listensocks[0], pipe_of_death_in);
+    apr_socket_from_file(&listensocks[0], pipe_of_death_in);
 #endif
     for (lr = ap_listeners, i = 1; i <= num_listensocks; lr = lr->next, ++i)
 	listensocks[i]=lr->sd;
@@ -683,7 +683,7 @@ static void child_main(int child_num_arg)
 	my_info->pid = my_child_num;
         my_info->tid = i;
 	my_info->sd = 0;
-	ap_create_pool(&my_info->tpool, pchild);
+	apr_create_pool(&my_info->tpool, pchild);
 	
 	/* We are creating threads right now */
 	(void) ap_update_child_status(my_child_num, i, SERVER_STARTING, 
@@ -780,7 +780,7 @@ static int make_child(server_rec *s, int slot, time_t now)
 
         RAISE_SIGSTOP(MAKE_CHILD);
 
-        ap_signal(SIGTERM, just_die);
+        apr_signal(SIGTERM, just_die);
         child_main(slot);
 
 	return 0;
@@ -829,8 +829,8 @@ static void perform_idle_server_maintenance(void)
     int free_slots[MAX_SPAWN_RATE];
     int last_non_dead;
     int total_non_dead;
-    ap_ssize_t one = 1;
-    ap_status_t rv;
+    apr_ssize_t one = 1;
+    apr_status_t rv;
 
     /* initialize the free_list */
     free_length = 0;
@@ -885,7 +885,7 @@ static void perform_idle_server_maintenance(void)
     if (idle_thread_count > max_spare_threads) {
         /* Kill off one child */
         char char_of_death = '!';
-        if ((rv = ap_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
+        if ((rv = apr_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, "write pipe_of_death");
         }
         idle_spawn_rate = 1;
@@ -938,7 +938,7 @@ static void server_main_loop(int remaining_children_to_start)
 {
     int child_slot;
     ap_wait_t status;
-    ap_proc_t pid;
+    apr_proc_t pid;
     int i;
 
     while (!restart_pending && !shutdown_pending) {
@@ -963,7 +963,7 @@ static void server_main_loop(int remaining_children_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (ap_reap_other_child(&pid, status) == 0) {
+	    else if (apr_reap_other_child(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -1001,26 +1001,26 @@ static void server_main_loop(int remaining_children_to_start)
     }
 }
 
-int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
+int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 {
     int remaining_children_to_start;
-    ap_status_t rv;
-    ap_ssize_t one = 1;
+    apr_status_t rv;
+    apr_ssize_t one = 1;
 
     pconf = _pconf;
     ap_server_conf = s;
-    rv = ap_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf);
+    rv = apr_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "ap_create_pipe (pipe_of_death)");
+                     "apr_create_pipe (pipe_of_death)");
         exit(1);
     }
 
-    if ((rv = ap_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
+    if ((rv = apr_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "ap_set_pipe_timeout (pipe_of_death)");
+                     "apr_set_pipe_timeout (pipe_of_death)");
         exit(1);
     }
     ap_server_conf = s;
@@ -1033,10 +1033,10 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     ap_log_pid(pconf, ap_pid_fname);
 
     /* Initialize cross-process accept lock */
-    lock_fname = ap_psprintf(_pconf, "%s.%u",
+    lock_fname = apr_psprintf(_pconf, "%s.%u",
                              ap_server_root_relative(_pconf, lock_fname),
                              ap_my_pid);
-    rv = ap_create_lock(&process_accept_mutex, APR_MUTEX, APR_CROSS_PROCESS,
+    rv = apr_create_lock(&process_accept_mutex, APR_MUTEX, APR_CROSS_PROCESS,
                    lock_fname, _pconf);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1112,7 +1112,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     }
 
     /* we've been told to restart */
-    ap_signal(SIGHUP, SIG_IGN);
+    apr_signal(SIGHUP, SIG_IGN);
 
     if (one_process) {
 	/* not worth thinking about */
@@ -1136,8 +1136,8 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
 
 	/* give the children the signal to die */
         for (i = 0; i < ap_daemons_limit;) {
-            if ((rv = ap_write(pipe_of_death_in, &char_of_death, &one)) != APR_SUCCESS) {
-                if (ap_canonical_error(rv) == APR_EINTR) continue;
+            if ((rv = apr_write(pipe_of_death_in, &char_of_death, &one)) != APR_SUCCESS) {
+                if (apr_canonical_error(rv) == APR_EINTR) continue;
                 ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf, "write pipe_of_death");
             }
             i++;
@@ -1173,7 +1173,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     return 0;
 }
 
-static void mpmt_pthread_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp)
+static void mpmt_pthread_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     static int restart_num = 0;
     int no_detach = 0;
@@ -1186,7 +1186,7 @@ static void mpmt_pthread_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t
 	is_graceful = 0;
 
 	if (!one_process && !no_detach) {
-	    ap_detach();
+	    apr_detach();
 	}
 	ap_my_pid = getpid();
     }
@@ -1204,7 +1204,7 @@ static void mpmt_pthread_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t
     ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
     ap_extended_status = 0;
 
-    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
 }
 
 static void mpmt_pthread_hooks(void)
@@ -1372,7 +1372,7 @@ static const char *set_max_requests(cmd_parms *cmd, void *dummy,
 static const char *set_coredumpdir (cmd_parms *cmd, void *dummy,
 				    const char *arg) 
 {
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     const char *fname;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1380,12 +1380,12 @@ static const char *set_coredumpdir (cmd_parms *cmd, void *dummy,
     }
 
     fname = ap_server_root_relative(cmd->pool, arg);
-    if ((ap_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
+    if ((apr_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
         (finfo.filetype != APR_DIR)) {
-	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
+	return apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
 			  " does not exist or is not a directory", NULL);
     }
-    ap_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
     return NULL;
 }
 
@@ -1422,7 +1422,7 @@ module MODULE_VAR_EXPORT mpm_mpmt_pthread_module = {
     NULL,			/* merge per-directory config structures */
     NULL,			/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    mpmt_pthread_cmds,		/* command ap_table_t */
+    mpmt_pthread_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     mpmt_pthread_hooks		/* register_hooks */
 };
diff --git a/server/mpm/mpmt_pthread/scoreboard.c b/server/mpm/mpmt_pthread/scoreboard.c
index 456dff2..22e3774 100644
--- a/server/mpm/mpmt_pthread/scoreboard.c
+++ b/server/mpm/mpmt_pthread/scoreboard.c
@@ -88,49 +88,49 @@ static int maintain_connection_status = 1;
 #if APR_HAS_SHARED_MEMORY
 #include "apr_shmem.h"
 
-static ap_shmem_t *scoreboard_shm = NULL;
+static apr_shmem_t *scoreboard_shm = NULL;
 
-ap_status_t ap_cleanup_shared_mem(void *d)
+apr_status_t ap_cleanup_shared_mem(void *d)
 {
-    ap_shm_free(scoreboard_shm, ap_scoreboard_image);
+    apr_shm_free(scoreboard_shm, ap_scoreboard_image);
     ap_scoreboard_image = NULL;
-    ap_shm_destroy(scoreboard_shm);
+    apr_shm_destroy(scoreboard_shm);
 
     return APR_SUCCESS;
 }
 
-static void setup_shared_mem(ap_pool_t *p)
+static void setup_shared_mem(apr_pool_t *p)
 {
     char buf[512];
     const char *fname;
 
     fname = ap_server_root_relative(p, ap_scoreboard_fname);
-    if (ap_shm_init(&scoreboard_shm, SCOREBOARD_SIZE + NEW_SCOREBOARD_SIZE + 40, fname, p) != APR_SUCCESS) {
-        ap_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
+    if (apr_shm_init(&scoreboard_shm, SCOREBOARD_SIZE + NEW_SCOREBOARD_SIZE + 40, fname, p) != APR_SUCCESS) {
+        apr_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
                     ap_server_argv0);
         perror(buf);
         exit(APEXIT_INIT);
     }
-    ap_scoreboard_image = ap_shm_malloc(scoreboard_shm, SCOREBOARD_SIZE);
-    ap_new_scoreboard_image = ap_shm_malloc(scoreboard_shm, NEW_SCOREBOARD_SIZE);
+    ap_scoreboard_image = apr_shm_malloc(scoreboard_shm, SCOREBOARD_SIZE);
+    ap_new_scoreboard_image = apr_shm_malloc(scoreboard_shm, NEW_SCOREBOARD_SIZE);
     if (ap_scoreboard_image == NULL || ap_new_scoreboard_image == NULL) {
-        ap_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
+        apr_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
                     ap_server_argv0);
         perror(buf);
-        ap_shm_destroy(scoreboard_shm);
+        apr_shm_destroy(scoreboard_shm);
         exit(APEXIT_INIT);
     }
-    ap_register_cleanup(p, NULL, ap_cleanup_shared_mem, ap_null_cleanup);
+    apr_register_cleanup(p, NULL, ap_cleanup_shared_mem, apr_null_cleanup);
     ap_scoreboard_image->global.running_generation = 0;
 }
 
-void reopen_scoreboard(ap_pool_t *p)
+void reopen_scoreboard(apr_pool_t *p)
 {
 }
 #endif   /* APR_SHARED_MEM */
 
 /* Called by parent process */
-void reinit_scoreboard(ap_pool_t *p)
+void reinit_scoreboard(apr_pool_t *p)
 {
     int running_gen = 0;
     if (ap_scoreboard_image)
@@ -206,7 +206,7 @@ void increment_counts(int child_num, int thread_num, request_rec *r)
 
 }
 
-API_EXPORT(int) find_child_by_pid(ap_proc_t *pid)
+API_EXPORT(int) find_child_by_pid(apr_proc_t *pid)
 {
     int i;
     int max_daemons_limit = ap_get_max_daemons();
@@ -253,15 +253,15 @@ int ap_update_child_status(int child_num, int thread_num, int status, request_re
 	}
 	if (r) {
 	    conn_rec *c = r->connection;
-	    ap_cpystrn(ss->client, ap_get_remote_host(c, r->per_dir_config,
+	    apr_cpystrn(ss->client, ap_get_remote_host(c, r->per_dir_config,
 				  REMOTE_NOLOOKUP), sizeof(ss->client));
 	    if (r->the_request == NULL) {
-		    ap_cpystrn(ss->request, "NULL", sizeof(ss->request));
+		    apr_cpystrn(ss->request, "NULL", sizeof(ss->request));
 	    } else if (r->parsed_uri.password == NULL) {
-		    ap_cpystrn(ss->request, r->the_request, sizeof(ss->request));
+		    apr_cpystrn(ss->request, r->the_request, sizeof(ss->request));
 	    } else {
 		/* Don't reveal the password in the server-status view */
-		    ap_cpystrn(ss->request, ap_pstrcat(r->pool, r->method, " ",
+		    apr_cpystrn(ss->request, apr_pstrcat(r->pool, r->method, " ",
 					       ap_unparse_uri_components(r->pool, &r->parsed_uri, UNP_OMITPASSWORD),
 					       r->assbackwards ? NULL : " ", r->protocol, NULL),
 				       sizeof(ss->request));
@@ -284,10 +284,10 @@ void ap_time_process_request(int child_num, int thread_num, int status)
     ss = &ap_scoreboard_image->servers[child_num][thread_num];
 
     if (status == START_PREQUEST) {
-        ss->start_time = ap_now(); 
+        ss->start_time = apr_now(); 
     }
     else if (status == STOP_PREQUEST) {
-        ss->stop_time = ap_now(); 
+        ss->stop_time = apr_now(); 
     }
     put_scoreboard_info(child_num, thread_num, ss);
 }
@@ -326,41 +326,41 @@ const char *ap_get_connection_status(long conn_id, const char *key)
     return NULL;
 }
 
-ap_array_header_t *ap_get_connections(ap_pool_t *p)
+apr_array_header_t *ap_get_connections(apr_pool_t *p)
 {
     int i;
-    ap_array_header_t *connection_list;
+    apr_array_header_t *connection_list;
     long *array_slot;
     int max_daemons_limit = ap_get_max_daemons();
 
-    connection_list = ap_make_array(p, 0, sizeof(long));
+    connection_list = apr_make_array(p, 0, sizeof(long));
     /* We assume that there is a connection iff it has an entry in the status
      * table. Connections without any status sound problematic to me, so this
      * is probably for the best. - manoj */
     for (i = 0; i < max_daemons_limit*HARD_THREAD_LIMIT; i++) {
          if (ap_new_scoreboard_image->table[i][0].key[0] != '\0') {
-            array_slot = ap_push_array(connection_list);
+            array_slot = apr_push_array(connection_list);
             *array_slot = i;
         }
     }
     return connection_list;
 }
 
-ap_array_header_t *ap_get_connection_keys(ap_pool_t *p, long conn_id)
+apr_array_header_t *ap_get_connection_keys(apr_pool_t *p, long conn_id)
 {
     int i = 0;
     status_table_entry *ss;
-    ap_array_header_t *key_list;
+    apr_array_header_t *key_list;
     char **array_slot;
 
-    key_list = ap_make_array(p, 0, KEY_LENGTH * sizeof(char));
+    key_list = apr_make_array(p, 0, KEY_LENGTH * sizeof(char));
     while (i < STATUSES_PER_CONNECTION) {
         ss = &(ap_new_scoreboard_image->table[conn_id][i]);
         if (ss->key[0] == '\0') {
             break;
         }
-        array_slot = ap_push_array(key_list);
-        *array_slot = ap_pstrdup(p, ss->key);
+        array_slot = apr_push_array(key_list);
+        *array_slot = apr_pstrdup(p, ss->key);
         i++;
     }
     return key_list;
@@ -381,7 +381,7 @@ void ap_update_connection_status(long conn_id, const char *key,
         ss = &(ap_new_scoreboard_image->table[conn_id][i]);
         if (ss->key[0] == '\0') {                                                           break;
         }                                                                               if (0 == strcmp(ss->key, key)) {
-            ap_cpystrn(ss->value, value, VALUE_LENGTH);
+            apr_cpystrn(ss->value, value, VALUE_LENGTH);
             return;
         }
         i++;
@@ -391,20 +391,20 @@ void ap_update_connection_status(long conn_id, const char *key,
         /* No room. Oh well, not much anyone can do about it. */
         return;
     }
-    ap_cpystrn(ss->key, key, KEY_LENGTH);
-    ap_cpystrn(ss->value, value, VALUE_LENGTH);
+    apr_cpystrn(ss->key, key, KEY_LENGTH);
+    apr_cpystrn(ss->value, value, VALUE_LENGTH);
     return;
 }
 
-ap_array_header_t *ap_get_status_table(ap_pool_t *p)
+apr_array_header_t *ap_get_status_table(apr_pool_t *p)
 {
     int i, j;
-    ap_array_header_t *server_status;
+    apr_array_header_t *server_status;
     ap_status_table_row_t *array_slot;
     int max_daemons_limit = ap_get_max_daemons();
     status_table_entry *ss;
 
-    server_status = ap_make_array(p, 0, sizeof(ap_status_table_row_t));
+    server_status = apr_make_array(p, 0, sizeof(ap_status_table_row_t));
 
     /* Go ahead and return what's in the connection status table even if we
      * aren't maintaining it. We can at least look at what children from
@@ -413,14 +413,14 @@ ap_array_header_t *ap_get_status_table(ap_pool_t *p)
     for (i = 0; i < max_daemons_limit*HARD_THREAD_LIMIT; i++) {
         if (ap_new_scoreboard_image->table[i][0].key[0] == '\0')
             continue;
-        array_slot = ap_push_array(server_status);
-        array_slot->data = ap_make_table(p, 0);
+        array_slot = apr_push_array(server_status);
+        array_slot->data = apr_make_table(p, 0);
         array_slot->conn_id = i;
 
         for (j = 0; j < STATUSES_PER_CONNECTION; j++) {
             ss = &(ap_new_scoreboard_image->table[i][j]);
             if (ss->key[0] != '\0') {
-                ap_table_add(array_slot->data, ss->key, ss->value);
+                apr_table_add(array_slot->data, ss->key, ss->value);
             }
             else {
                 break;
diff --git a/server/mpm/mpmt_pthread/scoreboard.h b/server/mpm/mpmt_pthread/scoreboard.h
index 21e37e3..822ae8b 100644
--- a/server/mpm/mpmt_pthread/scoreboard.h
+++ b/server/mpm/mpmt_pthread/scoreboard.h
@@ -152,8 +152,8 @@ typedef struct {
     unsigned long my_bytes_served;
     unsigned long conn_bytes;
     unsigned short conn_count;
-    ap_time_t start_time;
-    ap_time_t stop_time;
+    apr_time_t start_time;
+    apr_time_t stop_time;
 #ifdef HAVE_TIMES
     struct tms times;
 #endif
@@ -210,17 +210,17 @@ typedef struct {
 #endif
 
 API_EXPORT(int) ap_exists_scoreboard_image(void);
-void reinit_scoreboard(ap_pool_t *p);
-ap_status_t ap_cleanup_shared_mem(void *d);
+void reinit_scoreboard(apr_pool_t *p);
+apr_status_t ap_cleanup_shared_mem(void *d);
 API_EXPORT(void) ap_sync_scoreboard_image(void);
 void ap_mpmt_pthread_force_reset_connection_status(long conn_id);
 
-API_EXPORT(void) reopen_scoreboard(ap_pool_t *p);
+API_EXPORT(void) reopen_scoreboard(apr_pool_t *p);
 
 ap_inline void ap_sync_scoreboard_image(void);
 void increment_counts(int child_num, int thread_num, request_rec *r);
 void update_scoreboard_global(void);
-API_EXPORT(int) find_child_by_pid(ap_proc_t *pid);
+API_EXPORT(int) find_child_by_pid(apr_proc_t *pid);
 int ap_update_child_status(int child_num, int thread_num, int status, request_rec *r);
 void ap_time_process_request(int child_num, int thread_num, int status);
 
diff --git a/server/mpm/perchild/perchild.c b/server/mpm/perchild/perchild.c
index 32c1a4d..5e8d3ae 100644
--- a/server/mpm/perchild/perchild.c
+++ b/server/mpm/perchild/perchild.c
@@ -74,7 +74,7 @@
 #include "unixd.h"
 #include "mpm_common.h"
 #include "ap_iol.h"
-#include "ap_listen.h"
+#include "apr_listen.h"
 #include "mpm_default.h"
 #include "mpm.h"
 #include "scoreboard.h"
@@ -113,7 +113,7 @@ static int socket_num=0;
 static int workers_may_exit = 0;
 static int requests_this_child;
 static int num_listenfds = 0;
-static ap_socket_t **listenfds;
+static apr_socket_t **listenfds;
 
 struct child_info_t {
     uid_t uid;
@@ -140,7 +140,7 @@ typedef struct socket_info_t socket_info_t;
  * process.
  */
 static child_info_t child_info_table[HARD_SERVER_LIMIT];
-static ap_hash_t    *socket_info_table = NULL;
+static apr_hash_t    *socket_info_table = NULL;
 
 
 struct ap_ctable    ap_child_table[HARD_SERVER_LIMIT];
@@ -159,8 +159,8 @@ char ap_coredump_dir[MAX_STRING_LEN];
 
 module MODULE_VAR_EXPORT mpm_perchild_module;
 
-static ap_file_t *pipe_of_death_in = NULL;
-static ap_file_t *pipe_of_death_out = NULL;
+static apr_file_t *pipe_of_death_in = NULL;
+static apr_file_t *pipe_of_death_out = NULL;
 static pthread_mutex_t pipe_of_death_mutex;
 
 /* *Non*-shared http_main globals... */
@@ -184,9 +184,9 @@ static int one_process = 0;
 int raise_sigstop_flags;
 #endif
 
-static ap_pool_t *pconf;		/* Pool for config stuff */
-static ap_pool_t *pchild;		/* Pool for httpd child stuff */
-static ap_pool_t *thread_pool_parent; /* Parent of per-thread pools */
+static apr_pool_t *pconf;		/* Pool for config stuff */
+static apr_pool_t *pchild;		/* Pool for httpd child stuff */
+static apr_pool_t *thread_pool_parent; /* Parent of per-thread pools */
 static pthread_mutex_t thread_pool_parent_mutex;
 
 static int child_num;
@@ -207,7 +207,7 @@ static pthread_mutex_t idle_thread_count_mutex;
 #define SAFE_ACCEPT(stmt) APR_SUCCESS
 #else
 #define SAFE_ACCEPT(stmt) (stmt)
-static ap_lock_t *process_accept_mutex;
+static apr_lock_t *process_accept_mutex;
 #endif /* NO_SERIALIZED_ACCEPT */
 static const char *lock_fname;
 static pthread_mutex_t thread_accept_mutex = PTHREAD_MUTEX_INITIALIZER;
@@ -221,7 +221,7 @@ API_EXPORT(int) ap_get_max_daemons(void)
 static void clean_child_exit(int code)
 {
     if (pchild) {
-	ap_destroy_pool(pchild);
+	apr_destroy_pool(pchild);
     }
     exit(code);
 }
@@ -230,7 +230,7 @@ static void clean_child_exit(int code)
 static void sig_coredump(int sig)
 {
     chdir(ap_coredump_dir);
-    ap_signal(sig, SIG_DFL);
+    apr_signal(sig, SIG_DFL);
     kill(getpid(), sig);
     /* At this point we've got sig blocked, because we're still inside
      * the signal handler.  When we leave the signal handler it will
@@ -297,7 +297,7 @@ static void ap_start_restart(int graceful)
     restart_pending = 1;
     is_graceful = graceful;
     if (is_graceful) {
-        ap_kill_cleanup(pconf, NULL, ap_cleanup_shared_mem);
+        apr_kill_cleanup(pconf, NULL, ap_cleanup_shared_mem);
     }
 }
 
@@ -383,36 +383,36 @@ static void set_signals(void)
 	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGWINCH)");
 #else
     if (!one_process) {
-	ap_signal(SIGSEGV, sig_coredump);
+	apr_signal(SIGSEGV, sig_coredump);
 #ifdef SIGBUS
-	ap_signal(SIGBUS, sig_coredump);
+	apr_signal(SIGBUS, sig_coredump);
 #endif /* SIGBUS */
 #ifdef SIGABORT
-	ap_signal(SIGABORT, sig_coredump);
+	apr_signal(SIGABORT, sig_coredump);
 #endif /* SIGABORT */
 #ifdef SIGABRT
-	ap_signal(SIGABRT, sig_coredump);
+	apr_signal(SIGABRT, sig_coredump);
 #endif /* SIGABRT */
 #ifdef SIGILL
-	ap_signal(SIGILL, sig_coredump);
+	apr_signal(SIGILL, sig_coredump);
 #endif /* SIGILL */
 #ifdef SIGXCPU
-	ap_signal(SIGXCPU, SIG_DFL);
+	apr_signal(SIGXCPU, SIG_DFL);
 #endif /* SIGXCPU */
 #ifdef SIGXFSZ
-	ap_signal(SIGXFSZ, SIG_DFL);
+	apr_signal(SIGXFSZ, SIG_DFL);
 #endif /* SIGXFSZ */
     }
 
-    ap_signal(SIGTERM, sig_term);
+    apr_signal(SIGTERM, sig_term);
 #ifdef SIGHUP
-    ap_signal(SIGHUP, restart);
+    apr_signal(SIGHUP, restart);
 #endif /* SIGHUP */
 #ifdef SIGWINCH
-    ap_signal(SIGWINCH, restart);
+    apr_signal(SIGWINCH, restart);
 #endif /* SIGWINCH */
 #ifdef SIGPIPE
-    ap_signal(SIGPIPE, SIG_IGN);
+    apr_signal(SIGPIPE, SIG_IGN);
 #endif /* SIGPIPE */
 
 #endif
@@ -432,16 +432,16 @@ int ap_graceful_stop_signalled(void)
  * Child process main loop.
  */
 
-static void process_socket(ap_pool_t *p, ap_socket_t *sock, long conn_id)
+static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id)
 {
     BUFF *conn_io;
     conn_rec *current_conn;
     ap_iol *iol;
     int csd;
-    ap_status_t rv;
+    apr_status_t rv;
 
-    if ((rv = ap_get_os_sock(&csd, sock)) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "ap_get_os_sock");
+    if ((rv = apr_get_os_sock(&csd, sock)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_get_os_sock");
     }
 
     if (csd >= FD_SETSIZE) {
@@ -450,7 +450,7 @@ static void process_socket(ap_pool_t *p, ap_socket_t *sock, long conn_id)
                      "to rebuild Apache with a larger FD_SETSIZE "
                      "(currently %d)", 
                      csd, FD_SETSIZE);
-        ap_close_socket(sock);
+        apr_close_socket(sock);
         return;
     }
 
@@ -518,10 +518,10 @@ static void check_pipe_of_death(void)
     if (!workers_may_exit) {
         int ret;
         char pipe_read_char;
-        ap_ssize_t n = 1;
+        apr_ssize_t n = 1;
 
-        ret = ap_recv(listenfds[0], &pipe_read_char, &n);
-        if (ap_canonical_error(ret) == APR_EAGAIN) {
+        ret = apr_recv(listenfds[0], &pipe_read_char, &n);
+        if (apr_canonical_error(ret) == APR_EAGAIN) {
             /* It lost the lottery. It must continue to suffer
              * through a life of servitude. */
         }
@@ -538,27 +538,27 @@ static void check_pipe_of_death(void)
 
 static void *worker_thread(void *arg)
 {
-    ap_socket_t *csd = NULL;
-    ap_pool_t *tpool;		/* Pool for this thread           */
-    ap_pool_t *ptrans;		/* Pool for per-transaction stuff */
-    ap_socket_t *sd = NULL;
+    apr_socket_t *csd = NULL;
+    apr_pool_t *tpool;		/* Pool for this thread           */
+    apr_pool_t *ptrans;		/* Pool for per-transaction stuff */
+    apr_socket_t *sd = NULL;
     int srv;
     int curr_pollfd, last_pollfd = 0;
     int thread_just_started = 1;
     int thread_num = *((int *) arg);
     long conn_id = child_num * HARD_THREAD_LIMIT + thread_num;
-    ap_pollfd_t *pollset;
+    apr_pollfd_t *pollset;
     int n;
-    ap_status_t rv;
+    apr_status_t rv;
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    ap_create_pool(&tpool, thread_pool_parent);
+    apr_create_pool(&tpool, thread_pool_parent);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
-    ap_create_pool(&ptrans, tpool);
+    apr_create_pool(&ptrans, tpool);
 
-    ap_setup_poll(&pollset, num_listenfds+1, tpool);
+    apr_setup_poll(&pollset, num_listenfds+1, tpool);
     for(n=0 ; n <= num_listenfds ; ++n) {
-        ap_add_poll_socket(pollset, listenfds[n], APR_POLLIN);
+        apr_add_poll_socket(pollset, listenfds[n], APR_POLLIN);
     }
 
     while (!workers_may_exit) {
@@ -583,32 +583,32 @@ static void *worker_thread(void *arg)
             pthread_mutex_unlock(&thread_accept_mutex);
             break;
         }
-        if ((rv = SAFE_ACCEPT(ap_lock(process_accept_mutex)))
+        if ((rv = SAFE_ACCEPT(apr_lock(process_accept_mutex)))
             != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                         "ap_lock failed. Attempting to shutdown "
+                         "apr_lock failed. Attempting to shutdown "
                          "process gracefully.");
             workers_may_exit = 1;
         }
 
         while (!workers_may_exit) {
-            ap_int16_t event;
-            srv = ap_poll(pollset, &n, -1);
+            apr_int16_t event;
+            srv = apr_poll(pollset, &n, -1);
 
             if (srv != APR_SUCCESS) {
-                if (ap_canonical_error(srv) == APR_EINTR) {
+                if (apr_canonical_error(srv) == APR_EINTR) {
                     continue;
                 }
 
-                /* ap_poll() will only return errors in catastrophic
+                /* apr_poll() will only return errors in catastrophic
                  * circumstances. Let's try exiting gracefully, for now. */
                 ap_log_error(APLOG_MARK, APLOG_ERR, srv, (const server_rec *)
-                             ap_server_conf, "ap_poll: (listen)");
+                             ap_server_conf, "apr_poll: (listen)");
                 workers_may_exit = 1;
             }
             if (workers_may_exit) break;
 
-            ap_get_revents(&event, listenfds[0], pollset);
+            apr_get_revents(&event, listenfds[0], pollset);
             if (event & APR_POLLIN) {
                 /* A process got a signal on the shutdown pipe. Check if we're
                  * the lucky process to die. */
@@ -629,7 +629,7 @@ static void *worker_thread(void *arg)
                         curr_pollfd = 1;
                     }
                     /* XXX: Should we check for POLLERR? */
-                    ap_get_revents(&event, listenfds[curr_pollfd], pollset);
+                    apr_get_revents(&event, listenfds[curr_pollfd], pollset);
                     if (event & APR_POLLIN) {
                         last_pollfd = curr_pollfd;
                         sd = listenfds[curr_pollfd];
@@ -640,13 +640,13 @@ static void *worker_thread(void *arg)
         }
     got_fd:
         if (!workers_may_exit) {
-            if ((rv = ap_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
-                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, "ap_accept");
+            if ((rv = apr_accept(&csd, sd, ptrans)) != APR_SUCCESS) {
+                ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, "apr_accept");
             }
-            if ((rv = SAFE_ACCEPT(ap_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "ap_unlock failed. Attempting to shutdown "
+                             "apr_unlock failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -664,10 +664,10 @@ static void *worker_thread(void *arg)
             process_socket(ptrans, csd, conn_id);
             requests_this_child--;
 	} else {
-            if ((rv = SAFE_ACCEPT(ap_unlock(process_accept_mutex)))
+            if ((rv = SAFE_ACCEPT(apr_unlock(process_accept_mutex)))
                 != APR_SUCCESS) {
                 ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
-                             "ap_unlock failed. Attempting to shutdown "
+                             "apr_unlock failed. Attempting to shutdown "
                              "process gracefully.");
                 workers_may_exit = 1;
             }
@@ -677,11 +677,11 @@ static void *worker_thread(void *arg)
             pthread_mutex_unlock(&idle_thread_count_mutex);
 	    break;
 	}
-        ap_clear_pool(ptrans);
+        apr_clear_pool(ptrans);
     }
 
     pthread_mutex_lock(&thread_pool_parent_mutex);
-    ap_destroy_pool(tpool);
+    apr_destroy_pool(tpool);
     pthread_mutex_unlock(&thread_pool_parent_mutex);
     pthread_mutex_lock(&worker_thread_count_mutex);
     worker_thread_count--;
@@ -770,7 +770,7 @@ static int perchild_setup_child(int childnum)
     return 0;
 }
 
-static int create_child_socket(int child_num, ap_pool_t *p)
+static int create_child_socket(int child_num, apr_pool_t *p)
 {
     struct sockaddr_un unix_addr;
     mode_t omask;
@@ -779,9 +779,9 @@ static int create_child_socket(int child_num, ap_pool_t *p)
     perchild_server_conf *sconf = (perchild_server_conf *)
               ap_get_module_config(ap_server_conf->module_config, &mpm_perchild_module);
     int len = strlen(sconf->sockname) + strlen(child_info_table[child_num].name) + 3;
-    char *socket_name = ap_palloc(p, len);
+    char *socket_name = apr_palloc(p, len);
 
-    ap_snprintf(socket_name, len, "%s.%s", sconf->sockname, child_info_table[child_num].name);
+    apr_snprintf(socket_name, len, "%s.%s", sconf->sockname, child_info_table[child_num].name);
     if (unlink(socket_name) < 0 &&
         errno != ENOENT) {
         ap_log_error(APLOG_MARK, APLOG_ERR, errno, ap_server_conf,
@@ -833,15 +833,15 @@ static void child_main(int child_num_arg)
     int signal_received;
     int i;
     ap_listen_rec *lr;
-    ap_status_t rv;
+    apr_status_t rv;
 
     my_pid = getpid();
     child_num = child_num_arg;
-    ap_create_pool(&pchild, pconf);
+    apr_create_pool(&pchild, pconf);
 
     /*stuff to do before we switch id's, so we have permissions.*/
 
-    rv = SAFE_ACCEPT(ap_child_init_lock(&process_accept_mutex, lock_fname,
+    rv = SAFE_ACCEPT(apr_child_init_lock(&process_accept_mutex, lock_fname,
                                         pchild));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
@@ -879,13 +879,13 @@ static void child_main(int child_num_arg)
     /* Set up the pollfd array, num_listenfds + 1 for the pipe and 1 for
      * the child socket.
      */
-    listenfds = ap_pcalloc(pchild, sizeof(*listenfds) * (num_listenfds + 2));
+    listenfds = apr_pcalloc(pchild, sizeof(*listenfds) * (num_listenfds + 2));
 #if APR_FILES_AS_SOCKETS
-    ap_socket_from_file(&listenfds[0], pipe_of_death_in);
+    apr_socket_from_file(&listenfds[0], pipe_of_death_in);
 #endif
 
     /* The child socket */
-    ap_put_os_sock(&listenfds[1], &child_info_table[child_num].sd, pchild);
+    apr_put_os_sock(&listenfds[1], &child_info_table[child_num].sd, pchild);
 
     num_listenfds++;
     for (lr = ap_listeners, i = 2; i <= num_listenfds; lr = lr->next, ++i)
@@ -901,7 +901,7 @@ static void child_main(int child_num_arg)
     for (i = 0; i < max_threads; i++) {
         worker_thread_free_ids[i] = i;
     }
-    ap_create_pool(&thread_pool_parent, pchild);
+    apr_create_pool(&thread_pool_parent, pchild);
     pthread_mutex_init(&thread_pool_parent_mutex, NULL);
     pthread_mutex_init(&idle_thread_count_mutex, NULL);
     pthread_mutex_init(&worker_thread_count_mutex, NULL);
@@ -984,7 +984,7 @@ static int make_child(server_rec *s, int slot, time_t now)
         RAISE_SIGSTOP(MAKE_CHILD);
 
 	/* XXX - For an unthreaded server, a signal handler will be necessary
-        ap_signal(SIGTERM, just_die);
+        apr_signal(SIGTERM, just_die);
 	*/
         child_main(slot);
 
@@ -1078,7 +1078,7 @@ static void server_main_loop(int remaining_children_to_start)
 {
     int child_slot;
     ap_wait_t status;
-    ap_proc_t pid;
+    apr_proc_t pid;
     int i;
 
     while (!restart_pending && !shutdown_pending) {
@@ -1113,7 +1113,7 @@ static void server_main_loop(int remaining_children_to_start)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (ap_reap_other_child(&pid, status) == 0) {
+	    else if (apr_reap_other_child(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -1152,26 +1152,26 @@ static void server_main_loop(int remaining_children_to_start)
     }
 }
 
-int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
+int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 {
     int remaining_children_to_start;
     int i;
-    ap_status_t rv;
-    ap_ssize_t one = 1;
+    apr_status_t rv;
+    apr_ssize_t one = 1;
 
     pconf = _pconf;
     ap_server_conf = s;
-    if ((rv = ap_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
+    if ((rv = apr_create_pipe(&pipe_of_death_in, &pipe_of_death_out, pconf)) 
         != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "ap_create_pipe (pipe_of_death)");
+                     "apr_create_pipe (pipe_of_death)");
         exit(1);
     }
-    if ((rv = ap_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
+    if ((rv = apr_set_pipe_timeout(pipe_of_death_in, 0)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv,
                      (const server_rec*) ap_server_conf,
-                     "ap_set_pipe_timeout (pipe_of_death)");
+                     "apr_set_pipe_timeout (pipe_of_death)");
         exit(1);
     }
     ap_server_conf = s;
@@ -1205,10 +1205,10 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     } 
 
     /* Initialize cross-process accept lock */
-    lock_fname = ap_psprintf(_pconf, "%s.%u",
+    lock_fname = apr_psprintf(_pconf, "%s.%u",
                              ap_server_root_relative(_pconf, lock_fname),
                              my_pid);
-    rv = SAFE_ACCEPT(ap_create_lock(&process_accept_mutex, APR_MUTEX,
+    rv = SAFE_ACCEPT(apr_create_lock(&process_accept_mutex, APR_MUTEX,
                                     APR_CROSS_PROCESS, lock_fname, _pconf));
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
@@ -1284,7 +1284,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     }
 
     /* we've been told to restart */
-    ap_signal(SIGHUP, SIG_IGN);
+    apr_signal(SIGHUP, SIG_IGN);
 
     if (one_process) {
 	/* not worth thinking about */
@@ -1308,8 +1308,8 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
 	}
 	/* give the children the signal to die */
         for (i = 0; i < num_daemons;) {
-            if ((rv = ap_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
-                if (ap_canonical_error(rv) == APR_EINTR) continue;
+            if ((rv = apr_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS) {
+                if (apr_canonical_error(rv) == APR_EINTR) continue;
                 ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
                              "write pipe_of_death");
             }
@@ -1332,7 +1332,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     return 0;
 }
 
-static void perchild_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
+static void perchild_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     static int restart_num = 0;
     int no_detach = 0;
@@ -1346,7 +1346,7 @@ static void perchild_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
 	is_graceful = 0;
 
 	if (!one_process && !no_detach) {
-	    ap_detach();
+	    apr_detach();
 	}
 
 	my_pid = getpid();
@@ -1367,7 +1367,7 @@ static void perchild_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
     curr_child_num = 0;
     socket_num = 0;
 
-    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
 
     for (i = 0; i < HARD_SERVER_LIMIT; i++) {
         child_info_table[i].uid = -1;
@@ -1377,13 +1377,13 @@ static void perchild_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
     }
 }
 
-static void perchild_post_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp, server_rec *s)
+static void perchild_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
 {
     int i;
 
     for (i = 0; i < num_daemons; i++) {
         if (child_info_table[i].name == NULL) {
-            child_info_table[i].name = ap_pstrdup(p, "DEFAULT");
+            child_info_table[i].name = apr_pstrdup(p, "DEFAULT");
             child_info_table[i].num = socket_num;
         }
     }
@@ -1391,13 +1391,13 @@ static void perchild_post_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp
 
 static int perchild_post_read(request_rec *r)
 {
-    const char *hostname = ap_table_get(r->headers_in, "Host");
+    const char *hostname = apr_table_get(r->headers_in, "Host");
     char *process_num;
     int num;
 
 fprintf(stderr, "In perchild_post_read\n");
     fflush(stderr);
-    process_num = ap_hash_get(socket_info_table, hostname, 0);
+    process_num = apr_hash_get(socket_info_table, hostname, 0);
     if (process_num) {
         num = atoi(process_num);
     }
@@ -1603,7 +1603,7 @@ static const char *set_maintain_connection_status(cmd_parms *cmd,
 
 static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, const char *arg) 
 {
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     const char *fname;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1611,12 +1611,12 @@ static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, const char *arg
     }
 
     fname = ap_server_root_relative(cmd->pool, arg);
-    if ((ap_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
+    if ((apr_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
         (finfo.filetype != APR_DIR)) {
-	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
+	return apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
 			  " does not exist or is not a directory", NULL);
     }
-    ap_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
     return NULL;
 }
 
@@ -1635,7 +1635,7 @@ static const char *set_child_per_uid(cmd_parms *cmd, void *dummy, const char *u,
     
         ug->uid = atoi(u);
         ug->gid = atoi(g); 
-        ug->name = ap_pstrcat(cmd->pool, u, ":", g, NULL);
+        ug->name = apr_pstrcat(cmd->pool, u, ":", g, NULL);
         ug->num = socket_num;
     }
     socket_num++;
@@ -1652,7 +1652,7 @@ static const char *set_socket_name(cmd_parms *cmd, void *dummy, const char *arg)
     return NULL;
 }
     
-static ap_status_t cleanup_hash(void *dptr)
+static apr_status_t cleanup_hash(void *dptr)
 {
     socket_info_table = NULL;
     return APR_SUCCESS;
@@ -1661,12 +1661,12 @@ static ap_status_t cleanup_hash(void *dptr)
 static const char *assign_childuid(cmd_parms *cmd, void *dummy, const char *uid,
                                    const char *gid)
 {
-    char *socketname = ap_pstrcat(cmd->pool, uid, ":", gid, NULL);
+    char *socketname = apr_pstrcat(cmd->pool, uid, ":", gid, NULL);
     if (socket_info_table == NULL) {
-        socket_info_table = ap_make_hash(cmd->pool);
-        ap_register_cleanup(cmd->pool, socket_info_table, cleanup_hash, NULL);
+        socket_info_table = apr_make_hash(cmd->pool);
+        apr_register_cleanup(cmd->pool, socket_info_table, cleanup_hash, NULL);
     }
-    ap_hash_set(socket_info_table, cmd->server->server_hostname, 0, socketname);
+    apr_hash_set(socket_info_table, cmd->server->server_hostname, 0, socketname);
     return NULL;
 }
 
@@ -1707,10 +1707,10 @@ AP_INIT_TAKE1("ChildSockName", set_socket_name, NULL, RSRC_CONF,
 { NULL }
 };
 
-static void *perchild_create_config(ap_pool_t *p, server_rec *s)
+static void *perchild_create_config(apr_pool_t *p, server_rec *s)
 {
     perchild_server_conf *c =
-    (perchild_server_conf *) ap_pcalloc(p, sizeof(perchild_server_conf));
+    (perchild_server_conf *) apr_pcalloc(p, sizeof(perchild_server_conf));
 
     c->sockname = ap_server_root_relative(p, DEFAULT_PERCHILD_SOCKET);
     return c;
@@ -1723,7 +1723,7 @@ module MODULE_VAR_EXPORT mpm_perchild_module = {
     NULL,			/* merge per-directory config structures */
     perchild_create_config,	/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    perchild_cmds,		/* command ap_table_t */
+    perchild_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     perchild_hooks 		/* register_hooks */
 };
diff --git a/server/mpm/perchild/scoreboard.c b/server/mpm/perchild/scoreboard.c
index b44d29e..5700349 100644
--- a/server/mpm/perchild/scoreboard.c
+++ b/server/mpm/perchild/scoreboard.c
@@ -86,40 +86,40 @@ static scoreboard *ap_scoreboard_image = NULL;
 #if APR_HAS_SHARED_MEMORY
 #include "apr_shmem.h"
 
-static ap_shmem_t *scoreboard_shm = NULL;
+static apr_shmem_t *scoreboard_shm = NULL;
 
-ap_status_t ap_cleanup_shared_mem(void *d)
+apr_status_t ap_cleanup_shared_mem(void *d)
 {
-    ap_shm_free(scoreboard_shm, ap_scoreboard_image);
+    apr_shm_free(scoreboard_shm, ap_scoreboard_image);
     ap_scoreboard_image = NULL;
-    ap_shm_destroy(scoreboard_shm);
+    apr_shm_destroy(scoreboard_shm);
     return APR_SUCCESS;
 }
 
-static void setup_shared_mem(ap_pool_t *p)
+static void setup_shared_mem(apr_pool_t *p)
 {
     char buf[512];
     const char *fname;
 
     fname = ap_server_root_relative(p, ap_scoreboard_fname);
-    if (ap_shm_init(&scoreboard_shm, SCOREBOARD_SIZE + 40, fname, p) != APR_SUCCESS) {
-        ap_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
+    if (apr_shm_init(&scoreboard_shm, SCOREBOARD_SIZE + 40, fname, p) != APR_SUCCESS) {
+        apr_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
                     ap_server_argv0);
         perror(buf);
         exit(APEXIT_INIT);
     }
-    ap_scoreboard_image = ap_shm_malloc(scoreboard_shm, SCOREBOARD_SIZE);
+    ap_scoreboard_image = apr_shm_malloc(scoreboard_shm, SCOREBOARD_SIZE);
     if (ap_scoreboard_image == NULL) {
-        ap_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
+        apr_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
                     ap_server_argv0);
         perror(buf);
-        ap_shm_destroy(scoreboard_shm);
+        apr_shm_destroy(scoreboard_shm);
         exit(APEXIT_INIT);
     }
-    ap_register_cleanup(p, NULL, ap_cleanup_shared_mem, ap_null_cleanup);
+    apr_register_cleanup(p, NULL, ap_cleanup_shared_mem, apr_null_cleanup);
 }
 
-void reinit_scoreboard(ap_pool_t *p)
+void reinit_scoreboard(apr_pool_t *p)
 {
     if (ap_scoreboard_image == NULL) {
         setup_shared_mem(p);
@@ -177,40 +177,40 @@ const char *ap_get_connection_status(long conn_id, const char *key)
     return NULL;
 }
 
-ap_array_header_t *ap_get_connections(ap_pool_t *p)
+apr_array_header_t *ap_get_connections(apr_pool_t *p)
 {
     int i;
-    ap_array_header_t *connection_list;
+    apr_array_header_t *connection_list;
     long *array_slot;
 
-    connection_list = ap_make_array(p, 0, sizeof(long));
+    connection_list = apr_make_array(p, 0, sizeof(long));
     /* We assume that there is a connection iff it has an entry in the status
      * table. Connections without any status sound problematic to me, so this
      * is probably for the best. - manoj */
     for (i = 0; i < ap_max_daemons_limit*HARD_THREAD_LIMIT; i++) {
 	if (ap_scoreboard_image->table[i][0].key[0] != '\0') {
-            array_slot = ap_push_array(connection_list);
+            array_slot = apr_push_array(connection_list);
             *array_slot = i;
         }
     }
     return connection_list;
 }
 
-ap_array_header_t *ap_get_connection_keys(ap_pool_t *p, long conn_id)
+apr_array_header_t *ap_get_connection_keys(apr_pool_t *p, long conn_id)
 {
     int i = 0;
     status_table_entry *ss;
-    ap_array_header_t *key_list;
+    apr_array_header_t *key_list;
     char **array_slot;
 
-    key_list = ap_make_array(p, 0, KEY_LENGTH * sizeof(char));
+    key_list = apr_make_array(p, 0, KEY_LENGTH * sizeof(char));
     while (i < STATUSES_PER_CONNECTION) {
         ss = &(ap_scoreboard_image->table[conn_id][i]);
         if (ss->key[0] == '\0') {
             break;
         }
-        array_slot = ap_push_array(key_list);
-        *array_slot = ap_pstrdup(p, ss->key);
+        array_slot = apr_push_array(key_list);
+        *array_slot = apr_pstrdup(p, ss->key);
         i++;
     }
     return key_list;
@@ -233,7 +233,7 @@ void ap_update_connection_status(long conn_id, const char *key,
             break;
         }
         if (0 == strcmp(ss->key, key)) {
-            ap_cpystrn(ss->value, value, VALUE_LENGTH);
+            apr_cpystrn(ss->value, value, VALUE_LENGTH);
             return;
         }
 	i++;
@@ -243,19 +243,19 @@ void ap_update_connection_status(long conn_id, const char *key,
         /* No room. Oh well, not much anyone can do about it. */
         return;
     }
-    ap_cpystrn(ss->key, key, KEY_LENGTH);
-    ap_cpystrn(ss->value, value, VALUE_LENGTH);
+    apr_cpystrn(ss->key, key, KEY_LENGTH);
+    apr_cpystrn(ss->value, value, VALUE_LENGTH);
     return;
 }
 
-ap_array_header_t *ap_get_status_table(ap_pool_t *p)
+apr_array_header_t *ap_get_status_table(apr_pool_t *p)
 {
     int i, j;
-    ap_array_header_t *server_status;
+    apr_array_header_t *server_status;
     ap_status_table_row_t *array_slot;
     status_table_entry *ss;
 
-    server_status = ap_make_array(p, 0, sizeof(ap_status_table_row_t));
+    server_status = apr_make_array(p, 0, sizeof(ap_status_table_row_t));
 
     /* Go ahead and return what's in the connection status table even if we
      * aren't maintaining it. We can at least look at what children from
@@ -264,14 +264,14 @@ ap_array_header_t *ap_get_status_table(ap_pool_t *p)
     for (i = 0; i < ap_max_daemons_limit*HARD_THREAD_LIMIT; i++) {
 	if (ap_scoreboard_image->table[i][0].key[0] == '\0')
 	    continue;
-        array_slot = ap_push_array(server_status);
-        array_slot->data = ap_make_table(p, 0);
+        array_slot = apr_push_array(server_status);
+        array_slot->data = apr_make_table(p, 0);
         array_slot->conn_id = i;
         
         for (j = 0; j < STATUSES_PER_CONNECTION; j++) {
 	    ss = &(ap_scoreboard_image->table[i][j]);
             if (ss->key[0] != '\0') {
-                ap_table_add(array_slot->data, ss->key, ss->value);
+                apr_table_add(array_slot->data, ss->key, ss->value);
             }
             else {
                 break;
diff --git a/server/mpm/perchild/scoreboard.h b/server/mpm/perchild/scoreboard.h
index 9e15e6a..ded7cdc 100644
--- a/server/mpm/perchild/scoreboard.h
+++ b/server/mpm/perchild/scoreboard.h
@@ -72,9 +72,9 @@ extern "C" {
 #include "mpm_default.h"	/* For HARD_.*_LIMIT */
 
 /* The generic shared memory chunk code */
-void reinit_scoreboard(ap_pool_t *p);
+void reinit_scoreboard(apr_pool_t *p);
 
-API_EXPORT(void) reopen_scoreboard(ap_pool_t *p);
+API_EXPORT(void) reopen_scoreboard(apr_pool_t *p);
 
 /* The stuff for perchild's status table */
 
@@ -99,7 +99,7 @@ typedef struct {
 #define SCOREBOARD_SIZE		sizeof(scoreboard)
 
 API_VAR_EXPORT extern const char *ap_scoreboard_fname;
-ap_status_t ap_cleanup_shared_mem(void *d);
+apr_status_t ap_cleanup_shared_mem(void *d);
 
 #ifdef __cplusplus
 }
diff --git a/server/mpm/prefork/prefork.c b/server/mpm/prefork/prefork.c
index 16a7425..cf1f18a 100644
--- a/server/mpm/prefork/prefork.c
+++ b/server/mpm/prefork/prefork.c
@@ -104,7 +104,7 @@
 #include "unixd.h"
 #include "mpm_common.h"
 #include "ap_iol.h"
-#include "ap_listen.h"
+#include "apr_listen.h"
 #include "ap_mmn.h"
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
@@ -138,7 +138,7 @@
 
 static int ap_max_requests_per_child=0;
 static const char *ap_pid_fname=NULL;
-static ap_lock_t *accept_lock;
+static apr_lock_t *accept_lock;
 static const char *ap_scoreboard_fname=NULL;
 static const char *ap_lock_fname;
 static int ap_daemons_to_start=0;
@@ -161,7 +161,7 @@ char ap_coredump_dir[MAX_STRING_LEN];
 
 /* *Non*-shared http_main globals... */
 
-static ap_socket_t *sd;
+static apr_socket_t *sd;
 static fd_set listenfds;
 static int listenmaxfd;
 
@@ -178,8 +178,8 @@ static int listenmaxfd;
 
 static int one_process = 0;
 
-static ap_pool_t *pconf;		/* Pool for config stuff */
-static ap_pool_t *pchild;		/* Pool for httpd child stuff */
+static apr_pool_t *pconf;		/* Pool for config stuff */
+static apr_pool_t *pchild;		/* Pool for httpd child stuff */
 
 int ap_my_pid;	/* it seems silly to call getpid all the time */
 #ifndef MULTITHREAD
@@ -212,7 +212,7 @@ static void chdir_for_gprof(void)
 	int len = strlen(sconf->gprof_dir) - 1;
 	if(*(dir + len) == '%') {
 	    dir[len] = '\0';
-	    ap_snprintf(buf, sizeof(buf), "%sgprof.%d", dir, (int)getpid());
+	    apr_snprintf(buf, sizeof(buf), "%sgprof.%d", dir, (int)getpid());
 	} 
 	dir = ap_server_root_relative(pconf, buf[0] ? buf : dir);
 	if(mkdir(dir, 0755) < 0 && errno != EEXIST) {
@@ -239,27 +239,27 @@ static void clean_child_exit(int code) __attribute__ ((noreturn));
 static void clean_child_exit(int code)
 {
     if (pchild) {
-	ap_destroy_pool(pchild);
+	apr_destroy_pool(pchild);
     }
     chdir_for_gprof();
     exit(code);
 }
 
-static void expand_lock_fname(ap_pool_t *p)
+static void expand_lock_fname(apr_pool_t *p)
 {
     /* XXXX possibly bogus cast */
-    ap_lock_fname = ap_psprintf(p, "%s.%lu",
+    ap_lock_fname = apr_psprintf(p, "%s.%lu",
 	ap_server_root_relative(p, ap_lock_fname), (unsigned long)getpid());
 }
 
 /* Initialize mutex lock.
  * Done by each child at its birth
  */
-static void accept_mutex_child_init(ap_pool_t *p)
+static void accept_mutex_child_init(apr_pool_t *p)
 {
-    ap_status_t rv;
+    apr_status_t rv;
 
-    rv = ap_child_init_lock(&accept_lock, ap_lock_fname, p);
+    rv = apr_child_init_lock(&accept_lock, ap_lock_fname, p);
     if (rv) {
 	ap_log_error(APLOG_MARK, APLOG_EMERG, rv, NULL, 
                      "couldn't do child init for accept mutex");
@@ -270,12 +270,12 @@ static void accept_mutex_child_init(ap_pool_t *p)
 /* Initialize mutex lock.
  * Must be safe to call this on a restart.
  */
-static void accept_mutex_init(ap_pool_t *p)
+static void accept_mutex_init(apr_pool_t *p)
 {
-    ap_status_t rv;
+    apr_status_t rv;
 
     expand_lock_fname(p);
-    rv = ap_create_lock(&accept_lock, APR_MUTEX, APR_CROSS_PROCESS, ap_lock_fname, p);
+    rv = apr_create_lock(&accept_lock, APR_MUTEX, APR_CROSS_PROCESS, ap_lock_fname, p);
     if (rv) {
 	ap_log_error(APLOG_MARK, APLOG_EMERG, rv, NULL, "couldn't create accept mutex");
         exit(APEXIT_INIT);
@@ -284,13 +284,13 @@ static void accept_mutex_init(ap_pool_t *p)
 
 static void accept_mutex_on(void)
 {
-    ap_status_t rv = ap_lock(accept_lock);
+    apr_status_t rv = apr_lock(accept_lock);
     ap_assert(!rv);
 }
 
 static void accept_mutex_off(void)
 {
-    ap_status_t rv = ap_unlock(accept_lock);
+    apr_status_t rv = apr_unlock(accept_lock);
     ap_assert(!rv);
 }
 
@@ -308,48 +308,48 @@ static void accept_mutex_off(void)
 #if APR_HAS_SHARED_MEMORY
 #include "apr_shmem.h"
 
-static ap_shmem_t *scoreboard_shm = NULL;
+static apr_shmem_t *scoreboard_shm = NULL;
 
-static ap_status_t cleanup_shared_mem(void *d)
+static apr_status_t cleanup_shared_mem(void *d)
 {
-    ap_shm_free(scoreboard_shm, ap_scoreboard_image);
+    apr_shm_free(scoreboard_shm, ap_scoreboard_image);
     ap_scoreboard_image = NULL;
-    ap_shm_destroy(scoreboard_shm);
+    apr_shm_destroy(scoreboard_shm);
     return APR_SUCCESS;
 }
 
-static void setup_shared_mem(ap_pool_t *p)
+static void setup_shared_mem(apr_pool_t *p)
 {
     char buf[512];
     const char *fname;
 
     fname = ap_server_root_relative(p, ap_scoreboard_fname);
-    if (ap_shm_init(&scoreboard_shm, SCOREBOARD_SIZE + NEW_SCOREBOARD_SIZE + 40, fname, p) != APR_SUCCESS) {
-	ap_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
+    if (apr_shm_init(&scoreboard_shm, SCOREBOARD_SIZE + NEW_SCOREBOARD_SIZE + 40, fname, p) != APR_SUCCESS) {
+	apr_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
 		    ap_server_argv0);
 	perror(buf);
 	exit(APEXIT_INIT);
     }
-    ap_scoreboard_image = ap_shm_malloc(scoreboard_shm, SCOREBOARD_SIZE); 
-    ap_new_scoreboard_image = ap_shm_malloc(scoreboard_shm, NEW_SCOREBOARD_SIZE); 
+    ap_scoreboard_image = apr_shm_malloc(scoreboard_shm, SCOREBOARD_SIZE); 
+    ap_new_scoreboard_image = apr_shm_malloc(scoreboard_shm, NEW_SCOREBOARD_SIZE); 
     if (ap_scoreboard_image == NULL) {
-	ap_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
+	apr_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
 		    ap_server_argv0);
 	perror(buf);
-	ap_shm_destroy(scoreboard_shm);
+	apr_shm_destroy(scoreboard_shm);
 	exit(APEXIT_INIT);
     }
-    ap_register_cleanup(p, NULL, cleanup_shared_mem, ap_null_cleanup);
+    apr_register_cleanup(p, NULL, cleanup_shared_mem, apr_null_cleanup);
     ap_scoreboard_image->global.running_generation = 0;
 }
 
-static void reopen_scoreboard(ap_pool_t *p)
+static void reopen_scoreboard(apr_pool_t *p)
 {
 }
 #endif
 
 /* Called by parent process */
-static void reinit_scoreboard(ap_pool_t *p)
+static void reinit_scoreboard(apr_pool_t *p)
 {
     int running_gen = 0;
     if (ap_scoreboard_image)
@@ -429,15 +429,15 @@ int ap_update_child_status(int child_num, int status, request_rec *r)
 	}
 	if (r) {
 	    conn_rec *c = r->connection;
-	    ap_cpystrn(ss->client, ap_get_remote_host(c, r->per_dir_config,
+	    apr_cpystrn(ss->client, ap_get_remote_host(c, r->per_dir_config,
 				  REMOTE_NOLOOKUP), sizeof(ss->client));
 	    if (r->the_request == NULL) {
-		    ap_cpystrn(ss->request, "NULL", sizeof(ss->request));
+		    apr_cpystrn(ss->request, "NULL", sizeof(ss->request));
 	    } else if (r->parsed_uri.password == NULL) {
-		    ap_cpystrn(ss->request, r->the_request, sizeof(ss->request));
+		    apr_cpystrn(ss->request, r->the_request, sizeof(ss->request));
 	    } else {
 		/* Don't reveal the password in the server-status view */
-		    ap_cpystrn(ss->request, ap_pstrcat(r->pool, r->method, " ",
+		    apr_cpystrn(ss->request, apr_pstrcat(r->pool, r->method, " ",
 					       ap_unparse_uri_components(r->pool, &r->parsed_uri, UNP_OMITPASSWORD),
 					       r->assbackwards ? NULL : " ", r->protocol, NULL),
 				       sizeof(ss->request));
@@ -483,10 +483,10 @@ void ap_time_process_request(int child_num, int status)
     ss = &ap_scoreboard_image->servers[child_num];
 
     if (status == START_PREQUEST) {
-	ss->start_time = ap_now();
+	ss->start_time = apr_now();
     }
     else if (status == STOP_PREQUEST) {
-	ss->stop_time = ap_now();
+	ss->stop_time = apr_now();
     }
 
     put_scoreboard_info(child_num, ss);
@@ -518,7 +518,7 @@ static void increment_counts(int child_num, request_rec *r)
 }
 */
 
-static int find_child_by_pid(ap_proc_t *pid)
+static int find_child_by_pid(apr_proc_t *pid)
 {
     int i;
 
@@ -556,7 +556,7 @@ int reap_children(ap_wait_t *status)
 static void sig_coredump(int sig)
 {
     chdir(ap_coredump_dir);
-    ap_signal(sig, SIG_DFL);
+    apr_signal(sig, SIG_DFL);
     kill(getpid(), sig);
     /* At this point we've got sig blocked, because we're still inside
      * the signal handler.  When we leave the signal handler it will
@@ -613,7 +613,7 @@ static void restart(int sig)
     }
     restart_pending = 1;
     if ((is_graceful = (sig == SIGUSR1))) {
-        ap_kill_cleanup(pconf, NULL, cleanup_shared_mem);
+        apr_kill_cleanup(pconf, NULL, cleanup_shared_mem);
     }
 }
 
@@ -685,36 +685,36 @@ static void set_signals(void)
 	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGUSR1)");
 #else
     if (!one_process) {
-	ap_signal(SIGSEGV, sig_coredump);
+	apr_signal(SIGSEGV, sig_coredump);
 #ifdef SIGBUS
-	ap_signal(SIGBUS, sig_coredump);
+	apr_signal(SIGBUS, sig_coredump);
 #endif /* SIGBUS */
 #ifdef SIGABORT
-	ap_signal(SIGABORT, sig_coredump);
+	apr_signal(SIGABORT, sig_coredump);
 #endif /* SIGABORT */
 #ifdef SIGABRT
-	ap_signal(SIGABRT, sig_coredump);
+	apr_signal(SIGABRT, sig_coredump);
 #endif /* SIGABRT */
 #ifdef SIGILL
-	ap_signal(SIGILL, sig_coredump);
+	apr_signal(SIGILL, sig_coredump);
 #endif /* SIGILL */
 #ifdef SIGXCPU
-	ap_signal(SIGXCPU, SIG_DFL);
+	apr_signal(SIGXCPU, SIG_DFL);
 #endif /* SIGXCPU */
 #ifdef SIGXFSZ
-	ap_signal(SIGXFSZ, SIG_DFL);
+	apr_signal(SIGXFSZ, SIG_DFL);
 #endif /* SIGXFSZ */
     }
 
-    ap_signal(SIGTERM, sig_term);
+    apr_signal(SIGTERM, sig_term);
 #ifdef SIGHUP
-    ap_signal(SIGHUP, restart);
+    apr_signal(SIGHUP, restart);
 #endif /* SIGHUP */
 #ifdef SIGUSR1
-    ap_signal(SIGUSR1, restart);
+    apr_signal(SIGUSR1, restart);
 #endif /* SIGUSR1 */
 #ifdef SIGPIPE
-    ap_signal(SIGPIPE, SIG_IGN);
+    apr_signal(SIGPIPE, SIG_IGN);
 #endif /* SIGPIPE */
 
 #endif
@@ -727,7 +727,7 @@ static void set_signals(void)
  */
 
 static int srv;
-static ap_socket_t *csd;
+static apr_socket_t *csd;
 static int requests_this_child;
 static fd_set main_fds;
 
@@ -746,10 +746,10 @@ static void child_main(int child_num_arg)
     ap_listen_rec *lr;
     ap_listen_rec *last_lr;
     ap_listen_rec *first_lr;
-    ap_pool_t *ptrans;
+    apr_pool_t *ptrans;
     conn_rec *current_conn;
     ap_iol *iol;
-    ap_status_t stat = APR_EINIT;
+    apr_status_t stat = APR_EINIT;
     int sockdes;
 
     ap_my_pid = getpid();
@@ -761,9 +761,9 @@ static void child_main(int child_num_arg)
     /* Get a sub context for global allocations in this child, so that
      * we can have cleanups occur when the child exits.
      */
-    ap_create_pool(&pchild, pconf);
+    apr_create_pool(&pchild, pconf);
 
-    ap_create_pool(&ptrans, pchild);
+    apr_create_pool(&ptrans, pchild);
 
     /* needs to be done before we switch UIDs so we have permissions */
     reopen_scoreboard(pchild);
@@ -777,8 +777,8 @@ static void child_main(int child_num_arg)
 
     (void) ap_update_child_status(my_child_num, SERVER_READY, (request_rec *) NULL);
 
-    ap_signal(SIGHUP, just_die);
-    ap_signal(SIGTERM, just_die);
+    apr_signal(SIGHUP, just_die);
+    apr_signal(SIGTERM, just_die);
 
 #ifdef OS2
 /* Stop Ctrl-C/Ctrl-Break signals going to child processes */
@@ -795,7 +795,7 @@ static void child_main(int child_num_arg)
 	 * we can exit cleanly.
 	 */
 	usr1_just_die = 1;
-	ap_signal(SIGUSR1, usr1_handler);
+	apr_signal(SIGUSR1, usr1_handler);
 
 	/*
 	 * (Re)initialize this child to a pre-connection state.
@@ -803,7 +803,7 @@ static void child_main(int child_num_arg)
 
 	current_conn = NULL;
 
-	ap_clear_pool(ptrans);
+	apr_clear_pool(ptrans);
 
 	if ((ap_max_requests_per_child > 0
 	     && requests_this_child++ >= ap_max_requests_per_child)) {
@@ -851,7 +851,7 @@ static void child_main(int child_num_arg)
 		}
 		first_lr=lr;
 		do {
-                    ap_get_os_sock(&sockdes, lr->sd);
+                    apr_get_os_sock(&sockdes, lr->sd);
 		    if (FD_ISSET(sockdes, &main_fds))
 			goto got_listener;
 		    lr = lr->next;
@@ -881,7 +881,7 @@ static void child_main(int child_num_arg)
 		    /* we didn't get a socket, and we were told to die */
 		    clean_child_exit(0);
 		}
-		stat = ap_accept(&csd, sd, ptrans);
+		stat = apr_accept(&csd, sd, ptrans);
 		if (stat == APR_SUCCESS || stat != APR_EINTR)
 		    break;
 	    }
@@ -961,7 +961,7 @@ static void child_main(int child_num_arg)
 		      * occur in mobile IP.
 		      */
 		    ap_log_error(APLOG_MARK, APLOG_EMERG, stat, ap_server_conf,
-			"ap_accept: giving up.");
+			"apr_accept: giving up.");
 		    clean_child_exit(APEXIT_CHILDFATAL);
 #endif /*ENETDOWN*/
 
@@ -978,7 +978,7 @@ static void child_main(int child_num_arg)
 #else
 		default:
 		    ap_log_error(APLOG_MARK, APLOG_ERR, stat, ap_server_conf,
-				"ap_accept: (client socket)");
+				"apr_accept: (client socket)");
 		    clean_child_exit(1);
 #endif
 		}
@@ -997,13 +997,13 @@ static void child_main(int child_num_arg)
 	 * the signal to ignore because we don't want to disturb any
 	 * third party code.
 	 */
-	ap_signal(SIGUSR1, SIG_IGN);
+	apr_signal(SIGUSR1, SIG_IGN);
 	/*
 	 * We now have a connection, so set it up with the appropriate
 	 * socket options, file descriptors, and read/write buffers.
 	 */
 
-        ap_get_os_sock(&sockdes, csd);
+        apr_get_os_sock(&sockdes, csd);
 
         if (sockdes >= FD_SETSIZE) {
             ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
@@ -1011,7 +1011,7 @@ static void child_main(int child_num_arg)
                          "to rebuild Apache with a larger FD_SETSIZE "
                          "(currently %d)", 
                          sockdes, FD_SETSIZE);
-	    ap_close_socket(csd);
+	    apr_close_socket(csd);
 	    continue;
         }
 
@@ -1048,12 +1048,12 @@ static int make_child(server_rec *s, int slot, time_t now)
     }
 
     if (one_process) {
-	ap_signal(SIGHUP, just_die);
-	ap_signal(SIGINT, just_die);
+	apr_signal(SIGHUP, just_die);
+	apr_signal(SIGINT, just_die);
 #ifdef SIGQUIT
-	ap_signal(SIGQUIT, SIG_DFL);
+	apr_signal(SIGQUIT, SIG_DFL);
 #endif
-	ap_signal(SIGTERM, just_die);
+	apr_signal(SIGTERM, just_die);
 	child_main(slot);
     }
 
@@ -1101,9 +1101,9 @@ static int make_child(server_rec *s, int slot, time_t now)
 	 * Note that since restart() just notes that a restart has been
 	 * requested there's no race condition here.
 	 */
-	ap_signal(SIGHUP, just_die);
-	ap_signal(SIGUSR1, just_die);
-	ap_signal(SIGTERM, just_die);
+	apr_signal(SIGHUP, just_die);
+	apr_signal(SIGUSR1, just_die);
+	apr_signal(SIGTERM, just_die);
 	child_main(slot);
     }
 
@@ -1280,7 +1280,7 @@ static int setup_listeners(server_rec *s)
     listenmaxfd = -1;
     FD_ZERO(&listenfds);
     for (lr = ap_listeners; lr; lr = lr->next) {
-        ap_get_os_sock(&sockdes, lr->sd);
+        apr_get_os_sock(&sockdes, lr->sd);
 	FD_SET(sockdes, &listenfds);
 	if (sockdes > listenmaxfd) {
 	    listenmaxfd = sockdes;
@@ -1310,7 +1310,7 @@ void ap_reset_connection_status(long conn_id)
  * Executive routines.
  */
 
-int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
+int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 {
     int remaining_children_to_start;
 
@@ -1374,7 +1374,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
 	int child_slot;
 	ap_wait_t status;
         /* this is a memory leak, but I'll fix it later. */
-	ap_proc_t pid;
+	apr_proc_t pid;
 
         ap_wait_or_timeout(&status, &pid, pconf);
 
@@ -1401,7 +1401,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
 		}
 #if APR_HAS_OTHER_CHILD
 	    }
-	    else if (ap_reap_other_child(&pid, status) == 0) {
+	    else if (apr_reap_other_child(&pid, status) == 0) {
 		/* handled */
 #endif
 	    }
@@ -1469,8 +1469,8 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     }
 
     /* we've been told to restart */
-    ap_signal(SIGHUP, SIG_IGN);
-    ap_signal(SIGUSR1, SIG_IGN);
+    apr_signal(SIGHUP, SIG_IGN);
+    apr_signal(SIGUSR1, SIG_IGN);
     if (one_process) {
 	/* not worth thinking about */
 	return 1;
@@ -1526,7 +1526,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     return 0;
 }
 
-static void prefork_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
+static void prefork_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     static int restart_num = 0;
     int no_detach = 0;
@@ -1539,7 +1539,7 @@ static void prefork_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
 	is_graceful = 0;
 
 	if (!one_process && !no_detach) {
-	    ap_detach();
+	    apr_detach();
 	}
 
 	ap_my_pid = getpid();
@@ -1557,7 +1557,7 @@ static void prefork_pre_config(ap_pool_t *p, ap_pool_t *plog, ap_pool_t *ptemp)
     ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
     ap_extended_status = 0;
 
-    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
 }
 
 static void prefork_hooks(void)
@@ -1692,7 +1692,7 @@ static const char *set_max_requests(cmd_parms *cmd, void *dummy, const char *arg
 
 static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, const char *arg) 
 {
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     const char *fname;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1700,12 +1700,12 @@ static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, const char *arg
     }
 
     fname = ap_server_root_relative(cmd->pool, arg);
-    if ((ap_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
+    if ((apr_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
         (finfo.filetype != APR_DIR)) {
-	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
+	return apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
 			  " does not exist or is not a directory", NULL);
     }
-    ap_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
     return NULL;
 }
 
@@ -1730,40 +1730,40 @@ const char *ap_get_connection_status(long conn_id, const char *key)
     return NULL;
 }
 
-ap_array_header_t *ap_get_connections(ap_pool_t *p)
+apr_array_header_t *ap_get_connections(apr_pool_t *p)
 {
     int i;
-    ap_array_header_t *connection_list;
+    apr_array_header_t *connection_list;
     long *array_slot;
 
-    connection_list = ap_make_array(p, 0, sizeof(long));
+    connection_list = apr_make_array(p, 0, sizeof(long));
     /* We assume that there is a connection iff it has an entry in the status
      * table. Connections without any status sound problematic to me, so this
      * is probably for the best. - manoj */
     for (i = 0; i < ap_max_daemons_limit; i++) {
          if (ap_new_scoreboard_image->table[i][0].key[0] != '\0') {
-            array_slot = ap_push_array(connection_list);
+            array_slot = apr_push_array(connection_list);
             *array_slot = i;
         }
     }
     return connection_list;
 }
 
-ap_array_header_t *ap_get_connection_keys(ap_pool_t *p, long conn_id)
+apr_array_header_t *ap_get_connection_keys(apr_pool_t *p, long conn_id)
 {
     int i = 0;
     status_table_entry *ss;
-    ap_array_header_t *key_list;
+    apr_array_header_t *key_list;
     char **array_slot;
 
-    key_list = ap_make_array(p, 0, KEY_LENGTH * sizeof(char));
+    key_list = apr_make_array(p, 0, KEY_LENGTH * sizeof(char));
     while (i < STATUSES_PER_CONNECTION) {
         ss = &(ap_new_scoreboard_image->table[conn_id][i]);
         if (ss->key[0] == '\0') {
             break;
         }
-        array_slot = ap_push_array(key_list);
-        *array_slot = ap_pstrdup(p, ss->key);
+        array_slot = apr_push_array(key_list);
+        *array_slot = apr_pstrdup(p, ss->key);
         i++;
     }
     return key_list;
@@ -1786,7 +1786,7 @@ void ap_update_connection_status(long conn_id, const char *key,
             break;
         }
         if (0 == strcmp(ss->key, key)) {
-            ap_cpystrn(ss->value, value, VALUE_LENGTH);
+            apr_cpystrn(ss->value, value, VALUE_LENGTH);
             return;
         }
         i++;
@@ -1796,19 +1796,19 @@ void ap_update_connection_status(long conn_id, const char *key,
         /* No room. Oh well, not much anyone can do about it. */
         return;
     }
-    ap_cpystrn(ss->key, key, KEY_LENGTH);
-    ap_cpystrn(ss->value, value, VALUE_LENGTH);
+    apr_cpystrn(ss->key, key, KEY_LENGTH);
+    apr_cpystrn(ss->value, value, VALUE_LENGTH);
     return;
 }
 
-ap_array_header_t *ap_get_status_table(ap_pool_t *p)
+apr_array_header_t *ap_get_status_table(apr_pool_t *p)
 {
     int i, j;
-    ap_array_header_t *server_status;
+    apr_array_header_t *server_status;
     ap_status_table_row_t *array_slot;
     status_table_entry *ss;
 
-    server_status = ap_make_array(p, 0, sizeof(ap_status_table_row_t));
+    server_status = apr_make_array(p, 0, sizeof(ap_status_table_row_t));
 
     /* Go ahead and return what's in the connection status table even if we
      * aren't maintaining it. We can at least look at what children from
@@ -1817,14 +1817,14 @@ ap_array_header_t *ap_get_status_table(ap_pool_t *p)
     for (i = 0; i < ap_max_daemons_limit; i++) {
         if (ap_new_scoreboard_image->table[i][0].key[0] == '\0')
             continue;
-        array_slot = ap_push_array(server_status);
-        array_slot->data = ap_make_table(p, 0);
+        array_slot = apr_push_array(server_status);
+        array_slot->data = apr_make_table(p, 0);
         array_slot->conn_id = i;
 
         for (j = 0; j < STATUSES_PER_CONNECTION; j++) {
             ss = &(ap_new_scoreboard_image->table[i][j]);
             if (ss->key[0] != '\0') {
-                ap_table_add(array_slot->data, ss->key, ss->value);
+                apr_table_add(array_slot->data, ss->key, ss->value);
             }
             else {
                 break;
@@ -1865,7 +1865,7 @@ module MODULE_VAR_EXPORT mpm_prefork_module = {
     NULL,			/* merge per-directory config structures */
     NULL,			/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    prefork_cmds,		/* command ap_table_t */
+    prefork_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     prefork_hooks,		/* register hooks */
 };
diff --git a/server/mpm/prefork/scoreboard.h b/server/mpm/prefork/scoreboard.h
index d66c606..97ed8e8 100644
--- a/server/mpm/prefork/scoreboard.h
+++ b/server/mpm/prefork/scoreboard.h
@@ -151,8 +151,8 @@ typedef struct {
     unsigned long my_bytes_served;
     unsigned long conn_bytes;
     unsigned short conn_count;
-    ap_time_t start_time;
-    ap_time_t stop_time;
+    apr_time_t start_time;
+    apr_time_t stop_time;
 #ifdef HAVE_TIMES
     struct tms times;
 #endif
diff --git a/server/mpm/spmt_os2/scoreboard.h b/server/mpm/spmt_os2/scoreboard.h
index 41e594b..5ef4c4d 100644
--- a/server/mpm/spmt_os2/scoreboard.h
+++ b/server/mpm/spmt_os2/scoreboard.h
@@ -145,8 +145,8 @@ typedef struct {
     unsigned long my_bytes_served;
     unsigned long conn_bytes;
     unsigned short conn_count;
-    ap_time_t start_time;
-    ap_time_t stop_time;
+    apr_time_t start_time;
+    apr_time_t stop_time;
 #ifdef HAVE_TIMES
     struct tms times;
 #endif
diff --git a/server/mpm/spmt_os2/spmt_os2.c b/server/mpm/spmt_os2/spmt_os2.c
index c004e92..b19c133 100644
--- a/server/mpm/spmt_os2/spmt_os2.c
+++ b/server/mpm/spmt_os2/spmt_os2.c
@@ -70,7 +70,7 @@
 #include "http_connection.h"
 #include "scoreboard.h"
 #include "ap_mpm.h"
-#include "ap_listen.h"
+#include "apr_listen.h"
 #include "ap_iol.h"
 #include "apr_portable.h"
 #include "mpm_common.h"
@@ -119,12 +119,12 @@ server_rec *ap_server_conf;
 
 static int one_process = 0;
 
-static ap_pool_t *pconf;		/* Pool for config stuff */
+static apr_pool_t *pconf;		/* Pool for config stuff */
 static scoreboard *ap_scoreboard_image = NULL;
 
 struct thread_globals {
     int child_num;
-    ap_pool_t *pchild;		/* Pool for httpd child stuff */
+    apr_pool_t *pchild;		/* Pool for httpd child stuff */
     int usr1_just_die;
 };
 
@@ -133,7 +133,7 @@ static struct thread_globals **ppthread_globals = NULL;
 #define THREAD_GLOBAL(gvar) ((*ppthread_globals)->gvar)
 
 
-void reinit_scoreboard(ap_pool_t *p)
+void reinit_scoreboard(apr_pool_t *p)
 {
     if (ap_scoreboard_image == NULL) {
         ap_scoreboard_image = (scoreboard *) malloc(SCOREBOARD_SIZE);
@@ -159,7 +159,7 @@ void cleanup_scoreboard(void)
 static void clean_child_exit(int code)
 {
     if (THREAD_GLOBAL(pchild)) {
-        ap_destroy_pool(THREAD_GLOBAL(pchild));
+        apr_destroy_pool(THREAD_GLOBAL(pchild));
     }
 
     ap_scoreboard_image->servers[THREAD_GLOBAL(child_num)].thread_retval = code;
@@ -168,29 +168,29 @@ static void clean_child_exit(int code)
 
 
 
-static ap_lock_t *accept_mutex = NULL;
+static apr_lock_t *accept_mutex = NULL;
 
-static ap_status_t accept_mutex_child_cleanup(void *foo)
+static apr_status_t accept_mutex_child_cleanup(void *foo)
 {
-    return ap_unlock(accept_mutex);
+    return apr_unlock(accept_mutex);
 }
 
 /*
  * Initialize mutex lock.
  * Done by each child at it's birth
  */
-static void accept_mutex_child_init(ap_pool_t *p)
+static void accept_mutex_child_init(apr_pool_t *p)
 {
-    ap_register_cleanup(p, NULL, accept_mutex_child_cleanup, ap_null_cleanup);
+    apr_register_cleanup(p, NULL, accept_mutex_child_cleanup, apr_null_cleanup);
 }
 
 /*
  * Initialize mutex lock.
  * Must be safe to call this on a restart.
  */
-static void accept_mutex_init(ap_pool_t *p)
+static void accept_mutex_init(apr_pool_t *p)
 {
-    ap_status_t rc = ap_create_lock(&accept_mutex, APR_MUTEX, APR_INTRAPROCESS, NULL, p);
+    apr_status_t rc = apr_create_lock(&accept_mutex, APR_MUTEX, APR_INTRAPROCESS, NULL, p);
 
     if (rc != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_EMERG, rc, ap_server_conf,
@@ -201,7 +201,7 @@ static void accept_mutex_init(ap_pool_t *p)
 
 static void accept_mutex_on(void)
 {
-    ap_status_t rc = ap_lock(accept_mutex);
+    apr_status_t rc = apr_lock(accept_mutex);
 
     if (rc != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_EMERG, rc, ap_server_conf,
@@ -212,7 +212,7 @@ static void accept_mutex_on(void)
 
 static void accept_mutex_off(void)
 {
-    ap_status_t rc = ap_unlock(accept_mutex);
+    apr_status_t rc = apr_unlock(accept_mutex);
 
     if (rc != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_EMERG, rc, ap_server_conf,
@@ -270,15 +270,15 @@ int ap_update_child_status(int child_num, int status, request_rec *r)
 	}
 	if (r) {
 	    conn_rec *c = r->connection;
-	    ap_cpystrn(ss->client, ap_get_remote_host(c, r->per_dir_config,
+	    apr_cpystrn(ss->client, ap_get_remote_host(c, r->per_dir_config,
 				  REMOTE_NOLOOKUP), sizeof(ss->client));
 	    if (r->the_request == NULL) {
-		    ap_cpystrn(ss->request, "NULL", sizeof(ss->request));
+		    apr_cpystrn(ss->request, "NULL", sizeof(ss->request));
 	    } else if (r->parsed_uri.password == NULL) {
-		    ap_cpystrn(ss->request, r->the_request, sizeof(ss->request));
+		    apr_cpystrn(ss->request, r->the_request, sizeof(ss->request));
 	    } else {
 		/* Don't reveal the password in the server-status view */
-		    ap_cpystrn(ss->request, ap_pstrcat(r->pool, r->method, " ",
+		    apr_cpystrn(ss->request, apr_pstrcat(r->pool, r->method, " ",
 					       ap_unparse_uri_components(r->pool, &r->parsed_uri, UNP_OMITPASSWORD),
 					       r->assbackwards ? NULL : " ", r->protocol, NULL),
 				       sizeof(ss->request));
@@ -308,10 +308,10 @@ void ap_time_process_request(int child_num, int status)
     ss = &ap_scoreboard_image->servers[child_num];
 
     if (status == START_PREQUEST) {
-	ss->start_time = ap_now();
+	ss->start_time = apr_now();
     }
     else if (status == STOP_PREQUEST) {
-	ss->stop_time = ap_now();
+	ss->stop_time = apr_now();
     }
 }
 
@@ -367,7 +367,7 @@ static int wait_or_timeout(ap_wait_t *status)
     if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {
 	wait_or_timeout_counter = 0;
 #if APR_HAS_OTHER_CHILD
-	ap_probe_writable_fds();
+	apr_probe_writable_fds();
 #endif
     }
 
@@ -716,7 +716,7 @@ int ap_stop_signalled(void)
 
 
 
-static int setup_listen_poll(ap_pool_t *pchild, ap_pollfd_t **listen_poll)
+static int setup_listen_poll(apr_pool_t *pchild, apr_pollfd_t **listen_poll)
 {
     ap_listen_rec *lr;
     int numfds = 0;
@@ -725,10 +725,10 @@ static int setup_listen_poll(ap_pool_t *pchild, ap_pollfd_t **listen_poll)
         numfds++;
     }
 
-    ap_setup_poll(listen_poll, numfds, pchild);
+    apr_setup_poll(listen_poll, numfds, pchild);
 
     for (lr = ap_listeners; lr; lr = lr->next) {
-	ap_add_poll_socket(*listen_poll, lr->sd, APR_POLLIN);
+	apr_add_poll_socket(*listen_poll, lr->sd, APR_POLLIN);
     }
     return 0;
 }
@@ -739,14 +739,14 @@ static void child_main(void *child_num_arg)
 {
     ap_listen_rec *lr = NULL;
     ap_listen_rec *first_lr = NULL;
-    ap_pool_t *ptrans;
+    apr_pool_t *ptrans;
     conn_rec *current_conn;
     ap_iol *iol;
-    ap_pool_t *pchild;
+    apr_pool_t *pchild;
     parent_score *sc_parent_rec;
     int requests_this_child = 0;
-    ap_pollfd_t *listen_poll;
-    ap_socket_t *csd = NULL;
+    apr_pollfd_t *listen_poll;
+    apr_socket_t *csd = NULL;
     int nsds, rv;
 
     /* Disable the restart signal handlers and enable the just_die stuff.
@@ -762,12 +762,12 @@ static void child_main(void *child_num_arg)
     /* Get a sub pool for global allocations in this child, so that
      * we can have cleanups occur when the child exits.
      */
-    ap_create_pool(&pchild, pconf);
-    *ppthread_globals = (struct thread_globals *)ap_palloc(pchild, sizeof(struct thread_globals));
+    apr_create_pool(&pchild, pconf);
+    *ppthread_globals = (struct thread_globals *)apr_palloc(pchild, sizeof(struct thread_globals));
     THREAD_GLOBAL(child_num) = (int)child_num_arg;
     sc_parent_rec = ap_scoreboard_image->parent + THREAD_GLOBAL(child_num);
     THREAD_GLOBAL(pchild) = pchild;
-    ap_create_pool(&ptrans, pchild);
+    apr_create_pool(&ptrans, pchild);
 
     if (setup_listen_poll(pchild, &listen_poll)) {
 	clean_child_exit(1);
@@ -787,7 +787,7 @@ static void child_main(void *child_num_arg)
     while (!ap_stop_signalled()) {
         BUFF *conn_io;
         int srv;
-        ap_socket_t *sd;
+        apr_socket_t *sd;
 
 	/* Prepare to receive a SIGUSR1 due to graceful restart so that
 	 * we can exit cleanly.
@@ -801,7 +801,7 @@ static void child_main(void *child_num_arg)
 
 	current_conn = NULL;
 
-	ap_clear_pool(ptrans);
+	apr_clear_pool(ptrans);
 
 	if ((ap_max_requests_per_child > 0
 	     && requests_this_child++ >= ap_max_requests_per_child)) {
@@ -824,7 +824,7 @@ static void child_main(void *child_num_arg)
 	for (;;) {
 	    if (ap_listeners->next) {
 		/* more than one socket */
-                srv = ap_poll(listen_poll, &nsds, -1);
+                srv = apr_poll(listen_poll, &nsds, -1);
 
 		if (srv != APR_SUCCESS) {
 		    /* Single Unix documents select as returning errnos
@@ -846,13 +846,13 @@ static void child_main(void *child_num_arg)
                 lr = first_lr;
 		
                 do {
-                    ap_int16_t event;
+                    apr_int16_t event;
 
 		    if (!lr) {
 			lr = ap_listeners;
 		    }
 
-                    ap_get_revents(&event, lr->sd, listen_poll);
+                    apr_get_revents(&event, lr->sd, listen_poll);
 
 		    if (event == APR_POLLIN) {
                         first_lr = lr->next;
@@ -875,7 +875,7 @@ static void child_main(void *child_num_arg)
 	     * defer the exit
 	     */
             THREAD_GLOBAL(usr1_just_die) = 0;
-            rv = ap_accept(&csd, sd, ptrans);
+            rv = apr_accept(&csd, sd, ptrans);
 
 	    if (rv == APR_SUCCESS)
 		break;		/* We have a socket ready for reading */
@@ -891,7 +891,7 @@ static void child_main(void *child_num_arg)
 		 * lead to never-ending loops here.  So it seems best
 		 * to just exit in most cases.
 		 */
-                switch (ap_canonical_error(rv)) {
+                switch (apr_canonical_error(rv)) {
 #ifdef EPROTO
 		    /* EPROTO on certain older kernels really means
 		     * ECONNABORTED, so we need to ignore it for them.
@@ -972,7 +972,7 @@ static void child_main(void *child_num_arg)
 	if (iol == NULL) {
           ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, 0, NULL,
                        "error attaching to socket");
-	    ap_close_socket(csd);
+	    apr_close_socket(csd);
 	    continue;
         }
 
@@ -1178,11 +1178,11 @@ static void perform_idle_server_maintenance(void)
  * Executive routines.
  */
 
-int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
+int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
 {
     int remaining_children_to_start;
     int i;
-    ap_status_t status;
+    apr_status_t status;
 
     pconf = _pconf;
     ap_server_conf = s;
@@ -1208,7 +1208,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
                          "Error allocating thread local storage"
                          "Apache is exiting!");
         } else {
-          *ppthread_globals = (struct thread_globals *)ap_palloc(pconf, sizeof(struct thread_globals));
+          *ppthread_globals = (struct thread_globals *)apr_palloc(pconf, sizeof(struct thread_globals));
         }
     }
 
@@ -1254,7 +1254,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
 	 * extra child
 	 */
 	if (tid >= 0) {
-            ap_proc_t dummyproc;
+            apr_proc_t dummyproc;
             dummyproc.pid = tid;
             ap_process_child_status(&dummyproc, status);
 	    /* non-fatal death... note that it's gone in the scoreboard. */
@@ -1318,7 +1318,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
         ap_listen_rec *lr;
 
         for (lr = ap_listeners; lr; lr = lr->next) {
-            ap_close_socket(lr->sd);
+            apr_close_socket(lr->sd);
             DosSleep(0);
         }
 
@@ -1408,7 +1408,7 @@ int ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s)
     return 0;
 }
 
-static void spmt_os2_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp)
+static void spmt_os2_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
 {
     one_process = !!getenv("ONE_PROCESS");
 
@@ -1422,7 +1422,7 @@ static void spmt_os2_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *pt
     ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
     ap_extended_status = 0;
 
-    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
 }
 
 static void spmt_os2_hooks(void)
@@ -1532,7 +1532,7 @@ static const char *set_max_requests(cmd_parms *cmd, void *dummy, char *arg)
 
 static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg) 
 {
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     const char *fname;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -1540,12 +1540,12 @@ static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg)
     }
 
     fname = ap_server_root_relative(cmd->pool, arg);
-    if ((ap_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
+    if ((apr_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
         (finfo.filetype != APR_DIR)) {
-	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
+	return apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
 			  " does not exist or is not a directory", NULL);
     }
-    ap_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
     return NULL;
 }
 
@@ -1588,7 +1588,7 @@ module MODULE_VAR_EXPORT mpm_spmt_os2_module = {
     NULL,			/* merge per-directory config structures */
     NULL,			/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    spmt_os2_cmds,		/* command ap_table_t */
+    spmt_os2_cmds,		/* command apr_table_t */
     NULL,			/* handlers */
     spmt_os2_hooks,		/* register_hooks */
 };
diff --git a/server/mpm/winnt/mpm_winnt.c b/server/mpm/winnt/mpm_winnt.c
index b5bec3e..7361c21 100644
--- a/server/mpm/winnt/mpm_winnt.c
+++ b/server/mpm/winnt/mpm_winnt.c
@@ -68,7 +68,7 @@
 #include "apr_strings.h"
 #include "ap_mpm.h"
 #include "ap_config.h"
-#include "ap_listen.h"
+#include "apr_listen.h"
 #include "mpm_default.h"
 #include "ap_iol.h"
 #include "mpm_winnt.h"
@@ -97,7 +97,7 @@ static struct fd_set listenfds;
 static int num_listenfds = 0;
 static SOCKET listenmaxfd = INVALID_SOCKET;
 
-static ap_pool_t *pconf;		/* Pool for config stuff */
+static apr_pool_t *pconf;		/* Pool for config stuff */
 
 static char ap_coredump_dir[MAX_STRING_LEN];
 
@@ -114,7 +114,7 @@ int ap_daemons_to_start=0;
 
 static event *exit_event;
 HANDLE maintenance_event;
-ap_lock_t *start_mutex;
+apr_lock_t *start_mutex;
 DWORD my_pid;
 DWORD parent_pid;
 
@@ -142,11 +142,11 @@ FARPROC ap_load_dll_func(ap_dlltoken_e fnLib, char* fnName, int ordinal)
         return GetProcAddress(lateDllHandle[fnLib], fnName);
 }
 
-static ap_status_t socket_cleanup(void *sock)
+static apr_status_t socket_cleanup(void *sock)
 {
-    ap_socket_t *thesocket = sock;
+    apr_socket_t *thesocket = sock;
     SOCKET sd;
-    if (ap_get_os_sock(&sd, thesocket) == APR_SUCCESS) {
+    if (apr_get_os_sock(&sd, thesocket) == APR_SUCCESS) {
         closesocket(sd);
     }
     return APR_SUCCESS;
@@ -354,10 +354,10 @@ API_EXPORT(void) ap_start_restart(int gracefully)
 
 void setup_signal_names(char *prefix)
 {
-    ap_snprintf(signal_name_prefix, sizeof(signal_name_prefix), prefix);    
-    ap_snprintf(signal_shutdown_name, sizeof(signal_shutdown_name), 
+    apr_snprintf(signal_name_prefix, sizeof(signal_name_prefix), prefix);    
+    apr_snprintf(signal_shutdown_name, sizeof(signal_shutdown_name), 
 	"%s_shutdown", signal_name_prefix);    
-    ap_snprintf(signal_restart_name, sizeof(signal_restart_name), 
+    apr_snprintf(signal_restart_name, sizeof(signal_restart_name), 
 	"%s_restart", signal_name_prefix);    
 }
 
@@ -396,7 +396,7 @@ static ap_inline ap_listen_rec *find_ready_listener(fd_set * main_fds)
     SOCKET nsd;
 
     for (lr = head_listener; lr ; lr = lr->next) {
-        ap_get_os_sock(&nsd, lr->sd);
+        apr_get_os_sock(&nsd, lr->sd);
 	if (FD_ISSET(nsd, main_fds)) {
 	    head_listener = lr->next;
             if (head_listener == NULL)
@@ -423,7 +423,7 @@ static int setup_listeners(server_rec *s)
     for (lr = ap_listeners; lr; lr = lr->next) {
         num_listeners++;
         if (lr->sd != NULL) {
-            ap_get_os_sock(&nsd, lr->sd);
+            apr_get_os_sock(&nsd, lr->sd);
             FD_SET(nsd, &listenfds);
             if (listenmaxfd == INVALID_SOCKET || nsd > listenmaxfd) {
                 listenmaxfd = nsd;
@@ -453,7 +453,7 @@ static int setup_inherited_listeners(server_rec *s)
 
     if (ap_listeners == NULL) {
         ap_listen_rec *lr;
-        lr = ap_palloc(s->process->pool, sizeof(ap_listen_rec));
+        lr = apr_palloc(s->process->pool, sizeof(ap_listen_rec));
         if (!lr)
             return 0;
         lr->sd = NULL;
@@ -489,7 +489,7 @@ static int setup_inherited_listeners(server_rec *s)
                 listenmaxfd = nsd;
             }
         }
-        ap_put_os_sock(&lr->sd, &nsd, pconf);
+        apr_put_os_sock(&lr->sd, &nsd, pconf);
         lr->count = 0;
     }
     /* Now, read the AcceptExCompPort from the parent */
@@ -514,7 +514,7 @@ static void bind_listeners_to_completion_port()
     if (osver.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS) {
         for (lr = ap_listeners; lr; lr = lr->next) {
             int nsd;
-            ap_get_os_sock(&nsd,lr->sd);
+            apr_get_os_sock(&nsd,lr->sd);
             CreateIoCompletionPort((HANDLE) nsd, AcceptExCompPort, 0, 0);
         }
     }
@@ -602,7 +602,7 @@ typedef struct globals_s {
     semaphore *jobsemaphore;
     joblist *jobhead;
     joblist *jobtail;
-    ap_lock_t *jobmutex;
+    apr_lock_t *jobmutex;
     int jobcount;
 
 } globals;
@@ -641,7 +641,7 @@ static void add_job(int sock)
     new_job->next = NULL;
     new_job->sock = sock;
 
-    ap_lock(allowed_globals.jobmutex);
+    apr_lock(allowed_globals.jobmutex);
 
     if (allowed_globals.jobtail != NULL)
 	allowed_globals.jobtail->next = new_job;
@@ -651,7 +651,7 @@ static void add_job(int sock)
     allowed_globals.jobcount++;
     release_semaphore(allowed_globals.jobsemaphore);
 
-    ap_unlock(allowed_globals.jobmutex);
+    apr_unlock(allowed_globals.jobmutex);
 }
 
 static int remove_job(void)
@@ -660,10 +660,10 @@ static int remove_job(void)
     int sock;
 
     acquire_semaphore(allowed_globals.jobsemaphore);
-    ap_lock(allowed_globals.jobmutex);
+    apr_lock(allowed_globals.jobmutex);
 
     if (shutdown_in_progress && !allowed_globals.jobhead) {
-        ap_unlock(allowed_globals.jobmutex);
+        apr_unlock(allowed_globals.jobmutex);
 	return (-1);
     }
     job = allowed_globals.jobhead;
@@ -671,7 +671,7 @@ static int remove_job(void)
     allowed_globals.jobhead = job->next;
     if (allowed_globals.jobhead == NULL)
 	allowed_globals.jobtail = NULL;
-    ap_unlock(allowed_globals.jobmutex);
+    apr_unlock(allowed_globals.jobmutex);
     sock = job->sock;
     free(job);
 
@@ -726,7 +726,7 @@ static void accept_and_queue_connections(void * dummy)
 	    lr = find_ready_listener(&main_fds);
 	    if (lr != NULL) {
                 /* fetch the native socket descriptor */
-                ap_get_os_sock(&nsd, lr->sd);
+                apr_get_os_sock(&nsd, lr->sd);
 	    }
 	}
 
@@ -757,24 +757,24 @@ static PCOMP_CONTEXT win9x_get_connection(PCOMP_CONTEXT context)
 
     if (context == NULL) {
         /* allocate the completion context and the transaction pool */
-        context = ap_pcalloc(pconf, sizeof(COMP_CONTEXT));
+        context = apr_pcalloc(pconf, sizeof(COMP_CONTEXT));
         if (!context) {
             ap_log_error(APLOG_MARK,APLOG_ERR, GetLastError(), server_conf,
-                         "win9x_get_connection: ap_pcalloc() failed. Process will exit.");
+                         "win9x_get_connection: apr_pcalloc() failed. Process will exit.");
             return NULL;
         }
-        ap_create_pool(&context->ptrans, pconf);
+        apr_create_pool(&context->ptrans, pconf);
     }
     
 
     while (1) {
-        ap_clear_pool(context->ptrans);        
+        apr_clear_pool(context->ptrans);        
         context->accept_socket = remove_job();
         if (context->accept_socket == -1) {
             return NULL;
         }
 	len = sizeof(struct sockaddr);
-        context->sa_server = ap_palloc(context->ptrans, len);
+        context->sa_server = apr_palloc(context->ptrans, len);
         if (getsockname(context->accept_socket, 
                         context->sa_server, &len)== SOCKET_ERROR) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, WSAGetLastError(), server_conf, 
@@ -782,7 +782,7 @@ static PCOMP_CONTEXT win9x_get_connection(PCOMP_CONTEXT context)
             continue;
         }
         len = sizeof(struct sockaddr);
-        context->sa_client = ap_palloc(context->ptrans, len);
+        context->sa_client = apr_palloc(context->ptrans, len);
         if ((getpeername(context->accept_socket,
                          context->sa_client, &len)) == SOCKET_ERROR) {
             ap_log_error(APLOG_MARK, APLOG_WARNING, WSAGetLastError(), server_conf, 
@@ -840,7 +840,7 @@ static void drain_acceptex_complport(HANDLE hComplPort, BOOLEAN bCleanUp)
         }
     }
 }
-static int create_acceptex_context(ap_pool_t *_pconf, ap_listen_rec *lr) 
+static int create_acceptex_context(apr_pool_t *_pconf, ap_listen_rec *lr) 
 {
     PCOMP_CONTEXT context;
     DWORD BytesRead;
@@ -848,10 +848,10 @@ static int create_acceptex_context(ap_pool_t *_pconf, ap_listen_rec *lr)
     int lasterror;
 
     /* allocate the completion context */
-    context = ap_pcalloc(_pconf, sizeof(COMP_CONTEXT));
+    context = apr_pcalloc(_pconf, sizeof(COMP_CONTEXT));
     if (!context) {
         ap_log_error(APLOG_MARK,APLOG_ERR, GetLastError(), server_conf,
-                     "create_acceptex_context: ap_pcalloc() failed. Process will exit.");
+                     "create_acceptex_context: apr_pcalloc() failed. Process will exit.");
         return -1;
     }
 
@@ -865,7 +865,7 @@ static int create_acceptex_context(ap_pool_t *_pconf, ap_listen_rec *lr)
     }
 
     /* create and initialize the accept socket */
-    ap_get_os_sock(&nsd, context->lr->sd);
+    apr_get_os_sock(&nsd, context->lr->sd);
     context->accept_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
     if (context->accept_socket == INVALID_SOCKET) {
         ap_log_error(APLOG_MARK,APLOG_ERR, WSAGetLastError(), server_conf,
@@ -882,7 +882,7 @@ static int create_acceptex_context(ap_pool_t *_pconf, ap_listen_rec *lr)
         /* Not a failure condition. Keep running. */
     }
 
-    ap_create_pool(&context->ptrans, _pconf);
+    apr_create_pool(&context->ptrans, _pconf);
     context->conn_io = ap_bcreate(context->ptrans, B_RDWR);
     context->recv_buf = context->conn_io->inbase;
     context->recv_buf_size = context->conn_io->bufsiz - 2*PADDED_ADDR_SIZE;
@@ -908,7 +908,7 @@ static int create_acceptex_context(ap_pool_t *_pconf, ap_listen_rec *lr)
 
     return 0;
 }
-static ap_inline ap_status_t reset_acceptex_context(PCOMP_CONTEXT context) 
+static ap_inline apr_status_t reset_acceptex_context(PCOMP_CONTEXT context) 
 {
     DWORD BytesRead;
     SOCKET nsd;
@@ -917,7 +917,7 @@ static ap_inline ap_status_t reset_acceptex_context(PCOMP_CONTEXT context)
     context->lr->count++;
 
     /* recreate and initialize the accept socket if it is not being reused */
-    ap_get_os_sock(&nsd, context->lr->sd);
+    apr_get_os_sock(&nsd, context->lr->sd);
     if (context->accept_socket == INVALID_SOCKET) {
         context->accept_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
         if (context->accept_socket == INVALID_SOCKET) {
@@ -939,7 +939,7 @@ static ap_inline ap_status_t reset_acceptex_context(PCOMP_CONTEXT context)
     }
 
     /* reset the completion context */
-    ap_clear_pool(context->ptrans);
+    apr_clear_pool(context->ptrans);
     context->sock = NULL;
     context->conn_io = ap_bcreate(context->ptrans, B_RDWR);
     context->recv_buf = context->conn_io->inbase;
@@ -1055,12 +1055,12 @@ static PCOMP_CONTEXT winnt_get_connection(PCOMP_CONTEXT context)
      * but only if we are not in the process of shutting down
      */
     if (!shutdown_in_progress) {
-        ap_lock(allowed_globals.jobmutex);
+        apr_lock(allowed_globals.jobmutex);
         context->lr->count--;
         if (context->lr->count < 2) {
             SetEvent(maintenance_event);
         }
-        ap_unlock(allowed_globals.jobmutex);
+        apr_unlock(allowed_globals.jobmutex);
     }
 
     /* Received a connection */
@@ -1104,7 +1104,7 @@ static void worker_main(int child_num)
     while (1) {
         conn_rec *c;
         ap_iol *iol;
-        ap_int32_t disconnected;
+        apr_int32_t disconnected;
 
         /* Grab a connection off the network */
         if (osver.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
@@ -1117,7 +1117,7 @@ static void worker_main(int child_num)
         if (!context)
             break;
         sock_disable_nagle(context->accept_socket);
-        ap_put_os_sock(&context->sock, &context->accept_socket, context->ptrans);
+        apr_put_os_sock(&context->sock, &context->accept_socket, context->ptrans);
 
         iol = ap_iol_attach_socket(context->ptrans, context->sock);
         if (iol == NULL) {
@@ -1135,7 +1135,7 @@ static void worker_main(int child_num)
         ap_process_connection(c);
 
 
-        ap_getsocketopt(context->sock, APR_SO_DISCONNECTED, &disconnected);
+        apr_getsocketopt(context->sock, APR_SO_DISCONNECTED, &disconnected);
         if (disconnected) {
             /* Kill the clean-up registered by the iol. We want to leave 
              * the accept socket open because we are about to try to 
@@ -1201,7 +1201,7 @@ static void create_listeners()
  */
 static void child_main()
 {
-    ap_status_t status;
+    apr_status_t status;
     HANDLE child_events[2];
     char* exit_event_name;
     int nthreads = ap_threads_per_child;
@@ -1211,18 +1211,18 @@ static void child_main()
     time_t end_time;
     int i;
     int cld;
-    ap_pool_t *pchild;
+    apr_pool_t *pchild;
 
 
     /* This is the child process or we are running in single process
      * mode.
      */
-    exit_event_name = ap_psprintf(pconf, "apC%d", my_pid);
-    setup_signal_names(ap_psprintf(pconf,"ap%d", parent_pid));
+    exit_event_name = apr_psprintf(pconf, "apC%d", my_pid);
+    setup_signal_names(apr_psprintf(pconf,"ap%d", parent_pid));
 
     if (one_process) {
         /* Single process mode */
-        ap_create_lock(&start_mutex,APR_MUTEX, APR_CROSS_PROCESS,signal_name_prefix,pconf);
+        apr_create_lock(&start_mutex,APR_MUTEX, APR_CROSS_PROCESS,signal_name_prefix,pconf);
         exit_event = CreateEvent(NULL, TRUE, FALSE, exit_event_name);
 
         setup_listeners(server_conf);
@@ -1230,7 +1230,7 @@ static void child_main()
     }
     else {
         /* Child process mode */
-        ap_child_init_lock(&start_mutex, signal_name_prefix, pconf);
+        apr_child_init_lock(&start_mutex, signal_name_prefix, pconf);
         exit_event = OpenEvent(EVENT_ALL_ACCESS, FALSE, exit_event_name);
         ap_log_error(APLOG_MARK, APLOG_INFO, APR_SUCCESS, server_conf,
                      "Child %d: exit_event_name = %s", my_pid, exit_event_name);
@@ -1247,16 +1247,16 @@ static void child_main()
     ap_assert(exit_event);
     ap_assert(maintenance_event);
 
-    ap_create_pool(&pchild, pconf);
+    apr_create_pool(&pchild, pconf);
     allowed_globals.jobsemaphore = create_semaphore(0);
-    ap_create_lock(&allowed_globals.jobmutex, APR_MUTEX, APR_INTRAPROCESS, NULL, pchild);
+    apr_create_lock(&allowed_globals.jobmutex, APR_MUTEX, APR_INTRAPROCESS, NULL, pchild);
 
     /*
      * Wait until we have permission to start accepting connections.
      * start_mutex is used to ensure that only one child ever
      * goes into the listen/accept loop at once.
      */
-    status = ap_lock(start_mutex);
+    status = apr_lock(start_mutex);
     if (status != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK,APLOG_ERR, status, server_conf,
                      "Child %d: Failed to acquire the start_mutex. Process will exit.", my_pid);
@@ -1360,7 +1360,7 @@ static void child_main()
         workers_may_exit = 1;
 
         /* Unblock threads blocked on the completion port */
-        ap_lock(allowed_globals.jobmutex);
+        apr_lock(allowed_globals.jobmutex);
         while (g_blocked_threads > 0) {
             ap_log_error(APLOG_MARK,APLOG_INFO, APR_SUCCESS, server_conf, 
                          "Child %d: %d threads blocked on the completion port", my_pid, g_blocked_threads);
@@ -1369,11 +1369,11 @@ static void child_main()
             }
             Sleep(1000);
         }
-        ap_unlock(allowed_globals.jobmutex);
+        apr_unlock(allowed_globals.jobmutex);
 
         /* Cancel any remaining pending AcceptEx completion contexts */
         for (lr = ap_listeners; lr != NULL; lr = lr->next) {
-            ap_get_os_sock(&nsd,lr->sd);
+            apr_get_os_sock(&nsd,lr->sd);
             CancelIo((HANDLE) nsd);
         }
 
@@ -1386,7 +1386,7 @@ static void child_main()
      */
     ap_log_error(APLOG_MARK,APLOG_INFO, APR_SUCCESS, server_conf, 
                  "Child %d: Releasing the start mutex", my_pid);
-    ap_unlock(start_mutex);
+    apr_unlock(start_mutex);
 
     /* Give busy worker threads a chance to service their connections.
      * Kill them off if they take too long
@@ -1413,9 +1413,9 @@ static void child_main()
 
     CloseHandle(AcceptExCompPort);
     destroy_semaphore(allowed_globals.jobsemaphore);
-    ap_destroy_lock(allowed_globals.jobmutex);
+    apr_destroy_lock(allowed_globals.jobmutex);
 
-    ap_destroy_pool(pchild);
+    apr_destroy_pool(pchild);
     CloseHandle(exit_event);
 }
 
@@ -1464,7 +1464,7 @@ static void cleanup_process(HANDLE *handles, HANDLE *events, int position, int *
     (*processes)--;
 }
 
-static int create_process(ap_pool_t *p, HANDLE *handles, HANDLE *events, int *processes)
+static int create_process(apr_pool_t *p, HANDLE *handles, HANDLE *events, int *processes)
 {
     int rv;
     char buf[1024];
@@ -1506,13 +1506,13 @@ static int create_process(ap_pool_t *p, HANDLE *handles, HANDLE *events, int *pr
     }
 
     /* Build the command line */
-    pCommand = ap_psprintf(p, "\"%s\"", buf);  
+    pCommand = apr_psprintf(p, "\"%s\"", buf);  
     for (i = 1; i < server_conf->process->argc; i++) {
-        pCommand = ap_pstrcat(p, pCommand, " \"", server_conf->process->argv[i], "\"", NULL);
+        pCommand = apr_pstrcat(p, pCommand, " \"", server_conf->process->argv[i], "\"", NULL);
     }
 
     /* Build the environment, since Win9x disrespects the active env */
-    pEnvVar = ap_psprintf(p, "AP_PARENT_PID=%i", parent_pid);
+    pEnvVar = apr_psprintf(p, "AP_PARENT_PID=%i", parent_pid);
     /*
      * Win32's CreateProcess call requires that the environment
      * be passed in an environment block, a null terminated block of
@@ -1525,7 +1525,7 @@ static int create_process(ap_pool_t *p, HANDLE *handles, HANDLE *events, int *pr
         i++;
     }
 
-    pEnvBlock = (char *)ap_pcalloc(p, iEnvBlockLen + strlen(pEnvVar) + 1);
+    pEnvBlock = (char *)apr_pcalloc(p, iEnvBlockLen + strlen(pEnvVar) + 1);
     strcpy(pEnvBlock, pEnvVar);
     pEnvVar = strchr(pEnvBlock, '\0') + 1;
 
@@ -1579,7 +1579,7 @@ static int create_process(ap_pool_t *p, HANDLE *handles, HANDLE *events, int *pr
     sa.nLength = sizeof(sa);
     sa.bInheritHandle = TRUE;
     sa.lpSecurityDescriptor = NULL;        
-    kill_event = CreateEvent(&sa, TRUE, FALSE, ap_psprintf(pconf,"apC%d", pi.dwProcessId));
+    kill_event = CreateEvent(&sa, TRUE, FALSE, apr_psprintf(pconf,"apC%d", pi.dwProcessId));
     if (!kill_event) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, GetLastError(), server_conf,
                      "Parent: Could not create exit event for child process");
@@ -1602,8 +1602,8 @@ static int create_process(ap_pool_t *p, HANDLE *handles, HANDLE *events, int *pr
      * (returned by dup socket) to the child */
     for (lr = ap_listeners; lr; lr = lr->next) {
         int nsd;
-        lpWSAProtocolInfo = ap_pcalloc(p, sizeof(WSAPROTOCOL_INFO));
-        ap_get_os_sock(&nsd,lr->sd);
+        lpWSAProtocolInfo = apr_pcalloc(p, sizeof(WSAPROTOCOL_INFO));
+        apr_get_os_sock(&nsd,lr->sd);
         ap_log_error(APLOG_MARK, APLOG_INFO, APR_SUCCESS, server_conf,
                      "Parent: Duplicating socket %d and sending it to child process %d", nsd, pi.dwProcessId);
         if (WSADuplicateSocket(nsd, pi.dwProcessId,
@@ -1721,7 +1721,7 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
          * We are making a big assumption here that the child process, once signaled,
          * will REALLY go away. Since this is a restart, we do not want to hold the 
          * new child process up waiting for the old child to die. Remove the old 
-         * child out of the process_handles ap_table_t and hope for the best...
+         * child out of the process_handles apr_table_t and hope for the best...
          */
         for (i = 0; i < children_to_kill; i++) {
             if (SetEvent(process_kill_events[i]) == 0)
@@ -1733,7 +1733,7 @@ static int master_main(server_rec *s, HANDLE shutdown_event, HANDLE restart_even
     else {
         /* A child process must have exited because of a fatal error condition (seg fault, etc.). 
          * Remove the dead process 
-         * from the process_handles and process_kill_events ap_table_t and create a new
+         * from the process_handles and process_kill_events apr_table_t and create a new
          * child process.
          * TODO: Consider restarting the child immediately without looping through http_main
          * and without rereading the configuration. Will need this if we ever support multiple 
@@ -1796,14 +1796,14 @@ die_now:
 /* service_nt_main_fn needs to append the StartService() args 
  * outside of our call stack and thread as the service starts...
  */
-ap_array_header_t *mpm_new_argv;
+apr_array_header_t *mpm_new_argv;
 
 /* Remember service_to_start failures to log and fail in pre_config.
  * Remember inst_argc and inst_argv for installing or starting the
  * service after we preflight the config.
  */
 
-static ap_status_t service_to_start_success;
+static apr_status_t service_to_start_success;
 static int inst_argc;
 static char **inst_argv;
     
@@ -1817,8 +1817,8 @@ void winnt_rewrite_args(process_rec *process)
      * We can't leave this phase until we know our identity
      * and modify the command arguments appropriately.
      */
-    ap_status_t service_named = SERVICE_UNNAMED;
-    ap_status_t rv;
+    apr_status_t service_named = SERVICE_UNNAMED;
+    apr_status_t rv;
     char *def_server_root;
     char fnbuf[MAX_PATH];
     char optbuf[3];
@@ -1877,7 +1877,7 @@ void winnt_rewrite_args(process_rec *process)
                      "Failed to get the running module's file name");
         exit(1);
     }
-    def_server_root = (char *) ap_filename_of_pathname(fnbuf);
+    def_server_root = (char *) apr_filename_of_pathname(fnbuf);
     if (def_server_root > fnbuf) {
         *(def_server_root - 1) = '\0';
         def_server_root = ap_os_canonical_filename(process->pool, fnbuf);
@@ -1889,19 +1889,19 @@ void winnt_rewrite_args(process_rec *process)
      * initial pre-flight of the config parser.
      */
 
-    mpm_new_argv = ap_make_array(process->pool, process->argc + 2, sizeof(char *));
-    new_arg = (char**) ap_push_array(mpm_new_argv);
+    mpm_new_argv = apr_make_array(process->pool, process->argc + 2, sizeof(char *));
+    new_arg = (char**) apr_push_array(mpm_new_argv);
     *new_arg = (char *) process->argv[0];
     
-    new_arg = (char**) ap_push_array(mpm_new_argv);
+    new_arg = (char**) apr_push_array(mpm_new_argv);
     *new_arg = "-d";
-    new_arg = (char**) ap_push_array(mpm_new_argv);
+    new_arg = (char**) apr_push_array(mpm_new_argv);
     *new_arg = def_server_root;
 
     fixed_args = mpm_new_argv->nelts;
 
     optbuf[0] = '-'; optbuf[2] = '\0';
-    while (ap_getopt(process->argc, (char**) process->argv, 
+    while (apr_getopt(process->argc, (char**) process->argv, 
                      "n:k:iu" AP_SERVER_BASEARGS, 
                      &opt, process->pool) == APR_SUCCESS) {
         switch (opt) {
@@ -1921,16 +1921,16 @@ void winnt_rewrite_args(process_rec *process)
             break;
         default:
             optbuf[1] = (char) opt;
-            new_arg = (char**) ap_push_array(mpm_new_argv);
-            *new_arg = ap_pstrdup(process->pool, optbuf);
+            new_arg = (char**) apr_push_array(mpm_new_argv);
+            *new_arg = apr_pstrdup(process->pool, optbuf);
             if (ap_optarg) {
-                new_arg = (char**) ap_push_array(mpm_new_argv);
+                new_arg = (char**) apr_push_array(mpm_new_argv);
                 *new_arg = ap_optarg;
             }
             break;
         }
     }
-    /* Set optreset and optind to allow ap_getopt to work correctly
+    /* Set optreset and optind to allow apr_getopt to work correctly
      * when called from http_main.c
      */
     ap_optreset = 1;
@@ -2010,7 +2010,7 @@ void winnt_rewrite_args(process_rec *process)
 }
 
 
-static void winnt_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp) 
+static void winnt_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp) 
 {
     /* Handle the following SCM aspects in this phase:
      *
@@ -2020,7 +2020,7 @@ static void winnt_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp
      *
      * in these cases we -don't- care if httpd.conf has config errors!
      */
-    ap_status_t rv;
+    apr_status_t rv;
 
     if (!strcasecmp(signal_arg, "runservice")
             && (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
@@ -2047,13 +2047,13 @@ static void winnt_pre_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp
     ap_pid_fname = DEFAULT_PIDLOG;
     max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
 
-    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
 }
 
-static void winnt_post_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptemp, server_rec* server)
+static void winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec* server)
 {
     static int restart_num = 0;
-    ap_status_t rv = 0;
+    apr_status_t rv = 0;
 
     server_conf = server;
     
@@ -2094,7 +2094,7 @@ static void winnt_post_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptem
              * across a restart
              */
             PSECURITY_ATTRIBUTES sa = GetNullACL();  /* returns NULL if invalid (Win95?) */
-            setup_signal_names(ap_psprintf(pconf,"ap%d", parent_pid));
+            setup_signal_names(apr_psprintf(pconf,"ap%d", parent_pid));
             if (osver.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS) {
                 /* Create the AcceptEx IoCompletionPort once in the parent.
                  * The completion port persists across restarts. 
@@ -2163,7 +2163,7 @@ static void winnt_post_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptem
              * Ths start mutex is used during a restart to prevent more than one 
              * child process from entering the accept loop at once.
              */
-            ap_create_lock(&start_mutex,APR_MUTEX, APR_CROSS_PROCESS, signal_name_prefix,
+            apr_create_lock(&start_mutex,APR_MUTEX, APR_CROSS_PROCESS, signal_name_prefix,
                                server_conf->process->pool);
         }
     }
@@ -2173,7 +2173,7 @@ static void winnt_post_config(ap_pool_t *pconf, ap_pool_t *plog, ap_pool_t *ptem
     }
 }
 
-API_EXPORT(int) ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s )
+API_EXPORT(int) ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s )
 {
     static int restart = 0;            /* Default is "not a restart" */
 
@@ -2202,7 +2202,7 @@ API_EXPORT(int) ap_mpm_run(ap_pool_t *_pconf, ap_pool_t *plog, server_rec *s )
                              server_conf, "removed PID file %s (pid=%ld)",
                              pidfile, GetCurrentProcessId());
             }
-            ap_destroy_lock(start_mutex);
+            apr_destroy_lock(start_mutex);
 
             CloseHandle(restart_event);
             CloseHandle(shutdown_event);
@@ -2280,7 +2280,7 @@ static const char *set_max_requests(cmd_parms *cmd, void *dummy, char *arg)
 
 static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg) 
 {
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
     const char *fname;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
     if (err != NULL) {
@@ -2288,12 +2288,12 @@ static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg)
     }
 
     fname = ap_server_root_relative(cmd->pool, arg);
-    if ((ap_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
+    if ((apr_stat(&finfo, fname, cmd->pool) != APR_SUCCESS) || 
         (finfo.filetype != APR_DIR)) {
-	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
+	return apr_pstrcat(cmd->pool, "CoreDumpDirectory ", fname, 
 			  " does not exist or is not a directory", NULL);
     }
-    ap_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
+    apr_cpystrn(ap_coredump_dir, fname, sizeof(ap_coredump_dir));
     return NULL;
 }
 
@@ -2310,7 +2310,7 @@ API_EXPORT(void) ap_reset_connection_status(long conn_id)
     /* NOP */
 }
 
-API_EXPORT(ap_array_header_t *) ap_get_status_table(ap_pool_t *p)
+API_EXPORT(apr_array_header_t *) ap_get_status_table(apr_pool_t *p)
 {
     /* NOP */
     return NULL;
@@ -2336,7 +2336,7 @@ MODULE_VAR_EXPORT module mpm_winnt_module = {
     NULL,			/* merge per-directory config structures */
     NULL,			/* create per-server config structure */
     NULL,			/* merge per-server config structures */
-    winnt_cmds,		        /* command ap_table_t */
+    winnt_cmds,		        /* command apr_table_t */
     NULL,			/* handlers */
     winnt_hooks 		/* register_hooks */
 };
diff --git a/server/mpm/winnt/mpm_winnt.h b/server/mpm/winnt/mpm_winnt.h
index 4beb22c..4d6c753 100644
--- a/server/mpm/winnt/mpm_winnt.h
+++ b/server/mpm/winnt/mpm_winnt.h
@@ -59,24 +59,24 @@
 #ifndef APACHE_MPM_WINNT_H
 #define APACHE_MPM_WINNT_H
 
-#include "ap_listen.h"
+#include "apr_listen.h"
 
 /* From registry.c: */
 
-ap_status_t ap_registry_create_key(const char *key);
-ap_status_t ap_registry_delete_key(const char *key);
+apr_status_t ap_registry_create_key(const char *key);
+apr_status_t ap_registry_delete_key(const char *key);
 
-ap_status_t ap_registry_store_value(const char *key, const char *name, 
+apr_status_t ap_registry_store_value(const char *key, const char *name, 
                                     const char *value);
-ap_status_t ap_registry_get_value(ap_pool_t *p, const char *key, 
+apr_status_t ap_registry_get_value(apr_pool_t *p, const char *key, 
                                   const char *name, char **ppValue);
-ap_status_t ap_registry_store_array(ap_pool_t *p, const char *key, 
+apr_status_t ap_registry_store_array(apr_pool_t *p, const char *key, 
                                     const char *name, int nelts, 
                                     char const* const* elts);
-ap_status_t ap_registry_get_array(ap_pool_t *p, const char *key, 
+apr_status_t ap_registry_get_array(apr_pool_t *p, const char *key, 
                                   const char *name, 
-                                  ap_array_header_t **parray);
-ap_status_t ap_registry_delete_value(const char *key, const char *name);
+                                  apr_array_header_t **parray);
+apr_status_t ap_registry_delete_value(const char *key, const char *name);
 
 
 /* From service.c: */
@@ -91,20 +91,20 @@ ap_status_t ap_registry_delete_value(const char *key, const char *name);
 extern char *service_name;
 extern char *display_name;
 
-ap_status_t mpm_service_set_name(ap_pool_t *p, char *name);
-ap_status_t mpm_merge_service_args(ap_pool_t *p, ap_array_header_t *args, 
+apr_status_t mpm_service_set_name(apr_pool_t *p, char *name);
+apr_status_t mpm_merge_service_args(apr_pool_t *p, apr_array_header_t *args, 
                                    int fixed_args);
 
-ap_status_t mpm_service_to_start(void);
-ap_status_t mpm_service_started(void);
-ap_status_t mpm_service_install(ap_pool_t *ptemp, int argc, 
+apr_status_t mpm_service_to_start(void);
+apr_status_t mpm_service_started(void);
+apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc, 
                                 char const* const* argv);
-ap_status_t mpm_service_uninstall(void);
+apr_status_t mpm_service_uninstall(void);
 
-ap_status_t mpm_service_start(ap_pool_t *ptemp, int argc, 
+apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc, 
                               char const* const* argv);
 
-void mpm_signal_service(ap_pool_t *ptemp, int signal);
+void mpm_signal_service(apr_pool_t *ptemp, int signal);
 
 void mpm_service_stopping(void);
 
@@ -128,12 +128,12 @@ void signal_parent(int type);
 typedef struct CompContext {
     OVERLAPPED Overlapped;
     SOCKET accept_socket;
-    ap_socket_t *sock;
+    apr_socket_t *sock;
     ap_listen_rec *lr;
     BUFF *conn_io;
     char *recv_buf;
     int  recv_buf_size;
-    ap_pool_t *ptrans;
+    apr_pool_t *ptrans;
     struct sockaddr *sa_server;
     int sa_server_len;
     struct sockaddr *sa_client;
diff --git a/server/mpm/winnt/registry.c b/server/mpm/winnt/registry.c
index d51cbcf..be0bfaa 100644
--- a/server/mpm/winnt/registry.c
+++ b/server/mpm/winnt/registry.c
@@ -97,7 +97,7 @@
  */
 #define return_error(rv) return (SetLastError(rv), rv);
 
-ap_status_t ap_registry_create_key(const char *key)
+apr_status_t ap_registry_create_key(const char *key)
 {
     HKEY hKey = HKEY_LOCAL_MACHINE;
     HKEY hKeyNext;
@@ -107,7 +107,7 @@ ap_status_t ap_registry_create_key(const char *key)
     DWORD result;
     int rv;
 
-    ap_cpystrn(keystr, key, sizeof(keystr) - 1);
+    apr_cpystrn(keystr, key, sizeof(keystr) - 1);
     	
     /* Walk the tree, creating at each stage if necessary */
     while (parsekey) {
@@ -141,15 +141,15 @@ ap_status_t ap_registry_create_key(const char *key)
     return_error(rv);
 }
 
-ap_status_t ap_registry_delete_key(const char *key)
+apr_status_t ap_registry_delete_key(const char *key)
 {
-    ap_status_t rv;
+    apr_status_t rv;
     HKEY hKey;
     int nSize = 0;
     char tempkey[MAX_PATH + 1];
     char *parsekey;
 
-    ap_cpystrn(tempkey, key, sizeof(parsekey) - 1);
+    apr_cpystrn(tempkey, key, sizeof(parsekey) - 1);
     parsekey = strrchr(tempkey, '\\');
     
     if (parsekey) {
@@ -184,9 +184,9 @@ ap_status_t ap_registry_delete_key(const char *key)
  * The return value is APR_SUCCESS, APR_ENOPATH, APR_NOTFOUND, or the OS error
  */
 
-ap_status_t ap_registry_get_value(ap_pool_t *p, const char *key, const char *name, char **ppValue)
+apr_status_t ap_registry_get_value(apr_pool_t *p, const char *key, const char *name, char **ppValue)
 {
-    ap_status_t rv;
+    apr_status_t rv;
     HKEY hKey;
     int nSize = 0;
 
@@ -216,7 +216,7 @@ ap_status_t ap_registry_get_value(ap_pool_t *p, const char *key, const char *nam
     if (rv != ERROR_SUCCESS)
 	return_error(rv);
 
-    *ppValue = ap_palloc(p, nSize);
+    *ppValue = apr_palloc(p, nSize);
     rv = RegQueryValueEx(hKey, 
 			 name,		/* key name */
 			 NULL,		/* reserved */
@@ -232,12 +232,12 @@ ap_status_t ap_registry_get_value(ap_pool_t *p, const char *key, const char *nam
     return_error(rv);
 }
 
-ap_status_t ap_registry_get_array(ap_pool_t *p, const char *key, const char *name, ap_array_header_t **parray)
+apr_status_t ap_registry_get_array(apr_pool_t *p, const char *key, const char *name, apr_array_header_t **parray)
 {
     char *pValue;
     char *tmp;
     char **newelem;
-    ap_status_t rv;
+    apr_status_t rv;
     HKEY hKey;
     int nSize = 0;
 
@@ -272,7 +272,7 @@ ap_status_t ap_registry_get_array(ap_pool_t *p, const char *key, const char *nam
     }
     else 
     {
-        pValue = ap_palloc(p, nSize);
+        pValue = apr_palloc(p, nSize);
         rv = RegQueryValueEx(hKey, 
 			     name,		/* key name */
 			     NULL,		/* reserved */
@@ -289,14 +289,14 @@ ap_status_t ap_registry_get_array(ap_pool_t *p, const char *key, const char *nam
             ++tmp;
         }
     
-        *parray = ap_make_array(p, nSize, sizeof(char *));
+        *parray = apr_make_array(p, nSize, sizeof(char *));
         tmp = pValue;
-        newelem = (char **) ap_push_array(*parray);
+        newelem = (char **) apr_push_array(*parray);
         *newelem = tmp;
         while (tmp[0] || tmp[1])
         {
             if (!tmp[0]) {
-                newelem = (char **) ap_push_array(*parray);
+                newelem = (char **) apr_push_array(*parray);
                 *newelem = tmp + 1;
             }
             ++tmp;
@@ -323,7 +323,7 @@ ap_status_t ap_registry_get_array(ap_pool_t *p, const char *key, const char *nam
  * logged via aplog_error().
  */
 
-ap_status_t ap_registry_store_value(const char *key, const char *name, const char *value)
+apr_status_t ap_registry_store_value(const char *key, const char *name, const char *value)
 {
     long rv;
     HKEY hKey;
@@ -375,7 +375,7 @@ ap_status_t ap_registry_store_value(const char *key, const char *name, const cha
     return_error(rv);
 }
 
-ap_status_t ap_registry_store_array(ap_pool_t *p, const char *key, const char *name, int nelts, char const* const* elts)
+apr_status_t ap_registry_store_array(apr_pool_t *p, const char *key, const char *name, int nelts, char const* const* elts)
 {
     int  bufsize, i;
     char *buf, *tmp;
@@ -416,7 +416,7 @@ ap_status_t ap_registry_store_array(ap_pool_t *p, const char *key, const char *n
     if (!nelts) 
         ++bufsize;
 
-    buf = ap_palloc(p, bufsize);
+    buf = apr_palloc(p, bufsize);
     tmp = buf;
     for (i = 0; i < nelts; ++i)
     {
@@ -450,9 +450,9 @@ ap_status_t ap_registry_store_array(ap_pool_t *p, const char *key, const char *n
 
 /* A key or value that does not exist is _not_ an error while deleting. */
 
-ap_status_t ap_registry_delete_value(const char *key, const char *name)
+apr_status_t ap_registry_delete_value(const char *key, const char *name)
 {
-    ap_status_t rv;
+    apr_status_t rv;
     HKEY hKey;
     
     rv = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
@@ -483,9 +483,9 @@ ap_status_t ap_registry_delete_value(const char *key, const char *name)
  * dir will contain an empty string), or -1 if there was
  * an error getting the key.
  */
-ap_status_t ap_registry_get_server_root(ap_pool_t *p, char **buf)
+apr_status_t ap_registry_get_server_root(apr_pool_t *p, char **buf)
 {
-    ap_status_t rv;
+    apr_status_t rv;
 
     rv = ap_registry_get_value(p, REGKEY, "ServerRoot", buf);
     if (rv) 
@@ -501,7 +501,7 @@ ap_status_t ap_registry_get_server_root(ap_pool_t *p, char **buf)
  * logged via aplog_error().
  */
 
-ap_status_t ap_registry_set_server_root(char *dir)
+apr_status_t ap_registry_set_server_root(char *dir)
 {
     return ap_registry_store_value(REGKEY, "ServerRoot", dir);
 }
diff --git a/server/mpm/winnt/service.c b/server/mpm/winnt/service.c
index 3e5b177..aec1d49 100644
--- a/server/mpm/winnt/service.c
+++ b/server/mpm/winnt/service.c
@@ -512,7 +512,7 @@ long __stdcall service_stderr_thread(LPVOID hPipe)
  * primary server thread... so now we _really_ need a placeholder!
  * The winnt_rewrite_args has created and shared mpm_new_argv with us.
  */
-extern ap_array_header_t *mpm_new_argv;
+extern apr_array_header_t *mpm_new_argv;
 
 static void __stdcall service_nt_main_fn(DWORD argc, LPTSTR *argv)
 {
@@ -592,7 +592,7 @@ static void __stdcall service_nt_main_fn(DWORD argc, LPTSTR *argv)
     if (argc > 1) 
     {
         char **cmb_data;
-        cmb_data = ap_palloc(mpm_new_argv->cont, 
+        cmb_data = apr_palloc(mpm_new_argv->cont, 
                              (mpm_new_argv->nelts + argc - 1) * sizeof(char *));
 
         /* mpm_new_argv remains first (of lower significance) */
@@ -624,7 +624,7 @@ static void __stdcall service_nt_main_fn(DWORD argc, LPTSTR *argv)
 
 DWORD WINAPI service_nt_dispatch_thread(LPVOID nada)
 {
-    ap_status_t rv = APR_SUCCESS;
+    apr_status_t rv = APR_SUCCESS;
 
     SERVICE_TABLE_ENTRY dispatchTable[] =
     {
@@ -645,32 +645,32 @@ DWORD WINAPI service_nt_dispatch_thread(LPVOID nada)
 }
 
 
-ap_status_t mpm_service_set_name(ap_pool_t *p, char *name)
+apr_status_t mpm_service_set_name(apr_pool_t *p, char *name)
 {
     char *key_name;
     
-    service_name = ap_palloc(p, strlen(name) + 1);
-    ap_collapse_spaces(service_name, name);
-    key_name = ap_psprintf(p, SERVICECONFIG, service_name);
+    service_name = apr_palloc(p, strlen(name) + 1);
+    apr_collapse_spaces(service_name, name);
+    key_name = apr_psprintf(p, SERVICECONFIG, service_name);
     if (ap_registry_get_value(p, key_name, "DisplayName", &display_name) == APR_SUCCESS)
         return APR_SUCCESS;
 
     /* Take the given literal name if there is no service entry */
-    display_name = ap_pstrdup(p, name);
+    display_name = apr_pstrdup(p, name);
     return APR_ENOFILE;
 }
 
 
-ap_status_t mpm_merge_service_args(ap_pool_t *p, 
-                                   ap_array_header_t *args, 
+apr_status_t mpm_merge_service_args(apr_pool_t *p, 
+                                   apr_array_header_t *args, 
                                    int fixed_args)
 {
-    ap_array_header_t *svc_args = NULL;
+    apr_array_header_t *svc_args = NULL;
     char conf_key[MAX_PATH];
     char **cmb_data;
-    ap_status_t rv;
+    apr_status_t rv;
 
-    ap_snprintf(conf_key, sizeof(conf_key), SERVICEPARAMS, service_name);
+    apr_snprintf(conf_key, sizeof(conf_key), SERVICEPARAMS, service_name);
     rv = ap_registry_get_array(p, conf_key, "ConfigArgs", &svc_args);
     if (rv != APR_SUCCESS) {
         // TODO: More message?
@@ -686,7 +686,7 @@ ap_status_t mpm_merge_service_args(ap_pool_t *p,
      * time to _prepend_ the default arguments for the server from 
      * the service's default arguments (all others override them)...
      */
-    cmb_data = ap_palloc(p, (args->nelts + svc_args->nelts) * sizeof(char *));
+    cmb_data = apr_palloc(p, (args->nelts + svc_args->nelts) * sizeof(char *));
 
     /* First three args (argv[0], -f, path) remain first */
     memcpy (cmb_data, args->elts, args->elt_size * fixed_args);
@@ -733,7 +733,7 @@ void service_stopped(void)
 }
 
 
-ap_status_t mpm_service_to_start(void)
+apr_status_t mpm_service_to_start(void)
 {
     HANDLE waitfor[2];
 
@@ -782,7 +782,7 @@ ap_status_t mpm_service_to_start(void)
 }
 
 
-ap_status_t mpm_service_started(void)
+apr_status_t mpm_service_started(void)
 {
     if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
     {
@@ -803,19 +803,19 @@ void mpm_service_stopping(void)
 }
 
 
-ap_status_t mpm_service_install(ap_pool_t *ptemp, int argc, 
+apr_status_t mpm_service_install(apr_pool_t *ptemp, int argc, 
                                 char const* const* argv)
 {
     char key_name[MAX_PATH];
     char exe_path[MAX_PATH];
     char *launch_cmd;
-    ap_status_t(rv);
+    apr_status_t(rv);
     
     printf("Installing the %s service\n", display_name);
 
     if (GetModuleFileName(NULL, exe_path, sizeof(exe_path)) == 0)
     {
-        ap_status_t rv = GetLastError();
+        apr_status_t rv = GetLastError();
         ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
                      "GetModuleFileName failed");
         return rv;
@@ -836,7 +836,7 @@ ap_status_t mpm_service_install(ap_pool_t *ptemp, int argc,
             return (rv);
         }
 
-        launch_cmd = ap_psprintf(ptemp, "\"%s\" -k runservice", exe_path);
+        launch_cmd = apr_psprintf(ptemp, "\"%s\" -k runservice", exe_path);
 
         /* RPCSS is the Remote Procedure Call (RPC) Locator required for DCOM 
          * communication pipes.  I am far from convinced we should add this to
@@ -872,7 +872,7 @@ ap_status_t mpm_service_install(ap_pool_t *ptemp, int argc,
     else /* osver.dwPlatformId != VER_PLATFORM_WIN32_NT */
     {
         /* Store the launch command in the registry */
-        launch_cmd = ap_psprintf(ptemp, "\"%s\" -n %s -k runservice", 
+        launch_cmd = apr_psprintf(ptemp, "\"%s\" -n %s -k runservice", 
                                  exe_path, service_name);
         rv = ap_registry_store_value(SERVICECONFIG9X, service_name, launch_cmd);
         if (rv != APR_SUCCESS) {
@@ -882,7 +882,7 @@ ap_status_t mpm_service_install(ap_pool_t *ptemp, int argc,
             return (rv);
         }
 
-        ap_snprintf(key_name, sizeof(key_name), SERVICECONFIG, service_name);
+        apr_snprintf(key_name, sizeof(key_name), SERVICECONFIG, service_name);
         rv = ap_registry_store_value(key_name, "DisplayName", display_name);
         if (rv != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, 
@@ -894,7 +894,7 @@ ap_status_t mpm_service_install(ap_pool_t *ptemp, int argc,
 
     /* For both WinNT & Win9x store the service ConfigArgs in the registry...
      */
-    ap_snprintf(key_name, sizeof(key_name), SERVICEPARAMS, service_name);
+    apr_snprintf(key_name, sizeof(key_name), SERVICEPARAMS, service_name);
     rv = ap_registry_store_array(ptemp, key_name, "ConfigArgs", argc, argv);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL, 
@@ -906,10 +906,10 @@ ap_status_t mpm_service_install(ap_pool_t *ptemp, int argc,
 }
 
 
-ap_status_t mpm_service_uninstall(void)
+apr_status_t mpm_service_uninstall(void)
 {
     char key_name[MAX_PATH];
-    ap_status_t rv;
+    apr_status_t rv;
 
     if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
     {
@@ -972,7 +972,7 @@ ap_status_t mpm_service_uninstall(void)
         }
         
         /* we blast Services/us, not just the Services/us/Parameters branch */
-        ap_snprintf(key_name, sizeof(key_name), SERVICECONFIG, service_name);
+        apr_snprintf(key_name, sizeof(key_name), SERVICECONFIG, service_name);
         if (ap_registry_delete_key(key_name)) 
         {
             rv = GetLastError();
@@ -1009,10 +1009,10 @@ static int signal_service_transition(SC_HANDLE schService, DWORD signal, DWORD p
 }
 
 
-ap_status_t mpm_service_start(ap_pool_t *ptemp, int argc, 
+apr_status_t mpm_service_start(apr_pool_t *ptemp, int argc, 
                               char const* const* argv)
 {
-    ap_status_t rv;
+    apr_status_t rv;
     
     printf("Starting the %s service\n", display_name);
 
@@ -1052,7 +1052,7 @@ ap_status_t mpm_service_start(ap_pool_t *ptemp, int argc,
         }
         
         argc += 1;
-        start_argv = ap_palloc(ptemp, argc * sizeof(char**));
+        start_argv = apr_palloc(ptemp, argc * sizeof(char**));
         start_argv[0] = service_name;
         if (argc > 1)
             memcpy(start_argv + 1, argv, (argc - 1) * sizeof(char**));
@@ -1096,16 +1096,16 @@ ap_status_t mpm_service_start(ap_pool_t *ptemp, int argc,
         
         if (GetModuleFileName(NULL, exe_path, sizeof(exe_path)) == 0)
         {
-            ap_status_t rv = GetLastError();
+            apr_status_t rv = GetLastError();
             ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, rv, NULL,
                          "GetModuleFileName failed");
             return rv;
         }
         
-        pCommand = ap_psprintf(ptemp, "\"%s\" -n %s -k runservice", 
+        pCommand = apr_psprintf(ptemp, "\"%s\" -n %s -k runservice", 
                                exe_path, service_name);  
         for (i = 0; i < argc; ++i) {
-            pCommand = ap_pstrcat(ptemp, pCommand, " \"", argv[i], "\"", NULL);
+            pCommand = apr_pstrcat(ptemp, pCommand, " \"", argv[i], "\"", NULL);
         }
         
         memset(&si, 0, sizeof(si));
@@ -1149,7 +1149,7 @@ ap_status_t mpm_service_start(ap_pool_t *ptemp, int argc,
 
 /* signal is zero to stop, non-zero for restart */
 
-void mpm_signal_service(ap_pool_t *ptemp, int signal)
+void mpm_signal_service(apr_pool_t *ptemp, int signal)
 {
     int success = FALSE;
     
@@ -1239,7 +1239,7 @@ void mpm_signal_service(ap_pool_t *ptemp, int signal)
         printf("The %s service is %s.\n", display_name, 
                signal ? "restarting" : "stopping");
 
-        ap_snprintf(prefix, sizeof(prefix), "ap%ld", (long)service_pid);
+        apr_snprintf(prefix, sizeof(prefix), "ap%ld", (long)service_pid);
         setup_signal_names(prefix);
 
         if (!signal) 
diff --git a/server/mpm_common.c b/server/mpm_common.c
index 5825d68..144390d 100644
--- a/server/mpm_common.c
+++ b/server/mpm_common.c
@@ -86,7 +86,7 @@ void ap_reclaim_child_processes(int terminate)
 {
     int i;
     long int waittime = 1024 * 16;      /* in usecs */
-    ap_status_t waitret;
+    apr_status_t waitret;
     int tries;
     int not_dead_yet;
     int max_daemons = ap_get_max_daemons();
@@ -99,19 +99,19 @@ void ap_reclaim_child_processes(int terminate)
          * Set delay with an exponential backoff.
          */
         waittime = waittime * 4;
-        ap_sleep(waittime);
+        apr_sleep(waittime);
 
         /* now see who is done */
         not_dead_yet = 0;
         for (i = 0; i < max_daemons; ++i) {
             pid_t pid = MPM_CHILD_PID(i);
-            ap_proc_t proc;
+            apr_proc_t proc;
 
             if (pid == 0)
                 continue;
 
             proc.pid = pid;
-            waitret = ap_wait_proc(&proc, APR_NOWAIT);
+            waitret = apr_wait_proc(&proc, APR_NOWAIT);
             if (waitret != APR_CHILD_NOTDONE) {
                 MPM_NOTE_CHILD_KILLED(i);
                 continue;
@@ -164,7 +164,7 @@ void ap_reclaim_child_processes(int terminate)
                 break;
             }
         }
-        ap_check_other_child();
+        apr_check_other_child();
         if (!not_dead_yet) {
             /* nothing left to wait for */
             break;
@@ -179,19 +179,19 @@ void ap_reclaim_child_processes(int terminate)
 #endif
 static int wait_or_timeout_counter;
 
-void ap_wait_or_timeout(ap_wait_t *status, ap_proc_t *ret, ap_pool_t *p)
+void ap_wait_or_timeout(ap_wait_t *status, apr_proc_t *ret, apr_pool_t *p)
 {
-    ap_status_t rv;
+    apr_status_t rv;
 
     ++wait_or_timeout_counter;
     if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {
         wait_or_timeout_counter = 0;
 #if APR_HAS_OTHER_CHILD
-        ap_probe_writable_fds();
+        apr_probe_writable_fds();
 #endif
     }
-    rv = ap_wait_all_procs(ret, status, APR_NOWAIT, p);
-    if (ap_canonical_error(rv) == APR_EINTR) {
+    rv = apr_wait_all_procs(ret, status, APR_NOWAIT, p);
+    if (apr_canonical_error(rv) == APR_EINTR) {
         ret->pid = -1;
         return;
     }
@@ -203,12 +203,12 @@ void ap_wait_or_timeout(ap_wait_t *status, ap_proc_t *ret, ap_pool_t *p)
         return;
     }
 #endif
-    ap_sleep(SCOREBOARD_MAINTENANCE_INTERVAL);
+    apr_sleep(SCOREBOARD_MAINTENANCE_INTERVAL);
     ret->pid = -1;
     return;
 }
 
-void ap_process_child_status(ap_proc_t *pid, ap_wait_t status)
+void ap_process_child_status(apr_proc_t *pid, ap_wait_t status)
 {
     /* Child died... if it died due to a fatal error,
         * we should simply bail out.
diff --git a/server/rfc1413.c b/server/rfc1413.c
index e28cb9e..faab9f2 100644
--- a/server/rfc1413.c
+++ b/server/rfc1413.c
@@ -108,19 +108,19 @@ int ap_rfc1413_timeout = RFC1413_TIMEOUT;	/* Global so it can be changed */
 
 /* bind_connect - bind both ends of a socket */
 /* Ambarish fix this. Very broken */
-static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
+static int get_rfc1413(apr_socket_t *sock, const char *local_ip,
 		       const char *rmt_ip, 
 		       char user[RFC1413_USERLEN+1], server_rec *srv)
 {
     unsigned int rmt_port, our_port;
     unsigned int sav_rmt_port, sav_our_port;
-    ap_status_t status;
+    apr_status_t status;
     int i;
     char *cp;
     char buffer[RFC1413_MAXDATA + 1];
     int buflen;
 #ifdef CHARSET_EBCDIC
-    ap_size_t inbytes_left, outbytes_left;
+    apr_size_t inbytes_left, outbytes_left;
 #endif
 
     /*
@@ -132,10 +132,10 @@ static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
      * addresses from the query socket.
      */
 
-    ap_set_local_port(sock, ANY_PORT);
-    ap_set_local_ipaddr(sock, local_ip);
+    apr_set_local_port(sock, ANY_PORT);
+    apr_set_local_ipaddr(sock, local_ip);
 
-    if ((status = ap_bind(sock)) != APR_SUCCESS) {
+    if ((status = apr_bind(sock)) != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv,
 		    "bind: rfc1413: Error binding to local port");
 	return -1;
@@ -145,16 +145,16 @@ static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
  * errors from connect usually imply the remote machine doesn't support
  * the service
  */
-    ap_set_remote_port(sock, RFC1413_PORT);
-    ap_set_remote_ipaddr(sock, rmt_ip);
+    apr_set_remote_port(sock, RFC1413_PORT);
+    apr_set_remote_ipaddr(sock, rmt_ip);
                     
-    if (ap_connect(sock, NULL) != APR_SUCCESS)
+    if (apr_connect(sock, NULL) != APR_SUCCESS)
         return -1;
-    ap_get_local_port(&sav_our_port, sock);
-    ap_get_remote_port(&sav_rmt_port, sock);
+    apr_get_local_port(&sav_our_port, sock);
+    apr_get_remote_port(&sav_rmt_port, sock);
 
 /* send the data */
-    buflen = ap_snprintf(buffer, sizeof(buffer), "%u,%u\r\n", sav_rmt_port,
+    buflen = apr_snprintf(buffer, sizeof(buffer), "%u,%u\r\n", sav_rmt_port,
 		sav_our_port);
 #ifdef CHARSET_EBCDIC
     inbytes_left = outbytes_left = buflen;
@@ -165,10 +165,10 @@ static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
     /* send query to server. Handle short write. */
     i = 0;
     while(i < strlen(buffer)) {
-        ap_ssize_t j = strlen(buffer + i);
-        ap_status_t status;
-	status  = ap_send(sock, buffer+i, &j);
-	if (status != APR_SUCCESS && ap_canonical_error(status) != APR_EINTR) {
+        apr_ssize_t j = strlen(buffer + i);
+        apr_status_t status;
+	status  = apr_send(sock, buffer+i, &j);
+	if (status != APR_SUCCESS && apr_canonical_error(status) != APR_EINTR) {
 	    ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv,
 		         "write: rfc1413: error sending request");
 	    return -1;
@@ -191,10 +191,10 @@ static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
      * this allows it to work on both ASCII and EBCDIC machines.
      */
     while((cp = strchr(buffer, '\012')) == NULL && i < sizeof(buffer) - 1) {
-        ap_ssize_t j = sizeof(buffer) - 1 - i;
-        ap_status_t status;
-	status = ap_recv(sock, buffer+i, &j);
-	if (status != APR_SUCCESS && ap_canonical_error(status) != APR_EINTR) {
+        apr_ssize_t j = sizeof(buffer) - 1 - i;
+        apr_status_t status;
+	status = apr_recv(sock, buffer+i, &j);
+	if (status != APR_SUCCESS && apr_canonical_error(status) != APR_EINTR) {
 	    ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv,
 			"read: rfc1413: error reading response");
 	    return -1;
@@ -233,14 +233,14 @@ static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
 /* rfc1413 - return remote user name, given socket structures */
 char *ap_rfc1413(conn_rec *conn, server_rec *srv)
 {
-    ap_status_t status;
+    apr_status_t status;
     static char user[RFC1413_USERLEN + 1];	/* XXX */
     static char *result;
-    static ap_socket_t *sock;
+    static apr_socket_t *sock;
 
     result = FROM_UNKNOWN;
 
-    if ((status = ap_create_tcp_socket(&sock, conn->pool)) != APR_SUCCESS) {
+    if ((status = apr_create_tcp_socket(&sock, conn->pool)) != APR_SUCCESS) {
 	ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv,
 		    "socket: rfc1413: error creating socket");
 	conn->remote_logname = result;
@@ -248,7 +248,7 @@ char *ap_rfc1413(conn_rec *conn, server_rec *srv)
 
     if (get_rfc1413(sock, conn->local_ip, conn->remote_ip, user, srv) >= 0)
         result = user;
-    ap_close_socket(sock);
+    apr_close_socket(sock);
     conn->remote_logname = result;
 
     return conn->remote_logname;
diff --git a/server/util.c b/server/util.c
index 7f84a80..afad57f 100644
--- a/server/util.c
+++ b/server/util.c
@@ -126,7 +126,7 @@
  * Examine a field value (such as a media-/content-type) string and return
  * it sans any parameters; e.g., strip off any ';charset=foo' and the like.
  */
-API_EXPORT(char *) ap_field_noparam(ap_pool_t *p, const char *intype)
+API_EXPORT(char *) ap_field_noparam(apr_pool_t *p, const char *intype)
 {
     const char *semi;
 
@@ -134,19 +134,19 @@ API_EXPORT(char *) ap_field_noparam(ap_pool_t *p, const char *intype)
 
     semi = ap_strchr_c(intype, ';');
     if (semi == NULL) {
-	return ap_pstrdup(p, intype);
+	return apr_pstrdup(p, intype);
     } 
     else {
 	while ((semi > intype) && ap_isspace(semi[-1])) {
 	    semi--;
 	}
-	return ap_pstrndup(p, intype, semi - intype);
+	return apr_pstrndup(p, intype, semi - intype);
     }
 }
 
-API_EXPORT(char *) ap_ht_time(ap_pool_t *p, ap_time_t t, const char *fmt, int gmt)
+API_EXPORT(char *) ap_ht_time(apr_pool_t *p, apr_time_t t, const char *fmt, int gmt)
 {
-    ap_size_t retcode;
+    apr_size_t retcode;
     char ts[MAX_STRING_LEN];
     char tf[MAX_STRING_LEN];
     ap_exploded_time_t xt;
@@ -155,7 +155,7 @@ API_EXPORT(char *) ap_ht_time(ap_pool_t *p, ap_time_t t, const char *fmt, int gm
 	const char *f;
 	char *strp;
 
-        ap_explode_gmt(&xt, t);
+        apr_explode_gmt(&xt, t);
 	/* Convert %Z to "GMT" and %z to "+0000";
 	 * on hosts that do not have a time zone string in struct tm,
 	 * strftime must assume its argument is local time.
@@ -187,13 +187,13 @@ API_EXPORT(char *) ap_ht_time(ap_pool_t *p, ap_time_t t, const char *fmt, int gm
 	fmt = tf;
     }
     else {
-        ap_explode_localtime(&xt, t);
+        apr_explode_localtime(&xt, t);
     }
 
     /* check return code? */
-    ap_strftime(ts, &retcode, MAX_STRING_LEN, fmt, &xt);
+    apr_strftime(ts, &retcode, MAX_STRING_LEN, fmt, &xt);
     ts[MAX_STRING_LEN - 1] = '\0';
-    return ap_pstrdup(p, ts);
+    return apr_pstrdup(p, ts);
 }
 
 /* Roy owes Rob beer. */
@@ -275,30 +275,30 @@ API_EXPORT(int) ap_is_matchexp(const char *str)
  * regfree() doesn't clear it. So we don't allow it.
  */
 
-static ap_status_t regex_cleanup(void *preg)
+static apr_status_t regex_cleanup(void *preg)
 {
     regfree((regex_t *) preg);
     return APR_SUCCESS;
 }
 
-API_EXPORT(regex_t *) ap_pregcomp(ap_pool_t *p, const char *pattern,
+API_EXPORT(regex_t *) ap_pregcomp(apr_pool_t *p, const char *pattern,
 				   int cflags)
 {
-    regex_t *preg = ap_palloc(p, sizeof(regex_t));
+    regex_t *preg = apr_palloc(p, sizeof(regex_t));
 
     if (regcomp(preg, pattern, cflags)) {
 	return NULL;
     }
 
-    ap_register_cleanup(p, (void *) preg, regex_cleanup, regex_cleanup);
+    apr_register_cleanup(p, (void *) preg, regex_cleanup, regex_cleanup);
 
     return preg;
 }
 
-API_EXPORT(void) ap_pregfree(ap_pool_t *p, regex_t * reg)
+API_EXPORT(void) ap_pregfree(apr_pool_t *p, regex_t * reg)
 {
     regfree(reg);
-    ap_kill_cleanup(p, (void *) reg, regex_cleanup);
+    apr_kill_cleanup(p, (void *) reg, regex_cleanup);
 }
 
 /*
@@ -365,7 +365,7 @@ API_EXPORT(size_t) ap_regerror(int errcode, const regex_t *preg, char *errbuf, s
  * AT&T V8 regexp package.
  */
 
-API_EXPORT(char *) ap_pregsub(ap_pool_t *p, const char *input, const char *source,
+API_EXPORT(char *) ap_pregsub(apr_pool_t *p, const char *input, const char *source,
 			   size_t nmatch, regmatch_t pmatch[])
 {
     const char *src = input;
@@ -377,7 +377,7 @@ API_EXPORT(char *) ap_pregsub(ap_pool_t *p, const char *input, const char *sourc
     if (!source)
 	return NULL;
     if (!nmatch)
-	return ap_pstrdup(p, src);
+	return apr_pstrdup(p, src);
 
     /* First pass, find the size */
 
@@ -402,7 +402,7 @@ API_EXPORT(char *) ap_pregsub(ap_pool_t *p, const char *input, const char *sourc
 
     }
 
-    dest = dst = ap_pcalloc(p, len + 1);
+    dest = dst = apr_pcalloc(p, len + 1);
 
     /* Now actually fill in the string */
 
@@ -552,7 +552,7 @@ API_EXPORT(char *) ap_make_dirstr_prefix(char *d, const char *s, int n)
 /*
  * return the parent directory name including trailing / of the file s
  */
-API_EXPORT(char *) ap_make_dirstr_parent(ap_pool_t *p, const char *s)
+API_EXPORT(char *) ap_make_dirstr_parent(apr_pool_t *p, const char *s)
 {
     const char *last_slash = ap_strrchr_c(s, '/');
     char *d;
@@ -560,10 +560,10 @@ API_EXPORT(char *) ap_make_dirstr_parent(ap_pool_t *p, const char *s)
 
     if (last_slash == NULL) {
 	/* XXX: well this is really broken if this happens */
-	return (ap_pstrdup(p, "/"));
+	return (apr_pstrdup(p, "/"));
     }
     l = (last_slash - s) + 1;
-    d = ap_palloc(p, l + 1);
+    d = apr_palloc(p, l + 1);
     memcpy(d, s, l);
     d[l] = 0;
     return (d);
@@ -574,7 +574,7 @@ API_EXPORT(char *) ap_make_dirstr_parent(ap_pool_t *p, const char *s)
  * This function is deprecated.  Use one of the preceeding two functions
  * which are faster.
  */
-API_EXPORT(char *) ap_make_dirstr(ap_pool_t *p, const char *s, int n)
+API_EXPORT(char *) ap_make_dirstr(apr_pool_t *p, const char *s, int n)
 {
     register int x, f;
     char *res;
@@ -582,7 +582,7 @@ API_EXPORT(char *) ap_make_dirstr(ap_pool_t *p, const char *s, int n)
     for (x = 0, f = 0; s[x]; x++) {
 	if (s[x] == '/')
 	    if ((++f) == n) {
-		res = ap_palloc(p, x + 2);
+		res = apr_palloc(p, x + 2);
 		memcpy(res, s, x);
 		res[x] = '/';
 		res[x + 1] = '\0';
@@ -591,9 +591,9 @@ API_EXPORT(char *) ap_make_dirstr(ap_pool_t *p, const char *s, int n)
     }
 
     if (s[strlen(s) - 1] == '/')
-	return ap_pstrdup(p, s);
+	return apr_pstrdup(p, s);
     else
-	return ap_pstrcat(p, s, "/", NULL);
+	return apr_pstrcat(p, s, "/", NULL);
 }
 
 API_EXPORT(int) ap_count_dirs(const char *path)
@@ -625,23 +625,23 @@ API_EXPORT(void) ap_chdir_file(const char *file)
      * error... ah well. */
 }
 
-API_EXPORT(char *) ap_getword_nc(ap_pool_t *atrans, char **line, char stop)
+API_EXPORT(char *) ap_getword_nc(apr_pool_t *atrans, char **line, char stop)
 {
     return ap_getword(atrans, (const char **) line, stop);
 }
 
-API_EXPORT(char *) ap_getword(ap_pool_t *atrans, const char **line, char stop)
+API_EXPORT(char *) ap_getword(apr_pool_t *atrans, const char **line, char stop)
 {
     const char *pos = ap_strchr_c(*line, stop);
     char *res;
 
     if (!pos) {
-	res = ap_pstrdup(atrans, *line);
+	res = apr_pstrdup(atrans, *line);
 	*line += strlen(*line);
 	return res;
     }
 
-    res = ap_pstrndup(atrans, *line, pos - *line);
+    res = apr_pstrndup(atrans, *line, pos - *line);
 
     while (*pos == stop) {
 	++pos;
@@ -652,12 +652,12 @@ API_EXPORT(char *) ap_getword(ap_pool_t *atrans, const char **line, char stop)
     return res;
 }
 
-API_EXPORT(char *) ap_getword_white_nc(ap_pool_t *atrans, char **line)
+API_EXPORT(char *) ap_getword_white_nc(apr_pool_t *atrans, char **line)
 {
     return ap_getword_white(atrans, (const char **) line);
 }
 
-API_EXPORT(char *) ap_getword_white(ap_pool_t *atrans, const char **line)
+API_EXPORT(char *) ap_getword_white(apr_pool_t *atrans, const char **line)
 {
     int pos = -1, x;
     char *res;
@@ -670,13 +670,13 @@ API_EXPORT(char *) ap_getword_white(ap_pool_t *atrans, const char **line)
     }
 
     if (pos == -1) {
-	res = ap_pstrdup(atrans, *line);
+	res = apr_pstrdup(atrans, *line);
 	*line += strlen(*line);
 	return res;
     }
 
-    res = ap_palloc(atrans, pos + 1);
-    ap_cpystrn(res, *line, pos + 1);
+    res = apr_palloc(atrans, pos + 1);
+    apr_cpystrn(res, *line, pos + 1);
 
     while (ap_isspace((*line)[pos]))
 	++pos;
@@ -686,23 +686,23 @@ API_EXPORT(char *) ap_getword_white(ap_pool_t *atrans, const char **line)
     return res;
 }
 
-API_EXPORT(char *) ap_getword_nulls_nc(ap_pool_t *atrans, char **line, char stop)
+API_EXPORT(char *) ap_getword_nulls_nc(apr_pool_t *atrans, char **line, char stop)
 {
     return ap_getword_nulls(atrans, (const char **) line, stop);
 }
 
-API_EXPORT(char *) ap_getword_nulls(ap_pool_t *atrans, const char **line, char stop)
+API_EXPORT(char *) ap_getword_nulls(apr_pool_t *atrans, const char **line, char stop)
 {
     const char *pos = ap_strchr_c(*line, stop);
     char *res;
 
     if (!pos) {
-	res = ap_pstrdup(atrans, *line);
+	res = apr_pstrdup(atrans, *line);
 	*line += strlen(*line);
 	return res;
     }
 
-    res = ap_pstrndup(atrans, *line, pos - *line);
+    res = apr_pstrndup(atrans, *line, pos - *line);
 
     ++pos;
 
@@ -715,9 +715,9 @@ API_EXPORT(char *) ap_getword_nulls(ap_pool_t *atrans, const char **line, char s
  * all honored
  */
 
-static char *substring_conf(ap_pool_t *p, const char *start, int len, char quote)
+static char *substring_conf(apr_pool_t *p, const char *start, int len, char quote)
 {
-    char *result = ap_palloc(p, len + 2);
+    char *result = apr_palloc(p, len + 2);
     char *resp = result;
     int i;
 
@@ -737,12 +737,12 @@ static char *substring_conf(ap_pool_t *p, const char *start, int len, char quote
 #endif
 }
 
-API_EXPORT(char *) ap_getword_conf_nc(ap_pool_t *p, char **line)
+API_EXPORT(char *) ap_getword_conf_nc(apr_pool_t *p, char **line)
 {
     return ap_getword_conf(p, (const char **) line);
 }
 
-API_EXPORT(char *) ap_getword_conf(ap_pool_t *p, const char **line)
+API_EXPORT(char *) ap_getword_conf(apr_pool_t *p, const char **line)
 {
     const char *str = *line, *strend;
     char *res;
@@ -789,7 +789,7 @@ API_EXPORT(char *) ap_getword_conf(ap_pool_t *p, const char **line)
  * environment value does not exist, leave the ${ENV}
  * construct alone; it means something else.
  */
-API_EXPORT(const char *) ap_resolve_env(ap_pool_t *p, const char * word)
+API_EXPORT(const char *) ap_resolve_env(apr_pool_t *p, const char * word)
 {
        char tmp[ MAX_STRING_LEN ];
        const char *s, *e;
@@ -820,7 +820,7 @@ API_EXPORT(const char *) ap_resolve_env(ap_pool_t *p, const char * word)
        } while ((s=ap_strchr_c(word,'$')));
        strcat(tmp,word);
 
-       return ap_pstrdup(p,tmp);
+       return apr_pstrdup(p,tmp);
 }
 API_EXPORT(int) ap_cfg_closefile(configfile_t *cfp)
 {
@@ -831,36 +831,36 @@ API_EXPORT(int) ap_cfg_closefile(configfile_t *cfp)
     return (cfp->close == NULL) ? 0 : cfp->close(cfp->param);
 }
 
-static ap_status_t cfg_close(void *param)
+static apr_status_t cfg_close(void *param)
 {
-    ap_file_t *cfp = (ap_file_t *) param;
-    return (ap_close(cfp));
+    apr_file_t *cfp = (apr_file_t *) param;
+    return (apr_close(cfp));
 }
 
 static int cfg_getch(void *param)
 {
     char ch;
-    ap_file_t *cfp = (ap_file_t *) param;
-    if (ap_getc(&ch, cfp) == APR_SUCCESS)
+    apr_file_t *cfp = (apr_file_t *) param;
+    if (apr_getc(&ch, cfp) == APR_SUCCESS)
         return ch;
     return (int)EOF;
 }
 
 static void *cfg_getstr(void *buf, size_t bufsiz, void *param)
 {
-    ap_file_t *cfp = (ap_file_t *) param;
-    if (ap_fgets(buf, bufsiz, cfp) == APR_SUCCESS)
+    apr_file_t *cfp = (apr_file_t *) param;
+    if (apr_fgets(buf, bufsiz, cfp) == APR_SUCCESS)
         return buf;
     return NULL;
 }
 
 /* Open a configfile_t as FILE, return open configfile_t struct pointer */
-API_EXPORT(ap_status_t) ap_pcfg_openfile(configfile_t **ret_cfg, ap_pool_t *p, const char *name)
+API_EXPORT(apr_status_t) ap_pcfg_openfile(configfile_t **ret_cfg, apr_pool_t *p, const char *name)
 {
     configfile_t *new_cfg;
-    ap_file_t *file = NULL;
-    ap_finfo_t finfo;
-    ap_status_t status;
+    apr_file_t *file = NULL;
+    apr_finfo_t finfo;
+    apr_status_t status;
 #ifdef DEBUG
     char buf[120];
 #endif
@@ -878,17 +878,17 @@ API_EXPORT(ap_status_t) ap_pcfg_openfile(configfile_t **ret_cfg, ap_pool_t *p, c
         return APR_EACCES;
     }
 
-    status = ap_open(&file, name, APR_READ | APR_BUFFERED, APR_OS_DEFAULT, p);
+    status = apr_open(&file, name, APR_READ | APR_BUFFERED, APR_OS_DEFAULT, p);
 #ifdef DEBUG
     ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, NULL,
                 "Opening config file %s (%s)",
                 name, (status != APR_SUCCESS) ? 
-                ap_strerror(status, buf, sizeof(buf)) : "successful");
+                apr_strerror(status, buf, sizeof(buf)) : "successful");
 #endif
     if (status != APR_SUCCESS)
         return status;
 
-    status = ap_getfileinfo(&finfo, file);
+    status = apr_getfileinfo(&finfo, file);
     if (status != APR_SUCCESS)
         return status;
 
@@ -903,13 +903,13 @@ API_EXPORT(ap_status_t) ap_pcfg_openfile(configfile_t **ret_cfg, ap_pool_t *p, c
         ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, NULL,
                     "Access to file %s denied by server: not a regular file",
                     name);
-        ap_close(file);
+        apr_close(file);
         return APR_EBADF;
     }
 
-    new_cfg = ap_palloc(p, sizeof(*new_cfg));
+    new_cfg = apr_palloc(p, sizeof(*new_cfg));
     new_cfg->param = file;
-    new_cfg->name = ap_pstrdup(p, name);
+    new_cfg->name = apr_pstrdup(p, name);
     new_cfg->getch = (int (*)(void *)) cfg_getch;
     new_cfg->getstr = (void *(*)(void *, size_t, void *)) cfg_getstr;
     new_cfg->close = (int (*)(void *)) cfg_close;
@@ -920,13 +920,13 @@ API_EXPORT(ap_status_t) ap_pcfg_openfile(configfile_t **ret_cfg, ap_pool_t *p, c
 
 
 /* Allocate a configfile_t handle with user defined functions and params */
-API_EXPORT(configfile_t *) ap_pcfg_open_custom(ap_pool_t *p, const char *descr,
+API_EXPORT(configfile_t *) ap_pcfg_open_custom(apr_pool_t *p, const char *descr,
     void *param,
     int(*getch)(void *param),
     void *(*getstr) (void *buf, size_t bufsiz, void *param),
     int(*close_func)(void *param))
 {
-    configfile_t *new_cfg = ap_palloc(p, sizeof(*new_cfg));
+    configfile_t *new_cfg = apr_palloc(p, sizeof(*new_cfg));
 #ifdef DEBUG
     ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, NULL, "Opening config handler %s", descr);
 #endif
@@ -1151,7 +1151,7 @@ API_EXPORT(const char *) ap_size_list_item(const char **field, int *len)
  * the converted list item (or NULL if none) and the address pointed to by
  * field is shifted to the next non-comma, non-whitespace.
  */
-API_EXPORT(char *) ap_get_list_item(ap_pool_t *p, const char **field)
+API_EXPORT(char *) ap_get_list_item(apr_pool_t *p, const char **field)
 {
     const char *tok_start;
     const unsigned char *ptr;
@@ -1165,7 +1165,7 @@ API_EXPORT(char *) ap_get_list_item(ap_pool_t *p, const char **field)
     if ((tok_start = ap_size_list_item(field, &tok_len)) == NULL) {
         return NULL;
     }
-    token = ap_palloc(p, tok_len + 1);
+    token = apr_palloc(p, tok_len + 1);
 
     /* Scan the token again, but this time copy only the good bytes.
      * We skip extra whitespace and any whitespace around a '=', '/',
@@ -1240,7 +1240,7 @@ API_EXPORT(char *) ap_get_list_item(ap_pool_t *p, const char **field)
  * This would be much more efficient if we stored header fields as
  * an array of list items as they are received instead of a plain string.
  */
-API_EXPORT(int) ap_find_list_item(ap_pool_t *p, const char *line, const char *tok)
+API_EXPORT(int) ap_find_list_item(apr_pool_t *p, const char *line, const char *tok)
 {
     const unsigned char *pos;
     const unsigned char *ptr = (const unsigned char *)line;
@@ -1343,7 +1343,7 @@ API_EXPORT(int) ap_find_list_item(ap_pool_t *p, const char *line, const char *to
  * by whitespace at the caller's option.
  */
 
-API_EXPORT(char *) ap_get_token(ap_pool_t *p, const char **accept_line, int accept_white)
+API_EXPORT(char *) ap_get_token(apr_pool_t *p, const char **accept_line, int accept_white)
 {
     const char *ptr = *accept_line;
     const char *tok_start;
@@ -1370,7 +1370,7 @@ API_EXPORT(char *) ap_get_token(ap_pool_t *p, const char **accept_line, int acce
     }
 
     tok_len = ptr - tok_start;
-    token = ap_pstrndup(p, tok_start, tok_len);
+    token = apr_pstrndup(p, tok_start, tok_len);
 
     /* Advance accept_line pointer to the next non-white byte */
 
@@ -1383,7 +1383,7 @@ API_EXPORT(char *) ap_get_token(ap_pool_t *p, const char **accept_line, int acce
 
 
 /* find http tokens, see the definition of token from RFC2068 */
-API_EXPORT(int) ap_find_token(ap_pool_t *p, const char *line, const char *tok)
+API_EXPORT(int) ap_find_token(apr_pool_t *p, const char *line, const char *tok)
 {
     const unsigned char *start_token;
     const unsigned char *s;
@@ -1417,7 +1417,7 @@ API_EXPORT(int) ap_find_token(ap_pool_t *p, const char *line, const char *tok)
 }
 
 
-API_EXPORT(int) ap_find_last_token(ap_pool_t *p, const char *line, const char *tok)
+API_EXPORT(int) ap_find_last_token(apr_pool_t *p, const char *line, const char *tok)
 {
     int llen, tlen, lidx;
 
@@ -1435,13 +1435,13 @@ API_EXPORT(int) ap_find_last_token(ap_pool_t *p, const char *line, const char *t
     return (strncasecmp(&line[lidx], tok, tlen) == 0);
 }
 
-API_EXPORT(char *) ap_escape_shell_cmd(ap_pool_t *p, const char *str)
+API_EXPORT(char *) ap_escape_shell_cmd(apr_pool_t *p, const char *str)
 {
     char *cmd;
     unsigned char *d;
     const unsigned char *s;
 
-    cmd = ap_palloc(p, 2 * strlen(str) + 1);	/* Be safe */
+    cmd = apr_palloc(p, 2 * strlen(str) + 1);	/* Be safe */
     d = (unsigned char *)cmd;
     s = (const unsigned char *)str;
     for (; *s; ++s) {
@@ -1533,13 +1533,13 @@ API_EXPORT(int) ap_unescape_url(char *url)
 	return OK;
 }
 
-API_EXPORT(char *) ap_construct_server(ap_pool_t *p, const char *hostname,
+API_EXPORT(char *) ap_construct_server(apr_pool_t *p, const char *hostname,
 				    unsigned port, const request_rec *r)
 {
     if (ap_is_default_port(port, r))
-	return ap_pstrdup(p, hostname);
+	return apr_pstrdup(p, hostname);
     else {
-	return ap_psprintf(p, "%s:%u", hostname, port);
+	return apr_psprintf(p, "%s:%u", hostname, port);
     }
 }
 
@@ -1581,9 +1581,9 @@ static ap_inline unsigned char *c2x(unsigned what, unsigned char *where)
  * something with a '/' in it (and thus does not prefix "./").
  */
 
-API_EXPORT(char *) ap_escape_path_segment(ap_pool_t *p, const char *segment)
+API_EXPORT(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
 {
-    char *copy = ap_palloc(p, 3 * strlen(segment) + 1);
+    char *copy = apr_palloc(p, 3 * strlen(segment) + 1);
     const unsigned char *s = (const unsigned char *)segment;
     unsigned char *d = (unsigned char *)copy;
     unsigned c;
@@ -1601,9 +1601,9 @@ API_EXPORT(char *) ap_escape_path_segment(ap_pool_t *p, const char *segment)
     return copy;
 }
 
-API_EXPORT(char *) ap_os_escape_path(ap_pool_t *p, const char *path, int partial)
+API_EXPORT(char *) ap_os_escape_path(apr_pool_t *p, const char *path, int partial)
 {
-    char *copy = ap_palloc(p, 3 * strlen(path) + 3);
+    char *copy = apr_palloc(p, 3 * strlen(path) + 3);
     const unsigned char *s = (const unsigned char *)path;
     unsigned char *d = (unsigned char *)copy;
     unsigned c;
@@ -1632,7 +1632,7 @@ API_EXPORT(char *) ap_os_escape_path(ap_pool_t *p, const char *path, int partial
 
 /* ap_escape_uri is now a macro for os_escape_path */
 
-API_EXPORT(char *) ap_escape_html(ap_pool_t *p, const char *s)
+API_EXPORT(char *) ap_escape_html(apr_pool_t *p, const char *s)
 {
     int i, j;
     char *x;
@@ -1645,9 +1645,9 @@ API_EXPORT(char *) ap_escape_html(ap_pool_t *p, const char *s)
 	    j += 4;
 
     if (j == 0)
-	return ap_pstrndup(p, s, i);
+	return apr_pstrndup(p, s, i);
 
-    x = ap_palloc(p, i + j + 1);
+    x = apr_palloc(p, i + j + 1);
     for (i = 0, j = 0; s[i] != '\0'; i++, j++)
 	if (s[i] == '<') {
 	    memcpy(&x[j], "&lt;", 4);
@@ -1670,27 +1670,27 @@ API_EXPORT(char *) ap_escape_html(ap_pool_t *p, const char *s)
 
 API_EXPORT(int) ap_is_directory(const char *path)
 {
-    ap_finfo_t finfo;
+    apr_finfo_t finfo;
 
-    if (ap_stat(&finfo, path, NULL) == -1)
+    if (apr_stat(&finfo, path, NULL) == -1)
 	return 0;		/* in error condition, just return no */
 
     return (finfo.filetype == APR_DIR);
 }
 
-API_EXPORT(char *) ap_make_full_path(ap_pool_t *a, const char *src1,
+API_EXPORT(char *) ap_make_full_path(apr_pool_t *a, const char *src1,
 				  const char *src2)
 {
     register int x;
 
     x = strlen(src1);
     if (x == 0)
-	return ap_pstrcat(a, "/", src2, NULL);
+	return apr_pstrcat(a, "/", src2, NULL);
 
     if (src1[x - 1] != '/')
-	return ap_pstrcat(a, src1, "/", src2, NULL);
+	return apr_pstrcat(a, src1, "/", src2, NULL);
     else
-	return ap_pstrcat(a, src1, src2, NULL);
+	return apr_pstrcat(a, src1, src2, NULL);
 }
 
 /*
@@ -1862,7 +1862,7 @@ unsigned long ap_get_virthost_addr(char *w, unsigned short *ports)
 }
 
 
-static char *find_fqdn(ap_pool_t *a, struct hostent *p)
+static char *find_fqdn(apr_pool_t *a, struct hostent *p)
 {
     int x;
 
@@ -1870,14 +1870,14 @@ static char *find_fqdn(ap_pool_t *a, struct hostent *p)
 	for (x = 0; p->h_aliases[x]; ++x) {
 	    if (strchr(p->h_aliases[x], '.') &&
 		(!strncasecmp(p->h_aliases[x], p->h_name, strlen(p->h_name))))
-		return ap_pstrdup(a, p->h_aliases[x]);
+		return apr_pstrdup(a, p->h_aliases[x]);
 	}
 	return NULL;
     }
-    return ap_pstrdup(a, (void *) p->h_name);
+    return apr_pstrdup(a, (void *) p->h_name);
 }
 
-char *ap_get_local_host(ap_pool_t *a)
+char *ap_get_local_host(apr_pool_t *a)
 {
 #ifndef MAXHOSTNAMELEN
 #define MAXHOSTNAMELEN 256
@@ -1903,8 +1903,8 @@ char *ap_get_local_host(ap_pool_t *a)
             || (!(server_hostname = find_fqdn(a, p)))) {
             /* Recovery - return the default servername by IP: */
             if (!str && p->h_addr_list[0]) {
-                ap_snprintf(str, sizeof(str), "%pA", p->h_addr_list[0]);
-	        server_hostname = ap_pstrdup(a, str);
+                apr_snprintf(str, sizeof(str), "%pA", p->h_addr_list[0]);
+	        server_hostname = apr_pstrdup(a, str);
                 /* We will drop through to report the IP-named server */
             }
         }
@@ -1915,7 +1915,7 @@ char *ap_get_local_host(ap_pool_t *a)
     }
 
     if (!server_hostname) 
-        server_hostname = ap_pstrdup(a, "127.0.0.1");
+        server_hostname = apr_pstrdup(a, "127.0.0.1");
 
     ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, 0, NULL,
                  "%s: Could not find determine the server's fully qualified "
@@ -1927,24 +1927,24 @@ char *ap_get_local_host(ap_pool_t *a)
 
 /* simple 'pool' alloc()ing glue to ap_base64.c
  */
-API_EXPORT(char *) ap_pbase64decode(ap_pool_t *p, const char *bufcoded)
+API_EXPORT(char *) ap_pbase64decode(apr_pool_t *p, const char *bufcoded)
 {
     char *decoded;
     int l;
 
-    decoded = (char *) ap_palloc(p, 1 + ap_base64decode_len(bufcoded));
+    decoded = (char *) apr_palloc(p, 1 + ap_base64decode_len(bufcoded));
     l = ap_base64decode(decoded, bufcoded);
     decoded[l] = '\0'; /* make binary sequence into string */
 
     return decoded;
 }
 
-API_EXPORT(char *) ap_pbase64encode(ap_pool_t *p, char *string) 
+API_EXPORT(char *) ap_pbase64encode(apr_pool_t *p, char *string) 
 { 
     char *encoded;
     int l = strlen(string);
 
-    encoded = (char *) ap_palloc(p, 1 + ap_base64encode_len(l));
+    encoded = (char *) apr_palloc(p, 1 + ap_base64encode_len(l));
     l = ap_base64encode(encoded, string, l);
     encoded[l] = '\0'; /* make binary sequence into string */
 
@@ -1953,12 +1953,12 @@ API_EXPORT(char *) ap_pbase64encode(ap_pool_t *p, char *string)
 
 /* deprecated names for the above two functions, here for compatibility
  */
-API_EXPORT(char *) ap_uudecode(ap_pool_t *p, const char *bufcoded)
+API_EXPORT(char *) ap_uudecode(apr_pool_t *p, const char *bufcoded)
 {
     return ap_pbase64decode(p, bufcoded);
 }
 
-API_EXPORT(char *) ap_uuencode(ap_pool_t *p, char *string) 
+API_EXPORT(char *) ap_uuencode(apr_pool_t *p, char *string) 
 { 
     return ap_pbase64encode(p, string);
 }
@@ -1990,7 +1990,7 @@ API_EXPORT(void) ap_content_type_tolower(char *str)
 /*
  * Given a string, replace any bare " with \" .
  */
-API_EXPORT(char *) ap_escape_quotes (ap_pool_t *p, const char *instring)
+API_EXPORT(char *) ap_escape_quotes (apr_pool_t *p, const char *instring)
 {
     int newlen = 0;
     const char *inchr = instring;
@@ -2015,7 +2015,7 @@ API_EXPORT(char *) ap_escape_quotes (ap_pool_t *p, const char *instring)
 	}
 	inchr++;
     }
-    outstring = ap_palloc(p, newlen + 1);
+    outstring = apr_palloc(p, newlen + 1);
     inchr = instring;
     outchr = outstring;
     /*
diff --git a/server/util_charset.c b/server/util_charset.c
index b6bb0df..e284711 100644
--- a/server/util_charset.c
+++ b/server/util_charset.c
@@ -79,7 +79,7 @@
  * translation is performed.
  */
  
-ap_xlate_t *ap_hdrs_to_ascii, *ap_hdrs_from_ascii;
+apr_xlate_t *ap_hdrs_to_ascii, *ap_hdrs_from_ascii;
 
 /* ap_locale_to_ascii, ap_locale_from_ascii
  *
@@ -94,12 +94,12 @@ ap_xlate_t *ap_hdrs_to_ascii, *ap_hdrs_from_ascii;
  * performed (unless a configuration module does something, of course).
  */
 
-ap_xlate_t *ap_locale_to_ascii, *ap_locale_from_ascii;
+apr_xlate_t *ap_locale_to_ascii, *ap_locale_from_ascii;
 
-API_EXPORT(ap_status_t) ap_set_content_xlate(request_rec *r, int output, 
-                                             ap_xlate_t *xlate)
+API_EXPORT(apr_status_t) ap_set_content_xlate(request_rec *r, int output, 
+                                             apr_xlate_t *xlate)
 {
-    ap_status_t rv;
+    apr_status_t rv;
 
     if (output) {
         r->rrx->to_net = xlate;
diff --git a/server/util_date.c b/server/util_date.c
index bf782eb..f4c365c 100644
--- a/server/util_date.c
+++ b/server/util_date.c
@@ -180,10 +180,10 @@ API_EXPORT(int) ap_checkmask(const char *data, const char *mask)
  * but many changes since then.
  *
  */
-API_EXPORT(ap_time_t) ap_parseHTTPdate(const char *date)
+API_EXPORT(apr_time_t) ap_parseHTTPdate(const char *date)
 {
     ap_exploded_time_t ds;
-    ap_time_t result;
+    apr_time_t result;
     int mint, mon;
     const char *monstr, *timstr;
     static const int months[12] =
@@ -295,7 +295,7 @@ API_EXPORT(ap_time_t) ap_parseHTTPdate(const char *date)
      */
     ds.tm_usec = 0;
     ds.tm_gmtoff = 0;
-    if (ap_implode_time(&result, &ds) != APR_SUCCESS) 
+    if (apr_implode_time(&result, &ds) != APR_SUCCESS) 
 	return BAD_DATE;
     
     return result;
diff --git a/server/util_ebcdic.c b/server/util_ebcdic.c
index c319f97..c642035 100644
--- a/server/util_ebcdic.c
+++ b/server/util_ebcdic.c
@@ -65,9 +65,9 @@
 #include "http_core.h"
 #include "util_ebcdic.h"
 
-ap_status_t ap_init_ebcdic(ap_pool_t *pool)
+apr_status_t ap_init_ebcdic(apr_pool_t *pool)
 {
-    ap_status_t rv;
+    apr_status_t rv;
     char buf[80];
 
     rv = ap_xlate_open(&ap_hdrs_to_ascii, "ISO8859-1", APR_DEFAULT_CHARSET, pool);
@@ -125,11 +125,11 @@ ap_status_t ap_init_ebcdic(ap_pool_t *pool)
 #define ASCIITEXT_MAGIC_TYPE_PREFIX "text/x-ascii-" /* Text files whose content-type starts with this are passed thru unconverted */
 
 /* Check the Content-Type to decide if conversion is needed */
-ap_xlate_t *ap_checkconv(struct request_rec *r)
+apr_xlate_t *ap_checkconv(struct request_rec *r)
 {
     int convert_to_ascii;
     const char *type;
-    ap_xlate_t *zero = NULL;
+    apr_xlate_t *zero = NULL;
 
     /* To make serving of "raw ASCII text" files easy (they serve faster 
      * since they don't have to be converted from EBCDIC), a new
@@ -149,7 +149,7 @@ ap_xlate_t *ap_checkconv(struct request_rec *r)
 		 strncasecmp(type, "message/", 8) == 0)) {
 	if (strncasecmp(type, ASCIITEXT_MAGIC_TYPE_PREFIX,
 			sizeof(ASCIITEXT_MAGIC_TYPE_PREFIX)-1) == 0)
-	    r->content_type = ap_pstrcat(r->pool, "text/",
+	    r->content_type = apr_pstrcat(r->pool, "text/",
 					 type+sizeof(ASCIITEXT_MAGIC_TYPE_PREFIX)-1,
 					 NULL);
         else
diff --git a/server/util_filter.c b/server/util_filter.c
index 77bdc98..228491b 100644
--- a/server/util_filter.c
+++ b/server/util_filter.c
@@ -66,7 +66,7 @@
  */
 typedef struct ap_filter_rec_t {
     const char *name;
-    ap_filter_func filter_func;
+    apr_filter_func filter_func;
     ap_filter_type ftype;
 
     struct ap_filter_rec_t *next;
@@ -93,17 +93,17 @@ static ap_filter_rec_t *registered_filters = NULL;
                                        || (before_this)->ftype > (f)->ftype)
 
 
-static ap_status_t filter_cleanup(void *ctx)
+static apr_status_t filter_cleanup(void *ctx)
 {
     registered_filters = NULL;
     return APR_SUCCESS;
 }
 
 API_EXPORT(void) ap_register_filter(const char *name,
-                                    ap_filter_func filter_func,
+                                    apr_filter_func filter_func,
                                     ap_filter_type ftype)
 {
-    ap_filter_rec_t *frec = ap_palloc(FILTER_POOL, sizeof(*frec));
+    ap_filter_rec_t *frec = apr_palloc(FILTER_POOL, sizeof(*frec));
 
     frec->name = name;
     frec->filter_func = filter_func;
@@ -112,7 +112,7 @@ API_EXPORT(void) ap_register_filter(const char *name,
     frec->next = registered_filters;
     registered_filters = frec;
 
-    ap_register_cleanup(FILTER_POOL, NULL, filter_cleanup, NULL);
+    apr_register_cleanup(FILTER_POOL, NULL, filter_cleanup, NULL);
 }
 
 API_EXPORT(void) ap_add_filter(const char *name, void *ctx, request_rec *r)
@@ -121,7 +121,7 @@ API_EXPORT(void) ap_add_filter(const char *name, void *ctx, request_rec *r)
 
     for (; frec != NULL; frec = frec->next) {
         if (!strcasecmp(name, frec->name)) {
-            ap_filter_t *f = ap_pcalloc(r->pool, sizeof(*f));
+            apr_filter_t *f = apr_pcalloc(r->pool, sizeof(*f));
 
             f->filter_func = frec->filter_func;
             f->ctx = ctx;
@@ -132,7 +132,7 @@ API_EXPORT(void) ap_add_filter(const char *name, void *ctx, request_rec *r)
                 r->filters = f;
             }
             else {
-                ap_filter_t *fscan = r->filters;
+                apr_filter_t *fscan = r->filters;
                 while (!INSERT_BEFORE(f, fscan->next))
                     fscan = fscan->next;
                 f->next = fscan->next;
diff --git a/server/util_md5.c b/server/util_md5.c
index a4faf92..97104b6 100644
--- a/server/util_md5.c
+++ b/server/util_md5.c
@@ -92,7 +92,7 @@
 #include "util_md5.h"
 #include "util_ebcdic.h"
 
-API_EXPORT(char *) ap_md5_binary(ap_pool_t *p, const unsigned char *buf, int length)
+API_EXPORT(char *) ap_md5_binary(apr_pool_t *p, const unsigned char *buf, int length)
 {
     const char *hex = "0123456789abcdef";
     ap_md5_ctx_t my_md5;
@@ -104,12 +104,12 @@ API_EXPORT(char *) ap_md5_binary(ap_pool_t *p, const unsigned char *buf, int len
      * Take the MD5 hash of the string argument.
      */
 
-    ap_MD5Init(&my_md5);
+    apr_MD5Init(&my_md5);
 #ifdef CHARSET_EBCDIC
     ap_MD5SetXlate(&my_md5, ap_hdrs_to_ascii);
 #endif
-    ap_MD5Update(&my_md5, buf, (unsigned int)length);
-    ap_MD5Final(hash, &my_md5);
+    apr_MD5Update(&my_md5, buf, (unsigned int)length);
+    apr_MD5Final(hash, &my_md5);
 
     for (i = 0, r = result; i < MD5_DIGESTSIZE; i++) {
 	*r++ = hex[hash[i] >> 4];
@@ -117,10 +117,10 @@ API_EXPORT(char *) ap_md5_binary(ap_pool_t *p, const unsigned char *buf, int len
     }
     *r = '\0';
 
-    return ap_pstrdup(p, result);
+    return apr_pstrdup(p, result);
 }
 
-API_EXPORT(char *) ap_md5(ap_pool_t *p, const unsigned char *string)
+API_EXPORT(char *) ap_md5(apr_pool_t *p, const unsigned char *string)
 {
     return ap_md5_binary(p, string, (int) strlen((char *)string));
 }
@@ -170,16 +170,16 @@ API_EXPORT(char *) ap_md5(ap_pool_t *p, const unsigned char *string)
 static char basis_64[] =
 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
-API_EXPORT(char *) ap_md5contextTo64(ap_pool_t *a, ap_md5_ctx_t *context)
+API_EXPORT(char *) ap_md5contextTo64(apr_pool_t *a, ap_md5_ctx_t *context)
 {
     unsigned char digest[18];
     char *encodedDigest;
     int i;
     char *p;
 
-    encodedDigest = (char *) ap_pcalloc(a, 25 * sizeof(char));
+    encodedDigest = (char *) apr_pcalloc(a, 25 * sizeof(char));
 
-    ap_MD5Final(digest, context);
+    apr_MD5Final(digest, context);
     digest[sizeof(digest) - 1] = digest[sizeof(digest) - 2] = 0;
 
     p = encodedDigest;
@@ -197,45 +197,45 @@ API_EXPORT(char *) ap_md5contextTo64(ap_pool_t *a, ap_md5_ctx_t *context)
 
 #ifdef APACHE_XLATE
 
-API_EXPORT(char *) ap_md5digest(ap_pool_t *p, ap_file_t *infile,
-                                ap_xlate_t *xlate)
+API_EXPORT(char *) ap_md5digest(apr_pool_t *p, apr_file_t *infile,
+                                apr_xlate_t *xlate)
 {
     ap_md5_ctx_t context;
     unsigned char buf[1000];
     long length = 0;
     int nbytes;
-    ap_off_t offset = 0L;
+    apr_off_t offset = 0L;
 
-    ap_MD5Init(&context);
+    apr_MD5Init(&context);
     if (xlate) {
         ap_MD5SetXlate(&context, xlate);
     }
     nbytes = sizeof(buf);
-    while (ap_read(infile, buf, &nbytes) == APR_SUCCESS) {
+    while (apr_read(infile, buf, &nbytes) == APR_SUCCESS) {
 	length += nbytes;
-	ap_MD5Update(&context, buf, nbytes);
+	apr_MD5Update(&context, buf, nbytes);
     }
-    ap_seek(infile, APR_SET, &offset);
+    apr_seek(infile, APR_SET, &offset);
     return ap_md5contextTo64(p, &context);
 }
 
 #else
 
-API_EXPORT(char *) ap_md5digest(ap_pool_t *p, ap_file_t *infile)
+API_EXPORT(char *) ap_md5digest(apr_pool_t *p, apr_file_t *infile)
 {
     ap_md5_ctx_t context;
     unsigned char buf[1000];
     long length = 0;
-    ap_ssize_t nbytes;
-    ap_off_t offset = 0L;
+    apr_ssize_t nbytes;
+    apr_off_t offset = 0L;
 
-    ap_MD5Init(&context);
+    apr_MD5Init(&context);
     nbytes = sizeof(buf);
-    while (ap_read(infile, buf, &nbytes) == APR_SUCCESS) {
+    while (apr_read(infile, buf, &nbytes) == APR_SUCCESS) {
 	length += nbytes;
-	ap_MD5Update(&context, buf, nbytes);
+	apr_MD5Update(&context, buf, nbytes);
     }
-    ap_seek(infile, APR_SET, &offset);
+    apr_seek(infile, APR_SET, &offset);
     return ap_md5contextTo64(p, &context);
 }
 
diff --git a/server/util_script.c b/server/util_script.c
index 621134b..53a3af8 100644
--- a/server/util_script.c
+++ b/server/util_script.c
@@ -97,9 +97,9 @@
 #define MALFORMED_MESSAGE "malformed header from script. Bad header="
 #define MALFORMED_HEADER_LENGTH_TO_SHOW 30
 
-static char *http2env(ap_pool_t *a, char *w)
+static char *http2env(apr_pool_t *a, char *w)
 {
-    char *res = ap_pstrcat(a, "HTTP_", w, NULL);
+    char *res = apr_pstrcat(a, "HTTP_", w, NULL);
     char *cp = res;
 
     while (*++cp) {
@@ -114,27 +114,27 @@ static char *http2env(ap_pool_t *a, char *w)
     return res;
 }
 
-API_EXPORT(char **) ap_create_environment(ap_pool_t *p, ap_table_t *t)
+API_EXPORT(char **) ap_create_environment(apr_pool_t *p, apr_table_t *t)
 {
-    ap_array_header_t *env_arr = ap_table_elts(t);
-    ap_table_entry_t *elts = (ap_table_entry_t *) env_arr->elts;
-    char **env = (char **) ap_palloc(p, (env_arr->nelts + 2) * sizeof(char *));
+    apr_array_header_t *env_arr = ap_table_elts(t);
+    apr_table_entry_t *elts = (apr_table_entry_t *) env_arr->elts;
+    char **env = (char **) apr_palloc(p, (env_arr->nelts + 2) * sizeof(char *));
     int i, j;
     char *tz;
     char *whack;
 
     j = 0;
-    if (!ap_table_get(t, "TZ")) {
+    if (!apr_table_get(t, "TZ")) {
 	tz = getenv("TZ");
 	if (tz != NULL) {
-	    env[j++] = ap_pstrcat(p, "TZ=", tz, NULL);
+	    env[j++] = apr_pstrcat(p, "TZ=", tz, NULL);
 	}
     }
     for (i = 0; i < env_arr->nelts; ++i) {
         if (!elts[i].key) {
 	    continue;
 	}
-	env[j] = ap_pstrcat(p, elts[i].key, "=", elts[i].val, NULL);
+	env[j] = apr_pstrcat(p, elts[i].key, "=", elts[i].val, NULL);
 	whack = env[j];
 	if (ap_isdigit(*whack)) {
 	    *whack++ = '_';
@@ -154,7 +154,7 @@ API_EXPORT(char **) ap_create_environment(ap_pool_t *p, ap_table_t *t)
 
 API_EXPORT(void) ap_add_common_vars(request_rec *r)
 {
-    ap_table_t *e;
+    apr_table_t *e;
     server_rec *s = r->server;
     conn_rec *c = r->connection;
     const char *rem_logname;
@@ -163,14 +163,14 @@ API_EXPORT(void) ap_add_common_vars(request_rec *r)
     char *env_temp;
 #endif
     const char *host;
-    ap_array_header_t *hdrs_arr = ap_table_elts(r->headers_in);
-    ap_table_entry_t *hdrs = (ap_table_entry_t *) hdrs_arr->elts;
+    apr_array_header_t *hdrs_arr = ap_table_elts(r->headers_in);
+    apr_table_entry_t *hdrs = (apr_table_entry_t *) hdrs_arr->elts;
     int i;
 
-    /* use a temporary ap_table_t which we'll overlap onto
+    /* use a temporary apr_table_t which we'll overlap onto
      * r->subprocess_env later
      */
-    e = ap_make_table(r->pool, 25 + hdrs_arr->nelts);
+    e = apr_make_table(r->pool, 25 + hdrs_arr->nelts);
 
     /* First, add environment vars from headers... this is as per
      * CGI specs, though other sorts of scripting interfaces see
@@ -188,10 +188,10 @@ API_EXPORT(void) ap_add_common_vars(request_rec *r)
 	 */
 
 	if (!strcasecmp(hdrs[i].key, "Content-type")) {
-	    ap_table_addn(e, "CONTENT_TYPE", hdrs[i].val);
+	    apr_table_addn(e, "CONTENT_TYPE", hdrs[i].val);
 	}
 	else if (!strcasecmp(hdrs[i].key, "Content-length")) {
-	    ap_table_addn(e, "CONTENT_LENGTH", hdrs[i].val);
+	    apr_table_addn(e, "CONTENT_LENGTH", hdrs[i].val);
 	}
 	/*
 	 * You really don't want to disable this check, since it leaves you
@@ -205,83 +205,83 @@ API_EXPORT(void) ap_add_common_vars(request_rec *r)
 	}
 #endif
 	else {
-	    ap_table_addn(e, http2env(r->pool, hdrs[i].key), hdrs[i].val);
+	    apr_table_addn(e, http2env(r->pool, hdrs[i].key), hdrs[i].val);
 	}
     }
 
     if (!(env_path = getenv("PATH"))) {
 	env_path = DEFAULT_PATH;
     }
-    ap_table_addn(e, "PATH", ap_pstrdup(r->pool, env_path));
+    apr_table_addn(e, "PATH", apr_pstrdup(r->pool, env_path));
 
 #ifdef WIN32
     if (env_temp = getenv("SystemRoot")) {
-        ap_table_addn(e, "SystemRoot", env_temp);         
+        apr_table_addn(e, "SystemRoot", env_temp);         
     }
     if (env_temp = getenv("COMSPEC")) {
-        ap_table_addn(e, "COMSPEC", env_temp);            
+        apr_table_addn(e, "COMSPEC", env_temp);            
     }
     if (env_temp = getenv("WINDIR")) {
-        ap_table_addn(e, "WINDIR", env_temp);
+        apr_table_addn(e, "WINDIR", env_temp);
     }
 #endif
 
 #ifdef OS2
     if ((env_temp = getenv("COMSPEC")) != NULL) {
-        ap_table_addn(e, "COMSPEC", env_temp);            
+        apr_table_addn(e, "COMSPEC", env_temp);            
     }
     if ((env_temp = getenv("ETC")) != NULL) {
-        ap_table_addn(e, "ETC", env_temp);            
+        apr_table_addn(e, "ETC", env_temp);            
     }
     if ((env_temp = getenv("DPATH")) != NULL) {
-        ap_table_addn(e, "DPATH", env_temp);            
+        apr_table_addn(e, "DPATH", env_temp);            
     }
     if ((env_temp = getenv("PERLLIB_PREFIX")) != NULL) {
-        ap_table_addn(e, "PERLLIB_PREFIX", env_temp);            
+        apr_table_addn(e, "PERLLIB_PREFIX", env_temp);            
     }
 #endif
 
-    ap_table_addn(e, "SERVER_SIGNATURE", ap_psignature("", r));
-    ap_table_addn(e, "SERVER_SOFTWARE", ap_get_server_version());
-    ap_table_addn(e, "SERVER_NAME", ap_get_server_name(r));
-    ap_table_addn(e, "SERVER_ADDR", r->connection->local_ip);	/* Apache */
-    ap_table_addn(e, "SERVER_PORT",
-		  ap_psprintf(r->pool, "%u", ap_get_server_port(r)));
+    apr_table_addn(e, "SERVER_SIGNATURE", ap_psignature("", r));
+    apr_table_addn(e, "SERVER_SOFTWARE", ap_get_server_version());
+    apr_table_addn(e, "SERVER_NAME", ap_get_server_name(r));
+    apr_table_addn(e, "SERVER_ADDR", r->connection->local_ip);	/* Apache */
+    apr_table_addn(e, "SERVER_PORT",
+		  apr_psprintf(r->pool, "%u", ap_get_server_port(r)));
     host = ap_get_remote_host(c, r->per_dir_config, REMOTE_HOST);
     if (host) {
-	ap_table_addn(e, "REMOTE_HOST", host);
+	apr_table_addn(e, "REMOTE_HOST", host);
     }
-    ap_table_addn(e, "REMOTE_ADDR", c->remote_ip);
-    ap_table_addn(e, "DOCUMENT_ROOT", ap_document_root(r));	/* Apache */
-    ap_table_addn(e, "SERVER_ADMIN", s->server_admin);	/* Apache */
-    ap_table_addn(e, "SCRIPT_FILENAME", r->filename);	/* Apache */
+    apr_table_addn(e, "REMOTE_ADDR", c->remote_ip);
+    apr_table_addn(e, "DOCUMENT_ROOT", ap_document_root(r));	/* Apache */
+    apr_table_addn(e, "SERVER_ADMIN", s->server_admin);	/* Apache */
+    apr_table_addn(e, "SCRIPT_FILENAME", r->filename);	/* Apache */
 
-    ap_table_addn(e, "REMOTE_PORT",
-		  ap_psprintf(r->pool, "%d", ntohs(c->remote_addr.sin_port)));
+    apr_table_addn(e, "REMOTE_PORT",
+		  apr_psprintf(r->pool, "%d", ntohs(c->remote_addr.sin_port)));
 
     if (r->user) {
-	ap_table_addn(e, "REMOTE_USER", r->user);
+	apr_table_addn(e, "REMOTE_USER", r->user);
     }
     if (r->ap_auth_type) {
-	ap_table_addn(e, "AUTH_TYPE", r->ap_auth_type);
+	apr_table_addn(e, "AUTH_TYPE", r->ap_auth_type);
     }
     rem_logname = ap_get_remote_logname(r);
     if (rem_logname) {
-	ap_table_addn(e, "REMOTE_IDENT", ap_pstrdup(r->pool, rem_logname));
+	apr_table_addn(e, "REMOTE_IDENT", apr_pstrdup(r->pool, rem_logname));
     }
 
     /* Apache custom error responses. If we have redirected set two new vars */
 
     if (r->prev) {
         if (r->prev->args) {
-	    ap_table_addn(e, "REDIRECT_QUERY_STRING", r->prev->args);
+	    apr_table_addn(e, "REDIRECT_QUERY_STRING", r->prev->args);
 	}
 	if (r->prev->uri) {
-	    ap_table_addn(e, "REDIRECT_URL", r->prev->uri);
+	    apr_table_addn(e, "REDIRECT_URL", r->prev->uri);
 	}
     }
 
-    ap_overlap_tables(r->subprocess_env, e, AP_OVERLAP_TABLES_SET);
+    apr_overlap_tables(r->subprocess_env, e, AP_OVERLAP_TABLES_SET);
 }
 
 /* This "cute" little function comes about because the path info on
@@ -314,7 +314,7 @@ static char *original_uri(request_rec *r)
     char *first, *last;
 
     if (r->the_request == NULL) {
-	return (char *) ap_pcalloc(r->pool, 1);
+	return (char *) apr_pcalloc(r->pool, 1);
     }
 
     first = r->the_request;	/* use the request-line */
@@ -331,18 +331,18 @@ static char *original_uri(request_rec *r)
 	++last;			/* end at next whitespace */
     }
 
-    return ap_pstrndup(r->pool, first, last - first);
+    return apr_pstrndup(r->pool, first, last - first);
 }
 
 API_EXPORT(void) ap_add_cgi_vars(request_rec *r)
 {
-    ap_table_t *e = r->subprocess_env;
+    apr_table_t *e = r->subprocess_env;
 
-    ap_table_setn(e, "GATEWAY_INTERFACE", "CGI/1.1");
-    ap_table_setn(e, "SERVER_PROTOCOL", r->protocol);
-    ap_table_setn(e, "REQUEST_METHOD", r->method);
-    ap_table_setn(e, "QUERY_STRING", r->args ? r->args : "");
-    ap_table_setn(e, "REQUEST_URI", original_uri(r));
+    apr_table_setn(e, "GATEWAY_INTERFACE", "CGI/1.1");
+    apr_table_setn(e, "SERVER_PROTOCOL", r->protocol);
+    apr_table_setn(e, "REQUEST_METHOD", r->method);
+    apr_table_setn(e, "QUERY_STRING", r->args ? r->args : "");
+    apr_table_setn(e, "REQUEST_URI", original_uri(r));
 
     /* Note that the code below special-cases scripts run from includes,
      * because it "knows" that the sub_request has been hacked to have the
@@ -351,21 +351,21 @@ API_EXPORT(void) ap_add_cgi_vars(request_rec *r)
      */
 
     if (!strcmp(r->protocol, "INCLUDED")) {
-	ap_table_setn(e, "SCRIPT_NAME", r->uri);
+	apr_table_setn(e, "SCRIPT_NAME", r->uri);
 	if (r->path_info && *r->path_info) {
-	    ap_table_setn(e, "PATH_INFO", r->path_info);
+	    apr_table_setn(e, "PATH_INFO", r->path_info);
 	}
     }
     else if (!r->path_info || !*r->path_info) {
-	ap_table_setn(e, "SCRIPT_NAME", r->uri);
+	apr_table_setn(e, "SCRIPT_NAME", r->uri);
     }
     else {
 	int path_info_start = ap_find_path_info(r->uri, r->path_info);
 
-	ap_table_setn(e, "SCRIPT_NAME",
-		      ap_pstrndup(r->pool, r->uri, path_info_start));
+	apr_table_setn(e, "SCRIPT_NAME",
+		      apr_pstrndup(r->pool, r->uri, path_info_start));
 
-	ap_table_setn(e, "PATH_INFO", r->path_info);
+	apr_table_setn(e, "PATH_INFO", r->path_info);
     }
 
     if (r->path_info && r->path_info[0]) {
@@ -382,14 +382,14 @@ API_EXPORT(void) ap_add_cgi_vars(request_rec *r)
 #ifdef WIN32
 	    char buffer[HUGE_STRING_LEN];
 #endif
-	    char *pt = ap_pstrcat(r->pool, pa_req->filename, pa_req->path_info,
+	    char *pt = apr_pstrcat(r->pool, pa_req->filename, pa_req->path_info,
 				  NULL);
 #ifdef WIN32
 	    /* We need to make this a real Windows path name */
 	    GetFullPathName(pt, HUGE_STRING_LEN, buffer, NULL);
-	    ap_table_setn(e, "PATH_TRANSLATED", ap_pstrdup(r->pool, buffer));
+	    apr_table_setn(e, "PATH_TRANSLATED", apr_pstrdup(r->pool, buffer));
 #else
-	    ap_table_setn(e, "PATH_TRANSLATED", pt);
+	    apr_table_setn(e, "PATH_TRANSLATED", pt);
 #endif
 	}
 	ap_destroy_sub_req(pa_req);
@@ -399,7 +399,7 @@ API_EXPORT(void) ap_add_cgi_vars(request_rec *r)
 
 static int set_cookie_doo_doo(void *v, const char *key, const char *val)
 {
-    ap_table_addn(v, key, val);
+    apr_table_addn(v, key, val);
     return 1;
 }
 
@@ -411,8 +411,8 @@ API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
     char *w, *l;
     int p;
     int cgi_status = HTTP_OK;
-    ap_table_t *merge;
-    ap_table_t *cookie_table;
+    apr_table_t *merge;
+    apr_table_t *cookie_table;
 
     if (buffer) {
 	*buffer = '\0';
@@ -420,7 +420,7 @@ API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
     w = buffer ? buffer : x;
 
     /* temporary place to hold headers to merge in later */
-    merge = ap_make_table(r->pool, 10);
+    merge = apr_make_table(r->pool, 10);
 
     /* The HTTP specification says that it is legal to merge duplicate
      * headers into one.  Some browsers that support Cookies don't like
@@ -428,8 +428,8 @@ API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
      * separately.  Lets humour those browsers by not merging.
      * Oh what a pain it is.
      */
-    cookie_table = ap_make_table(r->pool, 2);
-    ap_table_do(set_cookie_doo_doo, cookie_table, r->err_headers_out, "Set-Cookie", NULL);
+    cookie_table = apr_make_table(r->pool, 2);
+    apr_table_do(set_cookie_doo_doo, cookie_table, r->err_headers_out, "Set-Cookie", NULL);
 
     while (1) {
 
@@ -473,12 +473,12 @@ API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
 	    if ((cgi_status == HTTP_OK) && (r->method_number == M_GET)) {
 		cond_status = ap_meets_conditions(r);
 	    }
-	    ap_overlap_tables(r->err_headers_out, merge,
+	    apr_overlap_tables(r->err_headers_out, merge,
 		AP_OVERLAP_TABLES_MERGE);
 	    if (!ap_is_empty_table(cookie_table)) {
 		/* the cookies have already been copied to the cookie_table */
-		ap_table_unset(r->err_headers_out, "Set-Cookie");
-		r->err_headers_out = ap_overlay_tables(r->pool,
+		apr_table_unset(r->err_headers_out, "Set-Cookie");
+		r->err_headers_out = apr_overlay_tables(r->pool,
 		    r->err_headers_out, cookie_table);
 	    }
 	    return cond_status;
@@ -493,7 +493,7 @@ API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
 	if (!(l = strchr(w, ':'))) {
 	    int maybeASCII = 0, maybeEBCDIC = 0;
 	    unsigned char *cp, native;
-            ap_size_t inbytes_left, outbytes_left;
+            apr_size_t inbytes_left, outbytes_left;
 
 	    for (cp = w; *cp != '\0'; ++cp) {
                 native = ap_xlate_conv_byte(ap_hdrs_from_ascii, *cp);
@@ -546,7 +546,7 @@ API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
 		*endp-- = '\0';
 	    }
 
-	    tmp = ap_pstrdup(r->pool, l);
+	    tmp = apr_pstrdup(r->pool, l);
 	    ap_content_type_tolower(tmp);
 	    r->content_type = tmp;
 	}
@@ -556,16 +556,16 @@ API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
 	 */
 	else if (!strcasecmp(w, "Status")) {
 	    r->status = cgi_status = atoi(l);
-	    r->status_line = ap_pstrdup(r->pool, l);
+	    r->status_line = apr_pstrdup(r->pool, l);
 	}
 	else if (!strcasecmp(w, "Location")) {
-	    ap_table_set(r->headers_out, w, l);
+	    apr_table_set(r->headers_out, w, l);
 	}
 	else if (!strcasecmp(w, "Content-Length")) {
-	    ap_table_set(r->headers_out, w, l);
+	    apr_table_set(r->headers_out, w, l);
 	}
 	else if (!strcasecmp(w, "Transfer-Encoding")) {
-	    ap_table_set(r->headers_out, w, l);
+	    apr_table_set(r->headers_out, w, l);
 	}
 	/*
 	 * If the script gave us a Last-Modified header, we can't just
@@ -576,20 +576,20 @@ API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
 	    ap_set_last_modified(r);
 	}
 	else if (!strcasecmp(w, "Set-Cookie")) {
-	    ap_table_add(cookie_table, w, l);
+	    apr_table_add(cookie_table, w, l);
 	}
 	else {
-	    ap_table_add(merge, w, l);
+	    apr_table_add(merge, w, l);
 	}
     }
 }
 
 static int getsfunc_FILE(char *buf, int len, void *f)
 {
-    return ap_fgets(buf, len, (ap_file_t *) f) == APR_SUCCESS;
+    return apr_fgets(buf, len, (apr_file_t *) f) == APR_SUCCESS;
 }
 
-API_EXPORT(int) ap_scan_script_header_err(request_rec *r, ap_file_t *f,
+API_EXPORT(int) ap_scan_script_header_err(request_rec *r, apr_file_t *f,
 					  char *buffer)
 {
     return ap_scan_script_header_err_core(r, buffer, getsfunc_FILE, f);
@@ -607,10 +607,10 @@ API_EXPORT(int) ap_scan_script_header_err_buff(request_rec *r, BUFF *fb,
 }
 
 
-API_EXPORT(void) ap_send_size(ap_ssize_t size, request_rec *r)
+API_EXPORT(void) ap_send_size(apr_ssize_t size, request_rec *r)
 {
     /* XXX: this -1 thing is a gross hack */
-    if (size == (ap_ssize_t)-1) {
+    if (size == (apr_ssize_t)-1) {
 	ap_rputs("    -", r);
     }
     else if (!size) {
diff --git a/server/util_uri.c b/server/util_uri.c
index 2eab6d2..972bfe1 100644
--- a/server/util_uri.c
+++ b/server/util_uri.c
@@ -116,7 +116,7 @@ API_EXPORT(unsigned short) ap_default_port_for_request(const request_rec *r)
  * from a call to gethostbyname() and lives in static storage.
  * By creating a copy we can tuck it away for later use.
  */
-API_EXPORT(struct hostent *) ap_pduphostent(ap_pool_t *p, const struct hostent *hp)
+API_EXPORT(struct hostent *) ap_pduphostent(apr_pool_t *p, const struct hostent *hp)
 {
     struct hostent *newent;
     char	  **ptrs;
@@ -138,19 +138,19 @@ API_EXPORT(struct hostent *) ap_pduphostent(ap_pool_t *p, const struct hostent *
 	    continue;
 
     /* Allocate hostent structure, alias ptrs, addr ptrs, addrs */
-    newent = (struct hostent *) ap_palloc(p, sizeof(*hp));
-    aliases = (char **) ap_palloc(p, (j+1) * sizeof(char*));
-    ptrs = (char **) ap_palloc(p, (i+1) * sizeof(char*));
-    addrs  = (struct in_addr *) ap_palloc(p, (i+1) * sizeof(struct in_addr));
+    newent = (struct hostent *) apr_palloc(p, sizeof(*hp));
+    aliases = (char **) apr_palloc(p, (j+1) * sizeof(char*));
+    ptrs = (char **) apr_palloc(p, (i+1) * sizeof(char*));
+    addrs  = (struct in_addr *) apr_palloc(p, (i+1) * sizeof(struct in_addr));
 
     *newent = *hp;
-    newent->h_name = ap_pstrdup(p, hp->h_name);
+    newent->h_name = apr_pstrdup(p, hp->h_name);
     newent->h_aliases = aliases;
     newent->h_addr_list = (char**) ptrs;
 
     /* Copy Alias Names: */
     for (j = 0; hp->h_aliases[j] != NULL; ++j) {
-       aliases[j] = ap_pstrdup(p, hp->h_aliases[j]);
+       aliases[j] = apr_pstrdup(p, hp->h_aliases[j]);
     }
     aliases[j] = NULL;
 
@@ -169,7 +169,7 @@ API_EXPORT(struct hostent *) ap_pduphostent(ap_pool_t *p, const struct hostent *
  * COPY OF the hostent structure, intended to be stored and used later.
  * (gethostbyname() uses static storage that would be overwritten on each call)
  */
-API_EXPORT(struct hostent *) ap_pgethostbyname(ap_pool_t *p, const char *hostname)
+API_EXPORT(struct hostent *) ap_pgethostbyname(apr_pool_t *p, const char *hostname)
 {
     struct hostent *hp = gethostbyname(hostname);
     return (hp == NULL) ? NULL : ap_pduphostent(p, hp);
@@ -179,7 +179,7 @@ API_EXPORT(struct hostent *) ap_pgethostbyname(ap_pool_t *p, const char *hostnam
 /* Unparse a uri_components structure to an URI string.
  * Optionally suppress the password for security reasons.
  */
-API_EXPORT(char *) ap_unparse_uri_components(ap_pool_t *p, const uri_components *uptr, unsigned flags)
+API_EXPORT(char *) ap_unparse_uri_components(apr_pool_t *p, const uri_components *uptr, unsigned flags)
 {
     char *ret = "";
 
@@ -188,7 +188,7 @@ API_EXPORT(char *) ap_unparse_uri_components(ap_pool_t *p, const uri_components
 
 	/* Construct a "user:password@" string, honoring the passed UNP_ flags: */
 	if (uptr->user||uptr->password)
-	    ret = ap_pstrcat (p,
+	    ret = apr_pstrcat (p,
 			(uptr->user     && !(flags & UNP_OMITUSER)) ? uptr->user : "",
 			(uptr->password && !(flags & UNP_OMITPASSWORD)) ? ":" : "",
 			(uptr->password && !(flags & UNP_OMITPASSWORD))
@@ -205,7 +205,7 @@ API_EXPORT(char *) ap_unparse_uri_components(ap_pool_t *p, const uri_components
 		 uptr->port == 0 ||
 		 uptr->port == ap_default_port_for_scheme(uptr->scheme));
 
-	    ret = ap_pstrcat (p,
+	    ret = apr_pstrcat (p,
 			uptr->scheme, "://", ret, 
 			uptr->hostname ? uptr->hostname : "",
 			is_default_port ? "" : ":",
@@ -217,7 +217,7 @@ API_EXPORT(char *) ap_unparse_uri_components(ap_pool_t *p, const uri_components
     /* Should we suppress all path info? */
     if (!(flags & UNP_OMITPATHINFO)) {
 	/* Append path, query and fragment strings: */
-	ret = ap_pstrcat (p,
+	ret = apr_pstrcat (p,
 		ret,
 		uptr->path ? uptr->path : "",
 		(uptr->query    && !(flags & UNP_OMITQUERY)) ? "?" : "",
@@ -311,7 +311,7 @@ API_EXPORT(void) ap_util_uri_init(void)
  *  - fills in fields of uri_components *uptr
  *  - none on any of the r->* fields
  */
-API_EXPORT(int) ap_parse_uri_components(ap_pool_t *p, const char *uri, uri_components *uptr)
+API_EXPORT(int) ap_parse_uri_components(apr_pool_t *p, const char *uri, uri_components *uptr)
 {
     int ret;
     regmatch_t match[10];	/* This must have at least as much elements
@@ -336,22 +336,22 @@ API_EXPORT(int) ap_parse_uri_components(ap_pool_t *p, const char *uri, uri_compo
     }
 
     if (match[2].rm_so != match[2].rm_eo)
-	uptr->scheme = ap_pstrndup (p, uri+match[2].rm_so, match[2].rm_eo - match[2].rm_so);
+	uptr->scheme = apr_pstrndup (p, uri+match[2].rm_so, match[2].rm_eo - match[2].rm_so);
 
     /* empty hostinfo is valid, that's why we test $1 but use $3 */
     if (match[1].rm_so != match[1].rm_eo)
-	uptr->hostinfo = ap_pstrndup (p, uri+match[3].rm_so, match[3].rm_eo - match[3].rm_so);
+	uptr->hostinfo = apr_pstrndup (p, uri+match[3].rm_so, match[3].rm_eo - match[3].rm_so);
 
     if (match[4].rm_so != match[4].rm_eo)
-	uptr->path = ap_pstrndup (p, uri+match[4].rm_so, match[4].rm_eo - match[4].rm_so);
+	uptr->path = apr_pstrndup (p, uri+match[4].rm_so, match[4].rm_eo - match[4].rm_so);
 
     /* empty query string is valid, that's why we test $5 but use $6 */
     if (match[5].rm_so != match[5].rm_eo)
-	uptr->query = ap_pstrndup (p, uri+match[6].rm_so, match[6].rm_eo - match[6].rm_so);
+	uptr->query = apr_pstrndup (p, uri+match[6].rm_so, match[6].rm_eo - match[6].rm_so);
 
     /* empty fragment is valid, test $7 use $8 */
     if (match[7].rm_so != match[7].rm_eo)
-	uptr->fragment = ap_pstrndup (p, uri+match[8].rm_so, match[8].rm_eo - match[8].rm_so);
+	uptr->fragment = apr_pstrndup (p, uri+match[8].rm_so, match[8].rm_eo - match[8].rm_so);
 
     if (uptr->hostinfo) {
 	/* Parse the hostinfo part to extract user, password, host, and port */
@@ -370,20 +370,20 @@ API_EXPORT(int) ap_parse_uri_components(ap_pool_t *p, const char *uri, uri_compo
 
 	/* empty user is valid, that's why we test $1 but use $2 */
 	if (match[1].rm_so != match[1].rm_eo)
-	    uptr->user = ap_pstrndup (p, uptr->hostinfo+match[2].rm_so, match[2].rm_eo - match[2].rm_so);
+	    uptr->user = apr_pstrndup (p, uptr->hostinfo+match[2].rm_so, match[2].rm_eo - match[2].rm_so);
 
 	/* empty password is valid, test $3 but use $4 */
 	if (match[3].rm_so != match[3].rm_eo)
-	    uptr->password = ap_pstrndup (p, uptr->hostinfo+match[4].rm_so, match[4].rm_eo - match[4].rm_so);
+	    uptr->password = apr_pstrndup (p, uptr->hostinfo+match[4].rm_so, match[4].rm_eo - match[4].rm_so);
 
 	/* empty hostname is valid, and implied by the existence of hostinfo */
-	uptr->hostname = ap_pstrndup (p, uptr->hostinfo+match[5].rm_so, match[5].rm_eo - match[5].rm_so);
+	uptr->hostname = apr_pstrndup (p, uptr->hostinfo+match[5].rm_so, match[5].rm_eo - match[5].rm_so);
 
 	if (match[6].rm_so != match[6].rm_eo) {
 	    /* Note that the port string can be empty.
 	     * If it is, we use the default port associated with the scheme
 	     */
-	    uptr->port_str = ap_pstrndup (p, uptr->hostinfo+match[7].rm_so, match[7].rm_eo - match[7].rm_so);
+	    uptr->port_str = apr_pstrndup (p, uptr->hostinfo+match[7].rm_so, match[7].rm_eo - match[7].rm_so);
 	    if (uptr->port_str[0] != '\0') {
 		char *endstr;
 		int port;
@@ -413,7 +413,7 @@ API_EXPORT(int) ap_parse_uri_components(ap_pool_t *p, const char *uri, uri_compo
  * that fast memchr()s use.  But that would be way non-portable. -djg
  */
 
-/* We have a ap_table_t that we can index by character and it tells us if the
+/* We have a apr_table_t that we can index by character and it tells us if the
  * character is one of the interesting delimiters.  Note that we even get
  * compares for NUL for free -- it's just another delimiter.
  */
@@ -453,7 +453,7 @@ API_EXPORT(void) ap_util_uri_init(void)
  *  - fills in fields of uri_components *uptr
  *  - none on any of the r->* fields
  */
-API_EXPORT(int) ap_parse_uri_components(ap_pool_t *p, const char *uri, uri_components *uptr)
+API_EXPORT(int) ap_parse_uri_components(apr_pool_t *p, const char *uri, uri_components *uptr)
 {
     const char *s;
     const char *s1;
@@ -481,7 +481,7 @@ deal_with_path:
 	    ++s;
 	}
 	if (s != uri) {
-	    uptr->path = ap_pstrndup(p, uri, s - uri);
+	    uptr->path = apr_pstrndup(p, uri, s - uri);
 	}
 	if (*s == 0) {
 	    return HTTP_OK;
@@ -490,16 +490,16 @@ deal_with_path:
 	    ++s;
 	    s1 = ap_strchr_c(s, '#');
 	    if (s1) {
-		uptr->fragment = ap_pstrdup(p, s1 + 1);
-		uptr->query = ap_pstrndup(p, s, s1 - s);
+		uptr->fragment = apr_pstrdup(p, s1 + 1);
+		uptr->query = apr_pstrndup(p, s, s1 - s);
 	    }
 	    else {
-		uptr->query = ap_pstrdup(p, s);
+		uptr->query = apr_pstrdup(p, s);
 	    }
 	    return HTTP_OK;
 	}
 	/* otherwise it's a fragment */
-	uptr->fragment = ap_pstrdup(p, s + 1);
+	uptr->fragment = apr_pstrdup(p, s + 1);
 	return HTTP_OK;
     }
 
@@ -513,14 +513,14 @@ deal_with_path:
 	goto deal_with_path;	/* backwards predicted taken! */
     }
 
-    uptr->scheme = ap_pstrndup(p, uri, s - uri);
+    uptr->scheme = apr_pstrndup(p, uri, s - uri);
     s += 3;
     hostinfo = s;
     while ((uri_delims[*(unsigned char *)s] & NOTEND_HOSTINFO) == 0) {
 	++s;
     }
     uri = s;	/* whatever follows hostinfo is start of uri */
-    uptr->hostinfo = ap_pstrndup(p, hostinfo, uri - hostinfo);
+    uptr->hostinfo = apr_pstrndup(p, hostinfo, uri - hostinfo);
 
     /* If there's a username:password@host:port, the @ we want is the last @...
      * too bad there's no memrchr()... For the C purists, note that hostinfo
@@ -539,12 +539,12 @@ deal_with_host:
 	s = memchr(hostinfo, ':', uri - hostinfo);
 	if (s == NULL) {
 	    /* we expect the common case to have no port */
-	    uptr->hostname = ap_pstrndup(p, hostinfo, uri - hostinfo);
+	    uptr->hostname = apr_pstrndup(p, hostinfo, uri - hostinfo);
 	    goto deal_with_path;
 	}
-	uptr->hostname = ap_pstrndup(p, hostinfo, s - hostinfo);
+	uptr->hostname = apr_pstrndup(p, hostinfo, s - hostinfo);
 	++s;
-	uptr->port_str = ap_pstrndup(p, s, uri - s);
+	uptr->port_str = apr_pstrndup(p, s, uri - s);
 	if (uri != s) {
 	    port = strtol(uptr->port_str, &endstr, 10);
 	    uptr->port = port;
@@ -561,12 +561,12 @@ deal_with_host:
     /* first colon delimits username:password */
     s1 = memchr(hostinfo, ':', s - hostinfo);
     if (s1) {
-	uptr->user = ap_pstrndup(p, hostinfo, s1 - hostinfo);
+	uptr->user = apr_pstrndup(p, hostinfo, s1 - hostinfo);
 	++s1;
-	uptr->password = ap_pstrndup(p, s1, s - s1);
+	uptr->password = apr_pstrndup(p, s1, s - s1);
     }
     else {
-	uptr->user = ap_pstrndup(p, hostinfo, s - hostinfo);
+	uptr->user = apr_pstrndup(p, hostinfo, s - hostinfo);
     }
     hostinfo = s + 1;
     goto deal_with_host;
@@ -577,7 +577,7 @@ deal_with_host:
  * currently at http://www.mcom.com/newsref/std/tunneling_ssl.html
  * for the format of the "CONNECT host:port HTTP/1.0" request
  */
-API_EXPORT(int) ap_parse_hostinfo_components(ap_pool_t *p, const char *hostinfo, uri_components *uptr)
+API_EXPORT(int) ap_parse_hostinfo_components(apr_pool_t *p, const char *hostinfo, uri_components *uptr)
 {
     const char *s;
     char *endstr;
@@ -587,7 +587,7 @@ API_EXPORT(int) ap_parse_hostinfo_components(ap_pool_t *p, const char *hostinfo,
      */
     memset (uptr, '\0', sizeof(*uptr));
     uptr->is_initialized = 1;
-    uptr->hostinfo = ap_pstrdup(p, hostinfo);
+    uptr->hostinfo = apr_pstrdup(p, hostinfo);
 
     /* We expect hostinfo to point to the first character of
      * the hostname.  There must be a port, separated by a colon
@@ -596,9 +596,9 @@ API_EXPORT(int) ap_parse_hostinfo_components(ap_pool_t *p, const char *hostinfo,
     if (s == NULL) {
 	return HTTP_BAD_REQUEST;
     }
-    uptr->hostname = ap_pstrndup(p, hostinfo, s - hostinfo);
+    uptr->hostname = apr_pstrndup(p, hostinfo, s - hostinfo);
     ++s;
-    uptr->port_str = ap_pstrdup(p, s);
+    uptr->port_str = apr_pstrdup(p, s);
     if (*s != '\0') {
 	uptr->port = (unsigned short) strtol(uptr->port_str, &endstr, 10);
 	if (*endstr == '\0') {
diff --git a/server/util_xml.c b/server/util_xml.c
index d0f25a7..56b05bb 100644
--- a/server/util_xml.c
+++ b/server/util_xml.c
@@ -86,7 +86,7 @@
 /* content for parsing */
 typedef struct ap_xml_ctx {
     ap_xml_doc *doc;		/* the doc we're parsing */
-    ap_pool_t *p;		/* the pool we allocate from */
+    apr_pool_t *p;		/* the pool we allocate from */
     ap_xml_elem *cur_elem;	/* current element */
 
     int error;			/* an error has occurred */
@@ -162,16 +162,16 @@ static void start_handler(void *userdata, const char *name, const char **attrs)
     if (ctx->error)
 	return;
 
-    elem = ap_pcalloc(ctx->p, sizeof(*elem));
+    elem = apr_pcalloc(ctx->p, sizeof(*elem));
 
     /* prep the element */
-    elem->name = elem_name = ap_pstrdup(ctx->p, name);
+    elem->name = elem_name = apr_pstrdup(ctx->p, name);
 
     /* fill in the attributes (note: ends up in reverse order) */
     while (*attrs) {
-	attr = ap_palloc(ctx->p, sizeof(*attr));
-	attr->name = ap_pstrdup(ctx->p, *attrs++);
-	attr->value = ap_pstrdup(ctx->p, *attrs++);
+	attr = apr_palloc(ctx->p, sizeof(*attr));
+	attr->name = apr_pstrdup(ctx->p, *attrs++);
+	attr->value = apr_pstrdup(ctx->p, *attrs++);
 	attr->next = elem->attr;
 	elem->attr = attr;
     }
@@ -221,7 +221,7 @@ static void start_handler(void *userdata, const char *name, const char **attrs)
 	    quoted = ap_xml_quote_string(ctx->p, attr->value, 1);
 
 	    /* build and insert the new scope */
-	    ns_scope = ap_pcalloc(ctx->p, sizeof(*ns_scope));
+	    ns_scope = apr_pcalloc(ctx->p, sizeof(*ns_scope));
 	    ns_scope->prefix = prefix;
 	    ns_scope->ns = ap_xml_insert_uri(ctx->doc->namespaces, quoted);
 	    ns_scope->emptyURI = *quoted == '\0';
@@ -344,7 +344,7 @@ static void cdata_handler(void *userdata, const char *data, int len)
 	return;
 
     elem = ctx->cur_elem;
-    s = ap_pstrndup(ctx->p, data, len);
+    s = apr_pstrndup(ctx->p, data, len);
 
     if (elem->last_child == NULL) {
 	/* no children yet. this cdata follows the start tag */
@@ -374,9 +374,9 @@ API_EXPORT(int) ap_xml_parse_input(request_rec * r, ap_xml_doc **pdoc)
     }
 
     ctx.p = r->pool;
-    ctx.doc = ap_pcalloc(ctx.p, sizeof(*ctx.doc));
+    ctx.doc = apr_pcalloc(ctx.p, sizeof(*ctx.doc));
 
-    ctx.doc->namespaces = ap_make_array(ctx.p, 5, sizeof(const char *));
+    ctx.doc->namespaces = apr_make_array(ctx.p, 5, sizeof(const char *));
     ap_xml_insert_uri(ctx.doc->namespaces, "DAV:");
 
     /* ### we should get the encoding from Content-Encoding */
@@ -400,7 +400,7 @@ API_EXPORT(int) ap_xml_parse_input(request_rec * r, ap_xml_doc **pdoc)
 	size_t limit_xml_body = ap_get_limit_xml_body(r);
 
 	/* allocate our working buffer */
-	buffer = ap_palloc(r->pool, AP_XML_READ_BLOCKSIZE);
+	buffer = apr_palloc(r->pool, AP_XML_READ_BLOCKSIZE);
 
 	/* read the body, stuffing it into the parser */
 	while ((len = ap_get_client_block(r, buffer, AP_XML_READ_BLOCKSIZE)) > 0) {
@@ -474,10 +474,10 @@ API_EXPORT(int) ap_xml_parse_input(request_rec * r, ap_xml_doc **pdoc)
     return HTTP_BAD_REQUEST;
 }
 
-API_EXPORT(void) ap_text_append(ap_pool_t * p, ap_text_header *hdr,
+API_EXPORT(void) ap_text_append(apr_pool_t * p, ap_text_header *hdr,
                                 const char *text)
 {
-    ap_text *t = ap_palloc(p, sizeof(*t));
+    ap_text *t = apr_palloc(p, sizeof(*t));
 
     t->text = text;
     t->next = NULL;
@@ -508,7 +508,7 @@ API_EXPORT(void) ap_text_append(ap_pool_t * p, ap_text_header *hdr,
 ** quotes is typically set to true for XML strings that will occur within
 ** double quotes -- attribute values.
 */
-API_EXPORT(const char *) ap_xml_quote_string(ap_pool_t *p, const char *s,
+API_EXPORT(const char *) ap_xml_quote_string(apr_pool_t *p, const char *s,
                                              int quotes)
 {
     const char *scan;
@@ -531,7 +531,7 @@ API_EXPORT(const char *) ap_xml_quote_string(ap_pool_t *p, const char *s,
     if (extra == 0)
 	return s;
 
-    qstr = ap_palloc(p, len + extra + 1);
+    qstr = apr_palloc(p, len + extra + 1);
     for (scan = s, qscan = qstr; (c = *scan) != '\0'; ++scan) {
 	if (c == '<') {
 	    *qscan++ = '&';
@@ -585,7 +585,7 @@ static int text_size(const ap_text *t)
 }
 
 static size_t elem_size(const ap_xml_elem *elem, int style,
-			ap_array_header_t *namespaces, int *ns_map)
+			apr_array_header_t *namespaces, int *ns_map)
 {
     size_t size;
 
@@ -693,7 +693,7 @@ static char *write_text(char *s, const ap_text *t)
 }
 
 static char *write_elem(char *s, const ap_xml_elem *elem, int style,
-			ap_array_header_t *namespaces, int *ns_map)
+			apr_array_header_t *namespaces, int *ns_map)
 {
     const ap_xml_elem *child;
     size_t len;
@@ -781,7 +781,7 @@ static char *write_elem(char *s, const ap_xml_elem *elem, int style,
     return s;
 }
 
-API_EXPORT(void) ap_xml_quote_elem(ap_pool_t *p, ap_xml_elem *elem)
+API_EXPORT(void) ap_xml_quote_elem(apr_pool_t *p, ap_xml_elem *elem)
 {
     ap_text *scan_txt;
     ap_xml_attr *scan_attr;
@@ -815,13 +815,13 @@ API_EXPORT(void) ap_xml_quote_elem(ap_pool_t *p, ap_xml_elem *elem)
 }
 
 /* convert an element to a text string */
-API_EXPORT(void) ap_xml_to_text(ap_pool_t * p, const ap_xml_elem *elem,
-                                int style, ap_array_header_t *namespaces,
+API_EXPORT(void) ap_xml_to_text(apr_pool_t * p, const ap_xml_elem *elem,
+                                int style, apr_array_header_t *namespaces,
                                 int *ns_map, const char **pbuf, size_t *psize)
 {
     /* get the exact size, plus a null terminator */
     size_t size = elem_size(elem, style, namespaces, ns_map) + 1;
-    char *s = ap_palloc(p, size);
+    char *s = apr_palloc(p, size);
 
     (void) write_elem(s, elem, style, namespaces, ns_map);
     s[size - 1] = '\0';
@@ -831,7 +831,7 @@ API_EXPORT(void) ap_xml_to_text(ap_pool_t * p, const ap_xml_elem *elem,
 	*psize = size;
 }
 
-API_EXPORT(const char *) ap_xml_empty_elem(ap_pool_t * p,
+API_EXPORT(const char *) ap_xml_empty_elem(apr_pool_t * p,
                                            const ap_xml_elem *elem)
 {
     if (elem->ns == AP_XML_NS_NONE) {
@@ -839,14 +839,14 @@ API_EXPORT(const char *) ap_xml_empty_elem(ap_pool_t * p,
 	 * The prefix (xml...) is already within the prop name, or
 	 * the element simply has no prefix.
 	 */
-	return ap_psprintf(p, "<%s/>" DEBUG_CR, elem->name);
+	return apr_psprintf(p, "<%s/>" DEBUG_CR, elem->name);
     }
 
-    return ap_psprintf(p, "<ns%d:%s/>" DEBUG_CR, elem->ns, elem->name);
+    return apr_psprintf(p, "<ns%d:%s/>" DEBUG_CR, elem->ns, elem->name);
 }
 
 /* return the URI's (existing) index, or insert it and return a new index */
-API_EXPORT(int) ap_xml_insert_uri(ap_array_header_t *uri_array,
+API_EXPORT(int) ap_xml_insert_uri(apr_array_header_t *uri_array,
                                   const char *uri)
 {
     int i;
@@ -857,7 +857,7 @@ API_EXPORT(int) ap_xml_insert_uri(ap_array_header_t *uri_array,
 	    return i;
     }
 
-    pelt = ap_push_array(uri_array);
+    pelt = apr_push_array(uri_array);
     *pelt = uri;		/* assume uri is const or in a pool */
     return uri_array->nelts - 1;
 }
diff --git a/server/vhost.c b/server/vhost.c
index aa387d3..9248130 100644
--- a/server/vhost.c
+++ b/server/vhost.c
@@ -117,7 +117,7 @@ struct ipaddr_chain {
     				 * sharing this address */
 };
 
-/* This defines the size of the hash ap_table_t used for hashing ip addresses
+/* This defines the size of the hash apr_table_t used for hashing ip addresses
  * of virtual hosts.  It must be a power of two.
  */
 #ifndef IPHASH_TABLE_SIZE
@@ -167,7 +167,7 @@ static server_addr_rec **name_vhost_list_tail;
 
 
 /* called at the beginning of the config */
-void ap_init_vhost_config(ap_pool_t *p)
+void ap_init_vhost_config(apr_pool_t *p)
 {
     memset(iphash_table, 0, sizeof(iphash_table));
     default_list = NULL;
@@ -183,7 +183,7 @@ void ap_init_vhost_config(ap_pool_t *p)
  * *paddr is the variable used to keep track of **paddr between calls
  * port is the default port to assume
  */
-static const char *get_addresses(ap_pool_t *p, const char *w_,
+static const char *get_addresses(apr_pool_t *p, const char *w_,
 				 server_addr_rec ***paddr, unsigned port)
 {
     struct hostent *hep;
@@ -196,7 +196,7 @@ static const char *get_addresses(ap_pool_t *p, const char *w_,
     if (*w_ == 0)
 	return NULL;
 
-    w=ap_pstrdup(p, w_);
+    w=apr_pstrdup(p, w_);
     t = strchr(w, ':');
     if (t) {
 	if (strcmp(t + 1, "*") == 0) {
@@ -225,12 +225,12 @@ static const char *get_addresses(ap_pool_t *p, const char *w_,
 	is_an_ip_addr = 1;
     }
     if (is_an_ip_addr) {
-	sar = ap_pcalloc(p, sizeof(server_addr_rec));
+	sar = apr_pcalloc(p, sizeof(server_addr_rec));
 	**paddr = sar;
 	*paddr = &sar->next;
 	sar->host_addr.s_addr = my_addr;
 	sar->host_port = port;
-	sar->virthost = ap_pstrdup(p, w);
+	sar->virthost = apr_pstrdup(p, w);
 	return NULL;
     }
 
@@ -243,12 +243,12 @@ static const char *get_addresses(ap_pool_t *p, const char *w_,
     }
 
     for (i = 0; hep->h_addr_list[i]; ++i) {
-	sar = ap_pcalloc(p, sizeof(server_addr_rec));
+	sar = apr_pcalloc(p, sizeof(server_addr_rec));
 	**paddr = sar;
 	*paddr = &sar->next;
 	sar->host_addr = *(struct in_addr *) hep->h_addr_list[i];
 	sar->host_port = port;
-	sar->virthost = ap_pstrdup(p, w);
+	sar->virthost = apr_pstrdup(p, w);
     }
 
     return NULL;
@@ -256,7 +256,7 @@ static const char *get_addresses(ap_pool_t *p, const char *w_,
 
 
 /* parse the <VirtualHost> addresses */
-const char *ap_parse_vhost_addrs(ap_pool_t *p, const char *hostname, server_rec *s)
+const char *ap_parse_vhost_addrs(apr_pool_t *p, const char *hostname, server_rec *s)
 {
     server_addr_rec **addrs;
     const char *err;
@@ -291,7 +291,7 @@ const char *ap_set_name_virtual_host (cmd_parms *cmd, void *dummy,
 }
 
 
-/* hash ap_table_t statistics, keep this in here for the beta period so
+/* hash apr_table_t statistics, keep this in here for the beta period so
  * we can find out if the hash function is ok
  */
 #ifdef IPHASH_STATISTICS
@@ -322,14 +322,14 @@ static void dump_iphash_statistics(server_rec *main_s)
 	}
     }
     qsort(count, IPHASH_TABLE_SIZE, sizeof(count[0]), iphash_compare);
-    p = buf + ap_snprintf(buf, sizeof(buf),
+    p = buf + apr_snprintf(buf, sizeof(buf),
 		    "iphash: total hashed = %u, avg chain = %u, "
 		    "chain lengths (count x len):",
 		    total, total / IPHASH_TABLE_SIZE);
     total = 1;
     for (i = 1; i < IPHASH_TABLE_SIZE; ++i) {
 	if (count[i - 1] != count[i]) {
-	    p += ap_snprintf(p, sizeof(buf) - (p - buf), " %ux%u",
+	    p += apr_snprintf(p, sizeof(buf) - (p - buf), " %ux%u",
 			     total, count[i - 1]);
 	    total = 1;
 	}
@@ -337,7 +337,7 @@ static void dump_iphash_statistics(server_rec *main_s)
 	    ++total;
 	}
     }
-    p += ap_snprintf(p, sizeof(buf) - (p - buf), " %ux%u",
+    p += apr_snprintf(p, sizeof(buf) - (p - buf), " %ux%u",
 		     total, count[IPHASH_TABLE_SIZE - 1]);
     ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, main_s, buf);
 }
@@ -362,12 +362,12 @@ static ap_inline unsigned hash_inaddr(unsigned key)
 
 
 
-static ipaddr_chain *new_ipaddr_chain(ap_pool_t *p,
+static ipaddr_chain *new_ipaddr_chain(apr_pool_t *p,
 				    server_rec *s, server_addr_rec *sar)
 {
     ipaddr_chain *new;
 
-    new = ap_palloc(p, sizeof(*new));
+    new = apr_palloc(p, sizeof(*new));
     new->names = NULL;
     new->server = s;
     new->sar = sar;
@@ -376,11 +376,11 @@ static ipaddr_chain *new_ipaddr_chain(ap_pool_t *p,
 }
 
 
-static name_chain *new_name_chain(ap_pool_t *p, server_rec *s, server_addr_rec *sar)
+static name_chain *new_name_chain(apr_pool_t *p, server_rec *s, server_addr_rec *sar)
 {
     name_chain *new;
 
-    new = ap_palloc(p, sizeof(*new));
+    new = apr_palloc(p, sizeof(*new));
     new->server = s;
     new->sar = sar;
     new->next = NULL;
@@ -395,7 +395,7 @@ static ap_inline ipaddr_chain *find_ipaddr(struct in_addr *server_ip,
     ipaddr_chain *trav;
     unsigned addr;
 
-    /* scan the hash ap_table_t for an exact match first */
+    /* scan the hash apr_table_t for an exact match first */
     addr = server_ip->s_addr;
     bucket = hash_inaddr(addr);
     for (trav = iphash_table[bucket]; trav; trav = trav->next) {
@@ -425,41 +425,41 @@ static ipaddr_chain *find_default_server(unsigned port)
     return NULL;
 }
 
-static void dump_vhost_config(ap_file_t *f)
+static void dump_vhost_config(apr_file_t *f)
 {
     int i;
     ipaddr_chain *ic;
     name_chain *nc;
     char buf[MAX_STRING_LEN];
 
-    ap_fprintf(f, "VirtualHost configuration:\n");
+    apr_fprintf(f, "VirtualHost configuration:\n");
     for (i = 0; i < IPHASH_TABLE_SIZE; ++i) {
 	for (ic = iphash_table[i]; ic; ic = ic->next) {
 	    if (ic->sar->host_port == 0) {
-		ap_snprintf(buf, sizeof(buf), "%pA:*", &ic->sar->host_addr);
+		apr_snprintf(buf, sizeof(buf), "%pA:*", &ic->sar->host_addr);
 	    }
 	    else {
-		ap_snprintf(buf, sizeof(buf), "%pA:%u", &ic->sar->host_addr,
+		apr_snprintf(buf, sizeof(buf), "%pA:%u", &ic->sar->host_addr,
 		    ic->sar->host_port);
 	    }
 	    if (ic->names == NULL) {
-		ap_fprintf(f, "%-22s %s (%s:%u)\n", buf,
+		apr_fprintf(f, "%-22s %s (%s:%u)\n", buf,
 		    ic->server->server_hostname, ic->server->defn_name,
 		    ic->server->defn_line_number);
 		continue;
 	    }
-	    ap_fprintf(f, "%-22s is a NameVirtualHost\n"
+	    apr_fprintf(f, "%-22s is a NameVirtualHost\n"
 	               "%22s default server %s (%s:%u)\n",
 		       buf, "", ic->server->server_hostname,
 		       ic->server->defn_name, ic->server->defn_line_number);
 	    for (nc = ic->names; nc; nc = nc->next) {
 		if (nc->sar->host_port) {
-		    ap_fprintf(f, "%22s port %u ", "", nc->sar->host_port);
+		    apr_fprintf(f, "%22s port %u ", "", nc->sar->host_port);
 		}
 		else {
-		    ap_fprintf(f, "%22s port * ", "");
+		    apr_fprintf(f, "%22s port * ", "");
 		}
-		ap_fprintf(f, "namevhost %s (%s:%u)\n",
+		apr_fprintf(f, "namevhost %s (%s:%u)\n",
 			nc->server->server_hostname,
 			nc->server->defn_name,
 			nc->server->defn_line_number);
@@ -467,15 +467,15 @@ static void dump_vhost_config(ap_file_t *f)
 	}
     }
     if (default_list) {
-	ap_fprintf(f, "_default_ servers:\n");
+	apr_fprintf(f, "_default_ servers:\n");
 	for (ic = default_list; ic; ic = ic->next) {
 	    if (ic->sar->host_port == 0) {
-		ap_fprintf(f, "port * ");
+		apr_fprintf(f, "port * ");
 	    }
 	    else {
-		ap_fprintf(f, "port %u ", ic->sar->host_port);
+		apr_fprintf(f, "port %u ", ic->sar->host_port);
 	    }
-	    ap_fprintf(f, "server %s (%s:%u)\n",
+	    apr_fprintf(f, "server %s (%s:%u)\n",
 		ic->server->server_hostname, ic->server->defn_name,
 		ic->server->defn_line_number);
 	}
@@ -483,7 +483,7 @@ static void dump_vhost_config(ap_file_t *f)
 }
 
 /* compile the tables and such we need to do the run-time vhost lookups */
-void ap_fini_vhost_config(ap_pool_t *p, server_rec *main_s)
+void ap_fini_vhost_config(apr_pool_t *p, server_rec *main_s)
 {
     server_addr_rec *sar;
     int has_default_vhost_addr;
@@ -506,7 +506,7 @@ void ap_fini_vhost_config(ap_pool_t *p, server_rec *main_s)
 	iphash_table_tail[i] = &iphash_table[i];
     }
 
-    /* The first things to go into the hash ap_table_t are the NameVirtualHosts
+    /* The first things to go into the hash apr_table_t are the NameVirtualHosts
      * Since name_vhost_list is in the same order that the directives
      * occured in the config file, we'll copy it in that order.
      */
@@ -522,7 +522,7 @@ void ap_fini_vhost_config(ap_pool_t *p, server_rec *main_s)
 	 */
     }
 
-    /* The next things to go into the hash ap_table_t are the virtual hosts
+    /* The next things to go into the hash apr_table_t are the virtual hosts
      * themselves.  They're listed off of main_s->next in the reverse
      * order they occured in the config file, so we insert them at
      * the iphash_table_tail but don't advance the tail.
@@ -608,14 +608,14 @@ void ap_fini_vhost_config(ap_pool_t *p, server_rec *main_s)
 		    DNS in the VirtualHost statement.  It's disabled
 		    anyhow by the host matching code.  -djg */
 		s->server_hostname =
-		    ap_pstrdup(p, "bogus_host_without_forward_dns");
+		    apr_pstrdup(p, "bogus_host_without_forward_dns");
 	    }
 	    else {
 		struct hostent *h;
 
 		if ((h = gethostbyaddr((char *) &(s->addrs->host_addr),
 					sizeof(struct in_addr), AF_INET))) {
-		    s->server_hostname = ap_pstrdup(p, (char *) h->h_name);
+		    s->server_hostname = apr_pstrdup(p, (char *) h->h_name);
 		}
 		else {
 		    /* again, what can we do?  They didn't specify a
@@ -626,7 +626,7 @@ void ap_fini_vhost_config(ap_pool_t *p, server_rec *main_s)
 			    "ServerName",
 			    inet_ntoa(s->addrs->host_addr));
 		    s->server_hostname =
-			ap_pstrdup(p, "bogus_host_without_reverse_dns");
+			apr_pstrdup(p, "bogus_host_without_reverse_dns");
 		}
 	    }
 	}
@@ -663,8 +663,8 @@ void ap_fini_vhost_config(ap_pool_t *p, server_rec *main_s)
     dump_iphash_statistics(main_s);
 #endif
     if (getenv("DUMP_VHOSTS")) {
-        ap_file_t *thefile = NULL;
-        ap_open_stderr(&thefile, p);
+        apr_file_t *thefile = NULL;
+        apr_open_stderr(&thefile, p);
 	dump_vhost_config(thefile);
     }
 }
@@ -679,7 +679,7 @@ void ap_fini_vhost_config(ap_pool_t *p, server_rec *main_s)
  */
 static void fix_hostname(request_rec *r)
 {
-    char *host = ap_palloc(r->pool, strlen(r->hostname) + 1);
+    char *host = apr_palloc(r->pool, strlen(r->hostname) + 1);
     const char *src;
     char *dst;
 
@@ -726,7 +726,7 @@ bad:
 static int matches_aliases(server_rec *s, const char *host)
 {
     int i;
-    ap_array_header_t *names;
+    apr_array_header_t *names;
 
     /* match ServerName */
     if (!strcasecmp(host, s->server_hostname)) {
@@ -919,7 +919,7 @@ static void check_serverpath(request_rec *r)
 void ap_update_vhost_from_headers(request_rec *r)
 {
     /* must set this for HTTP/1.1 support */
-    if (r->hostname || (r->hostname = ap_table_get(r->headers_in, "Host"))) {
+    if (r->hostname || (r->hostname = apr_table_get(r->headers_in, "Host"))) {
 	fix_hostname(r);
 	if (r->status != HTTP_OK)
 	    return;
@@ -942,7 +942,7 @@ void ap_update_vhost_given_ip(conn_rec *conn)
     ipaddr_chain *trav;
     unsigned port = ntohs(conn->local_addr.sin_port);
 
-    /* scan the hash ap_table_t for an exact match first */
+    /* scan the hash apr_table_t for an exact match first */
     trav = find_ipaddr(&conn->local_addr.sin_addr, port);
     if (trav) {
 	/* save the name_chain for later in case this is a name-vhost */
diff --git a/support/ab.c b/support/ab.c
index 65b5c86..ff02bdd 100644
--- a/support/ab.c
+++ b/support/ab.c
@@ -147,7 +147,7 @@
 #define CBUFFSIZE       2048
 
 struct connection {
-    ap_socket_t *aprsock;
+    apr_socket_t *aprsock;
     int state;
     int read;        		/* amount of bytes read */
     int bread;        		/* amount of body read */
@@ -157,7 +157,7 @@ struct connection {
     int keepalive;        	/* non-zero if a keep-alive request */
     int gotheader;        	/* non-zero if we have the entire header in
         			 * cbuff */
-    ap_time_t start, connect, done;
+    apr_time_t start, connect, done;
     int socknum;
 };
 
@@ -183,7 +183,7 @@ char hostname[1024];        	/* host name */
 char path[1024];        	/* path name */
 char postfile[1024];        	/* name of file containing post data */
 char *postdata;        		/* *buffer containing data from postfile */
-ap_ssize_t postlen = 0;        	/* length of data to be POSTed */
+apr_ssize_t postlen = 0;        	/* length of data to be POSTed */
 char content_type[1024];        /* content type to put in POST header */
 char cookie[1024],        	/* optional cookie line */
      auth[1024],        	/* optional (basic/uuencoded)
@@ -210,22 +210,22 @@ int good = 0, bad = 0;        	/* number of good and bad requests */
 int err_length = 0, err_conn = 0, err_except = 0;
 int err_response = 0;
 
-ap_time_t start, endtime;
+apr_time_t start, endtime;
 
 /* global request (and its length) */
 char request[512];
-ap_ssize_t reqlen;
+apr_ssize_t reqlen;
 
 /* one global throw-away buffer to read stuff into */
 char buffer[8192];
 
 struct connection *con;        	/* connection array */
 struct data *stats;        	/* date for each request */
-ap_pool_t *cntxt;
+apr_pool_t *cntxt;
 
-ap_pollfd_t *readbits;
+apr_pollfd_t *readbits;
 #ifdef NOT_ASCII
-ap_xlate_t *from_ascii, *to_ascii;
+apr_xlate_t *from_ascii, *to_ascii;
 #endif
 
 /* --------------------------------------------------------- */
@@ -240,13 +240,13 @@ static void err(char *s)
 
 /* simple little function to write an APR error string and exit */
 
-static void apr_err(char *s, ap_status_t rv)
+static void apr_err(char *s, apr_status_t rv)
 {
     char buf[120];
 
     fprintf(stderr,
             "%s: %s (%d)\n", 
-            s, ap_strerror(rv, buf, sizeof buf), rv);
+            s, apr_strerror(rv, buf, sizeof buf), rv);
     exit(rv);
 }
 
@@ -257,20 +257,20 @@ static void apr_err(char *s, ap_status_t rv)
 
 static void write_request(struct connection *c)
 {
-    ap_ssize_t len = reqlen;
-    c->connect = ap_now();
-    ap_setsocketopt(c->aprsock, APR_SO_TIMEOUT, 30 * AP_USEC_PER_SEC);
-    if (ap_send(c->aprsock, request, &reqlen) != APR_SUCCESS ||
+    apr_ssize_t len = reqlen;
+    c->connect = apr_now();
+    apr_setsocketopt(c->aprsock, APR_SO_TIMEOUT, 30 * AP_USEC_PER_SEC);
+    if (apr_send(c->aprsock, request, &reqlen) != APR_SUCCESS ||
         reqlen != len) {
         printf("Send request failed!\n");
     }
     if (posting) {
-        ap_send(c->aprsock, postdata, &postlen);
+        apr_send(c->aprsock, postdata, &postlen);
         totalposted += (reqlen + postlen);
     }
 
     c->state = STATE_READ;
-    ap_add_poll_socket(readbits, c->aprsock, APR_POLLIN);
+    apr_add_poll_socket(readbits, c->aprsock, APR_POLLIN);
 }
 
 /* --------------------------------------------------------- */
@@ -281,7 +281,7 @@ static void output_results(void)
 {
     int timetaken;
 
-    endtime = ap_now();
+    endtime = apr_now();
     timetaken = (endtime - start) / 1000;
 
     printf("\r                                                                           \r");
@@ -358,7 +358,7 @@ static void output_html_results(void)
 {
     int timetaken;
 
-    endtime = ap_now();
+    endtime = apr_now();
     timetaken = (endtime - start) / 1000;
 
     printf("\n\n<table %s>\n", tablestring);
@@ -480,7 +480,7 @@ static void output_html_results(void)
 
 static void start_connect(struct connection *c)
 {
-    ap_status_t rv;
+    apr_status_t rv;
 
     if(!(started < requests)) return;
 
@@ -490,27 +490,27 @@ static void start_connect(struct connection *c)
     c->cbx = 0;
     c->gotheader = 0;
 
-    if ((rv = ap_create_tcp_socket(&c->aprsock, cntxt)) != APR_SUCCESS) {
+    if ((rv = apr_create_tcp_socket(&c->aprsock, cntxt)) != APR_SUCCESS) {
         apr_err("Socket:", rv);
     }
-    if ((rv = ap_set_remote_port(c->aprsock, port)) != APR_SUCCESS) {
+    if ((rv = apr_set_remote_port(c->aprsock, port)) != APR_SUCCESS) {
         apr_err("Port:", rv);
     }
-    c->start = ap_now();
-    if ((rv = ap_connect(c->aprsock, hostname)) != APR_SUCCESS) {
-        if (ap_canonical_error(rv) == APR_EINPROGRESS) {
+    c->start = apr_now();
+    if ((rv = apr_connect(c->aprsock, hostname)) != APR_SUCCESS) {
+        if (apr_canonical_error(rv) == APR_EINPROGRESS) {
             c->state = STATE_CONNECTING;
-            ap_add_poll_socket(readbits, c->aprsock, APR_POLLOUT);
+            apr_add_poll_socket(readbits, c->aprsock, APR_POLLOUT);
             return;
         }
         else {
-            ap_remove_poll_socket(readbits, c->aprsock);
-            ap_close_socket(c->aprsock);
+            apr_remove_poll_socket(readbits, c->aprsock);
+            apr_close_socket(c->aprsock);
             err_conn++;
             if (bad++ > 10) {
                 fprintf(stderr,
                         "\nTest aborted after 10 failures\n\n");
-                apr_err("ap_connect()", rv);
+                apr_err("apr_connect()", rv);
             }
             start_connect(c);
             return;
@@ -544,7 +544,7 @@ static void close_connection(struct connection *c)
         /* save out time */
         if (done < requests) {
             struct data s;
-            c->done = ap_now();
+            c->done = apr_now();
             s.read  = c->read;
             s.ctime = (c->connect - c->start) / 1000;
             s.time  = (c->done - c->start) / 1000;
@@ -552,8 +552,8 @@ static void close_connection(struct connection *c)
         }
     }
 
-    ap_remove_poll_socket(readbits, c->aprsock);
-    ap_close_socket(c->aprsock);
+    apr_remove_poll_socket(readbits, c->aprsock);
+    apr_close_socket(c->aprsock);
 
     /* connect again */
     start_connect(c);
@@ -566,21 +566,21 @@ static void close_connection(struct connection *c)
 
 static void read_connection(struct connection *c)
 {
-    ap_ssize_t r;
-    ap_status_t status;
+    apr_ssize_t r;
+    apr_status_t status;
     char *part;
     char respcode[4];        	/* 3 digits and null */
 
     r = sizeof(buffer);
-    ap_setsocketopt(c->aprsock, APR_SO_TIMEOUT, aprtimeout);
-    status = ap_recv(c->aprsock, buffer, &r);
-    if (r == 0 || (status != 0 && ap_canonical_error(status) != APR_EAGAIN)) {
+    apr_setsocketopt(c->aprsock, APR_SO_TIMEOUT, aprtimeout);
+    status = apr_recv(c->aprsock, buffer, &r);
+    if (r == 0 || (status != 0 && apr_canonical_error(status) != APR_EAGAIN)) {
         good++;
         close_connection(c);
         return;
     }
 
-    if (ap_canonical_error(status) == APR_EAGAIN)
+    if (apr_canonical_error(status) == APR_EAGAIN)
         return;
 
     c->read += r;
@@ -592,7 +592,7 @@ static void read_connection(struct connection *c)
         int space = CBUFFSIZE - c->cbx - 1;  /* -1 to allow for 0 terminator */
         int tocopy = (space < r) ? space : r;
 #ifdef NOT_ASCII
-        ap_size_t inbytes_left = space, outbytes_left = space;
+        apr_size_t inbytes_left = space, outbytes_left = space;
 
         status = ap_xlate_conv_buffer(from_ascii, buffer, &inbytes_left,
                                       c->cbuff + c->cbx, &outbytes_left);
@@ -626,8 +626,8 @@ static void read_connection(struct connection *c)
             }
             else {
                 /* header is in invalid or too big - close connection */
-                ap_remove_poll_socket(readbits, c->aprsock);
-                ap_close_socket(c->aprsock);
+                apr_remove_poll_socket(readbits, c->aprsock);
+                apr_close_socket(c->aprsock);
                 err_response++;
                 if (bad++ > 10) {
                     err("\nTest aborted after 10 failures\n\n");
@@ -708,7 +708,7 @@ static void read_connection(struct connection *c)
         }
         if (done < requests) {
             struct data s;
-           c->done = ap_now();
+           c->done = apr_now();
             s.read = c->read;
            s.ctime = (c->connect - c->start) / 1000;
            s.time = (c->done - c->start) / 1000;
@@ -730,13 +730,13 @@ static void read_connection(struct connection *c)
 
 static void test(void)
 {
-    ap_time_t now;
-    ap_interval_time_t timeout;
-    ap_int16_t rv;
+    apr_time_t now;
+    apr_interval_time_t timeout;
+    apr_int16_t rv;
     int i;
-    ap_status_t status;
+    apr_status_t status;
 #ifdef NOT_ASCII
-    ap_size_t inbytes_left, outbytes_left;
+    apr_size_t inbytes_left, outbytes_left;
 #endif
 
     if (!use_html) {
@@ -744,13 +744,13 @@ static void test(void)
         fflush(stdout);
     }
 
-    now = ap_now();
+    now = apr_now();
 
     con = malloc(concurrency * sizeof(struct connection));
     memset(con, 0, concurrency * sizeof(struct connection));
 
     stats = malloc(requests * sizeof(struct data));
-    ap_setup_poll(&readbits, concurrency, cntxt);
+    apr_setup_poll(&readbits, concurrency, cntxt);
 
     /* setup request */
     if (!posting) {
@@ -801,7 +801,7 @@ static void test(void)
 #endif /*NOT_ASCII*/
 
     /* ok - lets start */
-    start = ap_now();
+    start = apr_now();
 
     /* initialise lots of requests */
     for (i = 0; i < concurrency; i++) {
@@ -810,11 +810,11 @@ static void test(void)
     }
 
     while (done < requests) {
-        ap_int32_t n;
-        ap_int32_t timed;
+        apr_int32_t n;
+        apr_int32_t timed;
 
         /* check for time limit expiry */
-        now = ap_now();
+        now = apr_now();
         timed = (now - start) / AP_USEC_PER_SEC;
         if (tlimit && timed > (tlimit * 1000)) {
             requests = done;   /* so stats are correct */
@@ -823,16 +823,16 @@ static void test(void)
         timeout = 30 * AP_USEC_PER_SEC;
 
         n = concurrency;
-        status = ap_poll(readbits, &n, timeout);
+        status = apr_poll(readbits, &n, timeout);
         if (status != APR_SUCCESS)
-            apr_err("ap_poll", status);
+            apr_err("apr_poll", status);
 
         if (!n) {
             err("\nServer timed out\n\n");
         }
 
         for (i = 0; i < concurrency; i++) {
-            ap_get_revents(&rv, con[i].aprsock, readbits);
+            apr_get_revents(&rv, con[i].aprsock, readbits);
 
             /* Note: APR_POLLHUP is set after FIN is received on some
              * systems, so treat that like APR_POLLIN so that we try
@@ -862,14 +862,14 @@ static void test(void)
 static void copyright(void)
 {
     if (!use_html) {
-        printf("This is ApacheBench, Version %s\n", AB_VERSION " <$Revision: 1.20 $> apache-2.0");
+        printf("This is ApacheBench, Version %s\n", AB_VERSION " <$Revision: 1.21 $> apache-2.0");
         printf("Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\n");
         printf("Copyright (c) 1998-2000 The Apache Software Foundation, http://www.apache.org/\n");
         printf("\n");
     }
     else {
         printf("<p>\n");
-        printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-2.0<br>\n", AB_VERSION, "$Revision: 1.20 $");
+        printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-2.0<br>\n", AB_VERSION, "$Revision: 1.21 $");
         printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
         printf(" Copyright (c) 1998-2000 The Apache Software Foundation, http://www.apache.org/<br>\n");
         printf("</p>\n<p>\n");
@@ -939,17 +939,17 @@ static int parse_url(char *url)
 
 static int open_postfile(char *pfile)
 {
-    ap_file_t *postfd = NULL;
-    ap_finfo_t finfo;
-    ap_fileperms_t mode = APR_OS_DEFAULT;
-    ap_ssize_t length;
+    apr_file_t *postfd = NULL;
+    apr_finfo_t finfo;
+    apr_fileperms_t mode = APR_OS_DEFAULT;
+    apr_ssize_t length;
 
-    if (ap_open(&postfd, pfile, APR_READ, mode, cntxt) != APR_SUCCESS) {
+    if (apr_open(&postfd, pfile, APR_READ, mode, cntxt) != APR_SUCCESS) {
         printf("Invalid postfile name (%s)\n", pfile);
         return errno;
     }
 
-    ap_getfileinfo(&finfo, postfd);
+    apr_getfileinfo(&finfo, postfd);
     postlen = finfo.size;
     postdata = (char *)malloc(postlen);
     if (!postdata) {
@@ -957,7 +957,7 @@ static int open_postfile(char *pfile)
         return ENOMEM;
     }
     length = postlen;
-    if (ap_read(postfd, postdata, &length) != APR_SUCCESS &&
+    if (apr_read(postfd, postdata, &length) != APR_SUCCESS &&
         length != postlen) {
         printf("error reading postfilen");
         return EIO;
@@ -973,7 +973,7 @@ int main(int argc, char **argv)
     int c, r, l;
     char tmp[1024];
 #ifdef NOT_ASCII
-    ap_status_t status;
+    apr_status_t status;
 #endif
 
     /* table defaults  */
@@ -984,9 +984,9 @@ int main(int argc, char **argv)
     auth[0] = '\0';
     hdrs[0] = '\0';
 
-    ap_initialize();
-    atexit(ap_terminate);
-    ap_create_pool(&cntxt, NULL);
+    apr_initialize();
+    atexit(apr_terminate);
+    apr_create_pool(&cntxt, NULL);
 
 #ifdef NOT_ASCII
     status = ap_xlate_open(&to_ascii, "ISO8859-1", APR_DEFAULT_CHARSET, cntxt);
@@ -1007,7 +1007,7 @@ int main(int argc, char **argv)
 #endif
 
     ap_optind = 1;
-    while (ap_getopt(argc, argv, "n:c:t:T:p:v:kVhwix:y:z:C:H:P:A:", &c, cntxt) == APR_SUCCESS) {
+    while (apr_getopt(argc, argv, "n:c:t:T:p:v:kVhwix:y:z:C:H:P:A:", &c, cntxt) == APR_SUCCESS) {
         switch (c) {
         case 'n':
             requests = atoi(ap_optarg);
diff --git a/support/htdigest.c b/support/htdigest.c
index 9292367..5c13782 100644
--- a/support/htdigest.c
+++ b/support/htdigest.c
@@ -100,9 +100,9 @@
 #define MAX_STRING_LEN 256
 
 char *tn;
-ap_pool_t *cntxt;
+apr_pool_t *cntxt;
 #ifdef CHARSET_EBCDIC
-ap_xlate_t *to_ascii;
+apr_xlate_t *to_ascii;
 #endif
 
 static void getword(char *word, char *line, char stop)
@@ -120,22 +120,22 @@ static void getword(char *word, char *line, char stop)
     while ((line[y++] = line[x++]));
 }
 
-static int getline(char *s, int n, ap_file_t *f)
+static int getline(char *s, int n, apr_file_t *f)
 {
     register int i = 0;
     char ch;
 
     while (1) {
-	ap_getc(&ch, f);
+	apr_getc(&ch, f);
             s[i] = ch;
 
 	if (s[i] == CR)
-	    ap_getc(&ch, f);
+	    apr_getc(&ch, f);
             s[i] = ch;
 
 	if ((s[i] == 0x4) || (s[i] == LF) || (i == (n - 1))) {
 	    s[i] = '\0';
-            if (ap_eof(f) == APR_EOF) {
+            if (apr_eof(f) == APR_EOF) {
                 return 1;
             }
             return 0;
@@ -144,17 +144,17 @@ static int getline(char *s, int n, ap_file_t *f)
     }
 }
 
-static void putline(ap_file_t *f, char *l)
+static void putline(apr_file_t *f, char *l)
 {
     int x;
 
     for (x = 0; l[x]; x++)
-	ap_putc(l[x], f);
-    ap_putc('\n', f);
+	apr_putc(l[x], f);
+    apr_putc('\n', f);
 }
 
 
-static void add_password(char *user, char *realm, ap_file_t *f)
+static void add_password(char *user, char *realm, apr_file_t *f)
 {
     char *pw;
     ap_md5_ctx_t context;
@@ -165,36 +165,36 @@ static void add_password(char *user, char *realm, ap_file_t *f)
     unsigned int i;
     size_t len = sizeof(pwin);
 
-    if (ap_getpass("New password: ", pwin, &len) != APR_SUCCESS) {
+    if (apr_getpass("New password: ", pwin, &len) != APR_SUCCESS) {
 	fprintf(stderr, "password too long");
 	exit(5);
     }
     len = sizeof(pwin);
-    ap_getpass("Re-type new password: ", pwv, &len);
+    apr_getpass("Re-type new password: ", pwv, &len);
     if (strcmp(pwin, pwv) != 0) {
 	fprintf(stderr, "They don't match, sorry.\n");
 	if (tn) {
-	    ap_remove_file(tn, cntxt);
+	    apr_remove_file(tn, cntxt);
 	}
 	exit(1);
     }
     pw = pwin;
-    ap_fprintf(f, "%s:%s:", user, realm);
+    apr_fprintf(f, "%s:%s:", user, realm);
 
     /* Do MD5 stuff */
     sprintf(string, "%s:%s:%s", user, realm, pw);
 
-    ap_MD5Init(&context);
+    apr_MD5Init(&context);
 #ifdef CHARSET_EBCDIC
     ap_MD5SetXlate(&context, to_ascii);
 #endif
-    ap_MD5Update(&context, (unsigned char *) string, strlen(string));
-    ap_MD5Final(digest, &context);
+    apr_MD5Update(&context, (unsigned char *) string, strlen(string));
+    apr_MD5Final(digest, &context);
 
     for (i = 0; i < 16; i++)
-	ap_fprintf(f, "%02x", digest[i]);
+	apr_fprintf(f, "%02x", digest[i]);
 
-    ap_fprintf(f, "\n");
+    apr_fprintf(f, "\n");
 }
 
 static void usage(void)
@@ -208,14 +208,14 @@ static void interrupted(void)
 {
     fprintf(stderr, "Interrupted.\n");
     if (tn)
-	ap_remove_file(tn, cntxt);
+	apr_remove_file(tn, cntxt);
     exit(1);
 }
 
 int main(int argc, char *argv[])
 {
-    ap_file_t *tfp = NULL, *f;
-    ap_status_t rv;
+    apr_file_t *tfp = NULL, *f;
+    apr_status_t rv;
     char user[MAX_STRING_LEN];
     char realm[MAX_STRING_LEN];
     char line[MAX_STRING_LEN];
@@ -225,50 +225,50 @@ int main(int argc, char *argv[])
     char command[MAX_STRING_LEN];
     int found;
    
-    rv = ap_initialize();
+    rv = apr_initialize();
     if (rv) {
-        fprintf(stderr, "ap_initialize(): %s (%d)\n",
-                ap_strerror(rv, line, sizeof(line)), rv);
+        fprintf(stderr, "apr_initialize(): %s (%d)\n",
+                apr_strerror(rv, line, sizeof(line)), rv);
         exit(1);
     }
-    atexit(ap_terminate); 
-    ap_create_pool(&cntxt, NULL);
+    atexit(apr_terminate); 
+    apr_create_pool(&cntxt, NULL);
 
 #ifdef CHARSET_EBCDIC
     rv = ap_xlate_open(&to_ascii, "ISO8859-1", APR_DEFAULT_CHARSET, cntxt);
     if (rv) {
         fprintf(stderr, "ap_xlate_open(): %s (%d)\n",
-                ap_strerror(rv, line, sizeof(line)), rv);
+                apr_strerror(rv, line, sizeof(line)), rv);
         exit(1);
     }
 #endif
     
     tn = NULL;
-    ap_signal(SIGINT, (void (*)(int)) interrupted);
+    apr_signal(SIGINT, (void (*)(int)) interrupted);
     if (argc == 5) {
 	if (strcmp(argv[1], "-c"))
 	    usage();
-	if (ap_open(&tfp, argv[2], APR_WRITE | APR_CREATE, -1, cntxt) != APR_SUCCESS) {
+	if (apr_open(&tfp, argv[2], APR_WRITE | APR_CREATE, -1, cntxt) != APR_SUCCESS) {
 	    fprintf(stderr, "Could not open passwd file %s for writing.\n",
 		    argv[2]);
-	    perror("ap_open");
+	    perror("apr_open");
 	    exit(1);
 	}
 	printf("Adding password for %s in realm %s.\n", argv[4], argv[3]);
 	add_password(argv[4], argv[3], tfp);
-	ap_close(tfp);
+	apr_close(tfp);
 	exit(0);
     }
     else if (argc != 4)
 	usage();
 
     tn = tmpnam(NULL);
-    if (ap_open(&tfp, tn, APR_WRITE | APR_CREATE, -1, cntxt)!= APR_SUCCESS) {
+    if (apr_open(&tfp, tn, APR_WRITE | APR_CREATE, -1, cntxt)!= APR_SUCCESS) {
 	fprintf(stderr, "Could not open temp file.\n");
 	exit(1);
     }
 
-    if (ap_open(&f, argv[1], APR_READ, -1, cntxt) != APR_SUCCESS) {
+    if (apr_open(&f, argv[1], APR_READ, -1, cntxt) != APR_SUCCESS) {
 	fprintf(stderr,
 		"Could not open passwd file %s for reading.\n", argv[1]);
 	fprintf(stderr, "Use -c option to create new one.\n");
@@ -300,14 +300,14 @@ int main(int argc, char *argv[])
 	printf("Adding user %s in realm %s\n", user, realm);
 	add_password(user, realm, tfp);
     }
-    ap_close(f);
-    ap_close(tfp);
+    apr_close(f);
+    apr_close(tfp);
 #if defined(OS2) || defined(WIN32)
     sprintf(command, "copy \"%s\" \"%s\"", tn, argv[1]);
 #else
     sprintf(command, "cp %s %s", tn, argv[1]);
 #endif
     system(command);
-    ap_remove_file(tn, cntxt);
+    apr_remove_file(tn, cntxt);
     return 0;
 }
diff --git a/support/htpasswd.c b/support/htpasswd.c
index 874d7dd..89013c5 100644
--- a/support/htpasswd.c
+++ b/support/htpasswd.c
@@ -198,15 +198,15 @@ static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
     }
     else {
         bufsize = sizeof(pwin);
-	if (ap_getpass("New password: ", pwin, &bufsize) != 0) {
-	    ap_snprintf(record, (rlen - 1), "password too long (>%d)",
+	if (apr_getpass("New password: ", pwin, &bufsize) != 0) {
+	    apr_snprintf(record, (rlen - 1), "password too long (>%d)",
 			sizeof(pwin) - 1);
 	    return ERR_OVERFLOW;
 	}
         bufsize = sizeof(pwv);
-	ap_getpass("Re-type new password: ", pwv, &bufsize);
+	apr_getpass("Re-type new password: ", pwv, &bufsize);
 	if (strcmp(pwin, pwv) != 0) {
-	    ap_cpystrn(record, "password verification error", (rlen - 1));
+	    apr_cpystrn(record, "password verification error", (rlen - 1));
 	    return ERR_PWMISMATCH;
 	}
 	pw = pwin;
@@ -224,13 +224,13 @@ static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
         to64(&salt[0], rand(), 8);
         salt[8] = '\0';
 
-	ap_MD5Encode((const char *)pw, (const char *)salt,
+	apr_MD5Encode((const char *)pw, (const char *)salt,
 		     cpw, sizeof(cpw));
 	break;
 
     case ALG_PLAIN:
 	/* XXX this len limitation is not in sync with any HTTPd len. */
-	ap_cpystrn(cpw,pw,sizeof(cpw));
+	apr_cpystrn(cpw,pw,sizeof(cpw));
 	break;
 
     case ALG_CRYPT:
@@ -239,7 +239,7 @@ static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
         to64(&salt[0], rand(), 8);
         salt[8] = '\0';
 
-	ap_cpystrn(cpw, (char *)crypt(pw, salt), sizeof(cpw) - 1);
+	apr_cpystrn(cpw, (char *)crypt(pw, salt), sizeof(cpw) - 1);
 	break;
     }
     memset(pw, '\0', strlen(pw));
@@ -249,7 +249,7 @@ static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
      * hash, and delimiters.
      */
     if ((strlen(user) + 1 + strlen(cpw)) > (rlen - 1)) {
-	ap_cpystrn(record, "resultant record too long", (rlen - 1));
+	apr_cpystrn(record, "resultant record too long", (rlen - 1));
 	return ERR_OVERFLOW;
     }
     strcpy(record, user);
@@ -334,10 +334,10 @@ static int writable(char *fname)
  */
 static int exists(char *fname)
 {
-    ap_finfo_t sbuf;
+    apr_finfo_t sbuf;
     int check;
 
-    check = ap_stat(&sbuf, fname, NULL);
+    check = apr_stat(&sbuf, fname, NULL);
     return ((check == -1) && (errno == ENOENT)) ? 0 : 1;
 }
 
@@ -376,13 +376,13 @@ int main(int argc, char *argv[])
     int i;
     int args_left = 2;
 #ifdef CHARSET_EBCDIC
-    ap_pool_t *pool;
-    ap_status_t rv;
-    ap_xlate_t *to_ascii;
+    apr_pool_t *pool;
+    apr_status_t rv;
+    apr_xlate_t *to_ascii;
 
-    ap_initialize();
-    atexit(ap_terminate);
-    ap_create_pool(&pool, NULL);
+    apr_initialize();
+    atexit(apr_terminate);
+    apr_create_pool(&pool, NULL);
 
     rv = ap_xlate_open(&to_ascii, "ISO8859-1", APR_DEFAULT_CHARSET, pool);
     if (rv) {
diff --git a/support/logresolve.c b/support/logresolve.c
index d21177c..250fd5c 100644
--- a/support/logresolve.c
+++ b/support/logresolve.c
@@ -74,7 +74,7 @@ static void stats(FILE *output);
 #define MAXDNAME 256
 #endif
 
-/* number of buckets in cache hash ap_table_t */
+/* number of buckets in cache hash apr_table_t */
 #define BUCKETS 256
 
 #if defined(NEED_STRDUP)
@@ -289,7 +289,7 @@ int main (int argc, char *argv[])
     int i, check;
 
 #ifdef WIN32
-    /*  If we apr'ify this code, ap_create_pool/ap_destroy_pool
+    /*  If we apr'ify this code, apr_create_pool/apr_destroy_pool
      *  should perform the WSAStartup/WSACleanup for us. 
      */
     WSADATA wsaData;
diff --git a/support/suexec.c b/support/suexec.c
index e5e3215..84c17d7 100644
--- a/support/suexec.c
+++ b/support/suexec.c
@@ -352,7 +352,7 @@ int main(int argc, char *argv[])
 	{
 	case -1:	/* Error */
 	    log_err("failed to setup bs2000 environment for user %s: %s\n",
-		    target_uname, ap_strerror(errno, buf, sizeof(buf)));
+		    target_uname, apr_strerror(errno, buf, sizeof(buf)));
 	    exit(150);
 	case 0:	/* Child */
 	    break;
@@ -560,6 +560,6 @@ int main(int argc, char *argv[])
      * Oh well, log the failure and error out.
      */
     log_err("(%d)%s: exec failed (%s)\n", errno, 
-            ap_strerror(errno, buf, sizeof(buf)), cmd);
+            apr_strerror(errno, buf, sizeof(buf)), cmd);
     exit(255);
 }
diff --git a/test/test_find.c b/test/test_find.c
index 026f98a..496168a 100644
--- a/test/test_find.c
+++ b/test/test_find.c
@@ -41,11 +41,11 @@ API_EXPORT(void) ap_log_error(const char *file, int line, int level,
 
 int main (void)
 {
-    ap_pool_t *p;
+    apr_pool_t *p;
     char line[512];
     char tok[512];
 
-    p = ap_init_alloc();
+    p = apr_init_alloc();
 
     printf("Enter field value to find items within:\n");
     if (!gets(line))
diff --git a/test/test_parser.c b/test/test_parser.c
index 70aecbf..440700a 100644
--- a/test/test_parser.c
+++ b/test/test_parser.c
@@ -41,12 +41,12 @@ API_EXPORT(void) ap_log_error(const char *file, int line, int level,
 
 int main (void)
 {
-    ap_pool_t *p;
+    apr_pool_t *p;
     const char *field;
     char *newstr;
     char instr[512];
 
-    p = ap_init_alloc();
+    p = apr_init_alloc();
 
     while (gets(instr)) {
         printf("  [%s] ==\n", instr);
