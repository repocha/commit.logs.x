commit 3d54c34d44ded1dcb0b66cc8d4acba8d1cb6ac44
Author: Jim Jagielski <jim@apache.org>
Date:   Fri Sep 23 13:39:32 2011 +0000

    Cleanup effort in prep for GA push:
    Trim trailing whitespace... no func change
    
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1174751 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/modules/aaa/mod_allowmethods.c b/modules/aaa/mod_allowmethods.c
index 4816e29..e586a1c 100644
--- a/modules/aaa/mod_allowmethods.c
+++ b/modules/aaa/mod_allowmethods.c
@@ -38,7 +38,7 @@
  *      AllowMethods GET HEAD OPTIONS POST
  *   </Directory>
  *  Non-matching methods will be returned a status 405 (method not allowed)
- *  
+ *
  *  To allow all methods, and effectively turn off mod_allowmethods, use:
  *    AllowMethods reset
  */
@@ -54,32 +54,32 @@ static int am_check_access(request_rec *r)
 {
   int method = r->method_number;
   am_conf_t *conf;
-  
+
   conf = (am_conf_t *) ap_get_module_config(r->per_dir_config,
                                             &allowmethods_module);
   if (!conf || conf->allowed == 0) {
     return DECLINED;
   }
-  
+
   r->allowed = conf->allowed;
 
   if (conf->allowed & (AP_METHOD_BIT << method)) {
     return DECLINED;
   }
-  
+
   ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                   "client method denied by server configuration: '%s' to %s%s",
                   r->method,
                   r->filename ? "" : "uri ",
                   r->filename ? r->filename : r->uri);
-  
+
   return HTTP_METHOD_NOT_ALLOWED;
 }
 
 static void *am_create_conf(apr_pool_t * p, char *dummy)
 {
   am_conf_t *conf = apr_pcalloc(p, sizeof(am_conf_t));
-  
+
   conf->allowed = 0;
   conf->allowed_set = 0;
   return conf;
@@ -89,7 +89,7 @@ static void* am_merge_conf(apr_pool_t* pool, void* a, void* b) {
   am_conf_t* base = (am_conf_t*) a;
   am_conf_t* add = (am_conf_t*) b;
   am_conf_t* conf = apr_palloc(pool, sizeof(am_conf_t));
-  
+
   if (add->allowed_set) {
       conf->allowed = add->allowed;
       conf->allowed_set = add->allowed_set;
diff --git a/modules/aaa/mod_auth_digest.c b/modules/aaa/mod_auth_digest.c
index d8aa4fa..ad338e8 100644
--- a/modules/aaa/mod_auth_digest.c
+++ b/modules/aaa/mod_auth_digest.c
@@ -267,13 +267,13 @@ static int initialize_tables(server_rec *s, apr_pool_t *ctx)
 {
     unsigned long idx;
     apr_status_t   sts;
-    const char *tempdir; 
+    const char *tempdir;
 
     /* set up client list */
 
     sts = apr_temp_dir_get(&tempdir, ctx);
     if (APR_SUCCESS != sts) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s, 
+        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s,
                      "Failed to find temporary directory");
         log_error_and_cleanup("failed to find temp dir", sts, s);
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -281,19 +281,19 @@ static int initialize_tables(server_rec *s, apr_pool_t *ctx)
 
     /* Create the shared memory segment */
 
-    /* 
-     * Create a unique filename using our pid. This information is 
+    /*
+     * Create a unique filename using our pid. This information is
      * stashed in the global variable so the children inherit it.
      */
-    client_shm_filename = apr_psprintf(ctx, "%s/authdigest_shm.%"APR_PID_T_FMT, tempdir, 
+    client_shm_filename = apr_psprintf(ctx, "%s/authdigest_shm.%"APR_PID_T_FMT, tempdir,
                                        getpid());
 
     /* Now create that segment */
     sts = apr_shm_create(&client_shm, shmem_size,
                         client_shm_filename, ctx);
     if (APR_SUCCESS != sts) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s, 
-                     "Failed to create shared memory segment on file %s", 
+        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s,
+                     "Failed to create shared memory segment on file %s",
                      client_shm_filename);
         log_error_and_cleanup("failed to initialize shm", sts, s);
         return HTTP_INTERNAL_SERVER_ERROR;
@@ -672,7 +672,7 @@ static const char *set_shmem_size(cmd_parms *cmd, void *config,
         num_buckets = 1;
     }
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, cmd->server,
-                 "Digest: Set shmem-size: %" APR_SIZE_T_FMT ", num-buckets: %ld", 
+                 "Digest: Set shmem-size: %" APR_SIZE_T_FMT ", num-buckets: %ld",
                  shmem_size, num_buckets);
 
     return NULL;
diff --git a/modules/aaa/mod_authn_socache.c b/modules/aaa/mod_authn_socache.c
index 4d7cfd8..4ba572f 100644
--- a/modules/aaa/mod_authn_socache.c
+++ b/modules/aaa/mod_authn_socache.c
@@ -314,7 +314,7 @@ static authn_status check_password(request_rec *r, const char *user,
     /* construct key
      * look it up
      * if found, test password
-     * 
+     *
      * mutexing here would be a big performance drag.
      * It's definitely unnecessary with some backends (like ndbm or gdbm)
      * Is there a risk in the general case?  I guess the only risk we
diff --git a/modules/aaa/mod_authnz_ldap.c b/modules/aaa/mod_authnz_ldap.c
index d32f84f..8cada8f 100644
--- a/modules/aaa/mod_authnz_ldap.c
+++ b/modules/aaa/mod_authnz_ldap.c
@@ -352,7 +352,7 @@ static apr_status_t authnz_ldap_cleanup_connection_close(void *param)
     return APR_SUCCESS;
 }
 
-static int set_request_vars(request_rec *r, enum auth_ldap_phase phase) { 
+static int set_request_vars(request_rec *r, enum auth_ldap_phase phase) {
     char *prefix = NULL;
     int prefix_len;
     int remote_user_attribute_set = 0;
@@ -379,7 +379,7 @@ static int set_request_vars(request_rec *r, enum auth_ldap_phase phase) {
 
             /* handle remote_user_attribute, if set */
             if ((phase == LDAP_AUTHN) &&
-                sec->remote_user_attribute && 
+                sec->remote_user_attribute &&
                 !strcmp(sec->remote_user_attribute, sec->attributes[i])) {
                 r->user = (char *)apr_pstrdup(r->pool, vals[i]);
                 remote_user_attribute_set = 1;
@@ -890,7 +890,7 @@ static authz_status ldapgroup_check_authorization(request_rec *r,
                 set_request_vars(r, LDAP_AUTHZ);
                 return AUTHZ_GRANTED;
             }
-            case LDAP_NO_SUCH_ATTRIBUTE: 
+            case LDAP_NO_SUCH_ATTRIBUTE:
             case LDAP_COMPARE_FALSE: {
                 /* nested groups need searches and compares, so grab a new handle */
                 authnz_ldap_cleanup_connection_close(ldc);
diff --git a/modules/aaa/mod_authz_core.c b/modules/aaa/mod_authz_core.c
index c81eb8e..906510a 100644
--- a/modules/aaa/mod_authz_core.c
+++ b/modules/aaa/mod_authz_core.c
@@ -948,7 +948,7 @@ static const char *all_parse_config(cmd_parms *cmd, const char *require_line,
                                     const void **parsed_require_line)
 {
     /*
-     * If the argument to the 'all' provider is 'granted' then just let 
+     * If the argument to the 'all' provider is 'granted' then just let
      * everybody in. This would be equivalent to the previous syntax of
      * 'allow from all'. If the argument is 'denied' we reject everbody,
      * which is equivalent to 'deny from all'.
diff --git a/modules/aaa/mod_authz_dbd.c b/modules/aaa/mod_authz_dbd.c
index b3ae99c..e9a67ae 100644
--- a/modules/aaa/mod_authz_dbd.c
+++ b/modules/aaa/mod_authz_dbd.c
@@ -36,7 +36,7 @@ module AP_MODULE_DECLARE_DATA authz_dbd_module;
  * to deal with those when we successfully login/logout at the server
  *
  * XXX: WHY would this be specific to dbd_authz?  Why wouldn't we track
- * this across all authz user providers in a lower level mod, such as 
+ * this across all authz user providers in a lower level mod, such as
  * mod_auth_basic/digest?
  */
 APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(authz_dbd, AUTHZ_DBD, int, client_login,
diff --git a/modules/aaa/mod_authz_dbm.c b/modules/aaa/mod_authz_dbm.c
index b18f148..9fadb82 100644
--- a/modules/aaa/mod_authz_dbm.c
+++ b/modules/aaa/mod_authz_dbm.c
@@ -172,7 +172,7 @@ static authz_status dbmgroup_check_authorization(request_rec *r,
             /* no groups available, so exit immediately */
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           "Authorization of user %s to access %s failed, reason: "
-                          "user doesn't appear in DBM group file (%s).", 
+                          "user doesn't appear in DBM group file (%s).",
                           r->user, r->uri, conf->grpfile);
             return AUTHZ_DENIED;
         }
@@ -240,7 +240,7 @@ static authz_status dbmfilegroup_check_authorization(request_rec *r,
         /* no groups available, so exit immediately */
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Authorization of user %s to access %s failed, reason: "
-                      "user doesn't appear in DBM group file (%s).", 
+                      "user doesn't appear in DBM group file (%s).",
                       r->user, r->uri, conf->grpfile);
         return AUTHZ_DENIED;
     }
diff --git a/modules/aaa/mod_authz_host.c b/modules/aaa/mod_authz_host.c
index 2509b50..2bc7f20 100644
--- a/modules/aaa/mod_authz_host.c
+++ b/modules/aaa/mod_authz_host.c
@@ -204,7 +204,7 @@ static authz_status local_check_authorization(request_rec *r,
                                r->connection->remote_addr)
          || apr_ipsubnet_test(localhost_v4, r->connection->remote_addr)
 #if APR_HAVE_IPV6
-         || apr_ipsubnet_test(localhost_v6, r->connection->remote_addr) 
+         || apr_ipsubnet_test(localhost_v6, r->connection->remote_addr)
 #endif
         )
      {
diff --git a/modules/arch/netware/mod_netware.c b/modules/arch/netware/mod_netware.c
index ad49729..bfb1e87 100644
--- a/modules/arch/netware/mod_netware.c
+++ b/modules/arch/netware/mod_netware.c
@@ -167,7 +167,7 @@ static apr_status_t ap_cgi_build_command(const char **cmd, const char ***argv,
     return APR_SUCCESS;
 }
 
-static int 
+static int
 netware_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                  apr_pool_t *ptemp)
 {
diff --git a/modules/arch/unix/mod_unixd.c b/modules/arch/unix/mod_unixd.c
index af30720..9e55177 100644
--- a/modules/arch/unix/mod_unixd.c
+++ b/modules/arch/unix/mod_unixd.c
@@ -134,7 +134,7 @@ static int set_group_privs(void)
 }
 
 
-static int 
+static int
 unixd_drop_privileges(apr_pool_t *pool, server_rec *s)
 {
     int rv = set_group_privs();
@@ -230,7 +230,7 @@ unixd_set_user(cmd_parms *cmd, void *dummy,
     return NULL;
 }
 
-static const char* 
+static const char*
 unixd_set_group(cmd_parms *cmd, void *dummy,
                                          const char *arg)
 {
@@ -244,7 +244,7 @@ unixd_set_group(cmd_parms *cmd, void *dummy,
     return NULL;
 }
 
-static const char* 
+static const char*
 unixd_set_chroot_dir(cmd_parms *cmd, void *dummy,
                     const char *arg)
 {
@@ -282,7 +282,7 @@ unixd_set_suexec(cmd_parms *cmd, void *dummy, int arg)
     return NULL;
 }
 
-static int 
+static int
 unixd_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                  apr_pool_t *ptemp)
 {
diff --git a/modules/arch/win32/mod_isapi.c b/modules/arch/win32/mod_isapi.c
index 71a2881..4a370c3 100644
--- a/modules/arch/win32/mod_isapi.c
+++ b/modules/arch/win32/mod_isapi.c
@@ -763,9 +763,9 @@ static apr_ssize_t send_response_header(isapi_cid *cid,
         cid->ecb->dwHttpStatusCode = cid->r->status;
     }
     else {
-        /* None of dwHttpStatusCode, the parser's r->status nor the 
+        /* None of dwHttpStatusCode, the parser's r->status nor the
          * old value of r->status were helpful, and nothing was decoded
-         * from Status: string passed to us.  Let's just say HTTP_OK 
+         * from Status: string passed to us.  Let's just say HTTP_OK
          * and get the data out, this was the isapi dev's oversight.
          */
         cid->r->status = HTTP_OK;
@@ -983,7 +983,7 @@ static int APR_THREAD_FUNC regfnServerSupportFunction(isapi_cid    *cid,
               && (file[len - 1] != '/'))
             file = apr_pstrcat(cid->r->pool, subreq->filename, "/", NULL);
         else
-            file = apr_pstrcat(cid->r->pool, subreq->filename, 
+            file = apr_pstrcat(cid->r->pool, subreq->filename,
                                               subreq->path_info, NULL);
 
         ap_destroy_sub_req(subreq);
@@ -1208,9 +1208,9 @@ static int APR_THREAD_FUNC regfnServerSupportFunction(isapi_cid    *cid,
             /* XXX: Many authors issue their next HSE_REQ_ASYNC_READ_CLIENT
              * within the completion logic.  An example is MS's own PSDK
              * sample web/iis/extensions/io/ASyncRead.  This potentially
-             * leads to stack exhaustion.  To refactor, the notification 
+             * leads to stack exhaustion.  To refactor, the notification
              * logic needs to move to isapi_handler() - differentiating
-             * the cid->completed event with a new flag to indicate 
+             * the cid->completed event with a new flag to indicate
              * an async-notice versus the async request completed.
              */
             if (res >= 0) {
@@ -1634,7 +1634,7 @@ static apr_status_t isapi_handler (request_rec *r)
         default:
             ap_log_rerror(APLOG_MARK, APLOG_WARNING, apr_get_os_error(), r,
                           "ISAPI: unrecognized result code %d "
-                          "from HttpExtensionProc(): %s ", 
+                          "from HttpExtensionProc(): %s ",
                           rv, r->filename);
             r->status = HTTP_INTERNAL_SERVER_ERROR;
             break;
diff --git a/modules/cache/mod_socache_dbm.c b/modules/cache/mod_socache_dbm.c
index 5020c19..132a508 100644
--- a/modules/cache/mod_socache_dbm.c
+++ b/modules/cache/mod_socache_dbm.c
@@ -71,12 +71,12 @@ struct ap_socache_instance_t {
 
 static void socache_dbm_expire(ap_socache_instance_t *ctx, server_rec *s);
 
-static apr_status_t socache_dbm_remove(ap_socache_instance_t *ctx, 
-                                       server_rec *s, const unsigned char *id, 
+static apr_status_t socache_dbm_remove(ap_socache_instance_t *ctx,
+                                       server_rec *s, const unsigned char *id,
                                        unsigned int idlen, apr_pool_t *p);
 
-static const char *socache_dbm_create(ap_socache_instance_t **context, 
-                                      const char *arg, 
+static const char *socache_dbm_create(ap_socache_instance_t **context,
+                                      const char *arg,
                                       apr_pool_t *tmp, apr_pool_t *p)
 {
     ap_socache_instance_t *ctx;
@@ -95,8 +95,8 @@ static const char *socache_dbm_create(ap_socache_instance_t **context,
     return NULL;
 }
 
-static apr_status_t socache_dbm_init(ap_socache_instance_t *ctx, 
-                                     const char *namespace, 
+static apr_status_t socache_dbm_init(ap_socache_instance_t *ctx,
+                                     const char *namespace,
                                      const struct ap_socache_hints *hints,
                                      server_rec *s, apr_pool_t *p)
 {
@@ -130,7 +130,7 @@ static apr_status_t socache_dbm_init(ap_socache_instance_t *ctx,
     }
     apr_dbm_close(dbm);
 
-    ctx->expiry_interval = (hints && hints->expiry_interval 
+    ctx->expiry_interval = (hints && hints->expiry_interval
                             ? hints->expiry_interval : apr_time_from_sec(30));
 
 #if AP_NEED_SET_MUTEX_PERMS
@@ -176,10 +176,10 @@ static void socache_dbm_destroy(ap_socache_instance_t *ctx, server_rec *s)
     return;
 }
 
-static apr_status_t socache_dbm_store(ap_socache_instance_t *ctx, 
-                                      server_rec *s, const unsigned char *id, 
-                                      unsigned int idlen, apr_time_t expiry, 
-                                      unsigned char *ucaData, 
+static apr_status_t socache_dbm_store(ap_socache_instance_t *ctx,
+                                      server_rec *s, const unsigned char *id,
+                                      unsigned int idlen, apr_time_t expiry,
+                                      unsigned char *ucaData,
                                       unsigned int nData, apr_pool_t *pool)
 {
     apr_dbm_t *dbm;
@@ -245,7 +245,7 @@ static apr_status_t socache_dbm_store(ap_socache_instance_t *ctx,
     return APR_SUCCESS;
 }
 
-static apr_status_t socache_dbm_retrieve(ap_socache_instance_t *ctx, server_rec *s, 
+static apr_status_t socache_dbm_retrieve(ap_socache_instance_t *ctx, server_rec *s,
                                          const unsigned char *id, unsigned int idlen,
                                          unsigned char *dest, unsigned int *destlen,
                                          apr_pool_t *p)
@@ -270,7 +270,7 @@ static apr_status_t socache_dbm_retrieve(ap_socache_instance_t *ctx, server_rec
      * do the apr_dbm_close? This would make the code a bit cleaner.
      */
     apr_pool_clear(ctx->pool);
-    if ((rc = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE, 
+    if ((rc = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,
                            DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rc, s,
                      "Cannot open socache DBM file `%s' for reading "
@@ -293,7 +293,7 @@ static apr_status_t socache_dbm_retrieve(ap_socache_instance_t *ctx, server_rec
     if (nData > *destlen) {
         apr_dbm_close(dbm);
         return APR_ENOSPC;
-    }    
+    }
 
     *destlen = nData;
     memcpy(&expiry, dbmval.dptr, sizeof(apr_time_t));
@@ -311,7 +311,7 @@ static apr_status_t socache_dbm_retrieve(ap_socache_instance_t *ctx, server_rec
     return APR_SUCCESS;
 }
 
-static apr_status_t socache_dbm_remove(ap_socache_instance_t *ctx, 
+static apr_status_t socache_dbm_remove(ap_socache_instance_t *ctx,
                                        server_rec *s, const unsigned char *id,
                                        unsigned int idlen, apr_pool_t *p)
 {
@@ -326,7 +326,7 @@ static apr_status_t socache_dbm_remove(ap_socache_instance_t *ctx,
     /* and delete it from the DBM file */
     apr_pool_clear(ctx->pool);
 
-    if ((rv = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE, 
+    if ((rv = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,
                            DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                      "Cannot open socache DBM file `%s' for writing "
@@ -447,7 +447,7 @@ static void socache_dbm_expire(ap_socache_instance_t *ctx, server_rec *s)
                  elts, elts-deleted, deleted);
 }
 
-static void socache_dbm_status(ap_socache_instance_t *ctx, request_rec *r, 
+static void socache_dbm_status(ap_socache_instance_t *ctx, request_rec *r,
                                int flags)
 {
     apr_dbm_t *dbm;
@@ -462,7 +462,7 @@ static void socache_dbm_status(ap_socache_instance_t *ctx, request_rec *r,
     size = 0;
 
     apr_pool_clear(ctx->pool);
-    if ((rv = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE, 
+    if ((rv = apr_dbm_open(&dbm, ctx->data_file, APR_DBM_RWCREATE,
                            DBM_FILE_MODE, ctx->pool)) != APR_SUCCESS) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                      "Cannot open socache DBM file `%s' for status "
@@ -565,7 +565,7 @@ static const ap_socache_provider_t socache_dbm = {
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP, "dbm", 
+    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP, "dbm",
                          AP_SOCACHE_PROVIDER_VERSION,
                          &socache_dbm);
 }
diff --git a/modules/cache/mod_socache_dc.c b/modules/cache/mod_socache_dc.c
index 7021cbc..78a92b9 100644
--- a/modules/cache/mod_socache_dc.c
+++ b/modules/cache/mod_socache_dc.c
@@ -38,22 +38,22 @@ struct ap_socache_instance_t {
     DC_CTX *dc;
 };
 
-static const char *socache_dc_create(ap_socache_instance_t **context, 
-                                     const char *arg, 
+static const char *socache_dc_create(ap_socache_instance_t **context,
+                                     const char *arg,
                                      apr_pool_t *tmp, apr_pool_t *p)
 {
     struct ap_socache_instance_t *ctx;
 
     ctx = *context = apr_palloc(p, sizeof *ctx);
-    
+
     ctx->target = apr_pstrdup(p, arg);
 
     return NULL;
 }
 
-static apr_status_t socache_dc_init(ap_socache_instance_t *ctx, 
-                                    const char *namespace, 
-                                    const struct ap_socache_hints *hints, 
+static apr_status_t socache_dc_init(ap_socache_instance_t *ctx,
+                                    const char *namespace,
+                                    const struct ap_socache_hints *hints,
                                     server_rec *s, apr_pool_t *p)
 {
 #if 0
@@ -90,13 +90,13 @@ static void socache_dc_destroy(ap_socache_instance_t *ctx, server_rec *s)
     }
 }
 
-static apr_status_t socache_dc_store(ap_socache_instance_t *ctx, server_rec *s, 
+static apr_status_t socache_dc_store(ap_socache_instance_t *ctx, server_rec *s,
                                      const unsigned char *id, unsigned int idlen,
                                      apr_time_t expiry,
                                      unsigned char *der, unsigned int der_len,
                                      apr_pool_t *p)
 {
-    /* !@#$%^ - why do we deal with *absolute* time anyway??? 
+    /* !@#$%^ - why do we deal with *absolute* time anyway???
      * Uhm - because most things expire things at a specific time?
      * Were the API were thought out expiry - r->request_time is a good approximation
      */
@@ -111,7 +111,7 @@ static apr_status_t socache_dc_store(ap_socache_instance_t *ctx, server_rec *s,
     return APR_SUCCESS;
 }
 
-static apr_status_t socache_dc_retrieve(ap_socache_instance_t *ctx, server_rec *s, 
+static apr_status_t socache_dc_retrieve(ap_socache_instance_t *ctx, server_rec *s,
                                         const unsigned char *id, unsigned int idlen,
                                         unsigned char *dest, unsigned int *destlen,
                                         apr_pool_t *p)
@@ -132,8 +132,8 @@ static apr_status_t socache_dc_retrieve(ap_socache_instance_t *ctx, server_rec *
     return APR_SUCCESS;
 }
 
-static apr_status_t socache_dc_remove(ap_socache_instance_t *ctx, 
-                                      server_rec *s, const unsigned char *id, 
+static apr_status_t socache_dc_remove(ap_socache_instance_t *ctx,
+                                      server_rec *s, const unsigned char *id,
                                       unsigned int idlen, apr_pool_t *p)
 {
     /* Remove any corresponding session from the distributed cache context */
@@ -177,7 +177,7 @@ static const ap_socache_provider_t socache_dc = {
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP, "dc", 
+    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP, "dc",
                          AP_SOCACHE_PROVIDER_VERSION,
                          &socache_dc);
 }
diff --git a/modules/cache/mod_socache_memcache.c b/modules/cache/mod_socache_memcache.c
index 9a3f26e..5376eeb 100644
--- a/modules/cache/mod_socache_memcache.c
+++ b/modules/cache/mod_socache_memcache.c
@@ -61,24 +61,24 @@ struct ap_socache_instance_t {
     apr_size_t taglen; /* strlen(tag) + 1 */
 };
 
-static const char *socache_mc_create(ap_socache_instance_t **context, 
-                                     const char *arg, 
+static const char *socache_mc_create(ap_socache_instance_t **context,
+                                     const char *arg,
                                      apr_pool_t *tmp, apr_pool_t *p)
 {
     ap_socache_instance_t *ctx;
-    
+
     *context = ctx = apr_palloc(p, sizeof *ctx);
 
     if (!arg || !*arg) {
         return "List of server names required to create memcache socache.";
     }
-    
+
     ctx->servers = apr_pstrdup(p, arg);
 
     return NULL;
 }
 
-static apr_status_t socache_mc_init(ap_socache_instance_t *ctx, 
+static apr_status_t socache_mc_init(ap_socache_instance_t *ctx,
                                     const char *namespace,
                                     const struct ap_socache_hints *hints,
                                     server_rec *s, apr_pool_t *p)
@@ -103,7 +103,7 @@ static apr_status_t socache_mc_init(ap_socache_instance_t *ctx,
     rv = apr_memcache_create(p, nservers, 0, &ctx->mc);
     if (rv != APR_SUCCESS) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
-                     "socache: Failed to create Memcache Object of '%d' size.", 
+                     "socache: Failed to create Memcache Object of '%d' size.",
                      nservers);
         return rv;
     }
@@ -144,7 +144,7 @@ static apr_status_t socache_mc_init(ap_socache_instance_t *ctx,
                                         &st);
         if (rv != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
-                         "socache: Failed to Create memcache Server: %s:%d", 
+                         "socache: Failed to Create memcache Server: %s:%d",
                          host_str, port);
             return rv;
         }
@@ -152,7 +152,7 @@ static apr_status_t socache_mc_init(ap_socache_instance_t *ctx,
         rv = apr_memcache_add_server(ctx->mc, st);
         if (rv != APR_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
-                         "socache: Failed to Add memcache Server: %s:%d", 
+                         "socache: Failed to Add memcache Server: %s:%d",
                          host_str, port);
             return rv;
         }
@@ -198,7 +198,7 @@ static int socache_mc_id2key(ap_socache_instance_t *ctx,
     return 0;
 }
 
-static apr_status_t socache_mc_store(ap_socache_instance_t *ctx, server_rec *s, 
+static apr_status_t socache_mc_store(ap_socache_instance_t *ctx, server_rec *s,
                                      const unsigned char *id, unsigned int idlen,
                                      apr_time_t expiry,
                                      unsigned char *ucaData, unsigned int nData,
@@ -224,7 +224,7 @@ static apr_status_t socache_mc_store(ap_socache_instance_t *ctx, server_rec *s,
     return APR_SUCCESS;
 }
 
-static apr_status_t socache_mc_retrieve(ap_socache_instance_t *ctx, server_rec *s, 
+static apr_status_t socache_mc_retrieve(ap_socache_instance_t *ctx, server_rec *s,
                                         const unsigned char *id, unsigned int idlen,
                                         unsigned char *dest, unsigned int *destlen,
                                         apr_pool_t *p)
@@ -252,7 +252,7 @@ static apr_status_t socache_mc_retrieve(ap_socache_instance_t *ctx, server_rec *
         ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                      "scache_mc: 'retrieve' OVERFLOW");
         return APR_ENOMEM;
-    }    
+    }
 
     memcpy(dest, data, data_len);
     *destlen = data_len;
@@ -260,8 +260,8 @@ static apr_status_t socache_mc_retrieve(ap_socache_instance_t *ctx, server_rec *
     return APR_SUCCESS;
 }
 
-static apr_status_t socache_mc_remove(ap_socache_instance_t *ctx, server_rec *s, 
-                                      const unsigned char *id, 
+static apr_status_t socache_mc_remove(ap_socache_instance_t *ctx, server_rec *s,
+                                      const unsigned char *id,
                                       unsigned int idlen, apr_pool_t *p)
 {
     char buf[MC_KEY_LEN];
@@ -313,7 +313,7 @@ static const ap_socache_provider_t socache_mc = {
 static void register_hooks(apr_pool_t *p)
 {
 #ifdef HAVE_APU_MEMCACHE
-    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP, "mc", 
+    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP, "mc",
                          AP_SOCACHE_PROVIDER_VERSION,
                          &socache_mc);
 #endif
diff --git a/modules/cache/mod_socache_shmcb.c b/modules/cache/mod_socache_shmcb.c
index 648a38f..c44c064 100644
--- a/modules/cache/mod_socache_shmcb.c
+++ b/modules/cache/mod_socache_shmcb.c
@@ -61,7 +61,7 @@ typedef struct {
     unsigned int subcache_data_size;
 } SHMCBHeader;
 
-/* 
+/*
  * Subcache structure - the start of each subcache, followed by
  * indexes then data
  */
@@ -72,7 +72,7 @@ typedef struct {
     unsigned int data_pos, data_used;
 } SHMCBSubcache;
 
-/* 
+/*
  * Index structure - each subcache has an array of these
  */
 typedef struct {
@@ -124,7 +124,7 @@ struct ap_socache_instance_t {
  *
  * Each in-use SHMCBIndex structure represents a single cached object.
  * The ID and data segment are stored consecutively in the subcache's
- * cyclic data buffer.  The "Data" segment can thus be seen to 
+ * cyclic data buffer.  The "Data" segment can thus be seen to
  * look like this, for example
  *
  * offset:  [ 0     1     2     3     4     5     6    ...
@@ -213,7 +213,7 @@ static void shmcb_cyclic_ntoc_memcpy(unsigned int buf_size, unsigned char *data,
  * SRC_LEN against the contents of cyclic buffer DATA (which is of
  * size BUF_SIZE), starting at offset DEST_OFFSET. Got that?  Good. */
 static int shmcb_cyclic_memcmp(unsigned int buf_size, unsigned char *data,
-                               unsigned int dest_offset, 
+                               unsigned int dest_offset,
                                const unsigned char *src,
                                unsigned int src_len)
 {
@@ -223,7 +223,7 @@ static int shmcb_cyclic_memcmp(unsigned int buf_size, unsigned char *data,
     else {
         /* Compare the two splits */
         int diff;
-        
+
         diff = memcmp(data + dest_offset, src, buf_size - dest_offset);
         if (diff) {
             return diff;
@@ -237,17 +237,17 @@ static int shmcb_cyclic_memcmp(unsigned int buf_size, unsigned char *data,
 /* Prototypes for low-level subcache operations */
 static void shmcb_subcache_expire(server_rec *, SHMCBHeader *, SHMCBSubcache *,
                                   apr_time_t);
-/* Returns zero on success, non-zero on failure. */   
+/* Returns zero on success, non-zero on failure. */
 static int shmcb_subcache_store(server_rec *s, SHMCBHeader *header,
-                                SHMCBSubcache *subcache, 
+                                SHMCBSubcache *subcache,
                                 unsigned char *data, unsigned int data_len,
                                 const unsigned char *id, unsigned int id_len,
                                 apr_time_t expiry);
-/* Returns zero on success, non-zero on failure. */   
+/* Returns zero on success, non-zero on failure. */
 static int shmcb_subcache_retrieve(server_rec *, SHMCBHeader *, SHMCBSubcache *,
                                    const unsigned char *id, unsigned int idlen,
                                    unsigned char *data, unsigned int *datalen);
-/* Returns zero on success, non-zero on failure. */   
+/* Returns zero on success, non-zero on failure. */
 static int shmcb_subcache_remove(server_rec *, SHMCBHeader *, SHMCBSubcache *,
                                  const unsigned char *, unsigned int);
 
@@ -269,7 +269,7 @@ static apr_status_t shmcb_subcache_iterate(ap_socache_instance_t *instance,
  */
 
 static const char *socache_shmcb_create(ap_socache_instance_t **context,
-                                        const char *arg, 
+                                        const char *arg,
                                         apr_pool_t *tmp, apr_pool_t *p)
 {
     ap_socache_instance_t *ctx;
@@ -277,14 +277,14 @@ static const char *socache_shmcb_create(ap_socache_instance_t **context,
 
     /* Allocate the context. */
     *context = ctx = apr_pcalloc(p, sizeof *ctx);
-    
+
     ctx->shm_size  = 1024*512; /* 512KB */
 
     if (!arg || *arg == '\0') {
         /* Use defaults. */
         return NULL;
     }
-    
+
     ctx->data_file = path = ap_server_root_relative(p, arg);
 
     cp = strrchr(path, '(');
@@ -297,24 +297,24 @@ static const char *socache_shmcb_create(ap_socache_instance_t **context,
         }
         *cp++ = '\0';
         *cp2  = '\0';
-        
-        
+
+
         ctx->shm_size = strtol(cp, &endptr, 10);
         if (endptr != cp2) {
             return "Invalid argument: cache size not numerical";
         }
-        
+
         if (ctx->shm_size < 8192) {
             return "Invalid argument: size has to be >= 8192 bytes";
-            
+
         }
-        
+
         if (ctx->shm_size >= SHMCB_MAX_SIZE) {
             return apr_psprintf(tmp,
                                 "Invalid argument: size has "
-                                "to be < %d bytes on this platform", 
+                                "to be < %d bytes on this platform",
                                 SHMCB_MAX_SIZE);
-            
+
         }
     }
     else if (cp2 >= path && *cp2 == ')') {
@@ -325,7 +325,7 @@ static const char *socache_shmcb_create(ap_socache_instance_t **context,
 }
 
 static apr_status_t socache_shmcb_init(ap_socache_instance_t *ctx,
-                                       const char *namespace, 
+                                       const char *namespace,
                                        const struct ap_socache_hints *hints,
                                        server_rec *s, apr_pool_t *p)
 {
@@ -338,7 +338,7 @@ static apr_status_t socache_shmcb_init(ap_socache_instance_t *ctx,
 
     /* Create shared memory segment */
     if (ctx->data_file == NULL) {
-        const char *path = apr_pstrcat(p, DEFAULT_SHMCB_PREFIX, namespace, 
+        const char *path = apr_pstrcat(p, DEFAULT_SHMCB_PREFIX, namespace,
                                        DEFAULT_SHMCB_SUFFIX, NULL);
 
         ctx->data_file = ap_server_root_relative(p, path);
@@ -394,7 +394,7 @@ static apr_status_t socache_shmcb_init(ap_socache_instance_t *ctx,
         num_subcache /= 2;
     num_idx /= num_subcache;
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-                 "for %" APR_SIZE_T_FMT " bytes (%" APR_SIZE_T_FMT 
+                 "for %" APR_SIZE_T_FMT " bytes (%" APR_SIZE_T_FMT
                  " including header), recommending %u subcaches, "
                  "%u indexes each", shm_segsize,
                  shm_segsize + sizeof(SHMCBHeader), num_subcache, num_idx);
@@ -461,9 +461,9 @@ static void socache_shmcb_destroy(ap_socache_instance_t *ctx, server_rec *s)
     }
 }
 
-static apr_status_t socache_shmcb_store(ap_socache_instance_t *ctx, 
-                                        server_rec *s, const unsigned char *id, 
-                                        unsigned int idlen, apr_time_t expiry, 
+static apr_status_t socache_shmcb_store(ap_socache_instance_t *ctx,
+                                        server_rec *s, const unsigned char *id,
+                                        unsigned int idlen, apr_time_t expiry,
                                         unsigned char *encoded,
                                         unsigned int len_encoded,
                                         apr_pool_t *p)
@@ -499,8 +499,8 @@ static apr_status_t socache_shmcb_store(ap_socache_instance_t *ctx,
     return APR_SUCCESS;
 }
 
-static apr_status_t socache_shmcb_retrieve(ap_socache_instance_t *ctx, 
-                                           server_rec *s, 
+static apr_status_t socache_shmcb_retrieve(ap_socache_instance_t *ctx,
+                                           server_rec *s,
                                            const unsigned char *id, unsigned int idlen,
                                            unsigned char *dest, unsigned int *destlen,
                                            apr_pool_t *p)
@@ -526,7 +526,7 @@ static apr_status_t socache_shmcb_retrieve(ap_socache_instance_t *ctx,
     return rv == 0 ? APR_SUCCESS : APR_NOTFOUND;
 }
 
-static apr_status_t socache_shmcb_remove(ap_socache_instance_t *ctx, 
+static apr_status_t socache_shmcb_remove(ap_socache_instance_t *ctx,
                                          server_rec *s, const unsigned char *id,
                                          unsigned int idlen, apr_pool_t *p)
 {
@@ -555,7 +555,7 @@ static apr_status_t socache_shmcb_remove(ap_socache_instance_t *ctx,
     return rv;
 }
 
-static void socache_shmcb_status(ap_socache_instance_t *ctx, 
+static void socache_shmcb_status(ap_socache_instance_t *ctx,
                                  request_rec *r, int flags)
 {
     server_rec *s = r->server;
@@ -654,7 +654,7 @@ static apr_status_t socache_shmcb_iterate(ap_socache_instance_t *instance,
 }
 
 /*
- * Subcache-level cache operations 
+ * Subcache-level cache operations
  */
 
 static void shmcb_subcache_expire(server_rec *s, SHMCBHeader *header,
@@ -704,7 +704,7 @@ static void shmcb_subcache_expire(server_rec *s, SHMCBHeader *header,
 }
 
 static int shmcb_subcache_store(server_rec *s, SHMCBHeader *header,
-                                SHMCBSubcache *subcache, 
+                                SHMCBSubcache *subcache,
                                 unsigned char *data, unsigned int data_len,
                                 const unsigned char *id, unsigned int id_len,
                                 apr_time_t expiry)
@@ -797,7 +797,7 @@ static int shmcb_subcache_store(server_rec *s, SHMCBHeader *header,
     idx->removed = 0;
     subcache->idx_used++;
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
-                 "insert happened at idx=%d, data=(%u:%u)", new_idx, 
+                 "insert happened at idx=%d, data=(%u:%u)", new_idx,
                  id_offset, data_offset);
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
                  "finished insert, subcache: idx_pos/idx_used=%d/%d, "
@@ -808,7 +808,7 @@ static int shmcb_subcache_store(server_rec *s, SHMCBHeader *header,
 }
 
 static int shmcb_subcache_retrieve(server_rec *s, SHMCBHeader *header,
-                                   SHMCBSubcache *subcache, 
+                                   SHMCBSubcache *subcache,
                                    const unsigned char *id, unsigned int idlen,
                                    unsigned char *dest, unsigned int *destlen)
 {
@@ -823,7 +823,7 @@ static int shmcb_subcache_retrieve(server_rec *s, SHMCBHeader *header,
 
         /* Only consider 'idx' if the id matches, and the "removed"
          * flag isn't set, and the record is not expired.
-         * Check the data length too to avoid a buffer overflow 
+         * Check the data length too to avoid a buffer overflow
          * in case of corruption, which should be impossible,
          * but it's cheap to be safe. */
         if (!idx->removed
@@ -838,7 +838,7 @@ static int shmcb_subcache_retrieve(server_rec *s, SHMCBHeader *header,
                 unsigned int data_offset;
 
                 /* Find the offset of the data segment, after the id */
-                data_offset = SHMCB_CYCLIC_INCREMENT(idx->data_pos, 
+                data_offset = SHMCB_CYCLIC_INCREMENT(idx->data_pos,
                                                      idx->id_len,
                                                      header->subcache_data_size);
 
@@ -936,13 +936,13 @@ static apr_status_t shmcb_subcache_iterate(ap_socache_instance_t *instance,
                 apr_size_t buf_req;
 
                 /* Find the offset of the data segment, after the id */
-                data_offset = SHMCB_CYCLIC_INCREMENT(idx->data_pos, 
+                data_offset = SHMCB_CYCLIC_INCREMENT(idx->data_pos,
                                                      idx->id_len,
                                                      header->subcache_data_size);
 
                 dest_len = idx->data_used - idx->id_len;
 
-                buf_req = APR_ALIGN_DEFAULT(idx->id_len + 1) 
+                buf_req = APR_ALIGN_DEFAULT(idx->id_len + 1)
                         + APR_ALIGN_DEFAULT(dest_len + 1);
 
                 if (buf_req > *buf_len) {
@@ -1004,12 +1004,12 @@ static const ap_socache_provider_t socache_shmcb = {
 
 static void register_hooks(apr_pool_t *p)
 {
-    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP, "shmcb", 
+    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP, "shmcb",
                          AP_SOCACHE_PROVIDER_VERSION,
                          &socache_shmcb);
 
     /* Also register shmcb under the default provider name. */
-    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP, 
+    ap_register_provider(p, AP_SOCACHE_PROVIDER_GROUP,
                          AP_SOCACHE_DEFAULT_PROVIDER,
                          AP_SOCACHE_PROVIDER_VERSION,
                          &socache_shmcb);
diff --git a/modules/cluster/mod_heartmonitor.c b/modules/cluster/mod_heartmonitor.c
index f53635e..b6cdb52 100644
--- a/modules/cluster/mod_heartmonitor.c
+++ b/modules/cluster/mod_heartmonitor.c
@@ -275,10 +275,10 @@ static apr_status_t hm_file_update_stat(hm_ctx_t *ctx, hm_server_t *s, apr_pool_
             apr_brigade_cleanup(tmpbb);
             if (APR_BRIGADE_EMPTY(bb)) {
                 break;
-            } 
+            }
             rv = apr_brigade_split_line(tmpbb, bb,
                                         APR_BLOCK_READ, sizeof(buf));
-       
+
             if (rv) {
                 ap_log_error(APLOG_MARK, APLOG_CRIT, rv, ctx->s,
                              "Heartmonitor: Unable to read from file: %s", ctx->storage_path);
@@ -300,7 +300,7 @@ static apr_status_t hm_file_update_stat(hm_ctx_t *ctx, hm_server_t *s, apr_pool_
                 /* copy things we can't process */
                 apr_file_printf(fp, "%s\n", buf);
             } else if (strcmp(ip, s->ip) !=0 ) {
-                hm_server_t node; 
+                hm_server_t node;
                 apr_time_t seen;
                 /* Update seen time according to the last file modification */
                 apr_table_clear(hbt);
@@ -320,14 +320,14 @@ static apr_status_t hm_file_update_stat(hm_ctx_t *ctx, hm_server_t *s, apr_pool_
                 if (apr_table_get(hbt, "lastseen")) {
                     node.seen = atoi(apr_table_get(hbt, "lastseen"));
                 } else {
-                    node.seen = SEEN_TIMEOUT; 
+                    node.seen = SEEN_TIMEOUT;
                 }
                 seen = fage + node.seen;
 
                 if (apr_table_get(hbt, "port")) {
                     node.port = atoi(apr_table_get(hbt, "port"));
                 } else {
-                    node.port = 80; 
+                    node.port = 80;
                 }
                 apr_file_printf(fp, "%s &ready=%u&busy=%u&lastseen=%u&port=%u\n",
                                 ip, node.ready, node.busy, (unsigned int) seen, node.port);
@@ -361,7 +361,7 @@ static apr_status_t hm_file_update_stat(hm_ctx_t *ctx, hm_server_t *s, apr_pool_
                    "Heartmonitor: Unable to close file: %s", path);
       return rv;
     }
-  
+
     rv = apr_file_perms_set(path,
                             APR_FPROT_UREAD | APR_FPROT_GREAD |
                             APR_FPROT_WREAD);
@@ -440,7 +440,7 @@ static apr_status_t hm_file_update_stats(hm_ctx_t *ctx, apr_pool_t *p)
                    "Heartmonitor: Unable to close file: %s", path);
       return rv;
     }
-  
+
     rv = apr_file_perms_set(path,
                             APR_FPROT_UREAD | APR_FPROT_GREAD |
                             APR_FPROT_WREAD);
@@ -542,7 +542,7 @@ static void hm_processmsg(hm_ctx_t *ctx, apr_pool_t *p,
 
         if (apr_table_get(tbl, "port") != NULL)
             port = atoi(apr_table_get(tbl, "port"));
-           
+
         s = hm_get_server(ctx, ip, port);
 
         s->busy = atoi(apr_table_get(tbl, "busy"));
@@ -879,7 +879,7 @@ static const char *cmd_hm_maxworkers(cmd_parms *cmd,
 
     maxworkers = atoi(data);
     if (maxworkers <= 10)
-        return "HeartbeatMaxServers: Should be bigger than 10"; 
+        return "HeartbeatMaxServers: Should be bigger than 10";
 
     return NULL;
 }
diff --git a/modules/core/mod_so.c b/modules/core/mod_so.c
index 7be9c06..5f44f81 100644
--- a/modules/core/mod_so.c
+++ b/modules/core/mod_so.c
@@ -271,7 +271,7 @@ static const char *load_module(cmd_parms *cmd, void *dummy,
                             "is garbled - expected signature %08lx but saw "
                             "%08lx - perhaps this is not an Apache module DSO, "
                             "or was compiled for a different Apache version?",
-                            modname, szModuleFile, 
+                            modname, szModuleFile,
                             MODULE_MAGIC_COOKIE, modp->magic);
     }
 
diff --git a/modules/dav/fs/repos.c b/modules/dav/fs/repos.c
index 7a22000..40395ca 100644
--- a/modules/dav/fs/repos.c
+++ b/modules/dav/fs/repos.c
@@ -143,7 +143,7 @@ enum {
 /*
  * prefix for temporary files
  */
-#define DAV_FS_TMP_PREFIX ".davfs.tmp" 
+#define DAV_FS_TMP_PREFIX ".davfs.tmp"
 
 static const dav_liveprop_spec dav_fs_props[] =
 {
@@ -360,7 +360,7 @@ static dav_error * dav_fs_copymove_file(
 
     dav_set_bufsize(p, pbuf, DAV_FS_COPY_BLOCKSIZE);
 
-    if ((status = apr_file_open(&inf, src, APR_READ | APR_BINARY, 
+    if ((status = apr_file_open(&inf, src, APR_READ | APR_BINARY,
                                 APR_OS_DEFAULT, p)) != APR_SUCCESS) {
         /* ### use something besides 500? */
         return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
@@ -391,7 +391,7 @@ static dav_error * dav_fs_copymove_file(
                 /* ### ACK! Inconsistent state... */
 
                 /* ### use something besides 500? */
-                return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 
+                return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
                                      lcl_status,
                                      "Could not delete output after read "
                                      "failure. Server is now in an "
@@ -448,7 +448,7 @@ static dav_error * dav_fs_copymove_file(
                                               "server may be in an "
                                               "inconsistent state.", src, dst));
             return err;
-        } 
+        }
         else if ((lcl_status = apr_file_remove(dst, p)) != APR_SUCCESS) {
             /* ### ACK. this creates an inconsistency. do more!? */
 
@@ -899,7 +899,7 @@ static apr_status_t dav_fs_mktemp(apr_file_t **fp, char *templ, apr_pool_t *p)
                            APR_WRITE | APR_CREATE | APR_BINARY | APR_EXCL,
                            APR_OS_DEFAULT, p);
     } while (APR_STATUS_IS_EEXIST(rv));
-        
+
     return rv;
 }
 
diff --git a/modules/dav/main/mod_dav.c b/modules/dav/main/mod_dav.c
index c246c3c..7e0ae21 100644
--- a/modules/dav/main/mod_dav.c
+++ b/modules/dav/main/mod_dav.c
@@ -1622,18 +1622,18 @@ static int dav_method_options(request_rec *r)
     /* DAV header additions registered by external modules */
     extensions = ap_list_provider_names(r->pool, DAV_OPTIONS_EXTENSION_GROUP, "0");
     entry = (ap_list_provider_names_t *)extensions->elts;
-	
+
     for (i = 0; i < extensions->nelts; i++, entry++) {
-	const dav_options_provider *options = 
+	const dav_options_provider *options =
 	    dav_get_options_providers(entry->provider_name);
-	
+
 	if (options && options->dav_header) {
 	    apr_text_header hoptions = { 0 };
-	    
+
 	    options->dav_header(r, resource, &hoptions);
 	    for (t = hoptions.first; t && t->text; t = t->next)
 		dav_level = apr_pstrcat(r->pool, dav_level, ",", t->text, NULL);
-	}   
+	}
     }
 
     /* ###
@@ -1782,18 +1782,18 @@ static int dav_method_options(request_rec *r)
     /* additional methods registered by external modules */
     extensions = ap_list_provider_names(r->pool, DAV_OPTIONS_EXTENSION_GROUP, "0");
     entry = (ap_list_provider_names_t *)extensions->elts;
-    
+
     for (i = 0; i < extensions->nelts; i++, entry++) {
-	const dav_options_provider *options = 
+	const dav_options_provider *options =
 	    dav_get_options_providers(entry->provider_name);
-	
+
 	if (options && options->dav_method) {
 	    apr_text_header hoptions = { 0 };
-	    
+
 	    options->dav_method(r, resource, &hoptions);
 	    for (t = hoptions.first; t && t->text; t = t->next)
 		apr_table_addn(methods, t->text, "");
-	}    
+	}
     }
 
     /* Generate the Allow header */
@@ -3045,7 +3045,7 @@ static int dav_method_lock(request_rec *r)
         err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
                            apr_psprintf(r->pool,
                                         "The parent resource of %s does not "
-                                        "exist or is not a collection.", 
+                                        "exist or is not a collection.",
                                         ap_escape_html(r->pool, r->uri)));
         return dav_handle_err(r, err, NULL);
     }
diff --git a/modules/dav/main/util.c b/modules/dav/main/util.c
index 7659b72..d076cc4 100644
--- a/modules/dav/main/util.c
+++ b/modules/dav/main/util.c
@@ -1421,11 +1421,11 @@ static int dav_meets_conditions(request_rec *r, int resource_state)
 
     retVal = ap_meets_conditions(r);
 
-    /* If-None-Match '*' fix. If-None-Match '*' request should succeed 
+    /* If-None-Match '*' fix. If-None-Match '*' request should succeed
      * if the resource does not exist. */
     if (retVal == HTTP_PRECONDITION_FAILED) {
         /* Note. If if_none_match != NULL, if_none_match is the culprit.
-         * Since, in presence of If-None-Match, 
+         * Since, in presence of If-None-Match,
          * other If-* headers are undefined. */
         if ((if_none_match =
             apr_table_get(r->headers_in, "If-None-Match")) != NULL) {
diff --git a/modules/echo/mod_echo.c b/modules/echo/mod_echo.c
index c595496..161ceed 100644
--- a/modules/echo/mod_echo.c
+++ b/modules/echo/mod_echo.c
@@ -92,7 +92,7 @@ static apr_status_t brigade_peek(apr_bucket_brigade *bbIn,
 }
 
 
-static int update_echo_child_status(ap_sb_handle_t *sbh, 
+static int update_echo_child_status(ap_sb_handle_t *sbh,
                                     int status, conn_rec *c,
                                     apr_bucket_brigade *last_echoed)
 {
@@ -108,7 +108,7 @@ static int update_echo_child_status(ap_sb_handle_t *sbh,
 
     /* initial pass only, please - in the name of efficiency */
     if (c) {
-        apr_cpystrn(ws->client, 
+        apr_cpystrn(ws->client,
                     ap_get_remote_host(c, c->base_server->lookup_defaults,
                                        REMOTE_NOLOOKUP, NULL),
                     sizeof(ws->client));
@@ -120,7 +120,7 @@ static int update_echo_child_status(ap_sb_handle_t *sbh,
 
     /* each subsequent WRITE pass, let's update what we echoed */
     if (last_echoed) {
-        brigade_peek(last_echoed, ws->request + sizeof("ECHO ") - 1, 
+        brigade_peek(last_echoed, ws->request + sizeof("ECHO ") - 1,
                      sizeof(ws->request) - sizeof("ECHO ") + 1);
     }
 
@@ -138,7 +138,7 @@ static int process_echo_connection(conn_rec *c)
     if (!pConfig->bEnabled) {
         return DECLINED;
     }
-    
+
     ap_time_process_request(c->sbh, START_PREQUEST);
     update_echo_child_status(c->sbh, SERVER_BUSY_READ, c, NULL);
 
@@ -182,7 +182,7 @@ static int process_echo_connection(conn_rec *c)
             ap_log_error(APLOG_MARK, APLOG_INFO, rv, c->base_server,
                          "ProtocolEcho: Failure writing to %s",
                          c->remote_ip);
-            break; 
+            break;
         }
         apr_brigade_cleanup(bb);
 
diff --git a/modules/examples/mod_case_filter.c b/modules/examples/mod_case_filter.c
index 6c07d37..f0b84d2 100644
--- a/modules/examples/mod_case_filter.c
+++ b/modules/examples/mod_case_filter.c
@@ -91,7 +91,7 @@ static apr_status_t CaseFilterOutFilter(ap_filter_t *f,
         APR_BRIGADE_INSERT_TAIL(pbbOut,pbktOut);
         }
 
-    /* Q: is there any advantage to passing a brigade for each bucket? 
+    /* Q: is there any advantage to passing a brigade for each bucket?
      * A: obviously, it can cut down server resource consumption, if this
      * experimental module was fed a file of 4MB, it would be using 8MB for
      * the 'read' buckets and the 'write' buckets.
diff --git a/modules/examples/mod_example_hooks.c b/modules/examples/mod_example_hooks.c
index 2a685de..4a3bfb3 100644
--- a/modules/examples/mod_example_hooks.c
+++ b/modules/examples/mod_example_hooks.c
@@ -27,36 +27,36 @@
  *
  * To use mod_example_hooks, configure the Apache build with
  * --enable-example and compile.  Set up a <Location> block in your
- * configuration file like so: 
- * 
+ * configuration file like so:
+ *
  * <Location /example>
  *    SetHandler example-hooks-handler
- * </Location> 
- * 
- * When you look at that location on your server, you will see a backtrace of 
- * the callbacks that have been invoked up to that point.  See the ErrorLog for 
- * more information on code paths that  touch mod_example_hooks. 
+ * </Location>
+ *
+ * When you look at that location on your server, you will see a backtrace of
+ * the callbacks that have been invoked up to that point.  See the ErrorLog for
+ * more information on code paths that  touch mod_example_hooks.
  *
  * IMPORTANT NOTES
  * ===============
- * 
+ *
  * Do NOT use this module on a production server. It attaches itself to every
  * phase of the server runtime operations including startup, shutdown and
- * request processing, and produces copious amounts of logging data.  This will 
- * negatively affect server performance. 
- * 
+ * request processing, and produces copious amounts of logging data.  This will
+ * negatively affect server performance.
+ *
  * Do NOT use mod_example_hooks as the basis for your own code.  This module
  * implements every callback hook offered by the Apache core, and your
  * module will almost certainly not have to implement this much.  If you
- * want a simple module skeleton to start development, use apxs -g. 
- * 
+ * want a simple module skeleton to start development, use apxs -g.
+ *
  * XXX TO DO XXX
  * =============
  *
- * * Enable HTML backtrace entries for more callbacks that are not directly 
+ * * Enable HTML backtrace entries for more callbacks that are not directly
  *   associated with a request
  * * Make sure every callback that posts an HTML backtrace entry does so in the *   right category, so nothing gets overwritten
- * * Implement some logic to show what happens in the parent, and what in the 
+ * * Implement some logic to show what happens in the parent, and what in the
  *   child(ren)
  */
 
@@ -120,8 +120,8 @@ typedef struct x_cfg {
 } x_cfg;
 
 /*
- * String pointer to hold the startup trace. No harm working with a global until 
- * the server is (may be) multi-threaded. 
+ * String pointer to hold the startup trace. No harm working with a global until
+ * the server is (may be) multi-threaded.
  */
 static const char *trace = NULL;
 
@@ -283,10 +283,10 @@ static x_cfg *our_dconfig(const request_rec *r)
     return (x_cfg *) ap_get_module_config(r->per_dir_config, &example_hooks_module);
 }
 
-/* 
- * The following utility routines are not used in the module. Don't 
- * compile them so -Wall doesn't complain about functions that are 
- * defined but not used. 
+/*
+ * The following utility routines are not used in the module. Don't
+ * compile them so -Wall doesn't complain about functions that are
+ * defined but not used.
  */
 #if 0
 /*
@@ -320,15 +320,15 @@ static x_cfg *our_cconfig(const conn_rec *c)
  * these co-routines are called for every single request, and the impact
  * on the size (and readability) of the error_log is considerable.
  */
-#ifndef EXAMPLE_LOG_EACH 
+#ifndef EXAMPLE_LOG_EACH
 #define EXAMPLE_LOG_EACH 0
 #endif
 
-#if EXAMPLE_LOG_EACH 
+#if EXAMPLE_LOG_EACH
 static void example_log_each(apr_pool_t *p, server_rec *s, const char *note)
 {
     if (s != NULL) {
-        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "mod_example: %s", 
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "mod_example: %s",
                      note);
     } else {
         apr_file_t *out = NULL;
@@ -339,19 +339,19 @@ static void example_log_each(apr_pool_t *p, server_rec *s, const char *note)
 }
 #endif
 
-/* 
- * This utility routine traces the hooks called when the server starts up. 
- * It leaves a trace in a global variable, so it should not be called from 
- * a hook handler that runs in a multi-threaded situation. 
+/*
+ * This utility routine traces the hooks called when the server starts up.
+ * It leaves a trace in a global variable, so it should not be called from
+ * a hook handler that runs in a multi-threaded situation.
  */
 
-static void trace_startup(apr_pool_t *p, server_rec *s, x_cfg *mconfig, 
+static void trace_startup(apr_pool_t *p, server_rec *s, x_cfg *mconfig,
                           const char *note)
 {
     const char *sofar;
     char *where, *addon;
 
-#if EXAMPLE_LOG_EACH 
+#if EXAMPLE_LOG_EACH
     example_log_each(p, s, note);
 #endif
 
@@ -374,28 +374,28 @@ static void trace_startup(apr_pool_t *p, server_rec *s, x_cfg *mconfig,
                         "   </li>\n",
                         NULL);
 
-    /* 
-     * Make sure that we start with a valid string, even if we have never been 
-     * called.  
+    /*
+     * Make sure that we start with a valid string, even if we have never been
+     * called.
      */
     sofar = (trace == NULL) ? "" : trace;
-    
+
     trace = apr_pstrcat(p, sofar, addon, NULL);
 }
 
 
 /*
- * This utility route traces the hooks called as a request is handled. 
- * It takes the current request as argument 
+ * This utility route traces the hooks called as a request is handled.
+ * It takes the current request as argument
  */
 #define TRACE_NOTE "example-hooks-trace"
- 
+
 static void trace_request(const request_rec *r, const char *note)
 {
     const char *trace_copy, *sofar;
     char *addon, *where;
     x_cfg *cfg;
-    
+
 #if EXAMPLE_LOG_EACH
     example_log_each(r->pool, r->server, note);
 #endif
@@ -403,13 +403,13 @@ static void trace_request(const request_rec *r, const char *note)
     if ((sofar = apr_table_get(r->notes, TRACE_NOTE)) == NULL) {
         sofar = "";
     }
-    
+
     cfg = our_dconfig(r);
-    
+
     where = (cfg != NULL) ? cfg->loc : "nowhere";
     where = (where != NULL) ? where : "";
-    
-    addon = apr_pstrcat(r->pool, 
+
+    addon = apr_pstrcat(r->pool,
                         "   <li>\n"
                         "    <dl>\n"
                         "     <dt><samp>", note, "</samp></dt>\n"
@@ -423,12 +423,12 @@ static void trace_request(const request_rec *r, const char *note)
 }
 
 /*
- * This utility routine traces the hooks called while processing a 
- * Connection. Its trace is kept in the pool notes of the pool associated 
+ * This utility routine traces the hooks called while processing a
+ * Connection. Its trace is kept in the pool notes of the pool associated
  * with the Connection.
  */
 
-/* 
+/*
  * Key to get and set the userdata.  We should be able to get away
  * with a constant key, since in prefork mode the process will have
  * the connection and its pool to itself entirely, and in
@@ -436,7 +436,7 @@ static void trace_request(const request_rec *r, const char *note)
  */
 #define CONN_NOTE "example-hooks-connection"
 
-static void trace_connection(conn_rec *c, const char *note) 
+static void trace_connection(conn_rec *c, const char *note)
 {
     const char *trace_copy, *sofar;
     char *addon, *where;
@@ -451,8 +451,8 @@ static void trace_connection(conn_rec *c, const char *note)
 
     where = (cfg != NULL) ? cfg->loc : "nowhere";
     where = (where != NULL) ? where : "";
-    
-    addon = apr_pstrcat(c->pool, 
+
+    addon = apr_pstrcat(c->pool,
                         "   <li>\n"
                         "    <dl>\n"
                         "     <dt><samp>", note, "</samp></dt>\n"
@@ -468,7 +468,7 @@ static void trace_connection(conn_rec *c, const char *note)
     /* Tack addon onto copy */
     trace_copy = apr_pstrcat(c->pool, sofar, addon, NULL);
 
-    /* 
+    /*
      * Stash copy back into pool notes.  This call has a cleanup
      * parameter, but we're not using it because the string has been
      * allocated from that same pool.  There is also an unused return
@@ -476,14 +476,14 @@ static void trace_connection(conn_rec *c, const char *note)
      * occur, and will have to check for the existence of this data on
      * the other end.
      */
-    apr_pool_userdata_set((const void *) trace_copy, CONN_NOTE, 
+    apr_pool_userdata_set((const void *) trace_copy, CONN_NOTE,
                           NULL, c->pool);
 }
 
-static void trace_nocontext(apr_pool_t *p, const char *file, int line, 
+static void trace_nocontext(apr_pool_t *p, const char *file, int line,
                             const char *note)
 {
-    /* 
+    /*
      * Since we have no request or connection to trace, or any idea
      * from where this routine was called, there's really not much we
      * can do.  If we are not logging everything by way of the
@@ -565,7 +565,7 @@ static void *x_create_dir_config(apr_pool_t *p, char *dirspec)
      */
     dname = (dname != NULL) ? dname : "";
     cfg->loc = apr_pstrcat(p, "DIR(", dname, ")", NULL);
-    note = apr_psprintf(p, "x_create_dir_config(p == %pp, dirspec == %s)", 
+    note = apr_psprintf(p, "x_create_dir_config(p == %pp, dirspec == %s)",
                         (void*) p, dirspec);
     trace_startup(p, NULL, cfg, note);
     return (void *) cfg;
@@ -618,7 +618,7 @@ static void *x_merge_dir_config(apr_pool_t *p, void *parent_conf,
      * Now just record our being called in the trace list.  Include the
      * locations we were asked to merge.
      */
-    note = apr_psprintf(p, "x_merge_dir_config(p == %pp, parent_conf == " 
+    note = apr_psprintf(p, "x_merge_dir_config(p == %pp, parent_conf == "
                         "%pp, newloc_conf == %pp)", (void*) p,
                         (void*) parent_conf, (void*) newloc_conf);
     trace_startup(p, NULL, merged_config, note);
@@ -773,7 +773,7 @@ static int x_check_config(apr_pool_t *pconf, apr_pool_t *plog,
  * phase and just before the process exits.  At this point the module
  * may output any information useful in configuration testing.
  *
- * This is a VOID hook: all defined handlers get called. 
+ * This is a VOID hook: all defined handlers get called.
  */
 static void x_test_config(apr_pool_t *pconf, server_rec *s)
 {
@@ -782,7 +782,7 @@ static void x_test_config(apr_pool_t *pconf, server_rec *s)
     apr_file_open_stderr(&out, pconf);
 
     apr_file_printf(out, "Example module configuration test routine\n");
-    
+
     trace_startup(pconf, s, NULL, "x_test_config()");
 }
 
@@ -846,7 +846,7 @@ static apr_status_t x_child_exit(void *data)
 /*
  * All our process initialiser does is add its trace to the log.
  *
- * This is a VOID hook: all defined handlers get called. 
+ * This is a VOID hook: all defined handlers get called.
  */
 static void x_child_init(apr_pool_t *p, server_rec *s)
 {
@@ -865,17 +865,17 @@ static void x_child_init(apr_pool_t *p, server_rec *s)
 }
 
 /*
- * The hook runner for ap_hook_http_scheme is aliased to ap_http_scheme(), 
- * a routine that the core and other modules call when they need to know 
+ * The hook runner for ap_hook_http_scheme is aliased to ap_http_scheme(),
+ * a routine that the core and other modules call when they need to know
  * the URL scheme for the request.  For instance, mod_ssl returns "https"
- * if the server_rec associated with the request has SSL enabled. 
+ * if the server_rec associated with the request has SSL enabled.
  *
- * This hook was named 'ap_hook_http_method' in httpd 2.0. 
+ * This hook was named 'ap_hook_http_method' in httpd 2.0.
  *
- * This is a RUN_FIRST hook: the first handler to return a non NULL 
- * value aborts the handler chain.  The http_core module inserts a 
+ * This is a RUN_FIRST hook: the first handler to return a non NULL
+ * value aborts the handler chain.  The http_core module inserts a
  * fallback handler (with APR_HOOK_REALLY_LAST preference) that returns
- * "http". 
+ * "http".
  */
 static const char *x_http_scheme(const request_rec *r)
 {
@@ -891,14 +891,14 @@ static const char *x_http_scheme(const request_rec *r)
 /*
  * The runner for this hook is aliased to ap_default_port(), which the
  * core and other modules call when they need to know the default port
- * for a particular server.  This is used for instance to omit the 
+ * for a particular server.  This is used for instance to omit the
  * port number from a Redirect response Location header URL if the port
- * number is equal to the default port for the service (like 80 for http). 
+ * number is equal to the default port for the service (like 80 for http).
  *
- * This is a RUN_FIRST hook: the first handler to return a non-zero 
- * value is the last one executed.  The http_core module inserts a 
+ * This is a RUN_FIRST hook: the first handler to return a non-zero
+ * value is the last one executed.  The http_core module inserts a
  * fallback handler (with APR_HOOK_REALLY_LAST order specifier) that
- * returns 80. 
+ * returns 80.
  */
 static apr_port_t x_default_port(const request_rec *r)
 {
@@ -911,29 +911,29 @@ static apr_port_t x_default_port(const request_rec *r)
 
 /*
  * This routine is called just before the handler gets invoked. It allows
- * a module to insert a previously defined filter into the filter chain. 
- * 
+ * a module to insert a previously defined filter into the filter chain.
+ *
  * No filter has been defined by this module, so we just log the call
- * and exit. 
+ * and exit.
  *
- * This is a VOID hook: all defined handlers get called. 
+ * This is a VOID hook: all defined handlers get called.
  */
 static void x_insert_filter(request_rec *r)
 {
     /*
      * Log the call and exit.
      */
-    trace_request(r, "x_insert_filter()"); 
+    trace_request(r, "x_insert_filter()");
 }
 
-/* 
- * This routine is called to insert a previously defined error filter into 
- * the filter chain as the request is being processed. 
- * 
- * For the purpose of this example, we don't have a filter to insert, 
- * so just add to the trace and exit. 
- * 
- * This is a VOID hook: all defined handlers get called. 
+/*
+ * This routine is called to insert a previously defined error filter into
+ * the filter chain as the request is being processed.
+ *
+ * For the purpose of this example, we don't have a filter to insert,
+ * so just add to the trace and exit.
+ *
+ * This is a VOID hook: all defined handlers get called.
  */
 static void x_insert_error_filter(request_rec *r)
 {
@@ -957,30 +957,30 @@ static void x_insert_error_filter(request_rec *r)
 /*
  * Sample content handler.  All this does is display the call list that has
  * been built up so far.
- * 
+ *
  * This routine gets called for every request, unless another handler earlier
- * in the callback chain has already handled the request. It is up to us to 
- * test the request_rec->handler field and see whether we are meant to handle 
- * this request. 
+ * in the callback chain has already handled the request. It is up to us to
+ * test the request_rec->handler field and see whether we are meant to handle
+ * this request.
  *
- * The content handler gets to write directly to the client using calls like 
+ * The content handler gets to write directly to the client using calls like
  * ap_rputs() and ap_rprintf()
  *
- * This is a RUN_FIRST hook. 
+ * This is a RUN_FIRST hook.
  */
 static int x_handler(request_rec *r)
 {
     x_cfg *dcfg;
-    char *note; 
+    char *note;
     void *conn_data;
     apr_status_t status;
 
     dcfg = our_dconfig(r);
-    /* 
-     * Add our trace to the log, and whether we get to write 
-     * content for this request. 
+    /*
+     * Add our trace to the log, and whether we get to write
+     * content for this request.
      */
-    note = apr_pstrcat(r->pool, "x_handler(), handler is \"", 
+    note = apr_pstrcat(r->pool, "x_handler(), handler is \"",
                       r->handler, "\"", NULL);
     trace_request(r, note);
 
@@ -990,8 +990,8 @@ static int x_handler(request_rec *r)
     }
 
     /*
-     * Set the Content-type header. Note that we do not actually have to send 
-     * the headers: this is done by the http core. 
+     * Set the Content-type header. Note that we do not actually have to send
+     * the headers: this is done by the http core.
      */
     ap_set_content_type(r, "text/html");
     /*
@@ -1046,7 +1046,7 @@ static int x_handler(request_rec *r)
             trace);
     ap_rputs("  <H2>Connection-specific callbacks so far:</H2>\n", r);
 
-    status =  apr_pool_userdata_get(&conn_data, CONN_NOTE, 
+    status =  apr_pool_userdata_get(&conn_data, CONN_NOTE,
                                     r->connection->pool);
     if ((status == APR_SUCCESS) && conn_data) {
         ap_rprintf(r, "  <OL>\n%s  </OL>\n", (char *) conn_data);
@@ -1081,17 +1081,17 @@ static int x_handler(request_rec *r)
 }
 
 /*
- * The quick_handler hook presents modules with a very powerful opportunity to 
- * serve their content in a very early request phase.  Note that this handler 
- * can not serve any requests from the file system because hooks like 
- * map_to_storage have not run.  The quick_handler hook also runs before any 
- * authentication and access control. 
+ * The quick_handler hook presents modules with a very powerful opportunity to
+ * serve their content in a very early request phase.  Note that this handler
+ * can not serve any requests from the file system because hooks like
+ * map_to_storage have not run.  The quick_handler hook also runs before any
+ * authentication and access control.
  *
- * This hook is used by mod_cache to serve cached content.  
+ * This hook is used by mod_cache to serve cached content.
  *
- * This is a RUN_FIRST hook. Return OK if you have served the request, 
- * DECLINED if you want processing to continue, or a HTTP_* error code to stop 
- * processing the request. 
+ * This is a RUN_FIRST hook. Return OK if you have served the request,
+ * DECLINED if you want processing to continue, or a HTTP_* error code to stop
+ * processing the request.
  */
 static int x_quick_handler(request_rec *r, int lookup_uri)
 {
@@ -1113,12 +1113,12 @@ static int x_quick_handler(request_rec *r, int lookup_uri)
  */
 static int x_pre_connection(conn_rec *c, void *csd)
 {
-    char *note; 
+    char *note;
 
     /*
      * Log the call and exit.
      */
-    note = apr_psprintf(c->pool, "x_pre_connection(c = %pp, p = %pp)", 
+    note = apr_psprintf(c->pool, "x_pre_connection(c = %pp, p = %pp)",
                         (void*) c, (void*) c->pool);
     trace_connection(c, note);
 
@@ -1136,7 +1136,7 @@ static int x_pre_connection(conn_rec *c, void *csd)
 static int x_process_connection(conn_rec *c)
 {
     trace_connection(c, "x_process_connection()");
-    
+
     return DECLINED;
 }
 
@@ -1216,7 +1216,7 @@ static int x_map_to_storage(request_rec *r)
  * to the filename. For example this phase can be used to block evil
  * clients, while little resources were wasted on these.
  *
- * This is a RUN_ALL hook. 
+ * This is a RUN_ALL hook.
  */
 static int x_header_parser(request_rec *r)
 {
@@ -1235,7 +1235,7 @@ static int x_header_parser(request_rec *r)
  * example.)
  *
  * This is a RUN_ALL hook. The first handler to return a status other than OK
- * or DECLINED (for instance, HTTP_FORBIDDEN) aborts the callback chain. 
+ * or DECLINED (for instance, HTTP_FORBIDDEN) aborts the callback chain.
  */
 static int x_check_access(request_rec *r)
 {
@@ -1248,8 +1248,8 @@ static int x_check_access(request_rec *r)
  * the request (such as looking up the user in a database and verifying that
  * the [encrypted] password sent matches the one in the database).
  *
- * This is a RUN_FIRST hook. The return value is OK, DECLINED, or some 
- * HTTP_mumble error (typically HTTP_UNAUTHORIZED).  
+ * This is a RUN_FIRST hook. The return value is OK, DECLINED, or some
+ * HTTP_mumble error (typically HTTP_UNAUTHORIZED).
  */
 static int x_check_authn(request_rec *r)
 {
@@ -1264,8 +1264,8 @@ static int x_check_authn(request_rec *r)
  * This routine is called to check to see if the resource being requested
  * requires authorisation.
  *
- * This is a RUN_FIRST hook. The return value is OK, DECLINED, or 
- * HTTP_mumble.  If we return OK, no other modules are called during this 
+ * This is a RUN_FIRST hook. The return value is OK, DECLINED, or
+ * HTTP_mumble.  If we return OK, no other modules are called during this
  * phase.
  *
  * If *all* modules return DECLINED, the request is aborted with a server
@@ -1317,7 +1317,7 @@ static int x_fixups(request_rec *r)
  * This routine is called to perform any module-specific logging activities
  * over and above the normal server things.
  *
- * This is a RUN_ALL hook. 
+ * This is a RUN_ALL hook.
  */
 static int x_log_transaction(request_rec *r)
 {
@@ -1329,13 +1329,13 @@ static int x_log_transaction(request_rec *r)
 
 /*
  * This routine is called to find out under which user id to run suexec
- * Unless our module runs CGI programs, there is no reason for us to 
- * mess with this information. 
- * 
- * This is a RUN_FIRST hook. The return value is a pointer to an 
- * ap_unix_identity_t or NULL. 
+ * Unless our module runs CGI programs, there is no reason for us to
+ * mess with this information.
+ *
+ * This is a RUN_FIRST hook. The return value is a pointer to an
+ * ap_unix_identity_t or NULL.
  */
-static ap_unix_identity_t *x_get_suexec_identity(const request_rec *r) 
+static ap_unix_identity_t *x_get_suexec_identity(const request_rec *r)
 {
     trace_request(r, "x_get_suexec_identity()");
     return NULL;
@@ -1344,26 +1344,26 @@ static ap_unix_identity_t *x_get_suexec_identity(const request_rec *r)
 
 /*
  * This routine is called to create a connection. This hook is implemented
- * by the Apache core: there is no known reason a module should override 
- * it. 
- * 
- * This is a RUN_FIRST hook. 
- * 
- * Return NULL to decline, a valid conn_rec pointer to accept. 
- */
-static conn_rec *x_create_connection(apr_pool_t *p, server_rec *server, 
-                                     apr_socket_t *csd, long conn_id, 
-                                     void *sbh, apr_bucket_alloc_t *alloc) 
+ * by the Apache core: there is no known reason a module should override
+ * it.
+ *
+ * This is a RUN_FIRST hook.
+ *
+ * Return NULL to decline, a valid conn_rec pointer to accept.
+ */
+static conn_rec *x_create_connection(apr_pool_t *p, server_rec *server,
+                                     apr_socket_t *csd, long conn_id,
+                                     void *sbh, apr_bucket_alloc_t *alloc)
 {
     trace_nocontext(p, __FILE__, __LINE__, "x_create_connection()");
-    return NULL; 
+    return NULL;
 }
 
 /*
- * This hook is defined in server/core.c, but it is not actually called 
- * or documented. 
- * 
- * This is a RUN_ALL hook. 
+ * This hook is defined in server/core.c, but it is not actually called
+ * or documented.
+ *
+ * This is a RUN_ALL hook.
  */
 static int x_get_mgmt_items(apr_pool_t *p, const char *val, apr_hash_t *ht)
 {
@@ -1376,14 +1376,14 @@ static int x_get_mgmt_items(apr_pool_t *p, const char *val, apr_hash_t *ht)
 
 /*
  * This routine gets called shortly after the request_rec structure
- * is created. It provides the opportunity to manipulae the request 
- * at a very early stage. 
+ * is created. It provides the opportunity to manipulae the request
+ * at a very early stage.
  *
- * This is a RUN_ALL hook. 
+ * This is a RUN_ALL hook.
  */
 static int x_create_request(request_rec *r)
 {
-    /* 
+    /*
      * We have a request_rec, but it is not filled in enough to give
      * us a usable configuration. So, add a trace without context.
      */
@@ -1392,10 +1392,10 @@ static int x_create_request(request_rec *r)
 }
 
 /*
- * This routine gets called during the startup of the MPM. 
- * No known existing module implements this hook. 
- * 
- * This is a RUN_ALL hook. 
+ * This routine gets called during the startup of the MPM.
+ * No known existing module implements this hook.
+ *
+ * This is a RUN_ALL hook.
  */
 static int x_pre_mpm(apr_pool_t *p, ap_scoreboard_e sb_type)
 {
@@ -1405,9 +1405,9 @@ static int x_pre_mpm(apr_pool_t *p, ap_scoreboard_e sb_type)
 
 /*
  * This hook gets run periodically by a maintenance function inside
- * the MPM. Its exact purpose is unknown and undocumented at this time. 
- * 
- * This is a RUN_ALL hook. 
+ * the MPM. Its exact purpose is unknown and undocumented at this time.
+ *
+ * This is a RUN_ALL hook.
  */
 static int x_monitor(apr_pool_t *p, server_rec *s)
 {
@@ -1487,7 +1487,7 @@ static void x_register_hooks(apr_pool_t *p)
     ap_hook_get_mgmt_items(x_get_mgmt_items, NULL, NULL, APR_HOOK_MIDDLE);
     ap_hook_create_request(x_create_request, NULL, NULL, APR_HOOK_MIDDLE);
     ap_hook_pre_mpm(x_pre_mpm, NULL, NULL, APR_HOOK_MIDDLE);
-    ap_hook_monitor(x_monitor, NULL, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_monitor(x_monitor, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 /*--------------------------------------------------------------------------*/
diff --git a/modules/examples/mod_example_ipc.c b/modules/examples/mod_example_ipc.c
index 483881b..a911f0b 100644
--- a/modules/examples/mod_example_ipc.c
+++ b/modules/examples/mod_example_ipc.c
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-/* 
- *  mod_example_ipc -- Apache sample module 
- * 
+/*
+ *  mod_example_ipc -- Apache sample module
+ *
  * This module illustrates the use in an Apache 2.x module of the Interprocess
- * Communications routines that come with APR. It is example code, and not meant 
- * to be used in a production server. 
+ * Communications routines that come with APR. It is example code, and not meant
+ * to be used in a production server.
  *
  * To play with this sample module first compile it into a DSO file and install
  * it into Apache's modules directory by running:
@@ -42,8 +42,8 @@
  * The module allocates a counter in shared memory, which is incremented by the
  * request handler under a mutex. After installation, activate the handler by
  * hitting the URL configured above with ab at various concurrency levels to see
- * how mutex contention affects server performance. 
- */ 
+ * how mutex contention affects server performance.
+ */
 
 #include "apr.h"
 #include "apr_strings.h"
@@ -81,15 +81,15 @@ static const char *exipc_mutex_type = "example-ipc-shm";
 
 /* Data structure for shared memory block */
 typedef struct exipc_data {
-    apr_uint64_t counter; 
+    apr_uint64_t counter;
     /* More fields if necessary */
 } exipc_data;
 
-/* 
- * Clean up the shared memory block. This function is registered as 
+/*
+ * Clean up the shared memory block. This function is registered as
  * cleanup function for the configuration pool, which gets called
- * on restarts. It assures that the new children will not talk to a stale 
- * shared memory segment. 
+ * on restarts. It assures that the new children will not talk to a stale
+ * shared memory segment.
  */
 static apr_status_t shm_cleanup_wrapper(void *unused) {
     if (exipc_shm)
@@ -103,36 +103,36 @@ static apr_status_t shm_cleanup_wrapper(void *unused) {
  * adjust the mutex settings using the Mutex directive.
  */
 
-static int exipc_pre_config(apr_pool_t *pconf, apr_pool_t *plog, 
+static int exipc_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                             apr_pool_t *ptemp)
 {
     ap_mutex_register(pconf, exipc_mutex_type, NULL, APR_LOCK_DEFAULT, 0);
     return OK;
 }
 
-/* 
+/*
  * This routine is called in the parent, so we'll set up the shared
- * memory segment and mutex here. 
+ * memory segment and mutex here.
  */
 
-static int exipc_post_config(apr_pool_t *pconf, apr_pool_t *plog, 
+static int exipc_post_config(apr_pool_t *pconf, apr_pool_t *plog,
                              apr_pool_t *ptemp, server_rec *s)
 {
     apr_status_t rs;
     exipc_data *base;
-    const char *tempdir; 
+    const char *tempdir;
 
 
-    /* 
+    /*
      * Do nothing if we are not creating the final configuration.
      * The parent process gets initialized a couple of times as the
      * server starts up, and we don't want to create any more mutexes
-     * and shared memory segments than we're actually going to use. 
-     */ 
+     * and shared memory segments than we're actually going to use.
+     */
     if (ap_state_query(AP_SQ_MAIN_STATE) == AP_SQ_MS_CREATE_PRE_CONFIG)
         return OK;
 
-    /* 
+    /*
      * The shared memory allocation routines take a file name.
      * Depending on system-specific implementation of these
      * routines, that file may or may not actually be created. We'd
@@ -141,26 +141,26 @@ static int exipc_post_config(apr_pool_t *pconf, apr_pool_t *plog,
      */
     rs = apr_temp_dir_get(&tempdir, pconf);
     if (APR_SUCCESS != rs) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rs, s, 
+        ap_log_error(APLOG_MARK, APLOG_ERR, rs, s,
                      "Failed to find temporary directory");
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     /* Create the shared memory segment */
 
-    /* 
-     * Create a unique filename using our pid. This information is 
+    /*
+     * Create a unique filename using our pid. This information is
      * stashed in the global variable so the children inherit it.
      */
-    shmfilename = apr_psprintf(pconf, "%s/httpd_shm.%ld", tempdir, 
+    shmfilename = apr_psprintf(pconf, "%s/httpd_shm.%ld", tempdir,
                                (long int)getpid());
 
     /* Now create that segment */
-    rs = apr_shm_create(&exipc_shm, sizeof(exipc_data), 
+    rs = apr_shm_create(&exipc_shm, sizeof(exipc_data),
                         (const char *) shmfilename, pconf);
     if (APR_SUCCESS != rs) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, rs, s, 
-                     "Failed to create shared memory segment on file %s", 
+        ap_log_error(APLOG_MARK, APLOG_ERR, rs, s,
+                     "Failed to create shared memory segment on file %s",
                      shmfilename);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
@@ -177,17 +177,17 @@ static int exipc_post_config(apr_pool_t *pconf, apr_pool_t *plog,
         return HTTP_INTERNAL_SERVER_ERROR;
     }
 
-    /* 
+    /*
      * Destroy the shm segment when the configuration pool gets destroyed. This
      * happens on server restarts. The parent will then (above) allocate a new
-     * shm segment that the new children will bind to. 
+     * shm segment that the new children will bind to.
      */
-    apr_pool_cleanup_register(pconf, NULL, shm_cleanup_wrapper, 
-                              apr_pool_cleanup_null);    
+    apr_pool_cleanup_register(pconf, NULL, shm_cleanup_wrapper,
+                              apr_pool_cleanup_null);
     return OK;
 }
 
-/* 
+/*
  * This routine gets called when a child inits. We use it to attach
  * to the shared memory segment, and reinitialize the mutex.
  */
@@ -195,17 +195,17 @@ static int exipc_post_config(apr_pool_t *pconf, apr_pool_t *plog,
 static void exipc_child_init(apr_pool_t *p, server_rec *s)
 {
     apr_status_t rs;
-         
-    /* 
+
+    /*
      * Re-open the mutex for the child. Note we're reusing
-     * the mutex pointer global here. 
+     * the mutex pointer global here.
      */
-    rs = apr_global_mutex_child_init(&exipc_mutex, 
+    rs = apr_global_mutex_child_init(&exipc_mutex,
                                      apr_global_mutex_lockfile(exipc_mutex),
                                      p);
     if (APR_SUCCESS != rs) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, rs, s, 
-                     "Failed to reopen mutex %s in child", 
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rs, s,
+                     "Failed to reopen mutex %s in child",
                      exipc_mutex_type);
         /* There's really nothing else we can do here, since This
          * routine doesn't return a status. If this ever goes wrong,
@@ -213,7 +213,7 @@ static void exipc_child_init(apr_pool_t *p, server_rec *s)
          * will.
          */
         exit(1); /* Ugly, but what else? */
-    } 
+    }
 }
 
 /* The sample content handler */
@@ -223,21 +223,21 @@ static int exipc_handler(request_rec *r)
     int camped;
     apr_time_t startcamp;
     apr_int64_t timecamped;
-    apr_status_t rs; 
+    apr_status_t rs;
     exipc_data *base;
-    
+
     if (strcmp(r->handler, "example_ipc")) {
         return DECLINED;
     }
-    
-    /* 
-     * The main function of the handler, aside from sending the 
-     * status page to the client, is to increment the counter in 
-     * the shared memory segment. This action needs to be mutexed 
-     * out using the global mutex. 
+
+    /*
+     * The main function of the handler, aside from sending the
+     * status page to the client, is to increment the counter in
+     * the shared memory segment. This action needs to be mutexed
+     * out using the global mutex.
      */
-     
-    /* 
+
+    /*
      * First, acquire the lock. This code is a lot more involved than
      * it usually needs to be, because the process based trylock
      * routine is not implemented on unix platforms. I left it in to
@@ -245,11 +245,11 @@ static int exipc_handler(request_rec *r)
      * and platforms where trylock works.
      */
     for (camped = 0, timecamped = 0; camped < MAXCAMP; camped++) {
-        rs = apr_global_mutex_trylock(exipc_mutex); 
+        rs = apr_global_mutex_trylock(exipc_mutex);
         if (APR_STATUS_IS_EBUSY(rs)) {
             apr_sleep(CAMPOUT);
         } else if (APR_SUCCESS == rs) {
-            gotlock = 1; 
+            gotlock = 1;
             break; /* Get out of the loop */
         } else if (APR_STATUS_IS_ENOTIMPL(rs)) {
             /* If it's not implemented, just hang in the mutex. */
@@ -261,36 +261,36 @@ static int exipc_handler(request_rec *r)
                 break; /* Out of the loop */
             } else {
                 /* Some error, log and bail */
-                ap_log_error(APLOG_MARK, APLOG_ERR, rs, r->server, 
-                             "Child %ld failed to acquire lock", 
+                ap_log_error(APLOG_MARK, APLOG_ERR, rs, r->server,
+                             "Child %ld failed to acquire lock",
                              (long int)getpid());
                 break; /* Out of the loop without having the lock */
-            }                
+            }
         } else {
             /* Some other error, log and bail */
-            ap_log_error(APLOG_MARK, APLOG_ERR, rs, r->server, 
-                         "Child %ld failed to try and acquire lock", 
+            ap_log_error(APLOG_MARK, APLOG_ERR, rs, r->server,
+                         "Child %ld failed to try and acquire lock",
                          (long int)getpid());
             break; /* Out of the loop without having the lock */
-            
+
         }
-        /* 
+        /*
          * The only way to get to this point is if the trylock worked
          * and returned BUSY. So, bump the time and try again
          */
         timecamped += CAMPOUT;
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_NOTICE, 
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_NOTICE,
                      0, r->server, "Child %ld camping out on mutex for %" APR_INT64_T_FMT
                      " microseconds",
                      (long int) getpid(), timecamped);
     } /* Lock acquisition loop */
-    
+
     /* Sleep for a millisecond to make it a little harder for
-     * httpd children to acquire the lock. 
+     * httpd children to acquire the lock.
      */
     apr_sleep(SLEEPYTIME);
-    
-    r->content_type = "text/html";      
+
+    r->content_type = "text/html";
 
     if (!r->header_only) {
         ap_rputs(HTML_HEADER, r);
@@ -299,32 +299,32 @@ static int exipc_handler(request_rec *r)
             base = (exipc_data *)apr_shm_baseaddr_get(exipc_shm);
             base->counter++;
             /* Send a page with our pid and the new value of the counter. */
-            ap_rprintf(r, "<p>Lock acquired after %ld microseoncds.</p>\n", 
-                       (long int) timecamped); 
+            ap_rprintf(r, "<p>Lock acquired after %ld microseoncds.</p>\n",
+                       (long int) timecamped);
             ap_rputs("<table border=\"1\">\n", r);
-            ap_rprintf(r, "<tr><td>Child pid:</td><td>%d</td></tr>\n", 
+            ap_rprintf(r, "<tr><td>Child pid:</td><td>%d</td></tr>\n",
                        (int) getpid());
-            ap_rprintf(r, "<tr><td>Counter:</td><td>%u</td></tr>\n", 
+            ap_rprintf(r, "<tr><td>Counter:</td><td>%u</td></tr>\n",
                        (unsigned int)base->counter);
             ap_rputs("</table>\n", r);
         } else {
-            /* 
+            /*
              * Send a page saying that we couldn't get the lock. Don't say
              * what the counter is, because without the lock the value could
-             * race. 
+             * race.
              */
             ap_rprintf(r, "<p>Child %d failed to acquire lock "
-                       "after camping out for %d microseconds.</p>\n", 
+                       "after camping out for %d microseconds.</p>\n",
                        (int) getpid(), (int) timecamped);
         }
-        ap_rputs(HTML_FOOTER, r); 
+        ap_rputs(HTML_FOOTER, r);
     } /* r->header_only */
-    
+
     /* Release the lock */
     if (gotlock)
-        rs = apr_global_mutex_unlock(exipc_mutex); 
-    /* Swallowing the result because what are we going to do with it at 
-     * this stage? 
+        rs = apr_global_mutex_unlock(exipc_mutex);
+    /* Swallowing the result because what are we going to do with it at
+     * this stage?
      */
 
     return OK;
@@ -333,14 +333,14 @@ static int exipc_handler(request_rec *r)
 static void exipc_register_hooks(apr_pool_t *p)
 {
     ap_hook_pre_config(exipc_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
-    ap_hook_post_config(exipc_post_config, NULL, NULL, APR_HOOK_MIDDLE); 
-    ap_hook_child_init(exipc_child_init, NULL, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_post_config(exipc_post_config, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_child_init(exipc_child_init, NULL, NULL, APR_HOOK_MIDDLE);
     ap_hook_handler(exipc_handler, NULL, NULL, APR_HOOK_MIDDLE);
 }
 
 /* Dispatch list for API hooks */
 AP_DECLARE_MODULE(example_ipc) = {
-    STANDARD20_MODULE_STUFF, 
+    STANDARD20_MODULE_STUFF,
     NULL,                  /* create per-dir    config structures */
     NULL,                  /* merge  per-dir    config structures */
     NULL,                  /* create per-server config structures */
diff --git a/modules/experimental/mod_noloris.c b/modules/experimental/mod_noloris.c
index cfc217e..d541e6a 100644
--- a/modules/experimental/mod_noloris.c
+++ b/modules/experimental/mod_noloris.c
@@ -80,7 +80,7 @@ static int noloris_conn(conn_rec *conn)
     }
 
     /* store this client IP for the monitor to pick up */
- 
+
     ap_update_child_status_from_conn(conn->sbh, SERVER_READY, conn);
 
     return DECLINED;
diff --git a/modules/filters/mod_buffer.c b/modules/filters/mod_buffer.c
index 7f4ea73..dac24e7 100644
--- a/modules/filters/mod_buffer.c
+++ b/modules/filters/mod_buffer.c
@@ -141,7 +141,7 @@ static apr_status_t buffer_out_filter(ap_filter_t *f, apr_bucket_brigade *bb) {
             /* pass what we have down the chain */
             rv = ap_pass_brigade(f->next, ctx->bb);
             if (rv) {
-                /* should break out of the loop, since our write to the client 
+                /* should break out of the loop, since our write to the client
                  * failed in some way. */
                 continue;
             }
diff --git a/modules/filters/mod_charset_lite.c b/modules/filters/mod_charset_lite.c
index c73ec9d..2b720bd 100644
--- a/modules/filters/mod_charset_lite.c
+++ b/modules/filters/mod_charset_lite.c
@@ -249,7 +249,7 @@ static int find_code_page(request_rec *r)
 
     reqinfo->dc = dc;
     output_ctx->dc = dc;
-    output_ctx->tmpbb = apr_brigade_create(r->pool, 
+    output_ctx->tmpbb = apr_brigade_create(r->pool,
                                            r->connection->bucket_alloc);
     ap_set_module_config(r->request_config, &charset_lite_module, reqinfo);
 
@@ -319,7 +319,7 @@ static void xlate_insert_filter(request_rec *r)
     charset_dir_t *dc = ap_get_module_config(r->per_dir_config,
                                              &charset_lite_module);
 
-    if (dc && (dc->implicit_add == IA_NOIMPADD)) { 
+    if (dc && (dc->implicit_add == IA_NOIMPADD)) {
         ap_log_rerror(APLOG_MARK, APLOG_TRACE6, 0, r,
                       "xlate output filter not added implicitly because "
                       "CharsetOptions included 'NoImplicitAdd'");
@@ -805,7 +805,7 @@ static apr_status_t xlate_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
          */
             strcmp(mime_type, DIR_MAGIC_TYPE) == 0 ||
 #endif
-            strncasecmp(mime_type, "message/", 8) == 0 || 
+            strncasecmp(mime_type, "message/", 8) == 0 ||
             dc->force_xlate == FX_FORCE)) {
 
             rv = apr_xlate_open(&ctx->xlate,
diff --git a/modules/filters/mod_data.c b/modules/filters/mod_data.c
index 873618e..83284dd 100644
--- a/modules/filters/mod_data.c
+++ b/modules/filters/mod_data.c
@@ -224,7 +224,7 @@ static apr_status_t data_out_filter(ap_filter_t *f, apr_bucket_brigade *bb)
             /* pass what we have down the chain */
             rv = ap_pass_brigade(f->next, ctx->bb);
             if (rv) {
-                /* should break out of the loop, since our write to the client 
+                /* should break out of the loop, since our write to the client
                  * failed in some way. */
                 continue;
             }
diff --git a/modules/filters/mod_deflate.c b/modules/filters/mod_deflate.c
index f2156aa..7a22711 100644
--- a/modules/filters/mod_deflate.c
+++ b/modules/filters/mod_deflate.c
@@ -416,7 +416,7 @@ static void deflate_check_etag(request_rec *r, const char *transform)
 
             apr_table_setn(r->headers_out, "ETag", newtag);
         }
-    }   
+    }
 }
 
 static apr_status_t deflate_out_filter(ap_filter_t *f,
diff --git a/modules/filters/mod_filter.c b/modules/filters/mod_filter.c
index 29275d3..829447f 100644
--- a/modules/filters/mod_filter.c
+++ b/modules/filters/mod_filter.c
@@ -509,8 +509,8 @@ static const char *filter_chain(cmd_parms *cmd, void *CFG, const char *arg)
         break;
 
     case '!':        /* Empty the chain */
-                     /** IG: Add a NULL provider to the beginning so that 
-                      *  we can ensure that we'll empty everything before 
+                     /** IG: Add a NULL provider to the beginning so that
+                      *  we can ensure that we'll empty everything before
                       *  this when doing config merges later */
         p = apr_pcalloc(cmd->pool, sizeof(mod_filter_chain));
         p->fname = NULL;
@@ -622,7 +622,7 @@ static void filter_insert(request_rec *r)
      *  through the chain, and prune out the NULL filters */
 
     for (p = cfg->chain; p; p = p->next) {
-        if (p->fname == NULL) 
+        if (p->fname == NULL)
             cfg->chain = p->next;
     }
 
diff --git a/modules/filters/mod_include.c b/modules/filters/mod_include.c
index db3b2a2..fdbde51 100644
--- a/modules/filters/mod_include.c
+++ b/modules/filters/mod_include.c
@@ -1551,7 +1551,7 @@ static int parse_expr(include_ctx_t *ctx, const char *expr, int *was_error)
             }
             else {
                 current->value = 0;
-                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rr->status, r, 
+                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rr->status, r,
                               "mod_include: The tested "
                               "subrequest -A \"%s\" returned an error code.",
                               current->right->token.value);
diff --git a/modules/filters/mod_reqtimeout.c b/modules/filters/mod_reqtimeout.c
index 5e7f4fb..471c66f 100644
--- a/modules/filters/mod_reqtimeout.c
+++ b/modules/filters/mod_reqtimeout.c
@@ -80,7 +80,7 @@ static apr_status_t check_time_left(reqtimeout_con_cfg *ccfg,
     *time_left_p = ccfg->timeout_at - apr_time_now();
     if (*time_left_p <= 0)
         return APR_TIMEUP;
-    
+
     if (*time_left_p < apr_time_from_sec(1)) {
         *time_left_p = apr_time_from_sec(1);
     }
@@ -393,7 +393,7 @@ static int reqtimeout_after_body(request_rec *r)
     ccfg->new_max_timeout = cfg->header_max_timeout;
     ccfg->min_rate = cfg->header_min_rate;
     ccfg->rate_factor = cfg->header_rate_factor;
-    
+
     ccfg->type = "header";
 
     return OK;
@@ -470,7 +470,7 @@ static const char *set_reqtimeout_param(reqtimeout_srv_cfg *conf,
     else {
         return "Unknown RequestReadTimeout parameter";
     }
-    
+
     if ((rate_str = ap_strcasestr(val, ",minrate="))) {
         initial_str = apr_pstrndup(p, val, rate_str - val);
         rate_str += strlen(",minrate=");
@@ -487,7 +487,7 @@ static const char *set_reqtimeout_param(reqtimeout_srv_cfg *conf,
             if (ret)
                 return ret;
         }
-        
+
         ret = parse_int(p, initial_str, &initial);
     }
     else {
@@ -495,7 +495,7 @@ static const char *set_reqtimeout_param(reqtimeout_srv_cfg *conf,
             return "Must set MinRate option if using timeout range";
         ret = parse_int(p, val, &initial);
     }
-        
+
     if (ret)
         return ret;
 
@@ -526,11 +526,11 @@ static const char *set_reqtimeouts(cmd_parms *cmd, void *mconfig,
     reqtimeout_srv_cfg *conf =
     ap_get_module_config(cmd->server->module_config,
                          &reqtimeout_module);
-    
+
     while (*arg) {
         char *word, *val;
         const char *err;
-        
+
         word = ap_getword_conf(cmd->temp_pool, &arg);
         val = strchr(word, '=');
         if (!val) {
@@ -541,14 +541,14 @@ static const char *set_reqtimeouts(cmd_parms *cmd, void *mconfig,
             *val++ = '\0';
 
         err = set_reqtimeout_param(conf, cmd->pool, word, val);
-        
+
         if (err)
             return apr_psprintf(cmd->temp_pool, "RequestReadTimeout: %s=%s: %s",
                                word, val, err);
     }
-    
+
     return NULL;
-    
+
 }
 
 static void reqtimeout_hooks(apr_pool_t *pool)
diff --git a/modules/filters/mod_sed.c b/modules/filters/mod_sed.c
index 64ff4bf..dd776c4 100644
--- a/modules/filters/mod_sed.c
+++ b/modules/filters/mod_sed.c
@@ -5,14 +5,14 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *  http://www.apache.org/licenses/LICENSE-2.0. 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express 
- * or implied. 
+ *  http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied.
  * See the License for the specific language governing permissions and
- * limitations under the License. 
+ * limitations under the License.
  */
 
 #include "httpd.h"
@@ -490,7 +490,7 @@ static apr_status_t sed_request_filter(ap_filter_t *f,
 static const char *sed_add_expr(cmd_parms *cmd, void *cfg, const char *arg)
 {
     int offset = (int) (long) cmd->info;
-    sed_expr_config *sed_cfg = 
+    sed_expr_config *sed_cfg =
                 (sed_expr_config *) (((char *) cfg) + offset);
     if (compile_sed_expr(sed_cfg, cmd, arg) != APR_SUCCESS) {
         return apr_psprintf(cmd->temp_pool,
diff --git a/modules/filters/mod_substitute.c b/modules/filters/mod_substitute.c
index 8d0c117..0dc53a7 100644
--- a/modules/filters/mod_substitute.c
+++ b/modules/filters/mod_substitute.c
@@ -124,7 +124,7 @@ static void do_pattmatch(ap_filter_t *f, apr_bucket *inb,
     subst_pattern_t *script;
 
     APR_BRIGADE_INSERT_TAIL(mybb, inb);
-    
+
     script = (subst_pattern_t *) cfg->patterns->elts;
     apr_pool_create(&tpool, tmp_pool);
     scratch = NULL;
@@ -281,7 +281,7 @@ static apr_status_t substitute_filter(ap_filter_t *f, apr_bucket_brigade *bb)
     apr_status_t rv;
 
     substitute_module_ctx *ctx = f->ctx;
-    
+
     /*
      * First time around? Create the saved bb that we used for each pass
      * through. Note that we can also get here when we explicitly clear ctx,
@@ -560,7 +560,7 @@ static const char *set_pattern(cmd_parms *cmd, void *cfg, const char *line)
 
     if (is_pattern) {
         nscript->patlen = strlen(from);
-        nscript->pattern = apr_strmatch_precompile(cmd->pool, from, 
+        nscript->pattern = apr_strmatch_precompile(cmd->pool, from,
                                                    !ignore_case);
     }
     else {
diff --git a/modules/filters/regexp.c b/modules/filters/regexp.c
index a0f170b..6c5e13e 100644
--- a/modules/filters/regexp.c
+++ b/modules/filters/regexp.c
@@ -2,8 +2,8 @@
  * Copyright (c) 2005, 2008 Sun Microsystems, Inc. All Rights Reserved.
  * Use is subject to license terms.
  *
- *	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	
- *	  All Rights Reserved  	
+ *	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
+ *	  All Rights Reserved
  *
  * University Copyright- Copyright (c) 1982, 1986, 1988
  * The Regents of the University of California
@@ -16,14 +16,14 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *  http://www.apache.org/licenses/LICENSE-2.0. 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express 
- * or implied. 
+ *  http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied.
  * See the License for the specific language governing permissions and
- * limitations under the License. 
+ * limitations under the License.
  */
 
 /* Code moved from regexp.h */
diff --git a/modules/filters/sed0.c b/modules/filters/sed0.c
index 1485987..7fb4296 100644
--- a/modules/filters/sed0.c
+++ b/modules/filters/sed0.c
@@ -3,19 +3,19 @@
  * Use is subject to license terms.
  *
  *	Copyright (c) 1984 AT&T
- *	  All Rights Reserved  	
+ *	  All Rights Reserved
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *  http://www.apache.org/licenses/LICENSE-2.0. 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express 
- * or implied. 
+ *  http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied.
  * See the License for the specific language governing permissions and
- * limitations under the License. 
+ * limitations under the License.
  */
 
 #include "apr.h"
@@ -85,7 +85,7 @@ apr_status_t sed_init_commands(sed_commands_t *commands, sed_err_fn_t *errfn, vo
 
     return APR_SUCCESS;
 }
- 
+
 /*
  * sed_destroy_commands
  */
@@ -541,7 +541,7 @@ jtcommon:
                     command_errf(commands, SEDERR_NRMES);
                     return -1;
                 }
-            } else 
+            } else
                 op = commands->rep->re1;
             commands->rep->rhs = p;
 
diff --git a/modules/filters/sed1.c b/modules/filters/sed1.c
index af26065..d17b70d 100644
--- a/modules/filters/sed1.c
+++ b/modules/filters/sed1.c
@@ -3,19 +3,19 @@
  * Use is subject to license terms.
  *
  *	Copyright (c) 1984 AT&T
- *	  All Rights Reserved  	
+ *	  All Rights Reserved
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *  http://www.apache.org/licenses/LICENSE-2.0. 
- * 
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express 
- * or implied. 
+ *  http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied.
  * See the License for the specific language governing permissions and
- * limitations under the License. 
+ * limitations under the License.
  */
 
 #include "apr.h"
@@ -394,7 +394,7 @@ apr_status_t sed_eval_buffer(sed_eval_t *eval, const char *buf, int bufsz, void
             eval->lreadyflag = 1;
             break;
         }
-        
+
         appendmem_to_linebuf(eval, buf, llen + 1);
         --eval->lspend;
         /* replace new line character with NULL */
@@ -953,7 +953,7 @@ static apr_status_t command(sed_eval_t *eval, sed_reptr_t *ipc,
             copy_to_holdbuf(eval, eval->genbuf);
             break;
 
-        case YCOM: 
+        case YCOM:
             p1 = eval->linebuf;
             p2 = ipc->re1;
             while((*p1 = p2[(unsigned char)*p1]) != 0)    p1++;
diff --git a/modules/generators/mod_autoindex.c b/modules/generators/mod_autoindex.c
index 3fe8257..f6d1176 100644
--- a/modules/generators/mod_autoindex.c
+++ b/modules/generators/mod_autoindex.c
@@ -583,8 +583,8 @@ static const command_rec autoindex_cmds[] =
                   "{Ascending,Descending} {Name,Size,Description,Date}"),
     AP_INIT_ITERATE("IndexIgnore", add_ignore, NULL, DIR_CMD_PERMS,
                     "one or more file extensions"),
-    AP_INIT_FLAG("IndexIgnoreReset", ap_set_flag_slot, 
-                 (void *)APR_OFFSETOF(autoindex_config_rec, ign_noinherit), 
+    AP_INIT_FLAG("IndexIgnoreReset", ap_set_flag_slot,
+                 (void *)APR_OFFSETOF(autoindex_config_rec, ign_noinherit),
                  DIR_CMD_PERMS,
                  "Reset the inherited list of IndexIgnore filenames"),
     AP_INIT_ITERATE2("AddDescription", add_desc, BY_PATH, DIR_CMD_PERMS,
@@ -1101,9 +1101,9 @@ static void emit_head(request_rec *r, char *header_fname, int suppress_amble,
     if (emit_amble) {
         emit_preamble(r, emit_xhtml, title);
     }
-    
+
     d = (autoindex_config_rec *) ap_get_module_config(r->per_dir_config, &autoindex_module);
-    
+
     if (emit_H1) {
         if (d->style_sheet != NULL) {
     	    /* Insert style id if stylesheet used */
@@ -2313,7 +2313,7 @@ static int handle_autoindex(request_rec *r)
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "Cannot serve directory %s: No matching DirectoryIndex (%s) found, and "
                       "server-generated directory index forbidden by "
-                      "Options directive", 
+                      "Options directive",
                        r->filename,
                        index_names ? index_names : "none");
         return HTTP_FORBIDDEN;
diff --git a/modules/generators/mod_cgi.c b/modules/generators/mod_cgi.c
index 121575c..32895a6 100644
--- a/modules/generators/mod_cgi.c
+++ b/modules/generators/mod_cgi.c
@@ -53,7 +53,7 @@
 #include "mod_core.h"
 #include "mod_cgi.h"
 
-#if APR_HAVE_STRUCT_RLIMIT 
+#if APR_HAVE_STRUCT_RLIMIT
 #if defined (RLIMIT_CPU) || defined (RLIMIT_NPROC) || defined (RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
 #define AP_CGI_USE_RLIMIT
 #endif
diff --git a/modules/generators/mod_cgid.c b/modules/generators/mod_cgid.c
index e88dc05..83e6dc1 100644
--- a/modules/generators/mod_cgid.c
+++ b/modules/generators/mod_cgid.c
@@ -70,7 +70,7 @@
 #include <sys/stat.h>
 #include <sys/un.h> /* for sockaddr_un */
 
-#if APR_HAVE_STRUCT_RLIMIT 
+#if APR_HAVE_STRUCT_RLIMIT
 #if defined (RLIMIT_CPU) || defined (RLIMIT_NPROC) || defined (RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
 #define AP_CGID_USE_RLIMIT
 #endif
@@ -174,7 +174,7 @@ typedef struct {
 } cgid_server_conf;
 
 #ifdef AP_CGID_USE_RLIMIT
-typedef struct { 
+typedef struct {
 #ifdef RLIMIT_CPU
     int    limit_cpu_set;
     struct rlimit limit_cpu;
diff --git a/modules/generators/mod_status.c b/modules/generators/mod_status.c
index 2f9eaf0..47f5988 100644
--- a/modules/generators/mod_status.c
+++ b/modules/generators/mod_status.c
@@ -829,7 +829,7 @@ static int status_handler(request_rec *r)
                                ap_escape_html(r->pool,
                                               ws_record->vhost),
                                ap_escape_html(r->pool,
-                                              ap_escape_logitem(r->pool, 
+                                              ap_escape_logitem(r->pool,
                                                       ws_record->request)));
                 } /* no_table_report */
             } /* for (j...) */
diff --git a/modules/http/byterange_filter.c b/modules/http/byterange_filter.c
index c9d942f..f796c8d 100644
--- a/modules/http/byterange_filter.c
+++ b/modules/http/byterange_filter.c
@@ -101,7 +101,7 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
     if (r->assbackwards) {
         return 0;
     }
-    
+
     /*
      * Check for Range request-header (HTTP/1.1) or Request-Range for
      * backwards-compatibility with second-draft Luotonen/Franks
@@ -112,27 +112,27 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
      * Request-Range based requests to work around a bug in Netscape
      * Navigator 2-3 and MSIE 3.
      */
-    
+
     if (!(range = apr_table_get(r->headers_in, "Range"))) {
         range = apr_table_get(r->headers_in, "Request-Range");
     }
-    
+
     if (!range || strncasecmp(range, "bytes=", 6) || r->status != HTTP_OK) {
         return 0;
     }
-    
+
     /* is content already a single range? */
     if (apr_table_get(r->headers_out, "Content-Range")) {
         return 0;
     }
-    
+
     /* is content already a multiple range? */
     if ((ct = apr_table_get(r->headers_out, "Content-Type"))
         && (!strncasecmp(ct, "multipart/byteranges", 20)
             || !strncasecmp(ct, "multipart/x-byteranges", 22))) {
             return 0;
         }
-    
+
     /*
      * Check the If-Range header for Etag or Date.
      * Note that this check will return false (as required) if either
@@ -150,7 +150,7 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
             return 0;
         }
     }
-    
+
     range += 6;
     it = range;
     while (*it) {
@@ -167,19 +167,19 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
         char *dash;
         char *errp;
         apr_off_t number, start, end;
-        
+
         if (!*cur)
             break;
-        
+
         /*
          * Per RFC 2616 14.35.1: If there is at least one syntactically invalid
          * byte-range-spec, we must ignore the whole header.
          */
-        
+
         if (!(dash = strchr(cur, '-'))) {
             return 0;
         }
-        
+
         if (dash == cur) {
             /* In the form "-5" */
             if (apr_strtoff(&number, dash+1, &errp, 10) || *errp) {
@@ -210,7 +210,7 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
                 end = clength - 1;
             }
         }
-        
+
         if (start < 0) {
             start = 0;
         }
@@ -221,7 +221,7 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
         if (end >= clength) {
             end = clength - 1;
         }
-        
+
         if (!in_merge) {
             /* new set */
             ostart = start;
@@ -230,11 +230,11 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
             continue;
         }
         in_merge = 0;
-        
+
         if (start >= ostart && end <= oend) {
             in_merge = 1;
         }
-        
+
         if (start < ostart && end >= ostart-1) {
             ostart = start;
             ++*reversals;
@@ -244,7 +244,7 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
             oend = end;
             in_merge = 1;
         }
-        
+
         if (in_merge) {
             ++*overlaps;
             continue;
@@ -260,7 +260,7 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
             num_ranges++;
         }
     }
-    
+
     if (in_merge) {
         idx = (indexes_t *)apr_array_push(*indexes);
         idx->start = ostart;
@@ -294,7 +294,7 @@ static int ap_set_byterange(request_rec *r, apr_off_t clength,
     ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                   "Range: %s | %s (%d : %d : %"APR_OFF_T_FMT")",
                   it, r->range, *overlaps, *reversals, clength);
-    
+
     return num_ranges;
 }
 
diff --git a/modules/http/http_core.c b/modules/http/http_core.c
index 8db3ad7..8970ae6 100644
--- a/modules/http/http_core.c
+++ b/modules/http/http_core.c
@@ -101,14 +101,14 @@ static const command_rec http_cmds[] = {
 
 static const char *http_scheme(const request_rec *r)
 {
-    /* 
-     * The http module shouldn't return anything other than 
+    /*
+     * The http module shouldn't return anything other than
      * "http" (the default) or "https".
      */
     if (r->server->server_scheme &&
         (strcmp(r->server->server_scheme, "https") == 0))
         return "https";
-    
+
     return "http";
 }
 
@@ -117,7 +117,7 @@ static apr_port_t http_port(const request_rec *r)
     if (r->server->server_scheme &&
         (strcmp(r->server->server_scheme, "https") == 0))
         return DEFAULT_HTTPS_PORT;
-    
+
     return DEFAULT_HTTP_PORT;
 }
 
@@ -150,7 +150,7 @@ static int ap_process_http_async_connection(conn_rec *c)
                 r = NULL;
             }
 
-            if (cs->state != CONN_STATE_WRITE_COMPLETION && 
+            if (cs->state != CONN_STATE_WRITE_COMPLETION &&
                 cs->state != CONN_STATE_SUSPENDED) {
                 /* Something went wrong; close the connection */
                 cs->state = CONN_STATE_LINGER;
diff --git a/modules/http/http_filters.c b/modules/http/http_filters.c
index 86b74e8..8723c57 100644
--- a/modules/http/http_filters.c
+++ b/modules/http/http_filters.c
@@ -392,11 +392,11 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
 
             /* Detect chunksize error (such as overflow) */
             if (rv != APR_SUCCESS || ctx->remaining < 0) {
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, "Error reading first chunk %s ", 
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, "Error reading first chunk %s ",
                               (ctx->remaining < 0) ? "(overflow)" : "");
                 ctx->remaining = 0; /* Reset it in case we have to
                                      * come back here later */
-                if (APR_STATUS_IS_TIMEUP(rv)) { 
+                if (APR_STATUS_IS_TIMEUP(rv)) {
                     http_error = HTTP_REQUEST_TIME_OUT;
                 }
                 return bail_out_on_error(ctx, f, http_error);
@@ -498,11 +498,11 @@ apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
 
                 /* Detect chunksize error (such as overflow) */
                 if (rv != APR_SUCCESS || ctx->remaining < 0) {
-                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, "Error reading chunk %s ", 
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, f->r, "Error reading chunk %s ",
                                   (ctx->remaining < 0) ? "(overflow)" : "");
                     ctx->remaining = 0; /* Reset it in case we have to
                                          * come back here later */
-                    if (APR_STATUS_IS_TIMEUP(rv)) { 
+                    if (APR_STATUS_IS_TIMEUP(rv)) {
                         http_error = HTTP_REQUEST_TIME_OUT;
                     }
                     return bail_out_on_error(ctx, f, http_error);
diff --git a/modules/http/http_protocol.c b/modules/http/http_protocol.c
index 0810efb..0e7d346 100644
--- a/modules/http/http_protocol.c
+++ b/modules/http/http_protocol.c
@@ -158,7 +158,7 @@ static int is_mpm_running(void)
     if (ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state)) {
       return 0;
     }
-  
+
     if (mpm_state == AP_MPMQ_STOPPING) {
       return 0;
     }
diff --git a/modules/http/http_request.c b/modules/http/http_request.c
index ed16708..0408db1 100644
--- a/modules/http/http_request.c
+++ b/modules/http/http_request.c
@@ -252,14 +252,14 @@ AP_DECLARE(void) ap_process_request_after_handler(request_rec *r)
     bb = apr_brigade_create(r->connection->pool, r->connection->bucket_alloc);
     b = ap_bucket_eor_create(r->connection->bucket_alloc, r);
     APR_BRIGADE_INSERT_HEAD(bb, b);
-    
+
     ap_pass_brigade(r->connection->output_filters, bb);
-    
+
     /* From here onward, it is no longer safe to reference r
      * or r->pool, because r->pool may have been destroyed
      * already by the EOR bucket's cleanup function.
      */
-    
+
     c->cs->state = CONN_STATE_WRITE_COMPLETION;
     check_pipeline(c);
     AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, r->status);
diff --git a/modules/ldap/util_ldap.c b/modules/ldap/util_ldap.c
index 0c55116..492af95 100644
--- a/modules/ldap/util_ldap.c
+++ b/modules/ldap/util_ldap.c
@@ -44,7 +44,7 @@
 
 /* Default define for ldap functions that need a SIZELIMIT but
  * do not have the define
- * XXX This should be removed once a supporting #define is 
+ * XXX This should be removed once a supporting #define is
  *  released through APR-Util.
  */
 #ifndef APR_LDAP_SIZELIMIT
@@ -59,7 +59,7 @@
 #endif
 #endif
 
-#define AP_LDAP_HOPLIMIT_UNSET -1 
+#define AP_LDAP_HOPLIMIT_UNSET -1
 #define AP_LDAP_CHASEREFERRALS_OFF 0
 #define AP_LDAP_CHASEREFERRALS_ON 1
 
@@ -154,10 +154,10 @@ static void uldap_connection_close(util_ldap_connection_t *ldc)
       * but always check/fix the binddn/bindpw when we take them out
       * of the pool
       */
-     if (!ldc->keep) { 
+     if (!ldc->keep) {
          uldap_connection_unbind(ldc);
      }
-     else { 
+     else {
          /* mark our connection as available for reuse */
          ldc->freed = apr_time_now();
 #if APR_HAS_THREADS
@@ -202,7 +202,7 @@ static apr_status_t uldap_connection_unbind(void *param)
  *
  * The caller should hold the lock for this connection
  */
-static apr_status_t util_ldap_connection_remove (void *param) { 
+static apr_status_t util_ldap_connection_remove (void *param) {
     util_ldap_connection_t *ldc = param, *l  = NULL, *prev = NULL;
     util_ldap_state_t *st;
 
@@ -220,9 +220,9 @@ static apr_status_t util_ldap_connection_remove (void *param) {
     for (l=st->connections; l; l=l->next) {
         if (l == ldc) {
             if (prev) {
-                prev->next = l->next; 
+                prev->next = l->next;
             }
-            else { 
+            else {
                 st->connections = l->next;
             }
             break;
@@ -244,8 +244,8 @@ static apr_status_t util_ldap_connection_remove (void *param) {
 
     /* Destory the pool associated with this connection */
 
-    apr_pool_destroy(ldc->pool);   
-   
+    apr_pool_destroy(ldc->pool);
+
     return APR_SUCCESS;
 }
 #endif
@@ -257,7 +257,7 @@ static int uldap_connection_init(request_rec *r,
     int version  = LDAP_VERSION3;
     apr_ldap_err_t *result = NULL;
 #ifdef LDAP_OPT_NETWORK_TIMEOUT
-    struct timeval connectionTimeout = {0}; 
+    struct timeval connectionTimeout = {0};
 #endif
     util_ldap_state_t *st =
         (util_ldap_state_t *)ap_get_module_config(r->server->module_config,
@@ -343,7 +343,7 @@ static int uldap_connection_init(request_rec *r,
     ldap_option = ldc->deref;
     ldap_set_option(ldc->ldap, LDAP_OPT_DEREF, &ldap_option);
 
-    if (ldc->ChaseReferrals == AP_LDAP_CHASEREFERRALS_ON) { 
+    if (ldc->ChaseReferrals == AP_LDAP_CHASEREFERRALS_ON) {
         /* Set options for rebind and referrals. */
         ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "LDAP: Setting referrals to %s.",
@@ -449,8 +449,8 @@ static int uldap_connection_init(request_rec *r,
     return(rc);
 }
 
-static int uldap_ld_errno(util_ldap_connection_t *ldc) 
-{ 
+static int uldap_ld_errno(util_ldap_connection_t *ldc)
+{
     int ldaprc;
 #ifdef LDAP_OPT_ERROR_NUMBER
     if (LDAP_SUCCESS == ldap_get_option(ldc->ldap, LDAP_OPT_ERROR_NUMBER, &ldaprc)) return ldaprc;
@@ -463,7 +463,7 @@ static int uldap_ld_errno(util_ldap_connection_t *ldc)
 
 /*
  * Replacement function for ldap_simple_bind_s() with a timeout.
- * To do this in a portable way, we have to use ldap_simple_bind() and 
+ * To do this in a portable way, we have to use ldap_simple_bind() and
  * ldap_result().
  *
  * Returns LDAP_SUCCESS on success; and an error code on failure
@@ -551,7 +551,7 @@ static int uldap_connection_open(request_rec *r,
      */
 
     while (failures <= st->retries) {
-        if (failures > 0 && st->retry_delay > 0) { 
+        if (failures > 0 && st->retry_delay > 0) {
             apr_sleep(st->retry_delay);
         }
         rc = uldap_simple_bind(ldc, (char *)ldc->binddn, (char *)ldc->bindpw,
@@ -561,7 +561,7 @@ static int uldap_connection_open(request_rec *r,
 
         failures++;
 
-        if (AP_LDAP_IS_SERVER_DOWN(rc)) { 
+        if (AP_LDAP_IS_SERVER_DOWN(rc)) {
              ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,
                           "ldap_simple_bind() failed with server down "
                           "(try %d)", failures);
@@ -569,24 +569,24 @@ static int uldap_connection_open(request_rec *r,
         else if (rc == LDAP_TIMEOUT) {
             ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                           "ldap_simple_bind() timed out on %s "
-                          "connection, dropped by firewall?", 
+                          "connection, dropped by firewall?",
                           new_connection ? "new" : "reused");
         }
-        else { 
+        else {
             /* Other errors not retryable */
             break;
         }
 
         if (!(failures % 2)) {
-            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, 
+            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,
                           "attempt to re-init the connection");
             uldap_connection_unbind(ldc);
-            if (LDAP_SUCCESS != uldap_connection_init(r, ldc)) { 
+            if (LDAP_SUCCESS != uldap_connection_init(r, ldc)) {
                 /* leave rc as the initial bind return code */
                 break;
             }
         }
-    } 
+    }
 
     /* free the handle if there was an error
     */
@@ -693,10 +693,10 @@ static util_ldap_connection_t *
             && (l->deref == deref) && (l->secure == secureflag)
             && !compare_client_certs(dc->client_certs, l->client_certs))
         {
-            if (st->connection_pool_ttl > 0) { 
-                if (l->bound && (now - l->freed) > st->connection_pool_ttl) { 
-                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, 
-                                  "Removing LDAP connection last used %" APR_TIME_T_FMT " seconds ago", 
+            if (st->connection_pool_ttl > 0) {
+                if (l->bound && (now - l->freed) > st->connection_pool_ttl) {
+                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,
+                                  "Removing LDAP connection last used %" APR_TIME_T_FMT " seconds ago",
                                   (now - l->freed) / APR_USEC_PER_SEC);
                     uldap_connection_unbind(l);
                     /* Go ahead (by falling through) and use it, so we don't create more just to unbind some other old ones */
@@ -730,7 +730,7 @@ static util_ldap_connection_t *
                 /* the bind credentials have changed */
                 /* no check for connection_pool_ttl, since we are unbinding any way */
                 uldap_connection_unbind(l);
-                        
+
                 util_ldap_strdup((char**)&(l->binddn), binddn);
                 util_ldap_strdup((char**)&(l->bindpw), bindpw);
                 break;
@@ -762,7 +762,7 @@ static util_ldap_connection_t *
 #endif
             return NULL;
         }
- 
+
         /*
          * Add the new connection entry to the linked list. Note that we
          * don't actually establish an LDAP connection yet; that happens
@@ -800,7 +800,7 @@ static util_ldap_connection_t *
         /* whether or not to keep this connection in the pool when it's returned */
         l->keep = (st->connection_pool_ttl == 0) ? 0 : 1;
 
-        if (l->ChaseReferrals == AP_LDAP_CHASEREFERRALS_ON) { 
+        if (l->ChaseReferrals == AP_LDAP_CHASEREFERRALS_ON) {
             if (apr_pool_create(&(l->rebind_pool), l->pool) != APR_SUCCESS) {
                 ap_log_rerror(APLOG_MARK, APLOG_CRIT, 0, r,
                               "util_ldap: Failed to create memory pool");
@@ -1070,7 +1070,7 @@ start_over:
                             (char *)dn,
                             (char *)attrib,
                             (char *)value);
-    if (AP_LDAP_IS_SERVER_DOWN(result)) { 
+    if (AP_LDAP_IS_SERVER_DOWN(result)) {
         /* connection failed - try again */
         ldc->reason = "ldap_compare_s() failed with server down";
         uldap_connection_unbind(ldc);
@@ -2530,7 +2530,7 @@ static const char *util_ldap_set_chase_referrals(cmd_parms *cmd,
 
 static const char *util_ldap_set_debug_level(cmd_parms *cmd,
                                              void *config,
-                                             const char *arg) { 
+                                             const char *arg) {
 #ifdef AP_LDAP_OPT_DEBUG
     util_ldap_state_t *st =
         (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config,
@@ -2548,7 +2548,7 @@ static const char *util_ldap_set_debug_level(cmd_parms *cmd,
     st->debug_level = atoi(arg);
     return NULL;
 #endif
-} 
+}
 
 static const char *util_ldap_set_referral_hop_limit(cmd_parms *cmd,
                                                     void *config,
@@ -2558,7 +2558,7 @@ static const char *util_ldap_set_referral_hop_limit(cmd_parms *cmd,
 
     dc->ReferralHopLimit = atol(hop_limit);
 
-    if (dc->ReferralHopLimit <= 0) { 
+    if (dc->ReferralHopLimit <= 0) {
         return "LDAPReferralHopLimit must be greater than zero (Use 'LDAPReferrals Off' to disable referral chasing)";
     }
 
@@ -2638,11 +2638,11 @@ static const char *util_ldap_set_conn_ttl(cmd_parms *cmd,
         (util_ldap_state_t *)ap_get_module_config(cmd->server->module_config,
                                                   &ldap_module);
 
-    if (ap_timeout_parameter_parse(val, &timeout, "s") != APR_SUCCESS) { 
+    if (ap_timeout_parameter_parse(val, &timeout, "s") != APR_SUCCESS) {
         return "LDAPConnPoolTTL has wrong format";
     }
 
-    if (timeout < 0) { 
+    if (timeout < 0) {
         /* reserve -1 for default value */
         timeout =  AP_LDAP_CONNPOOL_INFINITE;
     }
@@ -2663,11 +2663,11 @@ static const char *util_ldap_set_retry_delay(cmd_parms *cmd,
         return err;
     }
 
-    if (ap_timeout_parameter_parse(val, &timeout, "s") != APR_SUCCESS) { 
+    if (ap_timeout_parameter_parse(val, &timeout, "s") != APR_SUCCESS) {
         return "LDAPRetryDelay has wrong format";
     }
 
-    if (timeout < 0) { 
+    if (timeout < 0) {
         return "LDAPRetryDelay must be >= 0";
     }
 
@@ -2689,11 +2689,11 @@ static const char *util_ldap_set_retries(cmd_parms *cmd,
     }
 
     st->retries = atoi(val);
-    if (st->retries < 0) { 
+    if (st->retries < 0) {
         return  "LDAPRetries must be >= 0";
     }
 
-    return NULL; 
+    return NULL;
 }
 
 static void *util_ldap_create_config(apr_pool_t *p, server_rec *s)
@@ -2701,7 +2701,7 @@ static void *util_ldap_create_config(apr_pool_t *p, server_rec *s)
     util_ldap_state_t *st =
         (util_ldap_state_t *)apr_pcalloc(p, sizeof(util_ldap_state_t));
 
-    /* Create a per vhost pool for mod_ldap to use, serialized with 
+    /* Create a per vhost pool for mod_ldap to use, serialized with
      * st->mutex (also one per vhost).  both are replicated by fork(),
      * no shared memory managed by either.
      */
@@ -2746,7 +2746,7 @@ static void *util_ldap_merge_config(apr_pool_t *p, void *basev,
     st->mutex = overrides->mutex;
 #endif
 
-    /* The cache settings can not be modified in a 
+    /* The cache settings can not be modified in a
         virtual host since all server use the same
         shared memory cache. */
     st->cache_bytes = base->cache_bytes;
@@ -2754,7 +2754,7 @@ static void *util_ldap_merge_config(apr_pool_t *p, void *basev,
     st->search_cache_size = base->search_cache_size;
     st->compare_cache_ttl = base->compare_cache_ttl;
     st->compare_cache_size = base->compare_cache_size;
-    st->util_ldap_cache_lock = base->util_ldap_cache_lock; 
+    st->util_ldap_cache_lock = base->util_ldap_cache_lock;
 
     st->connections = NULL;
     st->ssl_supported = 0; /* not known until post-config and re-merged */
@@ -2763,22 +2763,22 @@ static void *util_ldap_merge_config(apr_pool_t *p, void *basev,
     st->secure = (overrides->secure_set == 0) ? base->secure
                                               : overrides->secure;
 
-    /* These LDAP connection settings can not be overwritten in 
-        a virtual host. Once set in the base server, they must 
+    /* These LDAP connection settings can not be overwritten in
+        a virtual host. Once set in the base server, they must
         remain the same. None of the LDAP SDKs seem to be able
-        to handle setting the verify_svr_cert flag on a 
+        to handle setting the verify_svr_cert flag on a
         per-connection basis.  The OpenLDAP client appears to be
         able to handle the connection timeout per-connection
         but the Novell SDK cannot.  Allowing the timeout to
         be set by each vhost is of little value so rather than
-        trying to make special expections for one LDAP SDK, GLOBAL_ONLY 
+        trying to make special expections for one LDAP SDK, GLOBAL_ONLY
         is being enforced on this setting as well. */
     st->connectionTimeout = base->connectionTimeout;
     st->opTimeout = base->opTimeout;
     st->verify_svr_cert = base->verify_svr_cert;
     st->debug_level = base->debug_level;
 
-    st->connection_pool_ttl = (overrides->connection_pool_ttl == AP_LDAP_CONNPOOL_DEFAULT) ? 
+    st->connection_pool_ttl = (overrides->connection_pool_ttl == AP_LDAP_CONNPOOL_DEFAULT) ?
                                 base->connection_pool_ttl : overrides->connection_pool_ttl;
 
     st->retries = base->retries;
@@ -2953,11 +2953,11 @@ static int util_ldap_post_config(apr_pool_t *p, apr_pool_t *plog,
     apr_ldap_rebind_init (p);
 
 #ifdef AP_LDAP_OPT_DEBUG
-    if (st->debug_level > 0) { 
+    if (st->debug_level > 0) {
         result = ldap_set_option(NULL, AP_LDAP_OPT_DEBUG, &st->debug_level);
         if (result != LDAP_SUCCESS) {
             ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
-                    "LDAP: Could not set the LDAP library debug level to %d:(%d) %s", 
+                    "LDAP: Could not set the LDAP library debug level to %d:(%d) %s",
                     st->debug_level, result, ldap_err2string(result));
         }
     }
@@ -2996,9 +2996,9 @@ static const command_rec util_ldap_cmds[] = {
     AP_INIT_TAKE1("LDAPCacheEntries", util_ldap_set_cache_entries,
                   NULL, RSRC_CONF,
                   "Set the maximum number of entries that are possible in the "
-                  "LDAP search cache. Use 0 or -1 to disable the search cache " 
+                  "LDAP search cache. Use 0 or -1 to disable the search cache "
                   "(default: 1024)"),
-                  
+
     AP_INIT_TAKE1("LDAPCacheTTL", util_ldap_set_cache_ttl,
                   NULL, RSRC_CONF,
                   "Set the maximum time (in seconds) that an item can be "
@@ -3008,7 +3008,7 @@ static const command_rec util_ldap_cmds[] = {
     AP_INIT_TAKE1("LDAPOpCacheEntries", util_ldap_set_opcache_entries,
                   NULL, RSRC_CONF,
                   "Set the maximum number of entries that are possible "
-                  "in the LDAP compare cache. Use 0 or -1 to disable the compare cache " 
+                  "in the LDAP compare cache. Use 0 or -1 to disable the compare cache "
                   "(default: 1024)"),
 
     AP_INIT_TAKE1("LDAPOpCacheTTL", util_ldap_set_opcache_ttl,
diff --git a/modules/loggers/mod_log_config.c b/modules/loggers/mod_log_config.c
index 96d77c6..fc7b83a 100644
--- a/modules/loggers/mod_log_config.c
+++ b/modules/loggers/mod_log_config.c
@@ -1082,7 +1082,7 @@ static int config_log_transaction(request_rec *r, config_log_state *cls,
     else if (cls->condition_expr != NULL) {
         const char *err;
         int rc = ap_expr_exec(r, cls->condition_expr, &err);
-        if (rc < 0) 
+        if (rc < 0)
             ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                            "Error evaluating log condition: %s", err);
         if (rc <= 0)
diff --git a/modules/loggers/mod_log_forensic.c b/modules/loggers/mod_log_forensic.c
index 70491cd..8e23dd8 100644
--- a/modules/loggers/mod_log_forensic.c
+++ b/modules/loggers/mod_log_forensic.c
@@ -195,7 +195,7 @@ static int log_before(request_rec *r)
     if (!(id = apr_table_get(r->subprocess_env, "UNIQUE_ID"))) {
         /* we make the assumption that we can't go through all the PIDs in
            under 1 second */
-        id = apr_psprintf(r->pool, "%" APR_PID_T_FMT ":%lx:%x", getpid(), 
+        id = apr_psprintf(r->pool, "%" APR_PID_T_FMT ":%lx:%x", getpid(),
                           time(NULL), apr_atomic_inc32(&next_id));
     }
     ap_set_module_config(r->request_config, &log_forensic_module, (char *)id);
diff --git a/modules/lua/lua_request.c b/modules/lua/lua_request.c
index 1fb1fc2..92a0b2b 100644
--- a/modules/lua/lua_request.c
+++ b/modules/lua/lua_request.c
@@ -342,7 +342,7 @@ static int req_dispatch(lua_State *L)
                               "request_rec->dispatching %s -> apr table",
                               name);
                 rs = (*func)(r);
-                ap_lua_push_apr_table(L, rs);          
+                ap_lua_push_apr_table(L, rs);
                 return 1;
             }
 
@@ -594,7 +594,7 @@ AP_LUA_DECLARE(void) ap_lua_load_request_lmodule(lua_State *L, apr_pool_t *p)
                  makefun(&req_notes, APL_REQ_FUNTYPE_TABLE, p));
     apr_hash_set(dispatch, "subprocess_env", APR_HASH_KEY_STRING,
                  makefun(&req_subprocess_env, APL_REQ_FUNTYPE_TABLE, p));
-    
+
 
     lua_pushlightuserdata(L, dispatch);
     lua_setfield(L, LUA_REGISTRYINDEX, "Apache2.Request.dispatch");
diff --git a/modules/lua/lua_vmprep.c b/modules/lua/lua_vmprep.c
index b681ef1..c2c59e1 100644
--- a/modules/lua/lua_vmprep.c
+++ b/modules/lua/lua_vmprep.c
@@ -238,7 +238,7 @@ static void munge_path(lua_State *L,
                        const char *sub_pat,
                        const char *rep_pat,
                        apr_pool_t *pool,
-                       apr_array_header_t *paths, 
+                       apr_array_header_t *paths,
                        const char *file)
 {
     const char *current;
@@ -287,7 +287,7 @@ static int loadjitmodule(lua_State *L, apr_pool_t *lifecycle_pool) {
 static apr_status_t vm_construct(void **vm, void *params, apr_pool_t *lifecycle_pool)
 {
     lua_State* L;
-    
+
     ap_lua_vm_spec *spec = params;
 
     L = luaL_newstate();
@@ -321,17 +321,17 @@ static apr_status_t vm_construct(void **vm, void *params, apr_pool_t *lifecycle_
         if (rc != 0) {
             char *err;
             switch (rc) {
-                case LUA_ERRSYNTAX: 
-                    err = "syntax error"; 
+                case LUA_ERRSYNTAX:
+                    err = "syntax error";
                     break;
-                case LUA_ERRMEM:    
-                    err = "memory allocation error"; 
+                case LUA_ERRMEM:
+                    err = "memory allocation error";
                     break;
-                case LUA_ERRFILE:   
-                    err = "error opening or reading file"; 
+                case LUA_ERRFILE:
+                    err = "error opening or reading file";
                     break;
                 default:
-                    err = "unknown error"; 
+                    err = "unknown error";
                     break;
             }
             ap_log_perror(APLOG_MARK, APLOG_ERR, 0, lifecycle_pool,
@@ -354,7 +354,7 @@ static apr_status_t vm_construct(void **vm, void *params, apr_pool_t *lifecycle_
 
 static apr_status_t vm_destruct(void *vm, void *params, apr_pool_t *pool)
 {
-    lua_State *L = (lua_State *)vm; 
+    lua_State *L = (lua_State *)vm;
 
     (void)params;
     (void)pool;
@@ -390,8 +390,8 @@ AP_LUA_DECLARE(lua_State*)ap_lua_get_lua_state(apr_pool_t *lifecycle_pool,
         if (apr_pool_userdata_get((void **)&reslist,
                                   "mod_lua", spec->pool) == APR_SUCCESS) {
             if(reslist==NULL) {
-                if(apr_reslist_create(&reslist, 
-                                      spec->vm_server_pool_min, 
+                if(apr_reslist_create(&reslist,
+                                      spec->vm_server_pool_min,
                                       spec->vm_server_pool_max,
                                       spec->vm_server_pool_max,
                                       0,
diff --git a/modules/lua/mod_lua.c b/modules/lua/mod_lua.c
index 8324a9b..8de595b 100644
--- a/modules/lua/mod_lua.c
+++ b/modules/lua/mod_lua.c
@@ -34,7 +34,7 @@ APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL(ap_lua, AP_LUA, int, lua_request,
      module AP_MODULE_DECLARE_DATA lua_module;
 
 /**
- * error reporting if lua has an error. 
+ * error reporting if lua has an error.
  * Extracts the error from lua stack and prints
  */
 static void report_lua_error(lua_State *L, request_rec *r)
@@ -73,7 +73,7 @@ static apr_status_t luahood(ap_filter_t *f, apr_bucket_brigade *bb) {
     apr_status_t rs;
     for ( b = APR_BRIGADE_FIRST(bb);
           b != APR_BRIGADE_SENTINEL(bb);
-          b = APR_BUCKET_NEXT(b)) 
+          b = APR_BUCKET_NEXT(b))
     {
         if (APR_BUCKET_IS_EOS(b)) {kl
             break;
@@ -87,9 +87,9 @@ static apr_status_t luahood(ap_filter_t *f, apr_bucket_brigade *bb) {
         char *mine = apr_pstrmemdup(f->r->pool, buffer, bytes);
         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, f->r, "sending '%s'", mine);
     }
-    
+
     ap_pass_brigade(f->next, bb);
-    
+
     return OK;
 }
 */
@@ -169,7 +169,7 @@ static int lua_handler(request_rec *r)
 
 
 /**
- * Like mod_alias except for lua handler fun :-) 
+ * Like mod_alias except for lua handler fun :-)
  */
 static int lua_alias_munger(request_rec *r)
 {
@@ -356,7 +356,7 @@ typedef struct cr_ctx
 
 /* Okay, this deserves a little explaination -- in order for the errors that lua
  * generates to be 'accuarate', including line numbers, we basically inject
- * N line number new lines into the 'top' of the chunk reader..... 
+ * N line number new lines into the 'top' of the chunk reader.....
  *
  * be happy. this is cool.
  *
@@ -788,7 +788,7 @@ static const char *register_package_cdir(cmd_parms *cmd, void *_cfg,
 
 /**
  * Called for config directive which looks like
- * LuaCodeCache 
+ * LuaCodeCache
  */
 static const char *register_code_cache(cmd_parms *cmd, void *_cfg,
                                        const char *arg)
diff --git a/modules/mappers/mod_dir.c b/modules/mappers/mod_dir.c
index c7ae2ae..4386dba 100644
--- a/modules/mappers/mod_dir.c
+++ b/modules/mappers/mod_dir.c
@@ -90,9 +90,9 @@ static const char *configure_redirect(cmd_parms *cmd, void *d_, const char *arg1
     dir_config_rec *d = d_;
     int status;
 
-    if (!strcasecmp(arg1, "ON")) 
+    if (!strcasecmp(arg1, "ON"))
         status = HTTP_MOVED_TEMPORARILY;
-    else if (!strcasecmp(arg1, "OFF")) 
+    else if (!strcasecmp(arg1, "OFF"))
         status = REDIRECT_OFF;
     else if (!strcasecmp(arg1, "permanent"))
         status = HTTP_MOVED_PERMANENTLY;
@@ -100,13 +100,13 @@ static const char *configure_redirect(cmd_parms *cmd, void *d_, const char *arg1
         status = HTTP_MOVED_TEMPORARILY;
     else if (!strcasecmp(arg1, "seeother"))
         status = HTTP_SEE_OTHER;
-    else if (apr_isdigit(*arg1)) { 
+    else if (apr_isdigit(*arg1)) {
         status = atoi(arg1);
-        if (!ap_is_HTTP_REDIRECT(status)) { 
+        if (!ap_is_HTTP_REDIRECT(status)) {
             return "DirectoryIndexRedirect only accepts values between 300 and 399";
         }
     }
-    else { 
+    else {
         return "DirectoryIndexRedirect ON|OFF|permanent|temp|seeother|3xx";
     }
 
@@ -122,7 +122,7 @@ static const command_rec dir_cmds[] =
                     "a list of file names"),
     AP_INIT_FLAG("DirectorySlash", configure_slash, NULL, DIR_CMD_PERMS,
                  "On or Off"),
-    AP_INIT_TAKE1("DirectoryIndexRedirect", configure_redirect, 
+    AP_INIT_TAKE1("DirectoryIndexRedirect", configure_redirect,
                    NULL, DIR_CMD_PERMS, "On, Off, or a 3xx status code."),
 
     {NULL}
@@ -299,8 +299,8 @@ static int fixup_dir(request_rec *r)
         if (rr->status == HTTP_OK
             && (   (rr->handler && !strcmp(rr->handler, "proxy-server"))
                 || rr->finfo.filetype == APR_REG)) {
-  
-            if (ap_is_HTTP_REDIRECT(d->redirect_index)) { 
+
+            if (ap_is_HTTP_REDIRECT(d->redirect_index)) {
                 apr_table_setn(r->headers_out, "Location", ap_construct_url(r->pool, rr->uri, r));
                 return d->redirect_index;
             }
@@ -347,9 +347,9 @@ static int fixup_dir(request_rec *r)
     }
 
     /* record what we tried, mostly for the benefit of mod_autoindex */
-    apr_table_set(r->notes, "dir-index-names", 
-                  d->index_names ? 
-                  apr_array_pstrcat(r->pool, d->index_names, ','): 
+    apr_table_set(r->notes, "dir-index-names",
+                  d->index_names ?
+                  apr_array_pstrcat(r->pool, d->index_names, ','):
                   AP_DEFAULT_INDEX);
 
     /* nothing for us to do, pass on through */
diff --git a/modules/mappers/mod_imagemap.c b/modules/mappers/mod_imagemap.c
index 5fc4797..c3de930 100644
--- a/modules/mappers/mod_imagemap.c
+++ b/modules/mappers/mod_imagemap.c
@@ -477,12 +477,12 @@ static void menu_header(request_rec *r, char *menu)
 {
     ap_set_content_type(r, "text/html; charset=ISO-8859-1");
 
-    ap_rvputs(r, DOCTYPE_HTML_3_2, "<html><head>\n<title>Menu for ", 
+    ap_rvputs(r, DOCTYPE_HTML_3_2, "<html><head>\n<title>Menu for ",
               ap_escape_html(r->pool, r->uri),
               "</title>\n</head><body>\n", NULL);
 
     if (!strcasecmp(menu, "formatted")) {
-        ap_rvputs(r, "<h1>Menu for ", 
+        ap_rvputs(r, "<h1>Menu for ",
                   ap_escape_html(r->pool, r->uri),
                   "</h1>\n<hr />\n\n", NULL);
     }
diff --git a/modules/mappers/mod_rewrite.c b/modules/mappers/mod_rewrite.c
index 8280c0e..dd10e53 100644
--- a/modules/mappers/mod_rewrite.c
+++ b/modules/mappers/mod_rewrite.c
@@ -1663,7 +1663,7 @@ static char *lookup_map(request_rec *r, char *name, char *key)
         rewritelog((r, 5, NULL, "cache lookup OK: map=%s[SQL] key=%s, val=%s",
                     name, key, value));
         return *value ? value : NULL;
-        
+
     /*
      * Program file map
      */
@@ -2336,7 +2336,7 @@ static char *do_expand(char *input, rewrite_ctx *ctx, rewriterule_entry *entry)
                     current->len = span;
                     current->string = bri->source + bri->regmatch[n].rm_so;
                 }
-                
+
                 outlen += span;
             }
 
@@ -2751,7 +2751,7 @@ static void *config_server_merge(apr_pool_t *p, void *basev, void *overridesv)
                                               overrides->rewritemaps);
         a->rewriteconds    = apr_array_append(p, base->rewriteconds,
                                               overrides->rewriteconds);
-        a->rewriterules    = apr_array_append(p, base->rewriterules, 
+        a->rewriterules    = apr_array_append(p, base->rewriterules,
                                               overrides->rewriterules);
     }
     else {
@@ -3331,7 +3331,7 @@ static const char *cmd_rewriterule_setflag(apr_pool_t *p, void *_cfg,
     case 'B':
         if (!*key || !strcasecmp(key, "ackrefescaping")) {
             cfg->flags |= RULEFLAG_ESCAPEBACKREF;
-        } 
+        }
         else {
             ++error;
         }
@@ -3365,9 +3365,9 @@ static const char *cmd_rewriterule_setflag(apr_pool_t *p, void *_cfg,
         break;
     case 'd':
     case 'D':
-        if (!*key || !strcasecmp(key, "PI") || !strcasecmp(key,"iscardpath")) {       
+        if (!*key || !strcasecmp(key, "PI") || !strcasecmp(key,"iscardpath")) {
             cfg->flags |= (RULEFLAG_DISCARDPATHINFO);
-        } 
+        }
         break;
     case 'e':
     case 'E':
@@ -4031,7 +4031,7 @@ static int apply_rewrite_rule(rewriterule_entry *p, rewrite_ctx *ctx)
     r->filename = newuri;
 
     if (ctx->perdir && (p->flags & RULEFLAG_DISCARDPATHINFO)) {
-        r->path_info = NULL; 
+        r->path_info = NULL;
     }
 
     splitout_queryargs(r, p->flags & RULEFLAG_QSAPPEND, p->flags & RULEFLAG_QSDISCARD);
@@ -4064,12 +4064,12 @@ static int apply_rewrite_rule(rewriterule_entry *p, rewrite_ctx *ctx)
          * instead.  See PR 39746, 46428, and other headaches. */
         if (ctx->perdir && (p->flags & RULEFLAG_NOESCAPE) == 0) {
             char *old_filename = r->filename;
-            
+
             r->filename = ap_escape_uri(r->pool, r->filename);
             rewritelog((r, 2, ctx->perdir, "escaped URI in per-dir context "
                         "for proxy, %s -> %s", old_filename, r->filename));
         }
-        
+
         fully_qualify_uri(r);
 
         rewritelog((r, 2, ctx->perdir, "forcing proxy-throughput with %s",
@@ -4209,7 +4209,7 @@ static int apply_rewrite_list(request_rec *r, apr_array_header_t *rewriterules,
                 break;
             }
 
-            if (p->flags & RULEFLAG_END) { 
+            if (p->flags & RULEFLAG_END) {
                 rewritelog((r, 8, perdir, "Rule has END flag, no further rewriting for this request"));
                 apr_pool_userdata_set("1", really_last_key, apr_pool_cleanup_null, r->pool);
                 break;
@@ -4397,9 +4397,9 @@ static int hook_uri2file(request_rec *r)
         return DECLINED;
     }
 
-    /* END flag was used as a RewriteRule flag on this request */ 
+    /* END flag was used as a RewriteRule flag on this request */
     apr_pool_userdata_get(&skipdata, really_last_key, r->pool);
-    if (skipdata != NULL) { 
+    if (skipdata != NULL) {
         rewritelog((r, 8, NULL, "Declining, no further rewriting due to END flag"));
         return DECLINED;
     }
@@ -4698,9 +4698,9 @@ static int hook_fixup(request_rec *r)
         }
     }
 
-    /* END flag was used as a RewriteRule flag on this request */ 
+    /* END flag was used as a RewriteRule flag on this request */
     apr_pool_userdata_get(&skipdata, really_last_key, r->pool);
-    if (skipdata != NULL) { 
+    if (skipdata != NULL) {
         rewritelog((r, 8, dconf->directory, "Declining, no further rewriting due to END flag"));
         return DECLINED;
     }
@@ -4833,18 +4833,18 @@ static int hook_fixup(request_rec *r)
             /* append the QUERY_STRING part */
             if (r->args) {
                 char *escaped_args = NULL;
-                int noescape = (rulestatus == ACTION_NOESCAPE || 
+                int noescape = (rulestatus == ACTION_NOESCAPE ||
                                 (oargs && !strcmp(r->args, oargs)));
-                             
+
                 r->filename = apr_pstrcat(r->pool, r->filename, "?",
-                                          noescape 
+                                          noescape
                                             ? r->args
                                             : (escaped_args = ap_escape_uri(r->pool, r->args)),
                                           NULL);
 
                 rewritelog((r, 1, dconf->directory, "%s %s to query string for redirect %s",
-                            noescape ? "copying" : "escaping",  
-                            r->args , 
+                            noescape ? "copying" : "escaping",
+                            r->args ,
                             noescape ? "" : escaped_args));
             }
 
diff --git a/modules/mappers/mod_speling.c b/modules/mappers/mod_speling.c
index 4fad5aa..b1c75d0 100644
--- a/modules/mappers/mod_speling.c
+++ b/modules/mappers/mod_speling.c
@@ -107,7 +107,7 @@ static const command_rec speling_cmds[] =
                   (void*)APR_OFFSETOF(spconfig, enabled), OR_OPTIONS,
                  "whether or not to fix miscapitalized/misspelled requests"),
     AP_INIT_FLAG("CheckCaseOnly", ap_set_flag_slot,
-                  (void*)APR_OFFSETOF(spconfig, case_only), OR_OPTIONS, 
+                  (void*)APR_OFFSETOF(spconfig, case_only), OR_OPTIONS,
                  "whether or not to fix only miscapitalized requests"),
     { NULL }
 };
diff --git a/modules/mappers/mod_userdir.c b/modules/mappers/mod_userdir.c
index 9d61972..b181e27 100644
--- a/modules/mappers/mod_userdir.c
+++ b/modules/mappers/mod_userdir.c
@@ -116,17 +116,17 @@ static void *merge_userdir_config(apr_pool_t *p, void *basev, void *overridesv)
 {
     userdir_config *cfg = apr_pcalloc(p, sizeof(userdir_config));
     userdir_config *base = basev, *overrides = overridesv;
- 
+
     cfg->globally_disabled = (overrides->globally_disabled != O_DEFAULT) ?
                              overrides->globally_disabled :
                              base->globally_disabled;
     cfg->userdir = (overrides->userdir != DEFAULT_USER_DIR) ?
                    overrides->userdir : base->userdir;
- 
+
     /* not merged */
     cfg->enabled_users = overrides->enabled_users;
     cfg->disabled_users = overrides->disabled_users;
-    
+
     return cfg;
 }
 
diff --git a/modules/metadata/mod_remoteip.c b/modules/metadata/mod_remoteip.c
index b6f7e0c..4a73a24 100644
--- a/modules/metadata/mod_remoteip.c
+++ b/modules/metadata/mod_remoteip.c
@@ -39,9 +39,9 @@ typedef struct {
 typedef struct {
     /** The header to retrieve a proxy-via ip list */
     const char *header_name;
-    /** A header to record the proxied IP's 
-     * (removed as the physical connection and 
-     * from the proxy-via ip header value list) 
+    /** A header to record the proxied IP's
+     * (removed as the physical connection and
+     * from the proxy-via ip header value list)
      */
     const char *proxies_header_name;
     /** A list of trusted proxies, ideally configured
@@ -153,8 +153,8 @@ static const char *proxies_set(cmd_parms *cmd, void *internal,
         apr_sockaddr_t *temp_sa;
 
         if (s) {
-            return apr_pstrcat(cmd->pool, "RemoteIP: Error parsing IP ", arg, 
-                               " the subnet /", s, " is invalid for ", 
+            return apr_pstrcat(cmd->pool, "RemoteIP: Error parsing IP ", arg,
+                               " the subnet /", s, " is invalid for ",
                                cmd->cmd->name, NULL);
         }
 
@@ -166,7 +166,7 @@ static const char *proxies_set(cmd_parms *cmd, void *internal,
             rv = apr_ipsubnet_create(&match->ip, ip, NULL, cmd->pool);
             if (!(temp_sa = temp_sa->next))
                 break;
-            match = (remoteip_proxymatch_t *) 
+            match = (remoteip_proxymatch_t *)
                     apr_array_push(config->proxymatch_ip);
             match->internal = internal;
         }
@@ -175,7 +175,7 @@ static const char *proxies_set(cmd_parms *cmd, void *internal,
     if (rv != APR_SUCCESS) {
         char msgbuf[128];
         apr_strerror(rv, msgbuf, sizeof(msgbuf));
-        return apr_pstrcat(cmd->pool, "RemoteIP: Error parsing IP ", arg, 
+        return apr_pstrcat(cmd->pool, "RemoteIP: Error parsing IP ", arg,
                            " (", msgbuf, " error) for ", cmd->cmd->name, NULL);
     }
 
@@ -196,7 +196,7 @@ static const char *proxylist_read(cmd_parms *cmd, void *internal,
     rv = ap_pcfg_openfile(&cfp, cmd->temp_pool, filename);
     if (rv != APR_SUCCESS) {
         return apr_psprintf(cmd->pool, "%s: Could not open file %s: %s",
-                            cmd->cmd->name, filename, 
+                            cmd->cmd->name, filename,
                             apr_strerror(rv, lbuf, sizeof(lbuf)));
     }
 
@@ -207,7 +207,7 @@ static const char *proxylist_read(cmd_parms *cmd, void *internal,
                 break;
             errmsg = proxies_set(cmd, internal, arg);
             if (errmsg) {
-                errmsg = apr_psprintf(cmd->pool, "%s at line %d of %s", 
+                errmsg = apr_psprintf(cmd->pool, "%s at line %d of %s",
                                       errmsg, cfp->line_number, filename);
                 return errmsg;
             }
@@ -292,7 +292,7 @@ static int remoteip_modify_connection(request_rec *r)
             *(parse_remote++) = '\0';
         }
 
-        while (*parse_remote == ' ') 
+        while (*parse_remote == ' ')
             ++parse_remote;
 
         eos = parse_remote + strlen(parse_remote) - 1;
@@ -309,12 +309,12 @@ static int remoteip_modify_connection(request_rec *r)
 
 #ifdef REMOTEIP_OPTIMIZED
         /* Decode remote_addr - sucks; apr_sockaddr_vars_set isn't 'public' */
-        if (inet_pton(AF_INET, parse_remote, 
+        if (inet_pton(AF_INET, parse_remote,
                       &temp_sa->sa.sin.sin_addr) > 0) {
             apr_sockaddr_vars_set(temp_sa, APR_INET, temp_sa.port);
         }
 #if APR_HAVE_IPV6
-        else if (inet_pton(AF_INET6, parse_remote, 
+        else if (inet_pton(AF_INET6, parse_remote,
                            &temp_sa->sa.sin6.sin6_addr) > 0) {
             apr_sockaddr_vars_set(temp_sa, APR_INET6, temp_sa.port);
         }
@@ -323,9 +323,9 @@ static int remoteip_modify_connection(request_rec *r)
             rv = apr_get_netos_error();
 #else /* !REMOTEIP_OPTIMIZED */
         /* We map as IPv4 rather than IPv6 for equivilant host names
-         * or IPV4OVERIPV6 
+         * or IPV4OVERIPV6
          */
-        rv = apr_sockaddr_info_get(&temp_sa,  parse_remote, 
+        rv = apr_sockaddr_info_get(&temp_sa,  parse_remote,
                                    APR_UNSPEC, temp_sa->port,
                                    APR_IPV4_ADDR_OK, r->pool);
         if (rv != APR_SUCCESS) {
@@ -348,7 +348,7 @@ static int remoteip_modify_connection(request_rec *r)
               && ((temp_sa->family == APR_INET
                    /* For internet (non-Internal proxies) deny all
                     * RFC3330 designated local/private subnets:
-                    * 10.0.0.0/8   169.254.0.0/16  192.168.0.0/16 
+                    * 10.0.0.0/8   169.254.0.0/16  192.168.0.0/16
                     * 127.0.0.0/8  172.16.0.0/12
                     */
                       && (addrbyte[0] == 10
@@ -358,7 +358,7 @@ static int remoteip_modify_connection(request_rec *r)
                        || (addrbyte[0] == 192 && addrbyte[1] == 168)))
 #if APR_HAVE_IPV6
                || (temp_sa->family == APR_INET6
-                   /* For internet (non-Internal proxies) we translated 
+                   /* For internet (non-Internal proxies) we translated
                     * IPv4-over-IPv6-mapped addresses as IPv4, above.
                     * Accept only Global Unicast 2000::/3 defined by RFC4291
                     */
@@ -386,7 +386,7 @@ static int remoteip_modify_connection(request_rec *r)
         /* Set remote_ip string */
         if (!internal) {
             if (proxy_ips)
-                proxy_ips = apr_pstrcat(r->pool, proxy_ips, ", ", 
+                proxy_ips = apr_pstrcat(r->pool, proxy_ips, ", ",
                                         c->remote_ip, NULL);
             else
                 proxy_ips = c->remote_ip;
@@ -400,7 +400,7 @@ static int remoteip_modify_connection(request_rec *r)
     if (!conn || (c->remote_addr == conn->orig_addr))
         return OK;
 
-    /* Fixups here, remote becomes the new Via header value, etc 
+    /* Fixups here, remote becomes the new Via header value, etc
      * In the heavy operations above we used request scope, to limit
      * conn pool memory growth on keepalives, so here we must scope
      * the final results to the connection pool lifetime.
@@ -416,7 +416,7 @@ static int remoteip_modify_connection(request_rec *r)
     if (remote)
         remote = apr_pstrdup(c->pool, remote);
     conn->proxied_remote = remote;
-    conn->prior_remote = apr_pstrdup(c->pool, apr_table_get(r->headers_in, 
+    conn->prior_remote = apr_pstrdup(c->pool, apr_table_get(r->headers_in,
                                                       config->header_name));
     if (proxy_ips)
         proxy_ips = apr_pstrdup(c->pool, proxy_ips);
@@ -440,7 +440,7 @@ ditto_request_rec:
     }
 
     ap_log_rerror(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, 0, r,
-                  conn->proxy_ips 
+                  conn->proxy_ips
                       ? "Using %s as client's IP by proxies %s"
                       : "Using %s as client's IP by internal proxies",
                   conn->proxied_ip, conn->proxy_ips);
diff --git a/modules/proxy/balancers/mod_lbmethod_bybusyness.c b/modules/proxy/balancers/mod_lbmethod_bybusyness.c
index 0ddfae1..dec610e 100644
--- a/modules/proxy/balancers/mod_lbmethod_bybusyness.c
+++ b/modules/proxy/balancers/mod_lbmethod_bybusyness.c
@@ -35,7 +35,7 @@ static proxy_worker *find_best_bybusyness(proxy_balancer *balancer,
     int checked_standby;
 
     int total_factor = 0;
-    
+
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "proxy: Entering bybusyness for BALANCER (%s)",
                  balancer->name);
@@ -76,7 +76,7 @@ static proxy_worker *find_best_bybusyness(proxy_balancer *balancer,
 
                     (*worker)->s->lbstatus += (*worker)->s->lbfactor;
                     total_factor += (*worker)->s->lbfactor;
-                    
+
                     if (!mycandidate
                         || (*worker)->s->busy < mycandidate->s->busy
                         || ((*worker)->s->busy == mycandidate->s->busy && (*worker)->s->lbstatus > mycandidate->s->lbstatus))
diff --git a/modules/proxy/balancers/mod_lbmethod_byrequests.c b/modules/proxy/balancers/mod_lbmethod_byrequests.c
index 09eea9b..e757bf8 100644
--- a/modules/proxy/balancers/mod_lbmethod_byrequests.c
+++ b/modules/proxy/balancers/mod_lbmethod_byrequests.c
@@ -79,7 +79,7 @@ static proxy_worker *find_best_byrequests(proxy_balancer *balancer,
     int max_lbset = 0;
     int checking_standby;
     int checked_standby;
-    
+
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "proxy: Entering byrequests for BALANCER (%s)",
                  balancer->name);
diff --git a/modules/proxy/balancers/mod_lbmethod_heartbeat.c b/modules/proxy/balancers/mod_lbmethod_heartbeat.c
index 65f7575..e5b5c27 100644
--- a/modules/proxy/balancers/mod_lbmethod_heartbeat.c
+++ b/modules/proxy/balancers/mod_lbmethod_heartbeat.c
@@ -64,7 +64,7 @@ argstr_to_table(apr_pool_t *p, char *str, apr_table_t *parms)
     char *key;
     char *value;
     char *strtok_state;
-    
+
     key = apr_strtok(str, "&", &strtok_state);
     while (key) {
         value = strchr(key, '=');
@@ -158,12 +158,12 @@ static apr_status_t readfile_heartbeats(const char *path, apr_hash_t *servers,
             if (!t) {
                 continue;
             }
-            
+
             ip = apr_pstrndup(pool, buf, t - buf);
             t++;
 
             server = apr_hash_get(servers, ip, APR_HASH_KEY_STRING);
-            
+
             if (server == NULL) {
                 server = apr_pcalloc(pool, sizeof(hb_server_t));
                 server->ip = ip;
@@ -172,7 +172,7 @@ static apr_status_t readfile_heartbeats(const char *path, apr_hash_t *servers,
 
                 apr_hash_set(servers, server->ip, APR_HASH_KEY_STRING, server);
             }
-            
+
             apr_table_clear(hbt);
 
             argstr_to_table(pool, apr_pstrdup(pool, t), hbt);
@@ -194,9 +194,9 @@ static apr_status_t readfile_heartbeats(const char *path, apr_hash_t *servers,
             }
 
             if (server->busy == 0 && server->ready != 0) {
-                /* Server has zero threads active, but lots of them ready, 
-                 * it likely just started up, so lets /4 the number ready, 
-                 * to prevent us from completely flooding it with all new 
+                /* Server has zero threads active, but lots of them ready,
+                 * it likely just started up, so lets /4 the number ready,
+                 * to prevent us from completely flooding it with all new
                  * requests.
                  */
                 server->ready = server->ready / 4;
@@ -266,7 +266,7 @@ static proxy_worker *find_best_hb(proxy_balancer *balancer,
     apr_pool_t *tpool;
     apr_hash_t *servers;
 
-    lb_hb_ctx_t *ctx = 
+    lb_hb_ctx_t *ctx =
         ap_get_module_config(r->server->module_config,
                              &lbmethod_heartbeat_module);
 
@@ -354,7 +354,7 @@ static int lb_hb_init(apr_pool_t *p, apr_pool_t *plog,
     unsigned int num;
     lb_hb_ctx_t *ctx = ap_get_module_config(s->module_config,
                                             &lbmethod_heartbeat_module);
-    
+
     /* do nothing on first call */
     if (ap_state_query(AP_SQ_MAIN_STATE) == AP_SQ_MS_CREATE_PRE_CONFIG)
         return OK;
@@ -389,9 +389,9 @@ static void register_hooks(apr_pool_t *p)
 static void *lb_hb_create_config(apr_pool_t *p, server_rec *s)
 {
     lb_hb_ctx_t *ctx = (lb_hb_ctx_t *) apr_palloc(p, sizeof(lb_hb_ctx_t));
-    
+
     ctx->path = ap_server_root_relative(p, "logs/hb.dat");
-    
+
     return ctx;
 }
 
@@ -420,7 +420,7 @@ static const char *cmd_lb_hb_storage(cmd_parms *cmd,
                                          &lbmethod_heartbeat_module);
 
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    
+
     if (err != NULL) {
         return err;
     }
diff --git a/modules/proxy/examples/mod_lbmethod_rr.c b/modules/proxy/examples/mod_lbmethod_rr.c
index 9e5e7a9..2ed3134 100644
--- a/modules/proxy/examples/mod_lbmethod_rr.c
+++ b/modules/proxy/examples/mod_lbmethod_rr.c
@@ -52,7 +52,7 @@ static proxy_worker *find_best_roundrobin(proxy_balancer *balancer,
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "proxy: Entering roundrobin for BALANCER %s (%d)",
                  balancer->name, (int)getpid());
-    
+
     /* The index of the candidate last chosen is stored in ctx->index */
     if (!balancer->context) {
         /* UGLY */
diff --git a/modules/proxy/mod_proxy.c b/modules/proxy/mod_proxy.c
index 52c3ee7..3cc90ab 100644
--- a/modules/proxy/mod_proxy.c
+++ b/modules/proxy/mod_proxy.c
@@ -281,7 +281,7 @@ static const char *set_balancer_param(proxy_server_conf *conf,
             return "stickysession length must be < 64 characters";
         PROXY_STRNCPY(balancer->s->sticky_path, val);
         PROXY_STRNCPY(balancer->s->sticky, val);
-        
+
         if ((path = strchr((char *)balancer->s->sticky, '|'))) {
             *path++ = '\0';
             PROXY_STRNCPY(balancer->s->sticky_path, path);
@@ -369,7 +369,7 @@ static const char *set_balancer_param(proxy_server_conf *conf,
     else if (!strcasecmp(key, "nonce")) {
         if (!strcasecmp(val, "None")) {
             *balancer->s->nonce = '\0';
-        } 
+        }
         else {
             if (strlen(val) > sizeof(balancer->s->nonce)-1) {
                 return "Provided nonce is too large";
diff --git a/modules/proxy/mod_proxy_ajp.c b/modules/proxy/mod_proxy_ajp.c
index c92cea5..3465a97 100644
--- a/modules/proxy/mod_proxy_ajp.c
+++ b/modules/proxy/mod_proxy_ajp.c
@@ -482,7 +482,7 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                         }
                         else {
                             apr_status_t rv;
-    
+
                             /* Handle the case where the error document is itself reverse
                              * proxied and was successful. We must maintain any previous
                              * error status so that an underlying error (eg HTTP_NOT_FOUND)
@@ -493,11 +493,11 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
                                 r->status = original_status;
                                 r->status_line = original_status_line;
                             }
-    
+
                             e = apr_bucket_transient_create(send_body_chunk_buff, size,
                                                         r->connection->bucket_alloc);
                             APR_BRIGADE_INSERT_TAIL(output_brigade, e);
-    
+
                             if ((conn->worker->s->flush_packets == flush_on) ||
                                 ((conn->worker->s->flush_packets == flush_auto) &&
                                 ((rv = apr_poll(conn_poll, 1, &conn_poll_fd,
diff --git a/modules/proxy/mod_proxy_balancer.c b/modules/proxy/mod_proxy_balancer.c
index aa2de41..8d8f230 100644
--- a/modules/proxy/mod_proxy_balancer.c
+++ b/modules/proxy/mod_proxy_balancer.c
@@ -846,7 +846,7 @@ static void push2table(const char *input, apr_table_t *params,
     char *args;
     char *tok, *val;
     char *key;
-    
+
     if (input == NULL) {
         return;
     }
@@ -943,7 +943,7 @@ static int balancer_handler(request_rec *r)
         apr_bucket_brigade *ib;
         apr_size_t len = 1024;
         char *buf = apr_pcalloc(r->pool, len+1);
-        
+
         ib = apr_brigade_create(r->connection->pool, r->connection->bucket_alloc);
         rv = ap_get_brigade(r->input_filters, ib, AP_MODE_READBYTES,
                                 APR_BLOCK_READ, len);
diff --git a/modules/proxy/mod_proxy_connect.c b/modules/proxy/mod_proxy_connect.c
index e6a3d29..4ccd6ca 100644
--- a/modules/proxy/mod_proxy_connect.c
+++ b/modules/proxy/mod_proxy_connect.c
@@ -71,7 +71,7 @@ static void *merge_config(apr_pool_t *p, void *basev, void *overridesv)
     c->allowed_connect_ports = apr_array_append(p,
                                                 base->allowed_connect_ports,
                                                 overrides->allowed_connect_ports);
-    
+
     return c;
 }
 
@@ -118,7 +118,7 @@ static int allowed_port(connect_conf *conf, int port)
 {
     int i;
     port_range *list = (port_range *) conf->allowed_connect_ports->elts;
-    
+
     if (apr_is_empty_array(conf->allowed_connect_ports)){
         return port == APR_URI_HTTPS_DEFAULT_PORT
                || port == APR_URI_SNEWS_DEFAULT_PORT;
@@ -400,7 +400,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
         nbytes = apr_snprintf(buffer, sizeof(buffer),
                               "HTTP/1.0 200 Connection Established" CRLF);
         ap_xlate_proto_to_ascii(buffer, nbytes);
-        ap_fwrite(c->output_filters, bb, buffer, nbytes); 
+        ap_fwrite(c->output_filters, bb, buffer, nbytes);
         nbytes = apr_snprintf(buffer, sizeof(buffer),
                               "Proxy-agent: %s" CRLF CRLF,
                               ap_get_server_banner());
@@ -439,7 +439,7 @@ static int proxy_connect_handler(request_rec *r, proxy_worker *worker,
     while (1) { /* Infinite loop until error (one side closes the connection) */
         if ((rv = apr_pollset_poll(pollset, -1, &pollcnt, &signalled))
             != APR_SUCCESS) {
-            if (APR_STATUS_IS_EINTR(rv)) { 
+            if (APR_STATUS_IS_EINTR(rv)) {
                 continue;
             }
             apr_socket_close(sock);
diff --git a/modules/proxy/mod_proxy_express.c b/modules/proxy/mod_proxy_express.c
index 7e34535..7dbc50d 100644
--- a/modules/proxy/mod_proxy_express.c
+++ b/modules/proxy/mod_proxy_express.c
@@ -44,7 +44,7 @@ static const char *set_dbmfile(cmd_parms *cmd,
 static const char *set_dbmtype(cmd_parms *cmd,
                                void *dconf,
                                const char *arg)
-{    
+{
     express_server_conf *sconf;
     sconf = ap_get_module_config(cmd->server->module_config, &proxy_express_module);
 
@@ -58,7 +58,7 @@ static const char *set_enabled(cmd_parms *cmd,
 {
     express_server_conf *sconf;
     sconf = ap_get_module_config(cmd->server->module_config, &proxy_express_module);
-    
+
     sconf->enabled = flag;
 
     return NULL;
@@ -67,20 +67,20 @@ static const char *set_enabled(cmd_parms *cmd,
 static void *server_create(apr_pool_t *p, server_rec *s)
 {
     express_server_conf *a;
-    
+
     a = (express_server_conf *)apr_pcalloc(p, sizeof(express_server_conf));
-    
+
     a->dbmfile = NULL;
     a->dbmtype = "default";
     a->enabled = 0;
-    
+
     return (void *)a;
 }
 
 static void *server_merge(apr_pool_t *p, void *basev, void *overridesv)
 {
     express_server_conf *a, *base, *overrides;
-    
+
     a         = (express_server_conf *)apr_pcalloc(p,
                                                    sizeof(express_server_conf));
     base      = (express_server_conf *)basev;
@@ -137,7 +137,7 @@ static int xlate_name(request_rec *r)
     if (rv != APR_SUCCESS) {
         return DECLINED;
     }
- 
+
     name = ap_get_server_name(r);
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "proxy_express: looking for %s", name);
diff --git a/modules/proxy/mod_proxy_fcgi.c b/modules/proxy/mod_proxy_fcgi.c
index 0500218..154c07a 100644
--- a/modules/proxy/mod_proxy_fcgi.c
+++ b/modules/proxy/mod_proxy_fcgi.c
@@ -85,7 +85,7 @@ static int proxy_fcgi_canon(request_rec *r, char *url)
     else {
         return DECLINED;
     }
-    
+
     ap_log_error(APLOG_MARK, APLOG_TRACE1, 0, r->server,
                  "proxy: FCGI: canonicalising URL %s", url);
 
@@ -95,9 +95,9 @@ static int proxy_fcgi_canon(request_rec *r, char *url)
                       "error parsing URL %s: %s", url, err);
         return HTTP_BAD_REQUEST;
     }
-        
+
     apr_snprintf(sport, sizeof(sport), ":%d", port);
-        
+
     if (ap_strchr_c(host, ':')) {
         /* if literal IPv6 address */
         host = apr_pstrcat(r->pool, "[", host, "]", NULL);
@@ -246,7 +246,7 @@ static apr_status_t send_begin_request(proxy_conn_rec *conn, int request_id)
     fill_in_header(&header, FCGI_BEGIN_REQUEST, request_id, sizeof(abrb), 0);
 
     brb.roleB1 = ((FCGI_RESPONDER >> 8) & 0xff);
-    brb.roleB0 = ((FCGI_RESPONDER) & 0xff); 
+    brb.roleB0 = ((FCGI_RESPONDER) & 0xff);
     brb.flags = FCGI_KEEP_CONN;
     brb.reserved[0] = 0;
     brb.reserved[1] = 0;
@@ -265,7 +265,7 @@ static apr_status_t send_begin_request(proxy_conn_rec *conn, int request_id)
     return send_data(conn, vec, 2, &len, 1);
 }
 
-static apr_status_t send_environment(proxy_conn_rec *conn, request_rec *r, 
+static apr_status_t send_environment(proxy_conn_rec *conn, request_rec *r,
                                      int request_id)
 {
     const apr_array_header_t *envarr;
@@ -350,7 +350,7 @@ static apr_status_t send_environment(proxy_conn_rec *conn, request_rec *r,
 
     for (i = 0; i < numenv; ++i) {
         apr_size_t keylen, vallen;
-       
+
         if (! elts[i].key) {
             continue;
         }
@@ -494,7 +494,7 @@ static void dump_header_to_log(request_rec *r, unsigned char fheader[],
     memset(hex_line, 0, sizeof(hex_line));
 
     while (posn < length) {
-        unsigned char c = fheader[posn]; 
+        unsigned char c = fheader[posn];
 
         if (i >= 20) {
             i = 0;
@@ -669,11 +669,11 @@ static apr_status_t dispatch(proxy_conn_rec *conn, proxy_dir_conf *conf,
             }
 
             dump_header_to_log(r, farray, readbuflen);
-            
+
             if (readbuflen != FCGI_HEADER_LEN) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                              "proxy: FCGI: Failed to read entire header "
-                             "got %" APR_SIZE_T_FMT " wanted %d", 
+                             "got %" APR_SIZE_T_FMT " wanted %d",
                              readbuflen, FCGI_HEADER_LEN);
                 rv = APR_EINVAL;
                 break;
@@ -881,13 +881,13 @@ static int fcgi_do_request(apr_pool_t *p, request_rec *r,
                            char *url, char *server_portstr)
 {
     /* Request IDs are arbitrary numbers that we assign to a
-     * single request. This would allow multiplex/pipelinig of 
-     * multiple requests to the same FastCGI connection, but 
+     * single request. This would allow multiplex/pipelinig of
+     * multiple requests to the same FastCGI connection, but
      * we don't support that, and always use a value of '1' to
      * keep things simple. */
-    int request_id = 1; 
+    int request_id = 1;
     apr_status_t rv;
-   
+
     /* Step 1: Send FCGI_BEGIN_REQUEST */
     rv = send_begin_request(conn, request_id);
     if (rv != APR_SUCCESS) {
@@ -897,7 +897,7 @@ static int fcgi_do_request(apr_pool_t *p, request_rec *r,
         conn->close = 1;
         return HTTP_SERVICE_UNAVAILABLE;
     }
-    
+
     /* Step 2: Send Environment via FCGI_PARAMS */
     rv = send_environment(conn, r, request_id);
     if (rv != APR_SUCCESS) {
@@ -955,7 +955,7 @@ static int proxy_fcgi_handler(request_rec *r, proxy_worker *worker,
                      "proxy: FCGI: declining URL %s", url);
         return DECLINED;
     }
-    
+
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "proxy: FCGI: serving URL %s", url);
 
diff --git a/modules/proxy/mod_proxy_fdpass.c b/modules/proxy/mod_proxy_fdpass.c
index ca547f8..0a170f5 100644
--- a/modules/proxy/mod_proxy_fdpass.c
+++ b/modules/proxy/mod_proxy_fdpass.c
@@ -44,7 +44,7 @@ static int proxy_fdpass_canon(request_rec *r, char *url)
     else {
         return DECLINED;
     }
-    
+
     path = ap_server_root_relative(r->pool, url);
 
     r->filename = apr_pstrcat(r->pool, "proxy:fd://", path, NULL);
@@ -89,7 +89,7 @@ static apr_status_t socket_connect_un(apr_socket_t *sock,
             return rv;
         }
     }
-    
+
     if (rv == -1 && errno != EISCONN) {
         return errno;
     }
@@ -137,7 +137,7 @@ static apr_status_t send_socket(apr_pool_t *p,
     struct cmsghdr *cmsg;
     struct iovec iov;
     char b = '\0';
-    
+
     rv = apr_os_sock_get(&rawsock, outbound);
     if (rv != APR_SUCCESS) {
         return rv;
@@ -147,7 +147,7 @@ static apr_status_t send_socket(apr_pool_t *p,
     if (rv != APR_SUCCESS) {
         return rv;
     }
-    
+
     memset(&msg, 0, sizeof(msg));
 
     msg.msg_iov = &iov;
@@ -172,7 +172,7 @@ static apr_status_t send_socket(apr_pool_t *p,
         return errno;
     }
 
-    
+
     return APR_SUCCESS;
 }
 
@@ -232,8 +232,8 @@ static int proxy_fdpass_handler(request_rec *r, proxy_worker *worker,
 
     {
         apr_socket_t *dummy;
-        /* Create a dummy unconnected socket, and set it as the one we were 
-         * connected to, so that when the core closes it, it doesn't close 
+        /* Create a dummy unconnected socket, and set it as the one we were
+         * connected to, so that when the core closes it, it doesn't close
          * the tcp connection to the client.
          */
         rv = apr_socket_create(&dummy, APR_INET, SOCK_STREAM, APR_PROTO_TCP,
@@ -245,8 +245,8 @@ static int proxy_fdpass_handler(request_rec *r, proxy_worker *worker,
         }
         ap_set_core_module_config(r->connection->conn_config, dummy);
     }
-    
-    
+
+
     return OK;
 }
 
@@ -260,7 +260,7 @@ static int standard_flush(request_rec *r)
 
     bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
     e = apr_bucket_flush_create(r->connection->bucket_alloc);
-    
+
     APR_BRIGADE_INSERT_TAIL(bb, e);
 
     status = ap_pass_brigade(r->output_filters, bb);
diff --git a/modules/proxy/mod_proxy_ftp.c b/modules/proxy/mod_proxy_ftp.c
index 20622be..aa1cf24 100644
--- a/modules/proxy/mod_proxy_ftp.c
+++ b/modules/proxy/mod_proxy_ftp.c
@@ -146,7 +146,7 @@ static const char *ftp_escape_globbingchars(apr_pool_t *p, const char *path, pro
 {
     char *ret;
     char *d;
-    
+
     if (!dconf->ftp_escape_wildcards) {
         return path;
     }
@@ -1008,9 +1008,9 @@ static int proxy_ftp_handler(request_rec *r, proxy_worker *worker,
         && (password = ap_pbase64decode(r->pool, password))[0] != ':') {
         /* Check the decoded string for special characters. */
         if (!ftp_check_string(password)) {
-            return ap_proxyerror(r, HTTP_BAD_REQUEST, 
+            return ap_proxyerror(r, HTTP_BAD_REQUEST,
                                  "user credentials contained invalid character");
-        } 
+        }
         /*
          * Note that this allocation has to be made from r->connection->pool
          * because it has the lifetime of the connection.  The other
diff --git a/modules/proxy/mod_proxy_http.c b/modules/proxy/mod_proxy_http.c
index 940c1f9..4e897d8 100644
--- a/modules/proxy/mod_proxy_http.c
+++ b/modules/proxy/mod_proxy_http.c
@@ -283,7 +283,7 @@ static int pass_brigade(apr_bucket_alloc_t *bucket_alloc,
             return APR_STATUS_IS_TIMEUP(status) ? HTTP_GATEWAY_TIME_OUT : HTTP_BAD_GATEWAY;
         }
         else {
-            return HTTP_BAD_REQUEST; 
+            return HTTP_BAD_REQUEST;
         }
     }
     apr_brigade_cleanup(bb);
@@ -439,7 +439,7 @@ static int stream_reqbody_cl(apr_pool_t *p,
 
         add_cl(p, bucket_alloc, header_brigade, old_cl_val);
         status = apr_strtoff(&cl_val, old_cl_val, &endstr, 10);
-        
+
         if (status || *endstr || endstr == old_cl_val || cl_val < 0) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
                           "proxy: could not parse request Content-Length (%s)",
@@ -719,7 +719,7 @@ int ap_proxy_http_request(apr_pool_t *p, request_rec *r,
     proxy_dir_conf *dconf;
     conn_rec *origin = p_conn->connection;
     int do_100_continue;
-    
+
     dconf = ap_get_module_config(r->per_dir_config, &proxy_module);
     header_brigade = apr_brigade_create(p, origin->bucket_alloc);
 
@@ -735,7 +735,7 @@ int ap_proxy_http_request(apr_pool_t *p, request_rec *r,
                        && ap_request_has_body(r)
                        && (PROXYREQ_REVERSE == r->proxyreq)
                        && !(apr_table_get(r->subprocess_env, "force-proxy-request-1.0")));
-    
+
     if (apr_table_get(r->subprocess_env, "force-proxy-request-1.0")) {
         /*
          * According to RFC 2616 8.2.3 we are not allowed to forward an
@@ -762,14 +762,14 @@ int ap_proxy_http_request(apr_pool_t *p, request_rec *r,
     if (dconf->preserve_host == 0) {
         if (ap_strchr_c(uri->hostname, ':')) { /* if literal IPv6 address */
             if (uri->port_str && uri->port != DEFAULT_HTTP_PORT) {
-                buf = apr_pstrcat(p, "Host: [", uri->hostname, "]:", 
+                buf = apr_pstrcat(p, "Host: [", uri->hostname, "]:",
                                   uri->port_str, CRLF, NULL);
             } else {
                 buf = apr_pstrcat(p, "Host: [", uri->hostname, "]", CRLF, NULL);
             }
         } else {
             if (uri->port_str && uri->port != DEFAULT_HTTP_PORT) {
-                buf = apr_pstrcat(p, "Host: ", uri->hostname, ":", 
+                buf = apr_pstrcat(p, "Host: ", uri->hostname, ":",
                                   uri->port_str, CRLF, NULL);
             } else {
                 buf = apr_pstrcat(p, "Host: ", uri->hostname, CRLF, NULL);
@@ -966,7 +966,7 @@ int ap_proxy_http_request(apr_pool_t *p, request_rec *r,
      * input_brigade and jump past all of the request body logic...
      * Reading anything with ap_get_brigade is likely to consume the
      * main request's body or read beyond EOS - which would be unplesant.
-     * 
+     *
      * An exception: when a kept_body is present, then subrequest CAN use
      * pass request bodies, and we DONT skip the body.
      */
@@ -1429,10 +1429,10 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                        && ap_request_has_body(r)
                        && (PROXYREQ_REVERSE == r->proxyreq)
                        && !(apr_table_get(r->subprocess_env, "force-proxy-request-1.0")));
-    
+
     bb = apr_brigade_create(p, c->bucket_alloc);
     pass_bb = apr_brigade_create(p, c->bucket_alloc);
-    
+
     /* Setup for 100-Continue timeout if appropriate */
     if (do_100_continue) {
         apr_socket_timeout_get(backend->sock, &old_timeout);
@@ -1497,7 +1497,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                               "proxy: Closing connection to client because"
                               " reading from backend server %s:%d failed."
-                              " Number of keepalives %i", backend->hostname, 
+                              " Number of keepalives %i", backend->hostname,
                               backend->port, c->keepalives);
                 ap_proxy_backend_broke(r, bb);
                 /*
@@ -2000,7 +2000,7 @@ apr_status_t ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
     /* See define of AP_MAX_INTERIM_RESPONSES for why */
     if (interim_response >= AP_MAX_INTERIM_RESPONSES) {
         return ap_proxyerror(r, HTTP_BAD_GATEWAY,
-                             apr_psprintf(p, 
+                             apr_psprintf(p,
                              "Too many (%d) interim responses from origin server",
                              interim_response));
     }
diff --git a/modules/proxy/mod_proxy_scgi.c b/modules/proxy/mod_proxy_scgi.c
index fc7e488..0a56e57 100644
--- a/modules/proxy/mod_proxy_scgi.c
+++ b/modules/proxy/mod_proxy_scgi.c
@@ -143,7 +143,7 @@ static const apr_bucket_type_t bucket_type_socket_ex = {
     "SOCKET_EX", 5, APR_BUCKET_DATA,
     apr_bucket_destroy_noop,
     bucket_socket_ex_read,
-    apr_bucket_setaside_notimpl, 
+    apr_bucket_setaside_notimpl,
     apr_bucket_split_notimpl,
     apr_bucket_copy_notimpl
 };
@@ -189,9 +189,9 @@ static int scgi_canon(request_rec *r, char *url)
                       "error parsing URL %s: %s", url, err);
         return HTTP_BAD_REQUEST;
     }
-        
+
     apr_snprintf(sport, sizeof(sport), ":%u", port);
-        
+
     if (ap_strchr(host, ':')) { /* if literal IPv6 address */
         host = apr_pstrcat(r->pool, "[", host, "]", NULL);
     }
diff --git a/modules/proxy/mod_serf.c b/modules/proxy/mod_serf.c
index 408179b..3f899e2 100644
--- a/modules/proxy/mod_serf.c
+++ b/modules/proxy/mod_serf.c
@@ -76,7 +76,7 @@ typedef struct {
 static void timed_cleanup_callback(void *baton)
 {
     s_baton_t *ctx = baton;
-    
+
     /* Causes all serf connections to unregister from the event mpm */
     if (ctx->rstatus) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, ctx->rstatus, ctx->r,
@@ -95,7 +95,7 @@ static void timed_cleanup_callback(void *baton)
 
         /* TODO: return code? bleh */
         ap_pass_brigade(ctx->r->output_filters, ctx->tmpbb);
-        
+
         apr_pool_destroy(ctx->serf_pool);
 
         ap_finalize_request_protocol(ctx->r);
@@ -144,7 +144,7 @@ static int copy_headers_in(void *vbaton, const char *key, const char *value)
 {
     serf_bucket_t *hdrs_bkt = (serf_bucket_t *)vbaton;
 
-    /* XXXXX: List of headers not to copy to serf. serf's serf_bucket_headers_setn, 
+    /* XXXXX: List of headers not to copy to serf. serf's serf_bucket_headers_setn,
      * doesn't actually overwrite a header if we set it once, so we need to ignore anything
      * we might want to toggle or combine.
      */
@@ -292,9 +292,9 @@ static apr_status_t handle_response(serf_request_t *request,
 
         return rv;
     }
-    
+
     /**
-     * XXXXX: If I understood serf buckets better, it might be possible to not 
+     * XXXXX: If I understood serf buckets better, it might be possible to not
      * copy all of the data here, and better stream it to the client.
      **/
 
@@ -314,7 +314,7 @@ static apr_status_t handle_response(serf_request_t *request,
             /* TODO: improve */
             serf_bucket_response_status(response, &line);
             ctx->r->status = line.code;
-            
+
             hdrs = serf_bucket_response_get_headers(response);
             serf_bucket_headers_do(hdrs, copy_headers_out, ctx);
             ctx->done_headers = 1;
@@ -390,7 +390,7 @@ static apr_status_t setup_request(serf_request_t *request,
                                                       ctx->bkt_alloc);
         }
     }
-    
+
     *acceptor = accept_response;
     *acceptor_baton = ctx;
     *handler = handle_response;
@@ -409,7 +409,7 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
     /* XXXXX: make persistent/per-process or something.*/
     serf_context_t *serfme;
     serf_connection_t *conn;
-    serf_server_config_t *ctx = 
+    serf_server_config_t *ctx =
         (serf_server_config_t *)ap_get_module_config(r->server->module_config,
                                                      &serf_module);
 
@@ -426,7 +426,7 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
         apr_uint32_t pick = 0;
         ap_serf_server_t *choice;
 
-        /* TODO: could this be optimized in post-config to pre-setup the 
+        /* TODO: could this be optimized in post-config to pre-setup the
          * pointers to the right cluster inside the conf structure?
          */
         cluster = apr_hash_get(ctx->clusters,
@@ -439,7 +439,7 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
         }
 
         cp = ap_lookup_provider(AP_SERF_CLUSTER_PROVIDER, cluster->provider, "0");
-        
+
         if (cp == NULL) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                           "SerfCluster: unable to find provider %s", cluster->provider);
@@ -451,7 +451,7 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
                           "SerfCluster: %s is missing list servers provider.", cluster->provider);
             return HTTP_INTERNAL_SERVER_ERROR;
         }
-        
+
         rc = cp->list_servers(cp->baton,
                               r,
                               cluster->params,
@@ -557,7 +557,7 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
         apr_file_seek(fp, APR_SET, &flen);
         baton->body_bkt = serf_bucket_file_create(fp, baton->bkt_alloc);
     }
-    
+
     conn = serf_connection_create(serfme, address,
                                   conn_setup, baton,
                                   closed_connection, baton,
@@ -572,20 +572,20 @@ static int drive_serf(request_rec *r, serf_config_t *conf)
     else {
         do {
             rv = serf_context_run(serfme, SERF_DURATION_FOREVER, pool);
-            
+
             /* XXXX: Handle timeouts */
             if (APR_STATUS_IS_TIMEUP(rv)) {
                 continue;
             }
-            
+
             if (rv != APR_SUCCESS) {
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "serf_context_run() for %pI", address);
-                return HTTP_INTERNAL_SERVER_ERROR;       
+                return HTTP_INTERNAL_SERVER_ERROR;
             }
-            
+
             serf_debug__closed_conn(baton->bkt_alloc);
         } while (baton->keep_reading);
-        
+
         return baton->rstatus;
     }
 }
@@ -645,7 +645,7 @@ static const char *add_pass(cmd_parms *cmd, void *vconf,
     for (i = 1; i < argc; i++) {
         const char *p = argv[i];
         const char *x = ap_strchr_c(p, '=');
-        
+
         if (x) {
             if (strncmp(p, "preservehost", x-p) == 0) {
                 conf->preservehost = is_true(x+1);
@@ -654,7 +654,7 @@ static const char *add_pass(cmd_parms *cmd, void *vconf,
     }
 
     conf->on = 1;
-    
+
     return NULL;
 }
 
@@ -667,12 +667,12 @@ static const char *add_cluster(cmd_parms *cmd, void *d,
     ap_serf_cluster_provider_t *backend;
     int i;
     serf_cluster_t *cluster = NULL;
-    serf_server_config_t *ctx = 
+    serf_server_config_t *ctx =
         (serf_server_config_t *)ap_get_module_config(cmd->server->module_config,
                                                      &serf_module);
 
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-  
+
     if (err != NULL) {
         return err;
     }
@@ -680,14 +680,14 @@ static const char *add_cluster(cmd_parms *cmd, void *d,
     if (argc < 2) {
         return "SerfCluster must have at least a name and provider.";
     }
-    
+
     cluster = apr_palloc(cmd->pool, sizeof(serf_cluster_t));
     cluster->name = apr_pstrdup(cmd->pool, argv[0]);
     cluster->provider = apr_pstrdup(cmd->pool, argv[1]);
     cluster->params = apr_table_make(cmd->pool, 6);
 
     backend = ap_lookup_provider(AP_SERF_CLUSTER_PROVIDER, cluster->provider, "0");
-    
+
     if (backend == NULL) {
         return apr_psprintf(cmd->pool, "SerfCluster: unable to find "
                             "provider '%s'", cluster->provider);
@@ -703,7 +703,7 @@ static const char *add_cluster(cmd_parms *cmd, void *d,
                            x+1);
         }
         else {
-            apr_table_addn(cluster->params, 
+            apr_table_addn(cluster->params,
                            apr_pstrdup(cmd->pool, p),
                            "");
         }
@@ -716,7 +716,7 @@ static const char *add_cluster(cmd_parms *cmd, void *d,
     }
 
     rv = backend->check_config(backend->baton, cmd, cluster->params);
-    
+
     if (rv) {
         return rv;
     }
@@ -736,7 +736,7 @@ static void *create_dir_config(apr_pool_t *p, char *dummy)
 
 static void *create_server_config(apr_pool_t *p, server_rec *s)
 {
-    serf_server_config_t *ctx = 
+    serf_server_config_t *ctx =
         (serf_server_config_t *) apr_pcalloc(p, sizeof(serf_server_config_t));
 
     ctx->clusters = apr_hash_make(p);
@@ -749,10 +749,10 @@ static void * merge_server_config(apr_pool_t *p, void *basev, void *overridesv)
     serf_server_config_t *ctx = apr_pcalloc(p, sizeof(serf_server_config_t));
     serf_server_config_t *base = (serf_server_config_t *) basev;
     serf_server_config_t *overrides = (serf_server_config_t *) overridesv;
-    
+
     ctx->clusters = apr_hash_overlay(p, base->clusters, overrides->clusters);
     return ctx;
-}    
+}
 
 static const command_rec serf_cmds[] =
 {
@@ -790,12 +790,12 @@ static const char* hb_config_check(void *baton,
     if (apr_is_empty_table(params)) {
         return "SerfCluster Heartbeat requires a path to the heartbat information.";
     }
-    
+
     b.p = cmd->pool;
     b.msg = NULL;
 
     apr_table_do(hb_table_check, &b, params, NULL);
-    
+
     if (b.msg) {
         return b.msg;
     }
@@ -817,7 +817,7 @@ argstr_to_table(apr_pool_t *p, char *str, apr_table_t *parms)
     char *key;
     char *value;
     char *strtok_state;
-    
+
     key = apr_strtok(str, "&", &strtok_state);
     while (key) {
         value = strchr(key, '=');
@@ -842,24 +842,24 @@ static apr_status_t read_heartbeats(const char *path,
     apr_finfo_t fi;
     apr_status_t rv;
     apr_file_t *fp;
-    
+
     if (!path) {
         return APR_SUCCESS;
     }
-    
+
     rv = apr_file_open(&fp, path, APR_READ|APR_BINARY|APR_BUFFERED,
                        APR_OS_DEFAULT, pool);
-    
+
     if (rv) {
         return rv;
     }
-    
+
     rv = apr_file_info_get(&fi, APR_FINFO_SIZE, fp);
-    
+
     if (rv) {
         return rv;
     }
-    
+
     {
         char *t;
         int lineno = 0;
@@ -875,14 +875,14 @@ static apr_status_t read_heartbeats(const char *path,
             if (buf[0] == '#') {
                 continue;
             }
-            
-            
+
+
             /* line format: <IP> <query_string>\n */
             t = strchr(buf, ' ');
             if (!t) {
                 continue;
             }
-            
+
             ip = apr_pstrndup(pool, buf, t - buf);
             t++;
             server = apr_pcalloc(pool, sizeof(hb_server_t));
@@ -890,29 +890,29 @@ static apr_status_t read_heartbeats(const char *path,
             server->port = 80;
             server->seen = -1;
             apr_table_clear(hbt);
-            
+
             argstr_to_table(pool, apr_pstrdup(pool, t), hbt);
-            
+
             if (apr_table_get(hbt, "busy")) {
                 server->busy = atoi(apr_table_get(hbt, "busy"));
             }
-            
+
             if (apr_table_get(hbt, "ready")) {
                 server->ready = atoi(apr_table_get(hbt, "ready"));
             }
-            
+
             if (apr_table_get(hbt, "lastseen")) {
                 server->seen = atoi(apr_table_get(hbt, "lastseen"));
             }
-            
+
             if (apr_table_get(hbt, "port")) {
                 server->port = atoi(apr_table_get(hbt, "port"));
             }
-            
+
             if (server->busy == 0 && server->ready != 0) {
-                /* Server has zero threads active, but lots of them ready, 
-                 * it likely just started up, so lets /4 the number ready, 
-                 * to prevent us from completely flooding it with all new 
+                /* Server has zero threads active, but lots of them ready,
+                 * it likely just started up, so lets /4 the number ready,
+                 * to prevent us from completely flooding it with all new
                  * requests.
                  */
                 server->ready = server->ready / 4;
@@ -921,7 +921,7 @@ static apr_status_t read_heartbeats(const char *path,
             APR_ARRAY_PUSH(servers, hb_server_t *) = server;
         }
     }
-    
+
     return APR_SUCCESS;
 }
 
@@ -966,7 +966,7 @@ static int hb_list_servers(void *baton,
         apr_pool_destroy(tpool);
         return HTTP_INTERNAL_SERVER_ERROR;
     }
-    
+
     qsort(tmpservers->elts, tmpservers->nelts, sizeof(hb_server_t *),
           hb_server_sort);
 
@@ -1011,7 +1011,7 @@ static int static_table_check(void *rec, const char *key, const char *value)
                               key);
         return 1;
     }
-    
+
     return 0;
 }
 
@@ -1020,20 +1020,20 @@ static const char* static_config_check(void *baton,
                                    apr_table_t *params)
 {
     hb_table_baton_t b;
-    
+
     if (apr_is_empty_table(params)) {
         return "SerfCluster Static requires at least a host list.";
     }
-    
+
     b.p = cmd->pool;
     b.msg = NULL;
-    
+
     apr_table_do(static_table_check, &b, params, NULL);
-    
+
     if (b.msg) {
         return b.msg;
     }
-    
+
     if (apr_table_get(params, "hosts") == NULL) {
         return "SerfCluster Static requires at least a hosts parameter";
     }
@@ -1053,13 +1053,13 @@ static int static_list_servers(void *baton,
     const char *order = apr_table_get(params, "order");
 
     servers = apr_array_make(r->pool, 10, sizeof(ap_serf_server_t *));
-    
+
     ip = apr_strtok(apr_pstrdup(r->pool, hosts), ",", &strtok_state);
     while (ip) {
         char *host_str;
         char *scope_id;
         apr_port_t port = 0;
-        
+
         rv = apr_parse_addr_port(&host_str, &scope_id, &port, ip, r->pool);
         if (!rv) {
             ap_serf_server_t *s = apr_palloc(r->pool, sizeof(ap_serf_server_t));
@@ -1097,8 +1097,8 @@ static int serf_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp,
     if (rv != APR_SUCCESS) {
         mpm_supprts_serf = 0;
     }
-    
-    return OK; 
+
+    return OK;
 }
 
 static void register_hooks(apr_pool_t *p)
diff --git a/modules/slotmem/mod_slotmem_plain.c b/modules/slotmem/mod_slotmem_plain.c
index 0a6bccb..47da15b 100644
--- a/modules/slotmem/mod_slotmem_plain.c
+++ b/modules/slotmem/mod_slotmem_plain.c
@@ -44,7 +44,7 @@ static apr_status_t slotmem_do(ap_slotmem_instance_t *mem, ap_slotmem_callback_f
     char *ptr;
     char *inuse;
     apr_status_t retval = APR_SUCCESS;
-    
+
 
     if (!mem)
         return APR_ENOSHMAVAIL;
diff --git a/modules/ssl/ssl_engine_config.c b/modules/ssl/ssl_engine_config.c
index 6e44bd7..8897387 100644
--- a/modules/ssl/ssl_engine_config.c
+++ b/modules/ssl/ssl_engine_config.c
@@ -808,7 +808,7 @@ const char *ssl_cmd_SSLCACertificatePath(cmd_parms *cmd,
     if ((err = ssl_cmd_check_dir(cmd, &arg))) {
         return err;
     }
-    
+
     if (cmd->path) {
         return NO_PER_DIR_SSL_CA;
     }
@@ -1066,7 +1066,7 @@ const char *ssl_cmd_SSLSessionCache(cmd_parms *cmd,
         if (mc->sesscache) {
             /* Cache found; create it, passing anything beyond the colon. */
             mc->sesscache_mode = enabled_flags;
-            err = mc->sesscache->create(&mc->sesscache_context, sep, 
+            err = mc->sesscache->create(&mc->sesscache_context, sep,
                                         cmd->temp_pool, cmd->pool);
         }
         else {
@@ -1075,7 +1075,7 @@ const char *ssl_cmd_SSLSessionCache(cmd_parms *cmd,
 
             /* Build a comma-separated list of all registered provider
              * names: */
-            name_list = ap_list_provider_names(cmd->pool, 
+            name_list = ap_list_provider_names(cmd->pool,
                                                AP_SOCACHE_PROVIDER_GROUP,
                                                AP_SOCACHE_PROVIDER_VERSION);
             all_names = apr_array_pstrcat(cmd->pool, name_list, ',');
@@ -1088,7 +1088,7 @@ const char *ssl_cmd_SSLSessionCache(cmd_parms *cmd,
     if (err) {
         return apr_psprintf(cmd->pool, "SSLSessionCache: %s", err);
     }
-    
+
     return NULL;
 }
 
@@ -1414,12 +1414,12 @@ const char *ssl_cmd_SSLProxyCARevocationFile(cmd_parms *cmd,
 const char *ssl_cmd_SSLProxyCARevocationCheck(cmd_parms *cmd,
                                               void *dcfg,
                                               const char *arg)
-{   
+{
     SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
 
     return ssl_cmd_crlcheck_parse(cmd, arg, &sc->proxy->crl_check_mode);
 }
-        
+
 const char *ssl_cmd_SSLProxyMachineCertificateFile(cmd_parms *cmd,
                                                    void *dcfg,
                                                    const char *arg)
@@ -1477,7 +1477,7 @@ const char *ssl_cmd_SSLUserName(cmd_parms *cmd, void *dcfg,
 }
 
 const char *ssl_cmd_SSLOCSPEnable(cmd_parms *cmd, void *dcfg, int flag)
-{   
+{
     SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
 
     sc->server->ocsp_enabled = flag ? TRUE : FALSE;
@@ -1487,11 +1487,11 @@ const char *ssl_cmd_SSLOCSPEnable(cmd_parms *cmd, void *dcfg, int flag)
         return "OCSP support disabled in SSL library; cannot enable "
             "OCSP validation";
     }
-#endif    
+#endif
 
     return NULL;
 }
-        
+
 const char *ssl_cmd_SSLOCSPOverrideResponder(cmd_parms *cmd, void *dcfg, int flag)
 {
     SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
@@ -1502,7 +1502,7 @@ const char *ssl_cmd_SSLOCSPOverrideResponder(cmd_parms *cmd, void *dcfg, int fla
 }
 
 const char *ssl_cmd_SSLOCSPDefaultResponder(cmd_parms *cmd, void *dcfg, const char *arg)
-{   
+{
     SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
 
     sc->server->ocsp_responder = arg;
@@ -1603,20 +1603,20 @@ const char *ssl_cmd_SSLStaplingCache(cmd_parms *cmd,
     if (mc->stapling_cache) {
         /* Cache found; create it, passing anything beyond the colon. */
         err = mc->stapling_cache->create(&mc->stapling_cache_context,
-                                         sep, cmd->temp_pool, 
+                                         sep, cmd->temp_pool,
                                          cmd->pool);
     }
     else {
         apr_array_header_t *name_list;
         const char *all_names;
-        
+
         /* Build a comma-separated list of all registered provider
          * names: */
-        name_list = ap_list_provider_names(cmd->pool, 
+        name_list = ap_list_provider_names(cmd->pool,
                                            AP_SOCACHE_PROVIDER_GROUP,
                                            AP_SOCACHE_PROVIDER_VERSION);
         all_names = apr_array_pstrcat(cmd->pool, name_list, ',');
-        
+
         err = apr_psprintf(cmd->pool, "'%s' stapling cache not supported "
                            "(known names: %s)", name, all_names);
     }
@@ -1624,12 +1624,12 @@ const char *ssl_cmd_SSLStaplingCache(cmd_parms *cmd,
     if (err) {
         return apr_psprintf(cmd->pool, "SSLStaplingCache: %s", err);
     }
-    
+
     return NULL;
 }
 
 const char *ssl_cmd_SSLUseStapling(cmd_parms *cmd, void *dcfg, int flag)
-{   
+{
     SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
     sc->server->stapling_enabled = flag ? TRUE : FALSE;
     return NULL;
@@ -1681,7 +1681,7 @@ const char *ssl_cmd_SSLStaplingErrorCacheTimeout(cmd_parms *cmd, void *dcfg,
 
 const char *ssl_cmd_SSLStaplingReturnResponderErrors(cmd_parms *cmd,
                                                      void *dcfg, int flag)
-{   
+{
     SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
     sc->server->stapling_return_errors = flag ? TRUE : FALSE;
     return NULL;
@@ -1689,7 +1689,7 @@ const char *ssl_cmd_SSLStaplingReturnResponderErrors(cmd_parms *cmd,
 
 const char *ssl_cmd_SSLStaplingFakeTryLater(cmd_parms *cmd,
                                             void *dcfg, int flag)
-{   
+{
     SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
     sc->server->stapling_fake_trylater = flag ? TRUE : FALSE;
     return NULL;
diff --git a/modules/ssl/ssl_engine_init.c b/modules/ssl/ssl_engine_init.c
index f9784ee..67d1258 100644
--- a/modules/ssl/ssl_engine_init.c
+++ b/modules/ssl/ssl_engine_init.c
@@ -40,7 +40,7 @@ static void ssl_add_version_components(apr_pool_t *p,
 {
     char *modver = ssl_var_lookup(p, s, NULL, NULL, "SSL_VERSION_INTERFACE");
     char *libver = ssl_var_lookup(p, s, NULL, NULL, "SSL_VERSION_LIBRARY");
-    char *incver = ssl_var_lookup(p, s, NULL, NULL, 
+    char *incver = ssl_var_lookup(p, s, NULL, NULL,
                                   "SSL_VERSION_LIBRARY_INTERFACE");
 
     ap_add_version_component(p, modver);
@@ -401,8 +401,8 @@ void ssl_init_Engine(server_rec *s, apr_pool_t *p)
             ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
             ssl_die();
         }
-        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, 
-                     "Init: loaded Crypto Device API `%s'", 
+        ap_log_error(APLOG_MARK, APLOG_INFO, 0, s,
+                     "Init: loaded Crypto Device API `%s'",
                      mc->szCryptoDevice);
 
         ENGINE_free(e);
@@ -901,7 +901,7 @@ static int ssl_server_import_cert(server_rec *s,
         ssl_log_ssl_error(SSLLOG_MARK, APLOG_EMERG, s);
         ssl_die();
     }
-  
+
 #ifdef HAVE_OCSP_STAPLING
     if ((mctx->pkp == FALSE) && (mctx->stapling_enabled == TRUE)) {
         if (!ssl_stapling_init_cert(s, mctx, cert)) {
@@ -1338,11 +1338,11 @@ void ssl_init_CheckServers(server_rec *base_server, apr_pool_t *p)
         klen = strlen(key);
 
         if ((ps = (server_rec *)apr_hash_get(table, key, klen))) {
-            ap_log_error(APLOG_MARK, 
+            ap_log_error(APLOG_MARK,
 #ifdef OPENSSL_NO_TLSEXT
-                         APLOG_WARNING, 
+                         APLOG_WARNING,
 #else
-                         APLOG_DEBUG, 
+                         APLOG_DEBUG,
 #endif
                          0,
                          base_server,
@@ -1378,7 +1378,7 @@ void ssl_init_CheckServers(server_rec *base_server, apr_pool_t *p)
     }
 }
 
-static int ssl_init_FindCAList_X509NameCmp(const X509_NAME * const *a, 
+static int ssl_init_FindCAList_X509NameCmp(const X509_NAME * const *a,
                                            const X509_NAME * const *b)
 {
     return(X509_NAME_cmp(*a, *b));
diff --git a/modules/ssl/ssl_engine_io.c b/modules/ssl/ssl_engine_io.c
index a0fd808..084e486 100644
--- a/modules/ssl/ssl_engine_io.c
+++ b/modules/ssl/ssl_engine_io.c
@@ -147,7 +147,7 @@ static int bio_filter_out_flush(BIO *bio)
     apr_bucket *e;
 
     AP_DEBUG_ASSERT(APR_BRIGADE_EMPTY(outctx->bb));
-    
+
     e = apr_bucket_flush_create(outctx->bb->bucket_alloc);
     APR_BRIGADE_INSERT_TAIL(outctx->bb, e);
 
@@ -192,7 +192,7 @@ static int bio_filter_out_write(BIO *bio, const char *in, int inl)
         outctx->rc = APR_ECONNABORTED;
         return -1;
     }
-    
+
     /* when handshaking we'll have a small number of bytes.
      * max size SSL will pass us here is about 16k.
      * (16413 bytes to be exact)
@@ -203,7 +203,7 @@ static int bio_filter_out_write(BIO *bio, const char *in, int inl)
      * filter must setaside if necessary. */
     e = apr_bucket_transient_create(in, inl, outctx->bb->bucket_alloc);
     APR_BRIGADE_INSERT_TAIL(outctx->bb, e);
-    
+
     if (bio_filter_out_pass(outctx) < 0) {
         return -1;
     }
@@ -863,10 +863,10 @@ static apr_status_t ssl_io_filter_error(ap_filter_t *f,
             /* fake the request line */
             bucket = HTTP_ON_HTTPS_PORT_BUCKET(f->c->bucket_alloc);
             break;
-            
+
     case MODSSL_ERROR_BAD_GATEWAY:
         bucket = ap_bucket_error_create(HTTP_BAD_REQUEST, NULL,
-                                        f->c->pool, 
+                                        f->c->pool,
                                         f->c->bucket_alloc);
         ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c,
                       "SSL handshake failed: sending 502");
@@ -1292,8 +1292,8 @@ static apr_status_t ssl_io_filter_input(ap_filter_t *f,
         /* Satisfy the read directly out of the buffer if possible;
          * invoking ssl_io_input_getline will mean the entire buffer
          * is copied once (unnecessarily) for each GETLINE call. */
-        if (inctx->cbuf.length 
-            && (pos = memchr(inctx->cbuf.value, APR_ASCII_LF, 
+        if (inctx->cbuf.length
+            && (pos = memchr(inctx->cbuf.value, APR_ASCII_LF,
                              inctx->cbuf.length)) != NULL) {
             start = inctx->cbuf.value;
             len = 1 + pos - start; /* +1 to include LF */
@@ -1340,7 +1340,7 @@ static apr_status_t ssl_io_filter_input(ap_filter_t *f,
  * overhead (network packets) for any output comprising many small
  * buckets.  SSI page applied through the HTTP chunk filter, for
  * example, may produce many brigades containing small buckets -
- * [chunk-size CRLF] [chunk-data] [CRLF]. 
+ * [chunk-size CRLF] [chunk-data] [CRLF].
  *
  * The coalescing filter merges many small buckets into larger buckets
  * where possible, allowing the SSL I/O output filter to handle them
@@ -1363,7 +1363,7 @@ static apr_status_t ssl_io_filter_coalesce(ap_filter_t *f,
 
     /* The brigade consists of zero-or-more small data buckets which
      * can be coalesced (the prefix), followed by the remainder of the
-     * brigade.  
+     * brigade.
      *
      * Find the last bucket - if any - of that prefix.  count gives
      * the number of buckets in the prefix.  The "prefix" must contain
@@ -1389,9 +1389,9 @@ static apr_status_t ssl_io_filter_coalesce(ap_filter_t *f,
     }
 
     /* Coalesce the prefix, if:
-     * a) more than one bucket is found to coalesce, or 
+     * a) more than one bucket is found to coalesce, or
      * b) the brigade contains only a single data bucket, or
-     * c) 
+     * c)
      */
     if (bytes > 0
         && (count > 1
@@ -1411,7 +1411,7 @@ static apr_status_t ssl_io_filter_coalesce(ap_filter_t *f,
          * in this loop it is safe to break out and fall back to the
          * normal path of sending the buffer + remaining buckets in
          * brigade.  */
-        e = APR_BRIGADE_FIRST(bb); 
+        e = APR_BRIGADE_FIRST(bb);
         while (e != last) {
             apr_size_t len;
             const char *data;
@@ -1422,7 +1422,7 @@ static apr_status_t ssl_io_filter_coalesce(ap_filter_t *f,
                 ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c,
                               "unexpected bucket type during coalesce");
                 break; /* non-fatal error; break out */
-            }                
+            }
 
             if (e->length) {
                 apr_status_t rv;
@@ -1438,7 +1438,7 @@ static apr_status_t ssl_io_filter_coalesce(ap_filter_t *f,
                 }
 
                 /* Be paranoid. */
-                if (len > sizeof ctx->buffer 
+                if (len > sizeof ctx->buffer
                     || (len + ctx->bytes > sizeof ctx->buffer)) {
                     ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, f->c,
                                   "unexpected coalesced bucket data length");
@@ -1468,13 +1468,13 @@ static apr_status_t ssl_io_filter_coalesce(ap_filter_t *f,
 
         ap_log_cerror(APLOG_MARK, APLOG_TRACE4, 0, f->c,
                       "coalesce: passing on %" APR_SIZE_T_FMT " bytes", ctx->bytes);
-        
+
         e = apr_bucket_transient_create(ctx->buffer, ctx->bytes, bb->bucket_alloc);
         APR_BRIGADE_INSERT_HEAD(bb, e);
         ctx->bytes = 0; /* buffer now emptied. */
     }
-    
-    return ap_pass_brigade(f->next, bb);    
+
+    return ap_pass_brigade(f->next, bb);
 }
 
 static apr_status_t ssl_io_filter_output(ap_filter_t *f,
@@ -1666,7 +1666,7 @@ int ssl_io_buffer_fill(request_rec *r, apr_size_t maxlen)
         /* Fail if this exceeds the maximum buffer size. */
         if (total > maxlen) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
-                          "request body exceeds maximum size (%" APR_SIZE_T_FMT 
+                          "request body exceeds maximum size (%" APR_SIZE_T_FMT
                           ") for SSL buffer", maxlen);
             return HTTP_REQUEST_ENTITY_TOO_LARGE;
         }
@@ -1677,7 +1677,7 @@ int ssl_io_buffer_fill(request_rec *r, apr_size_t maxlen)
 
     /* After consuming all protocol-level input, remove all protocol-level
      * filters.  It should strictly only be necessary to remove filters
-     * at exactly ftype == AP_FTYPE_PROTOCOL, since this filter will 
+     * at exactly ftype == AP_FTYPE_PROTOCOL, since this filter will
      * precede all > AP_FTYPE_PROTOCOL anyway. */
     while (r->proto_input_filters->frec->ftype < AP_FTYPE_CONNECTION) {
         ap_remove_input_filter(r->proto_input_filters);
diff --git a/modules/ssl/ssl_engine_kernel.c b/modules/ssl/ssl_engine_kernel.c
index c88f694..a3379ad 100644
--- a/modules/ssl/ssl_engine_kernel.c
+++ b/modules/ssl/ssl_engine_kernel.c
@@ -48,7 +48,7 @@ static apr_status_t upgrade_connection(request_rec *r)
     apr_status_t rv;
     SSL *ssl;
 
-    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, 
+    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                   "upgrading connection to TLS");
 
     bb = apr_brigade_create(r->pool, conn->bucket_alloc);
@@ -69,10 +69,10 @@ static apr_status_t upgrade_connection(request_rec *r)
     }
 
     ssl_init_ssl_connection(conn, r);
-    
+
     sslconn = myConnConfig(conn);
     ssl = sslconn->ssl;
-    
+
     /* Perform initial SSL handshake. */
     SSL_set_accept_state(ssl);
     SSL_do_handshake(ssl);
@@ -80,7 +80,7 @@ static apr_status_t upgrade_connection(request_rec *r)
     if (SSL_get_state(ssl) != SSL_ST_OK) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "TLS upgrade handshake failed: not accepted by client!?");
-        
+
         return APR_ECONNABORTED;
     }
 
@@ -90,23 +90,23 @@ static apr_status_t upgrade_connection(request_rec *r)
 /* Perform a speculative (and non-blocking) read from the connection
  * filters for the given request, to determine whether there is any
  * pending data to read.  Return non-zero if there is, else zero. */
-static int has_buffered_data(request_rec *r) 
+static int has_buffered_data(request_rec *r)
 {
     apr_bucket_brigade *bb;
     apr_off_t len;
     apr_status_t rv;
     int result;
-    
+
     bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
-    
+
     rv = ap_get_brigade(r->connection->input_filters, bb, AP_MODE_SPECULATIVE,
-                        APR_NONBLOCK_READ, 1); 
+                        APR_NONBLOCK_READ, 1);
     result = rv == APR_SUCCESS
         && apr_brigade_length(bb, 1, &len) == APR_SUCCESS
         && len > 0;
-    
+
     apr_brigade_destroy(bb);
-    
+
     return result;
 }
 
@@ -122,7 +122,7 @@ int ssl_hook_ReadReq(request_rec *r)
     const char *servername;
 #endif
     SSL *ssl;
-    
+
     /* Perform TLS upgrade here if "SSLEngine optional" is configured,
      * SSL is not already set up for this connection, and the client
      * has sent a suitable Upgrade header. */
@@ -768,7 +768,7 @@ int ssl_hook_Access(request_rec *r)
                           "Performing full renegotiation: complete handshake "
                           "protocol (%s support secure renegotiation)",
 #if defined(SSL_get_secure_renegotiation_support)
-                          SSL_get_secure_renegotiation_support(ssl) ? 
+                          SSL_get_secure_renegotiation_support(ssl) ?
                           "client does" : "client does not"
 #else
                           "server does not"
@@ -782,7 +782,7 @@ int ssl_hook_Access(request_rec *r)
             /* Toggle the renegotiation state to allow the new
              * handshake to proceed. */
             sslconn->reneg_state = RENEG_ALLOW;
-            
+
             SSL_renegotiate(ssl);
             SSL_do_handshake(ssl);
 
@@ -1190,7 +1190,7 @@ int ssl_hook_Fixup(request_rec *r)
 
 
 #ifdef SSL_get_secure_renegotiation_support
-    apr_table_setn(r->notes, "ssl-secure-reneg", 
+    apr_table_setn(r->notes, "ssl-secure-reneg",
                    SSL_get_secure_renegotiation_support(ssl) ? "1" : "0");
 #endif
 
@@ -1391,12 +1391,12 @@ EC_KEY *ssl_callback_TmpECDH(SSL *ssl, int export, int keylen)
         ecdh = EC_KEY_new();
         if (ecdh != NULL) {
             /* ecdh->group = EC_GROUP_new_by_nid(NID_secp160r2); */
-            EC_KEY_set_group(ecdh, 
+            EC_KEY_set_group(ecdh,
               EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1));
         }
         init = 1;
     }
-    
+
     return ecdh;
 }
 #endif
@@ -1819,7 +1819,7 @@ void ssl_callback_DelSessionCacheEntry(SSL_CTX *ctx,
 }
 
 /* Dump debugginfo trace to the log file. */
-static void log_tracing_state(const SSL *ssl, conn_rec *c, 
+static void log_tracing_state(const SSL *ssl, conn_rec *c,
                               server_rec *s, int where, int rc)
 {
     /*
@@ -1912,8 +1912,8 @@ void ssl_callback_Info(const SSL *ssl, int where, int rc)
      * read. */
     if ((where & SSL_CB_ACCEPT_LOOP) && scr->reneg_state == RENEG_REJECT) {
         int state = SSL_get_state((SSL *)ssl);
-        
-        if (state == SSL3_ST_SR_CLNT_HELLO_A 
+
+        if (state == SSL3_ST_SR_CLNT_HELLO_A
             || state == SSL23_ST_SR_CLNT_HELLO_A) {
             scr->reneg_state = RENEG_ABORT;
             ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
@@ -1970,7 +1970,7 @@ int ssl_callback_ServerNameIndication(SSL *ssl, int *al, modssl_ctx_t *mctx)
  * or one of the ServerAliases matches the supplied name (to be used
  * with ap_vhost_iterate_given_conn())
  */
-static int ssl_find_vhost(void *servername, conn_rec *c, server_rec *s) 
+static int ssl_find_vhost(void *servername, conn_rec *c, server_rec *s)
 {
     SSLSrvConfigRec *sc;
     SSL *ssl;
@@ -1984,7 +1984,7 @@ static int ssl_find_vhost(void *servername, conn_rec *c, server_rec *s)
         found = TRUE;
     }
 
-    /* 
+    /*
      * if not matched yet, check ServerAlias entries
      * (adapted from vhost.c:matches_aliases())
      */
diff --git a/modules/ssl/ssl_engine_log.c b/modules/ssl/ssl_engine_log.c
index 03cb1c8..31861ca 100644
--- a/modules/ssl/ssl_engine_log.c
+++ b/modules/ssl/ssl_engine_log.c
@@ -96,9 +96,9 @@ void ssl_log_ssl_error(const char *file, int line, int level, server_rec *s)
         ap_log_error(file, line, APLOG_MODULE_INDEX, level, 0, s,
                      "SSL Library Error: %s%s%s%s%s%s",
                      /* %s */
-                     err, 
+                     err,
                      /* %s%s%s */
-                     data ? " (" : "", data ? data : "", data ? ")" : "", 
+                     data ? " (" : "", data ? data : "", data ? ")" : "",
                      /* %s%s */
                      annotation ? " -- " : "",
                      annotation ? annotation : "");
@@ -108,7 +108,7 @@ void ssl_log_ssl_error(const char *file, int line, int level, server_rec *s)
     }
 }
 
-static void ssl_log_cert_error(const char *file, int line, int level, 
+static void ssl_log_cert_error(const char *file, int line, int level,
                                apr_status_t rv, const server_rec *s,
                                const conn_rec *c, const request_rec *r,
                                apr_pool_t *p, X509 *cert, const char *format,
@@ -117,7 +117,7 @@ static void ssl_log_cert_error(const char *file, int line, int level,
     char buf[HUGE_STRING_LEN];
     int msglen, n;
     char *name;
-    
+
     apr_vsnprintf(buf, sizeof buf, format, ap);
 
     msglen = strlen(buf);
diff --git a/modules/ssl/ssl_engine_ocsp.c b/modules/ssl/ssl_engine_ocsp.c
index df77cce..2396a35 100644
--- a/modules/ssl/ssl_engine_ocsp.c
+++ b/modules/ssl/ssl_engine_ocsp.c
@@ -34,7 +34,7 @@ static const char *extract_responder_uri(X509 *cert, apr_pool_t *pool)
 
     for (j = 0; j < sk_ACCESS_DESCRIPTION_num(values) && !result; j++) {
         ACCESS_DESCRIPTION *value = sk_ACCESS_DESCRIPTION_value(values, j);
-        
+
         /* Name found in extension, and is a URI: */
         if (OBJ_obj2nid(value->method) == NID_ad_OCSP
             && value->location->type == GEN_URI) {
@@ -42,7 +42,7 @@ static const char *extract_responder_uri(X509 *cert, apr_pool_t *pool)
                                  (char *)value->location->d.uniformResourceIdentifier->data);
         }
     }
-    
+
     AUTHORITY_INFO_ACCESS_free(values);
 
     return result;
@@ -51,7 +51,7 @@ static const char *extract_responder_uri(X509 *cert, apr_pool_t *pool)
 /* Return the responder URI object which should be used in the given
  * configuration for the given certificate, or NULL if none can be
  * determined. */
-static apr_uri_t *determine_responder_uri(SSLSrvConfigRec *sc, X509 *cert, 
+static apr_uri_t *determine_responder_uri(SSLSrvConfigRec *sc, X509 *cert,
                                           conn_rec *c, apr_pool_t *p)
 {
     apr_uri_t *u = apr_palloc(p, sizeof *u);
@@ -65,7 +65,7 @@ static apr_uri_t *determine_responder_uri(SSLSrvConfigRec *sc, X509 *cert,
         s = sc->server->ocsp_responder;
     }
     else {
-        s = extract_responder_uri(cert, p); 
+        s = extract_responder_uri(cert, p);
 
         if (s == NULL && sc->server->ocsp_responder) {
             s = sc->server->ocsp_responder;
@@ -80,14 +80,14 @@ static apr_uri_t *determine_responder_uri(SSLSrvConfigRec *sc, X509 *cert,
     }
 
     rv = apr_uri_parse(p, s, u);
-    if (rv || !u->hostname) {    
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, 
+    if (rv || !u->hostname) {
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c,
                       "failed to parse OCSP responder URI '%s'", s);
         return NULL;
     }
 
     if (strcasecmp(u->scheme, "http") != 0) {
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, 
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c,
                       "cannot handle OCSP responder URI '%s'", s);
         return NULL;
     }
@@ -102,8 +102,8 @@ static apr_uri_t *determine_responder_uri(SSLSrvConfigRec *sc, X509 *cert,
 /* Create an OCSP request for the given certificate; returning the
  * certificate ID in *certid and *issuer on success.  Returns the
  * request object on success, or NULL on error. */
-static OCSP_REQUEST *create_request(X509_STORE_CTX *ctx, X509 *cert, 
-                                    OCSP_CERTID **certid, 
+static OCSP_REQUEST *create_request(X509_STORE_CTX *ctx, X509 *cert,
+                                    OCSP_CERTID **certid,
                                     server_rec *s, apr_pool_t *p)
 {
     OCSP_REQUEST *req = OCSP_REQUEST_new();
@@ -115,17 +115,17 @@ static OCSP_REQUEST *create_request(X509_STORE_CTX *ctx, X509 *cert,
                      "could not retrieve certificate id");
         return NULL;
     }
-    
+
     OCSP_request_add1_nonce(req, 0, -1);
-    
+
     return req;
 }
-        
+
 /* Verify the OCSP status of given certificate.  Returns
  * V_OCSP_CERTSTATUS_* result code. */
-static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c, 
+static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
                               SSLSrvConfigRec *sc, server_rec *s,
-                              apr_pool_t *pool) 
+                              apr_pool_t *pool)
 {
     int rc = V_OCSP_CERTSTATUS_GOOD;
     OCSP_RESPONSE *response = NULL;
@@ -133,7 +133,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
     OCSP_REQUEST *request = NULL;
     OCSP_CERTID *certID = NULL;
     apr_uri_t *ruri;
-   
+
     ruri = determine_responder_uri(sc, cert, c, pool);
     if (!ruri) {
         return V_OCSP_CERTSTATUS_UNKNOWN;
@@ -150,7 +150,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
     if (!request || !response) {
         rc = V_OCSP_CERTSTATUS_UNKNOWN;
     }
-    
+
     if (rc == V_OCSP_CERTSTATUS_GOOD) {
         int r = OCSP_response_status(response);
 
@@ -160,7 +160,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
             rc = V_OCSP_CERTSTATUS_UNKNOWN;
         }
     }
-    
+
     if (rc == V_OCSP_CERTSTATUS_GOOD) {
         basicResponse = OCSP_response_get1_basic(response);
         if (!basicResponse) {
@@ -170,7 +170,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
             rc = V_OCSP_CERTSTATUS_UNKNOWN;
         }
     }
-    
+
     if (rc == V_OCSP_CERTSTATUS_GOOD) {
         if (OCSP_check_nonce(request, basicResponse) != 1) {
             ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
@@ -178,7 +178,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
             rc = V_OCSP_CERTSTATUS_UNKNOWN;
         }
     }
-    
+
     if (rc == V_OCSP_CERTSTATUS_GOOD) {
         /* TODO: allow flags configuration. */
         if (OCSP_basic_verify(basicResponse, NULL, ctx->ctx, 0) != 1) {
@@ -188,7 +188,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
             rc = V_OCSP_CERTSTATUS_UNKNOWN;
         }
     }
-    
+
     if (rc == V_OCSP_CERTSTATUS_GOOD) {
         int reason = -1, status;
         ASN1_GENERALIZEDTIME *thisup = NULL, *nextup = NULL;
@@ -224,10 +224,10 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
         }
 
         {
-            int level = 
+            int level =
                 (status == V_OCSP_CERTSTATUS_GOOD) ? APLOG_INFO : APLOG_ERR;
-            const char *result = 
-                status == V_OCSP_CERTSTATUS_GOOD ? "good" : 
+            const char *result =
+                status == V_OCSP_CERTSTATUS_GOOD ? "good" :
                 (status == V_OCSP_CERTSTATUS_REVOKED ? "revoked" : "unknown");
 
             ssl_log_cxerror(SSLLOG_MARK, level, 0, c, cert,
@@ -236,7 +236,7 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
                             result, status, reason);
         }
     }
-    
+
     if (request) OCSP_REQUEST_free(request);
     if (response) OCSP_RESPONSE_free(response);
     if (basicResponse) OCSP_BASICRESP_free(basicResponse);
@@ -245,8 +245,8 @@ static int verify_ocsp_status(X509 *cert, X509_STORE_CTX *ctx, conn_rec *c,
     return rc;
 }
 
-int modssl_verify_ocsp(X509_STORE_CTX *ctx, SSLSrvConfigRec *sc, 
-                       server_rec *s, conn_rec *c, apr_pool_t *pool) 
+int modssl_verify_ocsp(X509_STORE_CTX *ctx, SSLSrvConfigRec *sc,
+                       server_rec *s, conn_rec *c, apr_pool_t *pool)
 {
     X509 *cert = X509_STORE_CTX_get_current_cert(ctx);
     apr_pool_t *vpool;
@@ -272,7 +272,7 @@ int modssl_verify_ocsp(X509_STORE_CTX *ctx, SSLSrvConfigRec *sc,
     apr_pool_create(&vpool, pool);
 
     rv = verify_ocsp_status(cert, ctx, c, sc, s, vpool);
-    
+
     apr_pool_destroy(vpool);
 
     /* Propagate the verification status back to the passed-in
@@ -281,11 +281,11 @@ int modssl_verify_ocsp(X509_STORE_CTX *ctx, SSLSrvConfigRec *sc,
     case V_OCSP_CERTSTATUS_GOOD:
         X509_STORE_CTX_set_error(ctx, X509_V_OK);
         break;
-        
+
     case V_OCSP_CERTSTATUS_REVOKED:
         X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);
         break;
-        
+
     case V_OCSP_CERTSTATUS_UNKNOWN:
         /* correct error code for application errors? */
         X509_STORE_CTX_set_error(ctx, X509_V_ERR_APPLICATION_VERIFICATION);
@@ -293,5 +293,5 @@ int modssl_verify_ocsp(X509_STORE_CTX *ctx, SSLSrvConfigRec *sc,
     }
 
     return rv == V_OCSP_CERTSTATUS_GOOD;
-} 
+}
 #endif /* HAVE_OCSP */
diff --git a/modules/ssl/ssl_engine_pphrase.c b/modules/ssl/ssl_engine_pphrase.c
index 0a60f66..ca26e24 100644
--- a/modules/ssl/ssl_engine_pphrase.c
+++ b/modules/ssl/ssl_engine_pphrase.c
@@ -354,7 +354,7 @@ void ssl_pphrase_Handle(server_rec *s, apr_pool_t *p)
                 if (pkey_mtime) {
                     ssl_asn1_t *asn1 =
                         ssl_asn1_table_get(mc->tPrivateKey, key_id);
-                    
+
                     if (asn1 && (asn1->source_mtime == pkey_mtime)) {
                         ap_log_error(APLOG_MARK, APLOG_INFO,
                                      0, pServ,
diff --git a/modules/ssl/ssl_engine_vars.c b/modules/ssl/ssl_engine_vars.c
index 29ceccf..f94c706 100644
--- a/modules/ssl/ssl_engine_vars.c
+++ b/modules/ssl/ssl_engine_vars.c
@@ -112,7 +112,7 @@ void ssl_var_register(apr_pool_t *p)
 
     /* Perform once-per-process library version determination: */
     var_library = apr_pstrdup(p, SSL_LIBRARY_DYNTEXT);
-    
+
     if ((cp = strchr(var_library, ' ')) != NULL) {
         *cp = '/';
         if ((cp2 = strchr(cp, ' ')) != NULL)
@@ -342,7 +342,7 @@ static char *ssl_var_lookup_ssl(apr_pool_t *p, conn_rec *c, request_rec *r,
         }
     }
     else if(ssl != NULL && strcEQ(var, "SESSION_RESUMED")) {
-        if (SSL_session_reused(ssl) == 1) 
+        if (SSL_session_reused(ssl) == 1)
             result = "Resumed";
         else
             result = "Initial";
@@ -386,7 +386,7 @@ static char *ssl_var_lookup_ssl(apr_pool_t *p, conn_rec *c, request_rec *r,
         flag = SSL_get_secure_renegotiation_support(ssl);
 #endif
         result = apr_pstrdup(p, flag ? "true" : "false");
-    }                             
+    }
 
     return result;
 }
@@ -769,10 +769,10 @@ static char *ssl_var_lookup_ssl_version(apr_pool_t *p, char *var)
     }
     return NULL;
 }
-  
+
 /* Add each RDN in 'xn' to the table 't' where the NID is present in
  * 'nids', using key prefix 'pfx'.  */
-static void extract_dn(apr_table_t *t, apr_hash_t *nids, const char *pfx, 
+static void extract_dn(apr_table_t *t, apr_hash_t *nids, const char *pfx,
                        X509_NAME *xn, apr_pool_t *p)
 {
     STACK_OF(X509_NAME_ENTRY) *ents = xn->entries;
@@ -834,7 +834,7 @@ void modssl_var_extract_dns(apr_table_t *t, SSL *ssl, apr_pool_t *p)
                          ssl_var_lookup_ssl_cert_dn_rec[n].name);
         }
     }
-    
+
     /* Extract the server cert DNS -- note that the refcount does NOT
      * increase: */
     xs = SSL_get_certificate(ssl);
@@ -842,7 +842,7 @@ void modssl_var_extract_dns(apr_table_t *t, SSL *ssl, apr_pool_t *p)
         extract_dn(t, nids, "SSL_SERVER_S_DN_", X509_get_subject_name(xs), p);
         extract_dn(t, nids, "SSL_SERVER_I_DN_", X509_get_issuer_name(xs), p);
     }
-    
+
     /* Extract the client cert DNs -- note that the refcount DOES
      * increase: */
     xs = SSL_get_peer_certificate(ssl);
@@ -862,7 +862,7 @@ static int dump_extn_value(BIO *bio, ASN1_OCTET_STRING *str)
     MODSSL_D2I_ASN1_type_bytes_CONST unsigned char *pp = str->data;
     ASN1_STRING *ret = ASN1_STRING_new();
     int rv = 0;
-    
+
     /* This allows UTF8String, IA5String, VisibleString, or BMPString;
      * conversion to UTF-8 is forced. */
     if (d2i_DISPLAYTEXT(&ret, &pp, str->length)) {
diff --git a/modules/ssl/ssl_scache.c b/modules/ssl/ssl_scache.c
index 2b51631..e75c4c6 100644
--- a/modules/ssl/ssl_scache.c
+++ b/modules/ssl/ssl_scache.c
@@ -42,7 +42,7 @@ void ssl_scache_init(server_rec *s, apr_pool_t *p)
     SSLModConfigRec *mc = myModConfig(s);
     apr_status_t rv;
     struct ap_socache_hints hints;
-    
+
     /* The very first invocation of this function will be the
      * post_config invocation during server startup; do nothing for
      * this first (and only the first) time through, since the pool
@@ -57,7 +57,7 @@ void ssl_scache_init(server_rec *s, apr_pool_t *p)
         hints.avg_obj_size = 1500;
         hints.avg_id_len = 20;
         hints.expiry_interval = 300;
-    
+
         rv = mc->stapling_cache->init(mc->stapling_cache_context,
                                      "mod_ssl-stapling", &hints, s, p);
         if (rv) {
@@ -83,7 +83,7 @@ void ssl_scache_init(server_rec *s, apr_pool_t *p)
     hints.avg_obj_size = 150;
     hints.avg_id_len = 30;
     hints.expiry_interval = 30;
-    
+
     rv = mc->sesscache->init(mc->sesscache_context, "mod_ssl-session", &hints, s, p);
     if (rv) {
         ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
@@ -95,7 +95,7 @@ void ssl_scache_init(server_rec *s, apr_pool_t *p)
 void ssl_scache_kill(server_rec *s)
 {
     SSLModConfigRec *mc = myModConfig(s);
-    
+
     if (mc->sesscache) {
         mc->sesscache->destroy(mc->sesscache_context, s);
     }
@@ -131,8 +131,8 @@ BOOL ssl_scache_store(server_rec *s, UCHAR *id, int idlen,
     if (mc->sesscache->flags & AP_SOCACHE_FLAG_NOTMPSAFE) {
         ssl_mutex_on(s);
     }
-    
-    rv = mc->sesscache->store(mc->sesscache_context, s, id, idlen, 
+
+    rv = mc->sesscache->store(mc->sesscache_context, s, id, idlen,
                               expiry, encoded, len, p);
 
     if (mc->sesscache->flags & AP_SOCACHE_FLAG_NOTMPSAFE) {
@@ -155,7 +155,7 @@ SSL_SESSION *ssl_scache_retrieve(server_rec *s, UCHAR *id, int idlen,
         ssl_mutex_on(s);
     }
 
-    rv = mc->sesscache->retrieve(mc->sesscache_context, s, id, idlen, 
+    rv = mc->sesscache->retrieve(mc->sesscache_context, s, id, idlen,
                                  dest, &destlen, p);
 
     if (mc->sesscache->flags & AP_SOCACHE_FLAG_NOTMPSAFE) {
diff --git a/modules/ssl/ssl_util.c b/modules/ssl/ssl_util.c
index 091a68f..e8a08cf 100644
--- a/modules/ssl/ssl_util.c
+++ b/modules/ssl/ssl_util.c
@@ -154,7 +154,7 @@ ssl_algo_t ssl_util_algotypeof(X509 *pCert, EVP_PKEY *pKey)
             case EVP_PKEY_EC:
                 t = SSL_ALGO_ECC;
                 break;
-#endif 
+#endif
             default:
                 break;
         }
@@ -351,7 +351,7 @@ static void ssl_util_thr_lock(int mode, int type,
 /* Dynamic lock structure */
 struct CRYPTO_dynlock_value {
     apr_pool_t *pool;
-    const char* file; 
+    const char* file;
     int line;
     apr_thread_mutex_t *mutex;
 };
@@ -362,17 +362,17 @@ apr_pool_t *dynlockpool = NULL;
 /*
  * Dynamic lock creation callback
  */
-static struct CRYPTO_dynlock_value *ssl_dyn_create_function(const char *file, 
+static struct CRYPTO_dynlock_value *ssl_dyn_create_function(const char *file,
                                                      int line)
 {
     struct CRYPTO_dynlock_value *value;
     apr_pool_t *p;
     apr_status_t rv;
 
-    /* 
+    /*
      * We need a pool to allocate our mutex.  Since we can't clear
      * allocated memory from a pool, create a subpool that we can blow
-     * away in the destruction callback. 
+     * away in the destruction callback.
      */
     rv = apr_pool_create(&p, dynlockpool);
     if (rv != APR_SUCCESS) {
@@ -383,21 +383,21 @@ static struct CRYPTO_dynlock_value *ssl_dyn_create_function(const char *file,
 
     ap_log_perror(file, line, APLOG_MODULE_INDEX, APLOG_DEBUG, 0, p,
                   "Creating dynamic lock");
-    
-    value = (struct CRYPTO_dynlock_value *)apr_palloc(p, 
+
+    value = (struct CRYPTO_dynlock_value *)apr_palloc(p,
                                                       sizeof(struct CRYPTO_dynlock_value));
     if (!value) {
         ap_log_perror(file, line, APLOG_MODULE_INDEX, APLOG_ERR, 0, p,
                       "Failed to allocate dynamic lock structure");
         return NULL;
     }
-    
+
     value->pool = p;
     /* Keep our own copy of the place from which we were created,
        using our own pool. */
     value->file = apr_pstrdup(p, file);
     value->line = line;
-    rv = apr_thread_mutex_create(&(value->mutex), APR_THREAD_MUTEX_DEFAULT, 
+    rv = apr_thread_mutex_create(&(value->mutex), APR_THREAD_MUTEX_DEFAULT,
                                 p);
     if (rv != APR_SUCCESS) {
         ap_log_perror(file, line, APLOG_MODULE_INDEX, APLOG_ERR, rv, p,
@@ -436,7 +436,7 @@ static void ssl_dyn_lock_function(int mode, struct CRYPTO_dynlock_value *l,
 /*
  * Dynamic lock destruction callback
  */
-static void ssl_dyn_destroy_function(struct CRYPTO_dynlock_value *l, 
+static void ssl_dyn_destroy_function(struct CRYPTO_dynlock_value *l,
                           const char *file, int line)
 {
     apr_status_t rv;
@@ -446,7 +446,7 @@ static void ssl_dyn_destroy_function(struct CRYPTO_dynlock_value *l,
     rv = apr_thread_mutex_destroy(l->mutex);
     if (rv != APR_SUCCESS) {
         ap_log_perror(file, line, APLOG_MODULE_INDEX, APLOG_ERR, rv, l->pool,
-                      "Failed to destroy mutex for dynamic lock %s:%d", 
+                      "Failed to destroy mutex for dynamic lock %s:%d",
                       l->file, l->line);
     }
 
@@ -478,11 +478,11 @@ static apr_status_t ssl_util_thread_cleanup(void *data)
 {
     CRYPTO_set_locking_callback(NULL);
     CRYPTO_set_id_callback(NULL);
-    
+
     CRYPTO_set_dynlock_create_callback(NULL);
     CRYPTO_set_dynlock_lock_callback(NULL);
     CRYPTO_set_dynlock_destroy_callback(NULL);
-    
+
     dynlockpool = NULL;
 
     /* Let the registered mutex cleanups do their own thing
@@ -504,9 +504,9 @@ void ssl_util_thread_setup(apr_pool_t *p)
     CRYPTO_set_id_callback(ssl_util_thr_id);
 
     CRYPTO_set_locking_callback(ssl_util_thr_lock);
-    
+
     /* Set up dynamic locking scaffolding for OpenSSL to use at its
-     * convenience. 
+     * convenience.
      */
     dynlockpool = p;
     CRYPTO_set_dynlock_create_callback(ssl_dyn_create_function);
diff --git a/modules/ssl/ssl_util_ocsp.c b/modules/ssl/ssl_util_ocsp.c
index 5fb8e24..06ff993 100644
--- a/modules/ssl/ssl_util_ocsp.c
+++ b/modules/ssl/ssl_util_ocsp.c
@@ -40,7 +40,7 @@ static BIO *serialize_request(OCSP_REQUEST *req, const apr_uri_t *uri)
                "Host: %s:%d\r\n"
                "Content-Type: application/ocsp-request\r\n"
                "Content-Length: %d\r\n"
-               "\r\n", 
+               "\r\n",
                uri->path ? uri->path : "/",
                uri->query ? "?" : "", uri->query ? uri->query : "",
                uri->hostname, uri->port, len);
@@ -56,7 +56,7 @@ static BIO *serialize_request(OCSP_REQUEST *req, const apr_uri_t *uri)
 /* Send the OCSP request serialized into BIO 'request' to the
  * responder at given server given by URI.  Returns socket object or
  * NULL on error. */
-static apr_socket_t *send_request(BIO *request, const apr_uri_t *uri, 
+static apr_socket_t *send_request(BIO *request, const apr_uri_t *uri,
                                   apr_interval_time_t timeout,
                                   conn_rec *c, apr_pool_t *p)
 {
@@ -69,13 +69,13 @@ static apr_socket_t *send_request(BIO *request, const apr_uri_t *uri,
     rv = apr_sockaddr_info_get(&sa, uri->hostname, APR_UNSPEC, uri->port, 0, p);
     if (rv) {
         ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c,
-                      "could not resolve address of OCSP responder %s", 
+                      "could not resolve address of OCSP responder %s",
                       uri->hostinfo);
         return NULL;
     }
-    
-    /* establish a connection to the OCSP responder */ 
-    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, 
+
+    /* establish a connection to the OCSP responder */
+    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
                   "connecting to OCSP responder '%s'", uri->hostinfo);
 
     /* Cycle through address until a connect() succeeds. */
@@ -100,14 +100,14 @@ static apr_socket_t *send_request(BIO *request, const apr_uri_t *uri,
         return NULL;
     }
 
-    /* send the request and get a response */ 
-    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, 
+    /* send the request and get a response */
+    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
                  "sending request to OCSP responder");
 
     while ((len = BIO_read(request, buf, sizeof buf)) > 0) {
         char *wbuf = buf;
         apr_size_t remain = len;
-        
+
         do {
             apr_size_t wlen = remain;
 
@@ -145,7 +145,7 @@ static char *get_line(apr_bucket_brigade *bbout, apr_bucket_brigade *bbin,
                       "failed reading line from OCSP server");
         return NULL;
     }
-    
+
     rv = apr_brigade_pflatten(bbout, &line, &len, p);
     if (rv) {
         ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c,
@@ -248,7 +248,7 @@ static OCSP_RESPONSE *read_response(apr_socket_t *sd, BIO *bio, conn_rec *c,
             return NULL;
         }
         ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c,
-                      "OCSP response: got %" APR_SIZE_T_FMT 
+                      "OCSP response: got %" APR_SIZE_T_FMT
                       " bytes, %" APR_SIZE_T_FMT " total", len, count);
 
         BIO_write(bio, data, (int)len);
@@ -273,7 +273,7 @@ static OCSP_RESPONSE *read_response(apr_socket_t *sd, BIO *bio, conn_rec *c,
 OCSP_RESPONSE *modssl_dispatch_ocsp_request(const apr_uri_t *uri,
                                             apr_interval_time_t timeout,
                                             OCSP_REQUEST *request,
-                                            conn_rec *c, apr_pool_t *p) 
+                                            conn_rec *c, apr_pool_t *p)
 {
     OCSP_RESPONSE *response = NULL;
     apr_socket_t *sd;
@@ -286,7 +286,7 @@ OCSP_RESPONSE *modssl_dispatch_ocsp_request(const apr_uri_t *uri,
                       "could not serialize OCSP request");
         return NULL;
     }
-    
+
     sd = send_request(bio, uri, timeout, c, p);
     if (sd == NULL) {
         /* Errors already logged. */
diff --git a/modules/ssl/ssl_util_ssl.c b/modules/ssl/ssl_util_ssl.c
index 50d117d..ee46fd8 100644
--- a/modules/ssl/ssl_util_ssl.c
+++ b/modules/ssl/ssl_util_ssl.c
@@ -297,7 +297,7 @@ char *SSL_X509_NAME_ENTRY_to_string(apr_pool_t *p, X509_NAME_ENTRY *xsne)
     return result;
 }
 
-/* 
+/*
  * convert an X509_NAME to an RFC 2253 formatted string, optionally truncated
  * to maxlen characters (specify a maxlen of 0 for no length limit)
  */
diff --git a/modules/ssl/ssl_util_stapling.c b/modules/ssl/ssl_util_stapling.c
index afcf4ef..5ebd306 100644
--- a/modules/ssl/ssl_util_stapling.c
+++ b/modules/ssl/ssl_util_stapling.c
@@ -206,7 +206,7 @@ static BOOL stapling_cache_response(server_rec *s, modssl_ctx_t *mctx,
     if (ok == TRUE) {
         *p++ = 1;
         expiry = apr_time_from_sec(mctx->stapling_cache_timeout);
-    } 
+    }
     else {
         *p++ = 0;
         expiry = apr_time_from_sec(mctx->stapling_errcache_timeout);
@@ -322,7 +322,7 @@ static int stapling_check_response(server_rec *s, modssl_ctx_t *mctx,
         /* If ID not present just pass back to client */
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                      "stapling_check_response: certificate ID not present in response!");
-    } 
+    }
     else {
         if (OCSP_check_validity(thisupd, nextupd,
                                 mctx->stapling_resptime_skew,
@@ -338,7 +338,7 @@ static int stapling_check_response(server_rec *s, modssl_ctx_t *mctx,
             if (pok) {
                 ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                              "stapling_check_response: response times invalid");
-            } 
+            }
             else {
                 ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
                              "stapling_check_response: cached response expired");
@@ -406,7 +406,7 @@ static BOOL stapling_renew_response(server_rec *s, modssl_ctx_t *mctx, SSL *ssl,
                       ocspuri);
         rv = FALSE;
         goto done;
-    } 
+    }
     else if (strcmp(uri.scheme, "http")) {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                      "stapling_renew_response: Unsupported uri %s", ocspuri);
@@ -432,7 +432,7 @@ static BOOL stapling_renew_response(server_rec *s, modssl_ctx_t *mctx, SSL *ssl,
         else {
             goto done;
         }
-    } 
+    }
     else {
         int response_status = OCSP_response_status(*prsp);
 
@@ -444,7 +444,7 @@ static BOOL stapling_renew_response(server_rec *s, modssl_ctx_t *mctx, SSL *ssl,
                 ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                              "stapling_renew_response: error in retreived response!");
             }
-        } 
+        }
         else {
             ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
                          "stapling_renew_response: responder error %s",
diff --git a/modules/test/mod_dialup.c b/modules/test/mod_dialup.c
index eec35f4..1bcc3eb 100644
--- a/modules/test/mod_dialup.c
+++ b/modules/test/mod_dialup.c
@@ -49,14 +49,14 @@ dialup_send_pulse(dialup_baton_t *db)
     int status;
     apr_off_t len = 0;
     apr_size_t bytes_sent = 0;
-    
+
     while (!APR_BRIGADE_EMPTY(db->bb) && bytes_sent < db->bytes_per_second) {
         apr_bucket *e;
 
         if (db->r->connection->aborted) {
             return HTTP_INTERNAL_SERVER_ERROR;
         }
-        
+
         status = apr_brigade_partition(db->bb, db->bytes_per_second, &e);
 
         if (status != APR_SUCCESS && status != APR_INCOMPLETE) {
@@ -74,9 +74,9 @@ dialup_send_pulse(dialup_baton_t *db)
         else {
             APR_BRIGADE_CONCAT(db->tmpbb, db->bb);
         }
-        
+
         e = apr_bucket_flush_create(db->r->connection->bucket_alloc);
-        
+
         APR_BRIGADE_INSERT_TAIL(db->tmpbb, e);
 
         apr_brigade_length(db->tmpbb, 1, &len);
@@ -100,7 +100,7 @@ dialup_send_pulse(dialup_baton_t *db)
     }
 }
 
-static void 
+static void
 dialup_callback(void *baton)
 {
     int status;
@@ -142,8 +142,8 @@ dialup_handler(request_rec *r)
 
 
     /* See core.c, default handler for all of the cases we just decline. */
-    if (r->method_number != M_GET || 
-        r->finfo.filetype == APR_NOFILE || 
+    if (r->method_number != M_GET ||
+        r->finfo.filetype == APR_NOFILE ||
         r->finfo.filetype == APR_DIR) {
         return DECLINED;
     }
@@ -183,7 +183,7 @@ dialup_handler(request_rec *r)
     }
 
     db = apr_palloc(r->pool, sizeof(dialup_baton_t));
-    
+
     db->bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
     db->tmpbb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
 
@@ -194,8 +194,8 @@ dialup_handler(request_rec *r)
         apr_bucket_file_enable_mmap(e, 0);
     }
 #endif
-    
-    
+
+
     db->bytes_per_second = dcfg->bytes_per_second;
     db->r = r;
     db->fd = fd;
@@ -256,7 +256,7 @@ cmd_modem_standard(cmd_parms *cmd,
     const modem_speed_t *standard;
     int i = 0;
     dialup_dcfg_t *dcfg = (dialup_dcfg_t*)dconf;
-    
+
     dcfg->bytes_per_second = 0;
 
     while (modem_bitrates[i].name != NULL) {
@@ -279,7 +279,7 @@ static void *
 dialup_dcfg_create(apr_pool_t *p, char *dummy)
 {
     dialup_dcfg_t *cfg = apr_palloc(p, sizeof(dialup_dcfg_t));
-    
+
     cfg->bytes_per_second = 0;
 
     return cfg;
diff --git a/server/config.c b/server/config.c
index 0c8e04c..4a0fc1a 100644
--- a/server/config.c
+++ b/server/config.c
@@ -2083,7 +2083,7 @@ AP_CORE_DECLARE(int) ap_parse_htaccess(ap_conf_vector_t **result,
                 && !APR_STATUS_IS_ENOTDIR(status)) {
                 ap_log_rerror(APLOG_MARK, APLOG_CRIT, status, r,
                               "%s pcfg_openfile: unable to check htaccess file, "
-                              "ensure it is readable and that '%s' " 
+                              "ensure it is readable and that '%s' "
                               "is executable",
                               filename, d);
                 apr_table_setn(r->notes, "error-notes",
diff --git a/server/log.c b/server/log.c
index 88df8eb..dc3f700 100644
--- a/server/log.c
+++ b/server/log.c
@@ -173,9 +173,9 @@ typedef struct read_handle_t {
 static read_handle_t *read_handles;
 
 /**
- * @brief The piped logging structure.  
+ * @brief The piped logging structure.
  *
- * Piped logs are used to move functionality out of the main server.  
+ * Piped logs are used to move functionality out of the main server.
  * For example, log rotation is done with piped logs.
  */
 struct piped_log {
@@ -209,7 +209,7 @@ AP_DECLARE(apr_file_t *) ap_piped_log_write_fd(piped_log *pl)
  * take the parent process's child procs.
  * If the win32 parent instead passed each and every
  * logger write handle from itself down to the child,
- * and the parent manages all aspects of keeping the 
+ * and the parent manages all aspects of keeping the
  * reliable pipe log children alive, this would still
  * make no sense :)  Cripple it on Win32.
  */
@@ -266,18 +266,18 @@ AP_DECLARE(apr_status_t) ap_replace_stderr_log(apr_pool_t *p,
          */
         stderr_pool = p;
     }
-    if ((rc = apr_file_open_stderr(&stderr_log, stderr_pool)) 
+    if ((rc = apr_file_open_stderr(&stderr_log, stderr_pool))
             == APR_SUCCESS) {
         apr_file_flush(stderr_log);
-        if ((rc = apr_file_dup2(stderr_log, stderr_file, stderr_pool)) 
+        if ((rc = apr_file_dup2(stderr_log, stderr_file, stderr_pool))
                 == APR_SUCCESS) {
             apr_file_close(stderr_file);
             /*
              * You might ponder why stderr_pool should survive?
              * The trouble is, stderr_pool may have s_main->error_log,
              * so we aren't in a position to destory stderr_pool until
-             * the next recycle.  There's also an apparent bug which 
-             * is not; if some folk decided to call this function before 
+             * the next recycle.  There's also an apparent bug which
+             * is not; if some folk decided to call this function before
              * the core open error logs hook, this pool won't survive.
              * Neither does the stderr logger, so this isn't a problem.
              */
@@ -328,7 +328,7 @@ static int log_child(apr_pool_t *p, const char *progname,
                                       APR_NO_PIPE,
                                       APR_NO_PIPE)) == APR_SUCCESS)
         && ((rc = apr_procattr_error_check_set(procattr, 1)) == APR_SUCCESS)
-        && ((rc = apr_procattr_child_errfn_set(procattr, log_child_errfn)) 
+        && ((rc = apr_procattr_child_errfn_set(procattr, log_child_errfn))
                 == APR_SUCCESS)) {
         char **args;
         const char *pname;
@@ -371,7 +371,7 @@ static int open_error_log(server_rec *s, int is_main, apr_pool_t *p)
 
         /* In 2.4 favor PROGRAM_ENV, accept "||prog" syntax for compatibility
          * and "|$cmd" to override the default.
-         * Any 2.2 backport would continue to favor SHELLCMD_ENV so there 
+         * Any 2.2 backport would continue to favor SHELLCMD_ENV so there
          * accept "||prog" to override, and "|$cmd" to ease conversion.
          */
         if (*fname == '|')
@@ -450,17 +450,17 @@ int ap_open_logs(apr_pool_t *pconf, apr_pool_t *p /* plog */,
     /* Register to throw away the read_handles list when we
      * cleanup plog.  Upon fork() for the apache children,
      * this read_handles list is closed so only the parent
-     * can relaunch a lost log child.  These read handles 
+     * can relaunch a lost log child.  These read handles
      * are always closed on exec.
-     * We won't care what happens to our stderr log child 
-     * between log phases, so we don't mind losing stderr's 
+     * We won't care what happens to our stderr log child
+     * between log phases, so we don't mind losing stderr's
      * read_handle a little bit early.
      */
     apr_pool_cleanup_register(p, &read_handles, ap_pool_cleanup_set_null,
                               apr_pool_cleanup_null);
 
     /* HERE we need a stdout log that outlives plog.
-     * We *presume* the parent of plog is a process 
+     * We *presume* the parent of plog is a process
      * or global pool which spans server restarts.
      * Create our stderr_pool as a child of the plog's
      * parent pool.
@@ -1356,7 +1356,7 @@ AP_DECLARE(void) ap_log_command_line(apr_pool_t *plog, server_rec *s)
     process_rec *process = s->process;
     char *result;
     int len_needed = 0;
-    
+
     /* Piece together the command line from the pieces
      * in process->argv, with spaces in between.
      */
@@ -1721,7 +1721,7 @@ AP_DECLARE(piped_log *) ap_open_piped_log(apr_pool_t *p,
 
     /* In 2.4 favor PROGRAM_ENV, accept "||prog" syntax for compatibility
      * and "|$cmd" to override the default.
-     * Any 2.2 backport would continue to favor SHELLCMD_ENV so there 
+     * Any 2.2 backport would continue to favor SHELLCMD_ENV so there
      * accept "||prog" to override, and "|$cmd" to ease conversion.
      */
     if (*program == '|')
diff --git a/server/main.c b/server/main.c
index 2fdd4a1..fbc4c84 100644
--- a/server/main.c
+++ b/server/main.c
@@ -298,7 +298,7 @@ static process_rec *init_process(int *argc, const char * const * *argv)
         char ctimebuff[APR_CTIME_LEN];
         apr_ctime(ctimebuff, apr_time_now());
         fprintf(stderr, "[%s] [crit] (%d) %s: %s failed "
-                        "to initial context, exiting\n", 
+                        "to initial context, exiting\n",
                         ctimebuff, stat, (*argv)[0], failed);
         apr_terminate();
         exit(1);
diff --git a/server/mpm/event/event.c b/server/mpm/event/event.c
index 2e4ca38..0008477 100644
--- a/server/mpm/event/event.c
+++ b/server/mpm/event/event.c
@@ -1485,7 +1485,7 @@ static void * APR_THREAD_FUNC listener_thread(apr_thread_t * thd, void *dummy)
                                  "in this process");
                 }
                 else if (apr_atomic_read32(&connection_count) > threads_per_child
-                         + ap_queue_info_get_idlers(worker_queue_info) * 
+                         + ap_queue_info_get_idlers(worker_queue_info) *
                            worker_factor / WORKER_FACTOR_SCALE)
                 {
                     if (!listeners_disabled)
diff --git a/server/mpm/event/fdqueue.c b/server/mpm/event/fdqueue.c
index 9566df3..f7de0bf 100644
--- a/server/mpm/event/fdqueue.c
+++ b/server/mpm/event/fdqueue.c
@@ -397,21 +397,21 @@ apr_status_t ap_queue_push(fd_queue_t * queue, apr_socket_t * sd,
 apr_status_t ap_queue_push_timer(fd_queue_t * queue, timer_event_t *te)
 {
     apr_status_t rv;
-    
+
     if ((rv = apr_thread_mutex_lock(queue->one_big_mutex)) != APR_SUCCESS) {
         return rv;
     }
-    
+
     AP_DEBUG_ASSERT(!queue->terminated);
 
     APR_RING_INSERT_TAIL(&queue->timers, te, timer_event_t, link);
 
     apr_thread_cond_signal(queue->not_empty);
-    
+
     if ((rv = apr_thread_mutex_unlock(queue->one_big_mutex)) != APR_SUCCESS) {
         return rv;
     }
-    
+
     return APR_SUCCESS;
 }
 
@@ -472,7 +472,7 @@ apr_status_t ap_queue_pop_something(fd_queue_t * queue, apr_socket_t ** sd,
         elem->p = NULL;
 #endif /* AP_DEBUG */
     }
-    
+
     rv = apr_thread_mutex_unlock(queue->one_big_mutex);
     return rv;
 }
diff --git a/server/mpm/prefork/prefork.c b/server/mpm/prefork/prefork.c
index 9df7e0a..93dd65a 100644
--- a/server/mpm/prefork/prefork.c
+++ b/server/mpm/prefork/prefork.c
@@ -517,7 +517,7 @@ static void child_main(int child_num_arg)
     osthd = apr_os_thread_current();
     apr_os_thread_put(&thd, &osthd, pchild);
 #endif
-    
+
     apr_pool_create(&ptrans, pchild);
     apr_pool_tag(ptrans, "transaction");
 
@@ -625,7 +625,7 @@ static void child_main(int child_num_arg)
                 /* timeout == 10 seconds to avoid a hang at graceful restart/stop
                  * caused by the closing of sockets by the signal handler
                  */
-                status = apr_pollset_poll(pollset, apr_time_from_sec(10), 
+                status = apr_pollset_poll(pollset, apr_time_from_sec(10),
                                           &numdesc, &pdesc);
                 if (status != APR_SUCCESS) {
                     if (APR_STATUS_IS_TIMEUP(status) ||
diff --git a/server/mpm/simple/simple_children.c b/server/mpm/simple/simple_children.c
index a521564..0476f59 100644
--- a/server/mpm/simple/simple_children.c
+++ b/server/mpm/simple/simple_children.c
@@ -39,11 +39,11 @@ static void simple_kill_random_child(simple_core_t * sc)
         apr_thread_mutex_lock(sc->mtx);
         hi = apr_hash_first(sc->pool, sc->children);
         if (hi != NULL) {
-            apr_hash_this(hi, NULL, NULL, (void **)&child); 
+            apr_hash_this(hi, NULL, NULL, (void **)&child);
             apr_hash_set(sc->children, &child->pid, sizeof(child->pid), NULL);
         }
         apr_thread_mutex_unlock(sc->mtx);
-        
+
         if (child != NULL) {
             kill(child->pid, 9);
             /* TODO: recycle child object */
@@ -62,14 +62,14 @@ static int simple_spawn_child(simple_core_t * sc)
 {
     pid_t pid = 0;
     int rv = 0;
-    /* Although we could cut this off 'earlier', and not even invoke this 
+    /* Although we could cut this off 'earlier', and not even invoke this
      * function, I would like to keep the functions invoked when in debug mode
      * to be as close as possible to those when not in debug... So, we just skip
      * the actual spawn itself, but go through all of the motions...
      */
     if (!sc->run_single_process) {
         if (sc->spawn_via == SIMPLE_SPAWN_FORK) {
-            
+
             pid = fork();
             if (pid == -1) {
                 rv = errno;
@@ -77,10 +77,10 @@ static int simple_spawn_child(simple_core_t * sc)
                              "simple_spawn_child: Unable to fork new process");
                 return rv;
             }
-            
+
             if (pid == 0) {
                 /* this is the child process */
-                
+
                 rv = simple_child_loop(sc);
 
                 if (rv) {
@@ -108,7 +108,7 @@ static int simple_spawn_child(simple_core_t * sc)
 
         apr_thread_mutex_unlock(sc->mtx);
     }
-    
+
     return 0;
 }
 
@@ -125,7 +125,7 @@ void simple_check_children_size(simple_core_t * sc, void *baton)
 
     if (sc->run_single_process && sc->restart_num == 2) {
         static int run = 0;
-        /* This is kinda of hack, but rather than spawning a child process, 
+        /* This is kinda of hack, but rather than spawning a child process,
          * we register the normal IO handlers in the main event loop....
          */
         if (run == 0) {
diff --git a/server/mpm/simple/simple_core.c b/server/mpm/simple/simple_core.c
index 1315aa5..aa68211 100644
--- a/server/mpm/simple/simple_core.c
+++ b/server/mpm/simple/simple_core.c
@@ -43,7 +43,7 @@ apr_status_t simple_core_init_once(void)
     if (g_simple_core) {
         return APR_SUCCESS;
     }
-    
+
     sc = g_simple_core = ap_retained_data_create(userdata_key, sizeof(*g_simple_core));
 
     apr_pool_create(&sc->pool, ap_pglobal);
diff --git a/server/mpm/simple/simple_io.c b/server/mpm/simple/simple_io.c
index 4c25372..11f1a5b 100644
--- a/server/mpm/simple/simple_io.c
+++ b/server/mpm/simple/simple_io.c
@@ -260,10 +260,10 @@ apr_status_t simple_io_accept(simple_core_t * sc, simple_sb_t * sb)
     rv = apr_socket_accept(&socket, lr->sd, ptrans);
     if (rv) {
         /* pqXXXXXX: unixd.c has _tons_ of custom handling on return values
-         * from accept, but it seems really crazy, it either worked, or didn't, 
-         * but taking this approach of swallowing the error it is possible we have a 
-         * fatal error on our listening socket, but we don't notice.  
-         * 
+         * from accept, but it seems really crazy, it either worked, or didn't,
+         * but taking this approach of swallowing the error it is possible we have a
+         * fatal error on our listening socket, but we don't notice.
+         *
          * Need to discuss this on dev@
          */
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
diff --git a/server/mpm/simple/simple_run.c b/server/mpm/simple/simple_run.c
index 27b13d1..86ba246 100644
--- a/server/mpm/simple/simple_run.c
+++ b/server/mpm/simple/simple_run.c
@@ -286,7 +286,7 @@ int simple_child_loop(simple_core_t * sc)
     }
 
     /* XXXXX: Hack. Reseting parts of the simple core needs to be more
-     * thought out than this. 
+     * thought out than this.
      */
     APR_RING_INIT(&sc->timer_ring, simple_timer_t, link);
 
@@ -323,7 +323,7 @@ int simple_main_loop(simple_core_t * sc)
     if (rv) {
         return rv;
     }
-    
+
     rv = simple_setup_workers(sc);
     if (rv) {
         ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
diff --git a/server/mpm/winnt/child.c b/server/mpm/winnt/child.c
index ea2207f..3a99291 100644
--- a/server/mpm/winnt/child.c
+++ b/server/mpm/winnt/child.c
@@ -45,7 +45,7 @@
 
 #ifdef __MINGW32__
 #include <mswsock.h>
-#endif 
+#endif
 
 /*
  * The Windows MPM uses a queue of completion contexts that it passes
@@ -227,7 +227,7 @@ static winnt_conn_ctx_t *mpm_get_completion_context(int *timeout)
                 /* Create the transaction pool */
                 apr_allocator_create(&allocator);
                 apr_allocator_max_free_set(allocator, ap_max_mem_free);
-                rv = apr_pool_create_ex(&context->ptrans, pchild, NULL, 
+                rv = apr_pool_create_ex(&context->ptrans, pchild, NULL,
                                         allocator);
                 if (rv != APR_SUCCESS) {
                     ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
@@ -305,7 +305,7 @@ static unsigned int __stdcall winnt_accept(void *lr_)
     else {
         accf = 0;
         accf_name = "none";
-        ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(), 
+        ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(),
                      ap_server_conf,
                      "winnt_accept: unrecognized AcceptFilter '%s', "
                      "only 'data', 'connect' or 'none' are valid. "
@@ -316,7 +316,7 @@ static unsigned int __stdcall winnt_accept(void *lr_)
 
 #if APR_HAVE_IPV6
     if (getsockname(nlsd, (struct sockaddr *)&ss_listen, &namelen) == SOCKET_ERROR) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_netos_error(), 
+        ap_log_error(APLOG_MARK, APLOG_ERR, apr_get_netos_error(),
                      ap_server_conf,
                      "winnt_accept: getsockname error on listening socket, "
                      "is IPv6 available?");
@@ -386,13 +386,13 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
             /* Create and initialize the accept socket */
 #if APR_HAVE_IPV6
             if (context->accept_socket == INVALID_SOCKET) {
-                context->accept_socket = socket(ss_listen.ss_family, SOCK_STREAM, 
+                context->accept_socket = socket(ss_listen.ss_family, SOCK_STREAM,
                                                 IPPROTO_TCP);
                 context->socket_family = ss_listen.ss_family;
             }
             else if (context->socket_family != ss_listen.ss_family) {
                 closesocket(context->accept_socket);
-                context->accept_socket = socket(ss_listen.ss_family, SOCK_STREAM, 
+                context->accept_socket = socket(ss_listen.ss_family, SOCK_STREAM,
                                                 IPPROTO_TCP);
                 context->socket_family = ss_listen.ss_family;
             }
@@ -402,7 +402,7 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
 #endif
 
             if (context->accept_socket == INVALID_SOCKET) {
-                ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(), 
+                ap_log_error(APLOG_MARK, APLOG_WARNING, apr_get_netos_error(),
                              ap_server_conf,
                              "winnt_accept: Failed to allocate an accept socket. "
                              "Temporary resource constraint? Try again.");
@@ -444,7 +444,7 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
                     /* We can get here when:
                      * 1) TransmitFile does not properly recycle the accept socket (typically
                      *    because the client disconnected)
-                     * 2) there is VPN or Firewall software installed with 
+                     * 2) there is VPN or Firewall software installed with
                      *    buggy WSAAccept or WSADuplicateSocket implementation
                      * 3) the dynamic address / adapter has changed
                      * Give five chances, then fall back on AcceptFilter 'none'
@@ -539,14 +539,14 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
                 /* Not a failure condition. Keep running. */
             }
 
-            /* Get the local & remote address 
+            /* Get the local & remote address
              * TODO; error check
              */
             GetAcceptExSockaddrs(buf, len, PADDED_ADDR_SIZE, PADDED_ADDR_SIZE,
                                  &context->sa_server, &context->sa_server_len,
                                  &context->sa_client, &context->sa_client_len);
 
-            /* For 'data', craft a bucket for our data result 
+            /* For 'data', craft a bucket for our data result
              * and pass to worker_main as context->overlapped.Pointer
              */
             if (accf == 2 && BytesRead)
@@ -580,8 +580,8 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
 
 
             if (rv != WAIT_OBJECT_0 + 2) {
-                /* not FD_ACCEPT; 
-                 * exit_event triggered or event handle was closed 
+                /* not FD_ACCEPT;
+                 * exit_event triggered or event handle was closed
                  */
                 break;
             }
@@ -624,7 +624,7 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
                 }
                 break;
             }
-            /* Per MSDN, cancel the inherited association of this socket 
+            /* Per MSDN, cancel the inherited association of this socket
              * to the WSAEventSelect API, and restore the state corresponding
              * to apr_os_sock_make's default assumptions (really, a flaw within
              * os_sock_make and os_sock_put that it does not query).
@@ -640,14 +640,14 @@ reinit: /* target of data or connect upon too many AcceptEx failures */
         sockinfo.family  = context->sa_server->sa_family;
         sockinfo.type    = SOCK_STREAM;
         /* Restore the state corresponding to apr_os_sock_make's default
-         * assumption of timeout -1 (really, a flaw of os_sock_make and 
+         * assumption of timeout -1 (really, a flaw of os_sock_make and
          * os_sock_put that it does not query to determine ->timeout).
          * XXX: Upon a fix to APR, these three statements should disappear.
          */
         ioctlsocket(context->accept_socket, FIONBIO, &zero);
-        setsockopt(context->accept_socket, SOL_SOCKET, SO_RCVTIMEO, 
+        setsockopt(context->accept_socket, SOL_SOCKET, SO_RCVTIMEO,
                    (char *) &zero, sizeof(zero));
-        setsockopt(context->accept_socket, SOL_SOCKET, SO_SNDTIMEO, 
+        setsockopt(context->accept_socket, SOL_SOCKET, SO_SNDTIMEO,
                    (char *) &zero, sizeof(zero));
         apr_os_sock_make(&context->sock, &sockinfo, context->ptrans);
 
@@ -847,7 +847,7 @@ static DWORD __stdcall worker_main(void *thread_num_val)
 }
 
 
-static void cleanup_thread(HANDLE *handles, int *thread_cnt, 
+static void cleanup_thread(HANDLE *handles, int *thread_cnt,
                            int thread_to_clean)
 {
     int i;
@@ -891,7 +891,7 @@ static void create_listener_thread(void)
     for (lr = ap_listeners; lr; lr = lr->next) {
         if (lr->sd != NULL) {
             /* A smaller stack is sufficient.
-             * To convert to CreateThread, the returned handle cannot be 
+             * To convert to CreateThread, the returned handle cannot be
              * ignored, it must be closed/joined.
              */
             _beginthreadex(NULL, 65536, winnt_accept,
@@ -953,11 +953,11 @@ void child_main(apr_pool_t *pconf)
      */
     /* Create the worker thread dispatch IOCP */
     ThreadDispatchIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE,
-                                                NULL, 0, 0); 
+                                                NULL, 0, 0);
     apr_thread_mutex_create(&qlock, APR_THREAD_MUTEX_DEFAULT, pchild);
     qwait_event = CreateEvent(NULL, TRUE, FALSE, NULL);
     if (!qwait_event) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(), 
+        ap_log_error(APLOG_MARK, APLOG_CRIT, apr_get_os_error(),
                      ap_server_conf,
                      "Child: Failed to create a qwait event.");
         exit(APEXIT_CHILDINIT);
@@ -980,7 +980,7 @@ void child_main(apr_pool_t *pconf)
                 continue;
             }
             ap_update_child_status_from_indexes(0, i, SERVER_STARTING, NULL);
-        
+
             child_handles[i] = CreateThread(NULL, ap_thread_stacksize,
                                             worker_main, (void *) i,
                                             stack_res_flag, &tid);
@@ -996,7 +996,7 @@ void child_main(apr_pool_t *pconf)
                 goto shutdown;
             }
             threads_created++;
-            /* Save the score board index in ht keyed to the thread handle. 
+            /* Save the score board index in ht keyed to the thread handle.
              * We need this when cleaning up threads down below...
              */
             apr_thread_mutex_lock(child_lock);
@@ -1134,7 +1134,7 @@ void child_main(apr_pool_t *pconf)
                      "Child: %d threads blocked on the completion port",
                      g_blocked_threads);
         for (i=g_blocked_threads; i > 0; i--) {
-            PostQueuedCompletionStatus(ThreadDispatchIOCP, 0, 
+            PostQueuedCompletionStatus(ThreadDispatchIOCP, 0,
                                        IOCP_SHUTDOWN, NULL);
         }
         Sleep(1000);
@@ -1149,7 +1149,7 @@ void child_main(apr_pool_t *pconf)
     apr_thread_mutex_unlock(qlock);
 
     /* Give busy threads a chance to service their connections
-     * (no more than the global server timeout period which 
+     * (no more than the global server timeout period which
      * we track in msec remaining).
      */
     watch_thread = 0;
@@ -1170,10 +1170,10 @@ void child_main(apr_pool_t *pconf)
 
             /* Every 30 seconds give an update */
             if ((time_remains % 30000) == 0) {
-                ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS, 
+                ap_log_error(APLOG_MARK, APLOG_NOTICE, APR_SUCCESS,
                              ap_server_conf,
                              "Child: Waiting %d more seconds "
-                             "for %d worker threads to finish.", 
+                             "for %d worker threads to finish.",
                              time_remains / 1000, threads_created);
             }
             /* We'll poll from the top, 10 times per second */
diff --git a/server/mpm/winnt/mpm_winnt.c b/server/mpm/winnt/mpm_winnt.c
index 70f3479..e15d186 100644
--- a/server/mpm/winnt/mpm_winnt.c
+++ b/server/mpm/winnt/mpm_winnt.c
@@ -624,7 +624,7 @@ static int create_process(apr_pool_t *p, HANDLE *child_proc, HANDLE *child_exit_
     for (envc = 0; _environ[envc]; ++envc) {
         ;
     }
-    env = apr_palloc(ptemp, (envc + 2) * sizeof (char*));  
+    env = apr_palloc(ptemp, (envc + 2) * sizeof (char*));
     memcpy(env, _environ, envc * sizeof (char*));
     apr_snprintf(pidbuf, sizeof(pidbuf), "AP_PARENT_PID=%lu", parent_pid);
     env[envc] = pidbuf;
@@ -1026,7 +1026,7 @@ static void winnt_rewrite_args(process_rec *process)
     /* We wish this was *always* a reservation, but sadly it wasn't so and
      * we couldn't break a hard limit prior to NT Kernel 5.1
      */
-    if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT 
+    if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT
         && ((osver.dwMajorVersion > 5)
          || ((osver.dwMajorVersion == 5) && (osver.dwMinorVersion > 0)))) {
         stack_res_flag = STACK_SIZE_PARAM_IS_A_RESERVATION;
@@ -1072,7 +1072,7 @@ static void winnt_rewrite_args(process_rec *process)
         }
 
         /* This child needs the existing stderr opened for logging,
-         * already 
+         * already
          */
 
 
@@ -1231,7 +1231,7 @@ static void winnt_rewrite_args(process_rec *process)
 
         /* Open a null handle to soak stdout in this process.
          * Windows service processes are missing any file handle
-         * usable for stdin/out/err.  This was the cause of later 
+         * usable for stdin/out/err.  This was the cause of later
          * trouble with invocations of apr_file_open_stdout()
          */
         if ((rv = apr_file_open(&nullfile, "NUL",
@@ -1605,7 +1605,7 @@ static int winnt_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *pt
             }
         }
         /* Always reset our console handler to be the first, even on a restart
-        *  because some modules (e.g. mod_perl) might have set a console 
+        *  because some modules (e.g. mod_perl) might have set a console
         *  handler to terminate the process.
         */
         if (strcasecmp(signal_arg, "runservice"))
diff --git a/server/mpm/winnt/nt_eventlog.c b/server/mpm/winnt/nt_eventlog.c
index 5486994..e7e80d0 100644
--- a/server/mpm/winnt/nt_eventlog.c
+++ b/server/mpm/winnt/nt_eventlog.c
@@ -157,7 +157,7 @@ void mpm_nt_eventlog_stderr_open(const char *argv0, apr_pool_t *p)
 
     WaitForSingleObject(stderr_ready, INFINITE);
 
-    if ((apr_file_open_stderr(&stderr_file, p) 
+    if ((apr_file_open_stderr(&stderr_file, p)
              == APR_SUCCESS)
      && (apr_os_file_put(&eventlog_file, &hPipeWrite, APR_WRITE, p)
              == APR_SUCCESS))
diff --git a/server/mpm/winnt/service.c b/server/mpm/winnt/service.c
index 0c5f1d8..1c145be 100644
--- a/server/mpm/winnt/service.c
+++ b/server/mpm/winnt/service.c
@@ -262,7 +262,7 @@ static void set_service_description(void)
 
 /* handle the SCM's ControlService() callbacks to our service */
 
-static DWORD WINAPI service_nt_ctrl(DWORD dwCtrlCode, DWORD dwEventType, 
+static DWORD WINAPI service_nt_ctrl(DWORD dwCtrlCode, DWORD dwEventType,
                                    LPVOID lpEventData, LPVOID lpContext)
 {
     nt_service_ctx_t *ctx = lpContext;
diff --git a/server/mpm/worker/worker.c b/server/mpm/worker/worker.c
index 5b9fea1..f9c9f88 100644
--- a/server/mpm/worker/worker.c
+++ b/server/mpm/worker/worker.c
@@ -275,7 +275,7 @@ static void wakeup_listener(void)
     }
 
     /* unblock the listener if it's waiting for a worker */
-    ap_queue_info_term(worker_queue_info); 
+    ap_queue_info_term(worker_queue_info);
 
     /*
      * we should just be able to "kill(ap_my_pid, LISTENER_SIGNAL)" on all
@@ -661,15 +661,15 @@ static void accept_mutex_error(const char *func, apr_status_t rv, int process_sl
     if (ap_scoreboard_image->parent[process_slot].generation !=
         ap_scoreboard_image->global->running_generation) {
         level = APLOG_DEBUG; /* common to get these at restart time */
-    } 
-    else if (requests_this_child == INT_MAX  
+    }
+    else if (requests_this_child == INT_MAX
         || ((requests_this_child == ap_max_requests_per_child)
-            && ap_max_requests_per_child)) { 
+            && ap_max_requests_per_child)) {
         ap_log_error(APLOG_MARK, level, rv, ap_server_conf,
                      "apr_proc_mutex_%s failed "
                      "before this child process served any requests.",
                      func);
-        clean_child_exit(APEXIT_CHILDSICK); 
+        clean_child_exit(APEXIT_CHILDSICK);
     }
     ap_log_error(APLOG_MARK, level, rv, ap_server_conf,
                  "apr_proc_mutex_%s failed. Attempting to "
@@ -977,7 +977,7 @@ worker_pop:
         bucket_alloc = apr_bucket_alloc_create(ptrans);
         process_socket(thd, ptrans, csd, process_slot, thread_slot, bucket_alloc);
         worker_sockets[thread_slot] = NULL;
-        requests_this_child--; 
+        requests_this_child--;
         apr_pool_clear(ptrans);
         last_ptrans = ptrans;
     }
@@ -1500,7 +1500,7 @@ static void perform_idle_server_maintenance(void)
              */
             if (ps->pid != 0) { /* XXX just set all_dead_threads in outer for
                                    loop if no pid?  not much else matters */
-                if (status <= SERVER_READY && 
+                if (status <= SERVER_READY &&
                         !ps->quiescing &&
                         ps->generation == retained->my_generation) {
                     ++idle_thread_count;
@@ -1571,7 +1571,7 @@ static void perform_idle_server_maintenance(void)
         /* terminate the free list */
         if (free_length == 0) { /* scoreboard is full, can't fork */
 
-            if (active_thread_count >= ap_daemons_limit * threads_per_child) { 
+            if (active_thread_count >= ap_daemons_limit * threads_per_child) {
                 /* no threads are "inactive" - starting, stopping, etc. */
                 /* have we reached MaxRequestWorkers, or just getting close? */
                 if (0 == idle_thread_count) {
diff --git a/server/mpm_unix.c b/server/mpm_unix.c
index 9675d2f..96c5e4e 100644
--- a/server/mpm_unix.c
+++ b/server/mpm_unix.c
@@ -120,7 +120,7 @@ static int reclaim_one_pid(pid_t pid, action_t action)
     /* Ensure pid sanity. */
     if (pid < 1) {
         return 1;
-    }        
+    }
 
     proc.pid = pid;
     waitret = apr_proc_wait(&proc, &status, &why, APR_NOWAIT);
@@ -350,7 +350,7 @@ apr_status_t ap_mpm_safe_kill(pid_t pid, int sig)
         return APR_EINVAL;
     }
 
-    pg = getpgid(pid);    
+    pg = getpgid(pid);
     if (pg == -1) {
         /* Process already dead... */
         return errno;
@@ -362,7 +362,7 @@ apr_status_t ap_mpm_safe_kill(pid_t pid, int sig)
                      "process group", sig, (long)pid);
         return APR_EINVAL;
     }
-#endif        
+#endif
 
     return kill(pid, sig) ? errno : APR_SUCCESS;
 }
@@ -777,8 +777,8 @@ void ap_mpm_rewrite_args(process_rec *process)
 
     process->argc = mpm_new_argv->nelts;
     process->argv = (const char * const *)mpm_new_argv->elts;
-  
-    if (NULL == dash_k_arg) { 
+
+    if (NULL == dash_k_arg) {
         dash_k_arg = dash_k_arg_noarg;
     }
 
diff --git a/server/protocol.c b/server/protocol.c
index bf48919..f29c915 100644
--- a/server/protocol.c
+++ b/server/protocol.c
@@ -916,7 +916,7 @@ request_rec *ap_read_request(conn_rec *conn)
     tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
 
     ap_run_pre_read_request(r, conn);
-    
+
     /* Get the request... */
     if (!read_request_line(r, tmp_bb)) {
         if (r->status == HTTP_REQUEST_URI_TOO_LARGE
@@ -1379,7 +1379,7 @@ AP_DECLARE(apr_status_t) ap_send_fd(apr_file_t *fd, request_rec *r,
     apr_status_t rv;
 
     bb = apr_brigade_create(r->pool, c->bucket_alloc);
-    
+
     apr_brigade_insert_file(bb, fd, offset, len, r->pool);
 
     rv = ap_pass_brigade(r->output_filters, bb);
diff --git a/server/request.c b/server/request.c
index 90b7090..b575c28 100644
--- a/server/request.c
+++ b/server/request.c
@@ -1845,7 +1845,7 @@ static request_rec *make_sub_request(const request_rec *r,
      * until some module interjects and changes the value.
      */
     rnew->used_path_info = AP_REQ_DEFAULT_PATH_INFO;
-    
+
     /* Pass on the kept body (if any) into the new request. */
     rnew->kept_body = r->kept_body;
 
diff --git a/server/util.c b/server/util.c
index 864a6b8..a6c60a9 100644
--- a/server/util.c
+++ b/server/util.c
@@ -1984,7 +1984,7 @@ char *ap_get_local_host(apr_pool_t *a)
     ap_log_perror(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0, a,
                  "%s: Could not reliably determine the server's fully qualified "
                  "domain name, using %s. Set the 'ServerName' directive globally "
-                 "to suppress this message", 
+                 "to suppress this message",
                  ap_server_argv0, server_hostname);
 
     return server_hostname;
diff --git a/server/util_expr_eval.c b/server/util_expr_eval.c
index 5e3586e..4064787 100644
--- a/server/util_expr_eval.c
+++ b/server/util_expr_eval.c
@@ -99,7 +99,7 @@ static const char *ap_expr_eval_word(ap_expr_eval_ctx_t *ctx,
     return result;
 }
 
-static const char *ap_expr_eval_var(ap_expr_eval_ctx_t *ctx, 
+static const char *ap_expr_eval_var(ap_expr_eval_ctx_t *ctx,
                                     const ap_expr_var_func_t *func,
                                     const void *data)
 {
@@ -862,7 +862,7 @@ static const char *req_table_func(ap_expr_eval_ctx_t *ctx, const void *data,
             return v;
         }
         t = ctx->r->err_headers_out;
-    }        
+    }
     else if (name[0] == 'n')        /* notes */
         t = ctx->r->notes;
     else if (name[3] == 'e')        /* reqenv */
@@ -980,7 +980,7 @@ static const char *unescape_func(ap_expr_eval_ctx_t *ctx, const void *data,
     if (ret == OK)
         return result;
     ap_log_rerror(LOG_MARK(ctx->info), APLOG_DEBUG, 0, ctx->r,
-                      "%s %% escape in unescape('%s') at %s:%d", 
+                      "%s %% escape in unescape('%s') at %s:%d",
 		      ret == HTTP_BAD_REQUEST ? "Bad" : "Forbidden", arg,
 		      ctx->info->filename, ctx->info->line_number);
     return "";
diff --git a/server/util_expr_parse.c b/server/util_expr_parse.c
index 7bf00fa..f5051e9 100644
--- a/server/util_expr_parse.c
+++ b/server/util_expr_parse.c
@@ -2,20 +2,20 @@
 /* A Bison parser, made by GNU Bison 2.4.1.  */
 
 /* Skeleton implementation for Bison's Yacc-like parsers in C
-   
+
       Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
    Free Software Foundation, Inc.
-   
+
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
@@ -28,7 +28,7 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-   
+
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
diff --git a/server/util_expr_scan.c b/server/util_expr_scan.c
index ba759f2..b3edbf0 100644
--- a/server/util_expr_scan.c
+++ b/server/util_expr_scan.c
@@ -34,7 +34,7 @@
 #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
 
 /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
+ * if you want the limit (max/min) macros for int types.
  */
 #ifndef __STDC_LIMIT_MACROS
 #define __STDC_LIMIT_MACROS 1
@@ -51,7 +51,7 @@ typedef uint32_t flex_uint32_t;
 typedef signed char flex_int8_t;
 typedef short int flex_int16_t;
 typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
+typedef unsigned char flex_uint8_t;
 typedef unsigned short int flex_uint16_t;
 typedef unsigned int flex_uint32_t;
 
@@ -184,7 +184,7 @@ typedef struct yy_buffer_state *YY_BUFFER_STATE;
 #define EOB_ACT_LAST_MATCH 2
 
     #define YY_LESS_LINENO(n)
-    
+
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
@@ -246,7 +246,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-    
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -673,7 +673,7 @@ static int yy_init_globals (yyscan_t yyscanner );
     /* This must go here because YYSTYPE and YYLTYPE are included
      * from bison output in section 1.*/
     #    define yylval yyg->yylval_r
-    
+
 int ap_expr_yylex_init (yyscan_t* scanner);
 
 int ap_expr_yylex_init_extra (YY_EXTRA_TYPE user_defined,yyscan_t* scanner);
@@ -742,9 +742,9 @@ static int input (yyscan_t yyscanner );
 #endif
 
     static void yy_push_state (int new_state ,yyscan_t yyscanner);
-    
+
     static void yy_pop_state (yyscan_t yyscanner );
-    
+
 /* Amount of stuff to slurp up with each read. */
 #ifndef YY_READ_BUF_SIZE
 #ifdef __ia64__
@@ -967,7 +967,7 @@ case 1:
 /* rule 1 can match eol */
 YY_RULE_SETUP
 #line 103 "util_expr_scan.l"
-{ 
+{
     /* NOP */
 }
 	YY_BREAK
@@ -2001,7 +2001,7 @@ static void ap_expr_yy_load_buffer_state  (yyscan_t yyscanner)
     YY_BUFFER_STATE ap_expr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
 {
 	YY_BUFFER_STATE b;
-    
+
 	b = (YY_BUFFER_STATE) ap_expr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in ap_expr_yy_create_buffer()" );
@@ -2067,7 +2067,7 @@ static void ap_expr_yy_load_buffer_state  (yyscan_t yyscanner)
     }
 
         b->yy_is_interactive = 0;
-    
+
 	errno = oerrno;
 }
 
@@ -2173,9 +2173,9 @@ static void ap_expr_yyensure_buffer_stack (yyscan_t yyscanner)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( "out of dynamic memory in ap_expr_yyensure_buffer_stack()" );
-								  
+
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
@@ -2204,12 +2204,12 @@ static void ap_expr_yyensure_buffer_stack (yyscan_t yyscanner)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object. 
+ * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE ap_expr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
 {
 	YY_BUFFER_STATE b;
-    
+
 	if ( size < 2 ||
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
@@ -2245,7 +2245,7 @@ YY_BUFFER_STATE ap_expr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t
  */
 YY_BUFFER_STATE ap_expr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
 {
-    
+
 	return ap_expr_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
 }
 
@@ -2262,7 +2262,7 @@ YY_BUFFER_STATE ap_expr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_le
 	char *buf;
 	yy_size_t n;
 	int i;
-    
+
 	/* Get memory for full buffer, including space for trailing EOB's. */
 	n = _yybytes_len + 2;
 	buf = (char *) ap_expr_yyalloc(n ,yyscanner );
@@ -2364,10 +2364,10 @@ YY_EXTRA_TYPE ap_expr_yyget_extra  (yyscan_t yyscanner)
 int ap_expr_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
-    
+
     return yylineno;
 }
 
@@ -2432,8 +2432,8 @@ void ap_expr_yyset_lineno (int  line_number , yyscan_t yyscanner)
 
         /* lineno is only valid if an input buffer exists. */
         if (! YY_CURRENT_BUFFER )
-           yy_fatal_error( "ap_expr_yyset_lineno called with no buffer" , yyscanner); 
-    
+           yy_fatal_error( "ap_expr_yyset_lineno called with no buffer" , yyscanner);
+
     yylineno = line_number;
 }
 
@@ -2533,20 +2533,20 @@ int ap_expr_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_glob
         errno = EINVAL;
         return 1;
     }
-	
+
     *ptr_yy_globals = (yyscan_t) ap_expr_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-	
+
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
-    
+
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-    
+
     ap_expr_yyset_extra (yy_user_defined, *ptr_yy_globals);
-    
+
     return yy_init_globals ( *ptr_yy_globals );
 }
 
diff --git a/server/util_mutex.c b/server/util_mutex.c
index ef2ebe1..4905915 100644
--- a/server/util_mutex.c
+++ b/server/util_mutex.c
@@ -181,7 +181,7 @@ AP_DECLARE_NONSTD(const char *)ap_set_mutex(cmd_parms *cmd, void *dummy,
 
     mechdir = ap_getword_conf(cmd->pool, &arg);
     if (*mechdir == '\0') {
-        return "Mutex requires at least a mechanism argument (" 
+        return "Mutex requires at least a mechanism argument ("
                AP_ALL_AVAILABLE_MUTEXES_STRING ")";
     }
 
diff --git a/server/util_pcre.c b/server/util_pcre.c
index c167fcc..7196878 100644
--- a/server/util_pcre.c
+++ b/server/util_pcre.c
@@ -115,7 +115,7 @@ AP_DECLARE(void) ap_regfree(ap_regex_t *preg)
  *  preg        points to a structure for recording the compiled expression
  *  pattern     the pattern to compile
  *  cflags      compilation flags
- * 
+ *
  * Returns:      0 on success
  *               various non-zero codes on failure
 */
diff --git a/server/util_script.c b/server/util_script.c
index fd80255..243d509 100644
--- a/server/util_script.c
+++ b/server/util_script.c
@@ -483,7 +483,7 @@ AP_DECLARE(int) ap_scan_script_header_err_core_ex(request_rec *r, char *buffer,
 
             /* PR#38070: This fails because it gets confused when a
              * CGI Status header overrides ap_meets_conditions.
-             * 
+             *
              * We can fix that by dropping ap_meets_conditions when
              * Status has been set.  Since this is the only place
              * cgi_status gets used, let's test it explicitly.
@@ -809,7 +809,7 @@ argstr_to_table(char *str, apr_table_t *parms)
     if (str == NULL) {
         return;
     }
-    
+
     key = apr_strtok(str, "&", &strtok_state);
     while (key) {
         value = strchr(key, '=');
diff --git a/server/vhost.c b/server/vhost.c
index 6b9f4be..825708d 100644
--- a/server/vhost.c
+++ b/server/vhost.c
@@ -71,7 +71,7 @@ struct ipaddr_chain {
     server_rec *server;         /* the server to use if this matches */
     name_chain *names;          /* if non-NULL then a list of name-vhosts
                                  * sharing this address */
-    name_chain *initialnames;   /* no runtime use, temporary storage of first 
+    name_chain *initialnames;   /* no runtime use, temporary storage of first
                                  * NVH'es names */
 };
 
@@ -254,11 +254,11 @@ AP_DECLARE_NONSTD(const char *)ap_set_name_virtual_host(cmd_parms *cmd,
                                                         const char *arg)
 {
     static int warnonce = 0;
-    if (++warnonce == 1) { 
-        ap_log_error(APLOG_MARK, APLOG_NOTICE|APLOG_STARTUP, APR_SUCCESS, NULL, 
-                     "NameVirtualHost has no effect and will be removed in the " 
-                     "next release %s:%d", 
-                     cmd->directive->filename, 
+    if (++warnonce == 1) {
+        ap_log_error(APLOG_MARK, APLOG_NOTICE|APLOG_STARTUP, APR_SUCCESS, NULL,
+                     "NameVirtualHost has no effect and will be removed in the "
+                     "next release %s:%d",
+                     cmd->directive->filename,
                      cmd->directive->line_num);
     }
 
@@ -395,7 +395,7 @@ static APR_INLINE ipaddr_chain *find_ipaddr(apr_sockaddr_t *sa)
         if (wild_match == NULL && (cur->port == 0 || sa->port == 0)) {
             if (apr_sockaddr_equal(cur, sa)) {
                 /* don't break, continue looking for an exact match */
-                wild_match = trav; 
+                wild_match = trav;
             }
         }
     }
@@ -417,7 +417,7 @@ static ipaddr_chain *find_default_server(apr_port_t port)
         if (wild_match == NULL && sar->host_port == 0) {
             /* don't break, continue looking for an exact match */
             wild_match = trav;
-        } 
+        }
     }
     return wild_match;
 }
@@ -525,16 +525,16 @@ static void add_name_vhost_config(apr_pool_t *p, server_rec *main_s,
    nc->next = ic->names;
 
    /* iterating backwards, so each one we see becomes the current default server */
-   ic->server = s; 
+   ic->server = s;
 
-   if (ic->names == NULL) { 
-       if (ic->initialnames == NULL) { 
+   if (ic->names == NULL) {
+       if (ic->initialnames == NULL) {
            /* first pass, set these names aside in case we see another VH.
             * Until then, this looks like an IP-based VH to runtime.
             */
            ic->initialnames = nc;
        }
-       else { 
+       else {
            /* second pass through this chain -- this really is an NVH, and we
             * have two sets of names to link in.
             */
@@ -543,7 +543,7 @@ static void add_name_vhost_config(apr_pool_t *p, server_rec *main_s,
            ic->initialnames = NULL;
        }
    }
-   else { 
+   else {
        /* 3rd or more -- just keep stacking the names */
        ic->names = nc;
    }
@@ -584,8 +584,8 @@ AP_DECLARE(void) ap_fini_vhost_config(apr_pool_t *p, server_rec *main_s)
 
             if (!memcmp(sar->host_addr->ipaddr_ptr, inaddr_any, sar->host_addr->ipaddr_len)) {
                 ic = find_default_server(sar->host_port);
-                if (!ic || sar->host_port != ic->sar->host_port) { 
-                    /* No default server, or we found a default server but 
+                if (!ic || sar->host_port != ic->sar->host_port) {
+                    /* No default server, or we found a default server but
                     ** exactly one of us is a wildcard port, which means we want
                     ** two ip-based vhosts not an NVH with two names
                     */
@@ -599,8 +599,8 @@ AP_DECLARE(void) ap_fini_vhost_config(apr_pool_t *p, server_rec *main_s)
                 /* see if it matches something we've already got */
                 ic = find_ipaddr(sar->host_addr);
 
-                if (!ic || sar->host_port != ic->sar->host_port) { 
-                    /* No matching server, or we found a matching server but 
+                if (!ic || sar->host_port != ic->sar->host_port) {
+                    /* No matching server, or we found a matching server but
                     ** exactly one of us is a wildcard port, which means we want
                     ** two ip-based vhosts not an NVH with two names
                     */
diff --git a/support/ab.c b/support/ab.c
index ed3b265..48caf8f2 100644
--- a/support/ab.c
+++ b/support/ab.c
@@ -1201,12 +1201,12 @@ static void start_connect(struct connection * c)
     }
 
     if (windowsize != 0) {
-        rv = apr_socket_opt_set(c->aprsock, APR_SO_SNDBUF, 
+        rv = apr_socket_opt_set(c->aprsock, APR_SO_SNDBUF,
                                 windowsize);
         if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {
             apr_err("socket send buffer", rv);
         }
-        rv = apr_socket_opt_set(c->aprsock, APR_SO_RCVBUF, 
+        rv = apr_socket_opt_set(c->aprsock, APR_SO_RCVBUF,
                                 windowsize);
         if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {
             apr_err("socket receive buffer", rv);
@@ -1252,7 +1252,7 @@ static void start_connect(struct connection * c)
                    "\nTest aborted after 10 failures\n\n");
                 apr_err("apr_socket_connect()", rv);
             }
-            
+
             start_connect(c);
             return;
         }
@@ -1501,7 +1501,7 @@ static void read_connection(struct connection * c)
                 /* The response may not have a Content-Length header */
                 if (!cl) {
                     c->keepalive = 1;
-                    c->length = 0; 
+                    c->length = 0;
                 }
             }
             c->bread += c->cbx - (s + l - c->cbuff) + r - tocopy;
@@ -1656,7 +1656,7 @@ static void test(void)
     }
 
     if (verbosity >= 2)
-        printf("INFO: %s header == \n---\n%s\n---\n", 
+        printf("INFO: %s header == \n---\n%s\n---\n",
                method_str[method], request);
 
     reqlen = strlen(request);
@@ -1708,7 +1708,7 @@ static void test(void)
     start = lasttime = apr_time_now();
     stoptime = tlimit ? (start + apr_time_from_sec(tlimit)) : AB_MAX;
 
-#ifdef SIGINT 
+#ifdef SIGINT
     /* Output the results if the user terminates the run early. */
     apr_signal(SIGINT, output_results);
 #endif
@@ -1768,10 +1768,10 @@ static void test(void)
                 bad++;
                 err_except++;
                 /* avoid apr_poll/EINPROGRESS loop on HP-UX, let recv discover ECONNREFUSED */
-                if (c->state == STATE_CONNECTING) { 
+                if (c->state == STATE_CONNECTING) {
                     read_connection(c);
                 }
-                else { 
+                else {
                     start_connect(c);
                 }
                 continue;
@@ -1807,7 +1807,7 @@ static void test(void)
             }
         }
     } while (lasttime < stoptime && done < requests);
-    
+
     if (heartbeatres)
         fprintf(stderr, "Finished %d requests\n", done);
     else
diff --git a/support/htcacheclean.c b/support/htcacheclean.c
index 2e5a7fe..9ca9278 100644
--- a/support/htcacheclean.c
+++ b/support/htcacheclean.c
@@ -1349,7 +1349,7 @@ static void usage(const char *error)
 #undef NL
 
 static void usage_repeated_arg(apr_pool_t *pool, char option) {
-    usage(apr_psprintf(pool, 
+    usage(apr_psprintf(pool,
                        "The option '%c' cannot be specified more than once",
                        option));
 }
@@ -1370,7 +1370,7 @@ static void log_pid(apr_pool_t *pool, const char *pidfilename, apr_file_t **pidf
         if (errfile) {
             apr_file_printf(errfile,
                             "Could not write the pid file '%s': %s" APR_EOL_STR,
-                            pidfilename, 
+                            pidfilename,
                             apr_strerror(status, errmsg, sizeof errmsg));
         }
         exit(1);
diff --git a/support/htpasswd.c b/support/htpasswd.c
index 001d904..f67076f 100644
--- a/support/htpasswd.c
+++ b/support/htpasswd.c
@@ -125,7 +125,7 @@ static void to64(char *s, unsigned long v, int n)
 
 static void generate_salt(char *s, size_t size)
 {
-    static unsigned char tbl[] = 
+    static unsigned char tbl[] =
         "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
     size_t i;
     for (i = 0; i < size; ++i) {
diff --git a/support/rotatelogs.c b/support/rotatelogs.c
index a00bb63..c026a07 100644
--- a/support/rotatelogs.c
+++ b/support/rotatelogs.c
@@ -288,7 +288,7 @@ static void post_rotate(apr_pool_t *pool, struct logfile *newlog,
             exit(2);
         }
     }
-    
+
     if (!config->postrotate_prog) {
         /* Nothing more to do. */
         return;
@@ -358,7 +358,7 @@ static void doRotate(rotate_config_t *config, rotate_status_t *status)
     int tLogStart;
     apr_status_t rv;
     struct logfile newlog;
- 
+
     status->rotateReason = ROTATE_NONE;
 
     if (config->tRotation) {
@@ -427,10 +427,10 @@ static void doRotate(rotate_config_t *config, rotate_status_t *status)
             fprintf(stderr, "Could not open log file '%s' (%s)\n", newlog.name, error);
             exit(2);
         }
-        
+
         /* Throw away new state; it isn't going to be used. */
         apr_pool_destroy(newlog.pool);
-        
+
         /* Try to keep this error message constant length
          * in case it occurs several times. */
         apr_snprintf(status->errbuf, sizeof status->errbuf,
@@ -438,17 +438,17 @@ static void doRotate(rotate_config_t *config, rotate_status_t *status)
                      "new log file, %10d messages lost: %-25.25s\n",
                      status->nMessCount, error);
         nWrite = strlen(status->errbuf);
-        
+
         if (apr_file_trunc(status->current.fd, 0) != APR_SUCCESS) {
             fprintf(stderr, "Error truncating the file %s\n", status->current.name);
             exit(2);
-        }        
+        }
         if (apr_file_write(status->current.fd, status->errbuf, &nWrite) != APR_SUCCESS) {
             fprintf(stderr, "Error writing to the file %s\n", status->current.name);
             exit(2);
         }
     }
-    
+
     status->nMessCount = 0;
 }
 
diff --git a/support/win32/ApacheMonitor.c b/support/win32/ApacheMonitor.c
index 0e8a23e..de7c642 100644
--- a/support/win32/ApacheMonitor.c
+++ b/support/win32/ApacheMonitor.c
@@ -219,7 +219,7 @@ void ErrorMessage(LPCTSTR szError, BOOL bFatal)
 }
 
 
-int am_RespawnAsUserAdmin(HWND hwnd, DWORD op, LPCTSTR szService, 
+int am_RespawnAsUserAdmin(HWND hwnd, DWORD op, LPCTSTR szService,
                           LPCTSTR szComputerName)
 {
     TCHAR args[MAX_PATH + MAX_COMPUTERNAME_LENGTH + 12];
@@ -229,7 +229,7 @@ int am_RespawnAsUserAdmin(HWND hwnd, DWORD op, LPCTSTR szService,
         return 0;
     }
 
-    _sntprintf(args, sizeof(args) / sizeof(TCHAR), 
+    _sntprintf(args, sizeof(args) / sizeof(TCHAR),
                _T("%d \"%s\" \"%s\""), op, szService,
                szComputerName ? szComputerName : _T(""));
     if (!ShellExecute(hwnd, _T("runas"), __targv[0], args, NULL, SW_NORMAL)) {
@@ -259,7 +259,7 @@ BOOL am_ConnectComputer(LPTSTR szComputerName)
     }
     if (RegConnectRegistry(szComputerName, HKEY_LOCAL_MACHINE, &hKeyRemote)
             != ERROR_SUCCESS) {
-        _sntprintf(szTmp, sizeof(szTmp) / sizeof(TCHAR), 
+        _sntprintf(szTmp, sizeof(szTmp) / sizeof(TCHAR),
                    g_lpMsg[IDS_MSG_ECONNECT - IDS_MSG_FIRST],
                    szComputerName);
         ErrorMessage(szTmp, FALSE);
@@ -303,7 +303,7 @@ BOOL GetSystemOSVersion(LPDWORD dwVersion)
         if (osvi.dwMajorVersion >= 5)
             *dwVersion = OS_VERSION_WIN2K;
         else
-            *dwVersion = OS_VERSION_WINNT;            
+            *dwVersion = OS_VERSION_WINNT;
         break;
 
     case VER_PLATFORM_WIN32_WINDOWS:
@@ -351,11 +351,11 @@ static VOID ShowNotifyIcon(HWND hWnd, DWORD dwMessage)
         _tcscpy(nid.szTip, g_lpMsg[IDS_MSG_RUNNINGALL - IDS_MSG_FIRST]);
     }
     else if (n) {
-        _sntprintf(nid.szTip, sizeof(nid.szTip) / sizeof(TCHAR), 
+        _sntprintf(nid.szTip, sizeof(nid.szTip) / sizeof(TCHAR),
                   g_lpMsg[IDS_MSG_RUNNING - IDS_MSG_FIRST], n, i);
     }
     else if (i) {
-        _sntprintf(nid.szTip, sizeof(nid.szTip) / sizeof(TCHAR), 
+        _sntprintf(nid.szTip, sizeof(nid.szTip) / sizeof(TCHAR),
                   g_lpMsg[IDS_MSG_RUNNINGNONE - IDS_MSG_FIRST], i);
     }
     else {
@@ -563,7 +563,7 @@ BOOL ApacheManageService(LPCTSTR szServiceName, LPCTSTR szImagePath,
     {
         /* Avoid recursion of ImagePath NULL (from this Respawn) */
         if (szImagePath) {
-            am_RespawnAsUserAdmin(g_hwndMain, dwCommand, 
+            am_RespawnAsUserAdmin(g_hwndMain, dwCommand,
                                   szServiceName, szComputerName);
         }
         else {
@@ -581,7 +581,7 @@ BOOL ApacheManageService(LPCTSTR szServiceName, LPCTSTR szImagePath,
         switch (dwCommand)
         {
           case SERVICE_CONTROL_STOP:
-            _sntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR), 
+            _sntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR),
                        g_lpMsg[IDS_MSG_SRVSTOP - IDS_MSG_FIRST],
                        szServiceName);
             addListBoxString(g_hwndStdoutList, szMsg);
@@ -604,7 +604,7 @@ BOOL ApacheManageService(LPCTSTR szServiceName, LPCTSTR szImagePath,
                 if (schSStatus.dwCurrentState == SERVICE_STOPPED)
                 {
                     retValue = TRUE;
-                    _sntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR), 
+                    _sntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR),
                                g_lpMsg[IDS_MSG_SRVSTOPPED - IDS_MSG_FIRST],
                                szServiceName);
                     addListBoxString(g_hwndStdoutList, szMsg);
@@ -637,7 +637,7 @@ BOOL ApacheManageService(LPCTSTR szServiceName, LPCTSTR szImagePath,
                 if (schSStatus.dwCurrentState == SERVICE_RUNNING)
                 {
                     retValue = TRUE;
-                    _sntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR), 
+                    _sntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR),
                                g_lpMsg[IDS_MSG_SRVSTARTED - IDS_MSG_FIRST],
                                szServiceName);
                     addListBoxString(g_hwndStdoutList, szMsg);
@@ -646,7 +646,7 @@ BOOL ApacheManageService(LPCTSTR szServiceName, LPCTSTR szImagePath,
             break;
 
           case SERVICE_APACHE_RESTART:
-            _sntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR), 
+            _sntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR),
                        g_lpMsg[IDS_MSG_SRVRESTART - IDS_MSG_FIRST],
                        szServiceName);
             addListBoxString(g_hwndStdoutList, szMsg);
@@ -673,7 +673,7 @@ BOOL ApacheManageService(LPCTSTR szServiceName, LPCTSTR szImagePath,
             if (schSStatus.dwCurrentState == SERVICE_RUNNING)
             {
                 retValue = TRUE;
-                _sntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR), 
+                _sntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR),
                            g_lpMsg[IDS_MSG_SRVRESTARTED - IDS_MSG_FIRST],
                            szServiceName);
                 addListBoxString(g_hwndStdoutList, szMsg);
@@ -1474,7 +1474,7 @@ static int KillAllMonitors(void)
     int exitcode = 0;
     PWTS_PROCESS_INFO tsProcs;
     DWORD tsProcCount, i;
-    DWORD thisProcId; 
+    DWORD thisProcId;
 
     /* This is graceful, close our own Window, clearing the icon */
     if ((appwindow = FindWindow(g_szWindowClass, g_szTitle)) != NULL)
@@ -1498,7 +1498,7 @@ static int KillAllMonitors(void)
     for (i = 0; i < tsProcCount; ++i) {
         if (_tcscmp(tsProcs[i].pProcessName, _T(AM_STRINGIFY(BIN_NAME))) == 0
                 && tsProcs[i].ProcessId != thisProcId)
-            WTSTerminateProcess(WTS_CURRENT_SERVER_HANDLE, 
+            WTSTerminateProcess(WTS_CURRENT_SERVER_HANDLE,
                                 tsProcs[i].ProcessId, 1);
     }
     WTSFreeMemory(tsProcs);
