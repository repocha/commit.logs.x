commit 5cde3add9e1db42744d6a1b9ba7ceb2cd1e815c0
Author: Ryan Bloom <rbb@apache.org>
Date:   Wed Oct 20 12:50:12 1999 +0000

    Add a status value to ap_log_error and ap_log_rerror.  This allows us to use
    apr_status codes in our error logs.  The main advantage of this, is portable
    error codes.  Now, Windows will finally be able to use errno!
    
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@84007 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/include/http_log.h b/include/http_log.h
index 575013f..88d4c1b 100644
--- a/include/http_log.h
+++ b/include/http_log.h
@@ -114,12 +114,14 @@ void ap_open_logs (server_rec *, ap_context_t *p);
  * attack and other messy behavior.  Instead, use a simple format string
  * like "%s", followed by the string containing the untrusted data.
  */
-API_EXPORT(void) ap_log_error(const char *file, int line, int level,
-			     const server_rec *s, const char *fmt, ...)
-			    __attribute__((format(printf,5,6)));
-API_EXPORT(void) ap_log_rerror(const char *file, int line, int level,
-			     const request_rec *s, const char *fmt, ...)
-			    __attribute__((format(printf,5,6)));
+API_EXPORT(void) ap_log_error(const char *file, int line, int level, 
+                             ap_status_t status, const server_rec *s, 
+                             const char *fmt, ...)
+			    __attribute__((format(printf,6,7)));
+API_EXPORT(void) ap_log_rerror(const char *file, int line, int level, 
+                               ap_status_t status, const request_rec *s, 
+                               const char *fmt, ...)
+			    __attribute__((format(printf,6,7)));
 API_EXPORT(void) ap_error_log2stderr (server_rec *);     
 
 void ap_log_pid (ap_context_t *p, const char *fname);
diff --git a/modules/aaa/mod_access.c b/modules/aaa/mod_access.c
index e1b17f3..08639ab 100644
--- a/modules/aaa/mod_access.c
+++ b/modules/aaa/mod_access.c
@@ -376,7 +376,7 @@ static int check_dir_access(request_rec *r)
 
     if (ret == FORBIDDEN
 	&& (ap_satisfies(r) != SATISFY_ANY || !ap_some_auth_required(r))) {
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		  "client denied by server configuration: %s",
 		  r->filename);
     }
diff --git a/modules/aaa/mod_auth.c b/modules/aaa/mod_auth.c
index aedef1d..98782b7 100644
--- a/modules/aaa/mod_auth.c
+++ b/modules/aaa/mod_auth.c
@@ -124,7 +124,7 @@ static char *get_pw(request_rec *r, char *user, char *auth_pwfile)
     const char *rpw, *w;
 
     if (!(f = ap_pcfg_openfile(r->pool, auth_pwfile))) {
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
 		    "Could not open password file: %s", auth_pwfile);
 	return NULL;
     }
@@ -212,14 +212,14 @@ static int authenticate_basic_user(request_rec *r)
     if (!(real_pw = get_pw(r, r->user, sec->auth_pwfile))) {
 	if (!(sec->auth_authoritative))
 	    return DECLINED;
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		    "user %s not found: %s", r->user, r->uri);
 	ap_note_basic_auth_failure(r);
 	return AUTH_REQUIRED;
     }
     invalid_pw = ap_validate_password(sent_pw, real_pw);
     if (invalid_pw != NULL) {
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		      "user %s: authentication failure for \"%s\": %s",
 		      r->user, r->uri, invalid_pw);
 	ap_note_basic_auth_failure(r);
@@ -289,7 +289,7 @@ static int check_user_access(request_rec *r)
 	     * That something could be a missing "AuthAuthoritative off", but
 	     * more likely is a typo in the require directive.
 	     */
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		"access to %s failed, reason: unknown require directive:"
 		"\"%s\"", r->uri, reqs[x].requirement);
 	}
@@ -301,7 +301,7 @@ static int check_user_access(request_rec *r)
     if (!(sec->auth_authoritative))
 	return DECLINED;
 
-    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 	"access to %s failed, reason: user %s not allowed access",
 	r->uri, user);
 	
diff --git a/modules/generators/mod_asis.c b/modules/generators/mod_asis.c
index 6c7f9a1..8357f48 100644
--- a/modules/generators/mod_asis.c
+++ b/modules/generators/mod_asis.c
@@ -66,6 +66,7 @@
 static int asis_handler(request_rec *r)
 {
     ap_file_t *f;
+    ap_status_t status;
     const char *location;
     FILE *thefile;         /* XXX leave these alone until we convert */
     int thefd;             /* everything to use apr_file_t's. */ 
@@ -74,14 +75,14 @@ static int asis_handler(request_rec *r)
     if (r->method_number != M_GET)
 	return DECLINED;
     if (r->finfo.st_mode == 0) {
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		    "File does not exist: %s", r->filename);
 	return NOT_FOUND;
     }
 
-    if (ap_open(&f, r->filename, APR_READ | APR_BUFFERED, 
-                APR_OS_DEFAULT, r->pool) != APR_SUCCESS) {
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+    if ((status = ap_open(&f, r->filename, APR_READ | APR_BUFFERED, 
+                APR_OS_DEFAULT, r->pool)) != APR_SUCCESS) {
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
 		    "file permissions deny server access: %s", r->filename);
 	return FORBIDDEN;
     }
diff --git a/modules/generators/mod_autoindex.c b/modules/generators/mod_autoindex.c
index 8156f2f..6f1ea1c 100644
--- a/modules/generators/mod_autoindex.c
+++ b/modules/generators/mod_autoindex.c
@@ -1505,6 +1505,7 @@ static int index_directory(request_rec *r,
     char *name = r->filename;
 
     ap_dir_t *d;
+    ap_status_t status;
     int num_ent = 0, x;
     struct ent *head, *p;
     struct ent **ar = NULL;
@@ -1513,8 +1514,8 @@ static int index_directory(request_rec *r,
     char keyid;
     char direction;
 
-    if (ap_opendir(&d, name, r->pool) != APR_SUCCESS) {
-	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+    if ((status = ap_opendir(&d, name, r->pool)) != APR_SUCCESS) {
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
 		    "Can't open directory for index: %s", r->filename);
 	return HTTP_FORBIDDEN;
     }
@@ -1642,7 +1643,7 @@ static int handle_autoindex(request_rec *r)
 	return index_directory(r, d);
     }
     else {
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		     "Directory index forbidden by rule: %s", r->filename);
 	return HTTP_FORBIDDEN;
     }
diff --git a/modules/http/http_core.c b/modules/http/http_core.c
index 852b95a..1c8564b 100644
--- a/modules/http/http_core.c
+++ b/modules/http/http_core.c
@@ -856,7 +856,7 @@ API_EXPORT (file_type_e) ap_get_win32_interpreter(const  request_rec *r,
         if (*interpreter)
             return eFileTypeSCRIPT;
         else {
-            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, r->server,
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, r->server,
              "ScriptInterpreterSource config directive set to \"registry\".\n\t"
              "Registry was searched but interpreter not found. Trying the shebang line.");
         }
@@ -1079,7 +1079,7 @@ static const char *set_error_document(cmd_parms *cmd, core_dir_config *conf,
 
     if (error_number == 401 &&
 	line[0] != '/' && line[0] != '"') { /* Ignore it... */
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, cmd->server,
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, cmd->server,
 		     "cannot use a full URL in a 401 ErrorDocument "
 		     "directive --- ignoring!");
     }
@@ -2407,7 +2407,7 @@ static int core_translate(request_rec *r)
         return HTTP_FORBIDDEN;
     }
     if ((r->uri[0] != '/') && strcmp(r->uri, "*")) {
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		     "Invalid URI in request %s", r->the_request);
 	return BAD_REQUEST;
     }
@@ -2453,7 +2453,7 @@ static ap_status_t mmap_cleanup(void *mmv)
     struct mmap_rec *mmd = mmv;
 
     if (munmap(mmd->mm, mmd->length) == -1) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, NULL,
                      "Failed to munmap memory of length %ld at 0x%lx",
                      (long) mmd->length, (long) mmd->mm);
     }
@@ -2476,6 +2476,7 @@ static int default_handler(request_rec *r)
     int rangestatus, errstatus;
     ap_file_t *fd = NULL;
     int fd_os;
+    ap_status_t status;
 #ifdef USE_MMAP_FILES
     caddr_t mm;
 #endif
@@ -2493,7 +2494,7 @@ static int default_handler(request_rec *r)
     r->allowed |= (1 << M_GET) | (1 << M_OPTIONS);
 
     if (r->method_number == M_INVALID) {
-	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		    "Invalid method in request %s", r->the_request);
 	return NOT_IMPLEMENTED;
     }
@@ -2505,7 +2506,7 @@ static int default_handler(request_rec *r)
     }
     /* ZZZ can we store if the file exists or not? */
     if (r->finfo.st_mode == 0 || (r->path_info && *r->path_info)) {
-	ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
+	ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, r,
 		      "File does not exist: %s",r->path_info ?
 		      ap_pstrcat(r->pool, r->filename, r->path_info, NULL)
 		      : r->filename);
@@ -2515,8 +2516,8 @@ static int default_handler(request_rec *r)
         return METHOD_NOT_ALLOWED;
     }
 	
-    if (ap_open (&fd, r->filename, APR_READ | APR_BINARY, 0, r->pool) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+    if ((status = ap_open(&fd, r->filename, APR_READ | APR_BINARY, 0, r->pool)) != APR_SUCCESS) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
 		     "file permissions deny server access: %s", r->filename);
         return FORBIDDEN;
     }
@@ -2542,7 +2543,7 @@ static int default_handler(request_rec *r)
 	mm = mmap(NULL, r->finfo.st_size, PROT_READ, MAP_PRIVATE,
 		  fd_os, 0);
 	if (mm == (caddr_t)-1) {
-	    ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_CRIT, errno, r,
 			 "default_handler: mmap failed: %s", r->filename);
 	}
     }
@@ -2586,8 +2587,8 @@ static int default_handler(request_rec *r)
                 ap_off_t offset;
 
 		while (ap_each_byterange(r, &offset, &length)) {
-                    if (ap_seek(fd, APR_SET, &offset) != APR_SUCCESS) {
-		        ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                    if ((status = ap_seek(fd, APR_SET, &offset)) != APR_SUCCESS) {
+		        ap_log_error(APLOG_MARK, APLOG_ERR, status, r->server,
 				  "error byteserving file: %s", r->filename);
 			ap_close(fd);
 			return HTTP_INTERNAL_SERVER_ERROR;
diff --git a/modules/http/http_protocol.c b/modules/http/http_protocol.c
index e979baf..4e5d2ba 100644
--- a/modules/http/http_protocol.c
+++ b/modules/http/http_protocol.c
@@ -971,7 +971,7 @@ request_rec *ap_read_request(conn_rec *conn)
     /* Get the request... */
     if (!read_request_line(r)) {
         if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                          "request failed: URI too long");
             ap_send_error_response(r, 0);
             ap_run_log_transaction(r);
@@ -986,7 +986,7 @@ request_rec *ap_read_request(conn_rec *conn)
     if (!r->assbackwards) {
         get_mime_headers(r);
         if (r->status != HTTP_REQUEST_TIME_OUT) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
             ap_send_error_response(r, 0);
             ap_run_log_transaction(r);
@@ -1000,7 +1000,7 @@ request_rec *ap_read_request(conn_rec *conn)
              * headers! Have to dink things just to make sure the error message
              * comes through...
              */
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                           "client sent invalid HTTP/0.9 request: HEAD %s",
                           r->uri);
             r->header_only = 0;
@@ -1034,7 +1034,7 @@ request_rec *ap_read_request(conn_rec *conn)
          * a Host: header, and the server MUST respond with 400 if it doesn't.
          */
         r->status = HTTP_BAD_REQUEST;
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                       "client sent HTTP/1.1 request without hostname "
                       "(see RFC2068 section 9, and 14.23): %s", r->uri);
         ap_send_error_response(r, 0);
@@ -1054,7 +1054,7 @@ request_rec *ap_read_request(conn_rec *conn)
         }
         else {
             r->status = HTTP_EXPECTATION_FAILED;
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, r,
                           "client sent an unrecognized expectation value of "
                           "Expect: %s", expect);
             ap_send_error_response(r, 0);
@@ -1154,7 +1154,7 @@ API_EXPORT(int) ap_get_basic_auth_pw(request_rec *r, const char **pw)
 
     if (!ap_auth_name(r)) {
         ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR,
-		    r, "need AuthName: %s", r->uri);
+		    0, r, "need AuthName: %s", r->uri);
         return SERVER_ERROR;
     }
 
@@ -1165,7 +1165,7 @@ API_EXPORT(int) ap_get_basic_auth_pw(request_rec *r, const char **pw)
 
     if (strcasecmp(ap_getword(r->pool, &auth_line, ' '), "Basic")) {
         /* Client tried to authenticate using wrong auth scheme */
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                     "client used wrong authentication scheme: %s", r->uri);
         ap_note_basic_auth_failure(r);
         return AUTH_REQUIRED;
@@ -1715,12 +1715,12 @@ API_EXPORT(int) ap_setup_client_block(request_rec *r, int read_policy)
 
     if (tenc) {
         if (strcasecmp(tenc, "chunked")) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                         "Unknown Transfer-Encoding %s", tenc);
             return HTTP_NOT_IMPLEMENTED;
         }
         if (r->read_body == REQUEST_CHUNKED_ERROR) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                         "chunked Transfer-Encoding forbidden: %s", r->uri);
             return (lenp) ? HTTP_BAD_REQUEST : HTTP_LENGTH_REQUIRED;
         }
@@ -1733,7 +1733,7 @@ API_EXPORT(int) ap_setup_client_block(request_rec *r, int read_policy)
         while (ap_isdigit(*pos) || ap_isspace(*pos))
             ++pos;
         if (*pos != '\0') {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                         "Invalid Content-Length %s", lenp);
             return HTTP_BAD_REQUEST;
         }
@@ -1743,14 +1743,14 @@ API_EXPORT(int) ap_setup_client_block(request_rec *r, int read_policy)
 
     if ((r->read_body == REQUEST_NO_BODY) &&
         (r->read_chunked || (r->remaining > 0))) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                     "%s with body is not allowed for %s", r->method, r->uri);
         return HTTP_REQUEST_ENTITY_TOO_LARGE;
     }
 
     max_body = ap_get_limit_req_body(r);
     if (max_body && (r->remaining > max_body)) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
           "Request content-length of %s is larger than the configured "
           "limit of %lu", lenp, max_body);
         return HTTP_REQUEST_ENTITY_TOO_LARGE;
@@ -1847,7 +1847,7 @@ API_EXPORT(long) ap_get_client_block(request_rec *r, char *buffer, int bufsiz)
      */
     max_body = ap_get_limit_req_body(r);
     if (max_body && (r->read_length > max_body)) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
             "Chunked request body is larger than the configured limit of %lu",
             max_body);
         r->connection->keepalive = -1;
@@ -2045,7 +2045,7 @@ API_EXPORT(long) ap_send_fd_length(ap_file_t *fd, request_rec *r, long length)
             }
             else if (w < 0) {
                 if (!ap_is_aborted(r->connection)) {
-                    ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, errno, r,
                      "client stopped connection before send body completed");
                     ap_bsetflag(r->connection->client, B_EOUT, 1);
                     r->connection->aborted = 1;
@@ -2120,7 +2120,7 @@ API_EXPORT(long) ap_send_fb_length(BUFF *fb, request_rec *r, long length)
             }
             else if (w < 0) {
                 if (!ap_is_aborted(r->connection)) {
-                    ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, errno, r,
                         "client stopped connection before rflush completed");
                     ap_bsetflag(r->connection->client, B_EOUT, 1);
                     r->connection->aborted = 1;
@@ -2179,7 +2179,7 @@ API_EXPORT(size_t) ap_send_mmap(void *mm, request_rec *r, size_t offset,
                 else if (errno == EAGAIN)
                     continue;
                 else {
-                    ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, errno, r,
                      "client stopped connection before send mmap completed");
                     ap_bsetflag(r->connection->client, B_EOUT, 1);
                     r->connection->aborted = 1;
@@ -2200,7 +2200,7 @@ API_EXPORT(int) ap_rputc(int c, request_rec *r)
 
     if (ap_bputc(c, r->connection->client) < 0) {
         if (!r->connection->aborted) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, errno, r,
                 "client stopped connection before rputc completed");
             ap_bsetflag(r->connection->client, B_EOUT, 1);
             r->connection->aborted = 1;
@@ -2221,7 +2221,7 @@ API_EXPORT(int) ap_rputs(const char *str, request_rec *r)
     rcode = ap_bputs(str, r->connection->client);
     if (rcode < 0) {
         if (!r->connection->aborted) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, errno, r,
                 "client stopped connection before rputs completed");
             ap_bsetflag(r->connection->client, B_EOUT, 1);
             r->connection->aborted = 1;
@@ -2242,7 +2242,7 @@ API_EXPORT(int) ap_rwrite(const void *buf, int nbyte, request_rec *r)
     n = ap_bwrite(r->connection->client, buf, nbyte);
     if (n < 0) {
         if (!r->connection->aborted) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, errno, r,
                 "client stopped connection before rwrite completed");
             ap_bsetflag(r->connection->client, B_EOUT, 1);
             r->connection->aborted = 1;
@@ -2264,7 +2264,7 @@ API_EXPORT(int) ap_vrprintf(request_rec *r, const char *fmt, va_list ap)
 
     if (n < 0) {
         if (!r->connection->aborted) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, errno, r,
                 "client stopped connection before vrprintf completed");
             ap_bsetflag(r->connection->client, B_EOUT, 1);
             r->connection->aborted = 1;
@@ -2289,7 +2289,7 @@ API_EXPORT(int) ap_rprintf(request_rec *r, const char *fmt,...)
 
     if (n < 0) {
         if (!r->connection->aborted) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, errno, r,
                 "client stopped connection before rprintf completed");
             ap_bsetflag(r->connection->client, B_EOUT, 1);
             r->connection->aborted = 1;
@@ -2320,7 +2320,7 @@ API_EXPORT_NONSTD(int) ap_rvputs(request_rec *r,...)
         if (i != j) {
             va_end(args);
             if (!r->connection->aborted) {
-                ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, errno, r,
                     "client stopped connection before rvputs completed");
                 ap_bsetflag(r->connection->client, B_EOUT, 1);
                 r->connection->aborted = 1;
@@ -2339,7 +2339,7 @@ API_EXPORT(int) ap_rflush(request_rec *r)
 {
     if (ap_bflush(r->connection->client) < 0) {
         if (!ap_is_aborted(r->connection)) {
-            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, errno, r,
                 "client stopped connection before rflush completed");
             ap_bsetflag(r->connection->client, B_EOUT, 1);
             r->connection->aborted = 1;
diff --git a/modules/http/http_request.c b/modules/http/http_request.c
index 97dc2bb..48aecda 100644
--- a/modules/http/http_request.c
+++ b/modules/http/http_request.c
@@ -123,7 +123,7 @@ static int check_safe_file(request_rec *r)
         || S_ISLNK(r->finfo.st_mode)) {
         return OK;
     }
-    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                 "object is not a file, directory or symlink: %s",
                 r->filename);
     return HTTP_FORBIDDEN;
@@ -306,7 +306,7 @@ static int get_path_info(request_rec *r)
 #if defined(EACCES)      /* ZZZ again, AP error checking. */
             if (errno != EACCES)
 #endif
-                ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, errno, r,
                             "access to %s failed", r->uri);
             return HTTP_FORBIDDEN;
         }
@@ -429,7 +429,7 @@ static int directory_walk(request_rec *r)
     num_dirs = ap_count_dirs(test_filename);
 
     if (!ap_os_is_filename_valid(r->filename)) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                       "Filename is not valid: %s", r->filename);
         return HTTP_FORBIDDEN;
     }
@@ -483,7 +483,7 @@ static int directory_walk(request_rec *r)
          */
 
         if ((res = check_symlinks(test_dirname, core_dir->opts))) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                         "Symbolic link not allowed: %s", test_dirname);
             return res;
         }
@@ -580,7 +580,7 @@ static int directory_walk(request_rec *r)
      */
     if (!S_ISDIR(r->finfo.st_mode)   /* ZZZ use AP funcs and defines */
         && (res = check_symlinks(r->filename, ap_allow_options(r)))) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                     "Symbolic link not allowed: %s", r->filename);
         return res;
     }
@@ -892,7 +892,7 @@ API_EXPORT(request_rec *) ap_sub_req_lookup_file(const char *new_file,
         }
         else {
             if ((res = check_symlinks(rnew->filename, ap_allow_options(rnew)))) {
-                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, rnew,
+                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, rnew,
                             "Symbolic link not allowed: %s", rnew->filename);
                 rnew->status = res;
                 return rnew;
@@ -1073,7 +1073,7 @@ API_EXPORT(void) ap_die(int type, request_rec *r)
              * dying with a recursive server error...
              */
             recursive_error = SERVER_ERROR;
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                         "Invalid error redirection directive: %s",
                         custom_response);
         }
@@ -1084,7 +1084,7 @@ API_EXPORT(void) ap_die(int type, request_rec *r)
 static void decl_die(int status, char *phase, request_rec *r)
 {
     if (status == DECLINED) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_CRIT, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_CRIT, 0, r,
                     "configuration error:  couldn't %s: %s", phase, r->uri);
         ap_die(SERVER_ERROR, r);
     }
diff --git a/modules/http/mod_mime.c b/modules/http/mod_mime.c
index 19ac207..01cb6c0 100644
--- a/modules/http/mod_mime.c
+++ b/modules/http/mod_mime.c
@@ -252,7 +252,7 @@ static void mime_post_config(ap_context_t *p, ap_context_t *plog, ap_context_t *
     types_confname = ap_server_root_relative(p, types_confname);
 
     if (!(f = ap_pcfg_openfile(p, types_confname))) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, s,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s,
 		     "could not open mime types log file %s.", types_confname);
         exit(1);
     }
diff --git a/modules/loggers/mod_log_config.c b/modules/loggers/mod_log_config.c
index ce20a8c..636645b 100644
--- a/modules/loggers/mod_log_config.c
+++ b/modules/loggers/mod_log_config.c
@@ -982,6 +982,8 @@ static config_log_state *open_config_log(server_rec *s, ap_context_t *p,
                                          config_log_state *cls,
                                          ap_array_header_t *default_format)
 {
+    ap_status_t status;
+
     if (cls->log_fd != NULL) {
         return cls;             /* virtual config shared w/main server */
     }
@@ -1001,8 +1003,9 @@ static config_log_state *open_config_log(server_rec *s, ap_context_t *p,
     }
     else {
         const char *fname = ap_server_root_relative(p, cls->fname);
-        if (ap_open(&cls->log_fd, fname, xfer_flags, xfer_mode, p) != APR_SUCCESS) {
-            ap_log_error(APLOG_MARK, APLOG_ERR, s,
+        if ((status = ap_open(&cls->log_fd, fname, xfer_flags, xfer_mode, p)) 
+            != APR_SUCCESS) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, status, s,
                          "could not open transfer log file %s.", fname);
             exit(1);
         }
diff --git a/modules/mappers/mod_actions.c b/modules/mappers/mod_actions.c
index c3b2dfb..2af51f7 100644
--- a/modules/mappers/mod_actions.c
+++ b/modules/mappers/mod_actions.c
@@ -188,7 +188,7 @@ static int action_handler(request_rec *r)
 		       action ? action : ap_default_type(r)))) {
 	script = t;
 	if (r->finfo.st_mode == 0) {
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 			"File does not exist: %s", r->filename);
 	    return NOT_FOUND;
 	}
diff --git a/modules/mappers/mod_imap.c b/modules/mappers/mod_imap.c
index 37d9705..361f3db 100644
--- a/modules/mappers/mod_imap.c
+++ b/modules/mappers/mod_imap.c
@@ -406,7 +406,7 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
     /* must be a relative URL to be combined with base */
     if (strchr(base, '/') == NULL && (!strncmp(value, "../", 3)
         || !strcmp(value, ".."))) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                     "invalid base directive in map file: %s", r->uri);
         return NULL;
     }
@@ -466,7 +466,7 @@ static char *imap_url(request_rec *r, const char *base, const char *value)
                                    value */
         }
         else if (directory) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                         "invalid directory name in map file: %s", r->uri);
             return NULL;
         }
@@ -869,7 +869,7 @@ static int imap_handler(request_rec *r)
                                                  we failed. They lose! */
 
 need_2_fields:
-    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 		"map file %s, line %d syntax error: requires at "
                 "least two fields", r->uri, imap->line_number);
     /* fall through */
diff --git a/modules/mappers/mod_negotiation.c b/modules/mappers/mod_negotiation.c
index 0da1fa0..d2fd832 100644
--- a/modules/mappers/mod_negotiation.c
+++ b/modules/mappers/mod_negotiation.c
@@ -751,7 +751,7 @@ static char *lcase_header_name_return_body(char *header, request_rec *r)
     }
 
     if (!*cp) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                       "Syntax error in type map --- no ':': %s", r->filename);
         return NULL;
     }
@@ -761,7 +761,7 @@ static char *lcase_header_name_return_body(char *header, request_rec *r)
     } while (*cp && ap_isspace(*cp));
 
     if (!*cp) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                       "Syntax error in type map --- no header body: %s",
                       r->filename);
         return NULL;
@@ -774,6 +774,7 @@ static int read_type_map(negotiation_state *neg, request_rec *rr)
 {
     request_rec *r = neg->r;
     ap_file_t *map;
+    ap_status_t status;
     char buffer[MAX_STRING_LEN];
     enum header_state hstate;
     struct var_rec mime_info;
@@ -782,9 +783,9 @@ static int read_type_map(negotiation_state *neg, request_rec *rr)
     /* We are not using multiviews */
     neg->count_multiviews_variants = 0;
 
-    if (ap_open(&map, rr->filename, APR_READ | APR_BUFFERED,
-                APR_OS_DEFAULT, neg->pool) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+    if ((status = ap_open(&map, rr->filename, APR_READ | APR_BUFFERED,
+                APR_OS_DEFAULT, neg->pool)) != APR_SUCCESS) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
                       "cannot access type map file: %s", rr->filename);
         return HTTP_FORBIDDEN;
     }
@@ -891,6 +892,7 @@ static int read_types_multi(negotiation_state *neg)
     char *filp;
     int prefix_len;
     ap_dir_t *dirp;
+    ap_status_t status;
     struct var_rec mime_info;
     struct accept_rec accept_info;
     void *new_var;
@@ -908,8 +910,8 @@ static int read_types_multi(negotiation_state *neg)
     ++filp;
     prefix_len = strlen(filp);
 
-    if (ap_opendir(&dirp, neg->dir_name, neg->pool) != APR_SUCCESS) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+    if ((status = ap_opendir(&dirp, neg->dir_name, neg->pool)) != APR_SUCCESS) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
                     "cannot read directory for multi: %s", neg->dir_name);
         return HTTP_FORBIDDEN;
     }
@@ -2480,7 +2482,7 @@ static int do_negotiation(request_rec *r, negotiation_state *neg,
         }
         
         if (!*bestp) {
-            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                           "no acceptable variant: %s", r->filename);
             return NOT_ACCEPTABLE;
         }
diff --git a/os/unix/unixd.c b/os/unix/unixd.c
index e9196dc..62b45c2 100644
--- a/os/unix/unixd.c
+++ b/os/unix/unixd.c
@@ -146,7 +146,7 @@ static int set_group_privs(void)
 	    uid_t uid = atoi(&unixd_config.user_name[1]);
 
 	    if ((ent = getpwuid(uid)) == NULL) {
-		ap_log_error(APLOG_MARK, APLOG_ALERT, NULL,
+		ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
 			 "getpwuid: couldn't determine user name from uid %u, "
 			 "you probably need to modify the User directive",
 			 (unsigned)uid);
@@ -166,7 +166,7 @@ static int set_group_privs(void)
 	 * setgid() is known to zap the group list.
 	 */
 	if (setgid(unixd_config.group_id) == -1) {
-	    ap_log_error(APLOG_MARK, APLOG_ALERT, NULL,
+	    ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
 			"setgid: unable to set group id to Group %u",
 			(unsigned)unixd_config.group_id);
 	    return -1;
@@ -175,7 +175,7 @@ static int set_group_privs(void)
 	/* Reset `groups' attributes. */
 
 	if (initgroups(name, unixd_config.group_id) == -1) {
-	    ap_log_error(APLOG_MARK, APLOG_ALERT, NULL,
+	    ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
 			"initgroups: unable to set groups for User %s "
 			"and Group %u", name, (unsigned)unixd_config.group_id);
 	    return -1;
@@ -197,7 +197,7 @@ int unixd_setup_child(void)
 	GETPRIVMODE();
 	if (setuid(unixd_config.user_id) == -1) {
 	    GETUSERMODE();
-	    ap_log_error(APLOG_MARK, APLOG_ALERT, NULL,
+	    ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
 			"setuid: unable to change to uid: %ld",
                         (long) unixd_config.user_id);
 	    exit(1);
@@ -211,7 +211,7 @@ int unixd_setup_child(void)
 	os_init_job_environment(server_conf, unixd_config.user_name, one_process) != 0 || 
 #endif
 	setuid(unixd_config.user_id) == -1)) {
-	ap_log_error(APLOG_MARK, APLOG_ALERT, NULL,
+	ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
 		    "setuid: unable to change to uid: %ld",
                     (long) unixd_config.user_id);
 	return -1;
diff --git a/server/config.c b/server/config.c
index 16a01d1..318cf8b 100644
--- a/server/config.c
+++ b/server/config.c
@@ -352,7 +352,7 @@ int ap_invoke_handler(request_rec *r)
     }
 
     if (result == HTTP_INTERNAL_SERVER_ERROR && r->handler && r->filename) {
-        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, r,
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
             "handler \"%s\" not found for: %s", r->handler, r->filename);
     }
     return HTTP_INTERNAL_SERVER_ERROR;
@@ -459,7 +459,7 @@ API_EXPORT(void) ap_remove_module(module *m)
 	}
 	if (!modp) {
 	    /* Uh-oh, this module doesn't exist */
-	    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, NULL,
+	    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, NULL,
 		"Cannot remove module %s: not found in module list",
 		m->name);
 	    return;
@@ -1103,7 +1103,7 @@ int ap_parse_htaccess(void **result, request_rec *r, int override,
             ap_cfg_closefile(f);
 
             if (errmsg) {
-                ap_log_rerror(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, r,
+                ap_log_rerror(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, 0, r,
                               "%s: %s", filename, errmsg);
                 return HTTP_INTERNAL_SERVER_ERROR;
             }
@@ -1111,7 +1111,7 @@ int ap_parse_htaccess(void **result, request_rec *r, int override,
             break;
         }
         else if (errno != ENOENT && errno != ENOTDIR) {
-            ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
+            ap_log_rerror(APLOG_MARK, APLOG_CRIT, errno, r,
                           "%s pcfg_openfile: unable to check htaccess file, "
                           "ensure it is readable",
                           filename);
diff --git a/server/listen.c b/server/listen.c
index b90e83f..991386c 100644
--- a/server/listen.c
+++ b/server/listen.c
@@ -78,7 +78,7 @@ static ap_status_t make_sock(ap_context_t *p, ap_listen_rec *server)
 
     stat = ap_setsocketopt(s, APR_SO_REUSEADDR, one);
     if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
-	ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
+	ap_log_error(APLOG_MARK, APLOG_CRIT, stat, NULL,
 		    "make_sock: for %s, setsockopt: (SO_REUSEADDR)", addr);
 	ap_close_socket(s);
 	return stat;
@@ -86,7 +86,7 @@ static ap_status_t make_sock(ap_context_t *p, ap_listen_rec *server)
     
     stat = ap_setsocketopt(s, APR_SO_KEEPALIVE, one);
     if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
-	ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
+	ap_log_error(APLOG_MARK, APLOG_CRIT, stat, NULL,
 		    "make_sock: for %s, setsockopt: (SO_KEEPALIVE)", addr);
 	ap_close_socket(s);
 	return stat;
@@ -114,7 +114,7 @@ static ap_status_t make_sock(ap_context_t *p, ap_listen_rec *server)
     if (send_buffer_size) {
 	stat = ap_setsocketopt(s, APR_SO_SNDBUF,  send_buffer_size);
         if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, stat, NULL,
 			"make_sock: failed to set SendBufferSize for %s, "
 			"using default", addr);
 	    /* not a fatal error */
@@ -122,14 +122,14 @@ static ap_status_t make_sock(ap_context_t *p, ap_listen_rec *server)
     }
 
     if ((stat = ap_bind(s)) != APR_SUCCESS) {
-	ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
+	ap_log_error(APLOG_MARK, APLOG_CRIT, stat, NULL,
 	    "make_sock: could not bind to %s", addr);
 	ap_close_socket(s);
 	return stat;
     }
 
     if ((stat = ap_listen(s, ap_listenbacklog)) != APR_SUCCESS) {
-	ap_log_error(APLOG_MARK, APLOG_ERR, NULL,
+	ap_log_error(APLOG_MARK, APLOG_ERR, stat, NULL,
 	    "make_sock: unable to listen for connections on %s", addr);
 	ap_close_socket(s);
 	return stat;
@@ -157,6 +157,7 @@ static void alloc_listener(process_rec *process, char *addr, unsigned int port)
 {
     ap_listen_rec **walk;
     ap_listen_rec *new;
+    ap_status_t status;
     char oldaddr[17];
     unsigned int oldport;
 
@@ -178,8 +179,8 @@ static void alloc_listener(process_rec *process, char *addr, unsigned int port)
     /* XXX - We need to deal with freeing this structure properly. */
     new = ap_palloc(process->pool, sizeof(ap_listen_rec));
     new->active = 0;
-    if (ap_create_tcp_socket(&new->sd, NULL) != APR_SUCCESS) {
-        ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
+    if ((status = ap_create_tcp_socket(&new->sd, NULL)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_CRIT, status, NULL,
                  "make_sock: failed to get a socket for %s", addr);
         return;
     }
diff --git a/server/log.c b/server/log.c
index a96ac03..2830a42 100644
--- a/server/log.c
+++ b/server/log.c
@@ -284,7 +284,7 @@ void ap_open_logs(server_rec *s_main, ap_context_t *p)
 	fflush(stderr);
         ap_get_os_file(&errfile, s_main->error_log);
 	if (dup2(errfile, STDERR_FILENO) == -1) {
-	    ap_log_error(APLOG_MARK, APLOG_CRIT, s_main,
+	    ap_log_error(APLOG_MARK, APLOG_CRIT, errno, s_main,
 		"unable to replace stderr with error_log");
 	} else {
 	    replace_stderr = 0;
@@ -295,7 +295,7 @@ void ap_open_logs(server_rec *s_main, ap_context_t *p)
      * of the submitter.
      */
     if (replace_stderr && freopen("/dev/null", "w", stderr) == NULL) {
-	ap_log_error(APLOG_MARK, APLOG_CRIT, s_main,
+	ap_log_error(APLOG_MARK, APLOG_CRIT, errno, s_main,
 	    "unable to replace stderr with /dev/null");
     }
 
@@ -324,14 +324,12 @@ API_EXPORT(void) ap_error_log2stderr(server_rec *s) {
         dup2(errfile, STDERR_FILENO);
 }
 
-static void log_error_core(const char *file, int line, int level,
-			   const server_rec *s, const request_rec *r,
-			   const char *fmt, va_list args)
+static void log_error_core(const char *file, int line, int level, 
+                           ap_status_t status, const server_rec *s, 
+                           const request_rec *r, const char *fmt, va_list args)
 {
     char errstr[MAX_STRING_LEN];
     size_t len;
-    /* change to AP errno funcs. */
-    int save_errno = errno;
     ap_file_t *logf = NULL;
     int errfileno = STDERR_FILENO;
 
@@ -421,14 +419,13 @@ static void log_error_core(const char *file, int line, int level,
 		"[client %s] ", r->connection->remote_ip);
     }
     if (!(level & APLOG_NOERRNO)
-	&& (save_errno != 0)
+	&& (status != 0)
 #ifdef WIN32
 	&& !(level & APLOG_WIN32ERROR)
 #endif
 	) {
-      /* ZZZ use AP funcs to set the errno and the error string. */
 	len += ap_snprintf(errstr + len, sizeof(errstr) - len,
-		"(%d)%s: ", save_errno, strerror(save_errno));
+		"(%d)%s: ", status, strerror(status));
     }
 #ifdef WIN32
     if (level & APLOG_WIN32ERROR) {
@@ -493,22 +490,24 @@ static void log_error_core(const char *file, int line, int level,
 }
     
 API_EXPORT(void) ap_log_error(const char *file, int line, int level,
-			      const server_rec *s, const char *fmt, ...)
+			      ap_status_t status, const server_rec *s, 
+                              const char *fmt, ...)
 {
     va_list args;
 
     va_start(args, fmt);
-    log_error_core(file, line, level, s, NULL, fmt, args);
+    log_error_core(file, line, level, status, s, NULL, fmt, args);
     va_end(args);
 }
 
 API_EXPORT(void) ap_log_rerror(const char *file, int line, int level,
-			       const request_rec *r, const char *fmt, ...)
+			       ap_status_t status, const request_rec *r, 
+                               const char *fmt, ...)
 {
     va_list args;
 
     va_start(args, fmt);
-    log_error_core(file, line, level, r->server, r, fmt, args);
+    log_error_core(file, line, level, status, r->server, r, fmt, args);
     /*
      * IF the error level is 'warning' or more severe,
      * AND there isn't already error text associated with this request,
@@ -547,7 +546,7 @@ void ap_log_pid(ap_context_t *p, const char *fname)
        *      that may screw up scripts written to do something
        *      based on the last modification time of the pid file.
        */
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
 		     ap_psprintf(p,
                                  "pid file %s overwritten -- Unclean shutdown of previous Apache run?",
                      fname)
@@ -567,13 +566,13 @@ void ap_log_pid(ap_context_t *p, const char *fname)
 
 API_EXPORT(void) ap_log_error_old(const char *err, server_rec *s)
 {
-    ap_log_error(APLOG_MARK, APLOG_ERR, s, "%s", err);
+    ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, "%s", err);
 }
 
 API_EXPORT(void) ap_log_unixerr(const char *routine, const char *file,
 			      const char *msg, server_rec *s)
 {
-    ap_log_error(file, 0, APLOG_ERR, s, "%s", msg);
+    ap_log_error(file, 0, APLOG_ERR, errno, s, "%s", msg);
 }
 
 API_EXPORT(void) ap_log_printf(const server_rec *s, const char *fmt, ...)
@@ -581,13 +580,13 @@ API_EXPORT(void) ap_log_printf(const server_rec *s, const char *fmt, ...)
     va_list args;
     
     va_start(args, fmt);
-    log_error_core(APLOG_MARK, APLOG_ERR, s, NULL, fmt, args);
+    log_error_core(APLOG_MARK, APLOG_ERR, errno, s, NULL, fmt, args);
     va_end(args);
 }
 
 API_EXPORT(void) ap_log_reason(const char *reason, const char *file, request_rec *r) 
 {
-    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+    ap_log_error(APLOG_MARK, APLOG_ERR, errno, r->server,
 		"access to %s failed for %s, reason: %s",
 		file,
 		ap_get_remote_host(r->connection, r->per_dir_config, REMOTE_NAME),
diff --git a/server/mpm/mpmt_pthread/mpmt_pthread.c b/server/mpm/mpmt_pthread/mpmt_pthread.c
index cffac05..a390c51 100644
--- a/server/mpm/mpmt_pthread/mpmt_pthread.c
+++ b/server/mpm/mpmt_pthread/mpmt_pthread.c
@@ -344,14 +344,14 @@ static void reclaim_child_processes(int terminate)
 	    case 7:     /* 1.4sec */
 		/* ok, now it's being annoying */
 		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING,
-			    server_conf,
+			    0, server_conf,
 		   "child process %d still did not exit, sending a SIGTERM",
 			    pid);
 		kill(pid, SIGTERM);
 		break;
 	    case 8:     /*  6 sec */
 		/* die child scum */
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, server_conf,
 		   "child process %d still did not exit, sending a SIGKILL",
 			    pid);
 		kill(pid, SIGKILL);
@@ -362,7 +362,7 @@ static void reclaim_child_processes(int terminate)
 		 * exited, we will likely fail to bind to the port
 		 * after the restart.
 		 */
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, server_conf,
 			    "could not make child process %d exit, "
 			    "attempting to continue anyway", pid);
 		break;
@@ -535,46 +535,46 @@ static void set_signals(void)
 	sa.sa_flags = SA_RESETHAND;
 #endif
 	if (sigaction(SIGSEGV, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGSEGV)");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGSEGV)");
 #ifdef SIGBUS
 	if (sigaction(SIGBUS, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGBUS)");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGBUS)");
 #endif
 #ifdef SIGABORT
 	if (sigaction(SIGABORT, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGABORT)");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGABORT)");
 #endif
 #ifdef SIGABRT
 	if (sigaction(SIGABRT, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGABRT)");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGABRT)");
 #endif
 #ifdef SIGILL
 	if (sigaction(SIGILL, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGILL)");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGILL)");
 #endif
 	sa.sa_flags = 0;
     }
     sa.sa_handler = sig_term;
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGTERM)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGTERM)");
 #ifdef SIGINT
     if (sigaction(SIGINT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGINT)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGINT)");
 #endif
 #ifdef SIGXCPU
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXCPU, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGXCPU)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGXCPU)");
 #endif
 #ifdef SIGXFSZ
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXFSZ, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGXFSZ)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGXFSZ)");
 #endif
 #ifdef SIGPIPE
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGPIPE, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGPIPE)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGPIPE)");
 #endif
 
     /* we want to ignore HUPs and WINCH while we're busy processing one */
@@ -582,9 +582,9 @@ static void set_signals(void)
     sigaddset(&sa.sa_mask, SIGWINCH);
     sa.sa_handler = restart;
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGHUP)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGHUP)");
     if (sigaction(SIGWINCH, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGWINCH)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGWINCH)");
 #else
     if (!one_process) {
 	signal(SIGSEGV, sig_coredump);
@@ -629,7 +629,7 @@ static void process_child_status(int pid, ap_wait_t status)
 	*/
     if ((WIFEXITED(status)) &&
 	WEXITSTATUS(status) == APEXIT_CHILDFATAL) {
-	ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, 0, server_conf,
 			"Child %d returned a Fatal error... \n"
 			"Apache is exiting!",
 			pid);
@@ -647,7 +647,7 @@ static void process_child_status(int pid, ap_wait_t status)
 #ifdef WCOREDUMP
 	    if (WCOREDUMP(status)) {
 		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
-			     server_conf,
+			     0, server_conf,
 			     "child pid %d exit signal %s (%d), "
 			     "possible coredump in %s",
 			     pid, (WTERMSIG(status) >= NumSIG) ? "" : 
@@ -657,7 +657,7 @@ static void process_child_status(int pid, ap_wait_t status)
 	    else {
 #endif
 		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
-			     server_conf,
+			     0, server_conf,
 			     "child pid %d exit signal %s (%d)", pid,
 			     SYS_SIGLIST[WTERMSIG(status)], WTERMSIG(status));
 #ifdef WCOREDUMP
@@ -706,7 +706,7 @@ static void sock_disable_nagle(int s) /* ZZZ abstract */
 
     if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char *) &just_say_no,
 		   sizeof(int)) < 0) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf,
 		    "setsockopt: (TCP_NODELAY)");
     }
 }
@@ -735,7 +735,7 @@ static void process_socket(ap_context_t *p, struct sockaddr *sa_client, int csd,
     long conn_id = my_child_num * HARD_THREAD_LIMIT + my_thread_num;
 
     if (getsockname(csd, &sa_server, &len) < 0) { 
-	ap_log_error(APLOG_MARK, APLOG_ERR, server_conf, "getsockname");
+	ap_log_error(APLOG_MARK, APLOG_ERR, errno, server_conf, "getsockname");
 	close(csd);
 	return;
     }
@@ -745,13 +745,13 @@ static void process_socket(ap_context_t *p, struct sockaddr *sa_client, int csd,
     iol = unix_attach_socket(csd);
     if (iol == NULL) {
         if (errno == EBADF) {
-            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
                 "filedescriptor (%u) larger than FD_SETSIZE (%u) "
                 "found, you probably need to rebuild Apache with a "
                 "larger FD_SETSIZE", csd, FD_SETSIZE);
         }
         else {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, NULL,
                 "error attaching to socket");
         }
         close(csd);
@@ -846,7 +846,7 @@ static void * worker_thread(void * dummy)
 
                 /* poll() will only return errors in catastrophic
                  * circumstances. Let's try exiting gracefully, for now. */
-                ap_log_error(APLOG_MARK, APLOG_ERR, (const server_rec *)
+                ap_log_error(APLOG_MARK, APLOG_ERR, errno, (const server_rec *)
                              ap_get_server_conf(), "poll: (listen)");
                 workers_may_exit = 1;
             }
@@ -948,7 +948,7 @@ static void child_main(int child_num_arg)
     sigfillset(&sig_mask);
 
     if (pthread_sigmask(SIG_SETMASK, &sig_mask, NULL) != 0) {
-        ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf, "pthread_sigmask");
+        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, server_conf, "pthread_sigmask");
     }
 
     requests_this_child = ap_max_requests_per_child;
@@ -972,7 +972,7 @@ static void child_main(int child_num_arg)
 
 	my_info = (proc_info *)malloc(sizeof(proc_info));
         if (my_info == NULL) {
-            ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, server_conf,
 		         "malloc: out of memory");
             clean_child_exit(APEXIT_CHILDFATAL);
         }
@@ -986,7 +986,7 @@ static void child_main(int child_num_arg)
 				      (request_rec *) NULL);
 #ifndef NO_THREADS
 	if (pthread_create(&thread, &thread_attr, worker_thread, my_info)) {
-	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+	    ap_log_error(APLOG_MARK, APLOG_ALERT, errno, server_conf,
 			 "pthread_create: unable to create worker thread");
             /* In case system resources are maxxed out, we don't want
                Apache running away with the CPU trying to fork over and
@@ -1018,7 +1018,7 @@ static void child_main(int child_num_arg)
             just_die(signal_received);
             break;
         default:
-            ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, server_conf,
             "received impossible signal: %d", signal_received);
             just_die(SIGTERM);
     }
@@ -1039,7 +1039,7 @@ static int make_child(server_rec *s, int slot, time_t now) /* ZZZ */
     }
 
     if ((pid = fork()) == -1) {
-        ap_log_error(APLOG_MARK, APLOG_ERR, s, "fork: Unable to fork new process");
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, "fork: Unable to fork new process");
 	/* In case system resources are maxxed out, we don't want
 	   Apache running away with the CPU trying to fork over and
 	   over and over again. */
@@ -1169,7 +1169,7 @@ static void perform_idle_server_maintenance(void)
         /* Kill off one child */
         char char_of_death = '!';
         if (write(pipe_of_death[1], &char_of_death, 1) == -1) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "write pipe_of_death");
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "write pipe_of_death");
         }
         idle_spawn_rate = 1;
     }
@@ -1180,7 +1180,7 @@ static void perform_idle_server_maintenance(void)
 	    static int reported = 0;
 	    
 	    if (!reported) {
-	        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+	        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, server_conf,
 			     "server reached MaxClients setting, consider"
 			     " raising the MaxClients setting");
 		reported = 1;
@@ -1191,7 +1191,7 @@ static void perform_idle_server_maintenance(void)
 	    /* ZZZZ */
 	    
 	    if (idle_spawn_rate >= 8) {
-	        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+	        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, server_conf,
 			     "server seems busy, (you may need "
 			     "to increase StartServers, ThreadsPerChild "
                              "or Min/MaxSparetThreads), "
@@ -1256,7 +1256,7 @@ static void server_main_loop(int remaining_children_to_start)
 		    * scoreboard.  Somehow we don't know about this
 		    * child.
 		    */
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, server_conf,
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, server_conf,
 			    "long lost child came home! (pid %d)", pid);
 	    }
 	    /* Don't perform idle maintenance when a child dies,
@@ -1291,7 +1291,7 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
     pconf = _pconf;
     server_conf = s;
     if (pipe(pipe_of_death) == -1) {
-        ap_log_error(APLOG_MARK, APLOG_ERR,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno,
                      (const server_rec*) server_conf,
                      "pipe: (pipe_of_death)");
         exit(1);
@@ -1304,7 +1304,7 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
 */
 
     if (fcntl(pipe_of_death[0], F_SETFD, O_NONBLOCK) == -1) {
-        ap_log_error(APLOG_MARK, APLOG_ERR,
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno,
                      (const server_rec*) server_conf,
                      "fcntl: O_NONBLOCKing (pipe_of_death)");
         exit(1);
@@ -1312,7 +1312,7 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
     server_conf = s;
     if ((num_listensocks = setup_listeners(server_conf)) < 1) {
         /* XXX: hey, what's the right way for the mpm to indicate a fatal error? */
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ALERT, s,
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ALERT, 0, s,
             "no listening sockets available, shutting down");
         return 1;
     }
@@ -1349,10 +1349,10 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
 	hold_off_on_exponential_spawning = 10;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, server_conf,
 		"%s configured -- resuming normal operations",
 		ap_get_server_version());
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, server_conf,
 		"Server built: %s", ap_get_server_built());
     restart_pending = shutdown_pending = 0;
 
@@ -1363,7 +1363,7 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
          * Kill child processes, tell them to call child_exit, etc...
          */
         if (ap_killpg(getpgrp(), SIGTERM) < 0) {
-            ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGTERM");
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "killpg SIGTERM");
         }
         reclaim_child_processes(1);		/* Start with SIGTERM */
     
@@ -1372,13 +1372,13 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
             const char *pidfile = NULL;
             pidfile = ap_server_root_relative (pconf, ap_pid_fname);
             if ( pidfile != NULL && unlink(pidfile) == 0)
-                ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
+                ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0,
             		 server_conf,
             		 "removed PID file %s (pid=%ld)",
             		 pidfile, (long)getpid());
         }
     
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, server_conf,
             "caught SIGTERM, shutting down");
     
 	return 1;
@@ -1404,14 +1404,14 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
 	int i, j;
         char char_of_death = '!';
 
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, server_conf,
 		    "SIGWINCH received.  Doing graceful restart");
 
 	/* give the children the signal to die */
         for (i = 0; i < ap_daemons_limit;) {
             if (write(pipe_of_death[1], &char_of_death, 1) == -1) {
                 if (errno == EINTR) continue;
-                ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "write pipe_of_death");
+                ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "write pipe_of_death");
             }
             i++;
         }
@@ -1434,10 +1434,10 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
        * pthreads are stealing signals from us left and right.
        */
 	if (ap_killpg(getpgrp(), SIGTERM) < 0) {
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGTERM");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "killpg SIGTERM");
 	}
         reclaim_child_processes(1);		/* Start with SIGTERM */
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, server_conf,
 		    "SIGHUP received.  Attempting to restart");
     }
     if (!is_graceful) {
diff --git a/server/mpm/mpmt_pthread/scoreboard.c b/server/mpm/mpmt_pthread/scoreboard.c
index 5b2b4bb..2f8b34d 100644
--- a/server/mpm/mpmt_pthread/scoreboard.c
+++ b/server/mpm/mpmt_pthread/scoreboard.c
@@ -321,18 +321,18 @@ static void setup_shared_mem(ap_context_t *p)
     if ((shmid = shmget(shmkey, SCOREBOARD_SIZE, IPC_CREAT | SHM_R | SHM_W)) == -1) {
 #ifdef LINUX
 	if (errno == ENOSYS) {
-	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, 0, server_conf,
 			 "Your kernel was built without CONFIG_SYSVIPC\n"
 			 "%s: Please consult the Apache FAQ for details",
 			 ap_server_argv0);
 	}
 #endif
-	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_EMERG, errno, server_conf,
 		    "could not call shmget");
 	exit(APEXIT_INIT);
     }
 
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, server_conf,
 		"created shared memory segment #%d", shmid);
 
 #ifdef MOVEBREAK
@@ -353,21 +353,21 @@ static void setup_shared_mem(ap_context_t *p)
 
 #define BADSHMAT	((scoreboard *)(-1))
     if ((ap_scoreboard_image = (scoreboard *) shmat(shmid, 0, 0)) == BADSHMAT) {
-	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf, "shmat error");
+	ap_log_error(APLOG_MARK, APLOG_EMERG, errno, server_conf, "shmat error");
 	/*
 	 * We exit below, after we try to remove the segment
 	 */
     }
     else {			/* only worry about permissions if we attached the segment */
 	if (shmctl(shmid, IPC_STAT, &shmbuf) != 0) {
-	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+	    ap_log_error(APLOG_MARK, APLOG_ERR, errno, server_conf,
 		"shmctl() could not stat segment #%d", shmid);
 	}
 	else {
 	    shmbuf.shm_perm.uid = unixd_config.user_id;
 	    shmbuf.shm_perm.gid = unixd_config.group_id;
 	    if (shmctl(shmid, IPC_SET, &shmbuf) != 0) {
-		ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+		ap_log_error(APLOG_MARK, APLOG_ERR, errno, server_conf,
 		    "shmctl() could not set segment #%d", shmid);
 	    }
 	}
@@ -377,7 +377,7 @@ static void setup_shared_mem(ap_context_t *p)
      * (small) tables.
      */
     if (shmctl(shmid, IPC_RMID, NULL) != 0) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf,
 		"shmctl: IPC_RMID: could not remove shared memory segment #%d",
 		shmid);
     }
diff --git a/server/mpm/prefork/prefork.c b/server/mpm/prefork/prefork.c
index 3173a15..bbe3330 100644
--- a/server/mpm/prefork/prefork.c
+++ b/server/mpm/prefork/prefork.c
@@ -561,7 +561,7 @@ static void accept_mutex_on(void)
     }
 
     if (ret < 0) {
-	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_EMERG, errno, server_conf,
 		    "fcntl: F_SETLKW: Error getting accept lock, exiting!  "
 		    "Perhaps you need to use the LockFile directive to place "
 		    "your lock file on a local disk!");
@@ -577,7 +577,7 @@ static void accept_mutex_off(void)
 	/* nop */
     }
     if (ret < 0) {
-	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_EMERG, errno, server_conf,
 		    "fcntl: F_SETLKW: Error freeing accept lock, exiting!  "
 		    "Perhaps you need to use the LockFile directive to place "
 		    "your lock file on a local disk!");
@@ -1152,18 +1152,18 @@ static void setup_shared_mem(ap_context_t *p)
     if ((shmid = shmget(shmkey, SCOREBOARD_SIZE, IPC_CREAT | SHM_R | SHM_W)) == -1) {
 #ifdef LINUX
 	if (errno == ENOSYS) {
-	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, 0, server_conf,
 			 "Your kernel was built without CONFIG_SYSVIPC\n"
 			 "%s: Please consult the Apache FAQ for details",
 			 ap_server_argv0);
 	}
 #endif
-	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_EMERG, errno, server_conf,
 		    "could not call shmget");
 	exit(APEXIT_INIT);
     }
 
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, server_conf,
 		"created shared memory segment #%d", shmid);
 
 #ifdef MOVEBREAK
@@ -1184,21 +1184,21 @@ static void setup_shared_mem(ap_context_t *p)
 
 #define BADSHMAT	((scoreboard *)(-1))
     if ((ap_scoreboard_image = (scoreboard *) shmat(shmid, 0, 0)) == BADSHMAT) {
-	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf, "shmat error");
+	ap_log_error(APLOG_MARK, APLOG_EMERG, errno, server_conf, "shmat error");
 	/*
 	 * We exit below, after we try to remove the segment
 	 */
     }
     else {			/* only worry about permissions if we attached the segment */
 	if (shmctl(shmid, IPC_STAT, &shmbuf) != 0) {
-	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+	    ap_log_error(APLOG_MARK, APLOG_ERR, errno, server_conf,
 		"shmctl() could not stat segment #%d", shmid);
 	}
 	else {
 	    shmbuf.shm_perm.uid = unixd_config.user_id;
 	    shmbuf.shm_perm.gid = unixd_config.group_id;
 	    if (shmctl(shmid, IPC_SET, &shmbuf) != 0) {
-		ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+		ap_log_error(APLOG_MARK, APLOG_ERR, errno, server_conf,
 		    "shmctl() could not set segment #%d", shmid);
 	    }
 	}
@@ -1208,7 +1208,7 @@ static void setup_shared_mem(ap_context_t *p)
      * (small) tables.
      */
     if (shmctl(shmid, IPC_RMID, NULL) != 0) {
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf,
 		"shmctl: IPC_RMID: could not remove shared memory segment #%d",
 		shmid);
     }
@@ -1583,7 +1583,7 @@ static void reclaim_child_processes(int terminate)
 	    case 3:     /* 344ms */
 		/* perhaps it missed the SIGHUP, lets try again */
 		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING,
-			    server_conf,
+			    0, server_conf,
 		    "child process %d did not exit, sending another SIGHUP",
 			    pid);
 		kill(pid, SIGHUP);
@@ -1596,14 +1596,14 @@ static void reclaim_child_processes(int terminate)
 	    case 7:     /* 1.4sec */
 		/* ok, now it's being annoying */
 		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING,
-			    server_conf,
+			    0, server_conf,
 		   "child process %d still did not exit, sending a SIGTERM",
 			    pid);
 		kill(pid, SIGTERM);
 		break;
 	    case 8:     /*  6 sec */
 		/* die child scum */
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, server_conf,
 		   "child process %d still did not exit, sending a SIGKILL",
 			    pid);
 		kill(pid, SIGKILL);
@@ -1614,7 +1614,7 @@ static void reclaim_child_processes(int terminate)
 		 * exited, we will likely fail to bind to the port
 		 * after the restart.
 		 */
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, server_conf,
 			    "could not make child process %d exit, "
 			    "attempting to continue anyway", pid);
 		break;
@@ -1793,46 +1793,46 @@ static void set_signals(void)
 	sa.sa_flags = SA_RESETHAND;
 #endif
 	if (sigaction(SIGSEGV, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGSEGV)");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGSEGV)");
 #ifdef SIGBUS
 	if (sigaction(SIGBUS, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGBUS)");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGBUS)");
 #endif
 #ifdef SIGABORT
 	if (sigaction(SIGABORT, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGABORT)");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGABORT)");
 #endif
 #ifdef SIGABRT
 	if (sigaction(SIGABRT, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGABRT)");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGABRT)");
 #endif
 #ifdef SIGILL
 	if (sigaction(SIGILL, &sa, NULL) < 0)
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGILL)");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGILL)");
 #endif
 	sa.sa_flags = 0;
     }
     sa.sa_handler = sig_term;
     if (sigaction(SIGTERM, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGTERM)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGTERM)");
 #ifdef SIGINT
     if (sigaction(SIGINT, &sa, NULL) < 0)
-        ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGINT)");
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGINT)");
 #endif
 #ifdef SIGXCPU
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXCPU, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGXCPU)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGXCPU)");
 #endif
 #ifdef SIGXFSZ
     sa.sa_handler = SIG_DFL;
     if (sigaction(SIGXFSZ, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGXFSZ)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGXFSZ)");
 #endif
 #ifdef SIGPIPE
     sa.sa_handler = SIG_IGN;
     if (sigaction(SIGPIPE, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGPIPE)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGPIPE)");
 #endif
 
     /* we want to ignore HUPs and USR1 while we're busy processing one */
@@ -1840,9 +1840,9 @@ static void set_signals(void)
     sigaddset(&sa.sa_mask, SIGUSR1);
     sa.sa_handler = restart;
     if (sigaction(SIGHUP, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGHUP)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGHUP)");
     if (sigaction(SIGUSR1, &sa, NULL) < 0)
-	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGUSR1)");
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "sigaction(SIGUSR1)");
 #else
     if (!one_process) {
 	signal(SIGSEGV, sig_coredump);
@@ -2027,7 +2027,7 @@ static void child_main(int child_num_arg)
 		     * on Linux 2.0.x we seem to end up with EFAULT
 		     * occasionally, and we'd loop forever due to it.
 		     */
-		    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf, "select: (listen)");
+		    ap_log_error(APLOG_MARK, APLOG_ERR, errno, server_conf, "select: (listen)");
 		    clean_child_exit(1);
 		}
 
@@ -2156,24 +2156,24 @@ static void child_main(int child_num_arg)
 		      * Ben Hyde noted that temporary ENETDOWN situations
 		      * occur in mobile IP.
 		      */
-		    ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+		    ap_log_error(APLOG_MARK, APLOG_EMERG, errno, server_conf,
 			"accept: giving up.");
 		    clean_child_exit(APEXIT_CHILDFATAL);
 #endif /*ENETDOWN*/
 
 #ifdef TPF
 		case EINACT:
-		    ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+		    ap_log_error(APLOG_MARK, APLOG_EMERG, errno, server_conf,
 			"offload device inactive");
 		    clean_child_exit(APEXIT_CHILDFATAL);
 		    break;
 		default:
-		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, server_conf,
 			"select/accept error (%u)", errno);
 		    clean_child_exit(APEXIT_CHILDFATAL);
 #else
 		default:
-		    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+		    ap_log_error(APLOG_MARK, APLOG_ERR, errno, server_conf,
 				"accept: (client socket)");
 		    clean_child_exit(1);
 #endif
@@ -2209,7 +2209,7 @@ static void child_main(int child_num_arg)
 
 	clen = sizeof(sa_server);
 	if (getsockname(sockdes, &sa_server, &clen) < 0) {
-	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf, "getsockname");
+	    ap_log_error(APLOG_MARK, APLOG_ERR, errno, server_conf, "getsockname");
 	    ap_close_socket(csd);
 	    continue;
 	}
@@ -2219,13 +2219,13 @@ static void child_main(int child_num_arg)
 	iol = unix_attach_socket(sockdes);
 	if (iol == NULL) {
 	    if (errno == EBADF) {
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
 		    "filedescriptor (%u) larger than FD_SETSIZE (%u) "
 		    "found, you probably need to rebuild Apache with a "
 		    "larger FD_SETSIZE", sockdes, FD_SETSIZE);
 	    }
 	    else {
-		ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
+		ap_log_error(APLOG_MARK, APLOG_WARNING, errno, NULL,
 		    "error attaching to socket");
 	    }
 	    ap_close_socket(csd);
@@ -2278,7 +2278,7 @@ static int make_child(server_rec *s, int slot, time_t now)
 #else
     if ((pid = fork()) == -1) {
 #endif
-	ap_log_error(APLOG_MARK, APLOG_ERR, s, "fork: Unable to fork new process");
+	ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, "fork: Unable to fork new process");
 
 	/* fork didn't succeed. Fix the scoreboard or else
 	 * it will say SERVER_STARTING forever and ever
@@ -2431,7 +2431,7 @@ static void perform_idle_server_maintenance(void)
 	    static int reported = 0;
 
 	    if (!reported) {
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, server_conf,
 			    "server reached MaxClients setting, consider"
 			    " raising the MaxClients setting");
 		reported = 1;
@@ -2440,7 +2440,7 @@ static void perform_idle_server_maintenance(void)
 	}
 	else {
 	    if (idle_spawn_rate >= 8) {
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, server_conf,
 		    "server seems busy, (you may need "
 		    "to increase StartServers, or Min/MaxSpareServers), "
 		    "spawning %d children, there are %d idle, and "
@@ -2484,7 +2484,7 @@ static void process_child_status(int pid, ap_wait_t status)
 	*/
     if ((WIFEXITED(status)) &&
 	WEXITSTATUS(status) == APEXIT_CHILDFATAL) {
-	ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, 0, server_conf,
 			"Child %d returned a Fatal error... \n"
 			"Apache is exiting!",
 			pid);
@@ -2502,7 +2502,7 @@ static void process_child_status(int pid, ap_wait_t status)
 #ifdef WCOREDUMP
 	    if (WCOREDUMP(status)) {
 		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
-			     server_conf,
+			     0, server_conf,
 			     "child pid %d exit signal %s (%d), "
 			     "possible coredump in %s",
 			     pid, (WTERMSIG(status) >= NumSIG) ? "" : 
@@ -2512,7 +2512,7 @@ static void process_child_status(int pid, ap_wait_t status)
 	    else {
 #endif
 		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
-			     server_conf,
+			     0, server_conf,
 			     "child pid %d exit signal %s (%d)", pid,
 			     SYS_SIGLIST[WTERMSIG(status)], WTERMSIG(status));
 #ifdef WCOREDUMP
@@ -2535,7 +2535,7 @@ static int setup_listeners(server_rec *s)
     int sockdes;
 
     if (ap_listen_open(s->process, s->port)) {
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ALERT, s,
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ALERT, 0, s,
 		    "no listening sockets available, shutting down");
 	return -1;
     }
@@ -2610,10 +2610,10 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
 	hold_off_on_exponential_spawning = 10;
     }
 
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, server_conf,
 		"%s configured -- resuming normal operations",
 		ap_get_server_version());
-    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, 0, server_conf,
 		"Server built: %s", ap_get_server_built());
     restart_pending = shutdown_pending = 0;
 
@@ -2653,7 +2653,8 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
 		    * scoreboard.  Somehow we don't know about this
 		    * child.
 		    */
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, server_conf,
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 
+                            0, server_conf,
 			    "long lost child came home! (pid %d)", pid);
 	    }
 	    /* Don't perform idle maintenance when a child dies,
@@ -2690,7 +2691,7 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
 	 * Kill child processes, tell them to call child_exit, etc...
 	 */
 	if (ap_killpg(getpgrp(), SIGTERM) < 0) {
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGTERM");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "killpg SIGTERM");
 	}
 	reclaim_child_processes(1);		/* Start with SIGTERM */
 
@@ -2700,12 +2701,12 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
 	    pidfile = ap_server_root_relative (pconf, ap_pid_fname);
 	    if ( pidfile != NULL && unlink(pidfile) == 0)
 		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
-				server_conf,
+				0, server_conf,
 				"removed PID file %s (pid=%ld)",
 				pidfile, (long)getpid());
 	}
 
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, server_conf,
 		    "caught SIGTERM, shutting down");
 	return 1;
     }
@@ -2731,12 +2732,12 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
 #ifndef SCOREBOARD_FILE
 	int i;
 #endif
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, server_conf,
 		    "SIGUSR1 received.  Doing graceful restart");
 
 	/* kill off the idle ones */
 	if (ap_killpg(getpgrp(), SIGUSR1) < 0) {
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGUSR1");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "killpg SIGUSR1");
 	}
 #ifndef SCOREBOARD_FILE
 	/* This is mostly for debugging... so that we know what is still
@@ -2755,10 +2756,10 @@ int ap_mpm_run(ap_context_t *_pconf, ap_context_t *plog, server_rec *s)
     else {
 	/* Kill 'em off */
 	if (ap_killpg(getpgrp(), SIGHUP) < 0) {
-	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGHUP");
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, server_conf, "killpg SIGHUP");
 	}
 	reclaim_child_processes(0);		/* Not when just starting up */
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, server_conf,
 		    "SIGHUP received.  Attempting to restart");
     }
 
diff --git a/server/rfc1413.c b/server/rfc1413.c
index ac70921..3a9197b 100644
--- a/server/rfc1413.c
+++ b/server/rfc1413.c
@@ -109,6 +109,7 @@ static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
 {
     unsigned int rmt_port, our_port;
     unsigned int sav_rmt_port, sav_our_port;
+    ap_status_t status;
     int i;
     char *cp;
     char buffer[RFC1413_MAXDATA + 1];
@@ -126,8 +127,8 @@ static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
     ap_setport(sock, ANY_PORT);
     ap_setipaddr(sock, local_ip); 
 
-    if (ap_bind(sock) != APR_SUCCESS) {
-	ap_log_error(APLOG_MARK, APLOG_CRIT, srv,
+    if ((status = ap_bind(sock)) != APR_SUCCESS) {
+	ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv,
 		    "bind: rfc1413: Error binding to local port");
 	return -1;
     }
@@ -155,12 +156,12 @@ static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
     i = 0;
     while(i < strlen(buffer)) {
         int j = strlen(buffer + i);
-        ap_status_t stat;
-	stat  = ap_send(sock, buffer+i, &j);
-	if (stat != APR_SUCCESS && stat != APR_EINTR) {
-	  ap_log_error(APLOG_MARK, APLOG_CRIT, srv,
-		       "write: rfc1413: error sending request");
-	  return -1;
+        ap_status_t status;
+	status  = ap_send(sock, buffer+i, &j);
+	if (status != APR_SUCCESS && status != APR_EINTR) {
+	    ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv,
+		         "write: rfc1413: error sending request");
+	    return -1;
 	}
 	else if (j > 0) {
 	    i+=j; 
@@ -181,12 +182,12 @@ static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
      */
     while((cp = strchr(buffer, '\012')) == NULL && i < sizeof(buffer) - 1) {
         int j = sizeof(buffer) - 1 - i;
-        ap_status_t stat;
-	stat = ap_recv(sock, buffer+i, &j);
-	if (stat != APR_SUCCESS && stat != APR_EINTR) {
-	   ap_log_error(APLOG_MARK, APLOG_CRIT, srv,
+        ap_status_t status;
+	status = ap_recv(sock, buffer+i, &j);
+	if (status != APR_SUCCESS && status != APR_EINTR) {
+	    ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv,
 			"read: rfc1413: error reading response");
-	   return -1;
+	    return -1;
 	}
 	else if (j > 0) {
 	    i+=j; 
@@ -216,14 +217,15 @@ static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
 /* rfc1413 - return remote user name, given socket structures */
 char *ap_rfc1413(conn_rec *conn, server_rec *srv)
 {
+    ap_status_t status;
     static char user[RFC1413_USERLEN + 1];	/* XXX */
     static char *result;
     static ap_socket_t *sock;
 
     result = FROM_UNKNOWN;
 
-    if (ap_create_tcp_socket(&sock, conn->pool) != APR_SUCCESS) {
-	ap_log_error(APLOG_MARK, APLOG_CRIT, srv,
+    if ((status = ap_create_tcp_socket(&sock, conn->pool)) != APR_SUCCESS) {
+	ap_log_error(APLOG_MARK, APLOG_CRIT, status, srv,
 		    "socket: rfc1413: error creating socket");
 	conn->remote_logname = result;
     }
diff --git a/server/util.c b/server/util.c
index a71097a..d45246e 100644
--- a/server/util.c
+++ b/server/util.c
@@ -864,13 +864,13 @@ API_EXPORT(configfile_t *) ap_pcfg_openfile(ap_context_t *p, const char *name)
     ap_filetype_e type;
 
     if (name == NULL) {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, NULL,
                "Internal error: pcfg_openfile() called with NULL filename");
         return NULL;
     }
 
     if (!ap_os_is_filename_valid(name)) {
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, NULL,
                     "Access to config file %s denied: not a valid filename",
                     name);
 	errno = EACCES;
@@ -898,7 +898,7 @@ API_EXPORT(configfile_t *) ap_pcfg_openfile(ap_context_t *p, const char *name)
         strcmp(name, "/dev/null") != 0) {
 #endif /* WIN32 || OS2 */
 	saved_errno = errno;
-        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, NULL,
+        ap_log_error(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, NULL,
                     "Access to file %s denied by server: not a regular file",
                     name);
         ap_close(file);
diff --git a/server/util_script.c b/server/util_script.c
index 1339dac..08bf8dc 100644
--- a/server/util_script.c
+++ b/server/util_script.c
@@ -460,7 +460,7 @@ API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
     while (1) {
 
 	if ((*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data) == 0) {
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 			  "Premature end of script headers: %s", r->filename);
 	    return HTTP_INTERNAL_SERVER_ERROR;
 	}
@@ -543,7 +543,7 @@ API_EXPORT(int) ap_scan_script_header_err_core(request_rec *r, char *buffer,
 		}
 	    }
 
-	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
 			  "%s: %s", malformed, r->filename);
 	    return HTTP_INTERNAL_SERVER_ERROR;
 	}
diff --git a/server/vhost.c b/server/vhost.c
index f241e85..31f777e 100644
--- a/server/vhost.c
+++ b/server/vhost.c
@@ -221,7 +221,7 @@ static const char *get_addresses(ap_context_t *p, char *w, server_addr_rec ***pa
     hep = gethostbyname(w);
 
     if ((!hep) || (hep->h_addrtype != AF_INET || !hep->h_addr_list[0])) {
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, NULL,
 	    "Cannot resolve host name %s --- ignoring!", w);
 	if (t != NULL)
 	    *t = ':';
@@ -534,7 +534,7 @@ void ap_fini_vhost_config(ap_context_t *p, server_rec *main_s)
 
 		other = find_default_server(sar->host_port);
 		if (other && other->sar->host_port != 0) {
-		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, main_s,
+		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, main_s,
 			    "_default_ VirtualHost overlap on port %u,"
 			    " the first has precedence", sar->host_port);
 		}
@@ -558,7 +558,7 @@ void ap_fini_vhost_config(ap_context_t *p, server_rec *main_s)
 		    ic->server = s;
 		    if (sar->host_port != ic->sar->host_port) {
 			/* one of the two is a * port, the other isn't */
-			ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, main_s,
+			ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, main_s,
 				"VirtualHost %s:%u -- mixing * "
 				"ports and non-* ports with "
 				"a NameVirtualHost address is not supported,"
@@ -567,7 +567,7 @@ void ap_fini_vhost_config(ap_context_t *p, server_rec *main_s)
 		    }
 		}
 		else if (ic) {
-		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, main_s,
+		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, main_s,
 			    "VirtualHost %s:%u overlaps with "
 			    "VirtualHost %s:%u, the first has precedence, "
 			    "perhaps you need a NameVirtualHost directive",
@@ -612,7 +612,7 @@ void ap_fini_vhost_config(ap_context_t *p, server_rec *main_s)
 		else {
 		    /* again, what can we do?  They didn't specify a
 		       ServerName, and their DNS isn't working. -djg */
-		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, main_s,
+		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, main_s,
 			    "Failed to resolve server name "
 			    "for %s (check DNS) -- or specify an explicit "
 			    "ServerName",
@@ -634,7 +634,7 @@ void ap_fini_vhost_config(ap_context_t *p, server_rec *main_s)
 	    ipaddr_chain *ic = *pic;
 
 	    if (ic->server == NULL) {
-		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, main_s,
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, main_s,
 			"NameVirtualHost %s:%u has no VirtualHosts",
 			ic->sar->virthost, ic->sar->host_port);
 		*pic = ic->next;
diff --git a/support/htdigest.c b/support/htdigest.c
index eb28188..22d0f44 100644
--- a/support/htdigest.c
+++ b/support/htdigest.c
@@ -66,6 +66,7 @@
  * by Alexei Kosut, based on htpasswd.c, by Rob McCool
  */
 
+#include "apr_lib.h"
 #include "ap_config.h"
 #include <sys/types.h>
 #include "ap.h"
@@ -145,12 +146,15 @@ static void add_password(char *user, char *realm, FILE *f)
     char pwin[MAX_STRING_LEN];
     char pwv[MAX_STRING_LEN];
     unsigned int i;
+    size_t bufsize;
 
-    if (ap_getpass("New password: ", pwin, sizeof(pwin)) != 0) {
+    bufsize = sizeof(pwin);
+    if (ap_getpass("New password: ", pwin, &bufsize) != 0) {
 	fprintf(stderr, "password too long");
 	exit(5);
     }
-    ap_getpass("Re-type new password: ", pwv, sizeof(pwv));
+    bufsize = sizeof(pwv);
+    ap_getpass("Re-type new password: ", pwv, &bufsize);
     if (strcmp(pwin, pwv) != 0) {
 	fprintf(stderr, "They don't match, sorry.\n");
 	if (tn) {
diff --git a/support/htpasswd.c b/support/htpasswd.c
index e65daba..295520f 100644
--- a/support/htpasswd.c
+++ b/support/htpasswd.c
@@ -78,6 +78,7 @@
  *  6: Failure; username contains illegal or reserved characters
  */
 
+#include "apr_lib.h"
 #include "ap_config.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -176,17 +177,20 @@ static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
     char pwin[MAX_STRING_LEN];
     char pwv[MAX_STRING_LEN];
     char salt[9];
+    size_t bufsize;
 
     if (passwd != NULL) {
 	pw = passwd;
     }
     else {
-	if (ap_getpass("New password: ", pwin, sizeof(pwin)) != 0) {
+        bufsize = sizeof(pwin);
+	if (ap_getpass("New password: ", pwin, &bufsize) != 0) {
 	    ap_snprintf(record, (rlen - 1), "password too long (>%d)",
 			sizeof(pwin) - 1);
 	    return ERR_OVERFLOW;
 	}
-	ap_getpass("Re-type new password: ", pwv, sizeof(pwv));
+        bufsize = sizeof(pwv);
+	ap_getpass("Re-type new password: ", pwv, &bufsize);
 	if (strcmp(pwin, pwv) != 0) {
 	    ap_cpystrn(record, "password verification error", (rlen - 1));
 	    return ERR_PWMISMATCH;
